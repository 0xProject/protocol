{
    "schemaVersion": "2.0.0",
    "contractName": "TestRfqOriginRegistration",
    "compilerOutput": {
        "abi": [
            {
                "inputs": [
                    {
                        "internalType": "contract INativeOrdersFeature",
                        "name": "feature",
                        "type": "address"
                    },
                    {
                        "internalType": "address[]",
                        "name": "origins",
                        "type": "address[]"
                    },
                    {
                        "internalType": "bool",
                        "name": "allowed",
                        "type": "bool"
                    }
                ],
                "name": "registerAllowedRfqOrigins",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ],
        "devdoc": {
            "kind": "dev",
            "methods": {},
            "version": 1
        },
        "evm": {
            "bytecode": {
                "linkReferences": {},
                "object": "0x608060405234801561001057600080fd5b506102b7806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063564fc11914610030575b600080fd5b61004361003e3660046100f1565b610045565b005b6040517fb09f1fb100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84169063b09f1fb19061009990859085906004016101b4565b600060405180830381600087803b1580156100b357600080fd5b505af11580156100c7573d6000803e3d6000fd5b50505050505050565b80356100db8161025c565b92915050565b803580151581146100db57600080fd5b600080600060608486031215610105578283fd5b83356101108161025c565b925060208481013567ffffffffffffffff81111561012c578384fd5b8501601f8101871361013c578384fd5b803561014f61014a8261023c565b610215565b81815283810190838501858402850186018b101561016b578788fd5b8794505b83851015610195576101818b826100d0565b83526001949094019391850191850161016f565b5080965050505050506101ab85604086016100e1565b90509250925092565b604080825283519082018190526000906020906060840190828701845b8281101561020357815173ffffffffffffffffffffffffffffffffffffffff16845292840192908401906001016101d1565b50505093151592019190915250919050565b60405181810167ffffffffffffffff8111828210171561023457600080fd5b604052919050565b600067ffffffffffffffff821115610252578081fd5b5060209081020190565b73ffffffffffffffffffffffffffffffffffffffff8116811461027e57600080fd5b5056fea264697066735822122021e981b600353ba30537a17d07058622a0c9daae23ccb1adc08ec9a44807189a64736f6c634300060c0033",
                "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x2B7 DUP1 PUSH2 0x20 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x2B JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x564FC119 EQ PUSH2 0x30 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x43 PUSH2 0x3E CALLDATASIZE PUSH1 0x4 PUSH2 0xF1 JUMP JUMPDEST PUSH2 0x45 JUMP JUMPDEST STOP JUMPDEST PUSH1 0x40 MLOAD PUSH32 0xB09F1FB100000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP5 AND SWAP1 PUSH4 0xB09F1FB1 SWAP1 PUSH2 0x99 SWAP1 DUP6 SWAP1 DUP6 SWAP1 PUSH1 0x4 ADD PUSH2 0x1B4 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0xB3 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0xC7 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP POP POP POP JUMP JUMPDEST DUP1 CALLDATALOAD PUSH2 0xDB DUP2 PUSH2 0x25C JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST DUP1 CALLDATALOAD DUP1 ISZERO ISZERO DUP2 EQ PUSH2 0xDB JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x60 DUP5 DUP7 SUB SLT ISZERO PUSH2 0x105 JUMPI DUP3 DUP4 REVERT JUMPDEST DUP4 CALLDATALOAD PUSH2 0x110 DUP2 PUSH2 0x25C JUMP JUMPDEST SWAP3 POP PUSH1 0x20 DUP5 DUP2 ADD CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT ISZERO PUSH2 0x12C JUMPI DUP4 DUP5 REVERT JUMPDEST DUP6 ADD PUSH1 0x1F DUP2 ADD DUP8 SGT PUSH2 0x13C JUMPI DUP4 DUP5 REVERT JUMPDEST DUP1 CALLDATALOAD PUSH2 0x14F PUSH2 0x14A DUP3 PUSH2 0x23C JUMP JUMPDEST PUSH2 0x215 JUMP JUMPDEST DUP2 DUP2 MSTORE DUP4 DUP2 ADD SWAP1 DUP4 DUP6 ADD DUP6 DUP5 MUL DUP6 ADD DUP7 ADD DUP12 LT ISZERO PUSH2 0x16B JUMPI DUP8 DUP9 REVERT JUMPDEST DUP8 SWAP5 POP JUMPDEST DUP4 DUP6 LT ISZERO PUSH2 0x195 JUMPI PUSH2 0x181 DUP12 DUP3 PUSH2 0xD0 JUMP JUMPDEST DUP4 MSTORE PUSH1 0x1 SWAP5 SWAP1 SWAP5 ADD SWAP4 SWAP2 DUP6 ADD SWAP2 DUP6 ADD PUSH2 0x16F JUMP JUMPDEST POP DUP1 SWAP7 POP POP POP POP POP POP PUSH2 0x1AB DUP6 PUSH1 0x40 DUP7 ADD PUSH2 0xE1 JUMP JUMPDEST SWAP1 POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH1 0x40 DUP1 DUP3 MSTORE DUP4 MLOAD SWAP1 DUP3 ADD DUP2 SWAP1 MSTORE PUSH1 0x0 SWAP1 PUSH1 0x20 SWAP1 PUSH1 0x60 DUP5 ADD SWAP1 DUP3 DUP8 ADD DUP5 JUMPDEST DUP3 DUP2 LT ISZERO PUSH2 0x203 JUMPI DUP2 MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP5 MSTORE SWAP3 DUP5 ADD SWAP3 SWAP1 DUP5 ADD SWAP1 PUSH1 0x1 ADD PUSH2 0x1D1 JUMP JUMPDEST POP POP POP SWAP4 ISZERO ISZERO SWAP3 ADD SWAP2 SWAP1 SWAP2 MSTORE POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x40 MLOAD DUP2 DUP2 ADD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT DUP3 DUP3 LT OR ISZERO PUSH2 0x234 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x40 MSTORE SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH8 0xFFFFFFFFFFFFFFFF DUP3 GT ISZERO PUSH2 0x252 JUMPI DUP1 DUP2 REVERT JUMPDEST POP PUSH1 0x20 SWAP1 DUP2 MUL ADD SWAP1 JUMP JUMPDEST PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP2 AND DUP2 EQ PUSH2 0x27E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0x21 0xE9 DUP2 0xB6 STOP CALLDATALOAD EXTCODESIZE LOG3 SDIV CALLDATACOPY LOG1 PUSH30 0x7058622A0C9DAAE23CCB1ADC08EC9A44807189A64736F6C634300060C00 CALLER ",
                "sourceMap": "741:267:6:-:0;;;;;;;;;;;;;;;;;;;"
            },
            "deployedBytecode": {
                "immutableReferences": {},
                "linkReferences": {},
                "object": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063564fc11914610030575b600080fd5b61004361003e3660046100f1565b610045565b005b6040517fb09f1fb100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84169063b09f1fb19061009990859085906004016101b4565b600060405180830381600087803b1580156100b357600080fd5b505af11580156100c7573d6000803e3d6000fd5b50505050505050565b80356100db8161025c565b92915050565b803580151581146100db57600080fd5b600080600060608486031215610105578283fd5b83356101108161025c565b925060208481013567ffffffffffffffff81111561012c578384fd5b8501601f8101871361013c578384fd5b803561014f61014a8261023c565b610215565b81815283810190838501858402850186018b101561016b578788fd5b8794505b83851015610195576101818b826100d0565b83526001949094019391850191850161016f565b5080965050505050506101ab85604086016100e1565b90509250925092565b604080825283519082018190526000906020906060840190828701845b8281101561020357815173ffffffffffffffffffffffffffffffffffffffff16845292840192908401906001016101d1565b50505093151592019190915250919050565b60405181810167ffffffffffffffff8111828210171561023457600080fd5b604052919050565b600067ffffffffffffffff821115610252578081fd5b5060209081020190565b73ffffffffffffffffffffffffffffffffffffffff8116811461027e57600080fd5b5056fea264697066735822122021e981b600353ba30537a17d07058622a0c9daae23ccb1adc08ec9a44807189a64736f6c634300060c0033",
                "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x2B JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x564FC119 EQ PUSH2 0x30 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x43 PUSH2 0x3E CALLDATASIZE PUSH1 0x4 PUSH2 0xF1 JUMP JUMPDEST PUSH2 0x45 JUMP JUMPDEST STOP JUMPDEST PUSH1 0x40 MLOAD PUSH32 0xB09F1FB100000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP5 AND SWAP1 PUSH4 0xB09F1FB1 SWAP1 PUSH2 0x99 SWAP1 DUP6 SWAP1 DUP6 SWAP1 PUSH1 0x4 ADD PUSH2 0x1B4 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0xB3 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0xC7 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP POP POP POP JUMP JUMPDEST DUP1 CALLDATALOAD PUSH2 0xDB DUP2 PUSH2 0x25C JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST DUP1 CALLDATALOAD DUP1 ISZERO ISZERO DUP2 EQ PUSH2 0xDB JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x60 DUP5 DUP7 SUB SLT ISZERO PUSH2 0x105 JUMPI DUP3 DUP4 REVERT JUMPDEST DUP4 CALLDATALOAD PUSH2 0x110 DUP2 PUSH2 0x25C JUMP JUMPDEST SWAP3 POP PUSH1 0x20 DUP5 DUP2 ADD CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT ISZERO PUSH2 0x12C JUMPI DUP4 DUP5 REVERT JUMPDEST DUP6 ADD PUSH1 0x1F DUP2 ADD DUP8 SGT PUSH2 0x13C JUMPI DUP4 DUP5 REVERT JUMPDEST DUP1 CALLDATALOAD PUSH2 0x14F PUSH2 0x14A DUP3 PUSH2 0x23C JUMP JUMPDEST PUSH2 0x215 JUMP JUMPDEST DUP2 DUP2 MSTORE DUP4 DUP2 ADD SWAP1 DUP4 DUP6 ADD DUP6 DUP5 MUL DUP6 ADD DUP7 ADD DUP12 LT ISZERO PUSH2 0x16B JUMPI DUP8 DUP9 REVERT JUMPDEST DUP8 SWAP5 POP JUMPDEST DUP4 DUP6 LT ISZERO PUSH2 0x195 JUMPI PUSH2 0x181 DUP12 DUP3 PUSH2 0xD0 JUMP JUMPDEST DUP4 MSTORE PUSH1 0x1 SWAP5 SWAP1 SWAP5 ADD SWAP4 SWAP2 DUP6 ADD SWAP2 DUP6 ADD PUSH2 0x16F JUMP JUMPDEST POP DUP1 SWAP7 POP POP POP POP POP POP PUSH2 0x1AB DUP6 PUSH1 0x40 DUP7 ADD PUSH2 0xE1 JUMP JUMPDEST SWAP1 POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH1 0x40 DUP1 DUP3 MSTORE DUP4 MLOAD SWAP1 DUP3 ADD DUP2 SWAP1 MSTORE PUSH1 0x0 SWAP1 PUSH1 0x20 SWAP1 PUSH1 0x60 DUP5 ADD SWAP1 DUP3 DUP8 ADD DUP5 JUMPDEST DUP3 DUP2 LT ISZERO PUSH2 0x203 JUMPI DUP2 MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP5 MSTORE SWAP3 DUP5 ADD SWAP3 SWAP1 DUP5 ADD SWAP1 PUSH1 0x1 ADD PUSH2 0x1D1 JUMP JUMPDEST POP POP POP SWAP4 ISZERO ISZERO SWAP3 ADD SWAP2 SWAP1 SWAP2 MSTORE POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x40 MLOAD DUP2 DUP2 ADD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT DUP3 DUP3 LT OR ISZERO PUSH2 0x234 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x40 MSTORE SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH8 0xFFFFFFFFFFFFFFFF DUP3 GT ISZERO PUSH2 0x252 JUMPI DUP1 DUP2 REVERT JUMPDEST POP PUSH1 0x20 SWAP1 DUP2 MUL ADD SWAP1 JUMP JUMPDEST PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP2 AND DUP2 EQ PUSH2 0x27E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0x21 0xE9 DUP2 0xB6 STOP CALLDATALOAD EXTCODESIZE LOG3 SDIV CALLDATACOPY LOG1 PUSH30 0x7058622A0C9DAAE23CCB1ADC08EC9A44807189A64736F6C634300060C00 CALLER ",
                "sourceMap": "741:267:6:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;782:224;;;;;;:::i;:::-;;:::i;:::-;;;948:51;;;;;:33;;;;;;:51;;982:7;;991;;948:51;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;782:224;;;:::o;5:130:-1:-;72:20;;97:33;72:20;97:33;:::i;:::-;57:78;;;;:::o;875:124::-;939:20;;4833:13;;4826:21;5293:32;;5283:2;;5339:1;;5329:12;1199:677;;;;1387:2;1375:9;1366:7;1362:23;1358:32;1355:2;;;-1:-1;;1393:12;1355:2;1114:6;1101:20;1126:61;1181:5;1126:61;:::i;:::-;1445:91;-1:-1;1601:2;1586:18;;;1573:32;1625:18;1614:30;;1611:2;;;-1:-1;;1647:12;1611:2;1723:22;;270:4;258:17;;254:27;-1:-1;244:2;;-1:-1;;285:12;244:2;332:6;319:20;354:80;369:64;426:6;369:64;:::i;:::-;354:80;:::i;:::-;462:21;;;519:14;;;;494:17;;;608;;;599:27;;;;596:36;-1:-1;593:2;;;-1:-1;;635:12;593:2;-1:-1;661:10;;655:206;680:6;677:1;674:13;655:206;;;760:37;793:3;781:10;760:37;:::i;:::-;748:50;;702:1;695:9;;;;;812:14;;;;840;;655:206;;;659:14;1667:88;;;;;;;;1810:50;1852:7;1792:2;1832:9;1828:22;1810:50;:::i;:::-;1800:60;;1349:527;;;;;:::o;3015:469::-;3214:2;3228:47;;;4326:12;;3199:18;;;4601:19;;;3015:469;;4650:4;;4641:14;;;;4180;;;3015:469;2614:260;2639:6;2636:1;2633:13;2614:260;;;2700:13;;5058:42;5047:54;2126:37;;2037:14;;;;4456;;;;2661:1;2654:9;2614:260;;;-1:-1;;;4833:13;;4826:21;3455:18;;2969:34;;;;-1:-1;3281:116;3185:299;-1:-1;3185:299::o;3491:256::-;3553:2;3547:9;3579:17;;;3654:18;3639:34;;3675:22;;;3636:62;3633:2;;;3711:1;;3701:12;3633:2;3553;3720:22;3531:216;;-1:-1;3531:216::o;3754:304::-;;3913:18;3905:6;3902:30;3899:2;;;-1:-1;;3935:12;3899:2;-1:-1;3980:4;3968:17;;;4033:15;;3836:222::o;5113:117::-;5058:42;5200:5;5047:54;5175:5;5172:35;5162:2;;5221:1;;5211:12;5162:2;5156:74;:::o"
            },
            "methodIdentifiers": {
                "registerAllowedRfqOrigins(address,address[],bool)": "564fc119"
            }
        }
    },
    "sourceTreeHashHex": "0xe7f44ae906dd6b7816b17c863916101a4a47a959776ce304258c82482d4a1381",
    "sources": {
        "./TestRfqOriginRegistration.sol": {
            "id": 6,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"../src/features/interfaces/INativeOrdersFeature.sol\";\n\ncontract TestRfqOriginRegistration {\n    function registerAllowedRfqOrigins(\n        INativeOrdersFeature feature,\n        address[] memory origins,\n        bool allowed\n    )\n        external\n    {\n        feature.registerAllowedRfqOrigins(origins, allowed);\n    }\n}\n"
        },
        "../src/features/interfaces/INativeOrdersFeature.sol": {
            "id": 3,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol\";\nimport \"../libs/LibSignature.sol\";\nimport \"../libs/LibNativeOrder.sol\";\nimport \"./INativeOrdersEvents.sol\";\n\n\n/// @dev Feature for interacting with limit orders.\ninterface INativeOrdersFeature is\n    INativeOrdersEvents\n{\n\n    /// @dev Transfers protocol fees from the `FeeCollector` pools into\n    ///      the staking contract.\n    /// @param poolIds Staking pool IDs\n    function transferProtocolFeesForPools(bytes32[] calldata poolIds)\n        external;\n\n    /// @dev Fill a limit order. The taker and sender will be the caller.\n    /// @param order The limit order. ETH protocol fees can be\n    ///      attached to this call. Any unspent ETH will be refunded to\n    ///      the caller.\n    /// @param signature The order signature.\n    /// @param takerTokenFillAmount Maximum taker token amount to fill this order with.\n    /// @return takerTokenFilledAmount How much maker token was filled.\n    /// @return makerTokenFilledAmount How much maker token was filled.\n    function fillLimitOrder(\n        LibNativeOrder.LimitOrder calldata order,\n        LibSignature.Signature calldata signature,\n        uint128 takerTokenFillAmount\n    )\n        external\n        payable\n        returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);\n\n    /// @dev Fill an RFQ order for up to `takerTokenFillAmount` taker tokens.\n    ///      The taker will be the caller.\n    /// @param order The RFQ order.\n    /// @param signature The order signature.\n    /// @param takerTokenFillAmount Maximum taker token amount to fill this order with.\n    /// @return takerTokenFilledAmount How much maker token was filled.\n    /// @return makerTokenFilledAmount How much maker token was filled.\n    function fillRfqOrder(\n        LibNativeOrder.RfqOrder calldata order,\n        LibSignature.Signature calldata signature,\n        uint128 takerTokenFillAmount\n    )\n        external\n        returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);\n\n    /// @dev Fill an RFQ order for exactly `takerTokenFillAmount` taker tokens.\n    ///      The taker will be the caller. ETH protocol fees can be\n    ///      attached to this call. Any unspent ETH will be refunded to\n    ///      the caller.\n    /// @param order The limit order.\n    /// @param signature The order signature.\n    /// @param takerTokenFillAmount How much taker token to fill this order with.\n    /// @return makerTokenFilledAmount How much maker token was filled.\n    function fillOrKillLimitOrder(\n        LibNativeOrder.LimitOrder calldata order,\n        LibSignature.Signature calldata signature,\n        uint128 takerTokenFillAmount\n    )\n        external\n        payable\n        returns (uint128 makerTokenFilledAmount);\n\n    /// @dev Fill an RFQ order for exactly `takerTokenFillAmount` taker tokens.\n    ///      The taker will be the caller.\n    /// @param order The RFQ order.\n    /// @param signature The order signature.\n    /// @param takerTokenFillAmount How much taker token to fill this order with.\n    /// @return makerTokenFilledAmount How much maker token was filled.\n    function fillOrKillRfqOrder(\n        LibNativeOrder.RfqOrder calldata order,\n        LibSignature.Signature calldata signature,\n        uint128 takerTokenFillAmount\n    )\n        external\n        returns (uint128 makerTokenFilledAmount);\n\n    /// @dev Fill a limit order. Internal variant. ETH protocol fees can be\n    ///      attached to this call. Any unspent ETH will be refunded to\n    ///      `msg.sender` (not `sender`).\n    /// @param order The limit order.\n    /// @param signature The order signature.\n    /// @param takerTokenFillAmount Maximum taker token to fill this order with.\n    /// @param taker The order taker.\n    /// @param sender The order sender.\n    /// @return takerTokenFilledAmount How much maker token was filled.\n    /// @return makerTokenFilledAmount How much maker token was filled.\n    function _fillLimitOrder(\n        LibNativeOrder.LimitOrder calldata order,\n        LibSignature.Signature calldata signature,\n        uint128 takerTokenFillAmount,\n        address taker,\n        address sender\n    )\n        external\n        payable\n        returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);\n\n    /// @dev Fill an RFQ order. Internal variant.\n    /// @param order The RFQ order.\n    /// @param signature The order signature.\n    /// @param takerTokenFillAmount Maximum taker token to fill this order with.\n    /// @param taker The order taker.\n    /// @return takerTokenFilledAmount How much maker token was filled.\n    /// @return makerTokenFilledAmount How much maker token was filled.\n    function _fillRfqOrder(\n        LibNativeOrder.RfqOrder calldata order,\n        LibSignature.Signature calldata signature,\n        uint128 takerTokenFillAmount,\n        address taker\n    )\n        external\n        returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);\n\n    /// @dev Cancel a single limit order. The caller must be the maker.\n    ///      Silently succeeds if the order has already been cancelled.\n    /// @param order The limit order.\n    function cancelLimitOrder(LibNativeOrder.LimitOrder calldata order)\n        external;\n\n    /// @dev Cancel a single RFQ order. The caller must be the maker.\n    ///      Silently succeeds if the order has already been cancelled.\n    /// @param order The RFQ order.\n    function cancelRfqOrder(LibNativeOrder.RfqOrder calldata order)\n        external;\n\n    /// @dev Mark what tx.origin addresses are allowed to fill an order that\n    ///      specifies the message sender as its txOrigin.\n    /// @param origins An array of origin addresses to update.\n    /// @param allowed True to register, false to unregister.\n    function registerAllowedRfqOrigins(address[] memory origins, bool allowed)\n        external;\n\n    /// @dev Cancel multiple limit orders. The caller must be the maker.\n    ///      Silently succeeds if the order has already been cancelled.\n    /// @param orders The limit orders.\n    function batchCancelLimitOrders(LibNativeOrder.LimitOrder[] calldata orders)\n        external;\n\n    /// @dev Cancel multiple RFQ orders. The caller must be the maker.\n    ///      Silently succeeds if the order has already been cancelled.\n    /// @param orders The RFQ orders.\n    function batchCancelRfqOrders(LibNativeOrder.RfqOrder[] calldata orders)\n        external;\n\n    /// @dev Cancel all limit orders for a given maker and pair with a salt less\n    ///      than the value provided. The caller must be the maker. Subsequent\n    ///      calls to this function with the same caller and pair require the\n    ///      new salt to be >= the old salt.\n    /// @param makerToken The maker token.\n    /// @param takerToken The taker token.\n    /// @param minValidSalt The new minimum valid salt.\n    function cancelPairLimitOrders(\n        IERC20TokenV06 makerToken,\n        IERC20TokenV06 takerToken,\n        uint256 minValidSalt\n    )\n        external;\n\n    /// @dev Cancel all limit orders for a given maker and pair with a salt less\n    ///      than the value provided. The caller must be the maker. Subsequent\n    ///      calls to this function with the same caller and pair require the\n    ///      new salt to be >= the old salt.\n    /// @param makerTokens The maker tokens.\n    /// @param takerTokens The taker tokens.\n    /// @param minValidSalts The new minimum valid salts.\n    function batchCancelPairLimitOrders(\n        IERC20TokenV06[] calldata makerTokens,\n        IERC20TokenV06[] calldata takerTokens,\n        uint256[] calldata minValidSalts\n    )\n        external;\n\n    /// @dev Cancel all RFQ orders for a given maker and pair with a salt less\n    ///      than the value provided. The caller must be the maker. Subsequent\n    ///      calls to this function with the same caller and pair require the\n    ///      new salt to be >= the old salt.\n    /// @param makerToken The maker token.\n    /// @param takerToken The taker token.\n    /// @param minValidSalt The new minimum valid salt.\n    function cancelPairRfqOrders(\n        IERC20TokenV06 makerToken,\n        IERC20TokenV06 takerToken,\n        uint256 minValidSalt\n    )\n        external;\n\n    /// @dev Cancel all RFQ orders for a given maker and pair with a salt less\n    ///      than the value provided. The caller must be the maker. Subsequent\n    ///      calls to this function with the same caller and pair require the\n    ///      new salt to be >= the old salt.\n    /// @param makerTokens The maker tokens.\n    /// @param takerTokens The taker tokens.\n    /// @param minValidSalts The new minimum valid salts.\n    function batchCancelPairRfqOrders(\n        IERC20TokenV06[] calldata makerTokens,\n        IERC20TokenV06[] calldata takerTokens,\n        uint256[] calldata minValidSalts\n    )\n        external;\n\n    /// @dev Get the order info for a limit order.\n    /// @param order The limit order.\n    /// @return orderInfo Info about the order.\n    function getLimitOrderInfo(LibNativeOrder.LimitOrder calldata order)\n        external\n        view\n        returns (LibNativeOrder.OrderInfo memory orderInfo);\n\n    /// @dev Get the order info for an RFQ order.\n    /// @param order The RFQ order.\n    /// @return orderInfo Info about the order.\n    function getRfqOrderInfo(LibNativeOrder.RfqOrder calldata order)\n        external\n        view\n        returns (LibNativeOrder.OrderInfo memory orderInfo);\n\n    /// @dev Get the canonical hash of a limit order.\n    /// @param order The limit order.\n    /// @return orderHash The order hash.\n    function getLimitOrderHash(LibNativeOrder.LimitOrder calldata order)\n        external\n        view\n        returns (bytes32 orderHash);\n\n    /// @dev Get the canonical hash of an RFQ order.\n    /// @param order The RFQ order.\n    /// @return orderHash The order hash.\n    function getRfqOrderHash(LibNativeOrder.RfqOrder calldata order)\n        external\n        view\n        returns (bytes32 orderHash);\n\n    /// @dev Get the protocol fee multiplier. This should be multiplied by the\n    ///      gas price to arrive at the required protocol fee to fill a native order.\n    /// @return multiplier The protocol fee multiplier.\n    function getProtocolFeeMultiplier()\n        external\n        view\n        returns (uint32 multiplier);\n\n    /// @dev Get order info, fillable amount, and signature validity for a limit order.\n    ///      Fillable amount is determined using balances and allowances of the maker.\n    /// @param order The limit order.\n    /// @param signature The order signature.\n    /// @return orderInfo Info about the order.\n    /// @return actualFillableTakerTokenAmount How much of the order is fillable\n    ///         based on maker funds, in taker tokens.\n    /// @return isSignatureValid Whether the signature is valid.\n    function getLimitOrderRelevantState(\n        LibNativeOrder.LimitOrder calldata order,\n        LibSignature.Signature calldata signature\n    )\n        external\n        view\n        returns (\n            LibNativeOrder.OrderInfo memory orderInfo,\n            uint128 actualFillableTakerTokenAmount,\n            bool isSignatureValid\n        );\n\n    /// @dev Get order info, fillable amount, and signature validity for an RFQ order.\n    ///      Fillable amount is determined using balances and allowances of the maker.\n    /// @param order The RFQ order.\n    /// @param signature The order signature.\n    /// @return orderInfo Info about the order.\n    /// @return actualFillableTakerTokenAmount How much of the order is fillable\n    ///         based on maker funds, in taker tokens.\n    /// @return isSignatureValid Whether the signature is valid.\n    function getRfqOrderRelevantState(\n        LibNativeOrder.RfqOrder calldata order,\n        LibSignature.Signature calldata signature\n    )\n        external\n        view\n        returns (\n            LibNativeOrder.OrderInfo memory orderInfo,\n            uint128 actualFillableTakerTokenAmount,\n            bool isSignatureValid\n        );\n\n    /// @dev Batch version of `getLimitOrderRelevantState()`, without reverting.\n    ///      Orders that would normally cause `getLimitOrderRelevantState()`\n    ///      to revert will have empty results.\n    /// @param orders The limit orders.\n    /// @param signatures The order signatures.\n    /// @return orderInfos Info about the orders.\n    /// @return actualFillableTakerTokenAmounts How much of each order is fillable\n    ///         based on maker funds, in taker tokens.\n    /// @return isSignatureValids Whether each signature is valid for the order.\n    function batchGetLimitOrderRelevantStates(\n        LibNativeOrder.LimitOrder[] calldata orders,\n        LibSignature.Signature[] calldata signatures\n    )\n        external\n        view\n        returns (\n            LibNativeOrder.OrderInfo[] memory orderInfos,\n            uint128[] memory actualFillableTakerTokenAmounts,\n            bool[] memory isSignatureValids\n        );\n\n    /// @dev Batch version of `getRfqOrderRelevantState()`, without reverting.\n    ///      Orders that would normally cause `getRfqOrderRelevantState()`\n    ///      to revert will have empty results.\n    /// @param orders The RFQ orders.\n    /// @param signatures The order signatures.\n    /// @return orderInfos Info about the orders.\n    /// @return actualFillableTakerTokenAmounts How much of each order is fillable\n    ///         based on maker funds, in taker tokens.\n    /// @return isSignatureValids Whether each signature is valid for the order.\n    function batchGetRfqOrderRelevantStates(\n        LibNativeOrder.RfqOrder[] calldata orders,\n        LibSignature.Signature[] calldata signatures\n    )\n        external\n        view\n        returns (\n            LibNativeOrder.OrderInfo[] memory orderInfos,\n            uint128[] memory actualFillableTakerTokenAmounts,\n            bool[] memory isSignatureValids\n        );\n}\n"
        },
        "@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol": {
            "id": 7,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\n\n\ninterface IERC20TokenV06 {\n\n    // solhint-disable no-simple-event-func-name\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @dev send `value` token to `to` from `msg.sender`\n    /// @param to The address of the recipient\n    /// @param value The amount of token to be transferred\n    /// @return True if transfer was successful\n    function transfer(address to, uint256 value)\n        external\n        returns (bool);\n\n    /// @dev send `value` token to `to` from `from` on the condition it is approved by `from`\n    /// @param from The address of the sender\n    /// @param to The address of the recipient\n    /// @param value The amount of token to be transferred\n    /// @return True if transfer was successful\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n        external\n        returns (bool);\n\n    /// @dev `msg.sender` approves `spender` to spend `value` tokens\n    /// @param spender The address of the account able to transfer the tokens\n    /// @param value The amount of wei to be approved for transfer\n    /// @return Always true if the call has enough gas to complete execution\n    function approve(address spender, uint256 value)\n        external\n        returns (bool);\n\n    /// @dev Query total supply of token\n    /// @return Total supply of token\n    function totalSupply()\n        external\n        view\n        returns (uint256);\n\n    /// @dev Get the balance of `owner`.\n    /// @param owner The address from which the balance will be retrieved\n    /// @return Balance of owner\n    function balanceOf(address owner)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Get the allowance for `spender` to spend from `owner`.\n    /// @param owner The address of the account owning tokens\n    /// @param spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Get the number of decimals this token has.\n    function decimals()\n        external\n        view\n        returns (uint8);\n}\n"
        },
        "../src/features/libs/LibSignature.sol": {
            "id": 5,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-utils/contracts/src/v06/errors/LibRichErrorsV06.sol\";\nimport \"../../errors/LibSignatureRichErrors.sol\";\n\n\n/// @dev A library for validating signatures.\nlibrary LibSignature {\n    using LibRichErrorsV06 for bytes;\n\n    // '\\x19Ethereum Signed Message:\\n32\\x00\\x00\\x00\\x00' in a word.\n    uint256 private constant ETH_SIGN_HASH_PREFIX =\n        0x19457468657265756d205369676e6564204d6573736167653a0a333200000000;\n    /// @dev Exclusive upper limit on ECDSA signatures 'R' values.\n    ///      The valid range is given by fig (282) of the yellow paper.\n    uint256 private constant ECDSA_SIGNATURE_R_LIMIT =\n        uint256(0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141);\n    /// @dev Exclusive upper limit on ECDSA signatures 'S' values.\n    ///      The valid range is given by fig (283) of the yellow paper.\n    uint256 private constant ECDSA_SIGNATURE_S_LIMIT = ECDSA_SIGNATURE_R_LIMIT / 2 + 1;\n\n    /// @dev Allowed signature types.\n    enum SignatureType {\n        ILLEGAL,\n        INVALID,\n        EIP712,\n        ETHSIGN\n    }\n\n    /// @dev Encoded EC signature.\n    struct Signature {\n        // How to validate the signature.\n        SignatureType signatureType;\n        // EC Signature data.\n        uint8 v;\n        // EC Signature data.\n        bytes32 r;\n        // EC Signature data.\n        bytes32 s;\n    }\n\n    /// @dev Retrieve the signer of a signature.\n    ///      Throws if the signature can't be validated.\n    /// @param hash The hash that was signed.\n    /// @param signature The signature.\n    /// @return recovered The recovered signer address.\n    function getSignerOfHash(\n        bytes32 hash,\n        Signature memory signature\n    )\n        internal\n        pure\n        returns (address recovered)\n    {\n        // Ensure this is a signature type that can be validated against a hash.\n        _validateHashCompatibleSignature(hash, signature);\n\n        if (signature.signatureType == SignatureType.EIP712) {\n            // Signed using EIP712\n            recovered = ecrecover(\n                hash,\n                signature.v,\n                signature.r,\n                signature.s\n            );\n        } else if (signature.signatureType == SignatureType.ETHSIGN) {\n            // Signed using `eth_sign`\n            // Need to hash `hash` with \"\\x19Ethereum Signed Message:\\n32\" prefix\n            // in packed encoding.\n            bytes32 ethSignHash;\n            assembly {\n                // Use scratch space\n                mstore(0, ETH_SIGN_HASH_PREFIX) // length of 28 bytes\n                mstore(28, hash) // length of 32 bytes\n                ethSignHash := keccak256(0, 60)\n            }\n            recovered = ecrecover(\n                ethSignHash,\n                signature.v,\n                signature.r,\n                signature.s\n            );\n        }\n        // `recovered` can be null if the signature values are out of range.\n        if (recovered == address(0)) {\n            LibSignatureRichErrors.SignatureValidationError(\n                LibSignatureRichErrors.SignatureValidationErrorCodes.BAD_SIGNATURE_DATA,\n                hash\n            ).rrevert();\n        }\n    }\n\n    /// @dev Validates that a signature is compatible with a hash signee.\n    /// @param hash The hash that was signed.\n    /// @param signature The signature.\n    function _validateHashCompatibleSignature(\n        bytes32 hash,\n        Signature memory signature\n    )\n        private\n        pure\n    {\n        // Ensure the r and s are within malleability limits.\n        if (uint256(signature.r) >= ECDSA_SIGNATURE_R_LIMIT ||\n            uint256(signature.s) >= ECDSA_SIGNATURE_S_LIMIT)\n        {\n            LibSignatureRichErrors.SignatureValidationError(\n                LibSignatureRichErrors.SignatureValidationErrorCodes.BAD_SIGNATURE_DATA,\n                hash\n            ).rrevert();\n        }\n\n        // Always illegal signature.\n        if (signature.signatureType == SignatureType.ILLEGAL) {\n            LibSignatureRichErrors.SignatureValidationError(\n                LibSignatureRichErrors.SignatureValidationErrorCodes.ILLEGAL,\n                hash\n            ).rrevert();\n        }\n\n        // Always invalid.\n        if (signature.signatureType == SignatureType.INVALID) {\n            LibSignatureRichErrors.SignatureValidationError(\n                LibSignatureRichErrors.SignatureValidationErrorCodes.ALWAYS_INVALID,\n                hash\n            ).rrevert();\n        }\n\n        // Solidity should check that the signature type is within enum range for us\n        // when abi-decoding.\n    }\n}\n"
        },
        "@0x/contracts-utils/contracts/src/v06/errors/LibRichErrorsV06.sol": {
            "id": 9,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\n\n\nlibrary LibRichErrorsV06 {\n\n    // bytes4(keccak256(\"Error(string)\"))\n    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n\n    // solhint-disable func-name-mixedcase\n    /// @dev ABI encode a standard, string revert error payload.\n    ///      This is the same payload that would be included by a `revert(string)`\n    ///      solidity statement. It has the function signature `Error(string)`.\n    /// @param message The error string.\n    /// @return The ABI encoded error.\n    function StandardError(string memory message)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            STANDARD_ERROR_SELECTOR,\n            bytes(message)\n        );\n    }\n    // solhint-enable func-name-mixedcase\n\n    /// @dev Reverts an encoded rich revert reason `errorData`.\n    /// @param errorData ABI encoded error data.\n    function rrevert(bytes memory errorData)\n        internal\n        pure\n    {\n        assembly {\n            revert(add(errorData, 0x20), mload(errorData))\n        }\n    }\n}\n"
        },
        "../src/errors/LibSignatureRichErrors.sol": {
            "id": 1,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\n\n\nlibrary LibSignatureRichErrors {\n\n    enum SignatureValidationErrorCodes {\n        ALWAYS_INVALID,\n        INVALID_LENGTH,\n        UNSUPPORTED,\n        ILLEGAL,\n        WRONG_SIGNER,\n        BAD_SIGNATURE_DATA\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    function SignatureValidationError(\n        SignatureValidationErrorCodes code,\n        bytes32 hash,\n        address signerAddress,\n        bytes memory signature\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"SignatureValidationError(uint8,bytes32,address,bytes)\")),\n            code,\n            hash,\n            signerAddress,\n            signature\n        );\n    }\n\n    function SignatureValidationError(\n        SignatureValidationErrorCodes code,\n        bytes32 hash\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"SignatureValidationError(uint8,bytes32)\")),\n            code,\n            hash\n        );\n    }\n}\n"
        },
        "../src/features/libs/LibNativeOrder.sol": {
            "id": 4,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol\";\nimport \"@0x/contracts-utils/contracts/src/v06/errors/LibRichErrorsV06.sol\";\nimport \"@0x/contracts-utils/contracts/src/v06/LibSafeMathV06.sol\";\nimport \"../../errors/LibNativeOrdersRichErrors.sol\";\n\n\n/// @dev A library for common native order operations.\nlibrary LibNativeOrder {\n    using LibSafeMathV06 for uint256;\n    using LibRichErrorsV06 for bytes;\n\n    enum OrderStatus {\n        INVALID,\n        FILLABLE,\n        FILLED,\n        CANCELLED,\n        EXPIRED\n    }\n\n    /// @dev A standard OTC or OO limit order.\n    struct LimitOrder {\n        IERC20TokenV06 makerToken;\n        IERC20TokenV06 takerToken;\n        uint128 makerAmount;\n        uint128 takerAmount;\n        uint128 takerTokenFeeAmount;\n        address maker;\n        address taker;\n        address sender;\n        address feeRecipient;\n        bytes32 pool;\n        uint64 expiry;\n        uint256 salt;\n    }\n\n    /// @dev An RFQ limit order.\n    struct RfqOrder {\n        IERC20TokenV06 makerToken;\n        IERC20TokenV06 takerToken;\n        uint128 makerAmount;\n        uint128 takerAmount;\n        address maker;\n        address taker;\n        address txOrigin;\n        bytes32 pool;\n        uint64 expiry;\n        uint256 salt;\n    }\n\n    /// @dev Info on a limit or RFQ order.\n    struct OrderInfo {\n        bytes32 orderHash;\n        OrderStatus status;\n        uint128 takerTokenFilledAmount;\n    }\n\n    uint256 private constant UINT_128_MASK = (1 << 128) - 1;\n    uint256 private constant UINT_64_MASK = (1 << 64) - 1;\n    uint256 private constant ADDRESS_MASK = (1 << 160) - 1;\n\n    // The type hash for limit orders, which is:\n    // keccak256(abi.encodePacked(\n    //     \"LimitOrder(\",\n    //       \"address makerToken,\",\n    //       \"address takerToken,\",\n    //       \"uint128 makerAmount,\",\n    //       \"uint128 takerAmount,\",\n    //       \"uint128 takerTokenFeeAmount,\",\n    //       \"address maker,\",\n    //       \"address taker,\",\n    //       \"address sender,\",\n    //       \"address feeRecipient,\",\n    //       \"bytes32 pool,\",\n    //       \"uint64 expiry,\",\n    //       \"uint256 salt\"\n    //     \")\"\n    // ))\n    uint256 private constant _LIMIT_ORDER_TYPEHASH =\n        0xce918627cb55462ddbb85e73de69a8b322f2bc88f4507c52fcad6d4c33c29d49;\n\n    // The type hash for RFQ orders, which is:\n    // keccak256(abi.encodePacked(\n    //     \"RfqOrder(\",\n    //       \"address makerToken,\",\n    //       \"address takerToken,\",\n    //       \"uint128 makerAmount,\",\n    //       \"uint128 takerAmount,\",\n    //       \"address maker,\",\n    //       \"address taker,\",\n    //       \"address txOrigin,\",\n    //       \"bytes32 pool,\",\n    //       \"uint64 expiry,\",\n    //       \"uint256 salt\"\n    //     \")\"\n    // ))\n    uint256 private constant _RFQ_ORDER_TYPEHASH =\n        0xe593d3fdfa8b60e5e17a1b2204662ecbe15c23f2084b9ad5bae40359540a7da9;\n\n    /// @dev Get the struct hash of a limit order.\n    /// @param order The limit order.\n    /// @return structHash The struct hash of the order.\n    function getLimitOrderStructHash(LimitOrder memory order)\n        internal\n        pure\n        returns (bytes32 structHash)\n    {\n        // The struct hash is:\n        // keccak256(abi.encode(\n        //   TYPE_HASH,\n        //   order.makerToken,\n        //   order.takerToken,\n        //   order.makerAmount,\n        //   order.takerAmount,\n        //   order.takerTokenFeeAmount,\n        //   order.maker,\n        //   order.taker,\n        //   order.sender,\n        //   order.feeRecipient,\n        //   order.pool,\n        //   order.expiry,\n        //   order.salt,\n        // ))\n        assembly {\n            let mem := mload(0x40)\n            mstore(mem, _LIMIT_ORDER_TYPEHASH)\n            // order.makerToken;\n            mstore(add(mem, 0x20), and(ADDRESS_MASK, mload(order)))\n            // order.takerToken;\n            mstore(add(mem, 0x40), and(ADDRESS_MASK, mload(add(order, 0x20))))\n            // order.makerAmount;\n            mstore(add(mem, 0x60), and(UINT_128_MASK, mload(add(order, 0x40))))\n            // order.takerAmount;\n            mstore(add(mem, 0x80), and(UINT_128_MASK, mload(add(order, 0x60))))\n            // order.takerTokenFeeAmount;\n            mstore(add(mem, 0xA0), and(UINT_128_MASK, mload(add(order, 0x80))))\n            // order.maker;\n            mstore(add(mem, 0xC0), and(ADDRESS_MASK, mload(add(order, 0xA0))))\n            // order.taker;\n            mstore(add(mem, 0xE0), and(ADDRESS_MASK, mload(add(order, 0xC0))))\n            // order.sender;\n            mstore(add(mem, 0x100), and(ADDRESS_MASK, mload(add(order, 0xE0))))\n            // order.feeRecipient;\n            mstore(add(mem, 0x120), and(ADDRESS_MASK, mload(add(order, 0x100))))\n            // order.pool;\n            mstore(add(mem, 0x140), mload(add(order, 0x120)))\n            // order.expiry;\n            mstore(add(mem, 0x160), and(UINT_64_MASK, mload(add(order, 0x140))))\n            // order.salt;\n            mstore(add(mem, 0x180), mload(add(order, 0x160)))\n            structHash := keccak256(mem, 0x1A0)\n        }\n    }\n\n    /// @dev Get the struct hash of a RFQ order.\n    /// @param order The RFQ order.\n    /// @return structHash The struct hash of the order.\n    function getRfqOrderStructHash(RfqOrder memory order)\n        internal\n        pure\n        returns (bytes32 structHash)\n    {\n        // The struct hash is:\n        // keccak256(abi.encode(\n        //   TYPE_HASH,\n        //   order.makerToken,\n        //   order.takerToken,\n        //   order.makerAmount,\n        //   order.takerAmount,\n        //   order.maker,\n        //   order.taker,\n        //   order.txOrigin,\n        //   order.pool,\n        //   order.expiry,\n        //   order.salt,\n        // ))\n        assembly {\n            let mem := mload(0x40)\n            mstore(mem, _RFQ_ORDER_TYPEHASH)\n            // order.makerToken;\n            mstore(add(mem, 0x20), and(ADDRESS_MASK, mload(order)))\n            // order.takerToken;\n            mstore(add(mem, 0x40), and(ADDRESS_MASK, mload(add(order, 0x20))))\n            // order.makerAmount;\n            mstore(add(mem, 0x60), and(UINT_128_MASK, mload(add(order, 0x40))))\n            // order.takerAmount;\n            mstore(add(mem, 0x80), and(UINT_128_MASK, mload(add(order, 0x60))))\n            // order.maker;\n            mstore(add(mem, 0xA0), and(ADDRESS_MASK, mload(add(order, 0x80))))\n            // order.taker;\n            mstore(add(mem, 0xC0), and(ADDRESS_MASK, mload(add(order, 0xA0))))\n            // order.txOrigin;\n            mstore(add(mem, 0xE0), and(ADDRESS_MASK, mload(add(order, 0xC0))))\n            // order.pool;\n            mstore(add(mem, 0x100), mload(add(order, 0xE0)))\n            // order.expiry;\n            mstore(add(mem, 0x120), and(UINT_64_MASK, mload(add(order, 0x100))))\n            // order.salt;\n            mstore(add(mem, 0x140), mload(add(order, 0x120)))\n            structHash := keccak256(mem, 0x160)\n        }\n    }\n\n    /// @dev Refund any leftover protocol fees in `msg.value` to `msg.sender`.\n    /// @param ethProtocolFeePaid How much ETH was paid in protocol fees.\n    function refundExcessProtocolFeeToSender(uint256 ethProtocolFeePaid)\n        internal\n    {\n        if (msg.value > ethProtocolFeePaid && msg.sender != address(this)) {\n            uint256 refundAmount = msg.value.safeSub(ethProtocolFeePaid);\n            (bool success,) = msg\n                .sender\n                .call{value: refundAmount}(\"\");\n            if (!success) {\n                LibNativeOrdersRichErrors.ProtocolFeeRefundFailed(\n                    msg.sender,\n                    refundAmount\n                ).rrevert();\n            }\n        }\n    }\n}\n"
        },
        "@0x/contracts-utils/contracts/src/v06/LibSafeMathV06.sol": {
            "id": 8,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\n\nimport \"./errors/LibRichErrorsV06.sol\";\nimport \"./errors/LibSafeMathRichErrorsV06.sol\";\n\n\nlibrary LibSafeMathV06 {\n\n    function safeMul(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        if (c / a != b) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.MULTIPLICATION_OVERFLOW,\n                a,\n                b\n            ));\n        }\n        return c;\n    }\n\n    function safeDiv(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (b == 0) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.DIVISION_BY_ZERO,\n                a,\n                b\n            ));\n        }\n        uint256 c = a / b;\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (b > a) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.SUBTRACTION_UNDERFLOW,\n                a,\n                b\n            ));\n        }\n        return a - b;\n    }\n\n    function safeAdd(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 c = a + b;\n        if (c < a) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.ADDITION_OVERFLOW,\n                a,\n                b\n            ));\n        }\n        return c;\n    }\n\n    function max256(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    function safeMul128(uint128 a, uint128 b)\n        internal\n        pure\n        returns (uint128)\n    {\n        if (a == 0) {\n            return 0;\n        }\n        uint128 c = a * b;\n        if (c / a != b) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.MULTIPLICATION_OVERFLOW,\n                a,\n                b\n            ));\n        }\n        return c;\n    }\n\n    function safeDiv128(uint128 a, uint128 b)\n        internal\n        pure\n        returns (uint128)\n    {\n        if (b == 0) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.DIVISION_BY_ZERO,\n                a,\n                b\n            ));\n        }\n        uint128 c = a / b;\n        return c;\n    }\n\n    function safeSub128(uint128 a, uint128 b)\n        internal\n        pure\n        returns (uint128)\n    {\n        if (b > a) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.SUBTRACTION_UNDERFLOW,\n                a,\n                b\n            ));\n        }\n        return a - b;\n    }\n\n    function safeAdd128(uint128 a, uint128 b)\n        internal\n        pure\n        returns (uint128)\n    {\n        uint128 c = a + b;\n        if (c < a) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.ADDITION_OVERFLOW,\n                a,\n                b\n            ));\n        }\n        return c;\n    }\n\n    function max128(uint128 a, uint128 b)\n        internal\n        pure\n        returns (uint128)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min128(uint128 a, uint128 b)\n        internal\n        pure\n        returns (uint128)\n    {\n        return a < b ? a : b;\n    }\n\n    function safeDowncastToUint128(uint256 a)\n        internal\n        pure\n        returns (uint128)\n    {\n        if (a > type(uint128).max) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256DowncastError(\n                LibSafeMathRichErrorsV06.DowncastErrorCodes.VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT128,\n                a\n            ));\n        }\n        return uint128(a);\n    }\n}\n"
        },
        "@0x/contracts-utils/contracts/src/v06/errors/LibSafeMathRichErrorsV06.sol": {
            "id": 10,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\n\n\nlibrary LibSafeMathRichErrorsV06 {\n\n    // bytes4(keccak256(\"Uint256BinOpError(uint8,uint256,uint256)\"))\n    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR =\n        0xe946c1bb;\n\n    // bytes4(keccak256(\"Uint256DowncastError(uint8,uint256)\"))\n    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR =\n        0xc996af7b;\n\n    enum BinOpErrorCodes {\n        ADDITION_OVERFLOW,\n        MULTIPLICATION_OVERFLOW,\n        SUBTRACTION_UNDERFLOW,\n        DIVISION_BY_ZERO\n    }\n\n    enum DowncastErrorCodes {\n        VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT32,\n        VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT64,\n        VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT96,\n        VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT128\n    }\n\n    // solhint-disable func-name-mixedcase\n    function Uint256BinOpError(\n        BinOpErrorCodes errorCode,\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            UINT256_BINOP_ERROR_SELECTOR,\n            errorCode,\n            a,\n            b\n        );\n    }\n\n    function Uint256DowncastError(\n        DowncastErrorCodes errorCode,\n        uint256 a\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n            errorCode,\n            a\n        );\n    }\n}\n"
        },
        "../src/errors/LibNativeOrdersRichErrors.sol": {
            "id": 0,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\n\n\nlibrary LibNativeOrdersRichErrors {\n\n    // solhint-disable func-name-mixedcase\n\n    function ProtocolFeeRefundFailed(\n        address receiver,\n        uint256 refundAmount\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"ProtocolFeeRefundFailed(address,uint256)\")),\n            receiver,\n            refundAmount\n        );\n    }\n\n    function OrderNotFillableByOriginError(\n        bytes32 orderHash,\n        address txOrigin,\n        address orderTxOrigin\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"OrderNotFillableByOriginError(bytes32,address,address)\")),\n            orderHash,\n            txOrigin,\n            orderTxOrigin\n        );\n    }\n\n    function OrderNotFillableError(\n        bytes32 orderHash,\n        uint8 orderStatus\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"OrderNotFillableError(bytes32,uint8)\")),\n            orderHash,\n            orderStatus\n        );\n    }\n\n    function OrderNotSignedByMakerError(\n        bytes32 orderHash,\n        address signer,\n        address maker\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"OrderNotSignedByMakerError(bytes32,address,address)\")),\n            orderHash,\n            signer,\n            maker\n        );\n    }\n\n    function OrderNotFillableBySenderError(\n        bytes32 orderHash,\n        address sender,\n        address orderSender\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"OrderNotFillableBySenderError(bytes32,address,address)\")),\n            orderHash,\n            sender,\n            orderSender\n        );\n    }\n\n    function OrderNotFillableByTakerError(\n        bytes32 orderHash,\n        address taker,\n        address orderTaker\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"OrderNotFillableByTakerError(bytes32,address,address)\")),\n            orderHash,\n            taker,\n            orderTaker\n        );\n    }\n\n    function CancelSaltTooLowError(\n        uint256 minValidSalt,\n        uint256 oldMinValidSalt\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"CancelSaltTooLowError(uint256,uint256)\")),\n            minValidSalt,\n            oldMinValidSalt\n        );\n    }\n\n    function FillOrKillFailedError(\n        bytes32 orderHash,\n        uint256 takerTokenFilledAmount,\n        uint256 takerTokenFillAmount\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"FillOrKillFailedError(bytes32,uint256,uint256)\")),\n            orderHash,\n            takerTokenFilledAmount,\n            takerTokenFillAmount\n        );\n    }\n\n    function OnlyOrderMakerAllowed(\n        bytes32 orderHash,\n        address sender,\n        address maker\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"OnlyOrderMakerAllowed(bytes32,address,address)\")),\n            orderHash,\n            sender,\n            maker\n        );\n    }\n\n    function BatchFillIncompleteError(\n        bytes32 orderHash,\n        uint256 takerTokenFilledAmount,\n        uint256 takerTokenFillAmount\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"BatchFillIncompleteError(bytes32,uint256,uint256)\")),\n            orderHash,\n            takerTokenFilledAmount,\n            takerTokenFillAmount\n        );\n    }\n}\n"
        },
        "../src/features/interfaces/INativeOrdersEvents.sol": {
            "id": 2,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2021 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol\";\nimport \"../libs/LibSignature.sol\";\nimport \"../libs/LibNativeOrder.sol\";\n\n\n/// @dev Events emitted by NativeOrdersFeature.\ninterface INativeOrdersEvents {\n\n    /// @dev Emitted whenever a `LimitOrder` is filled.\n    /// @param orderHash The canonical hash of the order.\n    /// @param maker The maker of the order.\n    /// @param taker The taker of the order.\n    /// @param feeRecipient Fee recipient of the order.\n    /// @param takerTokenFilledAmount How much taker token was filled.\n    /// @param makerTokenFilledAmount How much maker token was filled.\n    /// @param protocolFeePaid How much protocol fee was paid.\n    /// @param pool The fee pool associated with this order.\n    event LimitOrderFilled(\n        bytes32 orderHash,\n        address maker,\n        address taker,\n        address feeRecipient,\n        address makerToken,\n        address takerToken,\n        uint128 takerTokenFilledAmount,\n        uint128 makerTokenFilledAmount,\n        uint128 takerTokenFeeFilledAmount,\n        uint256 protocolFeePaid,\n        bytes32 pool\n    );\n\n    /// @dev Emitted whenever an `RfqOrder` is filled.\n    /// @param orderHash The canonical hash of the order.\n    /// @param maker The maker of the order.\n    /// @param taker The taker of the order.\n    /// @param takerTokenFilledAmount How much taker token was filled.\n    /// @param makerTokenFilledAmount How much maker token was filled.\n    /// @param pool The fee pool associated with this order.\n    event RfqOrderFilled(\n        bytes32 orderHash,\n        address maker,\n        address taker,\n        address makerToken,\n        address takerToken,\n        uint128 takerTokenFilledAmount,\n        uint128 makerTokenFilledAmount,\n        bytes32 pool\n    );\n\n    /// @dev Emitted whenever a limit or RFQ order is cancelled.\n    /// @param orderHash The canonical hash of the order.\n    /// @param maker The order maker.\n    event OrderCancelled(\n        bytes32 orderHash,\n        address maker\n    );\n\n    /// @dev Emitted whenever Limit orders are cancelled by pair by a maker.\n    /// @param maker The maker of the order.\n    /// @param makerToken The maker token in a pair for the orders cancelled.\n    /// @param takerToken The taker token in a pair for the orders cancelled.\n    /// @param minValidSalt The new minimum valid salt an order with this pair must\n    ///        have.\n    event PairCancelledLimitOrders(\n        address maker,\n        address makerToken,\n        address takerToken,\n        uint256 minValidSalt\n    );\n\n    /// @dev Emitted whenever RFQ orders are cancelled by pair by a maker.\n    /// @param maker The maker of the order.\n    /// @param makerToken The maker token in a pair for the orders cancelled.\n    /// @param takerToken The taker token in a pair for the orders cancelled.\n    /// @param minValidSalt The new minimum valid salt an order with this pair must\n    ///        have.\n    event PairCancelledRfqOrders(\n        address maker,\n        address makerToken,\n        address takerToken,\n        uint256 minValidSalt\n    );\n\n    /// @dev Emitted when new addresses are allowed or disallowed to fill\n    ///      orders with a given txOrigin.\n    /// @param origin The address doing the allowing.\n    /// @param addrs The address being allowed/disallowed.\n    /// @param allowed Indicates whether the address should be allowed.\n    event RfqOrderOriginsAllowed(\n        address origin,\n        address[] addrs,\n        bool allowed\n    );\n}\n"
        }
    },
    "sourceCodes": {
        "./TestRfqOriginRegistration.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"../src/features/interfaces/INativeOrdersFeature.sol\";\n\ncontract TestRfqOriginRegistration {\n    function registerAllowedRfqOrigins(\n        INativeOrdersFeature feature,\n        address[] memory origins,\n        bool allowed\n    )\n        external\n    {\n        feature.registerAllowedRfqOrigins(origins, allowed);\n    }\n}\n",
        "../src/features/interfaces/INativeOrdersFeature.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol\";\nimport \"../libs/LibSignature.sol\";\nimport \"../libs/LibNativeOrder.sol\";\nimport \"./INativeOrdersEvents.sol\";\n\n\n/// @dev Feature for interacting with limit orders.\ninterface INativeOrdersFeature is\n    INativeOrdersEvents\n{\n\n    /// @dev Transfers protocol fees from the `FeeCollector` pools into\n    ///      the staking contract.\n    /// @param poolIds Staking pool IDs\n    function transferProtocolFeesForPools(bytes32[] calldata poolIds)\n        external;\n\n    /// @dev Fill a limit order. The taker and sender will be the caller.\n    /// @param order The limit order. ETH protocol fees can be\n    ///      attached to this call. Any unspent ETH will be refunded to\n    ///      the caller.\n    /// @param signature The order signature.\n    /// @param takerTokenFillAmount Maximum taker token amount to fill this order with.\n    /// @return takerTokenFilledAmount How much maker token was filled.\n    /// @return makerTokenFilledAmount How much maker token was filled.\n    function fillLimitOrder(\n        LibNativeOrder.LimitOrder calldata order,\n        LibSignature.Signature calldata signature,\n        uint128 takerTokenFillAmount\n    )\n        external\n        payable\n        returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);\n\n    /// @dev Fill an RFQ order for up to `takerTokenFillAmount` taker tokens.\n    ///      The taker will be the caller.\n    /// @param order The RFQ order.\n    /// @param signature The order signature.\n    /// @param takerTokenFillAmount Maximum taker token amount to fill this order with.\n    /// @return takerTokenFilledAmount How much maker token was filled.\n    /// @return makerTokenFilledAmount How much maker token was filled.\n    function fillRfqOrder(\n        LibNativeOrder.RfqOrder calldata order,\n        LibSignature.Signature calldata signature,\n        uint128 takerTokenFillAmount\n    )\n        external\n        returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);\n\n    /// @dev Fill an RFQ order for exactly `takerTokenFillAmount` taker tokens.\n    ///      The taker will be the caller. ETH protocol fees can be\n    ///      attached to this call. Any unspent ETH will be refunded to\n    ///      the caller.\n    /// @param order The limit order.\n    /// @param signature The order signature.\n    /// @param takerTokenFillAmount How much taker token to fill this order with.\n    /// @return makerTokenFilledAmount How much maker token was filled.\n    function fillOrKillLimitOrder(\n        LibNativeOrder.LimitOrder calldata order,\n        LibSignature.Signature calldata signature,\n        uint128 takerTokenFillAmount\n    )\n        external\n        payable\n        returns (uint128 makerTokenFilledAmount);\n\n    /// @dev Fill an RFQ order for exactly `takerTokenFillAmount` taker tokens.\n    ///      The taker will be the caller.\n    /// @param order The RFQ order.\n    /// @param signature The order signature.\n    /// @param takerTokenFillAmount How much taker token to fill this order with.\n    /// @return makerTokenFilledAmount How much maker token was filled.\n    function fillOrKillRfqOrder(\n        LibNativeOrder.RfqOrder calldata order,\n        LibSignature.Signature calldata signature,\n        uint128 takerTokenFillAmount\n    )\n        external\n        returns (uint128 makerTokenFilledAmount);\n\n    /// @dev Fill a limit order. Internal variant. ETH protocol fees can be\n    ///      attached to this call. Any unspent ETH will be refunded to\n    ///      `msg.sender` (not `sender`).\n    /// @param order The limit order.\n    /// @param signature The order signature.\n    /// @param takerTokenFillAmount Maximum taker token to fill this order with.\n    /// @param taker The order taker.\n    /// @param sender The order sender.\n    /// @return takerTokenFilledAmount How much maker token was filled.\n    /// @return makerTokenFilledAmount How much maker token was filled.\n    function _fillLimitOrder(\n        LibNativeOrder.LimitOrder calldata order,\n        LibSignature.Signature calldata signature,\n        uint128 takerTokenFillAmount,\n        address taker,\n        address sender\n    )\n        external\n        payable\n        returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);\n\n    /// @dev Fill an RFQ order. Internal variant.\n    /// @param order The RFQ order.\n    /// @param signature The order signature.\n    /// @param takerTokenFillAmount Maximum taker token to fill this order with.\n    /// @param taker The order taker.\n    /// @return takerTokenFilledAmount How much maker token was filled.\n    /// @return makerTokenFilledAmount How much maker token was filled.\n    function _fillRfqOrder(\n        LibNativeOrder.RfqOrder calldata order,\n        LibSignature.Signature calldata signature,\n        uint128 takerTokenFillAmount,\n        address taker\n    )\n        external\n        returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);\n\n    /// @dev Cancel a single limit order. The caller must be the maker.\n    ///      Silently succeeds if the order has already been cancelled.\n    /// @param order The limit order.\n    function cancelLimitOrder(LibNativeOrder.LimitOrder calldata order)\n        external;\n\n    /// @dev Cancel a single RFQ order. The caller must be the maker.\n    ///      Silently succeeds if the order has already been cancelled.\n    /// @param order The RFQ order.\n    function cancelRfqOrder(LibNativeOrder.RfqOrder calldata order)\n        external;\n\n    /// @dev Mark what tx.origin addresses are allowed to fill an order that\n    ///      specifies the message sender as its txOrigin.\n    /// @param origins An array of origin addresses to update.\n    /// @param allowed True to register, false to unregister.\n    function registerAllowedRfqOrigins(address[] memory origins, bool allowed)\n        external;\n\n    /// @dev Cancel multiple limit orders. The caller must be the maker.\n    ///      Silently succeeds if the order has already been cancelled.\n    /// @param orders The limit orders.\n    function batchCancelLimitOrders(LibNativeOrder.LimitOrder[] calldata orders)\n        external;\n\n    /// @dev Cancel multiple RFQ orders. The caller must be the maker.\n    ///      Silently succeeds if the order has already been cancelled.\n    /// @param orders The RFQ orders.\n    function batchCancelRfqOrders(LibNativeOrder.RfqOrder[] calldata orders)\n        external;\n\n    /// @dev Cancel all limit orders for a given maker and pair with a salt less\n    ///      than the value provided. The caller must be the maker. Subsequent\n    ///      calls to this function with the same caller and pair require the\n    ///      new salt to be >= the old salt.\n    /// @param makerToken The maker token.\n    /// @param takerToken The taker token.\n    /// @param minValidSalt The new minimum valid salt.\n    function cancelPairLimitOrders(\n        IERC20TokenV06 makerToken,\n        IERC20TokenV06 takerToken,\n        uint256 minValidSalt\n    )\n        external;\n\n    /// @dev Cancel all limit orders for a given maker and pair with a salt less\n    ///      than the value provided. The caller must be the maker. Subsequent\n    ///      calls to this function with the same caller and pair require the\n    ///      new salt to be >= the old salt.\n    /// @param makerTokens The maker tokens.\n    /// @param takerTokens The taker tokens.\n    /// @param minValidSalts The new minimum valid salts.\n    function batchCancelPairLimitOrders(\n        IERC20TokenV06[] calldata makerTokens,\n        IERC20TokenV06[] calldata takerTokens,\n        uint256[] calldata minValidSalts\n    )\n        external;\n\n    /// @dev Cancel all RFQ orders for a given maker and pair with a salt less\n    ///      than the value provided. The caller must be the maker. Subsequent\n    ///      calls to this function with the same caller and pair require the\n    ///      new salt to be >= the old salt.\n    /// @param makerToken The maker token.\n    /// @param takerToken The taker token.\n    /// @param minValidSalt The new minimum valid salt.\n    function cancelPairRfqOrders(\n        IERC20TokenV06 makerToken,\n        IERC20TokenV06 takerToken,\n        uint256 minValidSalt\n    )\n        external;\n\n    /// @dev Cancel all RFQ orders for a given maker and pair with a salt less\n    ///      than the value provided. The caller must be the maker. Subsequent\n    ///      calls to this function with the same caller and pair require the\n    ///      new salt to be >= the old salt.\n    /// @param makerTokens The maker tokens.\n    /// @param takerTokens The taker tokens.\n    /// @param minValidSalts The new minimum valid salts.\n    function batchCancelPairRfqOrders(\n        IERC20TokenV06[] calldata makerTokens,\n        IERC20TokenV06[] calldata takerTokens,\n        uint256[] calldata minValidSalts\n    )\n        external;\n\n    /// @dev Get the order info for a limit order.\n    /// @param order The limit order.\n    /// @return orderInfo Info about the order.\n    function getLimitOrderInfo(LibNativeOrder.LimitOrder calldata order)\n        external\n        view\n        returns (LibNativeOrder.OrderInfo memory orderInfo);\n\n    /// @dev Get the order info for an RFQ order.\n    /// @param order The RFQ order.\n    /// @return orderInfo Info about the order.\n    function getRfqOrderInfo(LibNativeOrder.RfqOrder calldata order)\n        external\n        view\n        returns (LibNativeOrder.OrderInfo memory orderInfo);\n\n    /// @dev Get the canonical hash of a limit order.\n    /// @param order The limit order.\n    /// @return orderHash The order hash.\n    function getLimitOrderHash(LibNativeOrder.LimitOrder calldata order)\n        external\n        view\n        returns (bytes32 orderHash);\n\n    /// @dev Get the canonical hash of an RFQ order.\n    /// @param order The RFQ order.\n    /// @return orderHash The order hash.\n    function getRfqOrderHash(LibNativeOrder.RfqOrder calldata order)\n        external\n        view\n        returns (bytes32 orderHash);\n\n    /// @dev Get the protocol fee multiplier. This should be multiplied by the\n    ///      gas price to arrive at the required protocol fee to fill a native order.\n    /// @return multiplier The protocol fee multiplier.\n    function getProtocolFeeMultiplier()\n        external\n        view\n        returns (uint32 multiplier);\n\n    /// @dev Get order info, fillable amount, and signature validity for a limit order.\n    ///      Fillable amount is determined using balances and allowances of the maker.\n    /// @param order The limit order.\n    /// @param signature The order signature.\n    /// @return orderInfo Info about the order.\n    /// @return actualFillableTakerTokenAmount How much of the order is fillable\n    ///         based on maker funds, in taker tokens.\n    /// @return isSignatureValid Whether the signature is valid.\n    function getLimitOrderRelevantState(\n        LibNativeOrder.LimitOrder calldata order,\n        LibSignature.Signature calldata signature\n    )\n        external\n        view\n        returns (\n            LibNativeOrder.OrderInfo memory orderInfo,\n            uint128 actualFillableTakerTokenAmount,\n            bool isSignatureValid\n        );\n\n    /// @dev Get order info, fillable amount, and signature validity for an RFQ order.\n    ///      Fillable amount is determined using balances and allowances of the maker.\n    /// @param order The RFQ order.\n    /// @param signature The order signature.\n    /// @return orderInfo Info about the order.\n    /// @return actualFillableTakerTokenAmount How much of the order is fillable\n    ///         based on maker funds, in taker tokens.\n    /// @return isSignatureValid Whether the signature is valid.\n    function getRfqOrderRelevantState(\n        LibNativeOrder.RfqOrder calldata order,\n        LibSignature.Signature calldata signature\n    )\n        external\n        view\n        returns (\n            LibNativeOrder.OrderInfo memory orderInfo,\n            uint128 actualFillableTakerTokenAmount,\n            bool isSignatureValid\n        );\n\n    /// @dev Batch version of `getLimitOrderRelevantState()`, without reverting.\n    ///      Orders that would normally cause `getLimitOrderRelevantState()`\n    ///      to revert will have empty results.\n    /// @param orders The limit orders.\n    /// @param signatures The order signatures.\n    /// @return orderInfos Info about the orders.\n    /// @return actualFillableTakerTokenAmounts How much of each order is fillable\n    ///         based on maker funds, in taker tokens.\n    /// @return isSignatureValids Whether each signature is valid for the order.\n    function batchGetLimitOrderRelevantStates(\n        LibNativeOrder.LimitOrder[] calldata orders,\n        LibSignature.Signature[] calldata signatures\n    )\n        external\n        view\n        returns (\n            LibNativeOrder.OrderInfo[] memory orderInfos,\n            uint128[] memory actualFillableTakerTokenAmounts,\n            bool[] memory isSignatureValids\n        );\n\n    /// @dev Batch version of `getRfqOrderRelevantState()`, without reverting.\n    ///      Orders that would normally cause `getRfqOrderRelevantState()`\n    ///      to revert will have empty results.\n    /// @param orders The RFQ orders.\n    /// @param signatures The order signatures.\n    /// @return orderInfos Info about the orders.\n    /// @return actualFillableTakerTokenAmounts How much of each order is fillable\n    ///         based on maker funds, in taker tokens.\n    /// @return isSignatureValids Whether each signature is valid for the order.\n    function batchGetRfqOrderRelevantStates(\n        LibNativeOrder.RfqOrder[] calldata orders,\n        LibSignature.Signature[] calldata signatures\n    )\n        external\n        view\n        returns (\n            LibNativeOrder.OrderInfo[] memory orderInfos,\n            uint128[] memory actualFillableTakerTokenAmounts,\n            bool[] memory isSignatureValids\n        );\n}\n",
        "@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\n\n\ninterface IERC20TokenV06 {\n\n    // solhint-disable no-simple-event-func-name\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @dev send `value` token to `to` from `msg.sender`\n    /// @param to The address of the recipient\n    /// @param value The amount of token to be transferred\n    /// @return True if transfer was successful\n    function transfer(address to, uint256 value)\n        external\n        returns (bool);\n\n    /// @dev send `value` token to `to` from `from` on the condition it is approved by `from`\n    /// @param from The address of the sender\n    /// @param to The address of the recipient\n    /// @param value The amount of token to be transferred\n    /// @return True if transfer was successful\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n        external\n        returns (bool);\n\n    /// @dev `msg.sender` approves `spender` to spend `value` tokens\n    /// @param spender The address of the account able to transfer the tokens\n    /// @param value The amount of wei to be approved for transfer\n    /// @return Always true if the call has enough gas to complete execution\n    function approve(address spender, uint256 value)\n        external\n        returns (bool);\n\n    /// @dev Query total supply of token\n    /// @return Total supply of token\n    function totalSupply()\n        external\n        view\n        returns (uint256);\n\n    /// @dev Get the balance of `owner`.\n    /// @param owner The address from which the balance will be retrieved\n    /// @return Balance of owner\n    function balanceOf(address owner)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Get the allowance for `spender` to spend from `owner`.\n    /// @param owner The address of the account owning tokens\n    /// @param spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Get the number of decimals this token has.\n    function decimals()\n        external\n        view\n        returns (uint8);\n}\n",
        "../src/features/libs/LibSignature.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-utils/contracts/src/v06/errors/LibRichErrorsV06.sol\";\nimport \"../../errors/LibSignatureRichErrors.sol\";\n\n\n/// @dev A library for validating signatures.\nlibrary LibSignature {\n    using LibRichErrorsV06 for bytes;\n\n    // '\\x19Ethereum Signed Message:\\n32\\x00\\x00\\x00\\x00' in a word.\n    uint256 private constant ETH_SIGN_HASH_PREFIX =\n        0x19457468657265756d205369676e6564204d6573736167653a0a333200000000;\n    /// @dev Exclusive upper limit on ECDSA signatures 'R' values.\n    ///      The valid range is given by fig (282) of the yellow paper.\n    uint256 private constant ECDSA_SIGNATURE_R_LIMIT =\n        uint256(0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141);\n    /// @dev Exclusive upper limit on ECDSA signatures 'S' values.\n    ///      The valid range is given by fig (283) of the yellow paper.\n    uint256 private constant ECDSA_SIGNATURE_S_LIMIT = ECDSA_SIGNATURE_R_LIMIT / 2 + 1;\n\n    /// @dev Allowed signature types.\n    enum SignatureType {\n        ILLEGAL,\n        INVALID,\n        EIP712,\n        ETHSIGN\n    }\n\n    /// @dev Encoded EC signature.\n    struct Signature {\n        // How to validate the signature.\n        SignatureType signatureType;\n        // EC Signature data.\n        uint8 v;\n        // EC Signature data.\n        bytes32 r;\n        // EC Signature data.\n        bytes32 s;\n    }\n\n    /// @dev Retrieve the signer of a signature.\n    ///      Throws if the signature can't be validated.\n    /// @param hash The hash that was signed.\n    /// @param signature The signature.\n    /// @return recovered The recovered signer address.\n    function getSignerOfHash(\n        bytes32 hash,\n        Signature memory signature\n    )\n        internal\n        pure\n        returns (address recovered)\n    {\n        // Ensure this is a signature type that can be validated against a hash.\n        _validateHashCompatibleSignature(hash, signature);\n\n        if (signature.signatureType == SignatureType.EIP712) {\n            // Signed using EIP712\n            recovered = ecrecover(\n                hash,\n                signature.v,\n                signature.r,\n                signature.s\n            );\n        } else if (signature.signatureType == SignatureType.ETHSIGN) {\n            // Signed using `eth_sign`\n            // Need to hash `hash` with \"\\x19Ethereum Signed Message:\\n32\" prefix\n            // in packed encoding.\n            bytes32 ethSignHash;\n            assembly {\n                // Use scratch space\n                mstore(0, ETH_SIGN_HASH_PREFIX) // length of 28 bytes\n                mstore(28, hash) // length of 32 bytes\n                ethSignHash := keccak256(0, 60)\n            }\n            recovered = ecrecover(\n                ethSignHash,\n                signature.v,\n                signature.r,\n                signature.s\n            );\n        }\n        // `recovered` can be null if the signature values are out of range.\n        if (recovered == address(0)) {\n            LibSignatureRichErrors.SignatureValidationError(\n                LibSignatureRichErrors.SignatureValidationErrorCodes.BAD_SIGNATURE_DATA,\n                hash\n            ).rrevert();\n        }\n    }\n\n    /// @dev Validates that a signature is compatible with a hash signee.\n    /// @param hash The hash that was signed.\n    /// @param signature The signature.\n    function _validateHashCompatibleSignature(\n        bytes32 hash,\n        Signature memory signature\n    )\n        private\n        pure\n    {\n        // Ensure the r and s are within malleability limits.\n        if (uint256(signature.r) >= ECDSA_SIGNATURE_R_LIMIT ||\n            uint256(signature.s) >= ECDSA_SIGNATURE_S_LIMIT)\n        {\n            LibSignatureRichErrors.SignatureValidationError(\n                LibSignatureRichErrors.SignatureValidationErrorCodes.BAD_SIGNATURE_DATA,\n                hash\n            ).rrevert();\n        }\n\n        // Always illegal signature.\n        if (signature.signatureType == SignatureType.ILLEGAL) {\n            LibSignatureRichErrors.SignatureValidationError(\n                LibSignatureRichErrors.SignatureValidationErrorCodes.ILLEGAL,\n                hash\n            ).rrevert();\n        }\n\n        // Always invalid.\n        if (signature.signatureType == SignatureType.INVALID) {\n            LibSignatureRichErrors.SignatureValidationError(\n                LibSignatureRichErrors.SignatureValidationErrorCodes.ALWAYS_INVALID,\n                hash\n            ).rrevert();\n        }\n\n        // Solidity should check that the signature type is within enum range for us\n        // when abi-decoding.\n    }\n}\n",
        "@0x/contracts-utils/contracts/src/v06/errors/LibRichErrorsV06.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\n\n\nlibrary LibRichErrorsV06 {\n\n    // bytes4(keccak256(\"Error(string)\"))\n    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n\n    // solhint-disable func-name-mixedcase\n    /// @dev ABI encode a standard, string revert error payload.\n    ///      This is the same payload that would be included by a `revert(string)`\n    ///      solidity statement. It has the function signature `Error(string)`.\n    /// @param message The error string.\n    /// @return The ABI encoded error.\n    function StandardError(string memory message)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            STANDARD_ERROR_SELECTOR,\n            bytes(message)\n        );\n    }\n    // solhint-enable func-name-mixedcase\n\n    /// @dev Reverts an encoded rich revert reason `errorData`.\n    /// @param errorData ABI encoded error data.\n    function rrevert(bytes memory errorData)\n        internal\n        pure\n    {\n        assembly {\n            revert(add(errorData, 0x20), mload(errorData))\n        }\n    }\n}\n",
        "../src/errors/LibSignatureRichErrors.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\n\n\nlibrary LibSignatureRichErrors {\n\n    enum SignatureValidationErrorCodes {\n        ALWAYS_INVALID,\n        INVALID_LENGTH,\n        UNSUPPORTED,\n        ILLEGAL,\n        WRONG_SIGNER,\n        BAD_SIGNATURE_DATA\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    function SignatureValidationError(\n        SignatureValidationErrorCodes code,\n        bytes32 hash,\n        address signerAddress,\n        bytes memory signature\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"SignatureValidationError(uint8,bytes32,address,bytes)\")),\n            code,\n            hash,\n            signerAddress,\n            signature\n        );\n    }\n\n    function SignatureValidationError(\n        SignatureValidationErrorCodes code,\n        bytes32 hash\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"SignatureValidationError(uint8,bytes32)\")),\n            code,\n            hash\n        );\n    }\n}\n",
        "../src/features/libs/LibNativeOrder.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol\";\nimport \"@0x/contracts-utils/contracts/src/v06/errors/LibRichErrorsV06.sol\";\nimport \"@0x/contracts-utils/contracts/src/v06/LibSafeMathV06.sol\";\nimport \"../../errors/LibNativeOrdersRichErrors.sol\";\n\n\n/// @dev A library for common native order operations.\nlibrary LibNativeOrder {\n    using LibSafeMathV06 for uint256;\n    using LibRichErrorsV06 for bytes;\n\n    enum OrderStatus {\n        INVALID,\n        FILLABLE,\n        FILLED,\n        CANCELLED,\n        EXPIRED\n    }\n\n    /// @dev A standard OTC or OO limit order.\n    struct LimitOrder {\n        IERC20TokenV06 makerToken;\n        IERC20TokenV06 takerToken;\n        uint128 makerAmount;\n        uint128 takerAmount;\n        uint128 takerTokenFeeAmount;\n        address maker;\n        address taker;\n        address sender;\n        address feeRecipient;\n        bytes32 pool;\n        uint64 expiry;\n        uint256 salt;\n    }\n\n    /// @dev An RFQ limit order.\n    struct RfqOrder {\n        IERC20TokenV06 makerToken;\n        IERC20TokenV06 takerToken;\n        uint128 makerAmount;\n        uint128 takerAmount;\n        address maker;\n        address taker;\n        address txOrigin;\n        bytes32 pool;\n        uint64 expiry;\n        uint256 salt;\n    }\n\n    /// @dev Info on a limit or RFQ order.\n    struct OrderInfo {\n        bytes32 orderHash;\n        OrderStatus status;\n        uint128 takerTokenFilledAmount;\n    }\n\n    uint256 private constant UINT_128_MASK = (1 << 128) - 1;\n    uint256 private constant UINT_64_MASK = (1 << 64) - 1;\n    uint256 private constant ADDRESS_MASK = (1 << 160) - 1;\n\n    // The type hash for limit orders, which is:\n    // keccak256(abi.encodePacked(\n    //     \"LimitOrder(\",\n    //       \"address makerToken,\",\n    //       \"address takerToken,\",\n    //       \"uint128 makerAmount,\",\n    //       \"uint128 takerAmount,\",\n    //       \"uint128 takerTokenFeeAmount,\",\n    //       \"address maker,\",\n    //       \"address taker,\",\n    //       \"address sender,\",\n    //       \"address feeRecipient,\",\n    //       \"bytes32 pool,\",\n    //       \"uint64 expiry,\",\n    //       \"uint256 salt\"\n    //     \")\"\n    // ))\n    uint256 private constant _LIMIT_ORDER_TYPEHASH =\n        0xce918627cb55462ddbb85e73de69a8b322f2bc88f4507c52fcad6d4c33c29d49;\n\n    // The type hash for RFQ orders, which is:\n    // keccak256(abi.encodePacked(\n    //     \"RfqOrder(\",\n    //       \"address makerToken,\",\n    //       \"address takerToken,\",\n    //       \"uint128 makerAmount,\",\n    //       \"uint128 takerAmount,\",\n    //       \"address maker,\",\n    //       \"address taker,\",\n    //       \"address txOrigin,\",\n    //       \"bytes32 pool,\",\n    //       \"uint64 expiry,\",\n    //       \"uint256 salt\"\n    //     \")\"\n    // ))\n    uint256 private constant _RFQ_ORDER_TYPEHASH =\n        0xe593d3fdfa8b60e5e17a1b2204662ecbe15c23f2084b9ad5bae40359540a7da9;\n\n    /// @dev Get the struct hash of a limit order.\n    /// @param order The limit order.\n    /// @return structHash The struct hash of the order.\n    function getLimitOrderStructHash(LimitOrder memory order)\n        internal\n        pure\n        returns (bytes32 structHash)\n    {\n        // The struct hash is:\n        // keccak256(abi.encode(\n        //   TYPE_HASH,\n        //   order.makerToken,\n        //   order.takerToken,\n        //   order.makerAmount,\n        //   order.takerAmount,\n        //   order.takerTokenFeeAmount,\n        //   order.maker,\n        //   order.taker,\n        //   order.sender,\n        //   order.feeRecipient,\n        //   order.pool,\n        //   order.expiry,\n        //   order.salt,\n        // ))\n        assembly {\n            let mem := mload(0x40)\n            mstore(mem, _LIMIT_ORDER_TYPEHASH)\n            // order.makerToken;\n            mstore(add(mem, 0x20), and(ADDRESS_MASK, mload(order)))\n            // order.takerToken;\n            mstore(add(mem, 0x40), and(ADDRESS_MASK, mload(add(order, 0x20))))\n            // order.makerAmount;\n            mstore(add(mem, 0x60), and(UINT_128_MASK, mload(add(order, 0x40))))\n            // order.takerAmount;\n            mstore(add(mem, 0x80), and(UINT_128_MASK, mload(add(order, 0x60))))\n            // order.takerTokenFeeAmount;\n            mstore(add(mem, 0xA0), and(UINT_128_MASK, mload(add(order, 0x80))))\n            // order.maker;\n            mstore(add(mem, 0xC0), and(ADDRESS_MASK, mload(add(order, 0xA0))))\n            // order.taker;\n            mstore(add(mem, 0xE0), and(ADDRESS_MASK, mload(add(order, 0xC0))))\n            // order.sender;\n            mstore(add(mem, 0x100), and(ADDRESS_MASK, mload(add(order, 0xE0))))\n            // order.feeRecipient;\n            mstore(add(mem, 0x120), and(ADDRESS_MASK, mload(add(order, 0x100))))\n            // order.pool;\n            mstore(add(mem, 0x140), mload(add(order, 0x120)))\n            // order.expiry;\n            mstore(add(mem, 0x160), and(UINT_64_MASK, mload(add(order, 0x140))))\n            // order.salt;\n            mstore(add(mem, 0x180), mload(add(order, 0x160)))\n            structHash := keccak256(mem, 0x1A0)\n        }\n    }\n\n    /// @dev Get the struct hash of a RFQ order.\n    /// @param order The RFQ order.\n    /// @return structHash The struct hash of the order.\n    function getRfqOrderStructHash(RfqOrder memory order)\n        internal\n        pure\n        returns (bytes32 structHash)\n    {\n        // The struct hash is:\n        // keccak256(abi.encode(\n        //   TYPE_HASH,\n        //   order.makerToken,\n        //   order.takerToken,\n        //   order.makerAmount,\n        //   order.takerAmount,\n        //   order.maker,\n        //   order.taker,\n        //   order.txOrigin,\n        //   order.pool,\n        //   order.expiry,\n        //   order.salt,\n        // ))\n        assembly {\n            let mem := mload(0x40)\n            mstore(mem, _RFQ_ORDER_TYPEHASH)\n            // order.makerToken;\n            mstore(add(mem, 0x20), and(ADDRESS_MASK, mload(order)))\n            // order.takerToken;\n            mstore(add(mem, 0x40), and(ADDRESS_MASK, mload(add(order, 0x20))))\n            // order.makerAmount;\n            mstore(add(mem, 0x60), and(UINT_128_MASK, mload(add(order, 0x40))))\n            // order.takerAmount;\n            mstore(add(mem, 0x80), and(UINT_128_MASK, mload(add(order, 0x60))))\n            // order.maker;\n            mstore(add(mem, 0xA0), and(ADDRESS_MASK, mload(add(order, 0x80))))\n            // order.taker;\n            mstore(add(mem, 0xC0), and(ADDRESS_MASK, mload(add(order, 0xA0))))\n            // order.txOrigin;\n            mstore(add(mem, 0xE0), and(ADDRESS_MASK, mload(add(order, 0xC0))))\n            // order.pool;\n            mstore(add(mem, 0x100), mload(add(order, 0xE0)))\n            // order.expiry;\n            mstore(add(mem, 0x120), and(UINT_64_MASK, mload(add(order, 0x100))))\n            // order.salt;\n            mstore(add(mem, 0x140), mload(add(order, 0x120)))\n            structHash := keccak256(mem, 0x160)\n        }\n    }\n\n    /// @dev Refund any leftover protocol fees in `msg.value` to `msg.sender`.\n    /// @param ethProtocolFeePaid How much ETH was paid in protocol fees.\n    function refundExcessProtocolFeeToSender(uint256 ethProtocolFeePaid)\n        internal\n    {\n        if (msg.value > ethProtocolFeePaid && msg.sender != address(this)) {\n            uint256 refundAmount = msg.value.safeSub(ethProtocolFeePaid);\n            (bool success,) = msg\n                .sender\n                .call{value: refundAmount}(\"\");\n            if (!success) {\n                LibNativeOrdersRichErrors.ProtocolFeeRefundFailed(\n                    msg.sender,\n                    refundAmount\n                ).rrevert();\n            }\n        }\n    }\n}\n",
        "@0x/contracts-utils/contracts/src/v06/LibSafeMathV06.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\n\nimport \"./errors/LibRichErrorsV06.sol\";\nimport \"./errors/LibSafeMathRichErrorsV06.sol\";\n\n\nlibrary LibSafeMathV06 {\n\n    function safeMul(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        if (c / a != b) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.MULTIPLICATION_OVERFLOW,\n                a,\n                b\n            ));\n        }\n        return c;\n    }\n\n    function safeDiv(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (b == 0) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.DIVISION_BY_ZERO,\n                a,\n                b\n            ));\n        }\n        uint256 c = a / b;\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (b > a) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.SUBTRACTION_UNDERFLOW,\n                a,\n                b\n            ));\n        }\n        return a - b;\n    }\n\n    function safeAdd(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 c = a + b;\n        if (c < a) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.ADDITION_OVERFLOW,\n                a,\n                b\n            ));\n        }\n        return c;\n    }\n\n    function max256(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    function safeMul128(uint128 a, uint128 b)\n        internal\n        pure\n        returns (uint128)\n    {\n        if (a == 0) {\n            return 0;\n        }\n        uint128 c = a * b;\n        if (c / a != b) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.MULTIPLICATION_OVERFLOW,\n                a,\n                b\n            ));\n        }\n        return c;\n    }\n\n    function safeDiv128(uint128 a, uint128 b)\n        internal\n        pure\n        returns (uint128)\n    {\n        if (b == 0) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.DIVISION_BY_ZERO,\n                a,\n                b\n            ));\n        }\n        uint128 c = a / b;\n        return c;\n    }\n\n    function safeSub128(uint128 a, uint128 b)\n        internal\n        pure\n        returns (uint128)\n    {\n        if (b > a) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.SUBTRACTION_UNDERFLOW,\n                a,\n                b\n            ));\n        }\n        return a - b;\n    }\n\n    function safeAdd128(uint128 a, uint128 b)\n        internal\n        pure\n        returns (uint128)\n    {\n        uint128 c = a + b;\n        if (c < a) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256BinOpError(\n                LibSafeMathRichErrorsV06.BinOpErrorCodes.ADDITION_OVERFLOW,\n                a,\n                b\n            ));\n        }\n        return c;\n    }\n\n    function max128(uint128 a, uint128 b)\n        internal\n        pure\n        returns (uint128)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min128(uint128 a, uint128 b)\n        internal\n        pure\n        returns (uint128)\n    {\n        return a < b ? a : b;\n    }\n\n    function safeDowncastToUint128(uint256 a)\n        internal\n        pure\n        returns (uint128)\n    {\n        if (a > type(uint128).max) {\n            LibRichErrorsV06.rrevert(LibSafeMathRichErrorsV06.Uint256DowncastError(\n                LibSafeMathRichErrorsV06.DowncastErrorCodes.VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT128,\n                a\n            ));\n        }\n        return uint128(a);\n    }\n}\n",
        "@0x/contracts-utils/contracts/src/v06/errors/LibSafeMathRichErrorsV06.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\n\n\nlibrary LibSafeMathRichErrorsV06 {\n\n    // bytes4(keccak256(\"Uint256BinOpError(uint8,uint256,uint256)\"))\n    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR =\n        0xe946c1bb;\n\n    // bytes4(keccak256(\"Uint256DowncastError(uint8,uint256)\"))\n    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR =\n        0xc996af7b;\n\n    enum BinOpErrorCodes {\n        ADDITION_OVERFLOW,\n        MULTIPLICATION_OVERFLOW,\n        SUBTRACTION_UNDERFLOW,\n        DIVISION_BY_ZERO\n    }\n\n    enum DowncastErrorCodes {\n        VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT32,\n        VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT64,\n        VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT96,\n        VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT128\n    }\n\n    // solhint-disable func-name-mixedcase\n    function Uint256BinOpError(\n        BinOpErrorCodes errorCode,\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            UINT256_BINOP_ERROR_SELECTOR,\n            errorCode,\n            a,\n            b\n        );\n    }\n\n    function Uint256DowncastError(\n        DowncastErrorCodes errorCode,\n        uint256 a\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n            errorCode,\n            a\n        );\n    }\n}\n",
        "../src/errors/LibNativeOrdersRichErrors.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\n\n\nlibrary LibNativeOrdersRichErrors {\n\n    // solhint-disable func-name-mixedcase\n\n    function ProtocolFeeRefundFailed(\n        address receiver,\n        uint256 refundAmount\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"ProtocolFeeRefundFailed(address,uint256)\")),\n            receiver,\n            refundAmount\n        );\n    }\n\n    function OrderNotFillableByOriginError(\n        bytes32 orderHash,\n        address txOrigin,\n        address orderTxOrigin\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"OrderNotFillableByOriginError(bytes32,address,address)\")),\n            orderHash,\n            txOrigin,\n            orderTxOrigin\n        );\n    }\n\n    function OrderNotFillableError(\n        bytes32 orderHash,\n        uint8 orderStatus\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"OrderNotFillableError(bytes32,uint8)\")),\n            orderHash,\n            orderStatus\n        );\n    }\n\n    function OrderNotSignedByMakerError(\n        bytes32 orderHash,\n        address signer,\n        address maker\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"OrderNotSignedByMakerError(bytes32,address,address)\")),\n            orderHash,\n            signer,\n            maker\n        );\n    }\n\n    function OrderNotFillableBySenderError(\n        bytes32 orderHash,\n        address sender,\n        address orderSender\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"OrderNotFillableBySenderError(bytes32,address,address)\")),\n            orderHash,\n            sender,\n            orderSender\n        );\n    }\n\n    function OrderNotFillableByTakerError(\n        bytes32 orderHash,\n        address taker,\n        address orderTaker\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"OrderNotFillableByTakerError(bytes32,address,address)\")),\n            orderHash,\n            taker,\n            orderTaker\n        );\n    }\n\n    function CancelSaltTooLowError(\n        uint256 minValidSalt,\n        uint256 oldMinValidSalt\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"CancelSaltTooLowError(uint256,uint256)\")),\n            minValidSalt,\n            oldMinValidSalt\n        );\n    }\n\n    function FillOrKillFailedError(\n        bytes32 orderHash,\n        uint256 takerTokenFilledAmount,\n        uint256 takerTokenFillAmount\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"FillOrKillFailedError(bytes32,uint256,uint256)\")),\n            orderHash,\n            takerTokenFilledAmount,\n            takerTokenFillAmount\n        );\n    }\n\n    function OnlyOrderMakerAllowed(\n        bytes32 orderHash,\n        address sender,\n        address maker\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"OnlyOrderMakerAllowed(bytes32,address,address)\")),\n            orderHash,\n            sender,\n            maker\n        );\n    }\n\n    function BatchFillIncompleteError(\n        bytes32 orderHash,\n        uint256 takerTokenFilledAmount,\n        uint256 takerTokenFillAmount\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            bytes4(keccak256(\"BatchFillIncompleteError(bytes32,uint256,uint256)\")),\n            orderHash,\n            takerTokenFilledAmount,\n            takerTokenFillAmount\n        );\n    }\n}\n",
        "../src/features/interfaces/INativeOrdersEvents.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2021 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol\";\nimport \"../libs/LibSignature.sol\";\nimport \"../libs/LibNativeOrder.sol\";\n\n\n/// @dev Events emitted by NativeOrdersFeature.\ninterface INativeOrdersEvents {\n\n    /// @dev Emitted whenever a `LimitOrder` is filled.\n    /// @param orderHash The canonical hash of the order.\n    /// @param maker The maker of the order.\n    /// @param taker The taker of the order.\n    /// @param feeRecipient Fee recipient of the order.\n    /// @param takerTokenFilledAmount How much taker token was filled.\n    /// @param makerTokenFilledAmount How much maker token was filled.\n    /// @param protocolFeePaid How much protocol fee was paid.\n    /// @param pool The fee pool associated with this order.\n    event LimitOrderFilled(\n        bytes32 orderHash,\n        address maker,\n        address taker,\n        address feeRecipient,\n        address makerToken,\n        address takerToken,\n        uint128 takerTokenFilledAmount,\n        uint128 makerTokenFilledAmount,\n        uint128 takerTokenFeeFilledAmount,\n        uint256 protocolFeePaid,\n        bytes32 pool\n    );\n\n    /// @dev Emitted whenever an `RfqOrder` is filled.\n    /// @param orderHash The canonical hash of the order.\n    /// @param maker The maker of the order.\n    /// @param taker The taker of the order.\n    /// @param takerTokenFilledAmount How much taker token was filled.\n    /// @param makerTokenFilledAmount How much maker token was filled.\n    /// @param pool The fee pool associated with this order.\n    event RfqOrderFilled(\n        bytes32 orderHash,\n        address maker,\n        address taker,\n        address makerToken,\n        address takerToken,\n        uint128 takerTokenFilledAmount,\n        uint128 makerTokenFilledAmount,\n        bytes32 pool\n    );\n\n    /// @dev Emitted whenever a limit or RFQ order is cancelled.\n    /// @param orderHash The canonical hash of the order.\n    /// @param maker The order maker.\n    event OrderCancelled(\n        bytes32 orderHash,\n        address maker\n    );\n\n    /// @dev Emitted whenever Limit orders are cancelled by pair by a maker.\n    /// @param maker The maker of the order.\n    /// @param makerToken The maker token in a pair for the orders cancelled.\n    /// @param takerToken The taker token in a pair for the orders cancelled.\n    /// @param minValidSalt The new minimum valid salt an order with this pair must\n    ///        have.\n    event PairCancelledLimitOrders(\n        address maker,\n        address makerToken,\n        address takerToken,\n        uint256 minValidSalt\n    );\n\n    /// @dev Emitted whenever RFQ orders are cancelled by pair by a maker.\n    /// @param maker The maker of the order.\n    /// @param makerToken The maker token in a pair for the orders cancelled.\n    /// @param takerToken The taker token in a pair for the orders cancelled.\n    /// @param minValidSalt The new minimum valid salt an order with this pair must\n    ///        have.\n    event PairCancelledRfqOrders(\n        address maker,\n        address makerToken,\n        address takerToken,\n        uint256 minValidSalt\n    );\n\n    /// @dev Emitted when new addresses are allowed or disallowed to fill\n    ///      orders with a given txOrigin.\n    /// @param origin The address doing the allowing.\n    /// @param addrs The address being allowed/disallowed.\n    /// @param allowed Indicates whether the address should be allowed.\n    event RfqOrderOriginsAllowed(\n        address origin,\n        address[] addrs,\n        bool allowed\n    );\n}\n"
    },
    "compiler": {
        "name": "solc",
        "version": "0.6.12+commit.27d51765",
        "settings": {
            "remappings": [
                "@0x/contracts-utils=/Users/michaelzhu/protocol/node_modules/@0x/contracts-utils",
                "@0x/contracts-erc20=/Users/michaelzhu/protocol/contracts/zero-ex/node_modules/@0x/contracts-erc20"
            ],
            "optimizer": {
                "enabled": true,
                "runs": 1000000,
                "details": {
                    "yul": true,
                    "deduplicate": true,
                    "cse": true,
                    "constantOptimizer": true
                }
            },
            "outputSelection": {
                "*": {
                    "*": [
                        "abi",
                        "devdoc",
                        "evm.bytecode.object",
                        "evm.bytecode.sourceMap",
                        "evm.deployedBytecode.object",
                        "evm.deployedBytecode.sourceMap",
                        "evm.methodIdentifiers"
                    ]
                }
            },
            "evmVersion": "istanbul"
        }
    },
    "chains": {}
}
