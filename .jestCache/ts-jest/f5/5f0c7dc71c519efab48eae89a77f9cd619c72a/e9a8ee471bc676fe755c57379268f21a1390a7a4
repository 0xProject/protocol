[["/Users/davidwalsh/code-local/0x-rfq-api/test/configureTestEnv.ts",{"fileContent":"import * as chai from 'chai';\nimport * as chaiAsPromised from 'chai-as-promised';\nimport { config } from 'dotenv';\n\n// Use the custom .env file\nconfig({ path: './test/test_env' });\n\n// Use chai as promied\nchai.use(chaiAsPromised);\n\n// Silence calls to `logger` in code under test.\n// Comment out this line to see logger output.\nprocess.env.LOG_LEVEL = 'silent';\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/rfqm_db_test.ts",{"fileContent":"import { MetaTransaction, MetaTransactionFields, OtcOrder, Signature } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { expect } from 'chai';\nimport { DataSource } from 'typeorm';\nimport * as uuid from 'uuid';\n\nimport { EXECUTE_META_TRANSACTION_EIP_712_TYPES, ONE_MINUTE_MS, ZERO } from '../src/core/constants';\nimport { feeToStoredFee, storedFeeToFee } from '../src/core/fee_utils';\nimport { MetaTransactionSubmissionEntityConstructorOpts } from '../src/entities/MetaTransactionSubmissionEntity';\nimport { RfqmV2TransactionSubmissionEntityConstructorOpts } from '../src/entities/RfqmV2TransactionSubmissionEntity';\nimport { RfqmJobStatus, RfqmTransactionSubmissionStatus, RfqmTransactionSubmissionType } from '../src/entities/types';\nimport { ExecuteMetaTransactionApproval, Fee, GaslessApprovalTypes } from '../src/core/types';\nimport { otcOrderToStoredOtcOrder, RfqmDbUtils, storedOtcOrderToOtcOrder } from '../src/utils/rfqm_db_utils';\n\nimport { MOCK_FEE, MOCK_META_TRANSACTION } from './constants';\nimport { setupDependenciesAsync, TeardownDependenciesFunctionHandle } from './test_utils/deployment';\nimport { initDbDataSourceAsync } from './test_utils/initDbDataSourceAsync';\n\nlet dbUtils: RfqmDbUtils;\n\nconst createdAt = new Date();\n// it's expired if it's over 9000\nconst expiry = new BigNumber(9000);\nconst chainId = 1;\nconst makerUri = 'https://marketmaking.over9000.io';\nconst fee: Fee = {\n    token: '0xatoken',\n    amount: new BigNumber(5),\n    type: 'fixed',\n};\n\nconst otcOrderNonce = new BigNumber(1637085289);\nconst otcOrder = new OtcOrder({\n    txOrigin: '0x0000000000000000000000000000000000000000',\n    taker: '0x1111111111111111111111111111111111111111',\n    maker: '0x2222222222222222222222222222222222222222',\n    makerToken: '0x3333333333333333333333333333333333333333',\n    takerToken: '0x4444444444444444444444444444444444444444',\n    expiryAndNonce: OtcOrder.encodeExpiryAndNonce(expiry, ZERO, otcOrderNonce),\n    chainId,\n    verifyingContract: '0x0000000000000000000000000000000000000000',\n});\n\nconst otcOrderHash = otcOrder.getHash();\n\nconst takerSignature: Signature = {\n    v: 27,\n    r: '0xd00d00',\n    s: '0xcaca',\n    signatureType: 1,\n};\n\nconst approval: ExecuteMetaTransactionApproval = {\n    kind: GaslessApprovalTypes.ExecuteMetaTransaction,\n    eip712: {\n        types: {\n            EIP712Domain: [\n                { name: 'name', type: 'string' },\n                { name: 'version', type: 'string' },\n                { name: 'verifyingContract', type: 'address' },\n                { name: 'salt', type: 'bytes32' },\n            ],\n            ...EXECUTE_META_TRANSACTION_EIP_712_TYPES,\n        },\n        primaryType: 'MetaTransaction',\n        domain: {\n            name: 'Balancer (PoS)',\n            version: '1',\n            verifyingContract: '0x9a71012b13ca4d3d0cdc72a177df3ef03b0e76a3',\n            salt: '0x0000000000000000000000000000000000000000000000000000000000000089',\n        },\n        message: {\n            nonce: 1,\n            from: '0x1111111111111111111111111111111111111111',\n            functionSignature:\n                '0x095ea7b3000000000000000000000000def1c0ded9bec7f1a1670819833240f027b25effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',\n        },\n    },\n};\n\n// tx properties\nconst transactionHash = '0x5678';\nconst from = '0xanRfqmWorker';\nconst to = '0xexchangeProxyAddress';\nconst gasPrice = new BigNumber('100');\nconst gasUsed = null;\nconst blockMined = null;\nconst nonce = 0;\n\n// meta-transaction\nconst inputToken = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48';\nconst outputToken = '0xdAC17F958D2ee523a2206206994597C13D831ec7';\nconst inputTokenAmount = new BigNumber(100);\nconst minOutputTokenAmount = new BigNumber(99);\n\nfunction creatMockMetaTransaction(opts: Partial<MetaTransactionFields> = {}): MetaTransaction {\n    return new MetaTransaction({\n        ...MOCK_META_TRANSACTION,\n        ...opts,\n    });\n}\n\n// tslint:disable-next-line: custom-no-magic-numbers\njest.setTimeout(ONE_MINUTE_MS * 3);\nlet teardownDependencies: TeardownDependenciesFunctionHandle;\nlet dataSource: DataSource;\n\ndescribe('RFQM Database', () => {\n    beforeAll(async () => {\n        teardownDependencies = await setupDependenciesAsync(['postgres']);\n        dataSource = await initDbDataSourceAsync();\n        dbUtils = new RfqmDbUtils(dataSource);\n    });\n\n    afterAll(async () => {\n        if (!teardownDependencies()) {\n            throw new Error('Failed to tear down dependencies');\n        }\n    });\n\n    afterEach(async () => {\n        await dataSource.query('TRUNCATE TABLE rfqm_quotes CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_jobs CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_transaction_submissions CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_v2_quotes CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_v2_jobs CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_v2_transaction_submissions CASCADE;');\n        await dataSource.query('TRUNCATE TABLE meta_transaction_submissions CASCADE;');\n        await dataSource.query('TRUNCATE TABLE meta_transaction_jobs CASCADE;');\n    });\n    describe('v2 tables', () => {\n        it('should be able to write to and read from the rfqm_v2_quote table', async () => {\n            await dbUtils.writeV2QuoteAsync({\n                chainId,\n                makerUri,\n                isUnwrap: false,\n                order: otcOrderToStoredOtcOrder(otcOrder),\n                orderHash: otcOrderHash,\n                fee: feeToStoredFee(fee),\n                takerSpecifiedSide: 'takerToken',\n            });\n\n            const storedQuote = await dbUtils.findV2QuoteByOrderHashAsync(otcOrderHash);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-non-null-asserted-optional-chain\n            expect(otcOrder).to.deep.eq(storedOtcOrderToOtcOrder(storedQuote?.order!));\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-non-null-asserted-optional-chain\n            expect(fee).to.deep.eq(storedFeeToFee(storedQuote?.fee!));\n\n            expect(storedQuote?.takerSpecifiedSide).to.equal('takerToken');\n        });\n\n        it('should be able to write, update, and read the rfqm_v2_job table', async () => {\n            // Write\n            await dbUtils.writeV2JobAsync({\n                approval,\n                chainId,\n                status: RfqmJobStatus.PendingProcessing,\n                expiry: otcOrder.expiry,\n                makerUri,\n                isUnwrap: false,\n                order: otcOrderToStoredOtcOrder(otcOrder),\n                takerSignature,\n                orderHash: otcOrderHash,\n                fee: feeToStoredFee(fee),\n                takerSpecifiedSide: 'makerToken',\n            });\n\n            // First Read\n            const storedJob = await dbUtils.findV2JobByOrderHashAsync(otcOrderHash);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-non-null-asserted-optional-chain\n            expect(storedOtcOrderToOtcOrder(storedJob?.order!)).to.deep.eq(otcOrder);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-non-null-asserted-optional-chain\n            expect(storedFeeToFee(storedJob?.fee!)).to.deep.eq(fee);\n            expect(storedJob?.status).to.equal(RfqmJobStatus.PendingProcessing);\n            expect(storedJob?.takerSignature).to.deep.eq(takerSignature);\n            expect(storedJob?.approval).to.deep.eq(approval);\n\n            // Update\n            await dbUtils.updateV2JobAsync(otcOrderHash, true, { status: RfqmJobStatus.SucceededConfirmed });\n\n            // Second Read\n            const updatedJob = await dbUtils.findV2JobByOrderHashAsync(otcOrderHash);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-non-null-asserted-optional-chain\n            expect(storedOtcOrderToOtcOrder(updatedJob?.order!)).to.deep.eq(otcOrder);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-non-null-asserted-optional-chain\n            expect(storedFeeToFee(updatedJob?.fee!)).to.deep.eq(fee);\n            expect(updatedJob?.status).to.equal(RfqmJobStatus.SucceededConfirmed);\n            expect(updatedJob?.takerSpecifiedSide).to.equal('makerToken');\n        });\n\n        it('should be able to find by status across the rfqm_v2_job table', async () => {\n            // Write job with failed status\n            await dbUtils.writeV2JobAsync({\n                chainId,\n                status: RfqmJobStatus.FailedEthCallFailed,\n                expiry: otcOrder.expiry,\n                makerUri,\n                isUnwrap: false,\n                order: otcOrderToStoredOtcOrder(otcOrder),\n                orderHash: otcOrderHash,\n                fee: feeToStoredFee(fee),\n                takerSpecifiedSide: 'makerToken',\n            });\n\n            // Get jobs with that status\n            const storedJobs = await dbUtils.findV2JobsWithStatusesAsync([RfqmJobStatus.FailedEthCallFailed]);\n            expect(storedJobs.length).to.equal(1);\n\n            // Confirm correctness\n            const storedJob = storedJobs[0];\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-non-null-asserted-optional-chain\n            expect(storedOtcOrderToOtcOrder(storedJob?.order!)).to.deep.eq(otcOrder);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-non-null-asserted-optional-chain\n            expect(storedFeeToFee(storedJob?.fee!)).to.deep.eq(fee);\n            expect(storedJob?.status).to.equal(RfqmJobStatus.FailedEthCallFailed);\n        });\n\n        it('should be able to write to and read from the last_look_rejection_cooldowns table', async () => {\n            const makerId = 'makerId1';\n            const nowMs = Date.now();\n            const startTime = new Date(nowMs);\n            const endTime = new Date(nowMs + ONE_MINUTE_MS);\n            await dbUtils.writeV2LastLookRejectionCooldownAsync(\n                makerId,\n                chainId,\n                otcOrder.makerToken,\n                otcOrder.takerToken,\n                startTime,\n                endTime,\n                otcOrderHash,\n            );\n\n            const storedCooldown = await dbUtils.findV2LastLookRejectionCooldownAsync(\n                makerId,\n                chainId,\n                otcOrder.makerToken,\n                otcOrder.takerToken,\n                startTime,\n            );\n            expect(storedCooldown?.endTime).to.deep.eq(endTime);\n            expect(storedCooldown?.orderHash).to.deep.eq(otcOrderHash);\n        });\n\n        it('should be able to write, update, and read the rfqm_v2_transaction_submission table', async () => {\n            // Write\n            const rfqmTransactionSubmissionEntityOpts: RfqmV2TransactionSubmissionEntityConstructorOpts = {\n                transactionHash,\n                orderHash: otcOrderHash,\n                createdAt,\n                from,\n                to,\n                gasPrice,\n                gasUsed,\n                blockMined,\n                nonce,\n                status: RfqmTransactionSubmissionStatus.Submitted,\n                type: RfqmTransactionSubmissionType.Trade,\n            };\n            await dbUtils.writeV2TransactionSubmissionAsync(rfqmTransactionSubmissionEntityOpts);\n\n            // First Read\n            const transactionSubmissions = await dbUtils.findV2TransactionSubmissionsByOrderHashAsync(otcOrderHash);\n            expect(transactionSubmissions.length).to.equal(1);\n\n            const transactionSubmission = transactionSubmissions[0];\n            expect(transactionSubmission.transactionHash).to.equal(transactionHash);\n            expect(transactionSubmission.status).to.equal(RfqmTransactionSubmissionStatus.Submitted);\n\n            // Update\n            await dbUtils.updateV2TransactionSubmissionsAsync([\n                {\n                    ...transactionSubmission,\n                    status: RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                },\n            ]);\n\n            // Second Read\n            const updatedTransactionSubmissions = await dbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                otcOrderHash,\n            );\n            expect(updatedTransactionSubmissions.length).to.equal(1);\n\n            const updatedTransactionSubmission = updatedTransactionSubmissions[0];\n            expect(updatedTransactionSubmission.transactionHash).to.equal(transactionHash);\n            expect(updatedTransactionSubmission.status).to.equal(RfqmTransactionSubmissionStatus.SucceededConfirmed);\n        });\n\n        it('should not run into duplicate key issues if attempting to write to the same hash', async () => {\n            // Write\n            const rfqmTransactionSubmissionEntityOpts: RfqmV2TransactionSubmissionEntityConstructorOpts = {\n                transactionHash,\n                orderHash: otcOrderHash,\n                createdAt,\n                from,\n                to,\n                gasPrice,\n                gasUsed,\n                blockMined,\n                nonce,\n                status: RfqmTransactionSubmissionStatus.Submitted,\n                type: RfqmTransactionSubmissionType.Trade,\n            };\n            await dbUtils.writeV2TransactionSubmissionAsync(rfqmTransactionSubmissionEntityOpts);\n\n            // Write again - should not error\n            await dbUtils.writeV2TransactionSubmissionAsync(rfqmTransactionSubmissionEntityOpts);\n\n            // Read\n            const transactionSubmissions = await dbUtils.findV2TransactionSubmissionsByOrderHashAsync(otcOrderHash);\n            expect(transactionSubmissions.length).to.equal(1);\n\n            const transactionSubmission = transactionSubmissions[0];\n            expect(transactionSubmission.transactionHash).to.equal(transactionHash);\n            expect(transactionSubmission.status).to.equal(RfqmTransactionSubmissionStatus.Submitted);\n        });\n    });\n\n    describe('meta transaction tables', () => {\n        it('should be able to write to, update, and read from the `meta_transaction_jobs` table', async () => {\n            const metaTransaction = creatMockMetaTransaction();\n            const metaTransactionHash = metaTransaction.getHash();\n            // Write\n            const savedJob = await dbUtils.writeMetaTransactionJobAsync({\n                approval,\n                chainId: 1,\n                expiry: new BigNumber(2),\n                fee: MOCK_FEE,\n                inputToken,\n                inputTokenAmount,\n                integratorId: 'integrator',\n                metaTransaction,\n                metaTransactionHash,\n                minOutputTokenAmount,\n                outputToken,\n                takerAddress: '0xaddress',\n                takerSignature,\n            });\n            expect(savedJob.id).to.not.equal(null);\n\n            // Read\n            const job = await dbUtils.findMetaTransactionJobByMetaTransactionHashAsync(metaTransactionHash);\n            if (!job) {\n                throw new Error('job should exist');\n            }\n            expect(job.metaTransaction).to.eql(metaTransaction);\n            expect(job.fee).to.eql(MOCK_FEE);\n            expect(job.status).to.eql(RfqmJobStatus.PendingEnqueued);\n            expect(job.approval).to.eql(approval);\n            expect(job.workerAddress).to.eql(null);\n\n            // Update\n            job.chainId = 1;\n            await dbUtils.updateRfqmJobAsync(job);\n\n            // Read\n            const updatedJob = await dbUtils.findMetaTransactionJobByIdAsync(job.id);\n            if (!updatedJob) {\n                throw new Error('job should exist');\n            }\n            expect(updatedJob.metaTransaction).to.eql(metaTransaction);\n            expect(updatedJob.fee).to.eql(MOCK_FEE);\n            expect(updatedJob.status).to.eql(RfqmJobStatus.PendingEnqueued);\n            expect(updatedJob.approval).to.eql(approval);\n            expect(updatedJob.workerAddress).to.eql(null);\n            expect(updatedJob.chainId).to.eql(1);\n        });\n\n        it('should be able to find by status across the `meta_transaction_jobs` table', async () => {\n            const metaTransaction = creatMockMetaTransaction();\n            const metaTransactionHash = metaTransaction.getHash();\n            // Write\n            const savedJob = await dbUtils.writeMetaTransactionJobAsync({\n                approval,\n                chainId: 1,\n                expiry: new BigNumber(2),\n                fee: MOCK_FEE,\n                inputToken,\n                inputTokenAmount,\n                integratorId: 'integrator',\n                metaTransaction,\n                metaTransactionHash,\n                minOutputTokenAmount,\n                outputToken,\n                takerAddress: '0xaddress',\n                takerSignature,\n                status: RfqmJobStatus.FailedExpired,\n            });\n            expect(savedJob.id).to.not.equal(null);\n\n            // Read\n            const jobs = await dbUtils.findMetaTransactionJobsWithStatusesAsync([RfqmJobStatus.FailedExpired]);\n            expect(jobs.length).to.equal(1);\n            expect(jobs[0].metaTransaction).to.eql(metaTransaction);\n            expect(jobs[0].fee).to.eql(MOCK_FEE);\n            expect(jobs[0].status).to.eql(RfqmJobStatus.FailedExpired);\n            expect(jobs[0].approval).to.eql(approval);\n            expect(jobs[0].workerAddress).to.eql(null);\n        });\n\n        it('should be able to find unsolved meta transaction jobs in the `meta_transaction_jobs` table', async () => {\n            const mockMetaTransaction1 = creatMockMetaTransaction();\n            const savedJob = await dbUtils.writeMetaTransactionJobAsync({\n                approval,\n                chainId: 1,\n                expiry: new BigNumber(2),\n                fee: MOCK_FEE,\n                id: '1',\n                integratorId: 'integrator',\n                inputToken,\n                inputTokenAmount,\n                metaTransaction: mockMetaTransaction1,\n                metaTransactionHash: mockMetaTransaction1.getHash(),\n                minOutputTokenAmount,\n                outputToken,\n                takerAddress: '0xaddress',\n                takerSignature,\n                status: RfqmJobStatus.PendingEnqueued,\n            });\n            expect(savedJob.id).to.not.equal(null);\n\n            const mockMetaTransaction2 = creatMockMetaTransaction({ signer: '0xabcdef2' });\n            await dbUtils.writeMetaTransactionJobAsync({\n                approval,\n                chainId: 2,\n                expiry: new BigNumber(2),\n                fee: MOCK_FEE,\n                inputToken,\n                inputTokenAmount,\n                integratorId: 'integrator',\n                metaTransaction: mockMetaTransaction2,\n                metaTransactionHash: mockMetaTransaction2.getHash(),\n                minOutputTokenAmount,\n                outputToken,\n                takerAddress: '0xaddress',\n                takerSignature,\n                status: RfqmJobStatus.PendingProcessing,\n                workerAddress: '0xworkerAddress',\n            });\n\n            const mockMetaTransaction3 = creatMockMetaTransaction({ signer: '0xabcdef3' });\n            await dbUtils.writeMetaTransactionJobAsync({\n                approval,\n                chainId: 3,\n                expiry: new BigNumber(2),\n                fee: MOCK_FEE,\n                inputToken,\n                inputTokenAmount,\n                integratorId: 'integrator',\n                metaTransaction: mockMetaTransaction3,\n                metaTransactionHash: mockMetaTransaction3.getHash(),\n                minOutputTokenAmount,\n                outputToken,\n                takerAddress: '0xaddress',\n                takerSignature,\n                status: RfqmJobStatus.FailedExpired,\n            });\n\n            const jobs = await dbUtils.findUnresolvedMetaTransactionJobsAsync('0xworkerAddress', 2);\n            expect(jobs.length).to.equal(1);\n            expect(jobs[0].status).to.eql(RfqmJobStatus.PendingProcessing);\n        });\n\n        it('should be able to write, update, and read the `meta_transaction_submissions` table', async () => {\n            const metaTransactionJobId = uuid.v4();\n            // Write\n            const metaTransactionSubmissionEntityOpts: MetaTransactionSubmissionEntityConstructorOpts = {\n                from,\n                metaTransactionJobId,\n                nonce,\n                to,\n                transactionHash,\n                type: RfqmTransactionSubmissionType.Trade,\n                status: RfqmTransactionSubmissionStatus.SucceededUnconfirmed,\n            };\n            const savedSubmission = await dbUtils.writeMetaTransactionSubmissionAsync(\n                metaTransactionSubmissionEntityOpts,\n            );\n            expect(savedSubmission.id).not.equal(null);\n\n            // First Read\n            let transactionSubmissions = await dbUtils.findMetaTransactionSubmissionsByTransactionHashAsync(\n                transactionHash,\n                RfqmTransactionSubmissionType.Trade,\n            );\n            expect(transactionSubmissions.length).to.equal(1);\n\n            let transactionSubmission = transactionSubmissions[0];\n            expect(transactionSubmission.transactionHash).to.equal(transactionHash);\n            expect(transactionSubmission.status).to.equal(RfqmTransactionSubmissionStatus.SucceededUnconfirmed);\n\n            // Update\n            await dbUtils.updateRfqmTransactionSubmissionsAsync([\n                {\n                    ...transactionSubmission,\n                    status: RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                },\n            ]);\n\n            // Second Read\n            const updatedTransactionSubmissionOrNull = await dbUtils.findMetaTransactionSubmissionByIdAsync(\n                transactionSubmission.id,\n            );\n            if (!updatedTransactionSubmissionOrNull) {\n                expect.fail('result should not be null');\n            }\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            expect(updatedTransactionSubmissionOrNull!.transactionHash).to.equal(transactionHash);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            expect(updatedTransactionSubmissionOrNull!.status).to.equal(\n                RfqmTransactionSubmissionStatus.SucceededConfirmed,\n            );\n\n            // Third read\n            transactionSubmissions = await dbUtils.findMetaTransactionSubmissionsByJobIdAsync(metaTransactionJobId);\n            expect(transactionSubmissions.length).to.equal(1);\n\n            transactionSubmission = transactionSubmissions[0];\n            expect(transactionSubmission.transactionHash).to.equal(transactionHash);\n            expect(transactionSubmission.status).to.equal(RfqmTransactionSubmissionStatus.SucceededConfirmed);\n        });\n    });\n});\n// tslint:disable-line:max-file-line-count\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/deployment.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/initDbDataSourceAsync.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/getDbDataSourceAsync.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { linearBuckets } from 'prom-client';\n\n// tslint:disable:custom-no-magic-numbers\n\nexport const NULL_ADDRESS = '0x0000000000000000000000000000000000000000';\nexport const NULL_BYTES = '0x';\nexport const ZERO = new BigNumber(0);\nexport const DEFAULT_LOCAL_POSTGRES_URI = 'postgres://api:api@localhost/api';\nexport const DEFAULT_SENTRY_ENVIRONMENT = 'development';\nexport const DEFAULT_LOCAL_REDIS_URI = 'redis://localhost';\nexport const DEFAULT_LOGGER_INCLUDE_TIMESTAMP = true;\nexport const ONE_SECOND_MS = 1000;\nexport const ONE_MINUTE_S = 60;\nexport const ONE_HOUR_S = ONE_MINUTE_S * 60;\nexport const ONE_MINUTE_MS = ONE_SECOND_MS * 60;\nexport const TEN_MINUTES_MS = ONE_MINUTE_MS * 10;\nexport const HEX_BASE = 16;\n\n// Constant to convert number of bps to ratio. E.g. 5 bps = 5 * 0.0001\nexport const BPS_TO_RATIO = 0.0001;\n\n// Gasless OtcOrder constants\nexport const GASLESS_OTC_ORDER_NUM_BUCKETS = 1000;\n\n// RFQM Service\nexport const KEEP_ALIVE_TTL = ONE_MINUTE_MS * 5;\nexport const DEFAULT_WORKER_TRANSACTION_WATCHER_SLEEP_TIME_MS = ONE_SECOND_MS * 15;\n\n// API namespaces\nexport const METRICS_PATH = '/metrics';\nexport const RFQM_PATH = '/rfqm/v1';\nexport const RFQT_V1_PATH = '/rfqt/v1'; // RFQt should be internal in general, but as v1 will be deprecated soon we won't update it.\nexport const RFQT_V2_PATH = '/internal/rfqt/v2';\nexport const ZERO_G_ALIAS_PATH = '/zero-gas/swap/v1';\nexport const ZERO_G_PATH = '/zero-g/swap/v1';\nexport const TX_RELAY_V1_PATH = '/tx-relay/v1/swap';\nexport const RFQ_MAKER_PATH = '/maker/v1';\nexport const RFQ_MAKER_API_KEY_HEADER = '0x-maker-api-key';\nexport const HEALTHCHECK_PATH = '/healthz';\nexport const ADMIN_PATH = '/admin/v1';\n\n// Meta Transactions\nexport const DEFAULT_ETH_GAS_STATION_API_URL = 'https://ethgasstation.api.0x.org/api/ethgasAPI.json';\n\n// TransactionWatcher\n// The expected time of a transaction to be mined according to ETHGasStation\n// \"Fast\" gas price estimations multiplied by a safety margin.\nexport const DEFAULT_EXPECTED_MINED_SEC = 120 * 1.5;\nexport const ETH_DECIMALS = 18;\nexport const GWEI_DECIMALS = 9;\n\n// RFQ quote minimum expiry\nexport const DEFAULT_MIN_EXPIRY_DURATION_MS = ONE_MINUTE_MS;\n\nexport const RFQ_ALLOWANCE_TARGET = '0xdef1c0ded9bec7f1a1670819833240f027b25eff';\nexport const RFQM_TX_GAS_ESTIMATE = 165e3;\nexport const RFQM_TX_OTC_ORDER_GAS_ESTIMATE = 100e3;\nexport const ZEROG_METATX_GAS_ESTIMATE = 500e3;\n\n// SQS Client\nexport const LONG_POLLING_WAIT_TIME_SECONDS = 20;\nexport const SINGLE_MESSAGE = 1;\n\n// Prometheus shared metrics\nexport const PROMETHEUS_REQUEST_BUCKETS = linearBuckets(0, 0.25, 25); // [ 0,  0.25,  0.5,  0.75, ... 5 ]\n\n// Redis Client\nexport const MAKER_TOKEN_BALANCE_EXPIRY_SECONDS = 30;\n\n// Default list of background jobs that the processor would execute\nexport const DEFAULT_BACKGROUND_JOB_TYPES = 'no_op';\n\nexport const EXECUTE_META_TRANSACTION_EIP_712_TYPES = {\n    MetaTransaction: [\n        { name: 'nonce', type: 'uint256' },\n        { name: 'from', type: 'address' },\n        { name: 'functionSignature', type: 'bytes' },\n    ],\n};\n\nexport const PERMIT_EIP_712_TYPES = {\n    Permit: [\n        { name: 'owner', type: 'address' },\n        { name: 'spender', type: 'address' },\n        { name: 'value', type: 'uint256' },\n        { name: 'nonce', type: 'uint256' },\n        { name: 'deadline', type: 'uint256' },\n    ],\n};\n\n// Default buffer for gas estimation returned by `eth_estimateGas`. For example, 0.5 means to\n// add a 50% buffer.\nexport const GAS_ESTIMATE_BUFFER = 0.5;\n\n// Time window to apply last look rejections (LLRs) cooldown, in seconds. Any LLRs for quotes\n// submited within the window are considered as `bad` LLRs, and the maker will be cooldown.\nexport const LLR_COOLDOWN_WINDOW_SECONDS = 30;\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\n\nimport { Fee, FeeWithDetails, StoredFee } from './types';\n\nconst tokenPriceUsdToString = (tokenPriceUsd: BigNumber | null): string | undefined => {\n    if (tokenPriceUsd === null) {\n        return undefined;\n    }\n    return tokenPriceUsd.toString();\n};\n\nconst isInstanceOfFeeWithDetails = (fee: Fee): fee is FeeWithDetails => {\n    return 'details' in fee;\n};\n\nconst isInstanceOfFeeWithBreakdown = (fee: Fee): fee is FeeWithDetails => {\n    return 'breakdown' in fee && 'conversionRates' in fee;\n};\n\nexport const feeToStoredFee = (fee: Fee): StoredFee => {\n    let details;\n    if (isInstanceOfFeeWithDetails(fee)) {\n        switch (fee.details.kind) {\n            case 'default':\n                details = {\n                    kind: fee.details.kind,\n                    feeModelVersion: fee.details.feeModelVersion,\n                    gasFeeAmount: fee.details.gasFeeAmount.toString(),\n                    gasPrice: fee.details.gasPrice.toString(),\n                    tradeSizeBps: fee.details.tradeSizeBps,\n                    zeroExFeeAmount: fee.details.zeroExFeeAmount.toString(),\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    feeTokenBaseUnitPriceUsd: tokenPriceUsdToString(fee.details.feeTokenBaseUnitPriceUsd!),\n                    takerTokenBaseUnitPriceUsd: tokenPriceUsdToString(fee.details.takerTokenBaseUnitPriceUsd),\n                    makerTokenBaseUnitPriceUsd: tokenPriceUsdToString(fee.details.makerTokenBaseUnitPriceUsd),\n                };\n                break;\n            case 'margin':\n                details = {\n                    kind: fee.details.kind,\n                    feeModelVersion: fee.details.feeModelVersion,\n                    gasFeeAmount: fee.details.gasFeeAmount.toString(),\n                    gasPrice: fee.details.gasPrice.toString(),\n                    margin: fee.details.margin.toString(),\n                    marginRakeRatio: fee.details.marginRakeRatio,\n                    zeroExFeeAmount: fee.details.zeroExFeeAmount.toString(),\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    feeTokenBaseUnitPriceUsd: tokenPriceUsdToString(fee.details.feeTokenBaseUnitPriceUsd!),\n                    takerTokenBaseUnitPriceUsd: tokenPriceUsdToString(fee.details.takerTokenBaseUnitPriceUsd),\n                    makerTokenBaseUnitPriceUsd: tokenPriceUsdToString(fee.details.makerTokenBaseUnitPriceUsd),\n                };\n                break;\n            case 'gasOnly':\n            default:\n                details = {\n                    kind: fee.details.kind,\n                    feeModelVersion: fee.details.feeModelVersion,\n                    gasFeeAmount: fee.details.gasFeeAmount.toString(),\n                    gasPrice: fee.details.gasPrice.toString(),\n                };\n        }\n    }\n\n    let breakdown, conversionRates;\n    if (isInstanceOfFeeWithBreakdown(fee)) {\n        if (fee.breakdown) {\n            let gas, zeroEx;\n            if (fee.breakdown.gas) {\n                gas = {\n                    amount: fee.breakdown.gas.amount.toString(),\n                    details: {\n                        gasPrice: fee.breakdown.gas.details.gasPrice.toString(),\n                        estimatedGas: fee.breakdown.gas.details.estimatedGas.toString(),\n                    },\n                };\n            }\n            if (fee.breakdown.zeroEx) {\n                let details;\n                switch (fee.breakdown.zeroEx.details.kind) {\n                    case 'volume':\n                        details = {\n                            kind: fee.breakdown.zeroEx.details.kind,\n                            tradeSizeBps: fee.breakdown.zeroEx.details.tradeSizeBps,\n                        };\n                        break;\n                    case 'price_improvement':\n                        details = {\n                            kind: fee.breakdown.zeroEx.details.kind,\n                            priceImprovement: fee.breakdown.zeroEx.details.priceImprovement.toString(),\n                            rakeRatio: fee.breakdown.zeroEx.details.rakeRatio,\n                        };\n                        break;\n                    default:\n                        throw new Error(`Invalide zeroEx fee details: ${JSON.stringify(fee.breakdown.zeroEx.details)}`);\n                }\n                zeroEx = {\n                    amount: fee.breakdown.zeroEx.amount.toString(),\n                    details,\n                };\n            }\n            breakdown = {\n                gas,\n                zeroEx,\n            };\n        }\n        if (fee.conversionRates) {\n            conversionRates = {\n                nativeTokenBaseUnitPriceUsd: tokenPriceUsdToString(fee.conversionRates.nativeTokenBaseUnitPriceUsd),\n                feeTokenBaseUnitPriceUsd: tokenPriceUsdToString(fee.conversionRates.feeTokenBaseUnitPriceUsd),\n                takerTokenBaseUnitPriceUsd: tokenPriceUsdToString(fee.conversionRates.takerTokenBaseUnitPriceUsd),\n                makerTokenBaseUnitPriceUsd: tokenPriceUsdToString(fee.conversionRates.makerTokenBaseUnitPriceUsd),\n            };\n        }\n    }\n\n    return {\n        token: fee.token,\n        amount: fee.amount.toString(),\n        type: fee.type,\n        details,\n        breakdown,\n        conversionRates,\n    };\n};\n\nexport const storedFeeToFee = (fee: StoredFee): Fee => {\n    return {\n        token: fee.token,\n        amount: new BigNumber(fee.amount),\n        type: fee.type,\n    };\n};\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts",{"fileContent":"import { OtcOrderFields } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\n\nexport enum RfqTables {\n    RfqmV2Quotes = 'rfqm_v2_quotes',\n    RfqmV2Jobs = 'rfqm_v2_jobs',\n    RfqmV2TransactionSubmissions = 'rfqm_v2_transaction_submissions',\n}\n\nexport enum RfqmJobStatus {\n    // Transaction has been enqueued and will be processed once a worker is available\n    PendingEnqueued = 'pending_enqueued',\n    // Transaction has passed initial validation. Last look will be executed and transaction will be submitted if last look is accepted.\n    PendingProcessing = 'pending_processing',\n    // For v1 orders, the last look has been approved. For v2 orders, the market maker has signed the order.\n    PendingLastLookAccepted = 'pending_last_look_accepted',\n    // Transaction has passed initial verification and has been submitted to the mem pool\n    PendingSubmitted = 'pending_submitted',\n\n    // Eth Call made before transaction submission was unsuccessful\n    FailedEthCallFailed = 'failed_eth_call_failed',\n    // Transaction has expired prior to eth call or worker is not available to make an eth call\n    FailedExpired = 'failed_expired',\n    // Market Maker declined the last look\n    FailedLastLookDeclined = 'failed_last_look_declined',\n    // [RFQM v2] Balance checks executed before obtaining market maker signature failed\n    FailedPresignValidationFailed = 'failed_presign_validation_failed',\n    // Transaction was reverted more than 3 blocks ago\n    FailedRevertedConfirmed = 'failed_reverted_confirmed',\n    // Transaction was reverted less than 3 blocks ago\n    FailedRevertedUnconfirmed = 'failed_reverted_unconfirmed',\n    // Obtaining the market maker's signature for a v2 order failed.\n    // This is NOT a status for the case where the market maker intentionally declined to sign.\n    FailedSignFailed = 'failed_sign_failed',\n    // Submitting the transaction to the network was unsuccessful\n    FailedSubmitFailed = 'failed_submit_failed',\n    // Transaction does not contain call data\n    FailedValidationNoCallData = 'failed_validation_no_call_data',\n    // Transaction does not include a maker URI\n    FailedValidationNoMakerUri = 'failed_validation_no_maker_uri',\n    // Job has been submitted with no taker signuature\n    FailedValidationNoTakerSignature = 'failed_validation_no_taker_signature',\n    // Transaction does not contain an order\n    FailedValidationNoOrder = 'failed_validation_no_order',\n    // Transaction does not contain a fee\n    FailedValidationNoFee = 'failed_validation_no_fee',\n\n    // Transaction has succeeded with 3 subsequent blocks\n    SucceededConfirmed = 'succeeded_confirmed',\n    // Transaction was successfully mined and filled\n    SucceededUnconfirmed = 'succeeded_unconfirmed',\n}\n\n// From https://0xproject.quip.com/ixNbA6mmn1KT/Error-reason-on-RFQm-zerog-status\nexport enum JobFailureReason {\n    TransactionSimulationFailed = 'transaction_simulation_failed',\n    OrderExpired = 'order_expired',\n    LastLookDeclined = 'last_look_declined',\n    TransactionReverted = 'transaction_reverted',\n    MarketMakerSignatureError = 'market_maker_sigature_error',\n    InvalidBalance = 'invalid_balance',\n    InternalError = 'internal_error', // fallback error reason\n}\n\n/**\n * Determines whether or not a given `RfqmJobStatus` indicates\n * the associated job has been processed to completion or not.\n *\n * Returns `true` if the status indicates the associated job is\n * resolved and should not be retried; returns `false` if the\n * associated job is in an incomplete state and should be retried.\n */\nfunction isJobResolved(status: RfqmJobStatus): boolean {\n    switch (status) {\n        case RfqmJobStatus.FailedEthCallFailed:\n        case RfqmJobStatus.FailedExpired:\n        case RfqmJobStatus.FailedLastLookDeclined:\n        case RfqmJobStatus.FailedPresignValidationFailed:\n        case RfqmJobStatus.FailedRevertedConfirmed:\n        case RfqmJobStatus.FailedSignFailed:\n        case RfqmJobStatus.FailedSubmitFailed:\n        case RfqmJobStatus.FailedValidationNoCallData:\n        case RfqmJobStatus.FailedValidationNoFee:\n        case RfqmJobStatus.FailedValidationNoMakerUri:\n        case RfqmJobStatus.FailedValidationNoOrder:\n        case RfqmJobStatus.FailedValidationNoTakerSignature:\n        case RfqmJobStatus.SucceededConfirmed:\n            return true;\n        case RfqmJobStatus.FailedRevertedUnconfirmed:\n        case RfqmJobStatus.PendingEnqueued:\n        case RfqmJobStatus.PendingLastLookAccepted:\n        case RfqmJobStatus.PendingProcessing:\n        case RfqmJobStatus.PendingSubmitted:\n        case RfqmJobStatus.SucceededUnconfirmed:\n            return false;\n        default:\n            ((_x: never) => {\n                throw new Error('unreachable');\n            })(status);\n    }\n}\n\n/**\n * `RfqmJobStatus` values which should be considered incomplete\n * and should be retried.\n */\nexport const UnresolvedRfqmJobStatuses = Object.values(RfqmJobStatus).filter((v) => !isJobResolved(v));\n\nexport enum RfqmTransactionSubmissionType {\n    Trade = 'trade',\n    Approval = 'approval',\n}\n\nexport enum RfqmTransactionSubmissionStatus {\n    DroppedAndReplaced = 'dropped_and_replaced',\n    Presubmit = 'presubmit', // Transaction created but not yet broadcast\n    RevertedConfirmed = 'reverted_confirmed',\n    RevertedUnconfirmed = 'reverted_unconfirmed',\n    Submitted = 'submitted',\n    SucceededConfirmed = 'succeeded_confirmed',\n    SucceededUnconfirmed = 'succeeded_unconfirmed',\n}\n\n/**\n * `SubmissionContext` contains multiple submissions with different gas prices. `SubmissionContextStatus`\n * is the collective status of all submissions contained within the submission context. It marks the final result of a\n * submission action which may contain several submission attempts.\n */\nexport enum SubmissionContextStatus {\n    FailedExpired = 'failed_expired',\n    FailedRevertedConfirmed = 'failed_reverted_confirmed',\n    FailedRevertedUnconfirmed = 'failed_reverted_unconfirmed',\n    PendingSubmitted = 'pending_submitted',\n    SucceededConfirmed = 'succeeded_confirmed',\n    SucceededUnconfirmed = 'succeeded_unconfirmed',\n}\n\nexport interface TransactionEntityOpts {\n    refHash: string;\n    apiKey?: string;\n    txHash?: string;\n    takerAddress?: string;\n    status: string;\n    expectedMinedInSec: number;\n    to: string;\n    data?: string;\n    value?: BigNumber;\n    from?: string;\n    nonce?: number;\n    gasPrice?: BigNumber;\n    gas?: number | null;\n    gasUsed?: number | null;\n    blockNumber?: number;\n    // Ethereum tx status, 1 == success, 0 == failure\n    txStatus?: number | null;\n}\n\nexport enum RfqmOrderTypes {\n    V4Rfq = 'v4Rfq',\n    Otc = 'otc',\n}\n\n/******* OTC ********/\nexport interface StoredOtcOrder {\n    type: RfqmOrderTypes.Otc;\n    order: StringOtcOrderFields;\n}\n\nexport type StringOtcOrderFields = Record<keyof OtcOrderFields, string>;\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts",{"fileContent":"import { OtcOrder, Signature } from '@0x/protocol-utils';\nimport { MarketOperation } from '@0x/types';\nimport { BigNumber } from '@0x/utils';\n\nexport type RequireOnlyOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n    {\n        [K in Keys]-?: Required<Pick<T, K>> & Partial<Record<Exclude<Keys, K>, undefined>>;\n    }[Keys];\n\nexport interface IndicativeQuote {\n    maker: string;\n    makerUri: string;\n    makerToken: string;\n    takerToken: string;\n    makerAmount: BigNumber;\n    takerAmount: BigNumber;\n    expiry: BigNumber;\n}\n\n/**\n * FirmOtcQuote is a quote for an OtcOrder. The makerSignature may not be present if the maker gets\n * the \"last look\" (RFQm).\n */\nexport interface FirmOtcQuote {\n    kind: 'otc';\n    makerUri: string;\n    order: OtcOrder;\n    makerSignature?: Signature;\n}\n\n/**\n * ERC20Owner is an address-token pair used to perform balance checks.\n */\nexport interface ERC20Owner {\n    owner: string;\n    token: string;\n}\n\nexport enum GaslessTypes {\n    MetaTransaction = 'metatransaction',\n    MetaTransactionV2 = 'metatransaction_v2',\n    OtcOrder = 'otc',\n}\n\n/**\n * Approval is an object that encapsulates the EIP-712 context that will eventually be signed by takers\n * for gasless approvals. There are multiple flavors of these approval objects, which can be distinguished\n * by their `kind`\n */\nexport enum GaslessApprovalTypes {\n    ExecuteMetaTransaction = 'executeMetaTransaction::approve',\n    Permit = 'permit',\n    DaiPermit = 'daiPermit',\n}\n\nexport type Approval = ExecuteMetaTransactionApproval | PermitApproval;\nexport interface ExecuteMetaTransactionApproval {\n    kind: GaslessApprovalTypes.ExecuteMetaTransaction;\n    eip712: ExecuteMetaTransactionEip712Context;\n}\n\nexport interface PermitApproval {\n    kind: GaslessApprovalTypes.Permit;\n    eip712: PermitEip712Context;\n}\nexport interface ExecuteMetaTransactionEip712Context {\n    types: ExecuteMetaTransactionEip712Types;\n    primaryType: 'MetaTransaction';\n    domain: Eip712Domain;\n    message: {\n        nonce: number;\n        from: string;\n        functionSignature: string;\n    };\n}\n\nexport interface PermitEip712Context {\n    types: PermitEip712Types;\n    primaryType: 'Permit';\n    domain: Eip712Domain;\n    message: {\n        owner: string;\n        spender: string;\n        value: string;\n        nonce: number;\n        deadline: string;\n    };\n}\n\nexport interface ExecuteMetaTransactionEip712Types {\n    EIP712Domain: Eip712DataField[];\n    MetaTransaction: Eip712DataField[];\n}\nexport interface PermitEip712Types {\n    EIP712Domain: Eip712DataField[];\n    Permit: Eip712DataField[];\n}\n\nexport interface Eip712Domain {\n    name?: string;\n    version?: string;\n    chainId?: number;\n    verifyingContract?: string;\n    salt?: string;\n}\n\nexport interface Eip712DataField {\n    name: string;\n    type: string;\n}\n\n/**\n * Parameters for the request from 0x API\n * to 0x RFQ api for the RFQt v2 `prices` endpoint\n */\nexport interface RfqtV2Request {\n    assetFillAmount: BigNumber;\n    chainId: number;\n    gasless?: boolean; // whether or not the request is for gasless RFQt\n    integratorId: string;\n    intentOnFilling: boolean;\n    makerToken: string;\n    marketOperation: MarketOperation;\n    takerAddress: string; // expect this to be NULL_ADDRESS\n    takerToken: string;\n    trader?: string; // this is the actual trader. Optional only during Gasless RFQt rollout. Intent is to be required in the long term\n    txOrigin?: string; // expect this to be the taker address, except for gasless RFQt where it will be the registry, can be missing for /price but not /quote\n    bucket?: number;\n}\n\n/**\n * Format of response payload which is sent to 0x API\n * from 0x RFQ API for the RFQt v2 `prices` endpoint\n */\nexport type RfqtV2Price = {\n    expiry: BigNumber;\n    makerAddress: string;\n    makerAmount: BigNumber;\n    makerId: string;\n    makerToken: string;\n    makerUri: string;\n    takerAmount: BigNumber;\n    takerToken: string;\n};\n\n/**\n * Format of response payload which is sent to 0x API\n * from 0x RFQ API for the RFQt v2 `quotes` endpoint\n */\nexport type RfqtV2Quote = {\n    fillableMakerAmount: BigNumber;\n    fillableTakerAmount: BigNumber;\n    fillableTakerFeeAmount: BigNumber;\n    makerId: string;\n    makerUri: string;\n    order: OtcOrder;\n    signature: Signature;\n};\n\nexport type QuoteServerPriceParams = RequireOnlyOne<\n    {\n        buyAmountBaseUnits?: string;\n        buyTokenAddress: string;\n        chainId?: string; // TODO - make this required after the rollout\n        comparisonPrice?: string;\n        feeAmount?: string;\n        feeToken?: string;\n        feeType?: string;\n        isLastLook?: string;\n        integratorId?: string;\n        nonce?: string;\n        nonceBucket?: string;\n        protocolVersion?: string;\n        sellAmountBaseUnits?: string;\n        sellTokenAddress: string;\n        takerAddress: string;\n        trader?: string;\n        txOrigin?: string;\n        worflow?: string;\n    },\n    'sellAmountBaseUnits' | 'buyAmountBaseUnits'\n>;\nexport interface TokenMetadata {\n    symbol: string;\n    decimals: number;\n    tokenAddress: string;\n}\n\nexport enum OrderEventEndState {\n    // The order was successfully validated and added to the Mesh node. The order is now being watched and any changes to\n    // the fillability will result in subsequent order events.\n    Added = 'ADDED',\n    // The order was filled for a partial amount. The order is still fillable up to the fillableTakerAssetAmount.\n    Filled = 'FILLED',\n    // The order was fully filled and its remaining fillableTakerAssetAmount is 0. The order is no longer fillable.\n    FullyFilled = 'FULLY_FILLED',\n    // The order was cancelled and is no longer fillable.\n    Cancelled = 'CANCELLED',\n    // The order expired and is no longer fillable.\n    Expired = 'EXPIRED',\n    // Catch all 'Invalid' state when invalid orders are submitted.\n    Invalid = 'INVALID',\n    // The order was previously expired, but due to a block re-org it is no longer considered expired (should be rare).\n    Unexpired = 'UNEXPIRED',\n    // The order has become unfunded and is no longer fillable. This can happen if the maker makes a transfer or changes their allowance.\n    Unfunded = 'UNFUNDED',\n    // The fillability of the order has increased. This can happen if a previously processed fill event gets reverted due to a block re-org,\n    // or if a maker makes a transfer or changes their allowance.\n    FillabilityIncreased = 'FILLABILITY_INCREASED',\n    // The order is potentially still valid but was removed for a different reason (e.g.\n    // the database is full or the peer that sent the order was misbehaving). The order will no longer be watched\n    // and no further events for this order will be emitted. In some cases, the order may be re-added in the\n    // future.\n    StoppedWatching = 'STOPPED_WATCHING',\n}\n\nexport * from './assetSwapper';\nexport * from './fees';\n\n// tslint:disable-line:max-file-line-count\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\n\nexport type FeeModelVersion = /* no 0x fee */ 0 | /* fixed rate */ 1 | /* margin rake */ 2;\n\nexport interface Fee {\n    token: string;\n    amount: BigNumber;\n    type: 'fixed' | 'bps';\n}\n\n/**\n * (Deprecated) base interface for FeeDetails type.\n */\ninterface FeeDetailsBaseDeprecated {\n    /**\n     * `kind` is used to mark the type of FeeDetails.\n     */\n    kind: 'gasOnly' | 'default' | 'margin';\n    /**\n     * Version number of fee model which determines the fee amount to charge MMs.\n     *   * Version 0 includes estimated gas cost only.\n     *   * Version 1 charge an additional bps as 0x fee, based on trade size, on top of gas.\n     *   * Version 2 charge 0x fee based on detected margin of RFQm with AMMs.\n     * While Verion 0 will use `gasOnly` FeeDetails, and Version 1 will use `default`, Version 2\n     * will use all three of them: `gasOnly` for margin detection, `margin` if margin detection\n     * succeeded, and `default` if margin detection failed.\n     */\n    feeModelVersion: FeeModelVersion;\n    gasFeeAmount: BigNumber;\n    gasPrice: BigNumber;\n}\n\n/**\n * (Deprecated) interface for `margin` FeeDetails type. In this case the Fee is\n * calculated using margin based method\n */\nexport interface MarginBasedFeeDetailsDeprecated extends FeeDetailsBaseDeprecated {\n    kind: 'margin';\n    margin: BigNumber;\n    marginRakeRatio: number;\n    zeroExFeeAmount: BigNumber;\n    /**\n     * All token prices are from TokenPriceOracle. `null` value means the oracle\n     * failed to provide price, or we don't need to query it. For example, the token\n     * is not involved in fee calculation, or bps for given pair is 0.\n     */\n    feeTokenBaseUnitPriceUsd: BigNumber | null;\n    takerTokenBaseUnitPriceUsd: BigNumber | null;\n    makerTokenBaseUnitPriceUsd: BigNumber | null;\n}\n\n/**\n * (Deprecated) interface for `default` FeeDetails type. In this case the Fee is\n * calculated using default method, based on trade size and bps of underlying\n * pairs.\n */\nexport interface DefaultFeeDetailsDeprecated extends FeeDetailsBaseDeprecated {\n    kind: 'default';\n    tradeSizeBps: number;\n    zeroExFeeAmount: BigNumber;\n    feeTokenBaseUnitPriceUsd: BigNumber | null;\n    takerTokenBaseUnitPriceUsd: BigNumber | null;\n    makerTokenBaseUnitPriceUsd: BigNumber | null;\n}\n\n/**\n * (Deprecated) interface for `gasOnly` FeeDetails type. Only gas related information\n * is included.\n */\nexport interface GasOnlyFeeDetailsDeprecated extends FeeDetailsBaseDeprecated {\n    kind: 'gasOnly';\n}\n\ninterface GasFeeBreakdownDetails {\n    gasPrice: BigNumber;\n    estimatedGas: BigNumber;\n}\n\ninterface VolumeBasedFeeBreakdownDetails {\n    kind: 'volume';\n    tradeSizeBps: number;\n}\n\ninterface PriceImprovementBasedFeeBreakdownDetails {\n    kind: 'price_improvement';\n    priceImprovement: BigNumber;\n    rakeRatio: number;\n}\n\nexport interface FeeBreakdown {\n    gas?: {\n        amount: BigNumber;\n        details: GasFeeBreakdownDetails;\n    };\n    zeroEx?: {\n        amount: BigNumber;\n        details: VolumeBasedFeeBreakdownDetails | PriceImprovementBasedFeeBreakdownDetails;\n    };\n}\n\nexport interface ConversionRates {\n    nativeTokenBaseUnitPriceUsd: BigNumber | null;\n    feeTokenBaseUnitPriceUsd: BigNumber | null;\n    takerTokenBaseUnitPriceUsd: BigNumber | null;\n    makerTokenBaseUnitPriceUsd: BigNumber | null;\n}\n\n/**\n * Extends Fee data schema to include a details session, which could be one\n * of `gasOnly`, `default` or `margin` type, depending on the approach used\n * to calculate the Fee.\n */\nexport interface FeeWithDetails extends Fee {\n    details: GasOnlyFeeDetailsDeprecated | DefaultFeeDetailsDeprecated | MarginBasedFeeDetailsDeprecated;\n    breakdown: FeeBreakdown;\n    conversionRates: ConversionRates;\n}\n\nexport interface StoredFee {\n    token: string;\n    amount: string;\n    type: 'fixed' | 'bps';\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    /* eslint-disable @typescript-eslint/no-explicit-any */\n    details?: any;\n    breakdown?: any;\n    conversionRates?: any;\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts",{"fileContent":"// tslint:disable:max-file-line-count\nimport { OtcOrder } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { FindOptionsWhere, In } from 'typeorm';\nimport { Connection } from 'typeorm/connection/Connection';\n\nimport { toPairString } from '../core/pair_utils';\nimport {\n    LastLookRejectionCooldownEntity,\n    MetaTransactionJobEntity,\n    MetaTransactionSubmissionEntity,\n    RfqmV2JobEntity,\n    RfqmV2QuoteEntity,\n    RfqmV2TransactionSubmissionEntity,\n} from '../entities';\nimport { MetaTransactionJobConstructorOpts } from '../entities/MetaTransactionJobEntity';\nimport { MetaTransactionSubmissionEntityConstructorOpts } from '../entities/MetaTransactionSubmissionEntity';\nimport { RfqmV2JobConstructorOpts } from '../entities/RfqmV2JobEntity';\nimport { RfqmV2QuoteConstructorOpts } from '../entities/RfqmV2QuoteEntity';\nimport { RfqmV2TransactionSubmissionEntityConstructorOpts } from '../entities/RfqmV2TransactionSubmissionEntity';\nimport { RfqmWorkerHeartbeatEntity } from '../entities/RfqmWorkerHeartbeatEntity';\nimport {\n    RfqmJobStatus,\n    RfqmOrderTypes,\n    RfqmTransactionSubmissionType,\n    StoredOtcOrder,\n    UnresolvedRfqmJobStatuses,\n} from '../entities/types';\n\n/**\n * Map a StoredOtcOrder to an OtcOrder\n */\nexport function storedOtcOrderToOtcOrder(storedOrder: StoredOtcOrder): OtcOrder {\n    return new OtcOrder({\n        txOrigin: storedOrder.order.txOrigin,\n        maker: storedOrder.order.maker,\n        taker: storedOrder.order.taker,\n        makerToken: storedOrder.order.makerToken,\n        takerToken: storedOrder.order.takerToken,\n        makerAmount: new BigNumber(storedOrder.order.makerAmount),\n        takerAmount: new BigNumber(storedOrder.order.takerAmount),\n        expiryAndNonce: new BigNumber(storedOrder.order.expiryAndNonce),\n        verifyingContract: storedOrder.order.verifyingContract,\n        chainId: Number(storedOrder.order.chainId),\n    });\n}\n\n/**\n * Map an OtcOrder to a StoredOtcOrder\n */\nexport function otcOrderToStoredOtcOrder(order: OtcOrder): StoredOtcOrder {\n    return {\n        type: RfqmOrderTypes.Otc,\n        order: {\n            txOrigin: order.txOrigin,\n            maker: order.maker,\n            taker: order.taker,\n            makerToken: order.makerToken,\n            takerToken: order.takerToken,\n            makerAmount: order.makerAmount.toString(),\n            takerAmount: order.takerAmount.toString(),\n            expiryAndNonce: order.expiryAndNonce.toString(),\n            verifyingContract: order.verifyingContract,\n            chainId: String(order.chainId),\n        },\n    };\n}\n\n/**\n * RfqmDbUtils provides tools for interacting with the database\n */\nexport class RfqmDbUtils {\n    constructor(private readonly _connection: Connection) {}\n\n    /**\n     * Fetches all the worker heartbeats for the provided chain ID.\n     */\n    public async findRfqmWorkerHeartbeatsAsync(chainId: number): Promise<RfqmWorkerHeartbeatEntity[]> {\n        return this._connection.getRepository(RfqmWorkerHeartbeatEntity).find({ where: { chainId } });\n    }\n\n    /**\n     * Updates an existing RFQM job.\n     */\n    public async updateRfqmJobAsync<T extends RfqmV2JobEntity | MetaTransactionJobEntity>(job: T): Promise<void> {\n        const kind = job.kind;\n        switch (kind) {\n            case 'rfqm_v2_job':\n                await this._connection.getRepository(RfqmV2JobEntity).save(job);\n                return;\n            case 'meta_transaction_job':\n                await this._connection.getRepository(MetaTransactionJobEntity).save(job);\n                return;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n    }\n\n    public async upsertRfqmWorkerHeartbeatToDbAsync(\n        address: string,\n        index: number,\n        balance: BigNumber,\n        chainId: number,\n    ): Promise<RfqmWorkerHeartbeatEntity> {\n        if (!Number.isInteger(index)) {\n            throw new Error(`Index ${index} is not an integer`);\n        }\n        const repository = this._connection.getRepository(RfqmWorkerHeartbeatEntity);\n\n        // Why I did not use `.save`:\n        // The `rfqm_worker_heartbeat` table has a trigger to automatically update the timestamp on UPDATE\n        // but the `.save` functionality is smart enough to not actually execute the update if none of the\n        // data has changed. Since this only happens when a worker balance changes, the timestamp won't\n        // update unless `.update` is explicitly called.\n        const updatedEntity = await repository.preload({ address, index, balance, chainId });\n        if (updatedEntity !== undefined) {\n            const findConditions: FindOptionsWhere<RfqmWorkerHeartbeatEntity> = {\n                address,\n                chainId,\n            };\n            await this._connection.getRepository(RfqmWorkerHeartbeatEntity).update(findConditions, updatedEntity);\n            return updatedEntity;\n        }\n\n        const newEntity = new RfqmWorkerHeartbeatEntity({ address, index, balance, chainId });\n        await this._connection.getRepository(RfqmWorkerHeartbeatEntity).insert(newEntity);\n        return newEntity;\n    }\n\n    /**\n     * Updates transactions in the `rfqm_v2_transaction_submission` or the `meta_transaction_submission` tables as appropriate.\n     */\n    public async updateRfqmTransactionSubmissionsAsync<\n        T extends RfqmV2TransactionSubmissionEntity[] | MetaTransactionSubmissionEntity[],\n    >(entities: T): Promise<void> {\n        if (entities.length === 0) {\n            return;\n        }\n\n        const kind = entities[0].kind;\n        switch (kind) {\n            case 'rfqm_v2_transaction_submission':\n                await this._connection\n                    .getRepository(RfqmV2TransactionSubmissionEntity)\n                    .save(entities as Partial<RfqmV2TransactionSubmissionEntity>[]);\n                return;\n            case 'meta_transaction_submission':\n                await this._connection\n                    .getRepository(MetaTransactionSubmissionEntity)\n                    .save(entities as Partial<MetaTransactionSubmissionEntity>[]);\n                return;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n    }\n\n    /**\n     * [RFQm v2] Queries the rfqm_job table with the given orderHash\n     */\n    public async findV2JobByOrderHashAsync(orderHash: string): Promise<RfqmV2JobEntity | null> {\n        return this._connection.getRepository(RfqmV2JobEntity).findOne({\n            where: { orderHash },\n        });\n    }\n\n    /**\n     * [RFQm v2] Queries the rfqm_quote table with the given orderHash\n     */\n    public async findV2QuoteByOrderHashAsync(orderHash: string): Promise<RfqmV2QuoteEntity | null> {\n        return this._connection.getRepository(RfqmV2QuoteEntity).findOne({\n            where: { orderHash },\n        });\n    }\n\n    /**\n     * [RFQm v2] Queries the `rfqm_v2_jobs` table for all jobs with the specified statuses\n     */\n    public async findV2JobsWithStatusesAsync(statuses: RfqmJobStatus[]): Promise<RfqmV2JobEntity[]> {\n        return this._connection.getRepository(RfqmV2JobEntity).find({\n            where: {\n                status: In(statuses),\n            },\n        });\n    }\n\n    /**\n     * [RFQm v2] Queries the rfqm_v2_transaction_submission table with the given transactionHash\n     */\n    public async findV2TransactionSubmissionByTransactionHashAsync(\n        transactionHash: string,\n    ): Promise<RfqmV2TransactionSubmissionEntity | null> {\n        return this._connection.getRepository(RfqmV2TransactionSubmissionEntity).findOne({\n            where: { transactionHash },\n        });\n    }\n\n    /**\n     * [RFQm v2] Queries the last_look_rejection_cooldowns table with primary key\n     */\n    public async findV2LastLookRejectionCooldownAsync(\n        makerId: string,\n        chainId: number,\n        tokenA: string,\n        tokenB: string,\n        startTime: Date,\n    ): Promise<LastLookRejectionCooldownEntity | null> {\n        return this._connection.getRepository(LastLookRejectionCooldownEntity).findOne({\n            where: {\n                makerId,\n                chainId,\n                pairKey: toPairString(tokenA, tokenB),\n                startTime,\n            },\n        });\n    }\n\n    /**\n     * [RFQm v2] Queries the rfqm_v2_transaction_submission table with the given orderHash\n     */\n    public async findV2TransactionSubmissionsByOrderHashAsync(\n        orderHash: string,\n        type: RfqmTransactionSubmissionType = RfqmTransactionSubmissionType.Trade,\n    ): Promise<RfqmV2TransactionSubmissionEntity[]> {\n        return this._connection.getRepository(RfqmV2TransactionSubmissionEntity).find({\n            where: { orderHash, type },\n        });\n    }\n\n    /**\n     * [RFQm v2] Updates an RfqmV2Job at the given orderHash\n     */\n    public async updateV2JobAsync(\n        orderHash: string,\n        isCompleted: boolean,\n        rfqmJobOpts: Partial<RfqmV2JobEntity>,\n    ): Promise<void> {\n        await this._connection.getRepository(RfqmV2JobEntity).save({ ...rfqmJobOpts, isCompleted, orderHash });\n    }\n\n    /**\n     * [RFQm v2] writes to the rfqm_v2_transaction_submission table\n     */\n    public async writeV2RfqmTransactionSubmissionToDbAsync(\n        partialV2RfqmTransactionSubmissionEntity: RfqmV2TransactionSubmissionEntityConstructorOpts,\n    ): Promise<RfqmV2TransactionSubmissionEntity> {\n        const entity = new RfqmV2TransactionSubmissionEntity(partialV2RfqmTransactionSubmissionEntity);\n        await this._connection.getRepository(RfqmV2TransactionSubmissionEntity).insert(entity);\n\n        return entity;\n    }\n\n    /**\n     * [RFQm v2] bulk update to the rfqm_v2_transaction_submission table\n     */\n    public async updateV2TransactionSubmissionsAsync(\n        entities: Partial<RfqmV2TransactionSubmissionEntity>[],\n    ): Promise<RfqmV2TransactionSubmissionEntity[]> {\n        return this._connection.getRepository(RfqmV2TransactionSubmissionEntity).save(entities);\n    }\n\n    /**\n     * [RFQm v2] writes to the rfqm_v2_quote table\n     */\n    public async writeV2QuoteAsync(rfqmV2QuoteOpts: RfqmV2QuoteConstructorOpts): Promise<void> {\n        await this._connection.getRepository(RfqmV2QuoteEntity).insert(new RfqmV2QuoteEntity(rfqmV2QuoteOpts));\n    }\n\n    /**\n     * [RFQm v2] writes to the rfqm_v2_job table\n     */\n    public async writeV2JobAsync(rfqmV2JobOpts: RfqmV2JobConstructorOpts): Promise<void> {\n        await this._connection.getRepository(RfqmV2JobEntity).insert(new RfqmV2JobEntity(rfqmV2JobOpts));\n    }\n\n    /**\n     * [RFQm v2] writes to the rfqm_v2_transaction_submission table. Should not error on duplicate\n     * primary key (PK), since the PK is essentially a hash of the contents of the table, minus status\n     */\n    public async writeV2TransactionSubmissionAsync(\n        constructorOpts: RfqmV2TransactionSubmissionEntityConstructorOpts,\n    ): Promise<RfqmV2TransactionSubmissionEntity> {\n        const entity = new RfqmV2TransactionSubmissionEntity(constructorOpts);\n        await this._connection.getRepository(RfqmV2TransactionSubmissionEntity).save(entity);\n\n        return entity;\n    }\n\n    /**\n     * [RFQm v2] writes to the last_look_rejection_cooldowns table\n     */\n    public async writeV2LastLookRejectionCooldownAsync(\n        makerId: string,\n        chainId: number,\n        tokenA: string,\n        tokenB: string,\n        startTime: Date,\n        endTime: Date,\n        orderHash: string,\n    ): Promise<void> {\n        await this._connection.getRepository(LastLookRejectionCooldownEntity).insert(\n            new LastLookRejectionCooldownEntity({\n                makerId,\n                chainId,\n                pairKey: toPairString(tokenA, tokenB),\n                startTime,\n                endTime,\n                orderHash,\n            }),\n        );\n    }\n\n    /**\n     * [RFQm v2] find unresolved jobs from the rfqm_v2_jobs table\n     * for a given worker address and chain ID.\n     */\n    public async findV2UnresolvedJobsAsync(workerAddress: string, chainId: number): Promise<RfqmV2JobEntity[]> {\n        return this._connection.getRepository(RfqmV2JobEntity).find({\n            where: {\n                chainId,\n                status: In(UnresolvedRfqmJobStatuses),\n                workerAddress,\n            },\n        });\n    }\n\n    /**\n     * [meta transaction] Queries the `meta_transaction_jobs` table with the given id.\n     */\n    public async findMetaTransactionJobByIdAsync(id: string): Promise<MetaTransactionJobEntity | null> {\n        return this._connection.getRepository(MetaTransactionJobEntity).findOne({\n            where: { id },\n        });\n    }\n\n    /**\n     * [meta transaction] Queries the `meta_transaction_jobs` table with the given meta transaction hash.\n     */\n    public async findMetaTransactionJobByMetaTransactionHashAsync(\n        metaTransactionHash: string,\n    ): Promise<MetaTransactionJobEntity | null> {\n        return this._connection.getRepository(MetaTransactionJobEntity).findOne({\n            where: { metaTransactionHash },\n        });\n    }\n\n    /**\n     * [meta transaction] Queries the `meta_transaction_jobs` table for all jobs with the specified statuss.\n     */\n    public async findMetaTransactionJobsWithStatusesAsync(\n        statuses: RfqmJobStatus[],\n    ): Promise<MetaTransactionJobEntity[]> {\n        return this._connection.getRepository(MetaTransactionJobEntity).find({\n            where: {\n                status: In(statuses),\n            },\n        });\n    }\n\n    /**\n     * [meta transaction] Writes to the `meta_transaction_jobs` tabe.\n     */\n    public async writeMetaTransactionJobAsync(\n        metaTransactionJobOpts: MetaTransactionJobConstructorOpts,\n    ): Promise<MetaTransactionJobEntity> {\n        return this._connection\n            .getRepository(MetaTransactionJobEntity)\n            .save(new MetaTransactionJobEntity(metaTransactionJobOpts));\n    }\n\n    /**\n     * [meta transaction] find unresolved jobs from the `meta_transaction_jobs` table for\n     * a given worker address and chain ID.\n     */\n    public async findUnresolvedMetaTransactionJobsAsync(\n        workerAddress: string,\n        chainId: number,\n    ): Promise<MetaTransactionJobEntity[]> {\n        return this._connection.getRepository(MetaTransactionJobEntity).find({\n            where: {\n                chainId,\n                status: In(UnresolvedRfqmJobStatuses),\n                workerAddress,\n            },\n        });\n    }\n\n    /**\n     * [meta transaction] Queries the `meta_transaction_submissions` table with the given submission id.\n     */\n    public async findMetaTransactionSubmissionByIdAsync(id: string): Promise<MetaTransactionSubmissionEntity | null> {\n        return this._connection.getRepository(MetaTransactionSubmissionEntity).findOne({\n            where: { id },\n        });\n    }\n\n    /**\n     * [meta transaction] Queries the `meta_transaction_submissions` table with the given transaction hash and type.\n     */\n    public async findMetaTransactionSubmissionsByTransactionHashAsync(\n        transactionHash: string,\n        type: RfqmTransactionSubmissionType,\n    ): Promise<MetaTransactionSubmissionEntity[]> {\n        return this._connection.getRepository(MetaTransactionSubmissionEntity).find({\n            where: { transactionHash, type },\n        });\n    }\n\n    /**\n     * [meta transaction] Queries the `meta_transaction_submissions` table with the given meta transaction job id and type.\n     */\n    public async findMetaTransactionSubmissionsByJobIdAsync(\n        metaTransactionJobId: string,\n        type: RfqmTransactionSubmissionType = RfqmTransactionSubmissionType.Trade,\n    ): Promise<MetaTransactionSubmissionEntity[]> {\n        return this._connection.getRepository(MetaTransactionSubmissionEntity).find({\n            where: { metaTransactionJobId, type },\n        });\n    }\n\n    /**\n     * [meta transaction] writes to the `meta_transaction_submissions` table.\n     */\n    public async writeMetaTransactionSubmissionAsync(\n        constructorOpts: MetaTransactionSubmissionEntityConstructorOpts,\n    ): Promise<MetaTransactionSubmissionEntity> {\n        return this._connection\n            .getRepository(MetaTransactionSubmissionEntity)\n            .save(new MetaTransactionSubmissionEntity(constructorOpts));\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts",{"fileContent":"/**\n * Transforms a \"pair string\" of format \"0x1-0x2\" into\n * a two-element array [\"0x1\", \"0x2\"]. Ensures the result\n * array is sorted and converted to lower case.\n */\nfunction fromPairString(k: string): [string, string] {\n    const a = k.split('-');\n    if (a.length !== 2) {\n        throw new Error();\n    }\n    // type coercion is there because TypeScript thinks\n    // `sort` might change the array length\n    return [a[0].toLowerCase(), a[1].toLowerCase()].sort() as [string, string];\n}\n\n/**\n * Transforms two token addresses into a \"pair string\" of the format\n * \"0x1-0x2\".\n */\nexport function toPairString(tokenA: string, tokenB: string): string {\n    return [tokenA, tokenB]\n        .map((str) => str.toLowerCase())\n        .sort()\n        .join('-');\n}\n\n/**\n * Transforms an array of \"0x1-0x2\" pair strings into an array\n * of two-element arrays. Removes duplicate pairs.\n *\n * Example:\n * const pairs = [\n *  \"0x1-0x2\",\n *  \"0x2-0x1\",\n *  \"0x3-0x4\",\n * ];\n * toUniqueArray(pairs); // [[\"0x1\", \"0x2\"], [\"0x3\", \"0x4\"]]\n */\nexport function toUniqueArray(pairs: string[]): [string, string][] {\n    return Array.from(\n        pairs.reduce((result, pair) => {\n            result.add(fromPairString(pair).sort());\n            return result;\n        }, new Set<[string, string]>()),\n    );\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts",{"fileContent":"export { BlockedAddressEntity } from './BlockedAddressEntity';\nexport { KeyValueEntity } from './KeyValueEntity';\nexport { LastLookRejectionCooldownEntity } from './LastLookRejectionCooldownsEntity';\nexport { MakerBalanceChainCacheEntity } from './MakerBalanceChainCacheEntity';\nexport { MetaTransactionJobEntity } from './MetaTransactionJobEntity';\nexport { MetaTransactionSubmissionEntity } from './MetaTransactionSubmissionEntity';\nexport { OrderWatcherSignedOrderEntity } from './OrderWatcherSignedOrderEntity';\nexport { PersistentSignedOrderEntity } from './PersistentSignedOrderEntity';\nexport { PersistentSignedOrderV4Entity } from './PersistentSignedOrderV4Entity';\nexport { RfqmJobEntity } from './RfqmJobEntity';\nexport { RfqmQuoteEntity } from './RfqmQuoteEntity';\nexport { RfqmTransactionSubmissionEntity } from './RfqmTransactionSubmissionEntity';\nexport { RfqmV2JobEntity } from './RfqmV2JobEntity';\nexport { RfqmV2QuoteEntity } from './RfqmV2QuoteEntity';\nexport { RfqmV2TransactionSubmissionEntity } from './RfqmV2TransactionSubmissionEntity';\nexport { RfqmWorkerHeartbeatEntity } from './RfqmWorkerHeartbeatEntity';\nexport { RfqMaker } from './RfqMaker';\nexport { RfqMakerUpdateTimeHash } from './RfqMakerUpdateTimeHash';\nexport { SignedOrderEntity } from './SignedOrderEntity';\nexport { SignedOrderV4Entity } from './SignedOrderV4Entity';\nexport { TransactionEntity } from './TransactionEntity';\nexport { TransactionEntityOpts } from './types';\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts",{"fileContent":"import { Check, Column, Entity, Index, PrimaryColumn } from 'typeorm';\n\nexport type BlockedAddressConstructorOpts = Pick<BlockedAddressEntity, 'address'> & Partial<BlockedAddressEntity>;\n@Entity({ name: 'blocked_addresses' })\nexport class BlockedAddressEntity {\n    @PrimaryColumn({ name: 'address', type: 'varchar' })\n    @Check('address = lower(address)')\n    public address: string;\n\n    @Index()\n    @Column({ name: 'created_at', type: 'timestamptz', default: () => 'now()' })\n    public createdAt!: Date;\n\n    @Column({ name: 'parent', type: 'varchar', nullable: true })\n    public parent: string | null;\n\n    @Column({ name: 'last_seen_nonce', type: 'bigint', nullable: true })\n    public lastSeenNonce: number | null;\n\n    @Column({ name: 'ignore', type: 'boolean', default: 'false' })\n    public ignore: boolean;\n\n    // tslint:disable-next-line: no-object-literal-type-assertion\n    constructor(opts: BlockedAddressConstructorOpts = {} as BlockedAddressConstructorOpts) {\n        // allow createdAt overrides for testing\n        if (opts.createdAt) {\n            this.createdAt = opts.createdAt;\n        }\n        this.address = opts.address;\n        this.parent = opts.parent || null;\n        this.lastSeenNonce = opts.lastSeenNonce || null;\n        this.ignore = opts.ignore || false;\n    }\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts",{"fileContent":"import { Column, CreateDateColumn, Entity, PrimaryColumn, UpdateDateColumn } from 'typeorm';\n\n@Entity({ name: 'kv_store' })\nexport class KeyValueEntity {\n    @PrimaryColumn({ name: 'key', type: 'varchar' })\n    public key: string;\n\n    @Column({ name: 'value', type: 'varchar', nullable: true })\n    public value?: string;\n\n    @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })\n    public createdAt?: Date;\n\n    @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })\n    public updatedAt?: Date;\n\n    constructor(key: string, value?: string) {\n        this.key = key;\n        this.value = value;\n    }\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts",{"fileContent":"import { Column, Entity, PrimaryColumn } from 'typeorm';\n\nexport type LastLookRejectionCooldownOpts = LastLookRejectionCooldownEntity;\n\n// A table of issued cooldowns due to bad last look rejection\n@Entity({ name: 'last_look_rejection_cooldowns' })\nexport class LastLookRejectionCooldownEntity {\n    // The ID of blocked market maker\n    @PrimaryColumn({ name: 'maker_id', type: 'varchar' })\n    public makerId: string;\n\n    // The chain ID of the chain market maker is blocked on\n    @PrimaryColumn({ name: 'chain_id', type: 'integer' })\n    public chainId: number;\n\n    // Token pair string of blocked pair (in format of \"0x1-0x2\")\n    @PrimaryColumn({ name: 'pair_key', type: 'varchar' })\n    public pairKey: string;\n\n    // The time the market maker is blocked from issuing quotes\n    @PrimaryColumn({ name: 'start_time', type: 'timestamptz' })\n    public startTime: Date;\n\n    // The time the market maker is unblocked\n    @Column({ name: 'end_time', type: 'timestamptz' })\n    public endTime: Date;\n\n    // The order hash of the order with bad last look rejection\n    @Column({ name: 'order_hash', type: 'varchar' })\n    public orderHash: string;\n\n    // tslint:disable-next-line: no-object-literal-type-assertion\n    constructor(opts: LastLookRejectionCooldownOpts = {} as LastLookRejectionCooldownOpts) {\n        this.makerId = opts.makerId;\n        this.chainId = opts.chainId;\n        this.pairKey = opts.pairKey;\n        this.startTime = opts.startTime;\n        this.endTime = opts.endTime;\n        this.orderHash = opts.orderHash;\n    }\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { Column, Entity, PrimaryColumn } from 'typeorm';\n\nimport { BigNumberTransformer } from './transformers';\n\n// A table of cached erc20 balances for RFQT market makers\n@Entity({ name: 'maker_balance_chain_cache' })\nexport class MakerBalanceChainCacheEntity {\n    @PrimaryColumn({ name: 'token_address', type: 'varchar' })\n    public tokenAddress?: string;\n\n    @PrimaryColumn({ name: 'maker_address', type: 'varchar' })\n    public makerAddress?: string;\n\n    @Column({ name: 'time_first_seen', type: 'timestamptz' })\n    public timeFirstSeen?: Date;\n\n    @Column({ name: 'balance', type: 'varchar', nullable: true, transformer: BigNumberTransformer })\n    public balance?: BigNumber | null;\n\n    @Column({ name: 'time_of_sample', type: 'timestamptz', nullable: true })\n    public timeOfSample?: Date | null;\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts",{"fileContent":"import { MetaTransaction, MetaTransactionFields } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { ValueTransformer } from 'typeorm';\n\nimport { Fee, StoredFee } from '../core/types';\nimport { feeToStoredFee, storedFeeToFee } from '../core/fee_utils';\n\nexport const BigIntTransformer: ValueTransformer = {\n    from: (value: string | null): number | null => {\n        if (value === null) {\n            return null;\n        }\n        const num = Number(value);\n        if (!Number.isSafeInteger(num)) {\n            throw new Error('unsafe integer precision when transforming value');\n        }\n        return value === null ? null : Number(value);\n    },\n    to: (value: number | null | undefined): string | null => {\n        if (value === null || value === undefined) {\n            return null;\n        }\n        if (!Number.isSafeInteger(value)) {\n            throw new Error('unsafe integer precision when transforming value');\n        }\n        return value.toString();\n    },\n};\n\nexport const BigNumberTransformer: ValueTransformer = {\n    from: (value: string | null): BigNumber | null => {\n        return value === null ? null : new BigNumber(value);\n    },\n    to: (value: BigNumber | null | undefined): string | null => {\n        return value === null || value === undefined ? null : value.toString();\n    },\n};\n\nexport const MetaTransactionTransformer: ValueTransformer = {\n    /**\n     * Used to marshal `MetaTransaction` when writing to the database.\n     */\n    to: (metaTransaction: MetaTransaction): Record<keyof MetaTransactionFields, string> => {\n        const { minGasPrice, maxGasPrice, expirationTimeSeconds, salt, value, feeAmount, chainId } = metaTransaction;\n        return {\n            ...metaTransaction,\n            minGasPrice: minGasPrice.toString(),\n            maxGasPrice: maxGasPrice.toString(),\n            expirationTimeSeconds: expirationTimeSeconds.toString(),\n            salt: salt.toString(),\n            value: value.toString(),\n            feeAmount: feeAmount.toString(),\n            chainId: chainId.toString(),\n        };\n    },\n    /**\n     * Used to unmarshal `MetaTransaction` when reading from the database.\n     */\n    from: (storedValue: Record<keyof MetaTransactionFields, string>): MetaTransaction => {\n        const { minGasPrice, maxGasPrice, expirationTimeSeconds, salt, value, feeAmount, chainId } = storedValue;\n        return new MetaTransaction({\n            ...storedValue,\n            minGasPrice: new BigNumber(minGasPrice),\n            maxGasPrice: new BigNumber(maxGasPrice),\n            expirationTimeSeconds: new BigNumber(expirationTimeSeconds),\n            salt: new BigNumber(salt),\n            value: new BigNumber(value),\n            feeAmount: new BigNumber(feeAmount),\n            chainId: Number(chainId),\n        });\n    },\n};\n\nexport const FeeTransformer: ValueTransformer = {\n    /**\n     * Used to marshal `Fee` when writing to the database.\n     */\n    to: (value: Fee): StoredFee => {\n        return feeToStoredFee(value);\n    },\n    /**\n     * Used to unmarshal `Fee` when reading from the database.\n     */\n    from: (storedFee: StoredFee): Fee => {\n        return storedFeeToFee(storedFee);\n    },\n};\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts",{"fileContent":"import { MetaTransaction, Signature } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { Column, Entity, Index, PrimaryGeneratedColumn, UpdateDateColumn } from 'typeorm';\n\nimport { Approval, Fee } from '../core/types';\n\nimport { BigNumberTransformer, FeeTransformer, MetaTransactionTransformer } from './transformers';\nimport { RfqmJobStatus } from './types';\n\nexport type MetaTransactionJobConstructorOpts = Pick<\n    MetaTransactionJobEntity,\n    | 'chainId'\n    | 'expiry'\n    | 'fee'\n    | 'inputToken'\n    | 'inputTokenAmount'\n    | 'integratorId'\n    | 'metaTransaction'\n    | 'metaTransactionHash'\n    | 'minOutputTokenAmount'\n    | 'outputToken'\n    | 'takerAddress'\n    | 'takerSignature'\n> &\n    Partial<MetaTransactionJobEntity>;\n\n@Entity({ name: 'meta_transaction_jobs' })\nexport class MetaTransactionJobEntity {\n    // Differentiator for different flavors of RFQM jobs\n    public kind: 'meta_transaction_job';\n\n    // UUID and would be generated automatically during insertion\n    @PrimaryGeneratedColumn('uuid')\n    public id!: string;\n\n    @Index()\n    @Column({ name: 'meta_transaction_hash', type: 'varchar', unique: true })\n    public metaTransactionHash: string;\n\n    @Index()\n    @Column({ name: 'created_at', type: 'timestamptz', default: () => 'now()' })\n    public createdAt!: Date;\n\n    @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz', nullable: true })\n    public updatedAt: Date | null;\n\n    // The expiration time of the job, in unix seconds\n    @Column({ name: 'expiry', type: 'numeric', transformer: BigNumberTransformer })\n    public expiry: BigNumber;\n\n    @Column({ name: 'chain_id', type: 'integer' })\n    public chainId: number;\n\n    @Column({ name: 'integrator_id', type: 'varchar' })\n    public integratorId: string;\n\n    @Index()\n    @Column({ name: 'status', type: 'varchar' })\n    public status: RfqmJobStatus;\n\n    @Column({ name: 'fee', type: 'jsonb', transformer: FeeTransformer })\n    public fee: Fee;\n\n    @Column({ name: 'meta_transaction', type: 'jsonb', transformer: MetaTransactionTransformer })\n    public metaTransaction: MetaTransaction;\n\n    @Index()\n    @Column({ name: 'worker_address', type: 'varchar', nullable: true })\n    public workerAddress: string | null;\n\n    @Column({ name: 'affiliate_address', type: 'varchar', nullable: true })\n    public affiliateAddress: string | null;\n\n    @Index()\n    @Column({ name: 'taker_address', type: 'varchar' })\n    public takerAddress: string;\n\n    // The taker's signature of the metaTransaction hash.\n    @Column({ name: 'taker_signature', type: 'jsonb' })\n    public takerSignature: Signature;\n\n    // The optional approval object that contains the EIP-712 context (which includes\n    // the message that the taker will sign). This is stored to help us prepare the\n    // calldata for gasless approvals\n    @Column({ name: 'approval', type: 'jsonb', nullable: true })\n    public approval: Approval | null;\n\n    // The signature for the approval.\n    @Column({ name: 'approval_signature', type: 'jsonb', nullable: true })\n    public approvalSignature: Signature | null;\n\n    @Column({ name: 'input_token', type: 'varchar' })\n    public inputToken: string;\n\n    @Column({ name: 'output_token', type: 'varchar' })\n    public outputToken: string;\n\n    @Column({ name: 'input_token_amount', type: 'numeric', transformer: BigNumberTransformer })\n    public inputTokenAmount: BigNumber;\n\n    @Column({ name: 'min_output_token_amount', type: 'numeric', transformer: BigNumberTransformer })\n    public minOutputTokenAmount: BigNumber;\n\n    @Column({ name: 'settled_output_token_amount', type: 'numeric', transformer: BigNumberTransformer, nullable: true })\n    public settledOutputTokenAmount: BigNumber | null;\n\n    /**\n     * Used to get the 'canonical' hash of the job. This is useful\n     * because it can also be called on an rfqm job and\n     * that will return the order hash.\n     */\n    public getHash(): string {\n        return this.metaTransactionHash;\n    }\n\n    // TypeORM runs a validation check where it calls this initializer with no argument.\n    // With no default `opts`, `opts` will be undefined and the validation will throw,\n    // therefore, add this hacky default.\n    // tslint:disable-next-line no-object-literal-type-assertion\n    constructor(opts: MetaTransactionJobConstructorOpts = {} as MetaTransactionJobConstructorOpts) {\n        this.kind = 'meta_transaction_job';\n\n        // allow createdAt overrides for testing\n        if (opts.createdAt) {\n            this.createdAt = opts.createdAt;\n        }\n\n        this.affiliateAddress = opts.affiliateAddress ?? null;\n        this.approval = opts.approval ?? null;\n        this.approvalSignature = opts.approvalSignature ?? null;\n        this.chainId = opts.chainId;\n        this.expiry = opts.expiry;\n        this.fee = opts.fee;\n        this.inputToken = opts.inputToken;\n        this.inputTokenAmount = opts.inputTokenAmount;\n        this.integratorId = opts.integratorId;\n        this.metaTransaction = opts.metaTransaction;\n        this.metaTransactionHash = opts.metaTransactionHash;\n        this.minOutputTokenAmount = opts.minOutputTokenAmount;\n        this.outputToken = opts.outputToken;\n        this.settledOutputTokenAmount = opts.settledOutputTokenAmount ?? null;\n        this.status = opts.status ?? RfqmJobStatus.PendingEnqueued;\n        this.takerAddress = opts.takerAddress;\n        this.takerSignature = opts.takerSignature;\n        this.updatedAt = opts.updatedAt ?? null;\n        this.workerAddress = opts.workerAddress ?? null;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { Column, Entity, Index, PrimaryGeneratedColumn, UpdateDateColumn } from 'typeorm';\n\nimport { BigIntTransformer, BigNumberTransformer } from './transformers';\nimport { RfqmTransactionSubmissionStatus, RfqmTransactionSubmissionType } from './types';\n\nexport type MetaTransactionSubmissionEntityConstructorOpts = Pick<\n    MetaTransactionSubmissionEntity,\n    'from' | 'metaTransactionJobId' | 'nonce' | 'to' | 'transactionHash' | 'type'\n> &\n    Partial<MetaTransactionSubmissionEntity>;\n\n@Entity({ name: 'meta_transaction_submissions' })\nexport class MetaTransactionSubmissionEntity {\n    public kind: 'meta_transaction_submission';\n\n    // UUID and would be generated automatically during insertion\n    @PrimaryGeneratedColumn('uuid')\n    public id!: string;\n\n    @Index()\n    @Column({ name: 'transaction_hash', type: 'varchar' })\n    public transactionHash: string;\n\n    // specified as a foreign key to metaTransaction jobs in migration, but not in the typeorm\n    // definition to preserve its being read as a string\n    @Index()\n    @Column({ name: 'meta_transaction_job_id', type: 'uuid' })\n    public metaTransactionJobId: string;\n\n    @Index()\n    @Column({ name: 'created_at', type: 'timestamptz', default: () => 'now()' })\n    public createdAt!: Date;\n\n    @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz', nullable: true })\n    public updatedAt: Date | null;\n\n    @Column({ name: 'from', type: 'varchar' })\n    public from: string;\n\n    @Column({ name: 'to', type: 'varchar' })\n    public to: string;\n\n    @Column({ name: 'nonce', type: 'bigint', transformer: BigIntTransformer })\n    public nonce: number;\n\n    // The gas price in wei. Set at transaction submission time in non-EIP1559 transactions. In EIP1559 transactions, this is set once we have the transaction receipt.\n    @Column({ name: 'gas_price', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public gasPrice: BigNumber | null;\n\n    // Max fee per gas in wei. Present in type 2 \"EIP1559\" transactions.\n    @Column({ name: 'max_fee_per_gas', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public maxFeePerGas: BigNumber | null;\n\n    // Max priority fee per gas in wei. Present in type 2 \"EIP1559\" transactions.\n    @Column({ name: 'max_priority_fee_per_gas', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public maxPriorityFeePerGas: BigNumber | null;\n\n    @Column({ name: 'gas_used', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public gasUsed: BigNumber | null;\n\n    @Column({ name: 'block_mined', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public blockMined: BigNumber | null;\n\n    @Index()\n    @Column({ name: 'status', type: 'varchar' })\n    public status: RfqmTransactionSubmissionStatus;\n\n    @Column({ name: 'type', type: 'varchar' })\n    public type: RfqmTransactionSubmissionType;\n\n    // TypeORM runs a validation check where it calls this initializer with no argument.\n    // With no default `opts`, `opts` will be undefined and the validation will throw,\n    // therefore, add this hacky default.\n    constructor(\n        // tslint:disable-next-line no-object-literal-type-assertion\n        opts: MetaTransactionSubmissionEntityConstructorOpts = {} as MetaTransactionSubmissionEntityConstructorOpts,\n    ) {\n        this.kind = 'meta_transaction_submission';\n\n        // allow createdAt overrides for testing\n        if (opts.createdAt) {\n            this.createdAt = opts.createdAt;\n        }\n\n        this.blockMined = opts.blockMined ?? null;\n        this.from = opts.from;\n        this.gasPrice = opts.gasPrice ?? null;\n        this.gasUsed = opts.gasUsed ?? null;\n        this.maxFeePerGas = opts.maxFeePerGas ?? null;\n        this.maxPriorityFeePerGas = opts.maxPriorityFeePerGas ?? null;\n        this.metaTransactionJobId = opts.metaTransactionJobId;\n        this.nonce = opts.nonce;\n        this.status = opts.status ?? RfqmTransactionSubmissionStatus.Submitted;\n        this.to = opts.to;\n        this.transactionHash = opts.transactionHash;\n        this.type = opts.type;\n        this.updatedAt = opts.updatedAt ?? null;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts",{"fileContent":"import { Column, Entity, Index, PrimaryColumn } from 'typeorm';\n\n// This should only be used in tests to set the state of `signed_orders_v4`.\n// In production, we only care about valid orders, so use\n// `ValidSignedOrderV4Entity` instead.\n@Entity({ name: 'signed_orders_v4' })\nexport class OrderWatcherSignedOrderEntity {\n    @PrimaryColumn({ name: 'hash', type: 'varchar' })\n    public hash?: string;\n\n    @Index()\n    @Column({ name: 'maker_token', type: 'varchar' })\n    public makerToken?: string;\n\n    @Index()\n    @Column({ name: 'taker_token', type: 'varchar' })\n    public takerToken?: string;\n\n    @Column({ name: 'maker_amount', type: 'varchar' })\n    public makerAmount?: string;\n\n    @Column({ name: 'taker_amount', type: 'varchar' })\n    public takerAmount?: string;\n\n    @Index()\n    @Column({ name: 'maker', type: 'varchar' })\n    public maker?: string;\n\n    @Column({ name: 'taker', type: 'varchar' })\n    public taker?: string;\n\n    @Column({ name: 'pool', type: 'varchar' })\n    public pool?: string;\n\n    @Column({ name: 'expiry', type: 'varchar' })\n    public expiry?: string;\n\n    @Column({ name: 'salt', type: 'varchar' })\n    public salt?: string;\n\n    @Column({ name: 'verifying_contract', type: 'varchar' })\n    public verifyingContract?: string;\n\n    @Column({ name: 'taker_token_fee_amount', type: 'varchar' })\n    public takerTokenFeeAmount?: string;\n\n    @Column({ name: 'sender', type: 'varchar' })\n    public sender?: string;\n\n    @Index()\n    @Column({ name: 'fee_recipient', type: 'varchar' })\n    public feeRecipient?: string;\n\n    @Column({ name: 'signature', type: 'varchar' })\n    public signature?: string;\n\n    @Column({ name: 'remaining_fillable_taker_amount', type: 'varchar' })\n    public remainingFillableTakerAmount?: string;\n\n    @Column({ name: 'created_at', type: 'timestamptz', default: () => 'now()' })\n    public createdAt?: string;\n\n    constructor(\n        opts: {\n            hash?: string;\n            makerToken?: string;\n            takerToken?: string;\n            makerAmount?: string;\n            takerAmount?: string;\n            maker?: string;\n            taker?: string;\n            pool?: string;\n            expiry?: string;\n            salt?: string;\n            verifyingContract?: string;\n            takerTokenFeeAmount?: string;\n            sender?: string;\n            feeRecipient?: string;\n            signature?: string;\n            remainingFillableTakerAmount?: string;\n        } = {},\n    ) {\n        this.hash = opts.hash;\n        this.makerToken = opts.makerToken;\n        this.takerToken = opts.takerToken;\n        this.makerAmount = opts.makerAmount;\n        this.takerAmount = opts.takerAmount;\n        this.maker = opts.maker;\n        this.taker = opts.taker;\n        this.pool = opts.pool;\n        this.expiry = opts.expiry;\n        this.salt = opts.salt;\n        this.verifyingContract = opts.verifyingContract;\n        this.takerTokenFeeAmount = opts.takerTokenFeeAmount;\n        this.sender = opts.sender;\n        this.feeRecipient = opts.feeRecipient;\n        this.signature = opts.signature;\n        this.remainingFillableTakerAmount = opts.remainingFillableTakerAmount;\n        this.signature = opts.signature;\n    }\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts",{"fileContent":"import { Column, Entity, Index, PrimaryColumn } from 'typeorm';\n\nimport { OrderEventEndState } from '../core/types';\n\n// Adds a field `orderState` to SignedOrderEntity\n// Persists after cancellation, expiration, etc\n// We save these to support account history for Matcha front-end\n@Entity({ name: 'persistent_signed_orders' })\n@Index(['makerAssetData', 'takerAssetData'], { unique: false })\nexport class PersistentSignedOrderEntity {\n    @PrimaryColumn({ name: 'hash', type: 'varchar' })\n    public hash?: string;\n\n    @Column({ name: 'sender_address', type: 'varchar' })\n    public senderAddress?: string;\n\n    @Index()\n    @Column({ name: 'maker_address', type: 'varchar' })\n    public makerAddress?: string;\n\n    @Column({ name: 'taker_address', type: 'varchar' })\n    public takerAddress?: string;\n\n    @Index()\n    @Column({ name: 'maker_asset_data', type: 'varchar' })\n    public makerAssetData?: string;\n\n    @Index()\n    @Column({ name: 'taker_asset_data', type: 'varchar' })\n    public takerAssetData?: string;\n\n    @Column({ name: 'exchange_address', type: 'varchar' })\n    public exchangeAddress?: string;\n\n    @Index()\n    @Column({ name: 'fee_recipient_address', type: 'varchar' })\n    public feeRecipientAddress?: string;\n\n    @Column({ name: 'expiration_time_seconds', type: 'varchar' })\n    public expirationTimeSeconds?: string;\n\n    @Column({ name: 'maker_fee', type: 'varchar' })\n    public makerFee?: string;\n\n    @Column({ name: 'taker_fee', type: 'varchar' })\n    public takerFee?: string;\n\n    @Column({ name: 'maker_asset_amount', type: 'varchar' })\n    public makerAssetAmount?: string;\n\n    @Column({ name: 'taker_asset_amount', type: 'varchar' })\n    public takerAssetAmount?: string;\n\n    @Column({ name: 'salt', type: 'varchar' })\n    public salt?: string;\n\n    @Column({ name: 'signature', type: 'varchar' })\n    public signature?: string;\n\n    @Column({ name: 'remaining_fillable_taker_asset_amount', type: 'varchar' })\n    public remainingFillableTakerAssetAmount?: string;\n\n    @Column({ name: 'maker_fee_asset_data', type: 'varchar' })\n    public makerFeeAssetData?: string;\n\n    @Column({ name: 'taker_fee_asset_data', type: 'varchar' })\n    public takerFeeAssetData?: string;\n\n    @Column({ name: 'state', type: 'enum', enum: OrderEventEndState, default: OrderEventEndState.Added })\n    public orderState?: OrderEventEndState;\n\n    @Column({ name: 'created_at', type: 'timestamptz', default: () => 'now()' })\n    public createdAt?: string;\n    constructor(\n        opts: {\n            hash?: string;\n            senderAddress?: string;\n            makerAddress?: string;\n            takerAddress?: string;\n            makerAssetData?: string;\n            takerAssetData?: string;\n            exchangeAddress?: string;\n            feeRecipientAddress?: string;\n            expirationTimeSeconds?: string;\n            makerFee?: string;\n            takerFee?: string;\n            makerFeeAssetData?: string;\n            takerFeeAssetData?: string;\n            makerAssetAmount?: string;\n            takerAssetAmount?: string;\n            salt?: string;\n            signature?: string;\n            remainingFillableTakerAssetAmount?: string;\n            orderState?: OrderEventEndState;\n        } = {},\n    ) {\n        this.hash = opts.hash;\n        this.senderAddress = opts.senderAddress;\n        this.makerAddress = opts.makerAddress;\n        this.takerAddress = opts.takerAddress;\n        this.makerAssetData = opts.makerAssetData;\n        this.takerAssetData = opts.takerAssetData;\n        this.exchangeAddress = opts.exchangeAddress;\n        this.feeRecipientAddress = opts.feeRecipientAddress;\n        this.expirationTimeSeconds = opts.expirationTimeSeconds;\n        this.makerFee = opts.makerFee;\n        this.takerFee = opts.takerFee;\n        this.makerFeeAssetData = opts.makerFeeAssetData;\n        this.takerFeeAssetData = opts.takerFeeAssetData;\n        this.makerAssetAmount = opts.makerAssetAmount;\n        this.takerAssetAmount = opts.takerAssetAmount;\n        this.salt = opts.salt;\n        this.signature = opts.signature;\n        this.remainingFillableTakerAssetAmount = opts.remainingFillableTakerAssetAmount;\n        this.orderState = opts.orderState || OrderEventEndState.Added;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts",{"fileContent":"import { Column, Entity, Index, PrimaryColumn } from 'typeorm';\n\nimport { OrderEventEndState } from '../core/types';\n\n// Adds a field `orderState` to SignedOrderEntity\n// Persists after cancellation, expiration, etc\n// We save these to support account history for Matcha front-end\n@Entity({ name: 'persistent_signed_orders_v4' })\n@Index(['makerToken', 'takerToken'], { unique: false })\nexport class PersistentSignedOrderV4Entity {\n    @PrimaryColumn({ name: 'hash', type: 'varchar' })\n    public hash?: string;\n\n    @Index()\n    @Column({ name: 'maker_token', type: 'varchar' })\n    public makerToken?: string;\n\n    @Index()\n    @Column({ name: 'taker_token', type: 'varchar' })\n    public takerToken?: string;\n\n    @Column({ name: 'maker_amount', type: 'varchar' })\n    public makerAmount?: string;\n\n    @Column({ name: 'taker_amount', type: 'varchar' })\n    public takerAmount?: string;\n\n    @Index()\n    @Column({ name: 'maker', type: 'varchar' })\n    public maker?: string;\n\n    @Column({ name: 'taker', type: 'varchar' })\n    public taker?: string;\n\n    @Column({ name: 'pool', type: 'varchar' })\n    public pool?: string;\n\n    @Column({ name: 'expiry', type: 'varchar' })\n    public expiry?: string;\n\n    @Column({ name: 'salt', type: 'varchar' })\n    public salt?: string;\n\n    @Column({ name: 'verifying_contract', type: 'varchar' })\n    public verifyingContract?: string;\n\n    @Column({ name: 'taker_token_fee_amount', type: 'varchar' })\n    public takerTokenFeeAmount?: string;\n\n    @Column({ name: 'sender', type: 'varchar' })\n    public sender?: string;\n\n    @Index()\n    @Column({ name: 'fee_recipient', type: 'varchar' })\n    public feeRecipient?: string;\n\n    @Column({ name: 'signature', type: 'varchar' })\n    public signature?: string;\n\n    @Column({ name: 'remaining_fillable_taker_amount', type: 'varchar' })\n    public remainingFillableTakerAmount?: string;\n\n    @Column({ name: 'state', type: 'enum', enum: OrderEventEndState, default: OrderEventEndState.Added })\n    public orderState?: OrderEventEndState;\n\n    @Column({ name: 'created_at', type: 'timestamptz', default: () => 'now()' })\n    public createdAt?: string;\n\n    constructor(\n        opts: {\n            hash?: string;\n            makerToken?: string;\n            takerToken?: string;\n            makerAmount?: string;\n            takerAmount?: string;\n            maker?: string;\n            taker?: string;\n            pool?: string;\n            expiry?: string;\n            salt?: string;\n            verifyingContract?: string;\n            takerTokenFeeAmount?: string;\n            sender?: string;\n            feeRecipient?: string;\n            signature?: string;\n            remainingFillableTakerAmount?: string;\n            orderState?: OrderEventEndState;\n        } = {},\n    ) {\n        this.hash = opts.hash;\n        this.makerToken = opts.makerToken;\n        this.takerToken = opts.takerToken;\n        this.makerAmount = opts.makerAmount;\n        this.takerAmount = opts.takerAmount;\n        this.maker = opts.maker;\n        this.taker = opts.taker;\n        this.pool = opts.pool;\n        this.expiry = opts.expiry;\n        this.salt = opts.salt;\n        this.verifyingContract = opts.verifyingContract;\n        this.takerTokenFeeAmount = opts.takerTokenFeeAmount;\n        this.sender = opts.sender;\n        this.feeRecipient = opts.feeRecipient;\n        this.signature = opts.signature;\n        this.remainingFillableTakerAmount = opts.remainingFillableTakerAmount;\n        this.signature = opts.signature;\n        this.orderState = opts.orderState || OrderEventEndState.Added;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts",{"fileContent":"import { RfqOrderFields } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { Column, Entity, Index, PrimaryColumn } from 'typeorm';\n\nimport { StoredFee } from '../core/types';\n\nimport { BigNumberTransformer } from './transformers';\nimport { RfqmJobStatus, RfqmOrderTypes } from './types';\n\nexport interface V4RfqStoredOrder {\n    type: RfqmOrderTypes.V4Rfq;\n    order: V4StringRfqOrderFields;\n}\n\nexport type StoredOrder = V4RfqStoredOrder;\n\nexport type V4StringRfqOrderFields = Record<keyof RfqOrderFields, string>;\n\nexport type RfqmJobConstructorOpts = Pick<RfqmJobEntity, 'calldata' | 'chainId' | 'expiry' | 'makerUri' | 'orderHash'> &\n    Partial<RfqmJobEntity>;\n\n@Entity({ name: 'rfqm_jobs' })\nexport class RfqmJobEntity {\n    // Differentiator for different flavors of RFQM jobs\n    public kind: 'rfqm_v1_job';\n\n    @PrimaryColumn({ name: 'order_hash', type: 'varchar' })\n    public orderHash: string;\n\n    @Column({ name: 'metatransaction_hash', type: 'varchar', nullable: true, unique: true })\n    public metaTransactionHash: string | null;\n\n    @Index()\n    @Column({ name: 'created_at', type: 'timestamptz', default: () => 'now()' })\n    public createdAt!: Date;\n\n    @Column({ name: 'updated_at', type: 'timestamptz', nullable: true })\n    public updatedAt: Date | null;\n\n    // The expiration time of the job, in unix seconds\n    @Column({ name: 'expiry', type: 'numeric', transformer: BigNumberTransformer })\n    public expiry: BigNumber;\n\n    @Column({ name: 'chain_id', type: 'integer' })\n    public chainId: number;\n\n    @Column({ name: 'integrator_id', type: 'varchar', nullable: true })\n    public integratorId: string | null;\n\n    @Column({ name: 'maker_uri', type: 'varchar' })\n    public makerUri: string;\n\n    @Index()\n    @Column({ name: 'status', type: 'varchar' })\n    public status: RfqmJobStatus;\n\n    @Column({ name: 'calldata', type: 'varchar' })\n    public calldata: string;\n\n    @Column({ name: 'fee', type: 'jsonb', nullable: true })\n    public fee: StoredFee | null;\n\n    @Column({ name: 'order', type: 'jsonb', nullable: true })\n    public order: StoredOrder | null;\n\n    @Column({ name: 'metadata', type: 'jsonb', nullable: true })\n    public metadata: object | null;\n\n    @Column({ name: 'is_completed', type: 'boolean', nullable: false, default: 'false' })\n    public isCompleted: boolean;\n\n    @Column({ name: 'worker_address', type: 'varchar', nullable: true })\n    public workerAddress: string | null;\n\n    @Column({ name: 'last_look_result', type: 'boolean', nullable: true })\n    public lastLookResult: boolean | null;\n\n    @Column({ name: 'affiliate_address', type: 'varchar', nullable: true })\n    public affiliateAddress: string | null;\n\n    // TypeORM runs a validation check where it calls this initializer with no argument.\n    // With no default `opts`, `opts` will be undefined and the validation will throw,\n    // therefore, add this hacky default.\n    // tslint:disable-next-line no-object-literal-type-assertion\n    constructor(opts: RfqmJobConstructorOpts = {} as RfqmJobConstructorOpts) {\n        this.kind = 'rfqm_v1_job';\n        // allow createdAt overrides for testing\n        if (opts.createdAt) {\n            this.createdAt = opts.createdAt;\n        }\n\n        this.affiliateAddress = opts.affiliateAddress || null;\n        this.calldata = opts.calldata;\n        this.chainId = opts.chainId;\n        this.expiry = opts.expiry;\n        this.fee = opts.fee || null;\n        this.integratorId = opts.integratorId || null;\n        this.isCompleted = opts.isCompleted || false;\n        this.lastLookResult = opts.lastLookResult || null;\n        this.makerUri = opts.makerUri;\n        this.metadata = opts.metadata || null;\n        this.metaTransactionHash = opts.metaTransactionHash || null;\n        this.order = opts.order || null;\n        this.orderHash = opts.orderHash;\n        this.status = opts.status || RfqmJobStatus.PendingEnqueued;\n        this.updatedAt = opts.updatedAt || null;\n        this.workerAddress = opts.workerAddress || null;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts",{"fileContent":"import { Column, Entity, Index, PrimaryColumn } from 'typeorm';\n\nimport { StoredFee } from '../core/types';\n\nimport { StoredOrder } from './RfqmJobEntity';\n\nexport type RfqmQuoteConstructorOpts = Pick<RfqmQuoteEntity, 'chainId' | 'makerUri' | 'orderHash'> &\n    Partial<RfqmQuoteEntity>;\n\n@Entity({ name: 'rfqm_quotes' })\nexport class RfqmQuoteEntity {\n    @PrimaryColumn({ name: 'order_hash', type: 'varchar' })\n    public orderHash: string;\n\n    @Column({ name: 'metatransaction_hash', type: 'varchar', nullable: true, unique: true })\n    public metaTransactionHash: string | null;\n\n    @Index()\n    @Column({ name: 'created_at', type: 'timestamptz', default: () => 'now()' })\n    public createdAt!: Date;\n\n    @Column({ name: 'chain_id', type: 'integer' })\n    public chainId: number;\n\n    @Column({ name: 'integrator_id', type: 'varchar', nullable: true })\n    public integratorId: string | null;\n\n    @Column({ name: 'maker_uri', type: 'varchar' })\n    public makerUri: string;\n\n    @Column({ name: 'fee', type: 'jsonb', nullable: true })\n    public fee: StoredFee | null;\n\n    @Column({ name: 'order', type: 'jsonb', nullable: true })\n    public order: StoredOrder | null;\n\n    @Column({ name: 'affiliate_address', type: 'varchar', nullable: true })\n    public affiliateAddress: string | null;\n\n    // tslint:disable-next-line no-object-literal-type-assertion\n    constructor(opts: RfqmQuoteConstructorOpts = {} as RfqmQuoteConstructorOpts) {\n        // allow createdAt overrides for testing\n        if (opts.createdAt) {\n            this.createdAt = opts.createdAt;\n        }\n\n        this.affiliateAddress = opts.affiliateAddress || null;\n        this.chainId = opts.chainId;\n        this.fee = opts.fee || null;\n        this.integratorId = opts.integratorId || null;\n        this.makerUri = opts.makerUri;\n        this.metaTransactionHash = opts.metaTransactionHash || null;\n        this.order = opts.order || null;\n        this.orderHash = opts.orderHash;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { Column, Entity, Index, PrimaryColumn } from 'typeorm';\n\nimport { BigIntTransformer, BigNumberTransformer } from './transformers';\nimport { RfqmTransactionSubmissionStatus } from './types';\n\n@Entity({ name: 'rfqm_transaction_submissions' })\nexport class RfqmTransactionSubmissionEntity {\n    // Differentiator for different flavors of RFQM transactions\n    public kind: 'rfqm_v1_transaction_submission';\n\n    @PrimaryColumn({ name: 'transaction_hash', type: 'varchar' })\n    public transactionHash?: string;\n\n    // specified as a foreign key to rfqm jobs in migration, but not in the typeorm\n    // definition to preserve its being read as a string\n    @Column({ name: 'order_hash', type: 'varchar' })\n    public orderHash?: string;\n\n    @Index()\n    @Column({ name: 'created_at', type: 'timestamptz', default: () => 'now()' })\n    public createdAt!: Date;\n\n    @Column({ name: 'updated_at', type: 'timestamptz', nullable: true })\n    public updatedAt: Date | null;\n\n    @Column({ name: 'from', type: 'varchar', nullable: true })\n    public from: string | null;\n\n    @Column({ name: 'to', type: 'varchar', nullable: true })\n    public to: string | null;\n\n    @Column({ name: 'nonce', type: 'bigint', nullable: true, transformer: BigIntTransformer })\n    public nonce: number | null;\n\n    @Column({ name: 'gas_price', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public gasPrice: BigNumber | null;\n\n    @Column({ name: 'gas_used', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public gasUsed: BigNumber | null;\n\n    @Column({ name: 'max_fee_per_gas', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public maxFeePerGas: BigNumber | null;\n\n    @Column({ name: 'max_priority_fee_per_gas', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public maxPriorityFeePerGas: BigNumber | null;\n\n    @Column({ name: 'block_mined', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public blockMined: BigNumber | null;\n\n    @Index()\n    @Column({ name: 'status', type: 'varchar' })\n    public status: RfqmTransactionSubmissionStatus;\n\n    @Column({ name: 'status_reason', type: 'varchar', nullable: true })\n    public statusReason: string | null;\n\n    @Column({ name: 'metadata', type: 'jsonb', nullable: true })\n    public metadata: object | null;\n\n    constructor(opts: Partial<RfqmTransactionSubmissionEntity> = {}) {\n        this.kind = 'rfqm_v1_transaction_submission';\n\n        // allow createdAt overrides for testing\n        if (opts.createdAt) {\n            this.createdAt = opts.createdAt;\n        }\n\n        this.blockMined = opts.blockMined || null;\n        this.from = opts.from || null;\n        this.gasPrice = opts.gasPrice || null;\n        this.gasUsed = opts.gasUsed || null;\n        this.metadata = opts.metadata || null;\n        this.nonce = opts.nonce !== undefined ? opts.nonce : null;\n        this.orderHash = opts.orderHash;\n        this.status = opts.status || RfqmTransactionSubmissionStatus.Submitted;\n        this.statusReason = opts.statusReason || null;\n        this.to = opts.to || null;\n        this.transactionHash = opts.transactionHash;\n        this.updatedAt = opts.updatedAt || null;\n        this.maxFeePerGas = opts.maxFeePerGas || null;\n        this.maxPriorityFeePerGas = opts.maxPriorityFeePerGas || null;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts",{"fileContent":"import { Signature } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { Column, Entity, Index, PrimaryColumn, UpdateDateColumn } from 'typeorm';\n\nimport { Approval, StoredFee } from '../core/types';\n\nimport { BigNumberTransformer } from './transformers';\nimport { RfqmJobStatus, StoredOtcOrder } from './types';\n\nexport type RfqmV2JobApprovalOpts = Pick<RfqmV2JobEntity, 'approval' | 'approvalSignature'>;\n\nexport type RfqmV2JobConstructorOpts = Pick<\n    RfqmV2JobEntity,\n    'chainId' | 'expiry' | 'fee' | 'makerUri' | 'order' | 'orderHash'\n> &\n    Partial<RfqmV2JobEntity>;\n\n@Entity({ name: 'rfqm_v2_jobs' })\nexport class RfqmV2JobEntity {\n    // Differentiator for different flavors of RFQM jobs\n    public kind: 'rfqm_v2_job';\n\n    @PrimaryColumn({ name: 'order_hash', type: 'varchar' })\n    public orderHash: string;\n\n    @Index()\n    @Column({ name: 'created_at', type: 'timestamptz', default: () => 'now()' })\n    public createdAt!: Date;\n\n    @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz', nullable: true })\n    public updatedAt: Date | null;\n\n    // The expiration time of the job, in unix seconds\n    @Column({ name: 'expiry', type: 'numeric', transformer: BigNumberTransformer })\n    public expiry: BigNumber;\n\n    @Column({ name: 'chain_id', type: 'integer' })\n    public chainId: number;\n\n    @Column({ name: 'integrator_id', type: 'varchar', nullable: true })\n    public integratorId: string | null;\n\n    @Column({ name: 'maker_uri', type: 'varchar' })\n    public makerUri: string;\n\n    @Index()\n    @Column({ name: 'status', type: 'varchar' })\n    public status: RfqmJobStatus;\n\n    @Column({ name: 'fee', type: 'jsonb' })\n    public fee: StoredFee;\n\n    @Column({ name: 'order', type: 'jsonb' })\n    public order: StoredOtcOrder;\n\n    @Column({ name: 'worker_address', type: 'varchar', nullable: true })\n    public workerAddress: string | null;\n\n    @Column({ name: 'last_look_result', type: 'boolean', nullable: true })\n    public lastLookResult: boolean | null;\n\n    @Column({ name: 'affiliate_address', type: 'varchar', nullable: true })\n    public affiliateAddress: string | null;\n\n    // The taker's signature of the order hash.\n    // Should be deleted upon job failure or last look rejection.\n    @Column({ name: 'taker_signature', type: 'jsonb', nullable: true })\n    public takerSignature: Signature | null;\n\n    // The maker's signature of the order hash.\n    // Should be deleted upon job failure.\n    @Column({ name: 'maker_signature', type: 'jsonb', nullable: true })\n    public makerSignature: Signature | null;\n\n    // Whether the maker wrapped native token will be unwrapped to the native token\n    // when passed to the taker\n    @Column({ name: 'is_unwrap', type: Boolean })\n    public isUnwrap: boolean;\n\n    // When a market maker rejects a last look, the server queries the market maker\n    // for a price for the same trade that was just rejected (same pair and size).\n    // The difference between the rejected price and the new price is stored here.\n    @Column({ name: 'll_reject_price_difference_bps', type: 'integer', nullable: true })\n    public llRejectPriceDifferenceBps: number | null;\n\n    // The optional approval object that contains the EIP-712 context (which includes\n    // the message that the taker will sign). This is stored to help us prepare the\n    // calldata for gasless approvals\n    @Column({ name: 'approval', type: 'jsonb', nullable: true })\n    public approval: Approval | null;\n\n    // The signature for the approval.\n    @Column({ name: 'approval_signature', type: 'jsonb', nullable: true })\n    public approvalSignature: Signature | null;\n\n    // When requesting a quote, taker specifies one amount (maker or taker amount)\n    // and the MM populates the other field.\n    // This field preserves that information.\n    // This field is accepted to be null, only for backward compatibility,\n    // in normal operation \"taker_specified_side\" is always known.\n    @Column({ name: 'taker_specified_side', type: 'varchar', nullable: true })\n    public takerSpecifiedSide: 'makerToken' | 'takerToken' | null;\n\n    /**\n     * Used to get the 'canonical' hash of the job. This is useful\n     * because it can also be called on a metatransaction job and\n     * that will return the metatransaction hash.\n     */\n    public getHash(): string {\n        return this.orderHash;\n    }\n\n    // TypeORM runs a validation check where it calls this initializer with no argument.\n    // With no default `opts`, `opts` will be undefined and the validation will throw,\n    // therefore, add this hacky default.\n    // tslint:disable-next-line no-object-literal-type-assertion\n    constructor(opts: RfqmV2JobConstructorOpts = {} as RfqmV2JobConstructorOpts) {\n        this.kind = 'rfqm_v2_job';\n\n        // allow createdAt overrides for testing\n        if (opts.createdAt) {\n            this.createdAt = opts.createdAt;\n        }\n\n        this.affiliateAddress = opts.affiliateAddress ?? null;\n        this.approval = opts.approval ?? null;\n        this.approvalSignature = opts.approvalSignature ?? null;\n        this.chainId = opts.chainId;\n        this.expiry = opts.expiry;\n        this.fee = opts.fee;\n        this.integratorId = opts.integratorId ?? null;\n        this.isUnwrap = opts.isUnwrap ?? false;\n        this.lastLookResult = opts.lastLookResult ?? null;\n        this.llRejectPriceDifferenceBps = opts.llRejectPriceDifferenceBps ?? null;\n        this.makerSignature = opts.makerSignature ?? null;\n        this.makerUri = opts.makerUri;\n        this.order = opts.order;\n        this.orderHash = opts.orderHash;\n        this.status = opts.status ?? RfqmJobStatus.PendingEnqueued;\n        this.takerSignature = opts.takerSignature ?? null;\n        this.updatedAt = opts.updatedAt ?? null;\n        this.workerAddress = opts.workerAddress ?? null;\n        this.takerSpecifiedSide = opts.takerSpecifiedSide ?? null;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts",{"fileContent":"import { Column, Entity, Index, PrimaryColumn } from 'typeorm';\n\nimport { StoredFee } from '../core/types';\n\nimport { StoredOtcOrder } from './types';\n\nexport type RfqmV2QuoteConstructorOpts = Pick<\n    RfqmV2QuoteEntity,\n    'chainId' | 'fee' | 'makerUri' | 'orderHash' | 'order'\n> &\n    Partial<RfqmV2QuoteEntity>;\n\n@Entity({ name: 'rfqm_v2_quotes' })\nexport class RfqmV2QuoteEntity {\n    @PrimaryColumn({ name: 'order_hash', type: 'varchar' })\n    public orderHash: string;\n\n    @Index()\n    @Column({ name: 'created_at', type: 'timestamptz', default: () => 'now()' })\n    public createdAt!: Date;\n\n    @Column({ name: 'chain_id', type: 'integer' })\n    public chainId: number;\n\n    @Column({ name: 'integrator_id', type: 'varchar', nullable: true })\n    public integratorId: string | null;\n\n    @Column({ name: 'maker_uri', type: 'varchar' })\n    public makerUri: string;\n\n    @Column({ name: 'fee', type: 'jsonb' })\n    public fee: StoredFee;\n\n    @Column({ name: 'order', type: 'jsonb' })\n    public order: StoredOtcOrder;\n\n    // Whether the maker wrapped native token will be unwrapped to the native token\n    // when passed to the taker\n    @Column({ name: 'is_unwrap', type: 'boolean' })\n    public isUnwrap: boolean;\n\n    @Column({ name: 'affiliate_address', type: 'varchar', nullable: true })\n    public affiliateAddress: string | null;\n\n    // When requesting a quote, taker specifies one amount (maker or taker amount)\n    // and the MM populates the other field.\n    // This field preserves that information.\n    // This field is accepted to be null, only for backward compatibility,\n    // in normal operation \"taker_specified_side\" is always known.\n    @Column({ name: 'taker_specified_side', type: 'varchar', nullable: true })\n    public takerSpecifiedSide: 'makerToken' | 'takerToken' | null;\n\n    // tslint:disable-next-line no-object-literal-type-assertion\n    constructor(opts: RfqmV2QuoteConstructorOpts = {} as RfqmV2QuoteConstructorOpts) {\n        // allow createdAt overrides for testing\n        if (opts.createdAt) {\n            this.createdAt = opts.createdAt;\n        }\n\n        this.affiliateAddress = opts.affiliateAddress ?? null;\n        this.chainId = opts.chainId;\n        this.fee = opts.fee;\n        this.integratorId = opts.integratorId ?? null;\n        this.isUnwrap = opts.isUnwrap ?? false;\n        this.makerUri = opts.makerUri;\n        this.order = opts.order;\n        this.orderHash = opts.orderHash;\n        this.takerSpecifiedSide = opts.takerSpecifiedSide ?? null;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { Column, Entity, Index, PrimaryColumn, UpdateDateColumn } from 'typeorm';\n\nimport { BigIntTransformer, BigNumberTransformer } from './transformers';\nimport { RfqmTransactionSubmissionStatus, RfqmTransactionSubmissionType } from './types';\n\nexport type RfqmV2TransactionSubmissionEntityConstructorOpts = Pick<\n    RfqmV2TransactionSubmissionEntity,\n    'from' | 'nonce' | 'orderHash' | 'to' | 'transactionHash' | 'type'\n> &\n    Partial<RfqmV2TransactionSubmissionEntity>;\n\n@Entity({ name: 'rfqm_v2_transaction_submissions' })\nexport class RfqmV2TransactionSubmissionEntity {\n    public kind: 'rfqm_v2_transaction_submission';\n\n    @PrimaryColumn({ name: 'transaction_hash', type: 'varchar' })\n    public transactionHash: string;\n\n    // specified as a foreign key to rfqm jobs in migration, but not in the typeorm\n    // definition to preserve its being read as a string\n    @Index()\n    @Column({ name: 'order_hash', type: 'varchar' })\n    public orderHash: string;\n\n    @Index()\n    @Column({ name: 'created_at', type: 'timestamptz', default: () => 'now()' })\n    public createdAt!: Date;\n\n    @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz', nullable: true })\n    public updatedAt: Date | null;\n\n    @Column({ name: 'from', type: 'varchar' })\n    public from: string;\n\n    @Column({ name: 'to', type: 'varchar' })\n    public to: string;\n\n    @Column({ name: 'nonce', type: 'bigint', transformer: BigIntTransformer })\n    public nonce: number;\n\n    // The gas price in wei. Set at transaction submission time in non-EIP1559 transactions. In EIP1559 transactions, this is set once we have the transaction receipt.\n    @Column({ name: 'gas_price', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public gasPrice: BigNumber | null;\n\n    // Max fee per gas in wei. Present in type 2 \"EIP1559\" transactions.\n    @Column({ name: 'max_fee_per_gas', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public maxFeePerGas: BigNumber | null;\n\n    // Max priority fee per gas in wei. Present in type 2 \"EIP1559\" transactions.\n    @Column({ name: 'max_priority_fee_per_gas', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public maxPriorityFeePerGas: BigNumber | null;\n\n    @Column({ name: 'gas_used', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public gasUsed: BigNumber | null;\n\n    @Column({ name: 'block_mined', type: 'numeric', nullable: true, transformer: BigNumberTransformer })\n    public blockMined: BigNumber | null;\n\n    @Index()\n    @Column({ name: 'status', type: 'varchar' })\n    public status: RfqmTransactionSubmissionStatus;\n\n    @Column({ name: 'type', type: 'varchar' })\n    public type: RfqmTransactionSubmissionType;\n\n    constructor(\n        // tslint:disable-next-line no-object-literal-type-assertion\n        opts: RfqmV2TransactionSubmissionEntityConstructorOpts = {} as RfqmV2TransactionSubmissionEntityConstructorOpts,\n    ) {\n        this.kind = 'rfqm_v2_transaction_submission';\n\n        // allow createdAt overrides for testing\n        if (opts.createdAt) {\n            this.createdAt = opts.createdAt;\n        }\n\n        this.blockMined = opts.blockMined ?? null;\n        this.from = opts.from;\n        this.gasPrice = opts.gasPrice ?? null;\n        this.gasUsed = opts.gasUsed ?? null;\n        this.maxFeePerGas = opts.maxFeePerGas ?? null;\n        this.maxPriorityFeePerGas = opts.maxPriorityFeePerGas ?? null;\n        this.nonce = opts.nonce;\n        this.orderHash = opts.orderHash;\n        this.status = opts.status ?? RfqmTransactionSubmissionStatus.Submitted;\n        this.to = opts.to;\n        this.transactionHash = opts.transactionHash;\n        this.type = opts.type;\n        this.updatedAt = opts.updatedAt ?? null;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { Column, Entity, PrimaryColumn } from 'typeorm';\n\nimport { BigNumberTransformer } from './transformers';\n\nexport type RfqmWorkerHeartbeatOptions = Pick<RfqmWorkerHeartbeatEntity, 'address' | 'balance' | 'index' | 'chainId'> &\n    Partial<RfqmWorkerHeartbeatEntity>;\n\n@Entity({ name: 'rfqm_worker_heartbeats' })\nexport class RfqmWorkerHeartbeatEntity {\n    // The blockchain address of the worker\n    @PrimaryColumn({ name: 'address', type: 'varchar' })\n    public address: string;\n\n    // The time the report was created\n    @Column({ name: 'timestamp', type: 'timestamptz', default: () => 'now()' })\n    public timestamp!: Date;\n\n    // The native token balance of the worker\n    @Column({ name: 'balance', type: 'numeric', transformer: BigNumberTransformer })\n    public balance: BigNumber;\n\n    // The worker index assigned to the worker's ENV by Kubernetes\n    @Column({ name: 'index', type: 'int' })\n    public index: number;\n\n    // The chain ID of the chain the worker is active on.\n    @PrimaryColumn({ name: 'chain_id', type: 'int' })\n    public chainId: number;\n\n    // TypeORM runs a validation check where it calls this initializer with no argument.\n    // With no default `opts`, `opts` will be undefined and the validation will throw,\n    // therefore, add this hacky default.\n    // tslint:disable-next-line no-object-literal-type-assertion\n    constructor(opts: RfqmWorkerHeartbeatOptions = {} as RfqmWorkerHeartbeatOptions) {\n        if (opts.timestamp) {\n            this.timestamp = opts.timestamp;\n        }\n        this.address = opts.address;\n        this.balance = opts.balance;\n        this.chainId = opts.chainId;\n        this.index = opts.index;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts",{"fileContent":"import { Column, Entity, PrimaryColumn, UpdateDateColumn } from 'typeorm';\n\nexport type RfqMakerOpts = Pick<RfqMaker, 'makerId' | 'chainId' | 'pairs' | 'rfqtUri' | 'rfqmUri'> & Partial<RfqMaker>;\n\n/**\n * A representation of the pairs a market maker is active on for a given chain ID\n */\n@Entity({ name: 'rfq_maker_pairs' })\nexport class RfqMaker {\n    @PrimaryColumn({ name: 'maker_id', type: 'varchar' })\n    public makerId: string;\n\n    @PrimaryColumn({ name: 'chain_id', type: 'integer' })\n    public chainId: number;\n\n    @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz', nullable: true })\n    public updatedAt: Date | null;\n\n    @Column({ name: 'pairs', type: 'jsonb' })\n    public pairs: [string, string][];\n\n    @Column({ name: 'rfqt_uri', type: 'varchar' })\n    public rfqtUri: string | null;\n\n    @Column({ name: 'rfqm_uri', type: 'varchar' })\n    public rfqmUri: string | null;\n\n    // TypeORM runs a validation check where it calls this initializer with no argument.\n    // With no default `opts`, `opts` will be undefined and the validation will throw,\n    // therefore, add this hacky default.\n    // tslint:disable-next-line no-object-literal-type-assertion\n    constructor(opts: RfqMakerOpts = {} as RfqMakerOpts) {\n        this.makerId = opts.makerId;\n        this.chainId = opts.chainId;\n        this.pairs = opts.pairs;\n        this.rfqtUri = opts.rfqtUri;\n        this.rfqmUri = opts.rfqmUri;\n        this.updatedAt = opts.updatedAt ?? null;\n    }\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts",{"fileContent":"import { ViewColumn, ViewEntity } from 'typeorm';\n\nexport type RfqMakerUpdateTimeHashOpts = Pick<RfqMakerUpdateTimeHash, 'hash' | 'chainId'> &\n    Partial<RfqMakerUpdateTimeHash>;\n\n/**\n * A materialized view for a hash of all makers' last update time for each chain.\n * The materialized view will be updated immidiately after table `rfq_maker_pairs` is updated.\n * The hashes (one per chain) are used by RfqMakerManger to determine whether a refresh is needed.\n * The expression of ViewEntity is duplicated with the corresponding mirgation file, and is only used when\n * `synchronize` is set to `true` which is the case when running some test cases.\n */\n@ViewEntity({\n    name: 'rfq_maker_pairs_update_time_hashes',\n    expression: `\n        SELECT\n            encode(\n                digest(\n                    array_agg(\n                        updated_at ORDER BY updated_at NULLS FIRST\n                    )::text,\n                'sha256'),\n            'hex') AS hash,\n            chain_id\n        FROM rfq_maker_pairs\n        GROUP BY chain_id\n    `,\n})\nexport class RfqMakerUpdateTimeHash {\n    @ViewColumn({ name: 'chain_id' })\n    public chainId: number;\n\n    @ViewColumn({ name: 'hash' })\n    public hash: string;\n\n    // TypeORM runs a validation check where it calls this initializer with no argument.\n    // With no default `opts`, `opts` will be undefined and the validation will throw,\n    // therefore, add this hacky default.\n    // tslint:disable-next-line no-object-literal-type-assertion\n    constructor(opts: RfqMakerUpdateTimeHashOpts = {} as RfqMakerUpdateTimeHashOpts) {\n        this.chainId = opts.chainId;\n        this.hash = opts.hash;\n    }\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts",{"fileContent":"import { Column, Entity, Index, PrimaryColumn } from 'typeorm';\n\n@Entity({ name: 'signed_orders' })\n@Index(['makerAssetData', 'takerAssetData'], { unique: false })\nexport class SignedOrderEntity {\n    @PrimaryColumn({ name: 'hash', type: 'varchar' })\n    public hash?: string;\n\n    @Column({ name: 'sender_address', type: 'varchar' })\n    public senderAddress?: string;\n\n    @Index()\n    @Column({ name: 'maker_address', type: 'varchar' })\n    public makerAddress?: string;\n\n    @Column({ name: 'taker_address', type: 'varchar' })\n    public takerAddress?: string;\n\n    @Index()\n    @Column({ name: 'maker_asset_data', type: 'varchar' })\n    public makerAssetData?: string;\n\n    @Index()\n    @Column({ name: 'taker_asset_data', type: 'varchar' })\n    public takerAssetData?: string;\n\n    @Column({ name: 'exchange_address', type: 'varchar' })\n    public exchangeAddress?: string;\n\n    @Index()\n    @Column({ name: 'fee_recipient_address', type: 'varchar' })\n    public feeRecipientAddress?: string;\n\n    @Column({ name: 'expiration_time_seconds', type: 'varchar' })\n    public expirationTimeSeconds?: string;\n\n    @Column({ name: 'maker_fee', type: 'varchar' })\n    public makerFee?: string;\n\n    @Column({ name: 'taker_fee', type: 'varchar' })\n    public takerFee?: string;\n\n    @Column({ name: 'maker_asset_amount', type: 'varchar' })\n    public makerAssetAmount?: string;\n\n    @Column({ name: 'taker_asset_amount', type: 'varchar' })\n    public takerAssetAmount?: string;\n\n    @Column({ name: 'salt', type: 'varchar' })\n    public salt?: string;\n\n    @Column({ name: 'signature', type: 'varchar' })\n    public signature?: string;\n\n    @Column({ name: 'remaining_fillable_taker_asset_amount', type: 'varchar' })\n    public remainingFillableTakerAssetAmount?: string;\n\n    @Column({ name: 'maker_fee_asset_data', type: 'varchar' })\n    public makerFeeAssetData?: string;\n\n    @Column({ name: 'taker_fee_asset_data', type: 'varchar' })\n    public takerFeeAssetData?: string;\n\n    @Column({ name: 'created_at', type: 'timestamptz', default: () => 'now()' })\n    public createdAt?: string;\n    constructor(\n        opts: {\n            hash?: string;\n            senderAddress?: string;\n            makerAddress?: string;\n            takerAddress?: string;\n            makerAssetData?: string;\n            takerAssetData?: string;\n            exchangeAddress?: string;\n            feeRecipientAddress?: string;\n            expirationTimeSeconds?: string;\n            makerFee?: string;\n            takerFee?: string;\n            makerFeeAssetData?: string;\n            takerFeeAssetData?: string;\n            makerAssetAmount?: string;\n            takerAssetAmount?: string;\n            salt?: string;\n            signature?: string;\n            remainingFillableTakerAssetAmount?: string;\n        } = {},\n    ) {\n        this.hash = opts.hash;\n        this.senderAddress = opts.senderAddress;\n        this.makerAddress = opts.makerAddress;\n        this.takerAddress = opts.takerAddress;\n        this.makerAssetData = opts.makerAssetData;\n        this.takerAssetData = opts.takerAssetData;\n        this.exchangeAddress = opts.exchangeAddress;\n        this.feeRecipientAddress = opts.feeRecipientAddress;\n        this.expirationTimeSeconds = opts.expirationTimeSeconds;\n        this.makerFee = opts.makerFee;\n        this.takerFee = opts.takerFee;\n        this.makerFeeAssetData = opts.makerFeeAssetData;\n        this.takerFeeAssetData = opts.takerFeeAssetData;\n        this.makerAssetAmount = opts.makerAssetAmount;\n        this.takerAssetAmount = opts.takerAssetAmount;\n        this.salt = opts.salt;\n        this.signature = opts.signature;\n        this.remainingFillableTakerAssetAmount = opts.remainingFillableTakerAssetAmount;\n    }\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts",{"fileContent":"import { PrimaryColumn, ViewColumn, ViewEntity } from 'typeorm';\n\n@ViewEntity({\n    name: 'valid_signed_orders_v4',\n    materialized: true,\n    synchronize: false,\n})\nclass ValidSignedOrderV4Entity {\n    @PrimaryColumn({ name: 'hash' })\n    public hash?: string;\n\n    @ViewColumn({ name: 'maker_token' })\n    public makerToken?: string;\n\n    @ViewColumn({ name: 'taker_token' })\n    public takerToken?: string;\n\n    @ViewColumn({ name: 'maker_amount' })\n    public makerAmount?: string;\n\n    @ViewColumn({ name: 'taker_amount' })\n    public takerAmount?: string;\n\n    @ViewColumn()\n    public maker?: string;\n\n    @ViewColumn()\n    public taker?: string;\n\n    @ViewColumn()\n    public pool?: string;\n\n    @ViewColumn()\n    public expiry?: string;\n\n    @ViewColumn()\n    public salt?: string;\n\n    @ViewColumn({ name: 'verifying_contract' })\n    public verifyingContract?: string;\n\n    @ViewColumn({ name: 'taker_token_fee_amount' })\n    public takerTokenFeeAmount?: string;\n\n    @ViewColumn()\n    public sender?: string;\n\n    @ViewColumn({ name: 'fee_recipient' })\n    public feeRecipient?: string;\n\n    @ViewColumn()\n    public signature?: string;\n\n    @ViewColumn({ name: 'remaining_fillable_taker_amount' })\n    public remainingFillableTakerAmount?: string;\n\n    @ViewColumn({ name: 'created_at' })\n    public createdAt?: string;\n\n    constructor(\n        opts: {\n            hash?: string;\n            makerToken?: string;\n            takerToken?: string;\n            makerAmount?: string;\n            takerAmount?: string;\n            maker?: string;\n            taker?: string;\n            pool?: string;\n            expiry?: string;\n            salt?: string;\n            verifyingContract?: string;\n            takerTokenFeeAmount?: string;\n            sender?: string;\n            feeRecipient?: string;\n            signature?: string;\n            remainingFillableTakerAmount?: string;\n        } = {},\n    ) {\n        Object.assign(this, opts);\n    }\n}\n\nexport { ValidSignedOrderV4Entity as SignedOrderV4Entity };\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts",{"fileContent":"import { assert } from '@0x/assert';\nimport { BigNumber } from '@0x/utils';\nimport { Column, CreateDateColumn, Entity, PrimaryColumn, UpdateDateColumn } from 'typeorm';\n\nimport { META_TXN_RELAY_EXPECTED_MINED_SEC } from '../config';\nimport { ONE_SECOND_MS, ZERO } from '../core/constants';\n\nimport { BigIntTransformer, BigNumberTransformer } from './transformers';\nimport { TransactionEntityOpts } from './types';\n\nenum TransactionStates {\n    // transaction has been constructed, but not yet submitted to the network.\n    Unsubmitted = 'unsubmitted',\n    // transaction has been submitted to the network.\n    Submitted = 'submitted',\n    // transaction has been spotted in the mempool.\n    Mempool = 'mempool',\n    // transaction has not been mined in the expected time.\n    Stuck = 'stuck',\n    // transaction has been mined.\n    Included = 'included',\n    // transaction is confirmed.\n    Confirmed = 'confirmed',\n    // transaction is no longer in the mempool.\n    Dropped = 'dropped',\n    // transaction has been aborted because a new transaction with the same\n    // nonce has been mined.\n    Aborted = 'aborted',\n    // transaction was in an unsubmitted state for too long.\n    Cancelled = 'cancelled',\n}\n\n@Entity({ name: 'transactions' })\nexport class TransactionEntity {\n    @PrimaryColumn({ name: 'ref_hash', type: 'varchar' })\n    // reference hash can be either be the zeroExTransaction hash or the actual\n    // txHash depending on whether we are submitting a meta-transaction or an\n    // unsticking ethereum transaction.\n    public refHash: string;\n\n    @Column({ name: 'data', type: 'varchar', nullable: true })\n    public data?: string;\n\n    @Column({ name: 'to', type: 'varchar' })\n    public to?: string;\n\n    @Column({ name: 'tx_hash', type: 'varchar', unique: true, nullable: true })\n    public txHash?: string;\n\n    @Column({ name: 'status', type: 'varchar' })\n    public status: string;\n\n    @Column({ name: 'taker_address', type: 'varchar', nullable: true })\n    public takerAddress?: string;\n\n    @Column({ name: 'expected_mined_in_sec', type: 'int' })\n    public expectedMinedInSec?: number;\n\n    @Column({ name: 'gas_price', type: 'bigint', nullable: true, transformer: BigNumberTransformer })\n    public gasPrice?: BigNumber;\n\n    @Column({ name: 'value', type: 'bigint', nullable: true, transformer: BigNumberTransformer })\n    public value?: BigNumber;\n\n    @Column({ name: 'gas', type: 'int', nullable: true })\n    public gas?: number | null;\n\n    @Column({ name: 'from', type: 'varchar', nullable: true })\n    public from?: string;\n\n    @Column({ name: 'nonce', type: 'bigint', nullable: true, transformer: BigIntTransformer })\n    public nonce?: number;\n\n    @Column({ name: 'gas_used', type: 'int', nullable: true })\n    public gasUsed?: number | null;\n\n    @Column({ name: 'block_number', type: 'bigint', nullable: true, transformer: BigIntTransformer })\n    public blockNumber?: number;\n\n    @Column({ name: 'tx_status', type: 'int', nullable: true })\n    public txStatus?: number | null;\n\n    @Column({ name: 'api_key', type: 'varchar', nullable: true })\n    public apiKey?: string;\n\n    @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })\n    public createdAt?: Date;\n\n    @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })\n    public updatedAt?: Date;\n\n    @Column({ name: 'expected_at', type: 'timestamptz' })\n    public expectedAt: Date;\n\n    public static make(opts: TransactionEntityOpts): TransactionEntity {\n        assert.isHexString('refHash', opts.refHash);\n        if (opts.txHash !== undefined) {\n            assert.isHexString('txHash', opts.txHash);\n        }\n        if (opts.from !== undefined) {\n            assert.isETHAddressHex('from', opts.from);\n        }\n        assert.doesBelongToStringEnum('status', opts.status, TransactionStates);\n        if (opts.nonce !== undefined && !Number.isInteger(opts.nonce) && opts.nonce <= 0) {\n            throw new Error(`Expected nonce to be a positive integer, encountered: ${opts.nonce}`);\n        }\n        if (opts.blockNumber !== undefined && !Number.isInteger(opts.blockNumber) && opts.blockNumber <= 0) {\n            throw new Error(`Expected blockNumber to be a positive integer, encountered: ${opts.blockNumber}`);\n        }\n        return new TransactionEntity(opts);\n    }\n\n    // HACK(oskar) we want all fields to be set and valid, otherwise we should\n    // not accept a transaction entity, however because of this issue:\n    // https://github.com/typeorm/typeorm/issues/1772 we cannot accept undefined\n    // as an argument to the constructor, to not break migrations with\n    // serialize. Please use the public static make method instead.\n    private constructor(\n        opts: TransactionEntityOpts = {\n            refHash: '',\n            txHash: '',\n            to: '',\n            data: '',\n            apiKey: '',\n            takerAddress: '',\n            status: '',\n            expectedMinedInSec: META_TXN_RELAY_EXPECTED_MINED_SEC,\n            nonce: 0,\n            gasPrice: ZERO,\n            value: ZERO,\n            from: '',\n            gas: null,\n            gasUsed: null,\n            txStatus: null,\n        },\n    ) {\n        this.refHash = opts.refHash;\n        this.txHash = opts.txHash;\n        this.takerAddress = opts.takerAddress;\n        this.to = opts.to;\n        this.data = opts.data;\n        this.apiKey = opts.apiKey;\n        this.status = opts.status;\n        this.expectedMinedInSec = opts.expectedMinedInSec;\n        this.nonce = opts.nonce;\n        this.gasPrice = opts.gasPrice;\n        this.value = opts.value;\n        this.blockNumber = opts.blockNumber;\n        this.from = opts.from;\n        this.gas = opts.gas;\n        this.gasUsed = opts.gasUsed;\n        this.txStatus = opts.txStatus;\n        const now = new Date();\n        this.expectedAt = new Date(now.getTime() + this.expectedMinedInSec * ONE_SECOND_MS);\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers max-file-line-count\nimport { HttpServiceConfig } from '@0x/api-utils';\nimport { assert } from '@0x/assert';\nimport { ChainId } from '@0x/contract-addresses';\nimport { BigNumber } from '@0x/utils';\nimport * as fs from 'fs';\nimport * as _ from 'lodash';\nimport * as validateUUID from 'uuid-validate';\n\nimport {\n    DEFAULT_BACKGROUND_JOB_TYPES,\n    DEFAULT_ETH_GAS_STATION_API_URL,\n    DEFAULT_EXPECTED_MINED_SEC,\n    DEFAULT_LOCAL_POSTGRES_URI,\n    DEFAULT_LOCAL_REDIS_URI,\n    DEFAULT_LOGGER_INCLUDE_TIMESTAMP,\n    DEFAULT_SENTRY_ENVIRONMENT,\n    HEALTHCHECK_PATH,\n    METRICS_PATH,\n    NULL_ADDRESS,\n    ONE_MINUTE_MS,\n} from './core/constants';\nimport { schemas } from './core/schemas';\nimport { FeeModelVersion } from './core/types';\nimport { toPairString } from './core/pair_utils';\nimport { schemaUtils } from './core/schema_utils';\n\n// tslint:disable:no-bitwise\n\nenum EnvVarType {\n    AddressList,\n    StringList,\n    Integer,\n    Port,\n    KeepAliveTimeout,\n    ChainId,\n    ETHAddressHex,\n    UnitAmount,\n    Rate,\n    Url,\n    UrlList,\n    WhitelistAllTokens,\n    Boolean,\n    NonEmptyString,\n    APIKeys,\n    PrivateKeys,\n    RfqMakerAssetOfferings,\n    LiquidityProviderRegistry,\n    JsonStringList,\n}\n\n/**\n * Values read from configuration files which enable\n * rfq-api to operate on a chain.\n */\nexport interface ChainConfiguration {\n    chainId: number;\n    gasStationUrl: string;\n    name: string; // human readable, for logging and such\n    registryAddress: string;\n    rpcUrl: string;\n    sqsUrl: string;\n    zeroExClientBaseUrl: string;\n    // Enables caching for maker balances on observed tokens\n    enableMakerBalanceCache?: boolean;\n    // Use this config to override the 0x Exchange Proxy contract address.\n    // There might be a case when we want a different exchange\n    // proxy contract than what is defined from @0x/contract-addresses repo.\n    //\n    // i.e. testing a new feature that hasn't been deployed to the official\n    // contract yet\n    exchangeProxyContractAddressOverride?: string;\n    // Service configuration needs to be present to run the corresponding service.\n    gasless?: {\n        metaTransactionServiceUrl: string;\n    };\n    rfqm?: {\n        minExpiryDurationMs?: number;\n        quoteReportTopic?: string;\n        feeModelVersion?: FeeModelVersion;\n    };\n    rfqt?: {\n        minExpiryDurationMs?: number;\n        feeEventTopic?: string;\n        feeModelVersion?: FeeModelVersion;\n    };\n    worker?: {\n        // The value of the \"tip\" the worker will use when it starts\n        // submitting transactions\n        initialMaxPriorityFeePerGasGwei: number;\n        // The max fee per gas (in gwei) the worker is willing to pay for a transaction\n        maxFeePerGasCapGwei: number;\n        // Use this config to change the sleep time between a transacion's on-chain status check.\n        // You should set the sleep time close to the chain's block time.\n        // The smaller sleep time, the more frequent a transaction is checked to see it has been\n        // settled on-chain but it also consumes more RPC calls.\n        transactionWatcherSleepTimeMs?: number;\n        enableAccessList?: boolean;\n    };\n}\n\nexport type ChainConfigurations = ChainConfiguration[];\n\n/**\n * Configuration which contains information about chains and\n * related resources, like the RPC url.\n */\nexport const CHAIN_CONFIGURATIONS: ChainConfigurations = (() => {\n    let result: ChainConfigurations;\n    try {\n        result = resolveEnvVar<ChainConfigurations>('CHAIN_CONFIGURATIONS', EnvVarType.JsonStringList, []);\n        schemaUtils.validateSchema(result, schemas.chainConfigurationsSchema);\n    } catch (e) {\n        throw new Error(`CHAIN_CONFIGURATIONS was defined but is not valid JSON per the schema: ${e}`);\n    }\n    return result;\n})();\n\nexport interface ZeroExFeeConfigEntryBase {\n    volumePercentage?: number;\n    integratorSharePercentage?: number;\n    // marginRakePercentage?: number; // for RFQ liqiduity\n}\n\n/**\n * 0x fee config entry for pairs.\n *\n * For example, this means the following pair take 10% volume fee.\n *  {\n *      kind: 'pair',\n *      pairs: [\n *          {\n *              tokenA: '0x123456...',\n *              tokenB: '0x654321...',\n *              label: 'token1-token2',\n *          },\n *          {\n *              tokenA: '0x13579...',\n *              tokenB: '0x24681...',\n *              label: 'token3-token4',\n *          }\n *      ],\n *      volumePercentage: 10\n *  }\n */\nexport interface Pairs extends ZeroExFeeConfigEntryBase {\n    kind: 'pairs';\n    pairs: {\n        tokenA: string;\n        tokenB: string;\n        label: string;\n    }[];\n}\n\n/**\n * 0x fee config entry for cartesian_product.\n *\n * For example, this means for any of the 4 combination between `setA` and `setB`, the pair takes 5% volume fee\n * {\n *      kind: 'cartesian_product',\n *      setA: [\n *          {\n *              token: '0x123455...',\n *              label: 'token5',\n *          },\n *          {\n *              token: '0x123457...',\n *              label: 'token6',\n *          }\n *      ],\n *      setB: [\n *          {\n *              token: '0x123458...',\n *              label: 'token7',\n *          },\n *          {\n *              token: '0x123459...',\n *              label: 'token8',\n *          }\n *      ],\n *      volumePercentage: 5\n * }\n */\nexport interface CartesianProduct extends ZeroExFeeConfigEntryBase {\n    kind: 'cartesian_product';\n    setA: {\n        token: string;\n        label: string;\n    }[];\n    setB: {\n        token: string;\n        label: string;\n    }[];\n}\n\n/**\n * 0x fee config entry for tokens.\n *\n * For example, this means if token9 or token10 is either sell / buy token, there is a 2% volume fee\n * {\n *      kind: 'tokens',\n *      tokens: [\n *          {\n *              token: '0x1234510...',\n *              label: 'token9',\n *          },\n *          {\n *              token: '0x12345711...',\n *              label: 'token10',\n *          }\n *      ]\n *      volumePercentage: 2\n * }\n */\nexport interface Tokens extends ZeroExFeeConfigEntryBase {\n    kind: 'tokens';\n    tokens: {\n        token: string;\n        label: string;\n    }[];\n}\n\nexport type ZeroExFeeConigurationEntry = Pairs | CartesianProduct | Tokens;\n\n// Raw 0x fee configuration read directly from config file\ninterface ZeroExFeeRawConfiguration {\n    name: string; // human readable integrator name\n    integratorId: string;\n    chainId: number;\n    feeOn: 'volume' | 'integrator_share' /* | 'price_improvement' */; // 'price_improvement' is for RFQ liquidity\n    zeroEx: {\n        // fee recipient and billing type for 0x fee\n        feeRecipient: string | null;\n        billingType: 'on-chain' | 'off-chain';\n    };\n    gas: {\n        // fee recipient and billing type for gas fee\n        feeRecipient: string | null;\n        billingType: 'on-chain' | 'off-chain';\n    };\n    fees: ZeroExFeeConigurationEntry[];\n}\n\ntype ZeroExFeeRawConfigurations = ZeroExFeeRawConfiguration[];\n\n// Processed raw 0x fee configuration\nexport interface ZeroExFeeConfiguration {\n    name: string;\n    feeOn: 'volume' | 'integrator_share' /* | 'price_improvement' */; // 'price_improvement' is for RFQ liquidity\n    zeroEx: {\n        feeRecipient: string | null;\n        billingType: 'on-chain' | 'off-chain';\n    };\n    gas: {\n        feeRecipient: string | null;\n        billingType: 'on-chain' | 'off-chain';\n    };\n    pairsFeeEntries: Map<string, BigNumber>; // tokenA-tokenB: <fee_parameter>; tokenA <= tokenB\n    cartesianProductFeeEntries: {\n        setA: Set<string>;\n        setB: Set<string>;\n        parameter: BigNumber;\n    }[];\n    tokensEntries: Map<string, BigNumber>; // tokenA-tokenB: <fee_parameter>; tokenA <= tokenB\n}\n\nexport const ZERO_EX_FEE_CONFIGURATION_MAP: Map<string, Map<number, ZeroExFeeConfiguration>> = (() => {\n    try {\n        const zeroExFeeRawConfigurations = resolveEnvVar<ZeroExFeeRawConfigurations>(\n            'ZERO_EX_FEE_CONFIGURATIONS',\n            EnvVarType.JsonStringList,\n            [],\n        );\n        schemaUtils.validateSchema(zeroExFeeRawConfigurations, schemas.zeroExFeeConfigurationsSchema);\n\n        return zeroExFeeRawConfigurations.reduce((acc, curr) => {\n            const { integratorId, chainId } = curr;\n            if (!acc.get(integratorId)) {\n                acc.set(integratorId, new Map<number, ZeroExFeeConfiguration>());\n            }\n\n            const pairsFeeEntries = new Map<string, BigNumber>();\n            const cartesianProductFeeEntries: {\n                setA: Set<string>;\n                setB: Set<string>;\n                parameter: BigNumber;\n            }[] = [];\n            const tokensEntries = new Map<string, BigNumber>();\n\n            curr.fees.forEach((feeConfig) => {\n                let feeParameter: BigNumber;\n                switch (curr.feeOn) {\n                    case 'volume':\n                        if (feeConfig.volumePercentage === undefined) {\n                            throw new Error(`volumePercentage not defined for ${curr.integratorId} for fee on volume`);\n                        }\n                        feeParameter = new BigNumber(feeConfig.volumePercentage);\n                        break;\n                    case 'integrator_share':\n                        if (feeConfig.integratorSharePercentage === undefined) {\n                            throw new Error(\n                                `integratorSharePercentage not defined for ${curr.integratorId} for fee on volume`,\n                            );\n                        }\n                        feeParameter = new BigNumber(feeConfig.integratorSharePercentage);\n                        break;\n                    default:\n                        ((_x: never) => {\n                            throw new Error('unreachable');\n                        })(curr.feeOn);\n                }\n\n                if (feeConfig.kind === 'pairs') {\n                    // parse config entries that are of kind `pairs`\n                    feeConfig.pairs.forEach(({ tokenA, tokenB }) => {\n                        pairsFeeEntries.set(toPairString(tokenA, tokenB), feeParameter);\n                    });\n                } else if (feeConfig.kind === 'cartesian_product') {\n                    // parse config entries that are of kind `cartesian_product`\n                    cartesianProductFeeEntries.push({\n                        setA: new Set(feeConfig.setA.map((tokenAndLabel) => tokenAndLabel.token.toLocaleLowerCase())),\n                        setB: new Set(feeConfig.setB.map((tokenAndLabel) => tokenAndLabel.token.toLocaleLowerCase())),\n                        parameter: feeParameter,\n                    });\n                } else if (feeConfig.kind === 'tokens') {\n                    // parse config entries that are of kind `tokens`\n                    feeConfig.tokens.forEach((tokenAndLabel) => {\n                        tokensEntries.set(tokenAndLabel.token.toLocaleLowerCase(), feeParameter);\n                    });\n                }\n            });\n\n            // Compiler can't track the state of TypeScript map. We need to perform a undefined check even if\n            // the value has been set for the integratorId previously. More discussion: https://stackoverflow.com/a/70726571\n            const feeConfigByChainId = acc.get(integratorId);\n            if (!feeConfigByChainId) {\n                // This should never happen\n                throw new Error(`${integratorId} is not set`);\n            }\n\n            feeConfigByChainId.set(chainId, {\n                name: curr.name,\n                feeOn: curr.feeOn,\n                zeroEx: {\n                    feeRecipient: curr.zeroEx.feeRecipient,\n                    billingType: curr.zeroEx.billingType,\n                },\n                gas: {\n                    feeRecipient: curr.gas.feeRecipient,\n                    billingType: curr.gas.billingType,\n                },\n                pairsFeeEntries,\n                cartesianProductFeeEntries,\n                tokensEntries,\n            });\n            return acc;\n        }, new Map</* integratorId */ string, Map</* chainId */ number, ZeroExFeeConfiguration>>());\n    } catch (e) {\n        throw new Error(`ZERO_EX_FEE_CONFIGURATIONS was defined but is not valid JSON per the schema: ${e}`);\n    }\n})();\n\n/**\n * Values read from configuration files which provide\n * per pair fee model constants.\n */\nexport interface FeeModelConfiguration {\n    marginRakeRatio: number; // Rake based on margin between RFQm and AMM prices. E.g. marginRakeRatio = 0.5 if we want to charge 50% of the margin.\n    tradeSizeBps: number; // Base points of fee based on trade size. 1 bps = 0.01%.\n}\n\n/**\n * This interface is used to represent an individual JSON object for a given chain and pair.\n * It is only used when we read the JSON object from a file, and should not be used elsewhere.\n */\ninterface FeeModelConfigurationWithKey extends FeeModelConfiguration {\n    chainId: number;\n    tokenA: string;\n    tokenB: string;\n}\n\nexport type FeeModelConfigurationMap = Map<number, Map<string, FeeModelConfiguration>>;\n\n/**\n * A nested map providing fee model constants for each token pair.\n * Use chainId as first key and pair key as the second key.\n */\nexport const FEE_MODEL_CONFIGURATION_MAP: FeeModelConfigurationMap = (() => {\n    try {\n        const feeModelConfigurations: FeeModelConfigurationWithKey[] = resolveEnvVar<FeeModelConfigurationWithKey[]>(\n            'FEE_MODEL_CONFIGURATIONS',\n            EnvVarType.JsonStringList,\n            [],\n        );\n        schemaUtils.validateSchema(feeModelConfigurations, schemas.feeModelConfigurationsSchema);\n\n        return feeModelConfigurations.reduce((acc, curr) => {\n            const { chainId, tokenA, tokenB, marginRakeRatio, tradeSizeBps } = curr;\n            if (!acc.has(chainId)) {\n                acc.set(chainId, new Map<string, FeeModelConfiguration>());\n            }\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            acc.get(chainId)!.set(toPairString(tokenA, tokenB), { marginRakeRatio, tradeSizeBps });\n            return acc;\n        }, new Map</* chainId */ number, Map</* pairKey */ string, FeeModelConfiguration>>());\n    } catch (e) {\n        throw new Error(`FEE_MODEL_CONFIGURATIONS was defined but is not valid JSON per the schema: ${e}`);\n    }\n})();\n\nexport const DEFAULT_FEE_MODEL_CONFIGURATION: FeeModelConfiguration = { marginRakeRatio: 0, tradeSizeBps: 0 };\n\n/**\n * A taker-integrator of the 0x API.\n */\nexport interface Integrator {\n    affiliateAddress?: string; // Used if present and no affiliate address is sent in the quote request\n    apiKeys: string[];\n    integratorId: string;\n    /* IDs for chains the integrator is allowed to access RFQ liquidity on */\n    allowedChainIds: number[];\n    whitelistIntegratorUrls?: string[];\n    whitelistMakerIds?: string[];\n    label: string;\n    plp: boolean;\n    rfqm: boolean;\n    rfqt: boolean;\n}\nexport type IntegratorsAcl = Integrator[];\n\n/**\n * Configuration which represents taker-integrators of the 0x API. The configuration contains the label, id,\n * api keys, and allowed liquidity sources for each integrator.\n */\nexport const INTEGRATORS_ACL: IntegratorsAcl = (() => {\n    let integrators: IntegratorsAcl;\n    try {\n        integrators = resolveEnvVar<IntegratorsAcl>('INTEGRATORS_ACL', EnvVarType.JsonStringList, []);\n        schemaUtils.validateSchema(integrators, schemas.integratorsAclSchema);\n    } catch (e) {\n        throw new Error(`INTEGRATORS_ACL was defined but is not valid JSON per the schema: ${e}`);\n    }\n    return integrators;\n})();\n\n/**\n * Extracts the integrator API keys from the `INTEGRATORS_ACL` environment variable for the provided group type.\n */\nexport const getApiKeyWhitelistFromIntegratorsAcl = (groupType: 'rfqt' | 'plp' | 'rfqm'): string[] => {\n    return INTEGRATORS_ACL.filter((i) => i[groupType])\n        .flatMap((i) => i.apiKeys)\n        .sort();\n};\n\n/**\n * Gets the integrator ID for the provided label.\n */\nexport const getIntegratorIdFromLabel = (label: string): string | undefined => {\n    for (const integrator of INTEGRATORS_ACL) {\n        if (integrator.label === label) {\n            return integrator.integratorId;\n        }\n    }\n};\n\nexport type RfqWorkFlowType = 'rfqt' | 'rfqm';\nexport type RfqOrderType = 'rfq' | 'otc';\n\nexport const RFQ_MAKER_REFRESH_INTERVAL_MS: number = ONE_MINUTE_MS * 1;\n\n/**\n * The JSON config for each Market Maker, providing information including URLs, type of order supported and authentication.\n */\nexport interface RfqMakerConfig {\n    makerId: string;\n    label: string;\n    rfqmOrderTypes: RfqOrderType[];\n    rfqtOrderTypes: RfqOrderType[];\n    apiKeyHashes: string[];\n}\n\n/**\n * A Map type which map the makerId to the config object.\n */\nexport type MakerIdSet = Set</* makerId */ string>;\n\n/**\n * Generate a set of MakerIds that support a given order type for a given workflow\n */\nexport const getMakerIdSetForOrderType = (orderType: RfqOrderType | 'any', workflow: RfqWorkFlowType): MakerIdSet => {\n    const typesField = workflow === 'rfqt' ? 'rfqtOrderTypes' : 'rfqmOrderTypes';\n    return RFQ_MAKER_CONFIGS.reduce((acc, curr) => {\n        if (orderType === 'any' || curr[typesField].includes(orderType)) {\n            acc.add(curr.makerId);\n        }\n        return acc;\n    }, new Set</* makerId */ string>());\n};\n\n/**\n * A list of type RfqMakerConfig, read from the RFQ_MAKER_CONFIGS env variable\n */\nexport const RFQ_MAKER_CONFIGS: RfqMakerConfig[] = (() => {\n    try {\n        const makerConfigs = resolveEnvVar<RfqMakerConfig[]>('RFQ_MAKER_CONFIGS', EnvVarType.JsonStringList, []);\n        schemaUtils.validateSchema(makerConfigs, schemas.rfqMakerConfigListSchema);\n        return makerConfigs;\n    } catch (e) {\n        throw new Error(`RFQ_MAKER_CONFIGS was defined but is not valid JSON per the schema: ${e}`);\n    }\n})();\n\n// Log level for pino.js\nexport const LOG_LEVEL: string = _.isEmpty(process.env.LOG_LEVEL)\n    ? 'info'\n    : assertEnvVarType('LOG_LEVEL', process.env.LOG_LEVEL, EnvVarType.NonEmptyString);\n\n// Network port to listen on\nexport const HTTP_PORT = _.isEmpty(process.env.HTTP_PORT)\n    ? 3000\n    : assertEnvVarType('HTTP_PORT', process.env.HTTP_PORT, EnvVarType.Port);\n\n// Network port for the healthcheck service at /healthz, if not provided, it uses the HTTP_PORT value.\nexport const HEALTHCHECK_HTTP_PORT = _.isEmpty(process.env.HEALTHCHECK_HTTP_PORT)\n    ? HTTP_PORT\n    : assertEnvVarType('HEALTHCHECK_HTTP_PORT', process.env.HEALTHCHECK_HTTP_PORT, EnvVarType.Port);\n\n// Number of milliseconds of inactivity the servers waits for additional\n// incoming data aftere it finished writing last response before a socket will\n// be destroyed.\n// Ref: https://nodejs.org/api/http.html#http_server_keepalivetimeout\nexport const HTTP_KEEP_ALIVE_TIMEOUT = _.isEmpty(process.env.HTTP_KEEP_ALIVE_TIMEOUT)\n    ? 76 * 1000\n    : assertEnvVarType('HTTP_KEEP_ALIVE_TIMEOUT', process.env.HTTP_KEEP_ALIVE_TIMEOUT, EnvVarType.KeepAliveTimeout);\n\n// Limit the amount of time the parser will wait to receive the complete HTTP headers.\n// NOTE: This value HAS to be higher than HTTP_KEEP_ALIVE_TIMEOUT.\n// Ref: https://nodejs.org/api/http.html#http_server_headerstimeout\nexport const HTTP_HEADERS_TIMEOUT = _.isEmpty(process.env.HTTP_HEADERS_TIMEOUT)\n    ? 77 * 1000\n    : assertEnvVarType('HTTP_HEADERS_TIMEOUT', process.env.HTTP_HEADERS_TIMEOUT, EnvVarType.KeepAliveTimeout);\n\n// Default chain id to use when not specified\nexport const CHAIN_ID: ChainId = _.isEmpty(process.env.CHAIN_ID)\n    ? ChainId.Kovan\n    : assertEnvVarType('CHAIN_ID', process.env.CHAIN_ID, EnvVarType.ChainId);\n\nexport const KAFKA_BROKERS = _.isEmpty(process.env.KAFKA_BROKERS)\n    ? undefined\n    : assertEnvVarType('KAFKA_BROKERS', process.env.KAFKA_BROKERS, EnvVarType.StringList);\n\n// The fee recipient for orders\nexport const FEE_RECIPIENT_ADDRESS = _.isEmpty(process.env.FEE_RECIPIENT_ADDRESS)\n    ? NULL_ADDRESS\n    : assertEnvVarType('FEE_RECIPIENT_ADDRESS', process.env.FEE_RECIPIENT_ADDRESS, EnvVarType.ETHAddressHex);\n\nexport const POSTGRES_URI = _.isEmpty(process.env.POSTGRES_URI)\n    ? DEFAULT_LOCAL_POSTGRES_URI\n    : assertEnvVarType('POSTGRES_URI', process.env.POSTGRES_URI, EnvVarType.Url);\n\nexport const POSTGRES_READ_REPLICA_URIS: string[] | undefined = _.isEmpty(process.env.POSTGRES_READ_REPLICA_URIS)\n    ? undefined\n    : assertEnvVarType('POSTGRES_READ_REPLICA_URIS', process.env.POSTGRES_READ_REPLICA_URIS, EnvVarType.UrlList);\n\n// Environment name Sentry used to categorize issues and traces.\nexport const SENTRY_ENVIRONMENT = _.isEmpty(process.env.SENTRY_ENVIRONMENT)\n    ? DEFAULT_SENTRY_ENVIRONMENT\n    : assertEnvVarType('SENTRY_ENVIRONMENT', process.env.SENTRY_ENVIRONMENT, EnvVarType.NonEmptyString);\n\n// An Url with client key to access Sentry from client SDK.\nexport const SENTRY_DSN = _.isEmpty(process.env.SENTRY_DSN)\n    ? undefined\n    : assertEnvVarType('SENTRY_DSN', process.env.SENTRY_DSN, EnvVarType.Url);\n\n// API Key for Defined.fi's token price API\nexport const DEFINED_FI_API_KEY: string = _.isEmpty(process.env.DEFINED_FI_API_KEY)\n    ? ''\n    : assertEnvVarType('DEFINED_FI_API_KEY', process.env.DEFINED_FI_API_KEY, EnvVarType.NonEmptyString);\n\n// Endpoint for Defined.fi's token price API, default to https://api.defined.fi\nexport const DEFINED_FI_ENDPOINT: string = _.isEmpty(process.env.DEFINED_FI_ENDPOINT)\n    ? 'https://api.defined.fi'\n    : assertEnvVarType('DEFINED_FI_ENDPOINT', process.env.DEFINED_FI_ENDPOINT, EnvVarType.NonEmptyString);\n\n// API Key for 0x API (for ZeroExApiClient)\nexport const ZERO_EX_API_KEY: string = _.isEmpty(process.env.ZERO_EX_API_KEY)\n    ? ''\n    : assertEnvVarType('ZERO_EX_API_KEY', process.env.ZERO_EX_API_KEY, EnvVarType.NonEmptyString);\n\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n// eslint-disable-next-line @typescript-eslint/no-inferrable-types\nexport const TOKEN_PRICE_ORACLE_TIMEOUT: number = 1000;\n\n// Sampling rate of traces reported to Sentry. Should be a number between 0.0 and 1.0 (inclusive).\nexport const SENTRY_TRACES_SAMPLE_RATE = _.isEmpty(process.env.SENTRY_TRACES_SAMPLE_RATE)\n    ? 0\n    : assertEnvVarType('SENTRY_TRACES_SAMPLE_RATE', process.env.SENTRY_TRACES_SAMPLE_RATE, EnvVarType.Rate);\n\nexport const REDIS_URI = _.isEmpty(process.env.REDIS_URI) ? DEFAULT_LOCAL_REDIS_URI : process.env.REDIS_URI;\n\nexport const REDIS_BACKGROUND_JOB_URI = _.isEmpty(process.env.REDIS_BACKGROUND_JOB_URI)\n    ? DEFAULT_LOCAL_REDIS_URI\n    : process.env.REDIS_BACKGROUND_JOB_URI;\n\nexport const BACKGROUND_JOB_TYPES = _.isEmpty(process.env.BACKGROUND_JOB_TYPES)\n    ? DEFAULT_BACKGROUND_JOB_TYPES\n    : process.env.BACKGROUND_JOB_TYPES;\n\n// Should the logger include time field in the output logs, defaults to true.\nexport const LOGGER_INCLUDE_TIMESTAMP = _.isEmpty(process.env.LOGGER_INCLUDE_TIMESTAMP)\n    ? DEFAULT_LOGGER_INCLUDE_TIMESTAMP\n    : assertEnvVarType('LOGGER_INCLUDE_TIMESTAMP', process.env.LOGGER_INCLUDE_TIMESTAMP, EnvVarType.Boolean);\n\nexport const ALT_RFQ_MM_ENDPOINT: string | undefined = _.isEmpty(process.env.ALT_RFQ_MM_ENDPOINT)\n    ? undefined\n    : assertEnvVarType('ALT_RFQ_MM_ENDPOINT', process.env.ALT_RFQ_MM_ENDPOINT, EnvVarType.Url);\nexport const ALT_RFQ_MM_API_KEY: string | undefined = _.isEmpty(process.env.ALT_RFQ_MM_API_KEY)\n    ? undefined\n    : assertEnvVarType('ALT_RFQ_MM_API_KEY', process.env.ALT_RFQ_MM_API_KEY, EnvVarType.NonEmptyString);\nexport const ALT_RFQ_MM_PROFILE: string | undefined = _.isEmpty(process.env.ALT_RFQ_MM_PROFILE)\n    ? undefined\n    : assertEnvVarType('ALT_RFQ_MM_PROFILE', process.env.ALT_RFQ_MM_PROFILE, EnvVarType.NonEmptyString);\n\nexport const RFQM_API_KEY_WHITELIST: Set<string> = new Set(getApiKeyWhitelistFromIntegratorsAcl('rfqm'));\n\nexport const ADMIN_API_KEY: string | undefined = _.isEmpty(process.env.ADMIN_API_KEY)\n    ? undefined\n    : assertEnvVarType('ADMIN_API_KEY', process.env.ADMIN_API_KEY, EnvVarType.NonEmptyString);\n\nexport const REASON_ON_STATUS_ERROR_RESPONSE_ENABLED: boolean = _.isEmpty(\n    process.env.REASON_ON_STATUS_ERROR_RESPONSE_ENABLED,\n)\n    ? false\n    : assertEnvVarType(\n          'REASON_ON_STATUS_ERROR_RESPONSE_ENABLED',\n          process.env.REASON_ON_STATUS_ERROR_RESPONSE_ENABLED,\n          EnvVarType.Boolean,\n      );\n\nexport const TAKER_SPECIFIED_SIDE_ENABLED: boolean = _.isEmpty(process.env.TAKER_SPECIFIED_SIDE_ENABLED)\n    ? false\n    : assertEnvVarType('TAKER_SPECIFIED_SIDE_ENABLED', process.env.TAKER_SPECIFIED_SIDE_ENABLED, EnvVarType.Boolean);\n\nexport const RFQM_MAKER_ID_SET: MakerIdSet = getMakerIdSetForOrderType('any', 'rfqm');\nexport const RFQT_MAKER_ID_SET_FOR_RFQ_ORDER: MakerIdSet = getMakerIdSetForOrderType('rfq', 'rfqt');\nexport const RFQT_MAKER_ID_SET_FOR_OTC_ORDER: MakerIdSet = getMakerIdSetForOrderType('otc', 'rfqt');\nexport const RFQM_MAKER_ID_SET_FOR_OTC_ORDER: MakerIdSet = getMakerIdSetForOrderType('otc', 'rfqm');\n\n/**\n * A map from RFQ maker's api key hashes to maker ids.\n * Invalid hashes, which appear more than once in the config file and might resolve to different makers, are removed from the result.\n */\nexport const RFQ_API_KEY_HASH_TO_MAKER_ID: Map<string, string> = (() => {\n    const hashToIdCount = RFQ_MAKER_CONFIGS.reduce((result, rfqMakerConfig) => {\n        rfqMakerConfig.apiKeyHashes.forEach((hash) => result.set(hash, (result.get(hash) || 0) + 1));\n        return result;\n    }, new Map<string, number>());\n\n    return RFQ_MAKER_CONFIGS.reduce((result, mm) => {\n        mm.apiKeyHashes.forEach((hash) => {\n            // Ignore invalid hashes with more than one appearances\n            if (hashToIdCount.get(hash) === 1) {\n                result.set(hash, mm.makerId);\n            }\n        });\n        return result;\n    }, new Map<string, string>());\n})();\n\nexport const META_TX_WORKER_MNEMONIC: string | undefined = _.isEmpty(process.env.META_TX_WORKER_MNEMONIC)\n    ? undefined\n    : assertEnvVarType('META_TX_WORKER_MNEMONIC', process.env.META_TX_WORKER_MNEMONIC, EnvVarType.NonEmptyString);\n\nexport const RFQM_WORKER_GROUP_INDEX: number | undefined = _.isEmpty(process.env.RFQM_WORKER_GROUP_INDEX)\n    ? undefined\n    : assertEnvVarType('RFQM_WORKER_GROUP_INDEX', process.env.RFQM_WORKER_GROUP_INDEX, EnvVarType.Integer);\n\nexport const RFQM_WORKER_GROUP_SIZE: number | undefined = _.isEmpty(process.env.RFQM_WORKER_GROUP_SIZE)\n    ? undefined\n    : assertEnvVarType('RFQM_WORKER_GROUP_SIZE', process.env.RFQM_WORKER_GROUP_SIZE, EnvVarType.Integer);\n\n// If set to TRUE, system health will change to MAINTENANCE and integrators will be told to not\n// send RFQM orders.\n// tslint:disable-next-line boolean-naming\nexport const RFQM_MAINTENANCE_MODE: boolean = _.isEmpty(process.env.RFQM_MAINTENANCE_MODE)\n    ? false\n    : assertEnvVarType('RFQM_MAINTENANCE_MODE', process.env.RFQM_MAINTENANCE_MODE, EnvVarType.Boolean);\n\nexport const RFQ_PRICE_ENDPOINT_TIMEOUT_MS: number = _.isEmpty(process.env.RFQ_PRICE_ENDPOINT_TIMEOUT_MS)\n    ? 1000\n    : assertEnvVarType('RFQ_PRICE_ENDPOINT_TIMEOUT_MS', process.env.RFQ_PRICE_ENDPOINT_TIMEOUT_MS, EnvVarType.Integer);\n\nexport const RFQ_SIGN_ENDPOINT_TIMEOUT_MS = _.isEmpty(process.env.RFQ_SIGN_ENDPOINT_TIMEOUT_MS)\n    ? 2000\n    : assertEnvVarType('RFQ_SIGN_ENDPOINT_TIMEOUT_MS', process.env.RFQ_SIGN_ENDPOINT_TIMEOUT_MS, EnvVarType.Integer);\n\n// The expected time for a meta-txn to be included in a block.\nexport const META_TXN_RELAY_EXPECTED_MINED_SEC: number = _.isEmpty(process.env.META_TXN_RELAY_EXPECTED_MINED_SEC)\n    ? DEFAULT_EXPECTED_MINED_SEC\n    : assertEnvVarType(\n          'META_TXN_RELAY_EXPECTED_MINED_SEC',\n          process.env.META_TXN_RELAY_EXPECTED_MINED_SEC,\n          EnvVarType.Integer,\n      );\n\n// Whether or not prometheus metrics should be enabled.\n// tslint:disable-next-line:boolean-naming\nexport const ENABLE_PROMETHEUS_METRICS: boolean = _.isEmpty(process.env.ENABLE_PROMETHEUS_METRICS)\n    ? false\n    : assertEnvVarType('ENABLE_PROMETHEUS_METRICS', process.env.ENABLE_PROMETHEUS_METRICS, EnvVarType.Boolean);\n\nexport const PROMETHEUS_PORT: number = _.isEmpty(process.env.PROMETHEUS_PORT)\n    ? 8080\n    : assertEnvVarType('PROMETHEUS_PORT', process.env.PROMETHEUS_PORT, EnvVarType.Port);\n\n// Eth Gas Station URL\nexport const ETH_GAS_STATION_API_URL: string = _.isEmpty(process.env.ETH_GAS_STATION_API_URL)\n    ? DEFAULT_ETH_GAS_STATION_API_URL\n    : assertEnvVarType('ETH_GAS_STATION_API_URL', process.env.ETH_GAS_STATION_API_URL, EnvVarType.Url);\n\nexport const RFQ_PROXY_ADDRESS: string | undefined = _.isEmpty(process.env.RFQ_PROXY_ADDRESS)\n    ? undefined\n    : assertEnvVarType('RFQ_PROXY_ADDRESS', process.env.RFQ_PROXY_ADDRESS, EnvVarType.NonEmptyString);\n\nexport const RFQ_PROXY_PORT: number | undefined = _.isEmpty(process.env.RFQ_PROXY_PORT)\n    ? undefined\n    : assertEnvVarType('RFQ_PROXY_PORT', process.env.RFQ_PROXY_PORT, EnvVarType.Port);\n\n// tslint:disable-next-line boolean-naming\nexport const ENABLE_LLR_COOLDOWN: boolean = _.isEmpty(process.env.ENABLE_LLR_COOLDOWN)\n    ? false\n    : assertEnvVarType('ENABLE_LLR_COOLDOWN', process.env.ENABLE_LLR_COOLDOWN, EnvVarType.Boolean);\n\nexport const LLR_COOLDOWN_DURATION_SECONDS: number = _.isEmpty(process.env.LLR_COOLDOWN_DURATION_SECONDS)\n    ? 60\n    : assertEnvVarType('LLR_COOLDOWN_DURATION_SECONDS', process.env.LLR_COOLDOWN_DURATION_SECONDS, EnvVarType.Integer);\n\nexport const defaultHttpServiceConfig: HttpServiceConfig = {\n    httpPort: HTTP_PORT,\n    healthcheckHttpPort: HEALTHCHECK_HTTP_PORT,\n    healthcheckPath: HEALTHCHECK_PATH,\n    httpKeepAliveTimeout: HTTP_KEEP_ALIVE_TIMEOUT,\n    httpHeadersTimeout: HTTP_HEADERS_TIMEOUT,\n    enablePrometheusMetrics: ENABLE_PROMETHEUS_METRICS,\n    prometheusPort: PROMETHEUS_PORT,\n    prometheusPath: METRICS_PATH,\n};\n\nexport const getIntegratorByIdOrThrow = (\n    (integratorsMap: Map<string, Integrator>) =>\n    (integratorId: string): Integrator => {\n        const integrator = integratorsMap.get(integratorId);\n        if (!integrator) {\n            throw new Error(`Integrator ${integratorId} does not exist.`);\n        }\n        return integrator;\n    }\n)(transformIntegratorsAcl(INTEGRATORS_ACL, 'integratorId'));\n\n/**\n * Gets the integrator ID for a given API key. If the API key is not in the configuration, returns `undefined`.\n */\nexport const getIntegratorIdForApiKey = (\n    (integratorsMap: Map<string, Integrator>) =>\n    (apiKey: string): string | undefined => {\n        const integrator = integratorsMap.get(apiKey);\n        return integrator?.integratorId;\n    }\n)(transformIntegratorsAcl(INTEGRATORS_ACL, 'apiKeys'));\n\n/**\n * Utility function to transform INTEGRATORS_ACL into a map of apiKey => integrator. The result can\n * be used to optimize the lookup of the integrator when a request comes in with an api key. Lookup complexity\n * becomes O(1) with the map instead of O(# integrators * # api keys) with the array.\n *\n * @param integrators the integrators map from the environment variable\n * @param keyBy either apiKeys (creates map keyed by every API key) or 'integratorId' (integratorId => Integrator)\n */\nfunction transformIntegratorsAcl(\n    integrators: IntegratorsAcl,\n    keyBy: 'apiKeys' | 'integratorId',\n): Map<string, Integrator> {\n    const result = new Map<string, Integrator>();\n    integrators.forEach((integrator) => {\n        let mapKeys: string[];\n        switch (keyBy) {\n            case 'apiKeys':\n                mapKeys = integrator.apiKeys;\n                break;\n            case 'integratorId':\n                mapKeys = [integrator.integratorId];\n                break;\n            default:\n                throw new Error(`Parameter \"${keyBy}\" is misconfigured`);\n        }\n        mapKeys.forEach((apiKey) => {\n            result.set(apiKey, integrator);\n        });\n    });\n    return result;\n}\n\n/**\n * RPC\n */\nexport const META_TRANSACTION_SERVICE_RPC_URL: string = _.isEmpty(process.env.META_TRANSACTION_SERVICE_RPC_URL)\n    ? ''\n    : assertEnvVarType(\n          'META_TRANSACTION_SERVICE_RPC_URL',\n          process.env.META_TRANSACTION_SERVICE_RPC_URL,\n          EnvVarType.Url,\n      );\n\n/**\n * Resolves a config of type T for an Enviornment Variable. Checks:\n *  - If the env variable is undefined, use the hardcoded fallback\n *  - If the env variable points to a filepath, resolve it\n *  - Otherwise, just use the env variable\n *\n * @param envVar - the name of the Environment Variable\n * @param envVarType - the type\n * @param fallback  - A hardcoded fallback value\n * @returns The config\n */\nfunction resolveEnvVar<T>(envVar: string, envVarType: EnvVarType, fallback: T): T {\n    const rawEnvVar = process.env[envVar];\n    if (rawEnvVar === undefined || _.isEmpty(rawEnvVar)) {\n        return fallback;\n    }\n\n    // If the enviornment variable points to a file\n    if (fs.existsSync(rawEnvVar)) {\n        return JSON.parse(fs.readFileSync(rawEnvVar, 'utf8'));\n    }\n\n    return assertEnvVarType(envVar, process.env[envVar], envVarType);\n}\n\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction assertEnvVarType(name: string, value: any, expectedType: EnvVarType): any {\n    let returnValue;\n    switch (expectedType) {\n        case EnvVarType.Port:\n            returnValue = parseInt(value, 10);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line no-case-declarations\n            const isWithinRange = returnValue >= 0 && returnValue <= 65535;\n            if (isNaN(returnValue) || !isWithinRange) {\n                throw new Error(`${name} must be between 0 to 65535, found ${value}.`);\n            }\n            return returnValue;\n        case EnvVarType.ChainId:\n        case EnvVarType.KeepAliveTimeout:\n        case EnvVarType.Integer:\n            returnValue = parseInt(value, 10);\n            if (isNaN(returnValue)) {\n                throw new Error(`${name} must be a valid integer, found ${value}.`);\n            }\n            return returnValue;\n        case EnvVarType.ETHAddressHex:\n            assert.isETHAddressHex(name, value);\n            return value;\n        case EnvVarType.Url:\n            assert.isUri(name, value);\n            return value;\n        case EnvVarType.UrlList:\n            assert.isString(name, value);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line no-case-declarations\n            const urlList = (value as string).split(',');\n            urlList.forEach((url, i) => assert.isUri(`${name}[${i}]`, url));\n            return urlList;\n        case EnvVarType.Boolean:\n            return value === 'true';\n        case EnvVarType.UnitAmount:\n            returnValue = new BigNumber(parseFloat(value));\n            if (returnValue.isNaN() || returnValue.isNegative()) {\n                throw new Error(`${name} must be valid number greater than 0.`);\n            }\n            return returnValue;\n        case EnvVarType.Rate:\n            returnValue = parseFloat(value);\n            if (returnValue < 0 || returnValue > 1) {\n                throw new Error(`${name} must be valid number between 0.0 and 1.0.`);\n            }\n            return returnValue;\n        case EnvVarType.AddressList:\n            assert.isString(name, value);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line no-case-declarations\n            const addressList = (value as string).split(',').map((a) => a.toLowerCase());\n            addressList.forEach((a, i) => assert.isETHAddressHex(`${name}[${i}]`, a));\n            return addressList;\n        case EnvVarType.StringList:\n            assert.isString(name, value);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line no-case-declarations\n            const stringList = (value as string).split(',');\n            return stringList;\n        case EnvVarType.WhitelistAllTokens:\n            return '*';\n        case EnvVarType.NonEmptyString:\n            assert.isString(name, value);\n            if (value === '') {\n                throw new Error(`${name} must be supplied`);\n            }\n            return value;\n        case EnvVarType.APIKeys:\n            assert.isString(name, value);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line no-case-declarations\n            const apiKeys = (value as string).split(',');\n            apiKeys.forEach((apiKey) => {\n                const isValidUUID = validateUUID(apiKey);\n                if (!isValidUUID) {\n                    throw new Error(`API Key ${apiKey} isn't UUID compliant`);\n                }\n            });\n            return apiKeys;\n        case EnvVarType.JsonStringList:\n            assert.isString(name, value);\n            return JSON.parse(value);\n\n        default:\n            throw new Error(`Unrecognized EnvVarType: ${expectedType} encountered for variable ${name}.`);\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/chain_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/chain_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/fee_model_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/fee_model_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/firm_quote_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/indicative_otc_quote_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/indicative_quote_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/integrators_acl_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/integrator_acl_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/rfq_maker_config.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/rfq_maker_config_list.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/sign_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configuration_entry.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts",{"fileContent":"import * as chainConfigurationsSchema from './chain_configurations_schema.json';\nimport * as chainConfigurationSchema from './chain_configuration_schema.json';\nimport * as feeModelConfigurationsSchema from './fee_model_configurations_schema.json';\nimport * as feeModelConfigurationSchema from './fee_model_configuration_schema.json';\nimport * as firmQuoteRequestSchema from './firm_quote_request_schema.json';\nimport * as indicativeOtcQuoteResponseSchema from './indicative_otc_quote_response_schema.json';\nimport * as indicativeQuoteRequestSchema from './indicative_quote_request_schema.json';\nimport * as integratorsAclSchema from './integrators_acl_schema.json';\nimport * as integratorAclSchema from './integrator_acl_schema.json';\nimport * as rfqMakerConfigSchema from './rfq_maker_config.json';\nimport * as rfqMakerConfigListSchema from './rfq_maker_config_list.json';\nimport * as signResponseSchema from './sign_response_schema.json';\nimport * as zeroExFeeConfigurationsSchema from './zero_ex_fee_configurations_schema.json';\nimport * as zeroExFeeConfigurationSchema from './zero_ex_fee_configuration_schema.json';\nimport * as zeroExFeeConfigurationEntrySchema from './zero_ex_fee_configuration_entry.json';\n\nexport const schemas = {\n    chainConfigurationSchema,\n    chainConfigurationsSchema,\n    feeModelConfigurationSchema,\n    feeModelConfigurationsSchema,\n    firmQuoteRequestSchema,\n    indicativeOtcQuoteResponseSchema,\n    indicativeQuoteRequestSchema,\n    integratorAclSchema,\n    integratorsAclSchema,\n    rfqMakerConfigListSchema,\n    rfqMakerConfigSchema,\n    signResponseSchema,\n    zeroExFeeConfigurationsSchema,\n    zeroExFeeConfigurationSchema,\n    zeroExFeeConfigurationEntrySchema,\n};\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/chain_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/chain_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/fee_model_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/fee_model_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/firm_quote_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/indicative_otc_quote_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/indicative_quote_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/integrators_acl_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/integrator_acl_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/rfq_maker_config.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/rfq_maker_config_list.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/sign_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configuration_entry.json"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts",{"fileContent":"import { AJV, SchemaValidator } from '@0x/json-schemas';\n\nimport { ValidationError, ValidationErrorCodes, ValidationErrorItem } from './errors';\nimport { schemas } from './schemas';\n\nconst schemaValidator = new SchemaValidator();\nfor (const schema of Object.values(schemas)) {\n    if (schema !== undefined) {\n        schemaValidator.addSchema(schema);\n    }\n}\n\nexport const schemaUtils = {\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    validateSchema(instance: any, schema: object): void {\n        const validationResult = schemaValidator.validate(instance, schema);\n        if (!validationResult.errors || validationResult.errors.length === 0) {\n            return;\n        } else {\n            const validationErrorItems = validationResult.errors.map((schemaValidationError) =>\n                schemaValidationErrorToValidationErrorItem(schemaValidationError),\n            );\n            throw new ValidationError(validationErrorItems);\n        }\n    },\n    addSchema(schema: object): void {\n        schemaValidator.addSchema(schema);\n    },\n};\n\nfunction schemaValidationErrorToValidationErrorItem(schemaValidationErrorObject: AJV.ErrorObject): ValidationErrorItem {\n    if (\n        [\n            'type',\n            'anyOf',\n            'allOf',\n            'oneOf',\n            'additionalProperties',\n            'minProperties',\n            'maxProperties',\n            'pattern',\n            'format',\n            'uniqueItems',\n            'items',\n            'dependencies',\n        ].includes(schemaValidationErrorObject.keyword)\n    ) {\n        return {\n            field: schemaValidationErrorObject.dataPath.replace('.', ''),\n            code: ValidationErrorCodes.IncorrectFormat,\n            reason: schemaValidationErrorObject.message || '',\n        };\n    } else if (\n        ['minimum', 'maximum', 'minLength', 'maxLength', 'minItems', 'maxItems', 'enum', 'const'].includes(\n            schemaValidationErrorObject.keyword,\n        )\n    ) {\n        return {\n            field: schemaValidationErrorObject.dataPath.replace('.', ''),\n            code: ValidationErrorCodes.ValueOutOfRange,\n            reason: schemaValidationErrorObject.message || '',\n        };\n    } else if (schemaValidationErrorObject.keyword === 'required') {\n        return {\n            field: (schemaValidationErrorObject.params as AJV.RequiredParams).missingProperty,\n            code: ValidationErrorCodes.RequiredField,\n            reason: schemaValidationErrorObject.message || '',\n        };\n    } else if (schemaValidationErrorObject.keyword === 'not') {\n        return {\n            field: schemaValidationErrorObject.dataPath.replace('.', ''),\n            code: ValidationErrorCodes.UnsupportedOption,\n            reason: schemaValidationErrorObject.message || '',\n        };\n    } else {\n        throw new Error(`Unknown schema validation error name: ${schemaValidationErrorObject.keyword}`);\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/chain_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/chain_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/fee_model_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/fee_model_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/firm_quote_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/indicative_otc_quote_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/indicative_quote_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/integrators_acl_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/integrator_acl_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/rfq_maker_config.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/rfq_maker_config_list.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/sign_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configuration_entry.json"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts",{"fileContent":"import { generalErrorCodeToReason as baseReasons } from '@0x/api-utils';\n\nexport {\n    BadRequestError,\n    ErrorBody,\n    GeneralErrorCodes,\n    InternalServerError,\n    InvalidAPIKeyError,\n    MalformedJSONError,\n    NotFoundError,\n    NotImplementedError,\n    RevertAPIError,\n    ValidationError,\n    ValidationErrorCodes,\n    ValidationErrorItem,\n} from '@0x/api-utils';\n\nexport enum APIErrorCodes {\n    OrderSubmissionDisabled = 102,\n    UnableToSubmitOnBehalfOfTaker = 106,\n    ServiceDisabled = 108,\n    InsufficientFundsError = 109,\n    EthSellNotSupported = 110,\n    GasEstimationFailed = 111,\n}\n\nexport const apiErrorCodesToReasons: { [key in APIErrorCodes]: string } = {\n    ...baseReasons,\n    [APIErrorCodes.OrderSubmissionDisabled]: 'Order submission disabled',\n    [APIErrorCodes.UnableToSubmitOnBehalfOfTaker]: 'Unable to submit transaction on behalf of taker',\n    [APIErrorCodes.ServiceDisabled]: 'Service disabled',\n    [APIErrorCodes.InsufficientFundsError]: 'Insufficient funds for transaction',\n    [APIErrorCodes.EthSellNotSupported]: 'ETH selling is not supported',\n    [APIErrorCodes.GasEstimationFailed]: 'Gas estimation failed',\n};\n\nexport enum ValidationErrorReasons {\n    ArgumentNotYetSupported = 'ARGUMENT_NOT_YET_SUPPORTED',\n    FeeRecipientMissing = 'FEE_RECIPIENT_MISSING',\n    MultipleFeeTypesUsed = 'MULTIPLE_FEE_TYPES_USED',\n    PercentageOutOfRange = 'MUST_BE_LESS_THAN_OR_EQUAL_TO_ONE',\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/constants.ts",{"fileContent":"import { ContractAddresses, getContractAddressesForChainOrThrow } from '@0x/contract-addresses';\nimport { IZeroExRfqOrderFilledEventArgs } from '@0x/contract-wrappers';\nimport { web3Factory, Web3ProviderEngine } from '@0x/dev-utils';\nimport { ETH_TOKEN_ADDRESS, MetaTransaction } from '@0x/protocol-utils';\nimport { ObjectMap } from '@0x/types';\nimport { BigNumber } from '@0x/utils';\nimport { LogWithDecodedArgs } from 'ethereum-types';\nimport { providers } from 'ethers';\nimport { ZeroExFeeConfiguration } from '../src/config';\n\nimport { EXECUTE_META_TRANSACTION_EIP_712_TYPES, PERMIT_EIP_712_TYPES } from '../src/core/constants';\nimport { toPairString } from '../src/core/pair_utils';\nimport { ExecuteMetaTransactionApproval, Fee, GaslessApprovalTypes, PermitApproval } from '../src/core/types';\n\nexport const CHAIN_ID = 1337;\n// tslint:disable-next-line:custom-no-magic-numbers\nexport const MAX_INT = new BigNumber(2).pow(256).minus(1);\nexport const MAX_MINT_AMOUNT = new BigNumber('10000000000000000000000');\nexport const CONTRACT_ADDRESSES: ContractAddresses = getContractAddressesForChainOrThrow(CHAIN_ID);\nexport { ETH_TOKEN_ADDRESS };\nexport const ZRX_TOKEN_ADDRESS = CONTRACT_ADDRESSES.zrxToken;\nexport const WETH_TOKEN_ADDRESS = CONTRACT_ADDRESSES.etherToken;\nexport const UNKNOWN_TOKEN_ADDRESS = '0xbe0037eaf2d64fe5529bca93c18c9702d3930376';\nexport const SYMBOL_TO_ADDRESS: ObjectMap<string> = {\n    ZRX: ZRX_TOKEN_ADDRESS,\n    WETH: WETH_TOKEN_ADDRESS,\n    ETH: ETH_TOKEN_ADDRESS,\n};\nexport const NULL_ADDRESS = '0x0000000000000000000000000000000000000000';\nexport const AFFILIATE_DATA_SELECTOR = '869584cd';\n\nexport const MATCHA_AFFILIATE_ADDRESS = '0x86003b044f70dac0abc80ac8957305b6370893ed';\nexport const MATCHA_AFFILIATE_ENCODED_PARTIAL_ORDER_DATA =\n    '869584cd00000000000000000000000086003b044f70dac0abc80ac8957305b6370893ed0000000000000000000000000000000000000000000000';\n\nexport const WORKER_TEST_ADDRESS = '0xE834EC434DABA538cd1b9Fe1582052B880BD7e63';\nexport const WORKER_TEST_PRIVATE_KEY = '0xff12e391b79415e941a94de3bf3a9aee577aed0731e297d5cfa0b8a1e02fa1d0';\n\nconst ganacheConfigs = {\n    shouldUseInProcessGanache: false,\n    shouldAllowUnlimitedContractSize: true,\n    shouldUseFakeGasEstimate: false,\n};\n\nexport const getProvider = (): Web3ProviderEngine => {\n    return web3Factory.getRpcProvider(ganacheConfigs);\n};\nexport const TEST_RFQ_ORDER_FILLED_EVENT_LOG: providers.Log = {\n    address: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n    blockHash: '0x4c9f6904bd33f57204a8451de0891b448a7be065c1704e5b6905f382cb31b040',\n    blockNumber: 11598119,\n    data: '0xf70ec34e807d08cb83757ec62fffd9e0d22db6b4b97f46b78adcf47682c4cccb000000000000000000000000e89bc18cee87c9af8b472635a152704b96dafb8f0000000000000000000000009016cc2122b52ff5d9937c0c1422b78d7e81ceea0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000000e44a075a36f7e7010000000000000000000000000000000000000000000000000000000000000000',\n    logIndex: 74,\n    removed: false,\n    topics: ['0x829fa99d94dc4636925b38632e625736a614c154d55006b7ab6bea979c210c32'],\n    transactionHash: '0x2b723137d9328fbe5e64bc2729ef5b1d846bb1d242ae2f3c016b9f70715aa818',\n    transactionIndex: 70,\n};\nexport const TEST_RFQ_ORDER_FILLED_EVENT_TAKER_AMOUNT = new BigNumber('10000000000000000');\nexport const TEST_DECODED_RFQ_ORDER_FILLED_EVENT_LOG: LogWithDecodedArgs<IZeroExRfqOrderFilledEventArgs> = {\n    blockHash: '0x4c9f6904bd33f57204a8451de0891b448a7be065c1704e5b6905f382cb31b040',\n    address: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n    logIndex: 74,\n    data: '0xf70ec34e807d08cb83757ec62fffd9e0d22db6b4b97f46b78adcf47682c4cccb000000000000000000000000e89bc18cee87c9af8b472635a152704b96dafb8f0000000000000000000000009016cc2122b52ff5d9937c0c1422b78d7e81ceea0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000000e44a075a36f7e7010000000000000000000000000000000000000000000000000000000000000000',\n    topics: ['0x829fa99d94dc4636925b38632e625736a614c154d55006b7ab6bea979c210c32'],\n    blockNumber: 11598119,\n    args: {\n        orderHash: '0xf70ec34e807d08cb83757ec62fffd9e0d22db6b4b97f46b78adcf47682c4cccb',\n        maker: '0xe89bc18cee87c9af8b472635a152704b96dafb8f',\n        taker: '0x9016cc2122b52ff5d9937c0c1422b78d7e81ceea',\n        makerToken: '0x6b175474e89094c44da98b954eedeac495271d0f',\n        takerToken: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n        takerTokenFilledAmount: TEST_RFQ_ORDER_FILLED_EVENT_TAKER_AMOUNT,\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-loss-of-precision\n        makerTokenFilledAmount: new BigNumber(16449968672974825217),\n        pool: '0x0000000000000000000000000000000000000000000000000000000000000000',\n    },\n    transactionIndex: 70,\n    transactionHash: '0x2b723137d9328fbe5e64bc2729ef5b1d846bb1d242ae2f3c016b9f70715aa818',\n    event: 'RfqOrderFilled',\n};\nexport const MOCK_EXECUTE_META_TRANSACTION_APPROVAL: ExecuteMetaTransactionApproval = {\n    kind: GaslessApprovalTypes.ExecuteMetaTransaction,\n    eip712: {\n        types: {\n            EIP712Domain: [\n                { name: 'name', type: 'string' },\n                { name: 'version', type: 'string' },\n                { name: 'verifyingContract', type: 'address' },\n                { name: 'salt', type: 'bytes32' },\n            ],\n            ...EXECUTE_META_TRANSACTION_EIP_712_TYPES,\n        },\n        primaryType: 'MetaTransaction',\n        domain: {\n            name: 'Fake Token',\n            version: '1',\n            verifyingContract: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n            salt: '0x5a17000000000000000000000000000000000000000000000000000000000000',\n        },\n        message: {\n            nonce: 1,\n            from: WORKER_TEST_ADDRESS,\n            functionSignature:\n                '0x095ea7b3000000000000000000000000def1c0ded9bec7f1a1670819833240f027b25effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',\n        },\n    },\n};\nexport const MOCK_EXECUTE_META_TRANSACTION_CALLDATA =\n    '0x0c53c51c000000000000000000000000e834ec434daba538cd1b9fe1582052b880bd7e6300000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000044095ea7b3000000000000000000000000def1c0ded9bec7f1a1670819833240f027b25effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000';\n\nexport const MOCK_PERMIT_APPROVAL: PermitApproval = {\n    kind: GaslessApprovalTypes.Permit,\n    eip712: {\n        types: {\n            EIP712Domain: [\n                { name: 'name', type: 'string' },\n                { name: 'version', type: 'string' },\n                { name: 'verifyingContract', type: 'address' },\n                { name: 'salt', type: 'bytes32' },\n            ],\n            ...PERMIT_EIP_712_TYPES,\n        },\n        primaryType: 'Permit',\n        domain: {\n            name: 'Fake Token',\n            version: '1',\n            verifyingContract: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n            salt: '0x5a17000000000000000000000000000000000000000000000000000000000000',\n        },\n        message: {\n            owner: '0x9016cc2122b52ff5d9937c0c1422b78d7e81ceea',\n            spender: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n            value: '115792089237316195423570985008687907853269984665640564039457584007913129639935',\n            nonce: 1,\n            deadline: '123456789',\n        },\n    },\n};\n\nexport const MOCK_PERMIT_CALLDATA =\n    '0xd505accf0000000000000000000000009016cc2122b52ff5d9937c0c1422b78d7e81ceea000000000000000000000000def1c0ded9bec7f1a1670819833240f027b25effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000075bcd15000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';\n\nexport const MOCK_META_TRANSACTION = new MetaTransaction({\n    signer: '0xabcdef',\n    sender: '0xabcdef',\n    minGasPrice: new BigNumber(0),\n    maxGasPrice: new BigNumber(1),\n    expirationTimeSeconds: new BigNumber(2),\n    salt: new BigNumber(3),\n    callData: '0x1234567890',\n    value: new BigNumber(4),\n    feeToken: '0xdef',\n    feeAmount: new BigNumber(5),\n    chainId: 1,\n    verifyingContract: '0xdef1',\n});\n\nexport const MOCK_STORED_META_TRANSACTION = {\n    signer: '0xabcdef',\n    sender: '0xabcdef',\n    minGasPrice: '0',\n    maxGasPrice: '1',\n    expirationTimeSeconds: '2',\n    salt: '3',\n    callData: '0x1234567890',\n    value: '4',\n    feeToken: '0xdef',\n    feeAmount: '5',\n    chainId: '1',\n    verifyingContract: '0xdef1',\n};\n\nexport const MOCK_FEE: Fee = {\n    type: 'fixed',\n    token: '0xtoken',\n    amount: new BigNumber(0),\n};\n\nexport const MOCK_STORED_FEE = {\n    type: 'fixed',\n    token: '0xtoken',\n    amount: '0',\n    details: undefined,\n};\n\nexport const MAINET_TOKEN_ADDRESSES = {\n    USDC: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n    WETH: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n    USDT: '0xdac17f958d2ee523a2206206994597c13d831ec7',\n    DAI: '0x6b175474e89094c44da98b954eedeac495271d0f',\n    WBTC: '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599',\n    SHIB: '0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce',\n    AAVE: '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9',\n};\n\nexport const ZERO_EX_FEE_CONFIGURATIONS = (() => {\n    const zeroExFeeConfigurations: Map<string, Map<number, ZeroExFeeConfiguration>> = new Map();\n    const coinbaseMainnetConfiguration: ZeroExFeeConfiguration = {\n        name: 'Coinbase',\n        feeOn: 'volume',\n        zeroEx: {\n            feeRecipient: '0x4ea754349ace5303c82f0d1d491041e042f2ad22',\n            billingType: 'on-chain',\n        },\n        gas: {\n            feeRecipient: null,\n            billingType: 'off-chain',\n        },\n        pairsFeeEntries: new Map([\n            [toPairString(MAINET_TOKEN_ADDRESSES.USDC, MAINET_TOKEN_ADDRESSES.WETH), new BigNumber(0.5)],\n            [toPairString(MAINET_TOKEN_ADDRESSES.USDT, MAINET_TOKEN_ADDRESSES.WETH), new BigNumber(0.5)],\n        ]),\n        cartesianProductFeeEntries: [\n            {\n                setA: new Set([MAINET_TOKEN_ADDRESSES.USDC, MAINET_TOKEN_ADDRESSES.USDT, MAINET_TOKEN_ADDRESSES.DAI]),\n                setB: new Set([MAINET_TOKEN_ADDRESSES.WETH, MAINET_TOKEN_ADDRESSES.WBTC]),\n                parameter: new BigNumber(0.7),\n            },\n            {\n                setA: new Set([MAINET_TOKEN_ADDRESSES.USDC, MAINET_TOKEN_ADDRESSES.USDT, MAINET_TOKEN_ADDRESSES.DAI]),\n                setB: new Set([MAINET_TOKEN_ADDRESSES.USDC, MAINET_TOKEN_ADDRESSES.USDT, MAINET_TOKEN_ADDRESSES.DAI]),\n                parameter: new BigNumber(0.1),\n            },\n        ],\n        tokensEntries: new Map([\n            [MAINET_TOKEN_ADDRESSES.WBTC, new BigNumber(1.5)],\n            ['*', new BigNumber(0.05)],\n        ]),\n    };\n    const defaultMainnetConfiguration: ZeroExFeeConfiguration = {\n        name: 'All',\n        feeOn: 'integrator_share',\n        zeroEx: {\n            feeRecipient: '0x4ea754349ace5303c82f0d1d491041e042f2ad22',\n            billingType: 'on-chain',\n        },\n        gas: {\n            feeRecipient: null,\n            billingType: 'off-chain',\n        },\n        pairsFeeEntries: new Map(),\n        cartesianProductFeeEntries: [],\n        tokensEntries: new Map([\n            [MAINET_TOKEN_ADDRESSES.WBTC, new BigNumber(1.2)],\n            ['*', new BigNumber(0.03)],\n        ]),\n    };\n    zeroExFeeConfigurations.set('5062340f-87bb-4e1b-8029-eb8c03a9989c', new Map());\n    zeroExFeeConfigurations.get('5062340f-87bb-4e1b-8029-eb8c03a9989c')?.set(1, coinbaseMainnetConfiguration);\n    zeroExFeeConfigurations.set('*', new Map());\n    zeroExFeeConfigurations.get('*')?.set(1, defaultMainnetConfiguration);\n\n    return zeroExFeeConfigurations;\n})();\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/deployment.ts",{"fileContent":"import { ChildProcessWithoutNullStreams, spawn } from 'child_process';\nimport * as path from 'path';\n\nimport { ONE_MINUTE_MS } from '../../src/core/constants';\n\nimport { initDbDataSourceAsync } from './initDbDataSourceAsync';\n\n// depends on a `docker-compose.yml` existing in the api root directory\nconst dockerComposeFilename = 'docker-compose.yml';\n\n/**\n * Returned by `setupDependenciesAsync`. Call to shutdown the\n * dependencies spun up by `setupDependenciesAsync`. Returns\n * `true` if the teardown is successful.\n */\nexport type TeardownDependenciesFunctionHandle = () => boolean;\n\ntype Service = 'sqs' | 'postgres' | 'redis' | 'ganache';\n\n/**\n * Sets up 0x-api's dependencies\n *\n * @param services An array of services to start\n * @returns A function handle which will tear down the dependencies when called\n */\nexport async function setupDependenciesAsync(services: Service[]): Promise<TeardownDependenciesFunctionHandle> {\n    if (services.length === 0) {\n        throw new Error('Pick at least one service to start');\n    }\n\n    const configFilePath = path.resolve(__dirname, '../../', dockerComposeFilename);\n\n    /**\n     * Only starts the services specified in `services`.\n     */\n    const up = spawn(`docker-compose`, ['-f', configFilePath, 'up', ...services], {});\n\n    await waitForDependencyStartupAsync(up, services);\n\n    if (services.includes('postgres')) {\n        await confirmPostgresConnectivityAsync();\n    }\n    // Return the function handle which will shutdown the services\n    return function closeFunction(): boolean {\n        const wasSuccessfulKill = up.kill();\n        return wasSuccessfulKill;\n    };\n}\n\n/**\n * Monitor the logs being emitted from the docker containers to detect\n * when services have started up. Postgres startup is managed with\n * `confirmPostgresConnectivityAsync`\n */\nasync function waitForDependencyStartupAsync(\n    logStream: ChildProcessWithoutNullStreams,\n    services: Service[],\n): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n        const startupTimeout = ONE_MINUTE_MS * 3; // tslint:disable-line custom-no-magic-numbers\n        const timeoutHandle = setTimeout(() => {\n            reject(new Error(`Timed out waiting for dependency logs\\n${JSON.stringify(isServiceStarted)}`));\n        }, startupTimeout);\n\n        const startupRegexSqs = /.*sqs.*listening on port \\d{4}/;\n        const startupRegexRedis = /.*redis.*Ready to accept connections/;\n        const startupRegexGananche = /.*ganache.*Listening on 0.0.0.0:\\d{4}/;\n\n        const isServiceStarted: Record<Service, boolean> = {\n            sqs: !services.includes('sqs'),\n            postgres: true, // managed by confirmPostgresConnectivityAsync\n            redis: !services.includes('redis'),\n            ganache: !services.includes('ganache'),\n        };\n\n        logStream.on('error', (error) => {\n            reject(`Stream closed with error: ${error}`);\n        });\n\n        logStream.stdout.on('data', (data) => {\n            const log = data.toString();\n            if (startupRegexRedis.test(log)) {\n                isServiceStarted.redis = true;\n            }\n            if (startupRegexSqs.test(log)) {\n                isServiceStarted.sqs = true;\n            }\n            if (startupRegexGananche.test(log)) {\n                isServiceStarted.ganache = true;\n            }\n\n            // Once all the services are started, resolve the promise\n            if (Object.values(isServiceStarted).every((v) => v)) {\n                // logStream.stdout.removeAllListeners('data');\n                // logStream.removeAllListeners('error');\n                clearTimeout(timeoutHandle);\n                resolve();\n            }\n        });\n    });\n}\n\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n// eslint-disable-next-line @typescript-eslint/no-inferrable-types\nasync function confirmPostgresConnectivityAsync(maxTries: number = 5): Promise<void> {\n    try {\n        await Promise.all([\n            // delay before retrying\n            new Promise<void>((resolve) => setTimeout(resolve, 2000)), // tslint:disable-line:custom-no-magic-numbers\n            async () => {\n                await initDbDataSourceAsync();\n            },\n        ]);\n        return;\n    } catch (e) {\n        if (maxTries > 0) {\n            await confirmPostgresConnectivityAsync(maxTries - 1);\n        } else {\n            throw e;\n        }\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/initDbDataSourceAsync.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/getDbDataSourceAsync.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/initDbDataSourceAsync.ts",{"fileContent":"import { DataSource } from 'typeorm';\n\nimport { getDbDataSourceAsync } from '../../src/getDbDataSourceAsync';\n\n/**\n * Get the DB connection and initialize it by installing extension and synchronize schemas\n * @returns db connection\n */\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n// eslint-disable-next-line @typescript-eslint/no-inferrable-types\nexport async function initDbDataSourceAsync(port: number = 5432): Promise<DataSource> {\n    const dataSource = await getDbDataSourceAsync(`postgres://api:api@localhost:${port}/api`);\n    await dataSource.query(`CREATE EXTENSION IF NOT EXISTS pgcrypto`); // used by view `rfq_maker_pairs_update_time_hashes`\n    await dataSource.query(`CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\"`); // used by `meta_transaction_jobs` to generate uuid\n    await dataSource.synchronize(true);\n    return dataSource;\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/getDbDataSourceAsync.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/createOrmConfig.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/getDbDataSourceAsync.ts",{"fileContent":"import { DataSource } from 'typeorm';\n\nimport { POSTGRES_URI } from './config';\nimport { createConfig } from './createOrmConfig';\n\nlet dataSource: DataSource;\n\n/**\n * Creates the DB connnection to use in an app\n */\nexport async function getDbDataSourceAsync(postgresUri: string = POSTGRES_URI): Promise<DataSource> {\n    if (!dataSource) {\n        const config = createConfig(postgresUri);\n        dataSource = new DataSource(config);\n        await dataSource.initialize();\n    }\n    return dataSource;\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/createOrmConfig.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/createOrmConfig.ts",{"fileContent":"import { DataSourceOptions } from 'typeorm';\n\nimport { POSTGRES_READ_REPLICA_URIS, POSTGRES_URI } from './config';\nimport {\n    BlockedAddressEntity,\n    KeyValueEntity,\n    MakerBalanceChainCacheEntity,\n    MetaTransactionJobEntity,\n    MetaTransactionSubmissionEntity,\n    OrderWatcherSignedOrderEntity,\n    PersistentSignedOrderEntity,\n    PersistentSignedOrderV4Entity,\n    RfqMaker,\n    RfqMakerUpdateTimeHash,\n    RfqmJobEntity,\n    RfqmQuoteEntity,\n    RfqmTransactionSubmissionEntity,\n    RfqmV2JobEntity,\n    RfqmV2QuoteEntity,\n    RfqmV2TransactionSubmissionEntity,\n    RfqmWorkerHeartbeatEntity,\n    SignedOrderEntity,\n    SignedOrderV4Entity,\n    TransactionEntity,\n} from './entities';\nimport { LastLookRejectionCooldownEntity } from './entities/LastLookRejectionCooldownsEntity';\n\nconst entities = [\n    BlockedAddressEntity,\n    SignedOrderEntity,\n    PersistentSignedOrderEntity,\n    TransactionEntity,\n    KeyValueEntity,\n    LastLookRejectionCooldownEntity,\n    MakerBalanceChainCacheEntity,\n    MetaTransactionJobEntity,\n    MetaTransactionSubmissionEntity,\n    SignedOrderV4Entity,\n    PersistentSignedOrderV4Entity,\n    RfqmWorkerHeartbeatEntity,\n    RfqmQuoteEntity,\n    RfqmJobEntity,\n    RfqmTransactionSubmissionEntity,\n    RfqmV2JobEntity,\n    RfqmV2QuoteEntity,\n    RfqmV2TransactionSubmissionEntity,\n    OrderWatcherSignedOrderEntity,\n    RfqMaker,\n    RfqMakerUpdateTimeHash,\n];\n\nexport const createConfig = (postgresUri: string = POSTGRES_URI): DataSourceOptions => ({\n    type: 'postgres',\n    entities,\n    synchronize: false,\n    logging: true,\n    logger: 'debug',\n    extra: {\n        max: 15,\n        statement_timeout: 10000,\n    },\n    migrations: ['./lib/migrations/*.js'],\n    ...(POSTGRES_READ_REPLICA_URIS\n        ? {\n              replication: {\n                  master: { url: postgresUri },\n                  slaves: POSTGRES_READ_REPLICA_URIS.map((r) => ({ url: r })),\n              },\n          }\n        : { url: postgresUri }),\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/background_job_test.ts",{"fileContent":"import { ChainId } from '@0x/contract-addresses';\nimport { Job, Queue } from 'bullmq';\nimport { expect } from 'chai';\nimport Redis from 'ioredis';\nimport { anything, instance, mock, spy, when } from 'ts-mockito';\n\nimport backgroundJobMBCEvict from '../src/background-jobs/maker_balance_cache_evict';\nimport backgroundJobMBCUpdate, {\n    BackgroundJobMBCUpdateData,\n    BackgroundJobMBCUpdateResult,\n} from '../src/background-jobs/maker_balance_cache_update';\nimport { CHAIN_CONFIGURATIONS } from '../src/config';\nimport { RfqMakerBalanceCacheService } from '../src/services/rfq_maker_balance_cache_service';\nimport * as serviceBuilder from '../src/utils/rfqm_service_builder';\n\ndescribe('Background Jobs Unit Tests', () => {\n    describe('maker-balance-cache-evict', () => {\n        it('should fail to create background job when bad chain id is passed', async () => {\n            const spiedChainConfigurations = spy(CHAIN_CONFIGURATIONS);\n            when(spiedChainConfigurations.find(anything())).thenReturn(undefined);\n\n            const { createAsync, processAsync } = backgroundJobMBCEvict;\n\n            const connectionMock = mock(Redis);\n\n            const queue = new Queue(backgroundJobMBCEvict.queueName, { connection: instance(connectionMock) });\n            const spiedQueue = spy(queue);\n            when(spiedQueue.emit(anything())).thenReturn(true);\n\n            const spiedJob = spy(Job);\n            when(spiedJob.create(anything(), anything(), anything(), anything())).thenCall(\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                (q: Queue, name: any, data: any) => new Job(q, name, data),\n            );\n\n            const badChainId = 11111111;\n            const timestamp = Date.now();\n\n            try {\n                const job = await createAsync(queue, {\n                    chainId: badChainId,\n                    timestamp,\n                });\n                expect(job.queueName).to.eq(backgroundJobMBCEvict.queueName);\n\n                const spiedJobInstance = spy(job);\n                when(spiedJobInstance.updateProgress(anything())).thenResolve();\n\n                expect(processAsync(job)).to.be.rejectedWith('chain configuration');\n            } catch (error) {\n                expect.fail('should create background job without error');\n            }\n        });\n\n        it('processes maker balance cache eviction without error', async () => {\n            const spiedChainConfigurations = spy(CHAIN_CONFIGURATIONS);\n            when(spiedChainConfigurations.find(anything())).thenReturn(anything());\n\n            const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n            when(rfqMakerBalanceCacheServiceMock.evictZeroBalancesAsync(anything())).thenResolve(1);\n\n            const spiedServiceBuilderAsync = spy(serviceBuilder);\n            when(spiedServiceBuilderAsync.buildRfqMakerBalanceCacheServiceAsync(anything())).thenResolve(\n                instance(rfqMakerBalanceCacheServiceMock),\n            );\n            const { createAsync, processAsync } = backgroundJobMBCEvict;\n\n            const connectionMock = mock(Redis);\n\n            const queue = new Queue(backgroundJobMBCEvict.queueName, { connection: instance(connectionMock) });\n            const spiedQueue = spy(queue);\n            when(spiedQueue.emit(anything())).thenReturn(true);\n\n            const spiedJob = spy(Job);\n            when(spiedJob.create(anything(), anything(), anything(), anything())).thenCall(\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                (q: Queue, name: any, data: any) => new Job(q, name, data),\n            );\n\n            const chainId = ChainId.Ganache;\n            const timestamp = Date.now();\n\n            try {\n                const job = await createAsync(queue, {\n                    chainId,\n                    timestamp,\n                });\n                expect(job.queueName).to.eq(backgroundJobMBCEvict.queueName);\n\n                const spiedJobInstance = spy(job);\n                when(spiedJobInstance.updateProgress(anything())).thenResolve();\n\n                const result = await processAsync(job);\n                expect(result.chainId).to.eq(chainId);\n                expect(result.numEvicted).to.eq(1);\n            } catch (error) {\n                expect.fail('should create and update background job without error');\n            }\n        });\n\n        it('should fail to process job when malformed cache service is passed', async () => {\n            const spiedChainConfigurations = spy(CHAIN_CONFIGURATIONS);\n            when(spiedChainConfigurations.find(anything())).thenReturn(anything());\n\n            const spiedServiceBuilderAsync = spy(serviceBuilder);\n            when(spiedServiceBuilderAsync.buildRfqMakerBalanceCacheServiceAsync(anything())).thenResolve();\n            const { createAsync, processAsync } = backgroundJobMBCEvict;\n\n            const connectionMock = mock(Redis);\n\n            const queue = new Queue(backgroundJobMBCEvict.queueName, { connection: instance(connectionMock) });\n            const spiedQueue = spy(queue);\n            when(spiedQueue.emit(anything())).thenReturn(true);\n\n            const spiedJob = spy(Job);\n            when(spiedJob.create(anything(), anything(), anything(), anything())).thenCall(\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                (q: Queue, name: any, data: any) => new Job(q, name, data),\n            );\n\n            const chainId = ChainId.Ganache;\n            const timestamp = Date.now();\n\n            try {\n                const job = await createAsync(queue, {\n                    chainId,\n                    timestamp,\n                });\n                expect(job.queueName).to.eq(backgroundJobMBCEvict.queueName);\n\n                const spiedJobInstance = spy(job);\n                when(spiedJobInstance.updateProgress(anything())).thenResolve();\n\n                expect(processAsync(job)).to.be.rejectedWith('initialize dependencies');\n            } catch (error) {\n                expect.fail('should create background job without error');\n            }\n        });\n\n        it('should fail to process job when the cache service fails to evict entries', async () => {\n            const spiedChainConfigurations = spy(CHAIN_CONFIGURATIONS);\n            when(spiedChainConfigurations.find(anything())).thenReturn(anything());\n\n            const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n            when(rfqMakerBalanceCacheServiceMock.evictZeroBalancesAsync(anything())).thenReject(\n                new Error('cache failed'),\n            );\n\n            const spiedServiceBuilderAsync = spy(serviceBuilder);\n            when(spiedServiceBuilderAsync.buildRfqMakerBalanceCacheServiceAsync(anything())).thenResolve(\n                instance(rfqMakerBalanceCacheServiceMock),\n            );\n            const { createAsync, processAsync } = backgroundJobMBCEvict;\n\n            const connectionMock = mock(Redis);\n\n            const queue = new Queue(backgroundJobMBCEvict.queueName, { connection: instance(connectionMock) });\n            const spiedQueue = spy(queue);\n            when(spiedQueue.emit(anything())).thenReturn(true);\n\n            const spiedJob = spy(Job);\n            when(spiedJob.create(anything(), anything(), anything(), anything())).thenCall(\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                (q: Queue, name: any, data: any) => new Job(q, name, data),\n            );\n\n            const chainId = ChainId.Ganache;\n            const timestamp = Date.now();\n\n            try {\n                const job = await createAsync(queue, {\n                    chainId,\n                    timestamp,\n                });\n                expect(job.queueName).to.eq(backgroundJobMBCEvict.queueName);\n\n                const spiedJobInstance = spy(job);\n                when(spiedJobInstance.updateProgress(anything())).thenResolve();\n\n                expect(processAsync(job)).to.be.rejectedWith('evict maker balance cache');\n            } catch (error) {\n                expect.fail('should create background job without error');\n            }\n        });\n    });\n\n    describe('maker-balance-cache-update', () => {\n        it('should fail to create background job when bad chain id is passed', async () => {\n            const spiedChainConfigurations = spy(CHAIN_CONFIGURATIONS);\n            when(spiedChainConfigurations.find(anything())).thenReturn(undefined);\n\n            const { createAsync, processAsync } = backgroundJobMBCUpdate;\n\n            const connectionMock = mock(Redis);\n\n            const queue = new Queue(backgroundJobMBCUpdate.queueName, { connection: instance(connectionMock) });\n            const spiedQueue = spy(queue);\n            when(spiedQueue.emit(anything())).thenReturn(true);\n\n            const spiedJob = spy(Job);\n            when(spiedJob.create(anything(), anything(), anything(), anything())).thenCall(\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                (q: Queue, name: any, data: any) => new Job(q, name, data),\n            );\n\n            const badChainId = 11111111;\n            const timestamp = Date.now();\n\n            try {\n                const job = await createAsync(queue, {\n                    chainId: badChainId,\n                    timestamp,\n                });\n                expect(job.queueName).to.eq(backgroundJobMBCUpdate.queueName);\n\n                const spiedJobInstance = spy(job);\n                when(spiedJobInstance.updateProgress(anything())).thenResolve();\n\n                expect(processAsync(job)).to.be.rejectedWith('chain configuration');\n            } catch (error) {\n                expect.fail('should create background job without error');\n            }\n        });\n\n        it('processes maker balance cache update without error', async () => {\n            const spiedChainConfigurations = spy(CHAIN_CONFIGURATIONS);\n            when(spiedChainConfigurations.find(anything())).thenReturn(anything());\n\n            const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n            when(rfqMakerBalanceCacheServiceMock.updateERC20OwnerBalancesAsync(anything())).thenResolve();\n\n            const spiedServiceBuilderAsync = spy(serviceBuilder);\n            when(spiedServiceBuilderAsync.buildRfqMakerBalanceCacheServiceAsync(anything())).thenResolve(\n                instance(rfqMakerBalanceCacheServiceMock),\n            );\n            const { createAsync, processAsync } = backgroundJobMBCUpdate;\n\n            const connectionMock = mock(Redis);\n\n            const queue = new Queue(backgroundJobMBCUpdate.queueName, { connection: instance(connectionMock) });\n            const spiedQueue = spy(queue);\n            when(spiedQueue.emit(anything())).thenReturn(true);\n\n            const spiedJob = spy(Job);\n            when(spiedJob.create(anything(), anything(), anything(), anything())).thenCall(\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                (q: Queue, name: any, data: any) => new Job(q, name, data),\n            );\n\n            const chainId = ChainId.Ganache;\n            const timestamp = Date.now();\n\n            let job: Job<BackgroundJobMBCUpdateData, BackgroundJobMBCUpdateResult>;\n            try {\n                job = await createAsync(queue, {\n                    chainId,\n                    timestamp,\n                });\n                expect(job.queueName).to.eq(backgroundJobMBCUpdate.queueName);\n\n                const spiedJobInstance = spy(job);\n                when(spiedJobInstance.updateProgress(anything())).thenResolve();\n\n                const result = await processAsync(job);\n                expect(result.chainId).to.eq(chainId);\n            } catch (error) {\n                expect.fail('should create and update background job without error');\n            }\n        });\n\n        it('should fail to process job when the cache service fails to update entries', async () => {\n            const spiedChainConfigurations = spy(CHAIN_CONFIGURATIONS);\n            when(spiedChainConfigurations.find(anything())).thenReturn(anything());\n\n            const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n            when(rfqMakerBalanceCacheServiceMock.updateERC20OwnerBalancesAsync(anything())).thenReject(\n                new Error('cache failed'),\n            );\n\n            const spiedServiceBuilderAsync = spy(serviceBuilder);\n            when(spiedServiceBuilderAsync.buildRfqMakerBalanceCacheServiceAsync(anything())).thenResolve(\n                instance(rfqMakerBalanceCacheServiceMock),\n            );\n            const { createAsync, processAsync } = backgroundJobMBCUpdate;\n\n            const connectionMock = mock(Redis);\n\n            const queue = new Queue(backgroundJobMBCUpdate.queueName, { connection: instance(connectionMock) });\n            const spiedQueue = spy(queue);\n            when(spiedQueue.emit(anything())).thenReturn(true);\n\n            const spiedJob = spy(Job);\n            when(spiedJob.create(anything(), anything(), anything(), anything())).thenCall(\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                (q: Queue, name: any, data: any) => new Job(q, name, data),\n            );\n\n            const chainId = ChainId.Ganache;\n            const timestamp = Date.now();\n\n            let job: Job<BackgroundJobMBCUpdateData, BackgroundJobMBCUpdateResult>;\n            try {\n                job = await createAsync(queue, {\n                    chainId,\n                    timestamp,\n                });\n                expect(job.queueName).to.eq(backgroundJobMBCUpdate.queueName);\n\n                const spiedJobInstance = spy(job);\n                when(spiedJobInstance.updateProgress(anything())).thenResolve();\n\n                expect(processAsync(job)).to.be.rejectedWith('update maker balance cache');\n            } catch (error) {\n                expect.fail('should create background job without error');\n            }\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/background-jobs/maker_balance_cache_evict.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/background-jobs/maker_balance_cache_update.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_service_builder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/background-jobs/blueprint.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/WorkerService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/provider_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/background-jobs/maker_balance_cache_evict.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\nimport { Job, Queue } from 'bullmq';\nimport { Counter } from 'prom-client';\n\nimport { CHAIN_CONFIGURATIONS } from '../config';\nimport { logger } from '../logger';\nimport { buildRfqMakerBalanceCacheServiceAsync } from '../utils/rfqm_service_builder';\n\nimport { BackgroundJobBlueprint } from './blueprint';\n\nconst QUEUE_NAME = 'maker-balance-cache-evict';\n// keep successful job history for 1 day\nconst REMOVE_ON_COMPLETE_OPS = {\n    count: 24 * 60 * 0.5,\n};\n// keep failed job history for 3 days\nconst REMOVE_ON_FAILURE_OPS = {\n    count: 3 * 24 * 60 * 0.5,\n};\nconst MAKER_BALANCE_CACHE_EVICT_SCHEDULE = '*/2 * * * *'; // job will be scheduled at every 2 minutes\nconst DESCRIPTION = 'Periodically evicts stale entries from maker balance cache.';\n\nexport interface BackgroundJobMBCEvictData {\n    chainId: number;\n    timestamp: number;\n}\n\nexport interface BackgroundJobMBCEvictResult {\n    chainId: number;\n    jobName: string;\n    numEvicted: number;\n    timestamp: number;\n}\n\nconst backgroundJobMBCEvict: BackgroundJobBlueprint<BackgroundJobMBCEvictData, BackgroundJobMBCEvictResult> = {\n    queueName: QUEUE_NAME,\n    schedule: MAKER_BALANCE_CACHE_EVICT_SCHEDULE,\n    description: DESCRIPTION,\n    createAsync,\n    processAsync,\n};\n// tslint:disable-next-line: no-default-export\nexport default backgroundJobMBCEvict;\n\nconst MAKER_BALANCE_CACHE_EVICT_PROCESS_COUNT = new Counter({\n    name: 'rfq_background_job_mbc_evict_process_total',\n    help: 'Number of times the processor method of the maker balance cache evict background job is triggered',\n});\n\n/**\n * Creates a background job by queues a message that performs an eviction on the maker balance cache.\n *\n * @param queue Queue to push the message.\n * @param data Necessary data for processor to execute the background job.\n * @returns Promise of the background job.\n */\nasync function createAsync(\n    queue: Queue,\n    data: BackgroundJobMBCEvictData,\n): Promise<Job<BackgroundJobMBCEvictData, BackgroundJobMBCEvictResult>> {\n    logger.info({ queue: QUEUE_NAME, data }, 'Creating the maker balance cache background job on queue');\n    return queue.add(`${QUEUE_NAME}.${data.timestamp}`, data, {\n        removeOnComplete: REMOVE_ON_COMPLETE_OPS,\n        removeOnFail: REMOVE_ON_FAILURE_OPS,\n    });\n}\n\n/**\n * Processor method for the maker balance cache evict job. Evicts entries with zero balances from the cache.\n *\n * @param job Maker balance cache evict background job.\n * @returns Result of the evict background job.\n */\nasync function processAsync(\n    job: Job<BackgroundJobMBCEvictData, BackgroundJobMBCEvictResult>,\n): Promise<BackgroundJobMBCEvictResult> {\n    await job.updateProgress(0);\n    logger.info(\n        { jobName: job.name, queue: job.queueName, data: job.data, timestamp: Date.now() },\n        'Processing the maker balance cache evict background job on queue',\n    );\n\n    const chainId = job.data.chainId;\n\n    // Build dependencies\n    const chain = CHAIN_CONFIGURATIONS.find((c) => c.chainId === chainId);\n    if (!chain) {\n        throw new Error(`Tried to start background job process for chain ${chainId}\n        but no chain configuration was present`);\n    }\n    const rfqMakerBalanceCacheService = await buildRfqMakerBalanceCacheServiceAsync(chain);\n    if (!rfqMakerBalanceCacheService) {\n        logger.error(\n            { jobName: job.name, queue: job.queueName, data: job.data, timestamp: Date.now() },\n            'Failed to initialize dependencies for maker-balance-cache-evict',\n        );\n        throw new Error('Failed to initialize dependencies for maker-balance-cache-evict');\n    }\n    await job.updateProgress(50);\n\n    // Perform eviction on maker balance cache entries\n    let numEvicted;\n    try {\n        numEvicted = await rfqMakerBalanceCacheService.evictZeroBalancesAsync(chainId);\n        MAKER_BALANCE_CACHE_EVICT_PROCESS_COUNT.inc();\n    } catch (error) {\n        logger.error(\n            { jobName: job.name, queue: job.queueName, data: job.data, timestamp: Date.now() },\n            'Failed to evict maker balance cache while running scheduled background job',\n        );\n        throw new Error('Failed to evict maker balance cache while running scheduled background job');\n    } finally {\n        await rfqMakerBalanceCacheService.closeAsync();\n    }\n\n    await job.updateProgress(100);\n    return {\n        chainId,\n        jobName: job.name,\n        numEvicted,\n        timestamp: Date.now(),\n    };\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_service_builder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/background-jobs/blueprint.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/WorkerService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/provider_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts",{"fileContent":"import { pino } from '@0x/api-utils';\nimport { BigNumber } from '@0x/utils';\nimport { createHash } from 'crypto';\n\nimport { LOGGER_INCLUDE_TIMESTAMP, LOG_LEVEL } from './config';\n\nexport const logger = pino({\n    formatters: {\n        level: (label) => ({\n            level: label,\n        }),\n    },\n    level: LOG_LEVEL,\n    timestamp: LOGGER_INCLUDE_TIMESTAMP,\n});\n\n/**\n * Converts the parameters of a swap request into a 16-character ID\n * which can be used in logging to associate price and quote requests.\n *\n * Used SHA1 because apparently it's the fastest:\n * https://medium.com/@chris_72272/what-is-the-fastest-node-js-hashing-algorithm-c15c1a0e164e\n *\n * `takerAddress` is an optional parameter so it's easy to put a price request\n * into the function. However, if `takerAddress` is not present, the function returns\n * `null`. The reasoning for this is so two common trades by different takers\n * (e.x.: sell 1 WMATIC for USDC) aren't given the same ID.\n */\nexport function createSwapId(parameters: {\n    buyAmount?: BigNumber;\n    buyToken: string;\n    sellAmount?: BigNumber;\n    sellToken: string;\n    // If a taker address is not provided, the function returns `null`.\n    takerAddress?: string;\n}): string | null {\n    const { takerAddress } = parameters;\n    if (!takerAddress) {\n        return null;\n    }\n    const idLength = 16;\n    return createHash('sha1')\n        .update(\n            `${parameters.buyAmount?.toString() ?? ''}${parameters.buyToken}${parameters.sellAmount?.toString() ?? ''}${\n                parameters.sellToken\n            }${parameters.takerAddress}`,\n        )\n        .digest('hex')\n        .slice(0, idLength);\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_service_builder.ts",{"fileContent":"import {\n    artifacts,\n    AssetSwapperContractAddresses,\n    ERC20BridgeSamplerContract,\n    SupportedProvider,\n} from '@0x/asset-swapper';\nimport { ChainId, getContractAddressesForChainOrThrow } from '@0x/contract-addresses';\nimport { PrivateKeyWalletSubprovider } from '@0x/subproviders';\nimport { getTokenMetadataIfExists } from '@0x/token-metadata';\nimport { Web3Wrapper } from '@0x/web3-wrapper';\nimport Axios, { AxiosRequestConfig } from 'axios';\nimport { providers, Wallet } from 'ethers';\nimport { Agent as HttpAgent } from 'http';\nimport { Agent as HttpsAgent } from 'https';\nimport Redis from 'ioredis';\nimport { Kafka, Producer as KafkaProducer } from 'kafkajs';\nimport { Producer } from 'sqs-producer';\n\nimport {\n    ChainConfiguration,\n    ChainConfigurations,\n    KAFKA_BROKERS,\n    META_TX_WORKER_MNEMONIC,\n    REDIS_URI,\n    RFQ_PROXY_ADDRESS,\n    RFQ_PROXY_PORT,\n    ZERO_EX_API_KEY,\n} from '../config';\nimport {\n    DEFAULT_MIN_EXPIRY_DURATION_MS,\n    DEFAULT_WORKER_TRANSACTION_WATCHER_SLEEP_TIME_MS,\n    KEEP_ALIVE_TTL,\n} from '../core/constants';\nimport { logger } from '../logger';\nimport { FeeService } from '../services/fee_service';\nimport { RfqmService } from '../services/rfqm_service';\nimport { RfqMakerBalanceCacheService } from '../services/rfq_maker_balance_cache_service';\nimport { WorkerService } from '../services/WorkerService';\n\nimport { BalanceChecker } from './balance_checker';\nimport { CacheClient } from './cache_client';\nimport { ConfigManager } from './config_manager';\nimport { getGasStationAttendant } from './GasStationAttendantUtils';\nimport { providerUtils } from './provider_utils';\nimport { QuoteServerClient } from './quote_server_client';\nimport { RfqmDbUtils } from './rfqm_db_utils';\nimport { RfqBalanceCheckUtils, RfqBlockchainUtils } from './rfq_blockchain_utils';\nimport { RfqMakerDbUtils } from './rfq_maker_db_utils';\nimport { RfqMakerManager } from './rfq_maker_manager';\nimport { TokenMetadataManager } from './TokenMetadataManager';\nimport { TokenPriceOracle } from './TokenPriceOracle';\nimport { ZeroExApiClient } from './ZeroExApiClient';\n\nexport type RfqmServices = Map<number, RfqmService>;\n\nconst DEFAULT_AXIOS_TIMEOUT = 600; // ms\n\n/**\n * Initialize a kafka producer if KAFKA_BROKERS is set\n */\nfunction getKafkaProducer(): KafkaProducer | undefined {\n    let kafkaProducer: KafkaProducer | undefined;\n    if (KAFKA_BROKERS !== undefined) {\n        const kafka = new Kafka({\n            clientId: '0x-api',\n            brokers: KAFKA_BROKERS,\n        });\n\n        kafkaProducer = kafka.producer();\n        // tslint:disable-next-line: no-floating-promises\n        kafkaProducer.connect();\n    }\n    return kafkaProducer;\n}\n\n/**\n * Creates the default Axios Request Config\n */\nexport function getAxiosRequestConfig(timeout: number = DEFAULT_AXIOS_TIMEOUT): AxiosRequestConfig {\n    return {\n        httpAgent: new HttpAgent({ keepAlive: true, timeout: KEEP_ALIVE_TTL }),\n        httpsAgent: new HttpsAgent({ keepAlive: true, timeout: KEEP_ALIVE_TTL }),\n        timeout,\n    };\n}\n\n/**\n * Creates the Axios Request Config with egress proxy\n */\nexport function getAxiosRequestConfigWithProxy(): AxiosRequestConfig {\n    const axiosRequestConfig: AxiosRequestConfig = getAxiosRequestConfig();\n    if (RFQ_PROXY_ADDRESS !== undefined && RFQ_PROXY_PORT !== undefined) {\n        axiosRequestConfig.proxy = {\n            host: RFQ_PROXY_ADDRESS,\n            port: RFQ_PROXY_PORT,\n        };\n    }\n\n    return axiosRequestConfig;\n}\n\nasync function deploySamplerContractAsync(\n    provider: SupportedProvider,\n    chainId: ChainId,\n): Promise<ERC20BridgeSamplerContract> {\n    const web3Wrapper = new Web3Wrapper(provider);\n    const _chainId = await web3Wrapper.getChainIdAsync();\n    if (_chainId !== chainId) {\n        throw new Error(`Incorrect Chain Id: ${_chainId}`);\n    }\n    const [account] = await web3Wrapper.getAvailableAddressesAsync();\n    try {\n        const sampler = await ERC20BridgeSamplerContract.deployFrom0xArtifactAsync(\n            artifacts.ERC20BridgeSampler,\n            provider,\n            { from: account },\n            {},\n        );\n        logger.info(`Deployed ERC20BridgeSamplerContract on network ${chainId}: ${sampler.address}`);\n        return sampler;\n    } catch (err) {\n        logger.error(`Failed to deploy ERC20BridgeSamplerContract on network ${chainId}: ${err}`);\n        throw err;\n    }\n}\n\n/**\n * Determines the contract addresses needed for the network. For testing (ganache)\n * required contracts are deployed\n * @param provider provider to the network, used for ganache deployment\n * @param chainConfiguration used for getting chainId and exchangeProxyContractAddressOverride\n */\nexport async function getContractAddressesForNetworkOrThrowAsync(\n    provider: SupportedProvider,\n    chainConfiguration: Pick<ChainConfiguration, 'chainId' | 'exchangeProxyContractAddressOverride'>,\n): Promise<AssetSwapperContractAddresses> {\n    const { chainId, exchangeProxyContractAddressOverride } = chainConfiguration;\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let contractAddresses = getContractAddressesForChainOrThrow(chainId.toString() as any);\n    // In a testnet where the environment does not support overrides\n    // so we deploy the latest sampler\n    if (chainId === ChainId.Ganache) {\n        const sampler = await deploySamplerContractAsync(provider, chainId);\n        contractAddresses = { ...contractAddresses, erc20BridgeSampler: sampler.address };\n    }\n    // If 0x Exchange Proxy contract address override is defined in the chain config\n    // we use address instead of the one provided from `@0x/contract-addresses`\n    if (exchangeProxyContractAddressOverride) {\n        contractAddresses = { ...contractAddresses, exchangeProxy: exchangeProxyContractAddressOverride };\n    }\n    return contractAddresses;\n}\n\n/**\n * Builds a single instance of RfqmService\n */\nexport async function buildRfqmServiceAsync(\n    rfqmDbUtils: RfqmDbUtils,\n    rfqMakerManager: RfqMakerManager,\n    tokenPriceOracle: TokenPriceOracle,\n    configManager: ConfigManager,\n    chain: ChainConfiguration,\n    redis: Redis,\n): Promise<RfqmService> {\n    const { rfqm: rfqmConfiguration, chainId } = chain;\n    if (!rfqmConfiguration) {\n        throw new Error(`RFQm Service for chain ${chainId} does not exist`);\n    }\n\n    // ether.js Provider coexists with web3 provider during migration away from 0x/web3-wrapper.\n    const ethersProvider = new providers.JsonRpcProvider(chain.rpcUrl, chainId);\n\n    const rpcProvider = providerUtils.createWeb3Provider(chain.rpcUrl);\n    const provider: SupportedProvider = rpcProvider;\n\n    const contractAddresses = await getContractAddressesForNetworkOrThrowAsync(provider, chain);\n    const axiosInstance = Axios.create(getAxiosRequestConfig());\n    const proxiedAxiosInstance = Axios.create(getAxiosRequestConfigWithProxy());\n\n    const balanceChecker = new BalanceChecker(provider);\n    const rfqBlockchainUtils = new RfqBlockchainUtils(\n        provider,\n        contractAddresses.exchangeProxy,\n        balanceChecker,\n        ethersProvider,\n    );\n\n    const tokenMetadataManager = new TokenMetadataManager(chainId, rfqBlockchainUtils);\n\n    const sqsProducer = Producer.create({\n        queueUrl: chain.sqsUrl,\n    });\n\n    const quoteServerClient = new QuoteServerClient(proxiedAxiosInstance);\n\n    const cacheClient = new CacheClient(redis);\n\n    const kafkaProducer = getKafkaProducer();\n\n    const gasStationAttendant = getGasStationAttendant(chain, axiosInstance);\n\n    const feeTokenMetadata = getTokenMetadataIfExists(contractAddresses.etherToken, chainId);\n    if (feeTokenMetadata === undefined) {\n        throw new Error(`Fee token ${contractAddresses.etherToken} on chain ${chainId} could not be found!`);\n    }\n\n    const zeroExApiClient = new ZeroExApiClient(Axios.create(), ZERO_EX_API_KEY, chain);\n\n    const feeService = new FeeService(\n        chainId,\n        feeTokenMetadata,\n        configManager,\n        gasStationAttendant,\n        tokenPriceOracle,\n        zeroExApiClient,\n        rfqmConfiguration.minExpiryDurationMs || DEFAULT_MIN_EXPIRY_DURATION_MS,\n    );\n\n    const rfqMakerBalanceCacheService = new RfqMakerBalanceCacheService(\n        cacheClient,\n        rfqBlockchainUtils.balanceCheckUtils,\n    );\n\n    return new RfqmService(\n        chainId,\n        feeService,\n        rfqmConfiguration.feeModelVersion || 0,\n        contractAddresses,\n        chain.registryAddress,\n        rfqBlockchainUtils,\n        rfqmDbUtils,\n        sqsProducer,\n        quoteServerClient,\n        rfqmConfiguration.minExpiryDurationMs || DEFAULT_MIN_EXPIRY_DURATION_MS,\n        cacheClient,\n        rfqMakerBalanceCacheService,\n        rfqMakerManager,\n        tokenMetadataManager,\n        kafkaProducer,\n        rfqmConfiguration.quoteReportTopic,\n    );\n}\n\n/**\n * Builds a single instance of the WorkerService\n */\nexport async function buildWorkerServiceAsync(\n    rfqmDbUtils: RfqmDbUtils,\n    rfqMakerManager: RfqMakerManager,\n    chain: ChainConfiguration,\n    redis: Redis,\n    workerIndex: number,\n): Promise<WorkerService> {\n    const { worker: workerConfiguration, chainId } = chain;\n    if (!workerConfiguration) {\n        throw new Error(`Worker Service for chain ${chainId} does not exist`);\n    }\n\n    let provider: SupportedProvider;\n\n    // ether.js Provider coexists with web3 provider during migration away from 0x/web3-wrapper.\n    const ethersProvider = new providers.JsonRpcProvider(chain.rpcUrl, chainId);\n    let ethersWallet: Wallet | undefined;\n\n    const rpcProvider = providerUtils.createWeb3Provider(chain.rpcUrl);\n    if (META_TX_WORKER_MNEMONIC === undefined) {\n        throw new Error(`META_TX_WORKER_MNEMONIC must be defined to run RFQM service as a worker`);\n    }\n    const workerPrivateKey = RfqBlockchainUtils.getPrivateKeyFromIndexAndPhrase(META_TX_WORKER_MNEMONIC, workerIndex);\n\n    // TODO (rhinodavid): Remove once migration to ethers.js is complete\n    const privateWalletSubprovider = new PrivateKeyWalletSubprovider(workerPrivateKey);\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    // eslint-disable-next-line prefer-const\n    provider = RfqBlockchainUtils.createPrivateKeyProvider(rpcProvider, privateWalletSubprovider);\n\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    ethersWallet = Wallet.fromMnemonic(META_TX_WORKER_MNEMONIC, `m/44'/60'/0'/0/${workerIndex!}`);\n    ethersWallet = ethersWallet.connect(ethersProvider);\n\n    const contractAddresses = await getContractAddressesForNetworkOrThrowAsync(provider, chain);\n    const axiosInstance = Axios.create(getAxiosRequestConfigWithProxy());\n\n    const balanceChecker = new BalanceChecker(provider);\n    const rfqBlockchainUtils = new RfqBlockchainUtils(\n        provider,\n        contractAddresses.exchangeProxy,\n        balanceChecker,\n        ethersProvider,\n        ethersWallet,\n    );\n\n    const quoteServerClient = new QuoteServerClient(axiosInstance);\n\n    const cacheClient = new CacheClient(redis);\n\n    const gasStationAttendant = getGasStationAttendant(chain, axiosInstance);\n\n    const feeTokenMetadata = getTokenMetadataIfExists(contractAddresses.etherToken, chainId);\n    if (feeTokenMetadata === undefined) {\n        throw new Error(`Fee token ${contractAddresses.etherToken} on chain ${chainId} could not be found!`);\n    }\n\n    const rfqMakerBalanceCacheService = new RfqMakerBalanceCacheService(\n        cacheClient,\n        rfqBlockchainUtils.balanceCheckUtils,\n    );\n\n    return new WorkerService(\n        chainId,\n        gasStationAttendant,\n        chain.registryAddress,\n        rfqBlockchainUtils,\n        rfqmDbUtils,\n        quoteServerClient,\n        workerConfiguration.transactionWatcherSleepTimeMs || DEFAULT_WORKER_TRANSACTION_WATCHER_SLEEP_TIME_MS,\n        cacheClient,\n        rfqMakerBalanceCacheService,\n        rfqMakerManager,\n        workerConfiguration.initialMaxPriorityFeePerGasGwei,\n        workerConfiguration.maxFeePerGasCapGwei,\n        workerConfiguration.enableAccessList,\n    );\n}\n\n/**\n * Builds an instance of maker balance cache service.\n * Intended to be used by maker balance cache background jobs.\n */\nexport async function buildRfqMakerBalanceCacheServiceAsync(\n    chain: ChainConfiguration,\n): Promise<RfqMakerBalanceCacheService> {\n    const provider = providerUtils.createWeb3Provider(chain.rpcUrl);\n    const contractAddresses = await getContractAddressesForNetworkOrThrowAsync(provider, chain);\n    const balanceChecker = new BalanceChecker(provider);\n    const balanceCheckUtils = new RfqBalanceCheckUtils(balanceChecker, contractAddresses.exchangeProxy);\n\n    if (!REDIS_URI) {\n        throw new Error('No redis URI provided to maker balance cache service');\n    }\n    const redis = new Redis(REDIS_URI);\n    const cacheClient = new CacheClient(redis);\n\n    return new RfqMakerBalanceCacheService(cacheClient, balanceCheckUtils);\n}\n\n/**\n * Creates an RFQM Service for each chain present in `ChainConfigurations`.\n *\n * Intended for use by the top-level runners.\n */\nexport async function buildRfqmServicesAsync(\n    asWorker: boolean,\n    rfqmDbUtils: RfqmDbUtils,\n    rfqMakerDbUtils: RfqMakerDbUtils,\n    chainConfigurations: ChainConfigurations,\n    tokenPriceOracle: TokenPriceOracle,\n    configManager: ConfigManager = new ConfigManager(),\n    redis: Redis,\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    // eslint-disable-next-line @typescript-eslint/no-inferrable-types\n    _workerIndex: number = 0,\n): Promise<RfqmServices> {\n    const services = await Promise.all(\n        chainConfigurations.map(async (chain) => {\n            const rfqMakerManager = new RfqMakerManager(configManager, rfqMakerDbUtils, chain.chainId);\n            await rfqMakerManager.initializeAsync();\n            return buildRfqmServiceAsync(rfqmDbUtils, rfqMakerManager, tokenPriceOracle, configManager, chain, redis);\n        }),\n    );\n    return new Map(services.map((s, i) => [chainConfigurations[i].chainId, s]));\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/WorkerService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/provider_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_health_check.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/SubmissionContext.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType0.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType2.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantEthereum.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantPolygon.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts",{"fileContent":"// tslint:disable:max-file-line-count\nimport { TokenMetadata } from '@0x/token-metadata';\nimport { BigNumber } from '@0x/utils';\n\nimport { BPS_TO_RATIO, ZERO } from '../core/constants';\nimport {\n    ConversionRates,\n    DefaultFeeDetailsDeprecated,\n    Fee,\n    FeeBreakdown,\n    FeeWithDetails,\n    GasOnlyFeeDetailsDeprecated,\n    IndicativeQuote,\n    MarginBasedFeeDetailsDeprecated,\n} from '../core/types';\nimport { logger } from '../logger';\nimport { ConfigManager } from '../utils/config_manager';\nimport { GasStationAttendant } from '../utils/GasStationAttendant';\nimport { getBestQuote } from '../utils/quote_comparison_utils';\nimport { calculateGasEstimate } from '../utils/rfqm_gas_estimate_utils';\nimport { TokenPriceOracle } from '../utils/TokenPriceOracle';\nimport { AmmQuote, ZeroExApiClient } from '../utils/ZeroExApiClient';\n\nimport { QuoteContext } from './types';\n\n/**\n * Interface for the response of CalculateFeeAsync() method. Including `feeWithDetails` object, and two optional fields for fee model v2:\n * `quotesWithGasFee` are the original quotes returned by MM when queried with gas fee, and `ammQuoteUniqueId` is the unique\n * id (`decodedUniqueId`) of quote report generated by /swap API as it get called by RFQm fee servie.\n */\ninterface CalculateFeeResponse {\n    feeWithDetails: FeeWithDetails;\n    quotesWithGasFee?: IndicativeQuote[];\n    ammQuoteUniqueId?: string;\n}\n\n/**\n * Pure function to calculate the amount of `default` fee, based on trade size and flat rate in `tradeSizeBps`. Trade size is denominated\n * in `tradeToken` (either `makerToken` or `takerToken`), which is selected by the caller.\n *\n * @param tradeTokenAmount amount of trade token (in base unit) in the trade.\n * @param feeRateBps flat fee rate represented by number of base points.\n * @param tradeTokenBaseUnitPriceUsd USD price of 1 base unit of trade token.\n * @returns `default` fee amount in fee token base unit.\n */\nexport const calculateDefaultFeeAmount = (\n    tradeTokenAmount: BigNumber,\n    feeRateBps: number,\n    tradeTokenBaseUnitPriceUsd: BigNumber | null,\n    feeTokenBaseUnitPriceUsd: BigNumber | null,\n): BigNumber => {\n    if (feeRateBps > 0 && tradeTokenBaseUnitPriceUsd !== null && feeTokenBaseUnitPriceUsd !== null) {\n        return tradeTokenAmount\n            .times(feeRateBps * BPS_TO_RATIO)\n            .times(tradeTokenBaseUnitPriceUsd)\n            .div(feeTokenBaseUnitPriceUsd)\n            .integerValue();\n    }\n\n    return ZERO;\n};\n\n/**\n * Pure function to calculate the price improvement based on given MM quote and AMM quote.\n *\n * @param makerQuoteWithGasFee maker quote with gas fee taken into account.\n * @param ammQuote Amm quote from 0x-api, with only AMM liquidity sources considered.\n * @param isSelling whether taker is selling. If true taker specifies `takerAmount` which should be fixed across quotes,\n * and `quoteToken` is `makerToken`. Otherwise taker specifies `makerAmount` and `quoteToken` is `takerToken`.\n * @param quoteTokenBaseUnitPriceUsd USD price of 1 base unit of quote token.\n * @param feeTokenBaseUnitPriceUsd USD price of 1 base unit of fee token.\n * @returns price improvement of MM quote comparing with AMM quote, in base unit of fee token.\n */\nexport const calculatePriceImprovementAmount = (\n    makerQuoteWithGasFee: IndicativeQuote,\n    ammQuote: AmmQuote,\n    isSelling: boolean,\n    quoteTokenBaseUnitPriceUsd: BigNumber,\n    feeTokenBaseUnitPriceUsd: BigNumber,\n): BigNumber => {\n    if (isSelling) {\n        const makerTokenBaseUnitPriceUsd = quoteTokenBaseUnitPriceUsd;\n        const rfqPrice = makerQuoteWithGasFee.makerAmount\n            .times(makerTokenBaseUnitPriceUsd)\n            .div(feeTokenBaseUnitPriceUsd);\n        const ammPrice = ammQuote.makerAmount\n            .times(new BigNumber(1).plus(ammQuote.expectedSlippage))\n            .times(makerTokenBaseUnitPriceUsd)\n            .div(feeTokenBaseUnitPriceUsd)\n            .minus(ammQuote.estimatedGasFeeWei);\n        if (rfqPrice.gt(ammPrice)) {\n            return rfqPrice.minus(ammPrice).integerValue();\n        }\n    } else {\n        const takerTokenBaseUnitPriceUsd = quoteTokenBaseUnitPriceUsd;\n        const rfqPrice = makerQuoteWithGasFee.takerAmount\n            .times(takerTokenBaseUnitPriceUsd)\n            .div(feeTokenBaseUnitPriceUsd);\n        const ammPrice = ammQuote.takerAmount\n            .times(new BigNumber(1).minus(ammQuote.expectedSlippage))\n            .times(takerTokenBaseUnitPriceUsd)\n            .div(feeTokenBaseUnitPriceUsd)\n            .plus(ammQuote.estimatedGasFeeWei);\n        if (ammPrice.gt(rfqPrice)) {\n            return ammPrice.minus(rfqPrice).integerValue();\n        }\n    }\n    return ZERO;\n};\n\n/**\n * Pure function to revise a maker's quote with fees. This allows us to approximate what the maker's actual quote will be when we\n * ask them to include fees. Useful for reducing load to MM servers.\n *\n * @param quote the raw quote from a maker. For RFQm the raw quote already include gas fee.\n * @param fees fees to incorporate into the quote. For RFQm this will be the amount other than gas fee.\n * @param isSelling whether taker is selling. If true taker specifies `takerAmount` which should be fixed across quotes,\n * and `quoteToken` is `makerToken`. Otherwise taker specifies `makerAmount` and `quoteToken` is `takerToken`.\n * @param quoteTokenBaseUnitPriceUsd USD price of 1 base unit of quote token.\n * @param feeTokenBaseUnitPriceUsd USD price of 1 base unit of fee token.\n * @returns revised quote with fees taken into account.\n */\nexport const reviseQuoteWithFees = (\n    quote: IndicativeQuote,\n    fees: BigNumber,\n    isSelling: boolean,\n    quoteTokenBaseUnitPriceUsd: BigNumber,\n    feeTokenBaseUnitPriceUsd: BigNumber,\n): IndicativeQuote => {\n    let { makerAmount, takerAmount } = quote;\n    if (isSelling) {\n        const makerTokenBaseUnitPriceUsd = quoteTokenBaseUnitPriceUsd;\n        makerAmount = makerAmount\n            .minus(fees.times(feeTokenBaseUnitPriceUsd).div(makerTokenBaseUnitPriceUsd))\n            .integerValue();\n    } else {\n        const takerTokenBaseUnitPriceUsd = quoteTokenBaseUnitPriceUsd;\n        takerAmount = takerAmount\n            .plus(fees.times(feeTokenBaseUnitPriceUsd).div(takerTokenBaseUnitPriceUsd))\n            .integerValue();\n    }\n\n    return { ...quote, makerAmount, takerAmount };\n};\n\n/**\n * FeeService is used by RfqmService to calculate RFQm Fees of all versions (0, 1 and 2).\n */\nexport class FeeService {\n    constructor(\n        private readonly _chainId: number,\n        private readonly _feeTokenMetadata: TokenMetadata,\n        private readonly _configManager: ConfigManager,\n        private readonly _gasStationAttendant: GasStationAttendant,\n        private readonly _tokenPriceOracle: TokenPriceOracle,\n        private readonly _zeroExApiClient: ZeroExApiClient,\n        private readonly _minExpiryDurationMs: number,\n    ) {}\n\n    /**\n     * Retrieve estimated gas price from the gas station.\n     *\n     * @returns estimated gas price\n     */\n    public async getGasPriceEstimationAsync(): Promise<BigNumber> {\n        const gasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();\n        return gasPriceEstimate;\n    }\n\n    /**\n     * Calculate Fee for given quote context.\n     *\n     * @returns estimated fee with details\n     */\n    public async calculateFeeAsync(\n        quoteContext: QuoteContext,\n        fetchMmQuotesAsync?: (quoteContext: QuoteContext, fee: Fee) => Promise<IndicativeQuote[]>,\n    ): Promise<CalculateFeeResponse> {\n        const { feeModelVersion } = quoteContext;\n\n        switch (feeModelVersion) {\n            case 2:\n                return this._calculateFeeV2Async(quoteContext, fetchMmQuotesAsync);\n            case 1:\n                return {\n                    feeWithDetails: await this._calculateFeeV1Async(quoteContext),\n                };\n            case 0:\n            default:\n                return {\n                    feeWithDetails: await this._calculateGasFeeAsync({ ...quoteContext, feeModelVersion: 0 }),\n                };\n        }\n    }\n    /**\n     * Revise original maker quotes with fees. This allows us to approximate what the maker's actual quote will be when we ask them\n     * to include fees. Useful for reducing load to MM servers.\n     * @param quotes the raw quotes from the makers. For RFQm the raw quote already include gas fee.\n     * @param fees fees to incorporate into the quote - amount in base unit of fee token. For RFQm this will be the amount other than\n     * gas fee.\n     * @param quoteContext context of quote request.\n     * @returns revised quotes.\n     */\n    public async reviseQuotesAsync(\n        quotes: IndicativeQuote[],\n        fees: BigNumber,\n        quoteContext: QuoteContext,\n    ): Promise<IndicativeQuote[]> {\n        if (fees.eq(ZERO)) {\n            return quotes;\n        }\n\n        const { isSelling, makerToken, takerToken, makerTokenDecimals, takerTokenDecimals } = quoteContext;\n\n        // `quoteToken` is one of `makerToken` and `takerToken` whose amount is specified by makers in the quotes.\n        const quoteToken = isSelling ? makerToken : takerToken;\n        const quoteTokenDecimal = isSelling ? makerTokenDecimals : takerTokenDecimals;\n\n        const { feeTokenBaseUnitPriceUsd, tradeTokenBaseUnitPriceUsd: quoteTokenBaseUnitPriceUsd } =\n            await this._fetchTokenPricesAsync(quoteToken, quoteTokenDecimal);\n\n        if (feeTokenBaseUnitPriceUsd === null || quoteTokenBaseUnitPriceUsd === null) {\n            return quotes;\n        }\n\n        return quotes.map((quote) =>\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            reviseQuoteWithFees(quote, fees, isSelling, quoteTokenBaseUnitPriceUsd!, feeTokenBaseUnitPriceUsd!),\n        );\n    }\n\n    /**\n     * Calculate gas fee for all fee model versions, based on gas price query and gas estimation.\n     *\n     * @returns estimated gas fee with `gasOnly` details\n     */\n    private async _calculateGasFeeAsync(\n        quoteContext: QuoteContext,\n    ): Promise<FeeWithDetails & { details: GasOnlyFeeDetailsDeprecated }> {\n        const { workflow, takerToken, makerToken, isUnwrap, feeModelVersion } = quoteContext;\n\n        if (workflow === 'rfqt') {\n            const gasPrice = new BigNumber(0);\n            const gasFeeAmount = new BigNumber(0);\n            return {\n                amount: gasFeeAmount,\n                token: this._feeTokenMetadata.tokenAddress,\n                type: 'fixed',\n                details: {\n                    kind: 'gasOnly',\n                    feeModelVersion,\n                    gasFeeAmount,\n                    gasPrice,\n                },\n                breakdown: {},\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: null,\n                    feeTokenBaseUnitPriceUsd: null,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n            };\n        }\n\n        const gasPrice: BigNumber = await this.getGasPriceEstimationAsync();\n        const gasEstimate = calculateGasEstimate(makerToken, takerToken, 'otc', isUnwrap);\n        const gasFeeAmount = gasPrice.times(gasEstimate);\n\n        return {\n            amount: gasFeeAmount,\n            token: this._feeTokenMetadata.tokenAddress,\n            type: 'fixed',\n            details: {\n                kind: 'gasOnly',\n                feeModelVersion,\n                gasFeeAmount,\n                gasPrice,\n            },\n            breakdown: {\n                gas: {\n                    amount: gasFeeAmount,\n                    details: {\n                        gasPrice,\n                        estimatedGas: new BigNumber(gasEstimate),\n                    },\n                },\n            },\n            conversionRates: {\n                nativeTokenBaseUnitPriceUsd: null,\n                feeTokenBaseUnitPriceUsd: null,\n                takerTokenBaseUnitPriceUsd: null,\n                makerTokenBaseUnitPriceUsd: null,\n            },\n        };\n    }\n\n    /**\n     * Calculate fee with fee model v1, including gas fee and and zeroExFee. If token prices query\n     * is successful, zeroExFee will be based on trade size and `tradeSizeBps`. If not, `gasOnly` fee\n     * will be returned.\n     *\n     * @returns fee with `default` | `gasOnly` details\n     */\n    private async _calculateFeeV1Async(\n        quoteContext: QuoteContext,\n    ): Promise<FeeWithDetails & { details: DefaultFeeDetailsDeprecated | GasOnlyFeeDetailsDeprecated }> {\n        const {\n            workflow,\n            takerToken,\n            makerToken,\n            takerAmount,\n            makerAmount,\n            takerTokenDecimals,\n            makerTokenDecimals,\n            isSelling,\n            feeModelVersion,\n        } = quoteContext;\n\n        const { tradeSizeBps } = this._configManager.getFeeModelConfiguration(this._chainId, makerToken, takerToken);\n\n        // Select trade token so that `tradeTokenAmount` is known from quote request\n        const tradeToken = isSelling ? takerToken : makerToken;\n        const tradeTokenDecimals = isSelling ? takerTokenDecimals : makerTokenDecimals;\n        const tradeTokenAmount = isSelling ? takerAmount : makerAmount;\n\n        const [gasFee, { feeTokenBaseUnitPriceUsd, tradeTokenBaseUnitPriceUsd }] = await Promise.all([\n            this._calculateGasFeeAsync(quoteContext),\n            tradeSizeBps > 0\n                ? this._fetchTokenPricesAsync(tradeToken, tradeTokenDecimals)\n                : { tradeTokenBaseUnitPriceUsd: null, feeTokenBaseUnitPriceUsd: null },\n        ]);\n\n        const wasUnableToFetchTokenPrices: boolean =\n            tradeSizeBps > 0 && (feeTokenBaseUnitPriceUsd === null || tradeTokenBaseUnitPriceUsd === null);\n\n        if (wasUnableToFetchTokenPrices) {\n            return gasFee;\n        }\n\n        const zeroExFeeAmount =\n            tradeSizeBps > 0\n                ? calculateDefaultFeeAmount(\n                      // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                      tradeTokenAmount!,\n                      tradeSizeBps,\n                      tradeTokenBaseUnitPriceUsd,\n                      feeTokenBaseUnitPriceUsd,\n                  )\n                : ZERO;\n\n        logger.info(\n            {\n                gasFee,\n                feeTokenBaseUnitPriceUsd,\n                tradeTokenBaseUnitPriceUsd,\n                zeroExFeeAmount,\n            },\n            'Gas fee, token prices and 0x fee amount in `_calculateFeeV1Async`',\n        );\n\n        return {\n            type: 'fixed',\n            token: this._feeTokenMetadata.tokenAddress,\n            amount: gasFee.amount.plus(zeroExFeeAmount),\n            details: {\n                kind: 'default',\n                feeModelVersion,\n                gasFeeAmount: gasFee.amount,\n                gasPrice: gasFee.details.gasPrice,\n                zeroExFeeAmount,\n                tradeSizeBps,\n                feeTokenBaseUnitPriceUsd,\n                takerTokenBaseUnitPriceUsd: isSelling ? tradeTokenBaseUnitPriceUsd : null,\n                makerTokenBaseUnitPriceUsd: isSelling ? null : tradeTokenBaseUnitPriceUsd,\n            },\n            breakdown: {\n                // RFQ will not charge gas fee for RFQt as taker will pay it\n                gas: workflow === 'rfqt' ? undefined : gasFee.breakdown.gas,\n                zeroEx: {\n                    amount: zeroExFeeAmount,\n                    details: {\n                        kind: 'volume',\n                        tradeSizeBps,\n                    },\n                },\n            },\n            conversionRates: {\n                nativeTokenBaseUnitPriceUsd: feeTokenBaseUnitPriceUsd,\n                feeTokenBaseUnitPriceUsd,\n                takerTokenBaseUnitPriceUsd: isSelling ? tradeTokenBaseUnitPriceUsd : null,\n                makerTokenBaseUnitPriceUsd: isSelling ? null : tradeTokenBaseUnitPriceUsd,\n            },\n        };\n    }\n\n    /**\n     * Calculate fee with fee model v2, including gas fee and zeroExFee. If price improvement detection\n     * is successful, zeroExFee will be based on price improvement. If not:\n     *     * Fall back to `default` fee if maker query and token prices query are both successful.\n     *     * Fall back to `gasOnly` fee if either maker query and token prices query failed.\n     *\n     * @returns fee with `margin` (price improvement) | `default` | `gasOnly` details (legacy fee breakdown)\n     * and a breakdown including gas fee and zeroEx fee details.\n     */\n    private async _calculateFeeV2Async(\n        quoteContext: QuoteContext,\n        fetchMmQuotesAsync?: (quoteContext: QuoteContext, fee: Fee) => Promise<IndicativeQuote[]>,\n    ): Promise<CalculateFeeResponse> {\n        const {\n            workflow,\n            takerToken,\n            makerToken,\n            takerTokenDecimals,\n            makerTokenDecimals,\n            isSelling,\n            assetFillAmount,\n            feeModelVersion,\n        } = quoteContext;\n\n        if (workflow === 'rfqt') {\n            throw new Error(`Not implemented: price improvement based fee model for RFQt has not been implemented!`);\n        }\n\n        const { marginRakeRatio: rakeRatio, tradeSizeBps } = this._configManager.getFeeModelConfiguration(\n            this._chainId,\n            makerToken,\n            takerToken,\n        );\n\n        // `quoteToken` is one of `makerToken` and `takerToken` whose amount is specified by makers in the quotes.\n        const quoteToken = isSelling ? makerToken : takerToken;\n        const quoteTokenDecimal = isSelling ? makerTokenDecimals : takerTokenDecimals;\n\n        /**\n         * Send all queries in parallel. Bypass AMM query and token price query if rakeRatio > 0.\n         */\n        const [\n            { gasFee, quotes: quotesWithGasFee },\n            ammQuote,\n            { feeTokenBaseUnitPriceUsd, tradeTokenBaseUnitPriceUsd: quoteTokenBaseUnitPriceUsd },\n        ] = await Promise.all([\n            this._fetchGasFeeAndIndicativeQuotesAsync(quoteContext, fetchMmQuotesAsync),\n            rakeRatio > 0 ? this._zeroExApiClient.fetchAmmQuoteAsync(quoteContext) : null,\n            rakeRatio > 0\n                ? this._fetchTokenPricesAsync(quoteToken, quoteTokenDecimal)\n                : { feeTokenBaseUnitPriceUsd: null, tradeTokenBaseUnitPriceUsd: null },\n        ]);\n\n        const ammQuoteUniqueId = ammQuote?.decodedUniqueId;\n\n        // Get the best quote\n        const bestMakerQuoteWithGasFee = getBestQuote(\n            quotesWithGasFee,\n            isSelling,\n            takerToken,\n            makerToken,\n            assetFillAmount,\n            this._minExpiryDurationMs,\n        );\n\n        const wasUnableToFetchMakerQuote: boolean = bestMakerQuoteWithGasFee === null;\n        const wasUnableToFetchTokenPrices: boolean =\n            rakeRatio > 0 && (feeTokenBaseUnitPriceUsd === null || quoteTokenBaseUnitPriceUsd === null);\n        const wasUnableToFetchAmmQuote: boolean = rakeRatio > 0 && ammQuote === null;\n\n        let zeroExFeeAmount: BigNumber;\n        let feeWithDetails: FeeWithDetails;\n\n        if (wasUnableToFetchMakerQuote || wasUnableToFetchTokenPrices) {\n            /**\n             * If maker query or token prices query failed: fallback to `gasOnly` fee.\n             */\n            zeroExFeeAmount = ZERO;\n            feeWithDetails = gasFee;\n        } else if (wasUnableToFetchAmmQuote) {\n            /**\n             * If maker query and token price query are successful, but AMM query failed,\n             * fall back to `default` fee calculated with `tradeSizeBps`.\n             */\n            const quoteTokenAmount = isSelling\n                ? // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  bestMakerQuoteWithGasFee!.makerAmount\n                : // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  bestMakerQuoteWithGasFee!.takerAmount;\n            zeroExFeeAmount = calculateDefaultFeeAmount(\n                quoteTokenAmount,\n                tradeSizeBps,\n                quoteTokenBaseUnitPriceUsd,\n                feeTokenBaseUnitPriceUsd,\n            );\n\n            const details: DefaultFeeDetailsDeprecated = {\n                kind: 'default',\n                feeModelVersion,\n                gasFeeAmount: gasFee.amount,\n                gasPrice: gasFee.details.gasPrice,\n                zeroExFeeAmount,\n                tradeSizeBps,\n                feeTokenBaseUnitPriceUsd,\n                takerTokenBaseUnitPriceUsd: isSelling ? null : quoteTokenBaseUnitPriceUsd,\n                makerTokenBaseUnitPriceUsd: isSelling ? quoteTokenBaseUnitPriceUsd : null,\n            };\n\n            const breakdown: FeeBreakdown = {\n                gas: gasFee.breakdown.gas,\n                zeroEx: {\n                    amount: zeroExFeeAmount,\n                    details: {\n                        kind: 'volume',\n                        tradeSizeBps,\n                    },\n                },\n            };\n\n            const conversionRates: ConversionRates = {\n                nativeTokenBaseUnitPriceUsd: feeTokenBaseUnitPriceUsd,\n                feeTokenBaseUnitPriceUsd,\n                takerTokenBaseUnitPriceUsd: isSelling ? null : quoteTokenBaseUnitPriceUsd,\n                makerTokenBaseUnitPriceUsd: isSelling ? quoteTokenBaseUnitPriceUsd : null,\n            };\n\n            feeWithDetails = {\n                type: 'fixed',\n                token: this._feeTokenMetadata.tokenAddress,\n                amount: gasFee.amount.plus(zeroExFeeAmount),\n                details,\n                breakdown,\n                conversionRates,\n            };\n        } else {\n            /**\n             * If all queries are successful: return `priceImprovement` based fee, calculated from `priceImprovement` and `rakeRatio`.\n             */\n            const priceImprovement =\n                rakeRatio > 0\n                    ? calculatePriceImprovementAmount(\n                          // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                          bestMakerQuoteWithGasFee!,\n                          // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                          ammQuote!,\n                          isSelling,\n                          // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                          quoteTokenBaseUnitPriceUsd!,\n                          // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                          feeTokenBaseUnitPriceUsd!,\n                      )\n                    : ZERO;\n            zeroExFeeAmount = priceImprovement.times(rakeRatio).integerValue();\n\n            const details: MarginBasedFeeDetailsDeprecated = {\n                kind: 'margin',\n                feeModelVersion,\n                gasFeeAmount: gasFee.amount,\n                gasPrice: gasFee.details.gasPrice,\n                zeroExFeeAmount,\n                margin: priceImprovement, // legacy field name `margin`\n                marginRakeRatio: rakeRatio, // legacy field name `marginRakeRatio`\n                feeTokenBaseUnitPriceUsd,\n                takerTokenBaseUnitPriceUsd: isSelling ? null : quoteTokenBaseUnitPriceUsd,\n                makerTokenBaseUnitPriceUsd: isSelling ? quoteTokenBaseUnitPriceUsd : null,\n            };\n\n            const breakdown: FeeBreakdown = {\n                gas: gasFee.breakdown.gas,\n                zeroEx: {\n                    amount: zeroExFeeAmount,\n                    details: {\n                        kind: 'price_improvement',\n                        priceImprovement,\n                        rakeRatio,\n                    },\n                },\n            };\n\n            const conversionRates: ConversionRates = {\n                nativeTokenBaseUnitPriceUsd: feeTokenBaseUnitPriceUsd,\n                feeTokenBaseUnitPriceUsd,\n                takerTokenBaseUnitPriceUsd: isSelling ? null : quoteTokenBaseUnitPriceUsd,\n                makerTokenBaseUnitPriceUsd: isSelling ? quoteTokenBaseUnitPriceUsd : null,\n            };\n\n            feeWithDetails = {\n                type: 'fixed',\n                token: this._feeTokenMetadata.tokenAddress,\n                amount: zeroExFeeAmount.plus(gasFee.amount),\n                details,\n                breakdown,\n                conversionRates,\n            };\n        }\n\n        return {\n            feeWithDetails,\n            quotesWithGasFee,\n            ammQuoteUniqueId,\n        };\n    }\n\n    /**\n     * Internal method to fetch prices of tradingToken (either makerToken or takerToken) and feeToken.\n     */\n    private async _fetchTokenPricesAsync(\n        tradeToken: string,\n        tradeTokenDecimals: number,\n    ): Promise<{\n        tradeTokenBaseUnitPriceUsd: BigNumber | null;\n        feeTokenBaseUnitPriceUsd: BigNumber | null;\n    }> {\n        const [tradeTokenBaseUnitPriceUsd, feeTokenBaseUnitPriceUsd] =\n            await this._tokenPriceOracle.batchFetchTokenPriceAsync([\n                {\n                    chainId: this._chainId,\n                    tokenAddress: tradeToken,\n                    tokenDecimals: tradeTokenDecimals,\n                },\n                {\n                    chainId: this._chainId,\n                    tokenAddress: this._feeTokenMetadata.tokenAddress,\n                    tokenDecimals: this._feeTokenMetadata.decimals,\n                },\n            ]);\n\n        return {\n            tradeTokenBaseUnitPriceUsd,\n            feeTokenBaseUnitPriceUsd,\n        };\n    }\n\n    private async _fetchGasFeeAndIndicativeQuotesAsync(\n        quoteContext: QuoteContext,\n        fetchMmQuotesAsync?: (quoteContext: QuoteContext, fee: Fee) => Promise<IndicativeQuote[]>,\n    ): Promise<{\n        gasFee: FeeWithDetails;\n        quotes: IndicativeQuote[];\n    }> {\n        const gasFee = await this._calculateGasFeeAsync(quoteContext);\n        const quotes = fetchMmQuotesAsync === undefined ? [] : await fetchMmQuotesAsync(quoteContext, gasFee);\n\n        return {\n            gasFee,\n            quotes,\n        };\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts",{"fileContent":"import { Counter } from 'prom-client';\n\nimport { ONE_SECOND_MS } from '../core/constants';\nimport { logger } from '../logger';\nimport { FirmOtcQuote, IndicativeQuote } from '../core/types';\n\nimport { toPairString } from '../core/pair_utils';\nimport { BigNumber } from '@0x/utils';\nimport { V4RFQIndicativeQuote } from '../quote-server/types';\n\nconst RFQM_MAKER_BLOCKED_FOR_LOW_MAKER_BALANCE = new Counter({\n    name: 'rfqm_maker_blocked_for_low_maker_balance',\n    help: 'A maker get blocked because of low maker balance',\n    labelNames: ['maker_uri', 'chain_id', 'pair_key'],\n});\n\n/**\n * Selects the best quote from an array of quotes.\n *\n * Ignores quotes that:\n *  - are for the wrong pair\n *  - cannot fill 100% of the requested amount\n *  - expire in less than the validity window\n *  - cannot be filled by the maker due to insufficient balances, if quotedMakerBalances is present\n *      (only for firm quotes)\n *\n * And selects the one with the best price.\n */\nexport function getBestQuote<T extends IndicativeQuote | FirmOtcQuote>(\n    quotes: T[],\n    isSelling: boolean,\n    takerToken: string,\n    makerToken: string,\n    assetFillAmount: BigNumber,\n    validityWindowMs: number,\n    quotedMakerBalances?: BigNumber[],\n): T | null {\n    // If maker balances are provided, quotes in which maker addresses cannot provide sufficient\n    // balances to fully fill the order are filtered out\n    let isMakerFillablePredicate = (_q: T, _idx: number) => true;\n    if (quotedMakerBalances) {\n        if (quotes.length !== quotedMakerBalances.length) {\n            throw new Error('Quotes do not match with provided maker balances');\n        }\n        isMakerFillablePredicate = (q: T, idx: number) => {\n            if (isFirmQuote(q) && q.order.makerAmount.gt(quotedMakerBalances[idx])) {\n                RFQM_MAKER_BLOCKED_FOR_LOW_MAKER_BALANCE.labels(\n                    q.makerUri,\n                    q.order.chainId.toString(),\n                    toPairString(getMakerToken(q), getTakerToken(q)),\n                ).inc();\n                logger.warn(\n                    {\n                        maker: q.makerUri,\n                        makerBalance: quotedMakerBalances[idx],\n                        order: q.order,\n                    },\n                    'Quote has insufficient maker balance',\n                );\n                return false;\n            }\n            return true;\n        };\n    }\n\n    const validityWindowSeconds = validityWindowMs / ONE_SECOND_MS;\n    const sortedQuotes = quotes\n        .filter(isMakerFillablePredicate)\n        .filter((q) => getTakerToken(q) === takerToken && getMakerToken(q) === makerToken)\n        .filter((q) => {\n            const requestedAmount = isSelling ? getTakerAmount(q) : getMakerAmount(q);\n            return requestedAmount.eq(assetFillAmount);\n        })\n        .filter((q) => !willQuoteExpireIn(q, validityWindowSeconds))\n        .sort((a, b) => {\n            // Want the most amount of maker tokens for each taker token\n            const aPrice = getMakerAmount(a).div(getTakerAmount(a));\n            const bPrice = getMakerAmount(b).div(getTakerAmount(b));\n            return bPrice.minus(aPrice).toNumber();\n        });\n\n    // No quotes found\n    if (sortedQuotes.length === 0) {\n        return null;\n    }\n\n    // Get the best quote\n    return sortedQuotes[0];\n}\n\n/// Private getter functions\n\nconst getTakerToken = (quote: V4RFQIndicativeQuote | FirmOtcQuote): string => {\n    return isFirmQuote(quote) ? quote.order.takerToken : quote.takerToken;\n};\n\nconst getMakerToken = (quote: V4RFQIndicativeQuote | FirmOtcQuote): string => {\n    return isFirmQuote(quote) ? quote.order.makerToken : quote.makerToken;\n};\n\nconst getTakerAmount = (quote: V4RFQIndicativeQuote | FirmOtcQuote): BigNumber => {\n    return isFirmQuote(quote) ? quote.order.takerAmount : quote.takerAmount;\n};\n\nconst getMakerAmount = (quote: V4RFQIndicativeQuote | FirmOtcQuote): BigNumber => {\n    return isFirmQuote(quote) ? quote.order.makerAmount : quote.makerAmount;\n};\n\nconst willQuoteExpireIn = (quote: V4RFQIndicativeQuote | FirmOtcQuote, secondsFromNow: number): boolean => {\n    if (isFirmQuote(quote)) {\n        return quote.order.willExpire(secondsFromNow);\n    }\n\n    // Handle indicative quote\n    const nowSeconds = new BigNumber(Date.now()).div(ONE_SECOND_MS);\n    const expirationCutoff = nowSeconds.plus(secondsFromNow);\n    return quote.expiry.lt(expirationCutoff);\n};\n\nconst isFirmQuote = (quote: V4RFQIndicativeQuote | FirmOtcQuote): quote is FirmOtcQuote => {\n    return (quote as FirmOtcQuote).order !== undefined;\n};\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts",{"fileContent":"import { RFQM_TX_GAS_ESTIMATE, RFQM_TX_OTC_ORDER_GAS_ESTIMATE } from '../core/constants';\n\n// ERC-20 tokens implement their own `transfer` and `transferFrom` functions, resulting in\n// different gas amounts used. These premia allow us to better estimate the gas each token uses\n// NOTE: Addresses must be in lower case\nconst TOKEN_GAS_PREMIUM: Record<string, number> = {\n    // Mainnet\n    /* 1INCH  */ '0x111111111117dc0aa78b770fa6a738034120c302': 6e3,\n    /* AAVE   */ '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9': 160e3,\n    /* BADGER */ '0x3472a5a71965499acd81997a54bba8d852c6e53d': 100e3,\n    /* DOUGH  */ '0xad32a8e6220741182940c5abf610bde99e737b2d': 100e3,\n    /* DYDX   */ '0x92d6c1e31e14520e676a687f0a93788b716beff5': 140e3,\n    /* ENS    */ '0xc18360217d8f7ab5e7c516566761ea12ce7f9d72': 40e3,\n    /* HOPR   */ '0xf5581dfefd8fb0e4aec526be659cfab1f8c781da': 70e3,\n    /* LDO    */ '0x5a98fcbea516cf06857215779fd812ca3bef1b32': 100e3,\n    /* LINK   */ '0x514910771af9ca656af840dff83e8264ecf986ca': 15e3,\n    /* OCEAN  */ '0x967da4048cd07ab37855c090aaf366e4ce1b9f48': 15e3,\n    /* SHIB   */ '0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce': 15e3,\n    /* SNX    */ '0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f': 70e3,\n    /* UMA    */ '0x04fa0d235c4abf4bcf4787af4cf447de572ef828': 75e3,\n    /* UNI    */ '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984': 10e3,\n    /* USDC   */ '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': 25e3,\n    /* USDT   */ '0xdac17f958d2ee523a2206206994597c13d831ec7': 20e3,\n    /* YFI    */ '0x0bc529c00c6401aef6d220be8c6ea1667f6ad93e': 10e3,\n\n    // Polygon\n    /* USDC   */ '0x2791bca1f2de4661ed88a30c99a7a9449aa84174': 15e3,\n    /* USDT   */ '0xc2132d05d31c914a87c6611c10748aeb04b58e8f': 15e3,\n    /* WETH   */ '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619': 15e3,\n    /* WBTC   */ '0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6': 15e3,\n    /* DAI    */ '0x8f3cf7ad23cd3cadbd9735aff958023239c6a063': 15e3,\n    /* AAVE   */ '0xd6df932a45c0f255f85145f286ea0b292b21c90b': 15e3,\n    /* LINK   */ '0xb0897686c545045afc77cf20ec7a532e3120e0f1': 15e3,\n    /* LINK   */ '0x53e0bca35ec356bd5dddfebbd1fc0fd03fabad39': 15e3, // lol, yes, there are two LINK tokens on Polygon\n    /* SHIB   */ '0x6f8a06447ff6fcf75d803135a7de15ce88c1d4ec': 15e3,\n};\n\n// If the buy token is native, an unwrap operation is needed which cost us additional gas.\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n// eslint-disable-next-line @typescript-eslint/no-inferrable-types\nconst UNWRAP_PREMIUM: number = 6e3;\n\n/**\n * Prepares the gas estimate for an RFQM trade\n */\nexport function calculateGasEstimate(\n    makerToken: string,\n    takerToken: string,\n    orderType: 'rfq' | 'otc',\n    isUnwrap: boolean,\n): number {\n    const makerTokenPremium: number = TOKEN_GAS_PREMIUM[makerToken.toLowerCase()] || 0;\n    const takerTokenPremium: number = TOKEN_GAS_PREMIUM[takerToken.toLowerCase()] || 0;\n    const unwrapPremium: number = isUnwrap ? UNWRAP_PREMIUM : 0;\n    const baseGas = orderType === 'otc' ? RFQM_TX_OTC_ORDER_GAS_ESTIMATE : RFQM_TX_GAS_ESTIMATE;\n\n    return baseGas + makerTokenPremium + takerTokenPremium + unwrapPremium;\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts",{"fileContent":"// tslint:disable:max-file-line-count\nimport { TooManyRequestsError } from '@0x/api-utils';\nimport { AssetSwapperContractAddresses } from '@0x/asset-swapper';\nimport { OtcOrder, ZERO } from '@0x/protocol-utils';\nimport {\n    getTokenMetadataIfExists,\n    nativeTokenSymbol,\n    nativeWrappedTokenSymbol,\n    TokenMetadata,\n} from '@0x/token-metadata';\nimport { BigNumber } from '@0x/utils';\nimport { Web3Wrapper } from '@0x/web3-wrapper';\nimport { retry } from '@lifeomic/attempt';\nimport { Producer as KafkaProducer } from 'kafkajs';\nimport * as _ from 'lodash';\nimport { Counter } from 'prom-client';\nimport { Producer } from 'sqs-producer';\n\nimport { ENABLE_LLR_COOLDOWN, RFQM_MAINTENANCE_MODE } from '../config';\nimport { GASLESS_OTC_ORDER_NUM_BUCKETS, NULL_ADDRESS, ONE_SECOND_MS } from '../core/constants';\nimport { MetaTransactionSubmissionEntity, RfqmV2TransactionSubmissionEntity } from '../entities';\nimport { RfqmV2JobApprovalOpts, RfqmV2JobConstructorOpts } from '../entities/RfqmV2JobEntity';\nimport {\n    JobFailureReason,\n    RfqmJobStatus,\n    RfqmTransactionSubmissionStatus,\n    RfqmTransactionSubmissionType,\n} from '../entities/types';\nimport { REASON_ON_STATUS_ERROR_RESPONSE_ENABLED } from '../config';\nimport { InternalServerError, NotFoundError, ValidationError, ValidationErrorCodes } from '../core/errors';\nimport { logger } from '../logger';\nimport { feeToStoredFee } from '../core/fee_utils';\nimport { toPairString } from '../core/pair_utils';\nimport {\n    Eip712DataField,\n    ExecuteMetaTransactionApproval,\n    ExecuteMetaTransactionEip712Context,\n    Fee,\n    FeeModelVersion,\n    FirmOtcQuote,\n    GaslessApprovalTypes,\n    GaslessTypes,\n    IndicativeQuote,\n    PermitApproval,\n    PermitEip712Context,\n} from '../core/types';\nimport { CacheClient } from '../utils/cache_client';\nimport { getBestQuote } from '../utils/quote_comparison_utils';\nimport { ExtendedQuoteReport, quoteReportUtils } from '../utils/quote_report_utils';\nimport { QuoteServerClient } from '../utils/quote_server_client';\nimport { otcOrderToStoredOtcOrder, RfqmDbUtils } from '../utils/rfqm_db_utils';\nimport { computeHealthCheckAsync, HealthCheckResult } from '../utils/rfqm_health_check';\nimport { RfqBlockchainUtils } from '../utils/rfq_blockchain_utils';\nimport { RfqMakerManager } from '../utils/rfq_maker_manager';\nimport { getSignerFromHash, padSignature } from '../utils/signature_utils';\nimport { TokenMetadataManager } from '../utils/TokenMetadataManager';\n\nimport { FeeService } from './fee_service';\nimport { RfqMakerBalanceCacheService } from './rfq_maker_balance_cache_service';\nimport {\n    ApprovalResponse,\n    FetchFirmQuoteParams,\n    FetchIndicativeQuoteParams,\n    FetchIndicativeQuoteResponse,\n    OtcOrderRfqmQuoteResponse,\n    OtcOrderSubmitRfqmSignedQuoteParams,\n    OtcOrderSubmitRfqmSignedQuoteResponse,\n    QuoteContext,\n    StatusResponse,\n    SubmitApprovalParams,\n    SubmitRfqmSignedQuoteWithApprovalParams,\n    SubmitRfqmSignedQuoteWithApprovalResponse,\n    TransactionDetails,\n} from './types';\nimport { MarketOperation } from '@0x/types';\n\nconst RFQM_QUOTE_INSERTED = new Counter({\n    name: 'rfqm_quote_inserted',\n    help: 'An RfqmQuote was inserted in the DB',\n    labelNames: ['apiKey', 'integratorId', 'makerUri'],\n});\n\nconst RFQM_SIGNED_QUOTE_NOT_FOUND = new Counter({\n    name: 'rfqm_signed_quote_not_found',\n    labelNames: ['chain_id'],\n    help: 'A submitted quote did not match any stored quotes',\n});\nconst RFQM_TAKER_AND_TAKERTOKEN_TRADE_EXISTS = new Counter({\n    name: 'rfqm_signed_quote_taker_and_takertoken_trade_exists',\n    labelNames: ['chain_id'],\n    help: 'A trade was submitted when the system already had a pending trade for the same taker and takertoken',\n});\nconst RFQM_SUBMIT_BALANCE_CHECK_FAILED = new Counter({\n    name: 'rfqm_submit_balance_check_failed',\n    labelNames: ['makerAddress', 'chain_id'],\n    help: 'A trade was submitted but our on-chain balance check failed',\n});\n\nconst RFQM_MAKER_BLOCKED_FOR_LLR_COOLDOWN = new Counter({\n    name: 'rfqm_maker_blocked_for_llr_cooldown',\n    help: 'A maker get blocked because of LLR cooldown',\n    labelNames: ['maker_id', 'chain_id', 'pair_key'],\n});\n\nconst RFQM_MM_RETURNED_DIFFERENT_AMOUNT = new Counter({\n    name: 'rfqm_mm_returned_different_amount_total',\n    help: 'A maker responded a quote with different amount than requested',\n    labelNames: ['maker_uri', 'chain_id', 'modification_type'],\n});\n\nconst PRICE_DECIMAL_PLACES = 6;\n\nconst getTokenAddressFromSymbol = (symbol: string, chainId: number): string => {\n    return (getTokenMetadataIfExists(symbol, chainId) as TokenMetadata).tokenAddress;\n};\n\n/**\n * RfqmService is the coordination layer for HTTP based RFQM flows.\n */\nexport class RfqmService {\n    private readonly _nativeTokenAddress: string;\n    private readonly _nativeTokenSymbol: string;\n    private readonly _nativeWrappedTokenSymbol: string;\n    private readonly _nativeWrappedTokenAddress: string;\n\n    private static _getSellAmountGivenBuyAmountAndQuote(\n        buyAmount: BigNumber,\n        quotedTakerAmount: BigNumber,\n        quotedMakerAmount: BigNumber,\n    ): BigNumber {\n        // Solving for x given the following proportion:\n        // x / buyAmount = quotedTakerAmount / quotedMakerAmount\n        return quotedTakerAmount.div(quotedMakerAmount).times(buyAmount).decimalPlaces(0);\n    }\n\n    private static _getBuyAmountGivenSellAmountAndQuote(\n        sellAmount: BigNumber,\n        quotedTakerAmount: BigNumber,\n        quotedMakerAmount: BigNumber,\n    ): BigNumber {\n        // Solving for y given the following proportion:\n        // y / sellAmount =  quotedMakerAmount / quotedTakerAmount\n        return quotedMakerAmount.div(quotedTakerAmount).times(sellAmount).decimalPlaces(0);\n    }\n\n    /**\n     * Transform a transaction submission to type `TransactionDetails`.\n     *\n     * @returns Corresponding `TransactionDetails` or null if transaction hash is not available.\n     */\n    private static _transformTransactionSubmission(\n        transactionSubmission: Pick<\n            RfqmV2TransactionSubmissionEntity | MetaTransactionSubmissionEntity,\n            'createdAt' | 'transactionHash'\n        >,\n    ): TransactionDetails | null {\n        const { transactionHash: hash, createdAt } = transactionSubmission;\n        return hash ? { hash, timestamp: createdAt.getTime() } : null;\n    }\n\n    /**\n     * Get details of the successful transaction submission (there will only be one).\n     *\n     * @param opts Options object that contains:\n     *             - `hash`: The hash of the order or metatransaction.\n     *             - `type`: The type of the transaction submissions.\n     *             - `transactionSubmssions`: List of transaction submissions to filter.\n     * @returns The details (hash and timestamp) of the successful transaction submission.\n     * @throws - When the number of the successful transaction submission is not 1\n     *         - The successful transaction submission does not have transaction hash\n     */\n    private static _getSuccessfulTransactionSubmissionDetails(opts: {\n        hash: string;\n        type: RfqmTransactionSubmissionType;\n        transactionSubmssions: Pick<\n            RfqmV2TransactionSubmissionEntity | MetaTransactionSubmissionEntity,\n            'createdAt' | 'status' | 'transactionHash'\n        >[];\n    }): TransactionDetails {\n        const { hash, type, transactionSubmssions } = opts;\n        const successfulTransactionSubmissions = transactionSubmssions.filter(\n            (s) =>\n                s.status === RfqmTransactionSubmissionStatus.SucceededUnconfirmed ||\n                s.status === RfqmTransactionSubmissionStatus.SucceededConfirmed,\n        );\n        if (successfulTransactionSubmissions.length !== 1) {\n            throw new Error(\n                `Expected exactly one successful transaction submission of type ${type} for hash ${hash}; found ${successfulTransactionSubmissions.length}`,\n            );\n        }\n        const successfulTransactionSubmission = successfulTransactionSubmissions[0];\n        const successfulTransactionSubmissionDetails = this._transformTransactionSubmission(\n            successfulTransactionSubmission,\n        );\n        if (!successfulTransactionSubmissionDetails) {\n            throw new Error(`Successful transaction of type ${type} does not have a hash ${hash}`);\n        }\n\n        return successfulTransactionSubmissionDetails;\n    }\n\n    private static _jobFailureStatusToReason(failureStatus: RfqmJobStatus): JobFailureReason {\n        switch (failureStatus) {\n            case RfqmJobStatus.FailedEthCallFailed:\n                return JobFailureReason.TransactionSimulationFailed;\n            case RfqmJobStatus.FailedExpired:\n                return JobFailureReason.OrderExpired;\n            case RfqmJobStatus.FailedLastLookDeclined:\n                return JobFailureReason.LastLookDeclined;\n            case RfqmJobStatus.FailedSignFailed:\n                return JobFailureReason.MarketMakerSignatureError;\n            case RfqmJobStatus.FailedRevertedConfirmed:\n            case RfqmJobStatus.FailedRevertedUnconfirmed:\n                return JobFailureReason.TransactionReverted;\n            default:\n                return JobFailureReason.InternalError;\n        }\n    }\n\n    constructor(\n        private readonly _chainId: number,\n        private readonly _feeService: FeeService,\n        private readonly _feeModelVersion: FeeModelVersion,\n        private readonly _contractAddresses: AssetSwapperContractAddresses,\n        private readonly _registryAddress: string,\n        private readonly _blockchainUtils: RfqBlockchainUtils,\n        private readonly _dbUtils: RfqmDbUtils,\n        private readonly _sqsProducer: Producer,\n        private readonly _quoteServerClient: QuoteServerClient,\n        private readonly _minExpiryDurationMs: number,\n        private readonly _cacheClient: CacheClient,\n        private readonly _rfqMakerBalanceCacheService: RfqMakerBalanceCacheService,\n        private readonly _rfqMakerManager: RfqMakerManager,\n        private readonly _tokenMetadataManager: TokenMetadataManager,\n        private readonly _kafkaProducer?: KafkaProducer,\n        private readonly _quoteReportTopic?: string,\n    ) {\n        this._nativeTokenSymbol = nativeTokenSymbol(this._chainId);\n        this._nativeTokenAddress = getTokenAddressFromSymbol(this._nativeTokenSymbol, this._chainId);\n        this._nativeWrappedTokenSymbol = nativeWrappedTokenSymbol(this._chainId);\n        this._nativeWrappedTokenAddress = getTokenAddressFromSymbol(this._nativeWrappedTokenSymbol, this._chainId);\n    }\n\n    /**\n     * Passthrough to TokenMetadataManager's `getTokenDecimalsAsync` method\n     */\n    public async getTokenDecimalsAsync(tokenAddress: string): Promise<number> {\n        return this._tokenMetadataManager.getTokenDecimalsAsync(tokenAddress);\n    }\n\n    /**\n     * Fetch the best indicative quote available. Returns null if no valid quotes found\n     */\n    public async fetchIndicativeQuoteAsync(\n        params: FetchIndicativeQuoteParams,\n        extendedQuoteReportSubmissionBy: ExtendedQuoteReport['submissionBy'] = 'rfqm',\n    ): Promise<FetchIndicativeQuoteResponse | null> {\n        const affiliateAddress = params.affiliateAddress ?? params.integrator.affiliateAddress;\n\n        // Retrieve quote context\n        const quoteContext = this._retrieveQuoteContext({ ...params, affiliateAddress }, /* isFirm */ false);\n        const {\n            isFirm,\n            takerAmount,\n            makerAmount,\n            takerToken,\n            makerToken,\n            originalMakerToken,\n            takerTokenDecimals,\n            makerTokenDecimals,\n            takerAddress,\n            isSelling,\n            assetFillAmount,\n            integrator,\n        } = quoteContext;\n\n        // (Optimization) When `quotesWithGasFee` is returned, we can use this value and revise it, to avoid another fetch to MMs\n        const { feeWithDetails, quotesWithGasFee, ammQuoteUniqueId } = await this._feeService.calculateFeeAsync(\n            quoteContext,\n            this._fetchIndicativeQuotesAsync.bind(this),\n        );\n\n        // Calculate fees (other than gas fee) to charge MMs\n        const otherFeesAmount = feeWithDetails.amount.minus(feeWithDetails.details.gasFeeAmount);\n\n        const finalQuotes = quotesWithGasFee\n            ? await this._feeService.reviseQuotesAsync(quotesWithGasFee, otherFeesAmount, quoteContext)\n            : await this._fetchIndicativeQuotesAsync(quoteContext, feeWithDetails);\n\n        // (Quote Report) If otherFees > 0, then we \"revised\" the quotes from MMs. We want to save both the original quotes (aka intermediateQuotes) and the revised (finalQuotes)\n        const intermediateQuotes = quotesWithGasFee && otherFeesAmount.gt(ZERO) ? quotesWithGasFee : [];\n\n        // Get the best quote\n        const bestQuote = getBestQuote(\n            finalQuotes,\n            isSelling,\n            takerToken,\n            makerToken,\n            assetFillAmount,\n            this._minExpiryDurationMs,\n        );\n\n        const isLiquidityAvailable = bestQuote !== null;\n\n        // Quote Report\n        if (this._kafkaProducer) {\n            await quoteReportUtils.publishRFQMQuoteReportAsync(\n                {\n                    isFirmQuote: isFirm,\n                    taker: takerAddress,\n                    buyTokenAddress: originalMakerToken,\n                    sellTokenAddress: takerToken,\n                    buyAmount: makerAmount,\n                    sellAmount: takerAmount,\n                    integratorId: integrator?.integratorId,\n                    finalQuotes,\n                    intermediateQuotes,\n                    bestQuote,\n                    fee: feeToStoredFee(feeWithDetails),\n                    ammQuoteUniqueId,\n                    isLiquidityAvailable,\n                },\n                this._kafkaProducer,\n                this._quoteReportTopic,\n                extendedQuoteReportSubmissionBy,\n            );\n        }\n\n        // No quotes found\n        if (!isLiquidityAvailable) {\n            return null;\n        }\n\n        // Prepare the price\n        const makerAmountInUnit = Web3Wrapper.toUnitAmount(bestQuote.makerAmount, makerTokenDecimals);\n        const takerAmountInUnit = Web3Wrapper.toUnitAmount(bestQuote.takerAmount, takerTokenDecimals);\n        const price = isSelling ? makerAmountInUnit.div(takerAmountInUnit) : takerAmountInUnit.div(makerAmountInUnit);\n        // The way the BigNumber round down behavior (https://mikemcl.github.io/bignumber.js/#dp) works requires us\n        // to add 1 to PRICE_DECIMAL_PLACES in order to actually come out with the decimal places specified.\n        const roundedPrice = price.decimalPlaces(PRICE_DECIMAL_PLACES + 1, BigNumber.ROUND_DOWN);\n\n        // Prepare response\n        return {\n            price: roundedPrice,\n            gas: feeWithDetails.details.gasPrice,\n            buyAmount: bestQuote.makerAmount,\n            buyTokenAddress: originalMakerToken,\n            sellAmount: bestQuote.takerAmount,\n            sellTokenAddress: bestQuote.takerToken,\n            allowanceTarget: this._contractAddresses.exchangeProxy,\n        };\n    }\n\n    /**\n     * Fetch the best firm quote available, including a metatransaction. Returns null if no valid quotes found\n     */\n    public async fetchFirmQuoteAsync(\n        params: FetchFirmQuoteParams,\n        extendedQuoteReportSubmissionBy: ExtendedQuoteReport['submissionBy'] = 'rfqm',\n    ): Promise<{ quote: OtcOrderRfqmQuoteResponse | null; quoteReportId: string | null }> {\n        const affiliateAddress = params.affiliateAddress ?? params.integrator.affiliateAddress;\n        // Retrieve quote context\n        const quoteContext = this._retrieveQuoteContext({ ...params, affiliateAddress }, /* isFirm */ true);\n        const {\n            isFirm,\n            takerAmount,\n            makerAmount,\n            takerToken,\n            makerToken,\n            originalMakerToken,\n            takerTokenDecimals,\n            makerTokenDecimals,\n            takerAddress,\n            integrator,\n            isUnwrap,\n            isSelling,\n            assetFillAmount,\n        } = quoteContext;\n\n        // (Optimization) When `quotesWithGasFee` is returned, we can sometimes reuse it, to avoid another fetch to MMs\n        // NOTE: this optimization differs from the optimization for indicative quotes because we do NOT revise firm quotes\n        const { feeWithDetails, quotesWithGasFee, ammQuoteUniqueId } = await this._feeService.calculateFeeAsync(\n            quoteContext,\n            this._fetchIndicativeQuotesAsync.bind(this),\n        );\n\n        // Calculate fees (other than gas fee) to charge MMs. If there are other fees, we don't reuse `quotesWithGasFee`\n        const otherFeesAmount = feeWithDetails.amount.minus(feeWithDetails.details.gasFeeAmount);\n\n        // If `quotesWithGasFee` have been obtained and there are no other fees, reuse the quotes. Otherwise call MMs with full fee to get new quotes.\n        const finalQuotes =\n            quotesWithGasFee && otherFeesAmount.eq(ZERO)\n                ? await this._convertToFirmQuotesAsync(quotesWithGasFee, quoteContext)\n                : await this._fetchFirmQuotesAsync(quoteContext, feeWithDetails);\n\n        // (Quote Report) If `quotesWithGasFee` have not been reused, save them as intermediate quotes\n        const intermediateQuotes = quotesWithGasFee && otherFeesAmount.gt(ZERO) ? quotesWithGasFee : [];\n\n        // (Maker Balance Cache) Fetch maker balances to validate whether quotes are fully fillable\n        let quotedMakerBalances: BigNumber[] | undefined;\n        const quotedERC20Owners = finalQuotes.map((quote) => {\n            return {\n                owner: quote.order.maker,\n                token: makerToken,\n            };\n        });\n        try {\n            quotedMakerBalances = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(\n                this._chainId,\n                quotedERC20Owners,\n            );\n        } catch (e) {\n            logger.error(\n                { chainId: this._chainId, quotedERC20Owners, errorMessage: e.message },\n                'Failed to fetch maker balances to validate firm quotes',\n            );\n        }\n\n        // Get the best quote\n        const bestQuote = getBestQuote(\n            finalQuotes,\n            isSelling,\n            takerToken,\n            makerToken,\n            assetFillAmount,\n            this._minExpiryDurationMs,\n            quotedMakerBalances,\n        );\n\n        const isLiquidityAvailable = bestQuote !== null;\n\n        const storedFeeWithDetails = feeToStoredFee(feeWithDetails);\n\n        let quoteReportId: string | null = null;\n        // Quote Report\n        if (this._kafkaProducer) {\n            quoteReportId = await quoteReportUtils.publishRFQMQuoteReportAsync(\n                {\n                    isFirmQuote: isFirm,\n                    taker: takerAddress,\n                    buyTokenAddress: originalMakerToken,\n                    sellTokenAddress: takerToken,\n                    buyAmount: makerAmount,\n                    sellAmount: takerAmount,\n                    integratorId: integrator?.integratorId,\n                    finalQuotes,\n                    intermediateQuotes,\n                    bestQuote,\n                    fee: storedFeeWithDetails,\n                    ammQuoteUniqueId,\n                    isLiquidityAvailable,\n                },\n                this._kafkaProducer,\n                this._quoteReportTopic,\n                extendedQuoteReportSubmissionBy,\n            );\n        }\n\n        // No quote found\n        if (!isLiquidityAvailable) {\n            return { quote: null, quoteReportId };\n        }\n\n        // Get the makerUri\n        const makerUri = bestQuote.makerUri;\n        if (makerUri === undefined) {\n            logger.error({ makerAddress: bestQuote.order.maker }, 'makerUri unknown for maker address');\n            throw new Error(`makerUri unknown for maker address ${bestQuote.order.maker}`);\n        }\n\n        // Prepare the price\n        const makerAmountInUnit = Web3Wrapper.toUnitAmount(bestQuote.order.makerAmount, makerTokenDecimals);\n        const takerAmountInUnit = Web3Wrapper.toUnitAmount(bestQuote.order.takerAmount, takerTokenDecimals);\n        const price = isSelling ? makerAmountInUnit.div(takerAmountInUnit) : takerAmountInUnit.div(makerAmountInUnit);\n        // The way the BigNumber round down behavior (https://mikemcl.github.io/bignumber.js/#dp) works requires us\n        // to add 1 to PRICE_DECIMAL_PLACES in order to actually come out with the decimal places specified.\n        const roundedPrice = price.decimalPlaces(PRICE_DECIMAL_PLACES + 1, BigNumber.ROUND_DOWN);\n\n        // Prepare the final takerAmount and makerAmount\n        const sellAmount = isSelling\n            ? // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              takerAmount!\n            : RfqmService._getSellAmountGivenBuyAmountAndQuote(\n                  // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  makerAmount!,\n                  bestQuote.order.takerAmount,\n                  bestQuote.order.makerAmount,\n              );\n\n        const buyAmount = isSelling\n            ? RfqmService._getBuyAmountGivenSellAmountAndQuote(\n                  // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  takerAmount!,\n                  bestQuote.order.takerAmount,\n                  bestQuote.order.makerAmount,\n              )\n            : // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              makerAmount!;\n\n        // Get the Order and its hash\n        const orderHash = bestQuote.order.getHash();\n\n        const otcOrder = bestQuote.order;\n        await this._dbUtils.writeV2QuoteAsync({\n            orderHash,\n            chainId: this._chainId,\n            fee: storedFeeWithDetails,\n            order: otcOrderToStoredOtcOrder(otcOrder),\n            makerUri,\n            affiliateAddress,\n            integratorId: integrator.integratorId,\n            isUnwrap,\n            takerSpecifiedSide: params.sellAmount ? 'takerToken' : 'makerToken',\n        });\n\n        const approval = params.checkApproval\n            ? // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              await this.getGaslessApprovalResponseAsync(takerAddress!, takerToken, sellAmount)\n            : null;\n\n        RFQM_QUOTE_INSERTED.labels(integrator.integratorId, integrator.integratorId, makerUri).inc();\n        return {\n            quote: {\n                type: GaslessTypes.OtcOrder,\n                price: roundedPrice,\n                gas: feeWithDetails.details.gasPrice,\n                buyAmount,\n                buyTokenAddress: originalMakerToken,\n                sellAmount,\n                sellTokenAddress: bestQuote.order.takerToken,\n                allowanceTarget: this._contractAddresses.exchangeProxy,\n                order: bestQuote.order,\n                orderHash,\n                // use approval variable directly is not ideal as we don't want to include approval field if `approval` is null\n                ...(approval && { approval }),\n            },\n            quoteReportId,\n        };\n    }\n\n    /**\n     * Get the value of the approval response in firm quote responses. The approval response contains whether an approval is required, is gasless approval\n     * is available for the token (optional), the type of the gasless approval (optional) and the EIP712 context (optional).\n     *\n     * @param takerAddress The address of the taker.\n     * @param tokenToApprove Token address to be approved.\n     * @param sellAmount Amount of token to sell in base unit.\n     * @returns The approval response.\n     */\n    public async getGaslessApprovalResponseAsync(\n        takerAddress: string,\n        tokenToApprove: string,\n        sellAmount: BigNumber,\n    ): Promise<ApprovalResponse> {\n        const allowance = await this._blockchainUtils.getAllowanceAsync(\n            tokenToApprove,\n            takerAddress,\n            this._blockchainUtils.getExchangeProxyAddress(),\n        );\n        const isRequired = allowance.lte(sellAmount);\n        if (!isRequired) {\n            return {\n                isRequired,\n            };\n        }\n\n        const gaslessApproval = await this._blockchainUtils.getGaslessApprovalAsync(\n            this._chainId,\n            tokenToApprove,\n            takerAddress,\n        );\n        const isGaslessAvailable = gaslessApproval !== null;\n        if (!isGaslessAvailable) {\n            return {\n                isRequired,\n                isGaslessAvailable,\n            };\n        }\n\n        return {\n            isRequired,\n            isGaslessAvailable,\n            type: gaslessApproval.kind,\n            eip712: gaslessApproval.eip712,\n        };\n    }\n\n    public async getStatusAsync(tradeHash: string): Promise<StatusResponse | null> {\n        const transformSubmissions = (\n            submissions: RfqmV2TransactionSubmissionEntity[] | MetaTransactionSubmissionEntity[],\n        ) => {\n            // `_transformTransactionSubmission` is a static method so no-unbound-method does not apply here\n            // tslint:disable-next-line:no-unbound-method\n            return submissions.map(RfqmService._transformTransactionSubmission).flatMap((s) => (s ? s : []));\n        };\n\n        const job = await Promise.all([\n            this._dbUtils.findV2JobByOrderHashAsync(tradeHash),\n            this._dbUtils.findMetaTransactionJobByMetaTransactionHashAsync(tradeHash),\n        ]).then((jobs) => jobs.find((x) => x));\n\n        if (!job) {\n            return null;\n        }\n\n        const { status, expiry } = job;\n\n        if (status === RfqmJobStatus.PendingEnqueued && expiry.multipliedBy(ONE_SECOND_MS).lt(Date.now())) {\n            // the workers are dead/on vacation and the expiration time has passed\n            return {\n                status: 'failed',\n                transactions: [],\n                ...(REASON_ON_STATUS_ERROR_RESPONSE_ENABLED && {\n                    reason: JobFailureReason.OrderExpired,\n                }),\n            };\n        }\n\n        const tradeTransactionSubmissions =\n            job.kind === 'rfqm_v2_job'\n                ? await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                      job.orderHash,\n                      RfqmTransactionSubmissionType.Trade,\n                  )\n                : await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(\n                      job.id,\n                      RfqmTransactionSubmissionType.Trade,\n                  );\n        const shouldIncludeApproval = !!job.approval;\n        let approvalTransactionSubmissions: RfqmV2TransactionSubmissionEntity[] | MetaTransactionSubmissionEntity[] =\n            [];\n        if (shouldIncludeApproval) {\n            approvalTransactionSubmissions =\n                job.kind === 'rfqm_v2_job'\n                    ? await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                          job.orderHash,\n                          RfqmTransactionSubmissionType.Approval,\n                      )\n                    : await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(\n                          job.id,\n                          RfqmTransactionSubmissionType.Approval,\n                      );\n        }\n\n        switch (status) {\n            case RfqmJobStatus.PendingEnqueued:\n            case RfqmJobStatus.PendingProcessing:\n            case RfqmJobStatus.PendingLastLookAccepted:\n                return { status: 'pending', transactions: [] };\n            case RfqmJobStatus.PendingSubmitted:\n                return {\n                    status: 'submitted',\n                    transactions: transformSubmissions(tradeTransactionSubmissions),\n                    ...(shouldIncludeApproval && {\n                        approvalTransactions: transformSubmissions(approvalTransactionSubmissions),\n                    }),\n                };\n            case RfqmJobStatus.FailedEthCallFailed:\n            case RfqmJobStatus.FailedExpired:\n            case RfqmJobStatus.FailedLastLookDeclined:\n            case RfqmJobStatus.FailedPresignValidationFailed:\n            case RfqmJobStatus.FailedRevertedConfirmed:\n            case RfqmJobStatus.FailedRevertedUnconfirmed:\n            case RfqmJobStatus.FailedSignFailed:\n            case RfqmJobStatus.FailedSubmitFailed:\n            case RfqmJobStatus.FailedValidationNoCallData:\n            case RfqmJobStatus.FailedValidationNoFee:\n            case RfqmJobStatus.FailedValidationNoMakerUri:\n            case RfqmJobStatus.FailedValidationNoOrder:\n            case RfqmJobStatus.FailedValidationNoTakerSignature:\n                return {\n                    status: 'failed',\n                    transactions: transformSubmissions(tradeTransactionSubmissions),\n                    ...(shouldIncludeApproval && {\n                        approvalTransactions: transformSubmissions(approvalTransactionSubmissions),\n                    }),\n                    ...(REASON_ON_STATUS_ERROR_RESPONSE_ENABLED && {\n                        reason: RfqmService._jobFailureStatusToReason(status),\n                    }),\n                };\n            case RfqmJobStatus.SucceededConfirmed:\n            case RfqmJobStatus.SucceededUnconfirmed:\n                return {\n                    status: status === RfqmJobStatus.SucceededUnconfirmed ? 'succeeded' : 'confirmed',\n                    transactions: [\n                        RfqmService._getSuccessfulTransactionSubmissionDetails({\n                            hash: job.getHash(),\n                            type: RfqmTransactionSubmissionType.Trade,\n                            transactionSubmssions: tradeTransactionSubmissions,\n                        }),\n                    ],\n                    ...(shouldIncludeApproval && {\n                        approvalTransactions: [\n                            RfqmService._getSuccessfulTransactionSubmissionDetails({\n                                hash: job.getHash(),\n                                type: RfqmTransactionSubmissionType.Approval,\n                                transactionSubmssions: approvalTransactionSubmissions,\n                            }),\n                        ],\n                    }),\n                };\n            default:\n                ((_x: never): never => {\n                    throw new Error('Unreachable');\n                })(status);\n        }\n    }\n\n    /**\n     * Runs checks to determine the health of the RFQm system. The results may be distilled to a format needed by integrators.\n     */\n    public async runHealthCheckAsync(): Promise<HealthCheckResult> {\n        const heartbeats = await this._dbUtils.findRfqmWorkerHeartbeatsAsync(this._chainId);\n        let gasPrice: BigNumber | undefined;\n        try {\n            gasPrice = await this._feeService.getGasPriceEstimationAsync();\n        } catch (error) {\n            logger.warn({ errorMessage: error.message }, 'Failed to get gas price for health check');\n        }\n        return computeHealthCheckAsync(\n            RFQM_MAINTENANCE_MODE,\n            this._rfqMakerManager.getRfqmV2MakerOfferings(),\n            this._sqsProducer,\n            heartbeats,\n            this._chainId,\n            gasPrice,\n        );\n    }\n\n    /**\n     * Validates and enqueues the Taker Signed Otc Order with approval for submission.\n     * Can also be used to submit order without approval if approval params are not supplied.\n     */\n    public async submitTakerSignedOtcOrderWithApprovalAsync<\n        T extends ExecuteMetaTransactionEip712Context | PermitEip712Context,\n    >(params: SubmitRfqmSignedQuoteWithApprovalParams<T>): Promise<SubmitRfqmSignedQuoteWithApprovalResponse> {\n        let submitRfqmSignedQuoteWithApprovalRes: SubmitRfqmSignedQuoteWithApprovalResponse;\n        const { approval, trade } = params;\n\n        const rfqmApprovalOpts = approval\n            ? await this.createApprovalAsync(approval, trade.order.getHash(), trade.order.takerToken)\n            : undefined;\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line prefer-const\n        submitRfqmSignedQuoteWithApprovalRes = await this.submitTakerSignedOtcOrderAsync(trade, rfqmApprovalOpts);\n\n        return submitRfqmSignedQuoteWithApprovalRes;\n    }\n\n    /**\n     * Processes a signed approval sent to the submission endpoint in order to\n     * create the approval data needed by the job.\n     */\n    public async createApprovalAsync<T extends ExecuteMetaTransactionEip712Context | PermitEip712Context>(\n        approval: SubmitApprovalParams<T>,\n        tradeHash: string,\n        takerToken: string,\n    ): Promise<RfqmV2JobApprovalOpts> {\n        let { signature } = approval;\n\n        // validate and convert EIP712 context to corresponding Approval object\n        const parsedApproval = this._convertEIP712ContextToApproval(approval.eip712, tradeHash);\n\n        // pad approval signature if there are missing bytes\n        const paddedSignature = padSignature(signature);\n        if (paddedSignature.r !== signature.r || paddedSignature.s !== signature.s) {\n            logger.warn(\n                { tradeHash, r: paddedSignature.r, s: paddedSignature.s },\n                'Got approval signature with missing bytes',\n            );\n            signature = paddedSignature;\n        }\n\n        // perform an eth_call on the approval object and signature\n        try {\n            const approvalCalldata = await this._blockchainUtils.generateApprovalCalldataAsync(\n                takerToken,\n                parsedApproval,\n                signature,\n            );\n            await retry(\n                async () => {\n                    // Use `estimateGasForAsync` to simulate the transaction. In ethers.js, provider.call and\n                    // provider.send('eth_call', ...) might not throw exception and the behavior might be dependent\n                    // on providers. Revisit this later\n                    return this._blockchainUtils.estimateGasForAsync({ to: takerToken, data: approvalCalldata });\n                },\n                {\n                    delay: ONE_SECOND_MS,\n                    factor: 1,\n                    maxAttempts: 3,\n                    handleError: (error, context, _options) => {\n                        const { attemptNum: attemptNumber, attemptsRemaining } = context;\n                        logger.warn(\n                            {\n                                attemptNumber,\n                                attemptsRemaining,\n                                errorMessage: error.message,\n                                stack: error.stack,\n                                tradeHash,\n                            },\n                            'Error during eth_call approval validation. Retrying.',\n                        );\n                    },\n                },\n            );\n        } catch (error) {\n            logger.error({ errorMessage: error.message }, 'Eth call approval validation failed');\n            throw new Error('Eth call approval validation failed');\n        }\n\n        return {\n            approval: parsedApproval,\n            approvalSignature: signature,\n        };\n    }\n\n    /**\n     * Validates and enqueues the Taker Signed Otc Order for submission\n     */\n    public async submitTakerSignedOtcOrderAsync(\n        params: OtcOrderSubmitRfqmSignedQuoteParams,\n        rfqmApprovalOpts?: RfqmV2JobApprovalOpts,\n    ): Promise<OtcOrderSubmitRfqmSignedQuoteResponse> {\n        const { order } = params;\n        let { signature: takerSignature } = params;\n        const orderHash = order.getHash();\n        const takerAddress = order.taker.toLowerCase();\n        const makerAddress = order.maker.toLowerCase();\n        const takerToken = order.takerToken.toLowerCase();\n        const makerToken = order.makerToken.toLowerCase();\n        // check that the orderHash is indeed a recognized quote\n        const quote = await this._dbUtils.findV2QuoteByOrderHashAsync(orderHash);\n        if (!quote) {\n            RFQM_SIGNED_QUOTE_NOT_FOUND.inc();\n            throw new NotFoundError('quote not found');\n        }\n\n        // validate that the expiration window is long enough to fill quote\n        const currentTimeMs = new Date().getTime();\n        if (!order.expiry.times(ONE_SECOND_MS).isGreaterThan(currentTimeMs + this._minExpiryDurationMs)) {\n            throw new ValidationError([\n                {\n                    field: 'expiryAndNonce',\n                    code: ValidationErrorCodes.FieldInvalid,\n                    reason: `order will expire too soon`,\n                },\n            ]);\n        }\n\n        // validate that there is not a pending transaction for this taker and taker token\n        const pendingJobs = await this._dbUtils.findV2JobsWithStatusesAsync([\n            RfqmJobStatus.PendingEnqueued,\n            RfqmJobStatus.PendingProcessing,\n            RfqmJobStatus.PendingLastLookAccepted,\n            RfqmJobStatus.PendingSubmitted,\n        ]);\n\n        if (\n            pendingJobs.some(\n                (job) =>\n                    job.order?.order.taker.toLowerCase() === quote.order?.order.taker.toLowerCase() &&\n                    job.order?.order.takerToken.toLowerCase() === quote.order?.order.takerToken.toLowerCase() &&\n                    // Other logic handles the case where the same order is submitted twice\n                    job.orderHash !== quote.orderHash,\n            )\n        ) {\n            RFQM_TAKER_AND_TAKERTOKEN_TRADE_EXISTS.labels(this._chainId.toString()).inc();\n            throw new TooManyRequestsError('a pending trade for this taker and takertoken already exists');\n        }\n\n        // In the unlikely event that takers submit a signature with a missing byte, pad the signature.\n        const paddedSignature = padSignature(takerSignature);\n        if (paddedSignature.r !== takerSignature.r || paddedSignature.s !== takerSignature.s) {\n            logger.warn(\n                { orderHash, r: paddedSignature.r, s: paddedSignature.s },\n                'Got taker signature with missing bytes',\n            );\n            takerSignature = paddedSignature;\n        }\n\n        // validate that the given taker signature is valid\n        const signerAddress = getSignerFromHash(orderHash, takerSignature).toLowerCase();\n        if (signerAddress !== takerAddress) {\n            logger.warn({ signerAddress, takerAddress, orderHash }, 'Signature is invalid');\n            throw new ValidationError([\n                {\n                    field: 'signature',\n                    code: ValidationErrorCodes.InvalidSignatureOrHash,\n                    reason: `signature is not valid`,\n                },\n            ]);\n        }\n\n        // Validate that order is fillable by both the maker and the taker according to balances and/or allowances.\n        // If rfqmApprovalOpts is not passed, allowances are not checked at this stage since gasless approval has not been done yet.\n        const [makerBalance] = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(this._chainId, [\n            {\n                owner: makerAddress,\n                token: makerToken,\n            },\n        ]);\n        const [takerBalance] = rfqmApprovalOpts\n            ? await this._blockchainUtils.getTokenBalancesAsync({ owner: takerAddress, token: takerToken })\n            : await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync({\n                  owner: takerAddress,\n                  token: takerToken,\n              });\n\n        if (makerBalance.lt(order.makerAmount) || takerBalance.lt(order.takerAmount)) {\n            RFQM_SUBMIT_BALANCE_CHECK_FAILED.labels(makerAddress, this._chainId.toString()).inc();\n            logger.warn(\n                {\n                    makerBalance,\n                    takerBalance,\n                    makerAddress,\n                    takerAddress,\n                    orderHash,\n                    order,\n                },\n                'Balance check failed while user was submitting',\n            );\n            throw new ValidationError([\n                {\n                    field: 'n/a',\n                    code: ValidationErrorCodes.InvalidOrder,\n                    reason: `order is not fillable`,\n                },\n            ]);\n        }\n\n        // prepare the job\n        let rfqmJobOpts: RfqmV2JobConstructorOpts = {\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            orderHash: quote.orderHash!,\n            createdAt: new Date(),\n            expiry: order.expiry,\n            chainId: this._chainId,\n            integratorId: quote.integratorId ? quote.integratorId : null,\n            makerUri: quote.makerUri,\n            status: RfqmJobStatus.PendingEnqueued,\n            fee: quote.fee,\n            order: quote.order,\n            takerSignature,\n            affiliateAddress: quote.affiliateAddress,\n            isUnwrap: quote.isUnwrap,\n            takerSpecifiedSide: quote.takerSpecifiedSide,\n        };\n\n        // if approval opts are supplied, add params to job table\n        if (rfqmApprovalOpts) {\n            rfqmJobOpts = {\n                ...rfqmJobOpts,\n                ...rfqmApprovalOpts,\n            };\n        }\n\n        // this insert will fail if a job has already been created, ensuring\n        // that a signed quote cannot be queued twice\n        try {\n            // make sure job data is persisted to Postgres before queueing task\n            await this._dbUtils.writeV2JobAsync(rfqmJobOpts);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            await this._enqueueJobAsync(quote.orderHash!, GaslessTypes.OtcOrder);\n        } catch (error) {\n            logger.error({ errorMessage: error.message }, 'Failed to queue the quote for submission.');\n            throw new InternalServerError(\n                `failed to queue the quote for submission, it may have already been submitted`,\n            );\n        }\n\n        return {\n            type: GaslessTypes.OtcOrder,\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            orderHash: quote.orderHash!,\n        };\n    }\n\n    /**\n     * Internal method to retrieve quote context, based on either indicative or firm quote parameters\n     */\n    private _retrieveQuoteContext(\n        params: FetchIndicativeQuoteParams | FetchFirmQuoteParams,\n        isFirm: boolean,\n    ): QuoteContext {\n        const {\n            sellAmount: takerAmount,\n            buyAmount: makerAmount,\n            sellToken: takerToken,\n            buyToken: originalMakerToken,\n            takerAddress,\n            sellTokenDecimals: takerTokenDecimals,\n            buyTokenDecimals: makerTokenDecimals,\n            integrator,\n            affiliateAddress,\n        } = params;\n\n        const isUnwrap = originalMakerToken === this._nativeTokenAddress;\n        const isSelling = takerAmount !== undefined;\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const assetFillAmount = isSelling ? takerAmount! : makerAmount!;\n\n        let makerToken = originalMakerToken;\n\n        // If the originalMakerToken is the native token, we will trade the wrapped version and unwrap at the end\n        if (isUnwrap) {\n            makerToken = this._nativeWrappedTokenAddress;\n        }\n\n        return {\n            workflow: 'rfqm',\n            chainId: this._chainId,\n            isFirm,\n            takerAmount,\n            makerAmount,\n            takerToken,\n            makerToken,\n            originalMakerToken,\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            takerAddress: takerAddress!,\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            trader: takerAddress!,\n            txOrigin: this._registryAddress,\n            takerTokenDecimals,\n            makerTokenDecimals,\n            integrator,\n            affiliateAddress,\n            isUnwrap,\n            isSelling,\n            assetFillAmount,\n            feeModelVersion: this._feeModelVersion,\n        };\n    }\n\n    /**\n     * Internal method to fetch indicative quotes.\n     */\n    private async _fetchIndicativeQuotesAsync(quoteContext: QuoteContext, fee: Fee): Promise<IndicativeQuote[]> {\n        // Extract quote context\n        const { isSelling, assetFillAmount, takerToken, makerToken, integrator } = quoteContext;\n\n        // Create Otc Order request options\n        const otcOrderParams = QuoteServerClient.makeQueryParameters({\n            chainId: this._chainId,\n            txOrigin: this._registryAddress,\n            takerAddress: NULL_ADDRESS,\n            marketOperation: isSelling ? MarketOperation.Sell : MarketOperation.Buy,\n            buyTokenAddress: makerToken,\n            sellTokenAddress: takerToken,\n            assetFillAmount,\n            isLastLook: true,\n            fee,\n        });\n\n        // If LLR Cooldown is enabled, filter out makers in cooldown before querying the quote server\n        let makerIdsInCooldown: string[] | undefined;\n        if (ENABLE_LLR_COOLDOWN) {\n            try {\n                makerIdsInCooldown = await this._cacheClient.getMakersInCooldownForPairAsync(\n                    this._chainId,\n                    makerToken,\n                    takerToken,\n                );\n                // log blocked maker ids\n                makerIdsInCooldown.map((makerId) => {\n                    RFQM_MAKER_BLOCKED_FOR_LLR_COOLDOWN.labels(\n                        makerId,\n                        this._chainId.toString(),\n                        toPairString(makerToken, takerToken),\n                    ).inc();\n                    logger.warn(\n                        {\n                            makerId,\n                            makerToken,\n                            takerToken,\n                            timestamp: Date.now(),\n                        },\n                        'Maker is on cooldown due to a bad last look reject',\n                    );\n                });\n            } catch (e) {\n                logger.error(\n                    { chainId: this._chainId, makerToken, takerToken, errorMessage: e.message },\n                    'Encountered an error while filtering makers on LLR cooldown',\n                );\n            }\n        }\n\n        const otcOrderMakerUris = this._rfqMakerManager.getRfqmV2MakerUrisForPair(\n            makerToken,\n            takerToken,\n            integrator.whitelistMakerIds || null,\n            makerIdsInCooldown || null,\n        );\n\n        logger.info(\n            {\n                otcOrderParams,\n            },\n            'otcOrderParams for `batchGetPriceV2Async`',\n        );\n        const quotes = await this._quoteServerClient.batchGetPriceV2Async(\n            otcOrderMakerUris,\n            integrator,\n            otcOrderParams,\n        );\n\n        // Log any quotes that are for the incorrect amount\n        quotes.forEach((quote) => {\n            const quotedAmount = isSelling ? quote.takerAmount : quote.makerAmount;\n            if (quotedAmount.eq(assetFillAmount)) {\n                return;\n            }\n            const modificationType = quotedAmount.gt(assetFillAmount) ? 'overfill' : 'underfill';\n            logger.warn(\n                {\n                    isSelling,\n                    overOrUnder: modificationType,\n                    requestedAmount: assetFillAmount,\n                    quotedAmount,\n                    quote,\n                },\n                'Maker returned an incorrect amount',\n            );\n            RFQM_MM_RETURNED_DIFFERENT_AMOUNT.labels(quote.makerUri, this._chainId.toString(), modificationType).inc();\n        });\n\n        return quotes;\n    }\n\n    /**\n     * Internal method to fetch firm quotes.\n     */\n    private async _fetchFirmQuotesAsync(quoteContext: QuoteContext, fee: Fee): Promise<FirmOtcQuote[]> {\n        const quotes = await this._fetchIndicativeQuotesAsync(quoteContext, fee);\n        return this._convertToFirmQuotesAsync(quotes, quoteContext);\n    }\n\n    /**\n     * Internal method to convert indicative quotes to firm quotes.\n     */\n    private async _convertToFirmQuotesAsync(\n        quotes: IndicativeQuote[],\n        quoteContext: QuoteContext,\n    ): Promise<FirmOtcQuote[]> {\n        const { takerAddress } = quoteContext;\n        const currentBucket =\n            (await this._cacheClient.getNextOtcOrderBucketAsync(this._chainId)) % GASLESS_OTC_ORDER_NUM_BUCKETS;\n        const nowSeconds = Math.floor(Date.now() / ONE_SECOND_MS);\n        const otcQuotes = quotes.map((q) =>\n            this._mapIndicativeQuoteToFirmOtcQuote(\n                q,\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                takerAddress!,\n                new BigNumber(currentBucket),\n                new BigNumber(nowSeconds),\n            ),\n        );\n\n        const firmQuotesWithCorrectChainId = otcQuotes.filter((quote) => {\n            if (quote.order.chainId !== this._chainId) {\n                logger.error({ quote }, 'Received a quote with incorrect chain id');\n                return false;\n            }\n            return true;\n        });\n\n        return firmQuotesWithCorrectChainId;\n    }\n\n    private async _enqueueJobAsync(orderHash: string, type: GaslessTypes): Promise<void> {\n        await this._sqsProducer.send({\n            // wait, it's all order hash?\n            // always has been.\n            groupId: orderHash,\n            id: orderHash,\n            body: JSON.stringify({ orderHash, type }),\n            deduplicationId: orderHash,\n        });\n    }\n\n    /**\n     * Maps an IndicativeQuote to a FirmOtcQuote. Handles txOrigin, chainId, expiryAndNonce, etc\n     */\n    private _mapIndicativeQuoteToFirmOtcQuote(\n        q: IndicativeQuote,\n        takerAddress: string,\n        nonceBucket: BigNumber,\n        nonce: BigNumber,\n    ): FirmOtcQuote {\n        return {\n            kind: 'otc',\n            makerUri: q.makerUri,\n            order: new OtcOrder({\n                txOrigin: this._registryAddress,\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(q.expiry, nonceBucket, nonce),\n                maker: q.maker,\n                taker: takerAddress,\n                makerToken: q.makerToken,\n                takerToken: q.takerToken,\n                makerAmount: q.makerAmount,\n                takerAmount: q.takerAmount,\n                chainId: this._chainId,\n                verifyingContract: this._contractAddresses.exchangeProxy,\n            }),\n        };\n    }\n\n    /**\n     * Validates and converts EIP-712 context to an Approval object.\n     * @param kind Type of gasless approval\n     * @param eip712 EIP-712 context parsed from the handler\n     * @param tradeHash The order hash or metatransaction hash,\n     *  only used for logging in case of validation error\n     * @returns The Approval object\n     */\n    // tslint:disable-next-line: prefer-function-over-method\n    private _convertEIP712ContextToApproval<T extends ExecuteMetaTransactionEip712Context | PermitEip712Context>(\n        eip712: T,\n        tradeHash: string,\n    ): T extends ExecuteMetaTransactionEip712Context ? ExecuteMetaTransactionApproval : PermitApproval {\n        const { types, primaryType, domain, message } = eip712;\n        switch (primaryType) {\n            case 'MetaTransaction': {\n                if (\n                    !_.isEqual(\n                        _.keys(message).sort(),\n                        types.MetaTransaction.map((dataField: Eip712DataField) => dataField.name).sort(),\n                    )\n                ) {\n                    logger.warn({ primaryType, tradeHash }, 'Invalid message field provided for Approval');\n                    throw new ValidationError([\n                        {\n                            field: 'message',\n                            code: ValidationErrorCodes.FieldInvalid,\n                            reason: `Invalid message field provided for Approval of primaryType ${primaryType}`,\n                        },\n                    ]);\n                }\n                const executeMetaTransactionApproval: ExecuteMetaTransactionApproval = {\n                    kind: GaslessApprovalTypes.ExecuteMetaTransaction,\n                    eip712: {\n                        types,\n                        primaryType,\n                        domain,\n                        message: {\n                            nonce: message.nonce,\n                            from: message.from,\n                            functionSignature: message.functionSignature,\n                        },\n                    },\n                };\n                return executeMetaTransactionApproval as T extends ExecuteMetaTransactionEip712Context\n                    ? ExecuteMetaTransactionApproval\n                    : PermitApproval;\n            }\n            case 'Permit': {\n                if (\n                    !_.isEqual(\n                        _.keys(message).sort(),\n                        types.Permit.map((dataField: Eip712DataField) => dataField.name).sort(),\n                    )\n                ) {\n                    logger.warn({ primaryType, tradeHash }, 'Invalid message field provided for Approval');\n                    throw new ValidationError([\n                        {\n                            field: 'message',\n                            code: ValidationErrorCodes.FieldInvalid,\n                            reason: `Invalid message field provided for Approval of primaryType ${primaryType}`,\n                        },\n                    ]);\n                }\n                const permitApproval: PermitApproval = {\n                    kind: GaslessApprovalTypes.Permit,\n                    eip712: {\n                        types,\n                        primaryType,\n                        domain,\n                        message: {\n                            owner: message.owner,\n                            spender: message.spender,\n                            value: message.value,\n                            nonce: message.nonce,\n                            deadline: message.deadline,\n                        },\n                    },\n                };\n\n                return permitApproval as T extends ExecuteMetaTransactionEip712Context\n                    ? ExecuteMetaTransactionApproval\n                    : PermitApproval;\n            }\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(primaryType);\n        }\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_health_check.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/number_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts",{"fileContent":"import { ERC20BridgeSource, FillData, NativeFillData, RfqOrderFields } from '@0x/asset-swapper';\nimport { BigNumber } from '@0x/utils';\nimport { Producer } from 'kafkajs';\n\nimport { logger } from '../logger';\nimport { FirmOtcQuote, IndicativeQuote, RfqtV2Quote, StoredFee } from '../core/types';\n\nimport { numberUtils } from './number_utils';\n\n/** Migrated from @0x/asset-swapper */\n\nexport interface ExtendedQuoteReport {\n    quoteId?: string;\n    taker?: string;\n    timestamp: number;\n    firmQuoteReport: boolean;\n    submissionBy: 'taker' | 'metaTxn' | 'rfqm' | 'gaslessSwapRfq' | 'gaslessSwapAmm';\n    buyAmount?: string;\n    sellAmount?: string;\n    buyTokenAddress: string;\n    sellTokenAddress: string;\n    integratorId?: string;\n    slippageBips?: number;\n    zeroExTransactionHash?: string;\n    decodedUniqueId?: string;\n    sourcesConsidered: ExtendedQuoteReportIndexedEntryOutbound[];\n    sourcesDelivered: ExtendedQuoteReportIndexedEntryOutbound[] | undefined;\n}\n\nexport interface QuoteReportEntryBase {\n    liquiditySource: ERC20BridgeSource;\n    makerAmount: BigNumber;\n    takerAmount: BigNumber;\n    fillData: FillData;\n}\nexport interface BridgeQuoteReportEntry extends QuoteReportEntryBase {\n    liquiditySource: Exclude<ERC20BridgeSource, ERC20BridgeSource.Native>;\n}\nexport interface MultiHopQuoteReportEntry extends QuoteReportEntryBase {\n    liquiditySource: ERC20BridgeSource.MultiHop;\n    hopSources: ERC20BridgeSource[];\n}\nexport interface NativeLimitOrderQuoteReportEntry extends QuoteReportEntryBase {\n    liquiditySource: ERC20BridgeSource.Native;\n    fillData: NativeFillData;\n    fillableTakerAmount: BigNumber;\n    isRFQ: false;\n}\nexport interface NativeRfqOrderQuoteReportEntry extends QuoteReportEntryBase {\n    liquiditySource: ERC20BridgeSource.Native;\n    fillData: NativeFillData;\n    fillableTakerAmount: BigNumber;\n    isRFQ: true;\n    nativeOrder: RfqOrderFields;\n    makerUri: string;\n    comparisonPrice?: number;\n}\nexport interface IndicativeRfqOrderQuoteReportEntry extends QuoteReportEntryBase {\n    liquiditySource: ERC20BridgeSource.Native;\n    fillableTakerAmount: BigNumber;\n    isRFQ: true;\n    makerUri?: string;\n    comparisonPrice?: number;\n}\n\nexport declare type ExtendedQuoteReportEntry =\n    | BridgeQuoteReportEntry\n    | MultiHopQuoteReportEntry\n    | NativeLimitOrderQuoteReportEntry\n    | NativeRfqOrderQuoteReportEntry\n    | IndicativeRfqOrderQuoteReportEntry;\n\nexport type ExtendedQuoteReportIndexedEntry = ExtendedQuoteReportEntry & {\n    quoteEntryIndex: number;\n    isDelivered: boolean;\n};\n\nexport type ExtendedQuoteReportIndexedEntryOutbound = Omit<ExtendedQuoteReportIndexedEntry, 'fillData'> & {\n    fillData?: string;\n};\n\n/************************************/\n\ntype ExtendedQuoteReportEntryWithIntermediateQuote = ExtendedQuoteReportIndexedEntryOutbound & {\n    isIntermediate: boolean;\n};\n\ntype ExtendedQuoteReportWithIntermediateQuote = Omit<ExtendedQuoteReport, 'sourcesConsidered'> & {\n    sourcesConsidered: ExtendedQuoteReportEntryWithIntermediateQuote[];\n};\n\ntype ExtendedQuoteReportWithFee = ExtendedQuoteReportWithIntermediateQuote & {\n    fee: StoredFee;\n    ammQuoteUniqueId?: string;\n    isLiquidityAvailable?: boolean;\n};\n\ninterface ExtendedQuoteReportForRFQMLogOptions {\n    isFirmQuote: boolean;\n    sellAmount?: BigNumber;\n    buyAmount?: BigNumber;\n    buyTokenAddress: string;\n    sellTokenAddress: string;\n    integratorId?: string;\n    taker?: string;\n    finalQuotes: IndicativeQuote[] | FirmOtcQuote[];\n    intermediateQuotes: IndicativeQuote[];\n    bestQuote: IndicativeQuote | FirmOtcQuote | null;\n    fee: StoredFee;\n    ammQuoteUniqueId?: string;\n    isLiquidityAvailable?: boolean;\n}\n/**\n * RFQt V2 Fee Event Interfaces\n */\ninterface RfqtV2FeeEventLogOptions {\n    requestedBuyAmount: BigNumber | null;\n    requestedSellAmount: BigNumber | null;\n    requestedTakerAddress: string;\n    buyTokenAddress: string;\n    sellTokenAddress: string;\n    integratorId: string;\n    blockNumber?: number;\n    quotes: RfqtV2Quote[];\n    fee: StoredFee;\n}\n\ninterface RfqtV2FeeEvent {\n    createdAt: number;\n    orderHash: string;\n    requestedBuyAmount: BigNumber | null;\n    requestedSellAmount: BigNumber | null;\n    requestedTakerAddress: string;\n    fillableBuyAmount: BigNumber;\n    fillableSellAmount: BigNumber;\n    buyTokenAddress: string;\n    sellTokenAddress: string;\n    fee: StoredFee;\n    integratorId: string;\n    makerId?: string;\n    makerUri?: string;\n    expiry: BigNumber;\n    blockNumber?: number;\n}\n\nexport const quoteReportUtils = {\n    async publishRFQMQuoteReportAsync(\n        logOpts: ExtendedQuoteReportForRFQMLogOptions,\n        kafkaProducer: Producer,\n        quoteReportTopic?: string,\n        extendedQuoteReportSubmissionBy: ExtendedQuoteReport['submissionBy'] = 'rfqm',\n    ): Promise</* quoteId */ string | null> {\n        if (kafkaProducer && quoteReportTopic) {\n            const quoteId = numberUtils.randomHexNumberOfLength(10);\n            logger.info(`Generating and pushing RFQm Quote Report for: ${quoteId}`);\n\n            let orderHash: string | undefined;\n            if (logOpts.bestQuote && isFirmQuote(logOpts.bestQuote)) {\n                orderHash = logOpts.bestQuote.order.getHash();\n            }\n\n            const finalQuotes = logOpts.finalQuotes.map(\n                (quote, index): ExtendedQuoteReportEntryWithIntermediateQuote => {\n                    return {\n                        ...jsonifyFillData({\n                            quoteEntryIndex: index,\n                            isDelivered: false,\n                            liquiditySource: ERC20BridgeSource.Native,\n                            makerAmount: isFirmQuote(quote) ? quote.order.makerAmount : quote.makerAmount,\n                            takerAmount: isFirmQuote(quote) ? quote.order.takerAmount : quote.takerAmount,\n                            fillableTakerAmount: isFirmQuote(quote) ? quote.order.takerAmount : quote.takerAmount,\n                            isRFQ: true,\n                            makerUri: quote.makerUri,\n                            fillData: isFirmQuote(quote) ? quote.order : {},\n                        }),\n                        isIntermediate: false,\n                    };\n                },\n            );\n\n            const intermediateQuotes = logOpts.intermediateQuotes.map(\n                (quote, index): ExtendedQuoteReportEntryWithIntermediateQuote => {\n                    return {\n                        ...jsonifyFillData({\n                            quoteEntryIndex: index,\n                            isDelivered: false,\n                            liquiditySource: ERC20BridgeSource.Native,\n                            makerAmount: isFirmQuote(quote) ? quote.order.makerAmount : quote.makerAmount,\n                            takerAmount: isFirmQuote(quote) ? quote.order.takerAmount : quote.takerAmount,\n                            fillableTakerAmount: isFirmQuote(quote) ? quote.order.takerAmount : quote.takerAmount,\n                            isRFQ: true,\n                            makerUri: quote.makerUri,\n                            fillData: isFirmQuote(quote) ? quote.order : {},\n                        }),\n                        isIntermediate: true,\n                    };\n                },\n            );\n\n            const sourcesDelivered: ExtendedQuoteReportIndexedEntryOutbound[] | undefined = logOpts.bestQuote\n                ? [\n                      jsonifyFillData({\n                          quoteEntryIndex: 0,\n                          isDelivered: true,\n                          liquiditySource: ERC20BridgeSource.Native,\n                          makerAmount: isFirmQuote(logOpts.bestQuote)\n                              ? logOpts.bestQuote?.order.makerAmount\n                              : logOpts.bestQuote?.makerAmount,\n                          takerAmount: isFirmQuote(logOpts.bestQuote)\n                              ? logOpts.bestQuote?.order.takerAmount\n                              : logOpts.bestQuote?.takerAmount,\n                          fillableTakerAmount: isFirmQuote(logOpts.bestQuote)\n                              ? logOpts.bestQuote?.order.takerAmount\n                              : logOpts.bestQuote?.takerAmount,\n                          isRFQ: true,\n                          makerUri: logOpts.bestQuote?.makerUri,\n                          fillData: isFirmQuote(logOpts.bestQuote) ? logOpts.bestQuote?.order : {},\n                      }),\n                  ]\n                : undefined;\n            const extendedQuoteReport: ExtendedQuoteReportWithFee = {\n                quoteId,\n                taker: logOpts.taker,\n                timestamp: Date.now(),\n                firmQuoteReport: logOpts.isFirmQuote,\n                submissionBy: extendedQuoteReportSubmissionBy,\n                buyAmount: logOpts.buyAmount ? logOpts.buyAmount.toString() : undefined,\n                sellAmount: logOpts.sellAmount ? logOpts.sellAmount.toString() : undefined,\n                buyTokenAddress: logOpts.buyTokenAddress,\n                sellTokenAddress: logOpts.sellTokenAddress,\n                integratorId: logOpts.integratorId,\n                slippageBips: undefined,\n                zeroExTransactionHash: orderHash,\n                sourcesConsidered: finalQuotes.concat(intermediateQuotes),\n                sourcesDelivered,\n                fee: logOpts.fee,\n                ammQuoteUniqueId: logOpts.ammQuoteUniqueId,\n                isLiquidityAvailable: logOpts.isLiquidityAvailable,\n            };\n            kafkaProducer.send({\n                topic: quoteReportTopic,\n                messages: [\n                    {\n                        value: JSON.stringify(extendedQuoteReport),\n                    },\n                ],\n            });\n            return quoteId;\n        }\n        return null;\n    },\n    async publishRfqtV2FeeEvent(logOpts: RfqtV2FeeEventLogOptions, kafkaProducer: Producer, feeEventTopic?: string) {\n        if (kafkaProducer && feeEventTopic) {\n            const createdAt = Date.now();\n            logger.info(`Generating and pushing RFQt V2 Quote Report`);\n\n            logOpts.quotes.map((quote) => {\n                const quoteReport: RfqtV2FeeEvent = {\n                    createdAt,\n                    orderHash: quote.order.getHash(),\n                    requestedBuyAmount: logOpts.requestedBuyAmount,\n                    requestedSellAmount: logOpts.requestedSellAmount,\n                    requestedTakerAddress: logOpts.requestedTakerAddress,\n                    fillableBuyAmount: quote.fillableMakerAmount,\n                    fillableSellAmount: quote.fillableTakerAmount,\n                    buyTokenAddress: logOpts.buyTokenAddress,\n                    sellTokenAddress: logOpts.sellTokenAddress,\n                    fee: logOpts.fee,\n                    integratorId: logOpts.integratorId,\n                    makerId: quote.makerId,\n                    makerUri: quote.makerUri,\n                    expiry: quote.order.expiry,\n                    blockNumber: logOpts.blockNumber,\n                };\n\n                kafkaProducer.send({\n                    topic: feeEventTopic,\n                    messages: [\n                        {\n                            value: JSON.stringify(quoteReport),\n                        },\n                    ],\n                });\n            });\n        }\n    },\n};\n\nfunction isFirmQuote(quote: FirmOtcQuote | IndicativeQuote): quote is FirmOtcQuote {\n    return (quote as FirmOtcQuote).order !== undefined;\n}\n\n/**\n * Migrated from @0x/asset-swapper\n */\nexport function jsonifyFillData(source: ExtendedQuoteReportIndexedEntry): ExtendedQuoteReportIndexedEntryOutbound {\n    return {\n        ...source,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fillData: JSON.stringify(source.fillData, (key: string, value: any) => {\n            if (key === '_samplerContract') {\n                return {};\n            } else {\n                return value;\n            }\n        }),\n    };\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/number_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/number_utils.ts",{"fileContent":"export const numberUtils = {\n    // from MDN https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random\n    randomNumberInclusive: (minimumSpecified: number, maximumSpecified: number): number => {\n        const min = Math.ceil(minimumSpecified);\n        const max = Math.floor(maximumSpecified);\n        return Math.floor(Math.random() * (max - min + 1)) + min; // The maximum is inclusive and the minimum is inclusive\n    },\n    // creates a random hex number of desired length by stringing together\n    // random integers from 1-15, guaranteeing the\n    // result is a hex number of the given length\n    randomHexNumberOfLength: (numberLength: number): string => {\n        let res = '';\n        for (let i = 0; i < numberLength; i++) {\n            // tslint:disable-next-line:custom-no-magic-numbers\n            res = `${res}${numberUtils.randomNumberInclusive(1, 15).toString(16)}`;\n        }\n        return res;\n    },\n};\n\nexport const modulo = (a: number, b: number): number => {\n    return ((a % b) + b) % b;\n};\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts",{"fileContent":"import { SchemaValidator } from '@0x/json-schemas';\nimport { Signature } from '@0x/protocol-utils';\nimport { schemas as quoteServerSchemas } from '../quote-server/schemas';\nimport { SignRequest } from '../quote-server/types';\nimport { BigNumber } from '@0x/utils';\nimport { AxiosInstance } from 'axios';\nimport { OK } from 'http-status-codes';\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\nimport { Summary } from 'prom-client';\nimport * as uuid from 'uuid';\n\nimport {\n    Integrator,\n    RFQ_PRICE_ENDPOINT_TIMEOUT_MS,\n    RFQ_SIGN_ENDPOINT_TIMEOUT_MS,\n    TAKER_SPECIFIED_SIDE_ENABLED,\n} from '../config';\nimport { ZERO } from '../core/constants';\nimport { logger } from '../logger';\nimport { schemas } from '../core/schemas';\nimport { Fee, IndicativeQuote, QuoteServerPriceParams } from '../core/types';\nimport { MarketOperation } from '@0x/types';\n\nconst MARKET_MAKER_SIGN_LATENCY = new Summary({\n    name: 'market_maker_sign_latency',\n    help: 'Latency for sign request to Market Makers',\n    labelNames: ['makerUri', 'statusCode'],\n});\n\nconst RFQ_MARKET_MAKER_PRICE_REQUEST_DURATION_SECONDS = new Summary({\n    name: 'rfq_market_maker_price_request_duration_seconds',\n    help: 'Provides stats around market maker network interactions',\n    percentiles: [0.5, 0.9, 0.95, 0.99, 0.999], // tslint:disable-line: custom-no-magic-numbers\n    labelNames: ['type', 'integratorLabel', 'makerUri', 'chainId', 'statusCode', 'market'],\n    maxAgeSeconds: 60,\n    ageBuckets: 5,\n});\n\nconst KNOWN_TOKENS: { [key: string]: string } = {\n    // Mainnet\n    '0x6b175474e89094c44da98b954eedeac495271d0f': 'DAI',\n    '0xdac17f958d2ee523a2206206994597c13d831ec7': 'USDT',\n    '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': 'USDC',\n    '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2': 'WETH',\n    // Polygon\n    '0x8f3cf7ad23cd3cadbd9735aff958023239c6a063': 'DAI',\n    '0xc2132d05d31c914a87c6611c10748aeb04b58e8f': 'USDT',\n    '0x2791bca1f2de4661ed88a30c99a7a9449aa84174': 'USDC',\n    '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619': 'WETH',\n    '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270': 'WMATIC',\n};\n\n/**\n * [Read this in Daniel's voice] Returns a human-readable label for Prometheus counters.\n * Only popular most relevant pairs should be displayed in Prometheus (since it overload the service)\n * and any other market that does not contain popular pairs will simply return \"Other\".\n *\n * @param tokenSold the token being sold\n * @param tokenPurchased the token being purchased\n * @returns a market like \"WETH-DAI\", or \"Other\" is a pair is unknown\n */\nfunction getMarketLabel(tokenSold: string, tokenPurchased: string): string {\n    const items = [tokenSold.toLowerCase(), tokenPurchased.toLowerCase()];\n    items.sort();\n\n    const tokenA: string | undefined = KNOWN_TOKENS[items[0]];\n    const tokenB: string | undefined = KNOWN_TOKENS[items[1]];\n    if (!tokenA || !tokenB) {\n        return 'Other';\n    }\n    return `${tokenA}-${tokenB}`;\n}\n\nconst schemaValidator = new SchemaValidator();\nschemaValidator.addSchema(quoteServerSchemas.feeSchema);\nschemaValidator.addSchema(quoteServerSchemas.submitRequestSchema);\nschemaValidator.addSchema(quoteServerSchemas.submitReceiptSchema);\nschemaValidator.addSchema(quoteServerSchemas.otcQuoteResponseSchema);\n\nexport class QuoteServerClient {\n    /**\n     * Prepares the query parameters (copied from QuoteRequestor)\n     */\n    public static makeQueryParameters(input: {\n        chainId?: number;\n        txOrigin: string;\n        takerAddress: string;\n        marketOperation: MarketOperation;\n        buyTokenAddress: string; // maker token\n        sellTokenAddress: string; // taker token\n        assetFillAmount: BigNumber;\n        comparisonPrice?: BigNumber;\n        isLastLook?: boolean | undefined;\n        fee?: Fee | undefined;\n    }): QuoteServerPriceParams {\n        const {\n            chainId,\n            txOrigin,\n            takerAddress,\n            marketOperation,\n            buyTokenAddress,\n            sellTokenAddress,\n            assetFillAmount,\n            comparisonPrice,\n            isLastLook,\n            fee,\n        } = input;\n        const { buyAmountBaseUnits, sellAmountBaseUnits } =\n            marketOperation === MarketOperation.Buy\n                ? {\n                      buyAmountBaseUnits: assetFillAmount,\n                      sellAmountBaseUnits: undefined,\n                  }\n                : {\n                      sellAmountBaseUnits: assetFillAmount,\n                      buyAmountBaseUnits: undefined,\n                  };\n\n        const requestParamsWithBigNumbers: Pick<\n            QuoteServerPriceParams,\n            | 'chainId'\n            | 'txOrigin'\n            | 'takerAddress'\n            | 'buyTokenAddress'\n            | 'sellTokenAddress'\n            | 'comparisonPrice'\n            | 'isLastLook'\n            | 'protocolVersion'\n            | 'feeAmount'\n            | 'feeToken'\n            | 'feeType'\n        > = {\n            txOrigin,\n            takerAddress,\n            buyTokenAddress,\n            sellTokenAddress,\n            protocolVersion: '4',\n        };\n\n        if (comparisonPrice) {\n            requestParamsWithBigNumbers.comparisonPrice = comparisonPrice.toString();\n        }\n\n        if (isLastLook) {\n            if (fee === undefined) {\n                throw new Error(`isLastLook cannot be passed without a fee parameter`);\n            }\n            requestParamsWithBigNumbers.isLastLook = isLastLook.toString();\n        }\n\n        logger.info({ fee }, 'fee parameter in `makeQueryParameters`');\n        if (fee) {\n            logger.info(\n                {\n                    feeAmount: fee.amount,\n                    feeAmountString: fee.amount.toString(),\n                },\n                'fee amounts in `makeQueryParameters`',\n            );\n            requestParamsWithBigNumbers.feeAmount = fee.amount.toString();\n            requestParamsWithBigNumbers.feeToken = fee.token;\n            requestParamsWithBigNumbers.feeType = fee.type;\n        }\n\n        if (chainId) {\n            requestParamsWithBigNumbers.chainId = String(chainId);\n        }\n\n        // convert BigNumbers to strings so they are digestible by axios\n        if (sellAmountBaseUnits) {\n            return {\n                ...requestParamsWithBigNumbers,\n                sellAmountBaseUnits: sellAmountBaseUnits.toString(),\n            };\n        } else if (buyAmountBaseUnits) {\n            return {\n                ...requestParamsWithBigNumbers,\n                buyAmountBaseUnits: buyAmountBaseUnits.toString(),\n            };\n        } else {\n            throw new Error('Neither \"buyAmountBaseUnits\" or \"sellAmountBaseUnits\" were defined');\n        }\n    }\n\n    constructor(private readonly _axiosInstance: AxiosInstance) {}\n\n    /**\n     * Fetch a price (indicative quote)\n     *\n     * @param makerUri - the maker URI\n     * @param integrator - the integrator\n     * @param parameters - the query parameters (created via {@link QuoteServerClient.makeQueryParameters} )\n     * @param makerUriToUrl - function to transform the maker URI into its `price` endpoint\n     * @returns - a Promise containing the indicative quote if available, else undefined\n     * @throws - Will throw an error if a 4xx or 5xx is returned\n     */\n    public async getPriceV2Async(\n        makerUri: string,\n        integrator: Integrator,\n        parameters: QuoteServerPriceParams,\n        makerUriToUrl: (u: string) => string,\n    ): Promise<IndicativeQuote | undefined> {\n        const timerStopFn = RFQ_MARKET_MAKER_PRICE_REQUEST_DURATION_SECONDS.startTimer();\n        const headers = {\n            '0x-request-uuid': uuid.v4(),\n            '0x-integrator-id': integrator.integratorId,\n            '0x-api-key': integrator.integratorId,\n        };\n        logger.info({ headers, parameters, integratorId: integrator.integratorId, makerUri }, 'v2/price request to MM');\n\n        const tempParams = { ...parameters };\n        delete tempParams.trader;\n        delete tempParams.worflow;\n\n        const response = await this._axiosInstance.get(makerUriToUrl(makerUri), {\n            timeout: RFQ_PRICE_ENDPOINT_TIMEOUT_MS,\n            validateStatus: (status: number) => {\n                // tslint:disable-next-line: custom-no-magic-numbers\n                if (status >= 300) {\n                    logger.warn({ status, makerUri }, 'Received non-OK status requesting price from market maker');\n                }\n                // Don't throw errors on 4xx or 5xx\n                return true;\n            },\n            headers,\n            params: tempParams,\n        });\n        logger.info({ makerUri, body: response.data, status: response.status }, 'v2/price response from MM');\n\n        timerStopFn({\n            type: makerUriToUrl(''), // HACK - used to distinguish between RFQm and RFQt\n            integratorLabel: integrator.label,\n            makerUri,\n            chainId: parameters.chainId,\n            statusCode: response.status,\n            market: getMarketLabel(parameters.sellTokenAddress, parameters.buyTokenAddress),\n        });\n\n        // Empty response from MM (not 200, no data, or empty object)\n        if (response.status !== OK || !response.data || Object.keys(response.data).length === 0) {\n            return;\n        }\n\n        const validationResult = schemaValidator.validate(response.data, schemas.indicativeOtcQuoteResponseSchema);\n        if (validationResult.errors && validationResult.errors.length > 0) {\n            const errorsMsg = validationResult.errors.map((err) => err.message).join(',');\n            logger.error({ response: response.data, makerUri, status: response.status }, 'Malformed price response');\n            throw new Error(`Error from validator: ${errorsMsg}`);\n        }\n\n        return {\n            expiry: new BigNumber(response.data.expiry),\n            maker: response.data.maker,\n            makerAmount: new BigNumber(response.data.makerAmount),\n            makerToken: response.data.makerToken,\n            makerUri,\n            takerAmount: new BigNumber(response.data.takerAmount),\n            takerToken: response.data.takerToken,\n        };\n    }\n\n    /**\n     * Fetch a batch of prices. Ignores all quotes that return errors\n     *\n     * @param makerUris - a list of maker URIs\n     * @param integrator - the integrator\n     * @param parameters - the query parameters (created via {@link QuoteServerClient.makeQueryParameters} )\n     * @param makerUriToUrl - function to transform the maker URI into its `price` endpoint\n     * @returns - a Promise containing a list of indicative quotes\n     */\n    public async batchGetPriceV2Async(\n        makerUris: string[],\n        integrator: Integrator,\n        parameters: QuoteServerPriceParams,\n        makerUriToUrl: (u: string) => string = (u: string) => `${u}/rfqm/v2/price`,\n    ): Promise<IndicativeQuote[]> {\n        return Promise.all(\n            makerUris.map(async (makerUri) => {\n                return this.getPriceV2Async(makerUri, integrator, parameters, makerUriToUrl).catch((err) => {\n                    logger.error(\n                        {\n                            errorMessage: err?.message,\n                            makerUri,\n                            status: err?.response?.status ?? 'unknown',\n                        },\n                        'Encountered an error requesting an indicative quote',\n                    );\n                    return undefined;\n                });\n            }),\n        ).then((arr) => arr.filter((result): result is IndicativeQuote => result !== undefined));\n    }\n\n    /**\n     * Request a signature from a MM for a given OtcOrder\n     *\n     * @param makerUri - the MM's uri\n     * @param integratorId - the integrator id\n     * @param payload - the payload of the request. RFQm transactions require\n     *   `takerSignature` to be present, while `takerSignature` will not be\n     *   present for RFQt transactions.\n     * @param requireProceedWithFill - whether or not to require the response\n     *  to include a `proceedWithFill` field. This field is specific to RFQm\n     *  and isn't required for an RFQt sign request.\n     * @param makerUriToUrl - function to transform the maker URI into its `sign` endpoint\n     * @returns - The signature if successful, undefined otherwise\n     * @throws - Will throw an error if a 4xx or 5xx is returned\n     */\n    public async signV2Async(\n        makerUri: string,\n        integratorId: string,\n        payload: Omit<SignRequest, 'takerSignature'> & Pick<Partial<SignRequest>, 'takerSignature'>,\n        makerUriToUrl: (u: string) => string = (u: string) => `${u}/rfqm/v2/sign`,\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-inferrable-types\n        requireProceedWithFill: boolean = true,\n    ): Promise<Signature | undefined> {\n        const timerStopFn = MARKET_MAKER_SIGN_LATENCY.startTimer();\n        const requestUuid = uuid.v4();\n        const headers = {\n            '0x-api-key': integratorId,\n            '0x-integrator-id': integratorId,\n            '0x-request-uuid': requestUuid,\n            'Content-Type': 'application/json',\n        };\n        logger.info({ headers, payload, integratorId, makerUri }, 'v2/sign request to MM');\n        const rawResponse = await this._axiosInstance.post(\n            makerUriToUrl(makerUri),\n            {\n                order: payload.order,\n                orderHash: payload.orderHash,\n                expiry: payload.expiry,\n                takerSignature: payload.takerSignature,\n                // trader: payload.trader,\n                feeToken: payload.fee.token,\n                feeAmount: payload.fee.amount,\n                // workflow: payload.workflow,\n                ...(TAKER_SPECIFIED_SIDE_ENABLED &&\n                    payload.takerSpecifiedSide && { takerSpecifiedSide: payload.takerSpecifiedSide }),\n            },\n            {\n                timeout: RFQ_SIGN_ENDPOINT_TIMEOUT_MS,\n                headers: {\n                    '0x-api-key': integratorId,\n                    '0x-integrator-id': integratorId,\n                    '0x-request-uuid': requestUuid,\n                    'Content-Type': 'application/json',\n                },\n                validateStatus: () => true, // Don't throw errors on 4xx or 5xx\n            },\n        );\n        logger.info(\n            {\n                makerUri,\n                requestUuid,\n                status: rawResponse.status,\n                body: rawResponse.data,\n            },\n            'v2/sign response from MM',\n        );\n        timerStopFn({\n            makerUri,\n            statusCode: rawResponse.status,\n        });\n\n        // TODO (rhinodavid): Filter out non-successful statuses from validation step\n\n        const validationResult = schemaValidator.validate(rawResponse.data, schemas.signResponseSchema);\n        if (validationResult.errors && validationResult.errors.length > 0) {\n            const errorsMsg = validationResult.errors.map((err) => err.message).join(',');\n            logger.error(\n                { response: rawResponse.data, makerUri, status: rawResponse.status },\n                'Malformed sign response',\n            );\n            throw new Error(`Error from validator: ${errorsMsg}`);\n        }\n\n        const proceedWithFill = rawResponse.data?.proceedWithFill as boolean | undefined;\n        const makerSignature: Signature | undefined = rawResponse.data?.makerSignature;\n        const feeAmount = new BigNumber(rawResponse.data?.feeAmount);\n\n        if (!proceedWithFill && requireProceedWithFill) {\n            logger.info({ makerUri }, 'Sign request rejected');\n            return undefined;\n        }\n\n        if (!payload.fee.amount.eq(ZERO) && !feeAmount.gte(payload.fee.amount)) {\n            logger.warn(\n                { requestFeeAmount: payload.fee.amount, responseFeeAmount: feeAmount, makerUri },\n                'Invalid fee acknowledgement',\n            );\n            return undefined;\n        }\n\n        if (makerSignature === undefined) {\n            logger.warn({ makerUri }, 'Signature is missing');\n            return undefined;\n        }\n\n        return makerSignature;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas/fee.json","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas/otc_quote_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas/sign_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas/sign_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas/submit_receipt_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas/submit_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas/taker_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/chain_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/chain_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/fee_model_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/fee_model_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/firm_quote_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/indicative_otc_quote_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/indicative_quote_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/integrators_acl_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/integrator_acl_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/rfq_maker_config.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/rfq_maker_config_list.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/sign_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configuration_entry.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas.ts",{"fileContent":"import * as feeSchema from './schemas/fee.json';\nimport * as otcQuoteResponseSchema from './schemas/otc_quote_response_schema.json';\nimport * as signRequestSchema from './schemas/sign_request_schema.json';\nimport * as signResponseSchema from './schemas/sign_response_schema.json';\nimport * as submitReceiptSchema from './schemas/submit_receipt_schema.json';\nimport * as submitRequestSchema from './schemas/submit_request_schema.json';\nimport * as takerRequestSchema from './schemas/taker_request_schema.json';\n\nexport const schemas = {\n    feeSchema,\n    otcQuoteResponseSchema,\n    signRequestSchema,\n    signResponseSchema,\n    submitReceiptSchema,\n    submitRequestSchema,\n    takerRequestSchema,\n};\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas/fee.json","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas/otc_quote_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas/sign_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas/sign_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas/submit_receipt_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas/submit_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas/taker_request_schema.json"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_health_check.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { Gauge } from 'prom-client';\nimport { Producer } from 'sqs-producer';\n\nimport { ETH_DECIMALS, RFQM_TX_GAS_ESTIMATE } from '../core/constants';\nimport { RfqmWorkerHeartbeatEntity } from '../entities';\nimport { RfqMakerAssetOfferings } from './rfq_maker_manager';\n\nconst SQS_QUEUE_SIZE_DEGRADED_THRESHOLD = 10; // More messages sitting in queue than this will cause a DEGRADED issue\nconst SQS_QUEUE_SIZE_FAILED_THRESHOLD = 20; // More messages sitting in queue than this will cause a FAILED issue\n\nconst RECENT_HEARTBEAT_AGE_THRESHOLD = 5; // (minutes) Heartbeats older than this will produce a DEGRADED issue. A FAILED issue is produced if NO heartbeats are newer than this.\n\nconst BALANCE_FAILED_THRESHOLD = 0.04; // (eth) If NO worker has a balance higher than this, a FAILED issue gets created.\n// tslint:disable-next-line: custom-no-magic-numbers\nconst BALANCE_DEGRADED_THRESHOLD = 0.1; // (eth) If < 2 workers have a balance lower than this, a DEGRADED issue gets created.\n\nconst MS_IN_MINUTE = 60000;\n\nconst BALANCE_DEGRADED_THRESHOLD_WEI = new BigNumber(BALANCE_DEGRADED_THRESHOLD).shiftedBy(ETH_DECIMALS);\nconst BALANCE_FAILED_THRESHOLD_WEI = new BigNumber(BALANCE_FAILED_THRESHOLD).shiftedBy(ETH_DECIMALS);\n\nconst RFQM_HEALTH_CHECK_ISSUE_GAUGE = new Gauge({\n    name: 'rfqm_health_check_issue_gauge',\n    labelNames: ['label' /* :HealthCheckLabel */, 'chain_id'],\n    help: 'Gauge indicating the current status for each label. Value corresponds to the `statusSeverity`',\n});\n\nconst RFQM_TOTAL_SYSTEM_TRADE_CAPACITY_GAUGE = new Gauge({\n    name: 'rfqm_total_system_trade_capacity',\n    labelNames: ['chain_id'],\n    help: 'Total amount of ETH in the worker pool divided by the current expected gas of a trade',\n});\n\nexport enum HealthCheckStatus {\n    Operational = 'operational',\n    Maintenance = 'maintenance',\n    Degraded = 'degraded',\n    Failed = 'failed',\n}\n\ntype HealthCheckLabel = 'RFQM_MAINTENANCE_MODE config `true`' | 'queue size' | 'worker balance' | 'worker heartbeat';\n\ninterface HealthCheckIssue {\n    status: HealthCheckStatus;\n    description: string;\n    label: HealthCheckLabel;\n}\n\n/**\n * The complete result of an RFQm health check routine.\n * For public users, this should be converted to a `RfqmHealthCheckShortResponse` before being\n * sent in the reponse in order to not expose potentially-sensitive system details.\n */\nexport interface HealthCheckResult {\n    status: HealthCheckStatus;\n    pairs: {\n        [pair: string]: HealthCheckStatus; // where the pair has the form `${contractA}-${contractB}`\n    };\n    http: {\n        status: HealthCheckStatus;\n        issues: HealthCheckIssue[];\n    };\n    workers: {\n        status: HealthCheckStatus;\n        issues: HealthCheckIssue[];\n    };\n    // TODO (rhinodavid): Add MarketMakers\n}\n\nexport interface RfqmHealthCheckShortResponse {\n    isOperational: boolean;\n    pairs: [string, string][];\n}\n\n/**\n * Produces a full health check from the given inupts.\n */\nexport async function computeHealthCheckAsync(\n    isMaintainenceMode: boolean,\n    offerings: RfqMakerAssetOfferings,\n    producer: Producer,\n    heartbeats: RfqmWorkerHeartbeatEntity[],\n    chainId: number,\n    gasPrice?: BigNumber,\n): Promise<HealthCheckResult> {\n    const pairs = transformPairs(offerings);\n\n    const httpIssues = getHttpIssues(isMaintainenceMode);\n    const httpStatus = getWorstStatus(httpIssues.map((issue) => issue.status));\n\n    const queueIssues = await checkSqsQueueAsync(producer);\n    const heartbeatIssues = await checkWorkerHeartbeatsAsync(heartbeats);\n    const workersIssues = [...queueIssues, ...heartbeatIssues];\n    const workersStatus = getWorstStatus(workersIssues.map((issue) => issue.status));\n\n    // Prometheus counters\n    const severityByLabel: Record<HealthCheckLabel, number> = {\n        'RFQM_MAINTENANCE_MODE config `true`': statusSeverity(HealthCheckStatus.Operational),\n        'queue size': statusSeverity(HealthCheckStatus.Operational),\n        'worker balance': statusSeverity(HealthCheckStatus.Operational),\n        'worker heartbeat': statusSeverity(HealthCheckStatus.Operational),\n    };\n    [...httpIssues, ...workersIssues].forEach(\n        (issue) =>\n            (severityByLabel[issue.label] = Math.max(severityByLabel[issue.label], statusSeverity(issue.status))),\n    );\n    Object.entries(severityByLabel).forEach(([label, severity]) => {\n        RFQM_HEALTH_CHECK_ISSUE_GAUGE.labels(label, chainId.toString()).set(severity);\n    });\n\n    if (gasPrice) {\n        // Note that this gauge is an estimation of the total number of trades, since two workers could have\n        // 50% of the amount for one trade and the gauge would show 1 but the actual capacity would be 0.\n        const totalWorkerBalance = heartbeats.reduce((total, { balance }) => total.plus(balance), new BigNumber(0));\n        const totalSystemTradeCapacity = totalWorkerBalance.div(gasPrice.times(RFQM_TX_GAS_ESTIMATE));\n        RFQM_TOTAL_SYSTEM_TRADE_CAPACITY_GAUGE.labels(chainId.toString()).set(totalSystemTradeCapacity.toNumber());\n    }\n\n    return {\n        status: getWorstStatus([httpStatus, workersStatus]),\n        pairs,\n        http: { status: httpStatus, issues: httpIssues },\n        workers: { status: workersStatus, issues: workersIssues },\n    };\n}\n\n/**\n * Transform the full health check result into the minimal response the Matcha UI requires.\n */\nexport function transformResultToShortResponse(result: HealthCheckResult): RfqmHealthCheckShortResponse {\n    return {\n        isOperational: result.status === HealthCheckStatus.Operational || result.status === HealthCheckStatus.Degraded,\n        pairs: Object.entries(result.pairs)\n            .filter(\n                ([_pair, status]) => status === HealthCheckStatus.Operational || status === HealthCheckStatus.Degraded,\n            )\n            .map(([pair, _status]) => {\n                const [tokenA, tokenB] = pair.split('-');\n                return [tokenA, tokenB];\n            }),\n    };\n}\n\n/**\n * Changes the set of trading pairs from the format used in config to the format used in the health check response.\n */\nfunction transformPairs(offerings: RfqMakerAssetOfferings): { [pair: string]: HealthCheckStatus } {\n    return Object.values(offerings)\n        .flat()\n        .reduce((result: { [pair: string]: HealthCheckStatus }, pair) => {\n            const [tokenA, tokenB] = pair.sort();\n            // Currently, we assume all pairs are operation. In the future, this may not be the case.\n            result[`${tokenA}-${tokenB}`] = HealthCheckStatus.Operational;\n            return result;\n        }, {});\n}\n\n/**\n * Creates issues related to the server/API not specific to the worker farm.\n */\nexport function getHttpIssues(isMaintainenceMode: boolean): HealthCheckIssue[] {\n    const issues: HealthCheckIssue[] = [];\n    if (isMaintainenceMode) {\n        issues.push({\n            status: HealthCheckStatus.Maintenance,\n            description: 'RFQM is set to maintainence mode via the 0x API configuration',\n            label: 'RFQM_MAINTENANCE_MODE config `true`',\n        });\n    }\n    return issues;\n}\n\n/**\n * Runs checks on the SQS queue to detect if there are messages piling up.\n */\nexport async function checkSqsQueueAsync(producer: Producer): Promise<HealthCheckIssue[]> {\n    const results: HealthCheckIssue[] = [];\n    const messagesInQueue = await producer.queueSize();\n    if (messagesInQueue === 0) {\n        return results;\n    }\n    if (messagesInQueue > SQS_QUEUE_SIZE_FAILED_THRESHOLD) {\n        results.push({\n            status: HealthCheckStatus.Failed,\n            description: `SQS queue contains ${messagesInQueue} messages (threshold is ${SQS_QUEUE_SIZE_FAILED_THRESHOLD})`,\n            label: 'queue size',\n        });\n    } else if (messagesInQueue > SQS_QUEUE_SIZE_DEGRADED_THRESHOLD) {\n        results.push({\n            status: HealthCheckStatus.Degraded,\n            description: `SQS queue contains ${messagesInQueue} messages (threshold is ${SQS_QUEUE_SIZE_DEGRADED_THRESHOLD})`,\n            label: 'queue size',\n        });\n    }\n    return results;\n}\n\n/**\n * Returns a numerical value which corresponds to the \"severity\" of a `HealthCheckStatus` enum member.\n * Higher values are more severe. (Oh to have SwiftLang enums here.)\n */\nfunction statusSeverity(status: HealthCheckStatus): number {\n    // tslint:disable custom-no-magic-numbers\n    switch (status) {\n        case HealthCheckStatus.Failed:\n            return 4;\n        case HealthCheckStatus.Maintenance:\n            return 3;\n        case HealthCheckStatus.Degraded:\n            return 2;\n        case HealthCheckStatus.Operational:\n            return 1;\n        default:\n            throw new Error(`Received unknown status: ${status}`);\n    }\n    // tslint:enable custom-no-magic-numbers\n}\n\n/**\n * Accepts a list of statuses and returns the worst status\n */\nfunction getWorstStatus(statuses: HealthCheckStatus[]): HealthCheckStatus {\n    if (!statuses.length) {\n        return HealthCheckStatus.Operational;\n    }\n    return statuses.reduce(\n        (worstStatus, currentStatus) =>\n            statusSeverity(currentStatus) > statusSeverity(worstStatus) ? currentStatus : worstStatus,\n        HealthCheckStatus.Operational,\n    );\n}\n\n/**\n * Looks at the worker heartbeats and produces appropriate issues based on the age\n * of the heartbeats and the worker balances.\n *\n * Heartbeat Age: Checks the most recent heartbeat and produces a FAILED issue if it is older than the failed\n * threshold. For heartbeats other than the most recent, will only produce a DEGRADED issue. (i.e. the check only\n * fails if ALL workers are stuck)\n *\n * Worker Balance: Like with the age check, this only produces a FAILED issue if all workers are below the failed\n * balance. Individual worker balances produce a DEGRADED issue if they are below BALANCE_DEGRADED_THRESHOLD.\n *\n * Current date is an optional parameter for testing.\n */\nexport async function checkWorkerHeartbeatsAsync(\n    heartbeats: RfqmWorkerHeartbeatEntity[],\n    nowDate: Date = new Date(),\n): Promise<HealthCheckIssue[]> {\n    const results: HealthCheckIssue[] = [];\n    if (!heartbeats.length) {\n        return [\n            {\n                status: HealthCheckStatus.Failed,\n                description: 'No worker heartbeats were found',\n                label: 'worker heartbeat',\n            },\n        ];\n    }\n\n    // Heartbeat Age\n    const sortedHeartbeats = heartbeats.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n    const newestHeartbeat = sortedHeartbeats[0];\n    const newestHeartbeatAgeMinutes = (nowDate.getTime() - newestHeartbeat.timestamp.getTime()) / MS_IN_MINUTE;\n    if (newestHeartbeatAgeMinutes > RECENT_HEARTBEAT_AGE_THRESHOLD) {\n        results.push({\n            status: HealthCheckStatus.Failed,\n            description: `No worker has published a heartbeat in the last ${RECENT_HEARTBEAT_AGE_THRESHOLD} minutes`,\n            label: 'worker heartbeat',\n        });\n    }\n    // TODO (rhinodavid): Think about how this will work when we downscale and a worker isn't producing new\n    // hearbeats because it's been removed.\n    sortedHeartbeats.forEach(({ index, timestamp, address }) => {\n        const heartbeatAgeMinutes = (nowDate.getTime() - timestamp.getTime()) / MS_IN_MINUTE;\n        if (heartbeatAgeMinutes >= RECENT_HEARTBEAT_AGE_THRESHOLD) {\n            results.push({\n                status: HealthCheckStatus.Degraded,\n                description: `Worker ${index} (${address}) last heartbeat was ${heartbeatAgeMinutes} ago`,\n                label: 'worker heartbeat',\n            });\n        }\n    });\n\n    // Balances\n    const heartbeatsAboveCriticalBalanceThreshold = heartbeats.filter(({ balance }) =>\n        balance.isGreaterThanOrEqualTo(BALANCE_FAILED_THRESHOLD_WEI),\n    );\n    if (heartbeatsAboveCriticalBalanceThreshold.length === 0) {\n        results.push({\n            status: HealthCheckStatus.Failed,\n            description: `No worker has a balance greater than the failed threshold (${BALANCE_FAILED_THRESHOLD})`,\n            label: 'worker heartbeat',\n        });\n    }\n\n    const heartbeatsAboveDegradedBalanceThreshold = heartbeats.filter(({ balance }) =>\n        balance.isGreaterThan(BALANCE_DEGRADED_THRESHOLD_WEI),\n    );\n    if (heartbeatsAboveDegradedBalanceThreshold.length < 2) {\n        results.push({\n            status: HealthCheckStatus.Degraded,\n            description: `Less than two workers have a balance above the degraded threshold (${BALANCE_DEGRADED_THRESHOLD})`,\n            label: 'worker heartbeat',\n        });\n    }\n    return results;\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts",{"fileContent":"import { Signature, SignatureType } from '@0x/protocol-utils';\nimport { hexUtils } from '@0x/utils';\nimport * as ethjs from 'ethereumjs-util';\n\nconst EIP_191_PREFIX = '\\x19Ethereum Signed Message:\\n';\n\n/**\n * recovers the signer from a signature for a given order hash\n */\nexport function getSignerFromHash(hash: string, signature: Signature): string {\n    switch (signature.signatureType) {\n        case SignatureType.EIP712:\n            return ecrecover(hash, signature);\n        case SignatureType.EthSign:\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line no-case-declarations\n            const eip191Hash = getEIP191Hash(hash);\n            return ecrecover(eip191Hash, signature);\n        default:\n            throw new Error('unsupported signature type');\n    }\n}\n\nfunction getEIP191Hash(msg: string): string {\n    const byteLength = ethjs.toBuffer(msg).length;\n    const prefix = `${EIP_191_PREFIX}${byteLength}`;\n    return hexUtils.toHex(ethjs.keccak256(ethjs.toBuffer(hexUtils.concat(Buffer.from(prefix), msg))));\n}\n\nfunction ecrecover(hash: string, signature: Signature): string {\n    const pubKey = ethjs.ecrecover(\n        ethjs.toBuffer(hash),\n        signature.v,\n        ethjs.toBuffer(signature.r),\n        ethjs.toBuffer(signature.s),\n    );\n    const recAddressBuffer = ethjs.pubToAddress(pubKey);\n    return ethjs.bufferToHex(recAddressBuffer);\n}\n\n/**\n * Certain market makers are returning signatures which are missing\n * leading bytes on the `r` and/or `s` fields.\n *\n * Add them if they don't exist.\n */\nexport function padSignature(signature: Signature): Signature {\n    const hexLength = 64;\n\n    const result = { ...signature };\n\n    const hexExtractor = /^0(x|X)(?<hex>\\w+)$/;\n    const rMatch = signature.r.match(hexExtractor);\n    const rHex = rMatch?.groups?.hex;\n    if (rHex) {\n        if (rHex.length !== hexLength) {\n            result.r = `0x${rHex.padStart(hexLength, '0')}`;\n        }\n    }\n\n    const sMatch = signature.s.match(hexExtractor);\n    const sHex = sMatch?.groups?.hex;\n    if (sHex) {\n        if (sHex.length !== hexLength) {\n            result.s = `0x${sHex.padStart(hexLength, '0')}`;\n        }\n    }\n    return result;\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { Counter, Gauge, Summary } from 'prom-client';\n\nimport { logger } from '../logger';\nimport { ERC20Owner } from '../core/types';\nimport { CacheClient } from '../utils/cache_client';\nimport { RfqBalanceCheckUtils } from '../utils/rfq_blockchain_utils';\n\nconst RFQ_BALANCE_CACHE_CHECKED = new Counter({\n    name: 'rfq_balance_cache_checked',\n    help: 'Number of times we checked balance cache',\n});\nconst RFQ_BALANCE_CACHE_MISS = new Counter({\n    name: 'rfq_balance_cache_missed',\n    help: 'cache miss observed in balance cache',\n});\nconst RFQ_BALANCE_CACHE_READ_LATENCY = new Summary({\n    name: 'rfq_balance_cache_read_latency',\n    help: 'Read latency for balance cache',\n});\nconst RFQ_BALANCE_CACHE_WRITE_LATENCY = new Summary({\n    name: 'rfq_balance_cache_write_latency',\n    help: 'Write latency for balance cache',\n});\nconst RFQ_BALANCE_CACHE_EVICT_LATENCY = new Summary({\n    name: 'rfq_balance_cache_evict_latency',\n    help: 'Evict latency for balance cache',\n});\nconst RFQ_BALANCE_CACHE_NUM_ADDRESSES = new Gauge({\n    name: 'rfq_balance_cache_num_addresses',\n    help: 'Number of unique addresses in balance cache',\n});\n\n/**\n * RfqMakerBalanceCacheService is used by RfqmService to fetch maker token balances.\n * It maintains a balance cache that is periodically updated via on-chain balance checks.\n */\nexport class RfqMakerBalanceCacheService {\n    constructor(\n        private readonly _cacheClient: CacheClient,\n        private readonly _balanceCheckUtils: RfqBalanceCheckUtils,\n    ) {}\n\n    /**\n     * Gets token balances for supplied maker and token addresses from the maker balance cache.\n     * Performs a balance check if balances are not found in the cache.\n     * Returns an array of balances ordered by corresponding erc20Owner objects.\n     */\n    public async getERC20OwnerBalancesAsync(\n        chainId: number,\n        erc20Owners: ERC20Owner | ERC20Owner[],\n    ): Promise<BigNumber[]> {\n        const timerStopFunction = RFQ_BALANCE_CACHE_READ_LATENCY.startTimer();\n\n        const erc20OwnersArr = Array.isArray(erc20Owners) ? erc20Owners : [erc20Owners];\n        let cachedBalances: (BigNumber | null)[];\n        try {\n            RFQ_BALANCE_CACHE_CHECKED.inc(erc20OwnersArr.length);\n            cachedBalances = await this._cacheClient.getERC20OwnerBalancesAsync(chainId, erc20OwnersArr);\n        } catch (e) {\n            timerStopFunction();\n            logger.error({ chainId, erc20Owners }, 'Failed to read entries from maker balance cache');\n            throw e;\n        }\n\n        // On cache miss (i.e. if balance is null), add to pending maker token addresses\n        const pendingIndices: number[] = [];\n        await Promise.all(\n            cachedBalances.map(async (balance, i) => {\n                if (balance === null) {\n                    RFQ_BALANCE_CACHE_MISS.inc();\n                    await this._cacheClient.addERC20OwnerAsync(chainId, erc20OwnersArr[i]);\n                    pendingIndices.push(i);\n                }\n            }),\n        );\n\n        // Perform balance check and update balances accordingly\n        // At this point, remaining null balances will be represented as zero balances\n        // and will be subject to eviction.\n        let balances: BigNumber[];\n        if (pendingIndices.length !== 0) {\n            const fetchedBalances = await this._balanceCheckUtils.getMinOfBalancesAndAllowancesAsync(\n                erc20OwnersArr.filter((_, i) => pendingIndices.includes(i)),\n            );\n            balances = cachedBalances.map((balance) => {\n                if (balance === null) {\n                    const fetchedBalance = fetchedBalances.shift();\n                    return fetchedBalance ? fetchedBalance : new BigNumber(0);\n                }\n                // balance should be a valid BigNumber at this point\n                return balance;\n            });\n        } else {\n            // balances should not be null here\n            balances = cachedBalances.filter((balance): balance is BigNumber => balance !== null);\n        }\n\n        timerStopFunction();\n        return balances;\n    }\n\n    /**\n     * Updates cached token balances by making an on-chain balance check.\n     * All newly observed erc20Owners included in the set of maintained maker token addresses are updated.\n     */\n    public async updateERC20OwnerBalancesAsync(chainId: number): Promise<void> {\n        const timerStopFunction = RFQ_BALANCE_CACHE_WRITE_LATENCY.startTimer();\n        try {\n            const erc20Owners = await this._cacheClient.getERC20OwnersAsync(chainId);\n            if (erc20Owners.length > 0) {\n                RFQ_BALANCE_CACHE_NUM_ADDRESSES.set(erc20Owners.length);\n                const balances = await this._balanceCheckUtils.getMinOfBalancesAndAllowancesAsync(erc20Owners);\n\n                await this._cacheClient.setERC20OwnerBalancesAsync(chainId, erc20Owners, balances);\n            }\n        } catch (e) {\n            logger.error({ chainId }, 'Failed to update entries for maker balance cache');\n            throw e;\n        } finally {\n            timerStopFunction();\n        }\n    }\n\n    /**\n     * Performs eviction of stale cache entries with zero balances.\n     */\n    public async evictZeroBalancesAsync(chainId: number): Promise<number> {\n        const timerStopFunction = RFQ_BALANCE_CACHE_EVICT_LATENCY.startTimer();\n        try {\n            return this._cacheClient.evictZeroBalancesAsync(chainId);\n        } catch (e) {\n            logger.error({ chainId }, 'Failed to evict entries from maker balance cache');\n            throw e;\n        } finally {\n            timerStopFunction();\n        }\n    }\n\n    /**\n     * Safely close the maker balance cache service to avoid potential memory leak.\n     */\n    public async closeAsync(): Promise<'OK'> {\n        try {\n            return this._cacheClient.closeAsync();\n        } catch (e) {\n            logger.error({ message: e.message, stack: e.stack }, 'Failed to close RFQm maker balance cache service');\n            throw e;\n        }\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/services/WorkerService.ts",{"fileContent":"// tslint:disable:max-file-line-count\nimport { OtcOrder, Signature } from '@0x/protocol-utils';\nimport { MarketOperation } from '@0x/types';\nimport { BigNumber } from '@0x/utils';\nimport { Web3Wrapper } from '@0x/web3-wrapper';\nimport { retry } from '@lifeomic/attempt';\nimport delay from 'delay';\nimport { Counter, Gauge, Summary } from 'prom-client';\n\nimport {\n    ENABLE_LLR_COOLDOWN,\n    Integrator,\n    LLR_COOLDOWN_DURATION_SECONDS,\n    TAKER_SPECIFIED_SIDE_ENABLED,\n} from '../config';\nimport {\n    ETH_DECIMALS,\n    GAS_ESTIMATE_BUFFER,\n    GWEI_DECIMALS,\n    LLR_COOLDOWN_WINDOW_SECONDS,\n    ONE_MINUTE_S,\n    ONE_SECOND_MS,\n} from '../core/constants';\nimport { storedFeeToFee } from '../core/fee_utils';\nimport { Approval } from '../core/types';\nimport {\n    MetaTransactionJobEntity,\n    MetaTransactionSubmissionEntity,\n    RfqmV2JobEntity,\n    RfqmV2TransactionSubmissionEntity,\n} from '../entities';\nimport {\n    RfqmJobStatus,\n    RfqmTransactionSubmissionStatus,\n    RfqmTransactionSubmissionType,\n    SubmissionContextStatus,\n} from '../entities/types';\nimport { logger } from '../logger';\nimport { SignRequest } from '../quote-server/types';\nimport { CacheClient } from '../utils/cache_client';\nimport { GasStationAttendant } from '../utils/GasStationAttendant';\nimport { QuoteServerClient } from '../utils/quote_server_client';\nimport { RfqmDbUtils, storedOtcOrderToOtcOrder } from '../utils/rfqm_db_utils';\nimport { RfqBlockchainUtils } from '../utils/rfq_blockchain_utils';\nimport { RfqMakerManager } from '../utils/rfq_maker_manager';\nimport { getSignerFromHash, padSignature } from '../utils/signature_utils';\nimport { SubmissionContext } from '../utils/SubmissionContext';\n\nimport { RfqMakerBalanceCacheService } from './rfq_maker_balance_cache_service';\n\ninterface GasFees {\n    maxFeePerGas: BigNumber;\n    maxPriorityFeePerGas: BigNumber;\n}\n\n// https://stackoverflow.com/questions/47632622/typescript-and-filter-boolean\nfunction isDefined<T>(value: T): value is NonNullable<T> {\n    return value !== null && value !== undefined;\n}\n\nconst RFQM_WORKER_BALANCE = new Gauge({\n    name: 'rfqm_worker_balance',\n    labelNames: ['address', 'chain_id'],\n    help: 'Worker balance for RFQM',\n});\n\nconst RFQM_WORKER_READY = new Counter({\n    name: 'rfqm_worker_ready',\n    labelNames: ['address', 'chain_id'],\n    help: 'A worker passed the readiness check, and is ready to pick up work',\n});\n\nconst RFQM_WORKER_NOT_READY = new Counter({\n    name: 'rfqm_worker_not_ready',\n    labelNames: ['address', 'chain_id'],\n    help: 'A worker did not pass the readiness check, and was not able to pick up work',\n});\n\nconst RFQM_JOB_REPAIR = new Gauge({\n    name: 'rfqm_job_to_repair',\n    labelNames: ['address', 'chain_id'],\n    help: 'A submitted job failed and started repair mode',\n});\n\nconst RFQM_JOB_FAILED_MM_SIGNATURE_FAILED = new Counter({\n    name: 'rfqm_job_failed_mm_signature_failed',\n    help: 'A job failed because the market maker signature process failed. NOT triggered when the MM declines to sign.',\n    labelNames: ['makerUri', 'chain_id'],\n});\nconst RFQM_JOB_MM_REJECTED_LAST_LOOK = new Counter({\n    name: 'rfqm_job_mm_rejected_last_look',\n    help: 'A job rejected by market maker on last look',\n    labelNames: ['makerUri', 'chain_id'],\n});\n\nconst RFQM_PROCESS_JOB_LATENCY = new Summary({\n    name: 'rfqm_process_job_latency',\n    labelNames: ['chain_id', 'job_kind'],\n    help: 'Latency for the worker processing the job',\n});\n\nconst RFQM_JOB_COMPLETED = new Counter({\n    name: 'rfqm_job_completed',\n    help: 'An Rfqm Job completed with no errors',\n    labelNames: ['address', 'chain_id', 'job_kind'],\n});\n\nconst RFQM_JOB_COMPLETED_WITH_ERROR = new Counter({\n    name: 'rfqm_job_completed_with_error',\n    help: 'An Rfqm Job completed with an error',\n    labelNames: ['address', 'chain_id', 'job_kind'],\n});\n\nconst RFQM_CREATE_ACCESS_LIST_REQUEST = new Counter({\n    name: 'rfqm_create_access_list_request_total',\n    help: 'Number of requests for eth_createAccessList call',\n    labelNames: ['chain_id', 'status'],\n});\n\nconst RFQM_GAS_ESTIMATE_ACCESS_LIST = new Gauge({\n    name: 'rfqm_gas_estimate_acess_list',\n    help: 'Gas estimate of transaction with access list',\n    labelNames: ['chain_id'],\n});\n\nconst RFQM_GAS_ESTIMATE_NO_ACCESS_LIST = new Gauge({\n    name: 'rfqm_gas_estimate_no_access_list',\n    help: 'Gas estimate of transaction without access list',\n    labelNames: ['chain_id'],\n});\n\nconst RFQM_SIGNED_QUOTE_EXPIRY_TOO_SOON = new Counter({\n    name: 'rfqm_signed_quote_expiry_too_soon',\n    labelNames: ['chain_id'],\n    help: 'A signed quote was not queued because it would expire too soon',\n});\n\nconst RFQM_MINING_LATENCY = new Summary({\n    name: 'rfqm_mining_latency',\n    labelNames: ['chain_id'],\n    help: 'The time in seconds between when the first transaction for a job is sent and when a transaction for the job is mined',\n});\n\nconst PRICE_DECIMAL_PLACES = 6;\n\nconst MIN_GAS_PRICE_INCREASE = 0.1;\n\n// Retrying an EIP 1559 transaction: https://docs.alchemy.com/alchemy/guides/eip-1559/retry-eip-1559-tx\nconst MAX_PRIORITY_FEE_PER_GAS_MULTIPLIER = 1.5; // Increase multiplier for tip with each resubmission cycle\nconst MAX_FEE_PER_GAS_MULTIPLIER = 1.1; // Increase multiplier in max fee per gas with each cycle; limitation of geth node\n// During recovery, we may not be able to successfully execute\n// `estimateGasForAsync`. In this case we use this value.\nconst MAX_GAS_ESTIMATE = 500_000;\nconst SIMULATION_MAX_GAS_MULTIPLIER = 2; // Multiplier of configured max fee when performing transaction simulation\n\n// How often the worker should publish a heartbeat\nconst WORKER_HEARTBEAT_FREQUENCY_MS = ONE_SECOND_MS * 30; // tslint:disable-line: custom-no-magic-numbers\n\n/**\n * The service layer for Gasless Workers.\n *\n * Workers are bots with their own EOAs which pull\n * messages off an SQS queue, retrieve the related\n * job, and submit that job to the blockchain.\n */\nexport class WorkerService {\n    private _lastHeartbeatTime: Date | null = null;\n    private _maxFeePerGasCapWei: BigNumber;\n\n    public static shouldResubmitTransaction(gasFees: GasFees, gasPriceEstimate: BigNumber): boolean {\n        // Geth only allows replacement of transactions if the replacement gas price\n        // is at least 10% higher than the gas price of the transaction being replaced\n        return gasPriceEstimate.gte(gasFees.maxFeePerGas.multipliedBy(MIN_GAS_PRICE_INCREASE + 1));\n    }\n\n    // Returns a failure status for an invalid rfqm v2 job or null if job is valid.\n    public static validateRfqmV2Job(job: RfqmV2JobEntity, now: Date = new Date()): RfqmJobStatus | null {\n        const { makerUri, order, fee } = job;\n\n        if (makerUri === undefined) {\n            return RfqmJobStatus.FailedValidationNoMakerUri;\n        }\n\n        if (order === null) {\n            return RfqmJobStatus.FailedValidationNoOrder;\n        }\n\n        if (fee === null) {\n            return RfqmJobStatus.FailedValidationNoFee;\n        }\n\n        // Orders can expire if any of the following happen:\n        // 1) workers are backed up\n        // 2) an RFQM order broke during submission and the order is stuck in the queue for a long time.\n        const otcOrderStringFields = job.order.order;\n        const { expiry } = OtcOrder.parseExpiryAndNonce(new BigNumber(otcOrderStringFields.expiryAndNonce));\n        const expiryTimeMs = expiry.times(ONE_SECOND_MS);\n        if (expiryTimeMs.isNaN() || expiryTimeMs.lte(now.getTime())) {\n            return RfqmJobStatus.FailedExpired;\n        }\n        if (!job.takerSignature) {\n            return RfqmJobStatus.FailedValidationNoTakerSignature;\n        }\n\n        return null;\n    }\n\n    // Returns a failure status for an invalid meta-transaction job or null if job is valid.\n    public static validateMetaTransactionJob(\n        job: MetaTransactionJobEntity,\n        now: Date = new Date(),\n    ): RfqmJobStatus | null {\n        const { expiry, fee, metaTransaction, takerSignature } = job;\n\n        if (metaTransaction === null) {\n            return RfqmJobStatus.FailedValidationNoOrder;\n        }\n\n        if (fee === null) {\n            return RfqmJobStatus.FailedValidationNoFee;\n        }\n\n        // Orders can expire if any of the following happen:\n        // 1) workers are backed up\n        // 2) an order broke during submission and the order is stuck in the queue for a long time.\n        const expiryTimeMs = expiry.times(ONE_SECOND_MS);\n        if (expiryTimeMs.isNaN() || expiryTimeMs.lte(now.getTime())) {\n            return RfqmJobStatus.FailedExpired;\n        }\n        if (!takerSignature) {\n            return RfqmJobStatus.FailedValidationNoTakerSignature;\n        }\n\n        return null;\n    }\n\n    constructor(\n        private readonly _chainId: number,\n        private readonly _gasStationAttendant: GasStationAttendant,\n        private readonly _registryAddress: string,\n        private readonly _blockchainUtils: RfqBlockchainUtils,\n        private readonly _dbUtils: RfqmDbUtils,\n        private readonly _quoteServerClient: QuoteServerClient,\n        private readonly _transactionWatcherSleepTimeMs: number,\n        private readonly _cacheClient: CacheClient,\n        private readonly _rfqMakerBalanceCacheService: RfqMakerBalanceCacheService,\n        private readonly _rfqMakerManager: RfqMakerManager,\n        private readonly _initialMaxPriorityFeePerGasGwei: number,\n        maxFeePerGasCapGwei: number,\n        private readonly _enableAccessList?: boolean,\n    ) {\n        this._maxFeePerGasCapWei = new BigNumber(maxFeePerGasCapGwei).times(Math.pow(10, GWEI_DECIMALS));\n    }\n\n    public async workerBeforeLogicAsync(workerIndex: number, workerAddress: string): Promise<boolean> {\n        let gasPrice;\n        try {\n            gasPrice = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();\n        } catch (error) {\n            logger.error(\n                { errorMessage: error.message },\n                'Current gas price is unable to be fetched, marking worker as not ready.',\n            );\n            RFQM_WORKER_NOT_READY.labels(workerAddress, this._chainId.toString()).inc();\n            return false;\n        }\n\n        const balance = await this._blockchainUtils.getAccountBalanceAsync(workerAddress);\n        const balanceUnitAmount = Web3Wrapper.toUnitAmount(balance, ETH_DECIMALS).decimalPlaces(PRICE_DECIMAL_PLACES);\n        RFQM_WORKER_BALANCE.labels(workerAddress, this._chainId.toString()).set(balanceUnitAmount.toNumber());\n\n        // check for outstanding jobs from the worker and resolve them\n        const unresolvedJobs = await Promise.all([\n            this._dbUtils.findV2UnresolvedJobsAsync(workerAddress, this._chainId),\n            this._dbUtils.findUnresolvedMetaTransactionJobsAsync(workerAddress, this._chainId),\n        ]).then((x) => x.flat());\n\n        RFQM_JOB_REPAIR.labels(workerAddress, this._chainId.toString()).inc(unresolvedJobs.length);\n        for (const job of unresolvedJobs) {\n            const { kind } = job;\n            let jobIdentifier;\n\n            switch (kind) {\n                case 'rfqm_v2_job':\n                    jobIdentifier = job.orderHash;\n                    break;\n                case 'meta_transaction_job':\n                    jobIdentifier = job.id;\n                    break;\n                default:\n                    ((_x: never): never => {\n                        throw new Error('Unreachable');\n                    })(kind);\n            }\n\n            logger.info({ kind, jobIdentifier, workerAddress }, `Unresolved job found, attempting to reprocess`);\n            await this.processJobAsync(jobIdentifier, workerAddress, kind);\n        }\n\n        const isWorkerReady = await this._blockchainUtils.isWorkerReadyAsync(\n            this._chainId,\n            workerAddress,\n            balance,\n            BigNumber.min(gasPrice, this._maxFeePerGasCapWei),\n        );\n        if (!isWorkerReady) {\n            RFQM_WORKER_NOT_READY.labels(workerAddress, this._chainId.toString()).inc();\n            return false;\n        }\n\n        if (this._lastHeartbeatTime && Date.now() - this._lastHeartbeatTime.getTime() < WORKER_HEARTBEAT_FREQUENCY_MS) {\n            return true;\n        }\n\n        // Publish a heartbeat if the worker is ready to go\n        try {\n            if (workerIndex === undefined) {\n                throw new Error('Worker index is undefined');\n            }\n            // NOTE: when merging with `feature/multichain`, update this line with\n            // `const chainId = this._chain.chainId.\n            const chainId = this._chainId;\n            await this._dbUtils.upsertRfqmWorkerHeartbeatToDbAsync(workerAddress, workerIndex, balance, chainId);\n            this._lastHeartbeatTime = new Date();\n        } catch (error) {\n            logger.error(\n                { workerAddress, balance, errorMessage: error.message },\n                'Worker failed to write a heartbeat to storage',\n            );\n        }\n\n        RFQM_WORKER_READY.labels(workerAddress, this._chainId.toString()).inc();\n        return true;\n    }\n\n    /**\n     * Top-level logic the worker uses to take a v2 job or meta-transaction job to completion.\n     * The identifier (orderHash for v2 job and jod id for meta-transaction job) can come from\n     * either an unfinished job found during the worker before logic or from an SQS message.\n     *\n     * Big picture steps:\n     * 1. Fetch the job from the database\n     * 2. Prepare the job by validating it (and getting the market maker signature for v2 job).\n     *    This step is different for v2 and meta-transaction jobs.\n     * 3. Submit a transaction if none exist, wait for mining + confirmation,\n     *    and submit new transactions if gas prices rise\n     * 4. Finalize the job status\n     *\n     * This function is the error boundary for job processing; errors will be caught, logged\n     * and swallowed. The worker will continue along its lifecycle.\n     *\n     * This function handles processing latency metrics & job success/fail counters.\n     */\n    public async processJobAsync(\n        identifier: string,\n        workerAddress: string,\n        kind: (RfqmV2JobEntity | MetaTransactionJobEntity)['kind'] = 'rfqm_v2_job',\n    ): Promise<void> {\n        logger.info({ kind, identifier, workerAddress }, 'Start process job');\n        const timerStopFunction = RFQM_PROCESS_JOB_LATENCY.labels(this._chainId.toString(), kind).startTimer();\n\n        try {\n            // Step 1: Find the job\n            let job;\n            switch (kind) {\n                case 'rfqm_v2_job':\n                    job = await this._dbUtils.findV2JobByOrderHashAsync(identifier);\n                    break;\n                case 'meta_transaction_job':\n                    job = await this._dbUtils.findMetaTransactionJobByIdAsync(identifier);\n                    break;\n                default:\n                    ((_x: never) => {\n                        throw new Error('unreachable');\n                    })(kind);\n            }\n\n            if (!job) {\n                throw new Error('No job found for identifier');\n            }\n\n            // Step 2: Prepare the job for submission\n\n            // Claim job for worker\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-extra-non-null-assertion\n            if (job.workerAddress!! && job.workerAddress !== workerAddress) {\n                throw new Error('Worker was sent a job claimed by a different worker');\n            }\n            job.workerAddress = workerAddress;\n            await this._dbUtils.updateRfqmJobAsync(job);\n            if (job.approval) {\n                // approval and trade workflow\n                await this.processApprovalAndTradeAsync(job, workerAddress);\n            } else {\n                // trade only workflow\n                await this.processTradeAsync(job, workerAddress);\n            }\n            logger.info({ kind, identifier, workerAddress }, 'Job completed without errors');\n            RFQM_JOB_COMPLETED.labels(workerAddress, this._chainId.toString(), kind).inc();\n        } catch (error) {\n            logger.error({ kind, workerAddress, identifier, errorMessage: error.message }, 'Job completed with error');\n            RFQM_JOB_COMPLETED_WITH_ERROR.labels(workerAddress, this._chainId.toString(), kind).inc();\n        } finally {\n            timerStopFunction();\n        }\n    }\n\n    /**\n     * Process approval (gasless approval) and trade (swap with the 0x exchange proxy) submissions. For the first version,\n     * they will be processed SEQUENTIALLY. In the future, we want to send the two transaction in parallel.\n     * The reason we can't parallelize the submissions is both function would modify job.status.\n     *\n     * The method would:\n     * 1. Perform preliminary check on the job object (and updates job status to `PendingProcessing`)\n     * 2. Getting the market maker signature\n     * 3. Prepare approval\n     * 4. Submit approval\n     * 5. Wait until the approval transaction is successfully confirmed\n     * 6. Prepare trade (since the method has already got the market maker signature, it's not performed here)\n     * 7. Submit trade\n     */\n    public async processApprovalAndTradeAsync(\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\n        workerAddress: string,\n    ): Promise<void> {\n        const { approval, approvalSignature, kind } = job;\n        if (!approval || !approvalSignature) {\n            throw new Error('Non-approval job should not be processed by `processApprovalAndTradeAsync`');\n        }\n\n        // Perform preliminary check\n        await this.checkJobPreprocessingAsync(job);\n        if (kind === 'rfqm_v2_job') {\n            // Perform last look for rfqm v2 job\n            await this.checkLastLookAsync(job, workerAddress, false);\n        }\n\n        let tokenToApprove;\n        let identifier;\n        switch (kind) {\n            case 'rfqm_v2_job':\n                tokenToApprove = job.order.order.takerToken;\n                identifier = job.orderHash;\n                break;\n            case 'meta_transaction_job':\n                tokenToApprove = job.inputToken;\n                identifier = job.id;\n                break;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n\n        const approvalCalldata = await this.prepareApprovalAsync(job, tokenToApprove, approval, approvalSignature);\n        const approvalStatus = await this.submitToChainAsync({\n            kind: job.kind,\n            to: tokenToApprove,\n            from: workerAddress,\n            calldata: approvalCalldata,\n            expiry: job.expiry,\n            identifier,\n            submissionType: RfqmTransactionSubmissionType.Approval,\n            onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(\n                job,\n                RfqmTransactionSubmissionType.Approval,\n            ),\n        });\n\n        // Prepare and submit trade only if approval transaction is successful\n        if (approvalStatus === SubmissionContextStatus.SucceededConfirmed) {\n            let tradeCalldata;\n            switch (kind) {\n                case 'rfqm_v2_job':\n                    tradeCalldata = await this.preparerfqmV2TradeAsync(job, workerAddress, false);\n                    break;\n                case 'meta_transaction_job':\n                    tradeCalldata = await this.prepareMetaTransactionTradeAsync(job, workerAddress, false);\n                    break;\n                default:\n                    ((_x: never) => {\n                        throw new Error('unreachable');\n                    })(kind);\n            }\n\n            await this.submitToChainAsync({\n                kind: job.kind,\n                to: this._blockchainUtils.getExchangeProxyAddress(),\n                from: workerAddress,\n                calldata: tradeCalldata,\n                expiry: job.expiry,\n                identifier,\n                submissionType: RfqmTransactionSubmissionType.Trade,\n                onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(\n                    job,\n                    RfqmTransactionSubmissionType.Trade,\n                ),\n            });\n        }\n    }\n\n    /**\n     * Process trade (swap with the 0x exchange proxy) submissions. The method would prepare trade calldata\n     * and submit the trade to the blockchain. Note that job status would be updated to the corresponding state.\n     */\n    public async processTradeAsync(\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\n        workerAddress: string,\n    ): Promise<void> {\n        const { kind } = job;\n\n        let calldata;\n        let identifier;\n        switch (kind) {\n            case 'rfqm_v2_job':\n                identifier = job.orderHash;\n                calldata = await this.preparerfqmV2TradeAsync(job, workerAddress);\n                break;\n            case 'meta_transaction_job':\n                identifier = job.id;\n                calldata = await this.prepareMetaTransactionTradeAsync(job, workerAddress);\n                break;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n\n        await this.submitToChainAsync({\n            kind: job.kind,\n            to: this._blockchainUtils.getExchangeProxyAddress(),\n            from: workerAddress,\n            calldata,\n            expiry: job.expiry,\n            identifier,\n            submissionType: RfqmTransactionSubmissionType.Trade,\n            onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(\n                job,\n                RfqmTransactionSubmissionType.Trade,\n            ),\n        });\n    }\n\n    /**\n     * Perform preliminary checks on a job before processing.\n     *\n     * The method would:\n     * 1. Call `RfqmService.validateRfqmV2Job` / `RfqmService.validateMetaTransactionJob` and check result. If there is an error, update the job status and throw exception\n     * 2. Make sure job.takerSignature is present or throw exception\n     * 3. Update job status to `PendingProcessing` if current status is `PendingEnqueued`\n     */\n    public async checkJobPreprocessingAsync(\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\n        now: Date = new Date(),\n    ): Promise<void> {\n        const { kind, takerSignature } = job;\n        let identifier;\n        let errorStatus;\n\n        switch (kind) {\n            case 'rfqm_v2_job':\n                identifier = job.orderHash;\n                errorStatus = WorkerService.validateRfqmV2Job(job, now);\n                break;\n            case 'meta_transaction_job':\n                identifier = job.id;\n                errorStatus = WorkerService.validateMetaTransactionJob(job, now);\n                break;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n\n        if (errorStatus !== null) {\n            job.status = errorStatus;\n            await this._dbUtils.updateRfqmJobAsync(job);\n\n            if (errorStatus === RfqmJobStatus.FailedExpired) {\n                RFQM_SIGNED_QUOTE_EXPIRY_TOO_SOON.labels(this._chainId.toString()).inc();\n            }\n            logger.error({ kind, identifier, errorStatus }, 'Job failed validation');\n            throw new Error('Job failed validation');\n        }\n\n        // Existence of taker signature has already been checked by\n        // `RfqmService.validateJob(job)`. Refine the type.\n        if (!takerSignature) {\n            throw new Error('No taker signature present');\n        }\n\n        if (job.status === RfqmJobStatus.PendingEnqueued) {\n            job.status = RfqmJobStatus.PendingProcessing;\n            await this._dbUtils.updateRfqmJobAsync(job);\n        }\n    }\n\n    /**\n     * Prepares a rfqm v2 / meta-transaction job for approval submission by validatidating the job and constructing\n     * the calldata.\n     *\n     * Note that `job.status` would be modified to `FailedEthCallFailed` if transaction simulation failed.\n     *\n     * Handles retries of retryable errors. Throws for unretriable errors. Updates job in database.\n     *\n     * @returns The generated calldata for approval submission type.\n     * @throws If the approval cannot be submitted (e.g. it is expired).\n     */\n    public async prepareApprovalAsync(\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\n        tokenToApprove: string,\n        approval: Approval,\n        siganature: Signature,\n    ): Promise<string> {\n        const { kind } = job;\n        const calldata = await this._blockchainUtils.generateApprovalCalldataAsync(\n            tokenToApprove,\n            approval,\n            siganature,\n        );\n\n        let identifier;\n        let transactionSubmissions;\n        // Check to see if we have already submitted an approval transaction for this job. If we have, the job has already\n        // been checked and we can skip `eth_call` validation.\n        switch (kind) {\n            case 'rfqm_v2_job':\n                identifier = job.orderHash;\n                transactionSubmissions = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                    identifier,\n                    RfqmTransactionSubmissionType.Approval,\n                );\n                break;\n            case 'meta_transaction_job':\n                identifier = job.id;\n                transactionSubmissions = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(\n                    identifier,\n                    RfqmTransactionSubmissionType.Approval,\n                );\n                break;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n\n        if (transactionSubmissions.length) {\n            if (!job.takerSignature) {\n                // This shouldn't happen\n                throw new Error('Encountered a job with submissions but no taker signature');\n            }\n            if (job.kind === 'rfqm_v2_job' && !job.makerSignature) {\n                // This shouldn't happen\n                throw new Error('Encountered a job with submissions but no maker signature');\n            }\n\n            return calldata;\n        }\n\n        // Simulate the transaction\n        try {\n            await retry(\n                async () => {\n                    // Use `estimateGasForAsync` to simulate the transaction. In ethers.js, provider.call and\n                    // provider.send('eth_call', ...) might not throw exception and the behavior might be dependent\n                    // on providers. Revisit this later\n                    return this._blockchainUtils.estimateGasForAsync({ to: tokenToApprove, data: calldata });\n                },\n                {\n                    delay: ONE_SECOND_MS,\n                    factor: 1,\n                    maxAttempts: 3,\n                    handleError: (error, context, _options) => {\n                        const { attemptNum: attemptNumber, attemptsRemaining } = context;\n                        logger.warn(\n                            { kind, attemptNumber, attemptsRemaining, errorMessage: error.message, stack: error.stack },\n                            'Error during eth_call approval validation. Retrying.',\n                        );\n                    },\n                },\n            );\n        } catch (error) {\n            job.status = RfqmJobStatus.FailedEthCallFailed;\n            await this._dbUtils.updateRfqmJobAsync(job);\n\n            logger.error(\n                { kind, identifier, errorMessage: error.message, stack: error.stack },\n                'eth_call approval validation failed',\n            );\n            throw new Error('Eth call approval validation failed');\n        }\n\n        return calldata;\n    }\n\n    /**\n     * Prepares an RfqmV2 Job for trade submission by validatidating the job, obtaining the\n     * market maker signature, and constructing the calldata.\n     *\n     * Note that `job.status` would be modified to corresponding status. For example, if maker signature\n     * is not valid, `job.status` would be set to `FailedSignFailed`.\n     *\n     * `shouldCheckLastLook` determines if the preliminary job check and getting market maker sigature\n     * would be performed and is default to `true`.\n     *\n     * Handles retries of retryable errors. Throws for unretriable errors, and logs\n     * ONLY IF the log needs more information than the orderHash and workerAddress,\n     * which are logged by the `processJobAsync` routine.\n     * Updates job in database.\n     *\n     * @returns The generated calldata for trade submission type.\n     * @throws If the trade cannot be submitted (e.g. it is expired).\n     */\n    public async preparerfqmV2TradeAsync(\n        job: RfqmV2JobEntity,\n        workerAddress: string,\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-inferrable-types\n        shouldCheckLastLook: boolean = true,\n        now: Date = new Date(),\n    ): Promise<string> {\n        /**\n         * Ask: This is the probably the only change I made to the old trade only workflow. To change from making a copy of parameter\n         * and then returning the copied value to change parameter value directly. The rationale behind is to make the style consistent\n         * with the new generalized `submitToChainAsync` (it has to use changing parameter value paradigm in order to work). Let me know\n         * if you don't like this change.\n         */\n        const { makerUri, order, orderHash } = job;\n        const otcOrder = storedOtcOrderToOtcOrder(order);\n\n        // Check to see if we have already submitted a transaction for this job.\n        // If we have, the job is already prepared and we can skip ahead.\n        const transactionSubmissions = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(job.orderHash);\n        if (transactionSubmissions.length) {\n            if (!job.makerSignature) {\n                // This shouldn't happen\n                throw new Error('Encountered a job with submissions but no maker signature');\n            }\n            if (!job.takerSignature) {\n                // This shouldn't happen\n                throw new Error('Encountered a job with submissions but no taker signature');\n            }\n            const existingSubmissionCalldata = this._blockchainUtils.generateTakerSignedOtcOrderCallData(\n                otcOrder,\n                job.makerSignature,\n                job.takerSignature,\n                job.isUnwrap,\n                job.affiliateAddress,\n            );\n            return existingSubmissionCalldata;\n        }\n\n        if (shouldCheckLastLook) {\n            // Perform the preliminary job check and getting market maker sigature\n            await this.checkJobPreprocessingAsync(job, now);\n            await this.checkLastLookAsync(job, workerAddress, true);\n        }\n\n        // Maker signature must already be defined here -- refine the type\n        if (!job.makerSignature) {\n            throw new Error('Maker signature does not exist');\n        }\n        // Taker signature must already be defined here -- refine the type\n        if (!job.takerSignature) {\n            throw new Error('Taker signature does not exist');\n        }\n\n        // Verify the signer was the maker\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const signerAddress = getSignerFromHash(orderHash, job.makerSignature!).toLowerCase();\n        const makerAddress = order.order.maker.toLowerCase();\n        if (signerAddress !== makerAddress) {\n            logger.info({ signerAddress, makerAddress, orderHash, makerUri }, 'Possible use of smart contract wallet');\n            const isValidSigner = await this._blockchainUtils.isValidOrderSignerAsync(makerAddress, signerAddress);\n            if (!isValidSigner) {\n                job.status = RfqmJobStatus.FailedSignFailed;\n                await this._dbUtils.updateRfqmJobAsync(job);\n                throw new Error('Invalid order signer address');\n            }\n        }\n\n        // Generate the calldata\n        const calldata = this._blockchainUtils.generateTakerSignedOtcOrderCallData(\n            otcOrder,\n            job.makerSignature,\n            job.takerSignature,\n            job.isUnwrap,\n            job.affiliateAddress,\n        );\n\n        // With the Market Maker signature, execute a full eth_call to validate the\n        // transaction via `estimateGasForFillTakerSignedOtcOrderAsync`\n        try {\n            await retry(\n                async () => {\n                    // Maker signature must already be defined here -- refine the type\n                    if (!job.makerSignature) {\n                        throw new Error('Maker signature does not exist');\n                    }\n                    // Taker signature must already be defined here -- refine the type\n                    if (!job.takerSignature) {\n                        throw new Error('Taker signature does not exist');\n                    }\n\n                    return this._blockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(\n                        otcOrder,\n                        job.makerSignature,\n                        job.takerSignature,\n                        workerAddress,\n                        job.isUnwrap,\n                    );\n                },\n                {\n                    delay: ONE_SECOND_MS,\n                    factor: 1,\n                    maxAttempts: 3,\n                    handleError: (error, context, _options) => {\n                        const { attemptNum: attemptNumber, attemptsRemaining } = context;\n                        logger.warn(\n                            { orderHash, makerUri, attemptNumber, attemptsRemaining, error: error.message },\n                            'Error during eth_call validation when preparing otc order trade. Retrying',\n                        );\n                    },\n                },\n            );\n        } catch (error) {\n            job.status = RfqmJobStatus.FailedEthCallFailed;\n            await this._dbUtils.updateRfqmJobAsync(job);\n\n            logger.error(\n                { orderHash, error: error.message },\n                'eth_call validation failed when preparing otc order trade',\n            );\n\n            // Attempt to gather extra context upon eth_call failure\n            try {\n                const [makerBalance] = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(\n                    this._chainId,\n                    { owner: otcOrder.maker, token: otcOrder.makerToken },\n                );\n                const [takerBalance] = await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync({\n                    owner: otcOrder.taker,\n                    token: otcOrder.takerToken,\n                });\n                const blockNumber = await this._blockchainUtils.getCurrentBlockAsync();\n                logger.info(\n                    {\n                        makerBalance,\n                        takerBalance,\n                        calldata,\n                        blockNumber,\n                        orderHash,\n                        order: otcOrder,\n                        bucket: otcOrder.nonceBucket,\n                        nonce: otcOrder.nonce,\n                    },\n                    'Extra context after eth_call validation failed when preparing otc order trade',\n                );\n            } catch (error) {\n                logger.warn(\n                    { orderHash },\n                    'Failed to get extra context after eth_call validation failed when preparing otc order trade',\n                );\n            }\n            throw new Error('Eth call validation failed when preparing otc order trade');\n        }\n\n        return calldata;\n    }\n\n    /**\n     * Prepares a meta-transaction job for trade submission by validatidating the job and constructing the calldata.\n     *\n     * Note that `job.status` would be modified to corresponding status. For example, if the meta-transaction expires,\n     * `job.status` would be set to `FailedFailedExpired`.\n     *\n     * Handles retries of retryable errors. Throws for unretriable errors, and logs\n     * ONLY IF the log needs more information than the orderHash and workerAddress,\n     * which are logged by the `processJobAsync` routine.\n     * Updates job in database.\n     *\n     * @returns The generated calldata for trade submission type.\n     * @throws If the trade cannot be submitted (e.g. it is expired).\n     */\n    public async prepareMetaTransactionTradeAsync(\n        job: MetaTransactionJobEntity,\n        workerAddress: string,\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-inferrable-types\n        shouldValidateJob: boolean = true,\n        now: Date = new Date(),\n    ): Promise<string> {\n        // ASK: What's the difference bewtween `metaTransaction.signer` vs `metaTransaction.sender`?\n        //      Which one is the taker address?\n        const { affiliateAddress, id: jobId, inputToken, metaTransaction, takerAddress, takerSignature } = job;\n\n        // Check to see if we have already submitted a transaction for this job.\n        // If we have, the job is already prepared and we can skip ahead.\n        const transactionSubmissions = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId);\n        if (transactionSubmissions.length) {\n            if (!takerSignature) {\n                // This shouldn't happen\n                throw new Error('Encountered a job with submissions but no taker signature');\n            }\n            const existingSubmissionCalldata = this._blockchainUtils.generateMetaTransactionCallData(\n                metaTransaction,\n                takerSignature,\n                affiliateAddress,\n            );\n            return existingSubmissionCalldata;\n        }\n\n        if (shouldValidateJob) {\n            // Perform the preliminary job check\n            await this.checkJobPreprocessingAsync(job, now);\n        }\n\n        // Taker signature must already be defined here -- refine the type\n        if (!takerSignature) {\n            throw new Error('Taker signature does not exist');\n        }\n\n        // Generate the calldata\n        const calldata = this._blockchainUtils.generateMetaTransactionCallData(\n            metaTransaction,\n            takerSignature,\n            affiliateAddress,\n        );\n\n        // execute a full eth_call to validate the\n        // transaction via `estimateGasForAsync`\n        try {\n            await retry(\n                async () => {\n                    // The following gas fee operations are added because `executeMetaTransaction` in 0x Exchange Proxy\n                    // would check whether the gas price of the transaction is within a window. If left empty, it will\n                    // fail the simulation. The gas fee estimation below is the same as the first gas fee estimation\n                    // used in `submitToChain`.\n                    const gasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();\n                    const initialMaxPriorityFeePerGas = new BigNumber(this._initialMaxPriorityFeePerGasGwei).times(\n                        Math.pow(10, GWEI_DECIMALS),\n                    );\n                    const gasFees: GasFees = {\n                        maxFeePerGas: BigNumber.min(\n                            gasPriceEstimate.multipliedBy(2).plus(initialMaxPriorityFeePerGas),\n                            // If the max fee is less than the base fee, simulations will fail (unlike submissions, which may sit in the mempool).\n                            // An extra multiplier mitigates, but does not solve, the issue.\n                            this._maxFeePerGasCapWei.multipliedBy(SIMULATION_MAX_GAS_MULTIPLIER),\n                        ),\n                        maxPriorityFeePerGas: initialMaxPriorityFeePerGas,\n                    };\n\n                    return this._blockchainUtils.estimateGasForAsync({\n                        from: workerAddress,\n                        to: this._blockchainUtils.getExchangeProxyAddress(),\n                        data: calldata,\n                        maxFeePerGas: gasFees.maxFeePerGas.toString(),\n                        maxPriorityFeePerGas: gasFees.maxPriorityFeePerGas.toString(),\n                    });\n                },\n                {\n                    delay: ONE_SECOND_MS,\n                    factor: 1,\n                    maxAttempts: 3,\n                    handleError: (error, context, _options) => {\n                        const { attemptNum: attemptNumber, attemptsRemaining } = context;\n                        logger.warn(\n                            { jobId, attemptNumber, attemptsRemaining, error: error.message },\n                            'Error during eth_call validation when preparing meta-transaction trade. Retrying',\n                        );\n                    },\n                },\n            );\n        } catch (error) {\n            job.status = RfqmJobStatus.FailedEthCallFailed;\n            await this._dbUtils.updateRfqmJobAsync(job);\n\n            logger.error(\n                { jobId, error: error.message },\n                'eth_call validation failed when preparing meta-transaction trade',\n            );\n\n            // Attempt to gather extra context upon eth_call failure\n            try {\n                const [takerBalance] = await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync([\n                    { owner: takerAddress, token: inputToken },\n                ]);\n                const blockNumber = await this._blockchainUtils.getCurrentBlockAsync();\n                logger.info(\n                    {\n                        calldata,\n                        blockNumber,\n                        jobId,\n                        metaTransaction,\n                        takerBalance,\n                    },\n                    'Extra context after eth_call validation failed when preparing meta-transaction trade',\n                );\n            } catch (error) {\n                logger.warn(\n                    { jobId },\n                    'Failed to get extra context after eth_call validation failed when preparing meta-transaction trade ',\n                );\n            }\n            throw new Error('Eth call validation failed when preparing meta-transaction trade');\n        }\n\n        return calldata;\n    }\n\n    /**\n     * Check last look by getting market maker signature. Handles retries when making request to market maker servers.\n     *\n     * When verifying the order is fillable by both the maker and the taker:\n     * - If `shouldCheckAllowance` is false, the method would only check balances but not the allowances the maker and\n     *   the taker set for 0x exchange proxy because the taker allowance will not be set when `checkLastLookAsync` is called as we\n     *   want to call this method as soon as possible to mitigate the latency brought by sequential submissions\n     *   (which would lead to higher decline to sign rate).\n     * - Otherwise, both balances and allowances would be checked.\n     */\n    public async checkLastLookAsync(\n        job: RfqmV2JobEntity,\n        workerAddress: string,\n        shouldCheckAllowance: boolean,\n    ): Promise<void> {\n        const { makerUri, order, orderHash, takerSignature } = job;\n        const otcOrder = storedOtcOrderToOtcOrder(order);\n        let { makerSignature } = job;\n\n        if (makerSignature) {\n            // Market Maker had already signed order\n            logger.info({ workerAddress, orderHash }, 'Order already signed');\n        } else {\n            // validate that order is fillable by both the maker and the taker according to balances (and allowances\n            // when `shouldCheckAllowance` is true)\n            const [makerBalance] = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(this._chainId, {\n                owner: otcOrder.maker,\n                token: otcOrder.makerToken,\n            });\n            const [takerBalance] = shouldCheckAllowance\n                ? await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync({\n                      owner: otcOrder.taker,\n                      token: otcOrder.takerToken,\n                  })\n                : await this._blockchainUtils.getTokenBalancesAsync({\n                      owner: otcOrder.taker,\n                      token: otcOrder.takerToken,\n                  });\n\n            if (makerBalance.lt(otcOrder.makerAmount) || takerBalance.lt(otcOrder.takerAmount)) {\n                logger.error(\n                    {\n                        orderHash,\n                        makerBalance,\n                        takerBalance,\n                        makerAmount: otcOrder.makerAmount,\n                        takerAmount: otcOrder.takerAmount,\n                    },\n                    'Order failed pre-sign validation',\n                );\n                job.status = RfqmJobStatus.FailedPresignValidationFailed;\n                await this._dbUtils.updateRfqmJobAsync(job);\n                throw new Error('Order failed pre-sign validation');\n            }\n\n            if (!takerSignature) {\n                logger.error('Order failed pre-sign validation due to empty takerSignature');\n                job.status = RfqmJobStatus.FailedPresignValidationFailed;\n                await this._dbUtils.updateRfqmJobAsync(job);\n                throw new Error('Order failed pre-sign validation due to empty takerSignature');\n            }\n\n            const trader = getSignerFromHash(orderHash, takerSignature);\n\n            const signRequest: SignRequest = {\n                expiry: job.expiry,\n                fee: storedFeeToFee(job.fee),\n                order: otcOrder,\n                orderHash,\n                takerSignature,\n                workflow: 'rfqm',\n                trader: trader,\n                ...(job.takerSpecifiedSide &&\n                    TAKER_SPECIFIED_SIDE_ENABLED && { takerSpecifiedSide: job.takerSpecifiedSide }),\n            };\n\n            // \"Last Look\" in v1 is replaced by market maker order signing in v2.\n            const signAttemptTimeMs = Date.now();\n            try {\n                makerSignature = await retry(\n                    async () =>\n                        this._quoteServerClient\n                            .signV2Async(makerUri, job.integratorId ?? '', signRequest)\n                            .then((s) => s ?? null),\n                    {\n                        delay: ONE_SECOND_MS,\n                        factor: 2,\n                        maxAttempts: 3,\n                        handleError: (error, context, _options) => {\n                            const { attemptNum: attemptNumber, attemptsRemaining } = context;\n                            logger.warn(\n                                { orderHash, makerUri, attemptNumber, attemptsRemaining, error: error.message },\n                                'Error encountered while attempting to get market maker signature',\n                            );\n                        },\n                    },\n                );\n            } catch (error) {\n                // The sign process has failed after retries\n                RFQM_JOB_FAILED_MM_SIGNATURE_FAILED.labels(makerUri, this._chainId.toString()).inc();\n                logger.error(\n                    { orderHash, makerUri, error: error.message },\n                    'RFQM v2 job failed due to market maker sign failure',\n                );\n                job.status = RfqmJobStatus.FailedSignFailed;\n                await this._dbUtils.updateRfqmJobAsync(job);\n                throw new Error('Job failed during market maker sign attempt');\n            }\n\n            logger.info({ makerUri, signed: !!makerSignature, orderHash }, 'Got signature response from market maker');\n            if (!makerSignature) {\n                // Market Maker has declined to sign the transaction\n                RFQM_JOB_MM_REJECTED_LAST_LOOK.labels(makerUri, this._chainId.toString()).inc();\n                job.lastLookResult = false;\n                job.status = RfqmJobStatus.FailedLastLookDeclined;\n                await this._dbUtils.updateRfqmJobAsync(job);\n\n                if (ENABLE_LLR_COOLDOWN) {\n                    try {\n                        const quote = await this._dbUtils.findV2QuoteByOrderHashAsync(orderHash);\n                        if (quote === null) {\n                            throw new Error(`Failed to find quote with order hash ${orderHash}`);\n                        }\n\n                        // `bad` last look rejection, rejected within the cooldown window\n                        if (\n                            signAttemptTimeMs - quote.createdAt.valueOf() <\n                            LLR_COOLDOWN_WINDOW_SECONDS * ONE_SECOND_MS\n                        ) {\n                            const makerId = this._rfqMakerManager.findMakerIdWithRfqmUri(makerUri);\n                            if (makerId === null) {\n                                throw new Error(`Failed to find maker ID with RFQm URI ${makerUri}`);\n                            }\n\n                            const cooldownEndTimeMs = signAttemptTimeMs + LLR_COOLDOWN_DURATION_SECONDS * ONE_SECOND_MS;\n\n                            // schedule cooldown\n                            const isScheduleUpdated = await this._cacheClient.addMakerToCooldownAsync(\n                                makerId,\n                                cooldownEndTimeMs,\n                                this._chainId,\n                                otcOrder.makerToken,\n                                otcOrder.takerToken,\n                            );\n\n                            logger.info(\n                                {\n                                    makerId,\n                                    chainId: this._chainId,\n                                    makerToken: otcOrder.makerToken,\n                                    takerToken: otcOrder.takerToken,\n                                    startTime: signAttemptTimeMs,\n                                    endTime: cooldownEndTimeMs,\n                                    orderHash,\n                                    isScheduleUpdated,\n                                },\n                                'LLR cooldown scheduled',\n                            );\n\n                            try {\n                                // insert cooldown entry to db for record keeping\n                                await this._dbUtils.writeV2LastLookRejectionCooldownAsync(\n                                    makerId,\n                                    this._chainId,\n                                    otcOrder.makerToken,\n                                    otcOrder.takerToken,\n                                    new Date(signAttemptTimeMs), // startTime\n                                    new Date(cooldownEndTimeMs), // endTime\n                                    orderHash,\n                                );\n                            } catch (e) {\n                                logger.warn({ orderHash, errorMessage: e.message }, 'Saving LLR cooldown failed');\n                            }\n                        }\n                    } catch (error) {\n                        logger.warn(\n                            { errorMessage: error.message },\n                            'Encountered error when detecting bad LLR and scheduling cooldown',\n                        );\n                    }\n                }\n\n                // We'd like some data on how much the price the market maker is offering\n                // has changed. We query the market maker's price endpoint with the same\n                // trade they've just declined to sign and log the result.\n                try {\n                    const declineToSignPriceCheckTimeMs = Date.now();\n                    const otcOrderParams = QuoteServerClient.makeQueryParameters({\n                        chainId: this._chainId,\n                        txOrigin: this._registryAddress,\n                        takerAddress: otcOrder.taker,\n                        marketOperation: MarketOperation.Sell,\n                        buyTokenAddress: otcOrder.makerToken,\n                        sellTokenAddress: otcOrder.takerToken,\n                        assetFillAmount: otcOrder.takerAmount,\n                        isLastLook: true,\n                        fee: storedFeeToFee(job.fee),\n                    });\n                    // Instead of adding a dependency to `ConfigManager` to get the actual integrator\n                    // (we only have the ID at this point), just create a stand-in.\n                    // This will send the same integrator ID to the market maker; they will not be\n                    // able to tell the difference.\n                    // `logRfqMakerNetworkInteraction` does use the `label`, however, but I think the\n                    // tradeoff is reasonable.\n                    const integrator: Integrator = {\n                        apiKeys: [],\n                        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        integratorId: job.integratorId!,\n                        allowedChainIds: [this._chainId],\n                        label: 'decline-to-sign-price-check',\n                        plp: true,\n                        rfqm: true,\n                        rfqt: true,\n                    };\n                    const priceResponse = await this._quoteServerClient.getPriceV2Async(\n                        job.makerUri,\n                        integrator,\n                        otcOrderParams,\n                        (u: string) => `${u}/rfqm/v2/price`,\n                    );\n                    if (!priceResponse) {\n                        throw new Error('Failed to get a price response');\n                    }\n                    const { makerAmount: priceCheckMakerAmount, takerAmount: priceCheckTakerAmount } = priceResponse;\n                    const originalPrice = otcOrder.makerAmount.dividedBy(priceCheckTakerAmount);\n                    const priceAfterReject = priceCheckMakerAmount.dividedBy(priceCheckTakerAmount);\n                    const bipsFactor = 10000;\n                    const priceDifferenceBips = originalPrice\n                        .minus(priceAfterReject)\n                        .dividedBy(originalPrice)\n                        .absoluteValue()\n                        .times(bipsFactor)\n                        .toPrecision(1);\n                    // The time, in seconds, between when we initiated the sign attempt and when we\n                    // initiated the price check after the maker declined to sign.\n                    const priceCheckDelayS = (declineToSignPriceCheckTimeMs - signAttemptTimeMs) / ONE_SECOND_MS;\n                    logger.info(\n                        {\n                            orderHash,\n                            originalPrice: originalPrice.toNumber(),\n                            priceAfterReject: priceAfterReject.toNumber(),\n                            priceCheckDelayS,\n                            priceDifferenceBips,\n                        },\n                        'Decline to sign price check',\n                    );\n                    try {\n                        job.llRejectPriceDifferenceBps = parseInt(priceDifferenceBips, 10);\n                        await this._dbUtils.updateRfqmJobAsync(job);\n                    } catch (e) {\n                        logger.warn({ orderHash, errorMessage: e.message }, 'Saving LL reject price difference failed');\n                    }\n                } catch (error) {\n                    logger.warn(\n                        { errorMessage: error.message },\n                        'Encountered error during decline to sign price check',\n                    );\n                }\n                throw new Error('Market Maker declined to sign');\n            }\n\n            // Certain market makers are returning signature components which are missing\n            // leading bytes. Add them if they don't exist.\n            const paddedSignature = padSignature(makerSignature);\n            if (paddedSignature.r !== makerSignature.r || paddedSignature.s !== makerSignature.s) {\n                logger.warn(\n                    { orderHash, r: paddedSignature.r, s: paddedSignature.s },\n                    'Got market maker signature with missing bytes',\n                );\n                makerSignature = paddedSignature;\n            }\n\n            job.makerSignature = paddedSignature;\n            job.lastLookResult = true;\n            job.status = RfqmJobStatus.PendingLastLookAccepted;\n            await this._dbUtils.updateRfqmJobAsync(job);\n        }\n\n        // Maker signature must already be defined here -- refine the type\n        if (!makerSignature) {\n            throw new Error('Maker signature does not exist');\n        }\n\n        // Verify the signer was the maker\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const signerAddress = getSignerFromHash(orderHash, makerSignature!).toLowerCase();\n        const makerAddress = order.order.maker.toLowerCase();\n        if (signerAddress !== makerAddress) {\n            logger.info({ signerAddress, makerAddress, orderHash, makerUri }, 'Possible use of smart contract wallet');\n            const isValidSigner = await this._blockchainUtils.isValidOrderSignerAsync(makerAddress, signerAddress);\n            if (!isValidSigner) {\n                job.status = RfqmJobStatus.FailedSignFailed;\n                await this._dbUtils.updateRfqmJobAsync(job);\n                throw new Error('Invalid order signer address');\n            }\n        }\n    }\n\n    /**\n     * Submits a specific type of submission to the blockchain.\n     *\n     * First checks to see if there are previous transactions with the submission type and enters the\n     * watch loop; if not, submits an initial transaction and enters the watch loop.\n     *\n     * During the watch loop, waits for a transaction to be mined and confirmed;\n     * replaces the transaction if gas prices rise while a transactions are in the mempool.\n     *\n     * @param opts Options object that contains:\n     *        - `to`: The address to send to.\n     *        - `from`: The address submitting the transaction (usually the worker address).\n     *        - `calldata`: Calldata to submit.\n     *        - `expiry`: Exiry before the submission is considered invalid.\n     *        - `identifier`: The job identifier. For rfqm_v2_job, it should be order hash; for meta-transaction, it should be job id.\n     *        - `submissionType`: The type of submission.\n     *        - `onSubmissionContextStatusUpdate`: Callback to perform appropriate actions when the submission context statuses change.\n     *        - `now`: The current time.\n     * @returns FailedRevertedConfirmed or SucceededConfirmed.\n     * @throws Submission context status is FailedExpired or unhandled exceptions.\n     */\n    public async submitToChainAsync(opts: {\n        kind: (RfqmV2JobEntity | MetaTransactionJobEntity)['kind'];\n        to: string;\n        from: string;\n        calldata: string;\n        expiry: BigNumber;\n        identifier: string;\n        submissionType: RfqmTransactionSubmissionType;\n        onSubmissionContextStatusUpdate: (\n            newSubmissionContextStatus: SubmissionContextStatus,\n            oldSubmissionContextStatus?: SubmissionContextStatus,\n        ) => Promise<void>;\n    }): Promise<SubmissionContextStatus.FailedRevertedConfirmed | SubmissionContextStatus.SucceededConfirmed> {\n        const { kind, to, from, calldata, expiry, identifier, submissionType, onSubmissionContextStatusUpdate } = opts;\n\n        let previousSubmissionsWithPresubmits;\n        switch (kind) {\n            case 'rfqm_v2_job':\n                previousSubmissionsWithPresubmits = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                    identifier,\n                    submissionType,\n                );\n                break;\n            case 'meta_transaction_job':\n                previousSubmissionsWithPresubmits = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(\n                    identifier,\n                    submissionType,\n                );\n                break;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n\n        const previousSubmissions = await this._recoverPresubmitTransactionsAsync(previousSubmissionsWithPresubmits);\n\n        const gasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();\n\n        // For the first submission, we use the \"fast\" gas estimate to approximate the base fee.\n        // We use the strategy outlined in https://www.blocknative.com/blog/eip-1559-fees --\n        // The `maxFeePerGas` is 2x the base fee (plus priority tip). Since we don't have a\n        // handy oracle for the en vogue priorty fee we start with 2 gwei and work up from there.\n        const initialMaxPriorityFeePerGas = new BigNumber(this._initialMaxPriorityFeePerGasGwei).times(\n            Math.pow(10, GWEI_DECIMALS),\n        );\n\n        let gasFees: GasFees = {\n            maxFeePerGas: BigNumber.min(\n                gasPriceEstimate.multipliedBy(2).plus(initialMaxPriorityFeePerGas),\n                this._maxFeePerGasCapWei,\n            ),\n            maxPriorityFeePerGas: initialMaxPriorityFeePerGas,\n        };\n\n        let submissionContext;\n        let nonce;\n        let gasEstimate;\n\n        if (!previousSubmissions.length) {\n            // There's an edge case here where there are previous submissions but they're all in `PRESUBMIT`.\n            // Those are filtered out if they can't be found on the blockchain so we end up here.\n            // If this occurs we need to check if the transaction is expired.\n            const nowSeconds = new BigNumber(new Date().getTime() / ONE_SECOND_MS);\n\n            if (expiry.isLessThan(nowSeconds)) {\n                await onSubmissionContextStatusUpdate(SubmissionContextStatus.FailedExpired);\n                throw new Error(`Exceed expiry ${expiry} for kind ${kind} and submission type ${submissionType}`);\n            }\n\n            logger.info({ kind, identifier, from }, 'Attempting to submit first transaction');\n            await onSubmissionContextStatusUpdate(SubmissionContextStatus.PendingSubmitted);\n\n            logger.info(\n                {\n                    kind,\n                    gasFees,\n                    gasPriceEstimate,\n                    identifier,\n                    submissionCount: 1,\n                    from,\n                    submissionType,\n                },\n                'Submitting transaction',\n            );\n\n            nonce = await this._blockchainUtils.getNonceAsync(from);\n            const gasEstimateWithoutBuffer = await this._blockchainUtils.estimateGasForAsync({\n                to,\n                from,\n                data: calldata,\n                // The following gas fee properties are added because `executeMetaTransaction` in 0x Exchange Proxy\n                // would check whether the gas price of the transaction is within a window. If left empty, it will\n                // fail the simulation.\n                maxFeePerGas: gasFees.maxFeePerGas.toString(),\n                maxPriorityFeePerGas: gasFees.maxPriorityFeePerGas.toString(),\n            });\n            // Add buffer to gas estimate returned by `eth_estimateGas` as the RPC method\n            // tends to under estimate gas usage\n            gasEstimate = Math.ceil((GAS_ESTIMATE_BUFFER + 1) * gasEstimateWithoutBuffer);\n            let accessListWithGas;\n\n            if (this._enableAccessList) {\n                try {\n                    accessListWithGas = await this._blockchainUtils.createAccessListForAsync({\n                        to,\n                        from,\n                        data: calldata,\n                    });\n                    RFQM_CREATE_ACCESS_LIST_REQUEST.labels(this._chainId.toString(), 'success').inc();\n                } catch (error) {\n                    RFQM_CREATE_ACCESS_LIST_REQUEST.labels(this._chainId.toString(), 'failure').inc();\n                    logger.warn({ kind, calldata, from }, 'Failed to create access list');\n                }\n\n                if (accessListWithGas !== undefined && accessListWithGas.gasEstimate) {\n                    // Add buffer to gas estimate returned by `eth_estimateGas` as the RPC method\n                    // tends to under estimate gas usage\n                    accessListWithGas.gasEstimate = Math.ceil(\n                        (GAS_ESTIMATE_BUFFER + 1) * accessListWithGas.gasEstimate,\n                    );\n\n                    logger.info(\n                        { gasEstimate, accessListGasEstimate: accessListWithGas.gasEstimate },\n                        'Regular gas estimate vs access list gas estimate',\n                    );\n                    RFQM_GAS_ESTIMATE_NO_ACCESS_LIST.labels(this._chainId.toString()).set(gasEstimate);\n                    RFQM_GAS_ESTIMATE_ACCESS_LIST.labels(this._chainId.toString()).set(accessListWithGas.gasEstimate);\n                }\n            }\n\n            const firstSubmission = await this._submitTransactionAsync(\n                kind,\n                identifier,\n                from,\n                calldata,\n                gasFees,\n                nonce,\n                gasEstimate,\n                submissionType,\n                to,\n            );\n\n            logger.info(\n                { kind, from, identifier, submissionType, transactionHash: firstSubmission.transactionHash },\n                'Successfully submitted transaction',\n            );\n\n            submissionContext = new SubmissionContext(this._blockchainUtils, [firstSubmission] as\n                | RfqmV2TransactionSubmissionEntity[]\n                | MetaTransactionSubmissionEntity[]);\n        } else {\n            logger.info({ kind, from, identifier, submissionType }, `Previous submissions found, recovering context`);\n            submissionContext = new SubmissionContext(this._blockchainUtils, previousSubmissions);\n            nonce = submissionContext.nonce;\n\n            // If we've already submitted a transaction and it has been mined,\n            // using `_blockchainUtils.estimateGasForAsync` will throw\n            // given the same calldata. In the edge case where a transaction has been sent\n            // but not mined, we would ideally pull the gas estimate from the previous\n            // transaction. Unfortunately, we currently do not store it on the\n            // `RfqmV2TransactionSubmissionEntity`. As a workaround, we'll just use an\n            // overestimate..\n            gasEstimate = MAX_GAS_ESTIMATE;\n        }\n\n        // The \"Watch Loop\"\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            // We've already submitted the transaction once at this point, so we first need to wait before checking the status.\n            await delay(this._transactionWatcherSleepTimeMs);\n            const oldSubmissionContextStatus = submissionContext.submissionContextStatus;\n            const newSubmissionContextStatus = await this._checkSubmissionReceiptsAndUpdateDbAsync(\n                identifier,\n                submissionContext,\n            );\n            logger.info(\n                { kind, submissionType, oldSubmissionContextStatus, newSubmissionContextStatus },\n                'Old and new submission context statuses',\n            );\n            await onSubmissionContextStatusUpdate(newSubmissionContextStatus, oldSubmissionContextStatus);\n\n            switch (newSubmissionContextStatus) {\n                case SubmissionContextStatus.PendingSubmitted:\n                    // We've put in at least one transaction but none have been mined yet.\n                    // Check to make sure we haven't passed the expiry window.\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line no-case-declarations\n                    const nowSeconds = new BigNumber(new Date().getTime() / ONE_SECOND_MS);\n\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line no-case-declarations\n                    const secondsPastExpiration = nowSeconds.minus(expiry);\n\n                    // If we're more than 120 seconds past expiration, give up.\n                    // See https://github.com/rolandkofler/blocktime for some\n                    // analysis of expected block times. Two minutes was selected\n                    // to cover most cases without locking up the worker for too long.\n                    if (secondsPastExpiration.isGreaterThan(ONE_MINUTE_S * 2)) {\n                        await onSubmissionContextStatusUpdate(\n                            SubmissionContextStatus.FailedExpired,\n                            oldSubmissionContextStatus,\n                        );\n                        throw new Error(\n                            `Exceed expiry ${expiry} for kind ${kind} and submission type ${submissionType}`,\n                        );\n                    }\n                    // If we're past expiration by less than a minute, don't put in any new transactions\n                    // but keep watching in case a receipt shows up\n                    if (secondsPastExpiration.isGreaterThan(0)) {\n                        continue;\n                    }\n\n                    // \"Fast\" gas price estimation; used to approximate the base fee\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line no-case-declarations\n                    const newGasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();\n\n                    if (submissionContext.transactionType === 0) {\n                        throw new Error('Non-EIP-1559 transactions are not implemented');\n                    }\n\n                    // We don't wait for gas conditions to change. Rather, we increase the gas\n                    // based bid based onthe knowledge that time (and therefore blocks, theoretically)\n                    // has passed without a transaction being mined.\n\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line no-case-declarations\n                    const { maxFeePerGas: oldMaxFeePerGas, maxPriorityFeePerGas: oldMaxPriorityFeePerGas } =\n                        submissionContext.maxGasFees;\n\n                    if (oldMaxFeePerGas.isGreaterThanOrEqualTo(this._maxFeePerGasCapWei)) {\n                        // If we've reached the max fee per gas we'd like to pay, just\n                        // continue watching the transactions to see if one gets mined.\n                        logger.info(\n                            { kind, submissionType, oldMaxFeePerGas, maxFeePerGasCap: this._maxFeePerGasCapWei },\n                            'Exceeds max fee per gas',\n                        );\n                        continue;\n                    }\n\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line no-case-declarations\n                    const newMaxPriorityFeePerGas = oldMaxPriorityFeePerGas\n                        .multipliedBy(MAX_PRIORITY_FEE_PER_GAS_MULTIPLIER)\n                        .integerValue(BigNumber.ROUND_CEIL);\n\n                    // The RPC nodes still need at least a 0.1 increase in both values to accept the new transaction.\n                    // For the new max fee per gas, we'll take the maximum of a 0.1 increase from the last value\n                    // or the value from an increase in the base fee.\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line no-case-declarations\n                    const newMaxFeePerGas = BigNumber.max(\n                        oldMaxFeePerGas.multipliedBy(MAX_FEE_PER_GAS_MULTIPLIER).integerValue(BigNumber.ROUND_CEIL),\n                        newGasPriceEstimate.multipliedBy(2).plus(newMaxPriorityFeePerGas),\n                    );\n\n                    gasFees = {\n                        maxFeePerGas: newMaxFeePerGas,\n                        maxPriorityFeePerGas: newMaxPriorityFeePerGas,\n                    };\n\n                    logger.info(\n                        {\n                            kind,\n                            gasFees,\n                            gasPriceEstimate,\n                            identifier,\n                            submissionCount: submissionContext.transactions.length + 1,\n                            from,\n                            submissionType,\n                        },\n                        'Submitting transaction',\n                    );\n\n                    try {\n                        const newTransaction = await this._submitTransactionAsync(\n                            kind,\n                            identifier,\n                            from,\n                            calldata,\n                            gasFees,\n                            nonce,\n                            gasEstimate,\n                            submissionType,\n                            to,\n                        );\n                        logger.info(\n                            {\n                                kind,\n                                from,\n                                identifier,\n                                transactionHash: newTransaction.transactionHash,\n                                submissionType,\n                            },\n                            'Successfully resubmited tx with higher gas price',\n                        );\n                        submissionContext.addTransaction(newTransaction);\n                    } catch (err) {\n                        const errorMessage = err.message;\n                        const isNonceTooLow = /nonce too low/.test(errorMessage);\n                        logger.warn(\n                            { from, kind, identifier, submissionType, errorMessage: err.message, isNonceTooLow },\n                            'Encountered an error re-submitting a tx',\n                        );\n                        if (isNonceTooLow) {\n                            logger.info(\n                                { from, kind, identifier, submissionType },\n                                'Ignore nonce too low error on re-submission. A previous submission was successful',\n                            );\n                            break;\n                        }\n\n                        // Rethrow on all other types of errors\n                        throw err;\n                    }\n                    break;\n\n                case SubmissionContextStatus.FailedRevertedUnconfirmed:\n                case SubmissionContextStatus.SucceededUnconfirmed:\n                    break;\n                case SubmissionContextStatus.FailedRevertedConfirmed:\n                case SubmissionContextStatus.SucceededConfirmed:\n                    return newSubmissionContextStatus;\n                default:\n                    ((_x: never) => {\n                        throw new Error('unreachable');\n                    })(newSubmissionContextStatus);\n            }\n        }\n    }\n\n    /**\n     * Get the callback function to supply to `submitToChainAsync`.\n     *\n     * Note that `job.status` would be updated to appropriate state by  the callback function according to old & new\n     * submission context status and submission type. There would be job status update ONLY IF the new and old submission\n     * context statuses differ.\n     *\n     * This function also \"closes over\" `job` so that it's accessible in the callback function. Refer the docstring of\n     * `RfqmTransactionSubmissionContextStatus` for more details on submission context.\n     *\n     * @param job A rfqm v2 job or a meta transactino job object.\n     * @param submissionType Type of submission.\n     * @returns Function would make appropriate update to job status according to submission context statuses and submission type.\n     */\n    private _getOnSubmissionContextStatusUpdateCallback(\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\n        submissionType: RfqmTransactionSubmissionType,\n    ): (\n        newSubmissionContextStatus: SubmissionContextStatus,\n        oldSubmissionContextStatus?: SubmissionContextStatus,\n    ) => Promise<void> {\n        return async (\n            newSubmissionContextStatus: SubmissionContextStatus,\n            oldSubmissionContextStatus?: SubmissionContextStatus,\n        ): Promise<void> => {\n            if (newSubmissionContextStatus !== oldSubmissionContextStatus) {\n                let newJobStatus: RfqmJobStatus;\n                switch (submissionType) {\n                    case RfqmTransactionSubmissionType.Approval:\n                        newJobStatus =\n                            SubmissionContext.approvalSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\n                        break;\n                    case RfqmTransactionSubmissionType.Trade:\n                        newJobStatus =\n                            SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\n                        break;\n                    default:\n                        ((_x: never) => {\n                            throw new Error('unreachable');\n                        })(submissionType);\n                }\n\n                job.status = newJobStatus;\n                await this._dbUtils.updateRfqmJobAsync(job);\n            }\n        };\n    }\n\n    /**\n     * Takes an array of Transaction Submissions, which may include transactions with the\n     * \"Presbumit\" status, and resolves or removes the \"Presubmit\" transactions.\n     *\n     * If there are previous submissions in the \"Presubmit\" state,\n     *\n     * For \"Presubmit\" transactions, we check to see if the transaction was actually sent to\n     * the mempool or not, as that is indeterminate. Depending on the result of the check, we\n     * update the status to \"Submitted\" or remove them from the submissions in memory.\n     * Note that we leave the transaction record present in the database so that if the worker\n     * dies again and the submission actually went through but was not found at the time of\n     * this check we can potentially recover it later.\n     */\n    private async _recoverPresubmitTransactionsAsync<\n        T extends RfqmV2TransactionSubmissionEntity[] | MetaTransactionSubmissionEntity[],\n    >(transactionSubmissions: T): Promise<T> {\n        // Any is so nasty -- https://dev.to/shadow1349/typescript-tip-of-the-week-generics-170g\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const result: any = await Promise.all(\n            transactionSubmissions.map(async (transactionSubmission) => {\n                // If the transaction is any status other than \"Presubmit\" then we'll leave it\n                if (transactionSubmission.status !== RfqmTransactionSubmissionStatus.Presubmit) {\n                    return transactionSubmission;\n                }\n                // For transactions in presubmit, check the mempool and chain to see if they exist\n                const transactionResponse = await this._blockchainUtils.getTransactionAsync(\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    transactionSubmission.transactionHash!,\n                );\n                if (transactionResponse) {\n                    // If it does exist, update the status. If not, remove it.\n                    transactionSubmission.status = RfqmTransactionSubmissionStatus.Submitted;\n                    await this._dbUtils.updateRfqmTransactionSubmissionsAsync([transactionSubmission] as T);\n                    return transactionSubmission;\n                } else {\n                    return null;\n                }\n            }),\n        ).then((x) => x.filter(isDefined));\n        return result;\n    }\n\n    /**\n     * Check for receipts from the tx hashes and update databases with status of all tx's.\n     */\n    private async _checkSubmissionReceiptsAndUpdateDbAsync(\n        identifier: string,\n        submissionContext: SubmissionContext<RfqmV2TransactionSubmissionEntity[] | MetaTransactionSubmissionEntity[]>,\n    ): Promise<\n        | SubmissionContextStatus.PendingSubmitted\n        | SubmissionContextStatus.FailedRevertedConfirmed\n        | SubmissionContextStatus.FailedRevertedUnconfirmed\n        | SubmissionContextStatus.SucceededConfirmed\n        | SubmissionContextStatus.SucceededUnconfirmed\n    > {\n        // At most one tx can be mined, since they all have the same nonce.\n        const minedReceipt = await submissionContext.getReceiptAsync();\n\n        // If the tx hasn't been mined yet, there're no database updates to do.\n        if (!minedReceipt) {\n            return SubmissionContextStatus.PendingSubmitted;\n        }\n\n        // Attempt to publish the mining latency\n        try {\n            const { timestamp: minedBlockTimestampS } = await this._blockchainUtils.getBlockAsync(\n                minedReceipt.blockHash,\n            );\n            const firstSubmissionTimestampS = submissionContext.firstSubmissionTimestampS;\n            RFQM_MINING_LATENCY.labels(this._chainId.toString()).observe(\n                minedBlockTimestampS - firstSubmissionTimestampS,\n            );\n        } catch (e) {\n            logger.warn(\n                { orderHash: identifier, errorMessage: e.message, stack: e.stack },\n                'Failed to meter the mining latency',\n            );\n        }\n\n        await submissionContext.updateForReceiptAsync(minedReceipt);\n        await this._dbUtils.updateRfqmTransactionSubmissionsAsync(submissionContext.transactions);\n        return submissionContext.submissionContextStatus;\n    }\n\n    /**\n     * Determine transaction properties and submit a transaction\n     */\n    private async _submitTransactionAsync(\n        kind: (RfqmV2JobEntity | MetaTransactionJobEntity)['kind'],\n        identifier: string,\n        workerAddress: string,\n        callData: string,\n        gasFees: GasFees,\n        nonce: number,\n        gasEstimate: number,\n        submissionType: RfqmTransactionSubmissionType = RfqmTransactionSubmissionType.Trade,\n        to: string = this._blockchainUtils.getExchangeProxyAddress(),\n    ): Promise<RfqmV2TransactionSubmissionEntity | MetaTransactionSubmissionEntity> {\n        const txOptions = {\n            ...gasFees,\n            from: workerAddress,\n            to,\n            gas: gasEstimate,\n            nonce,\n            value: 0,\n        };\n\n        const transactionRequest = this._blockchainUtils.transformTxDataToTransactionRequest(\n            txOptions,\n            this._chainId,\n            callData,\n        );\n        const { signedTransaction, transactionHash } = await this._blockchainUtils.signTransactionAsync(\n            transactionRequest,\n        );\n\n        let partialEntity;\n        let transactionSubmissionEntity;\n        switch (kind) {\n            case 'rfqm_v2_job':\n                partialEntity = {\n                    ...gasFees,\n                    transactionHash,\n                    orderHash: identifier,\n                    createdAt: new Date(),\n                    from: workerAddress,\n                    to,\n                    nonce,\n                    status: RfqmTransactionSubmissionStatus.Presubmit,\n                    type: submissionType,\n                };\n                transactionSubmissionEntity = await this._dbUtils.writeV2RfqmTransactionSubmissionToDbAsync(\n                    partialEntity,\n                );\n                break;\n            case 'meta_transaction_job':\n                partialEntity = {\n                    ...gasFees,\n                    transactionHash,\n                    metaTransactionJobId: identifier,\n                    createdAt: new Date(),\n                    from: workerAddress,\n                    to,\n                    nonce,\n                    status: RfqmTransactionSubmissionStatus.Presubmit,\n                    type: submissionType,\n                };\n                transactionSubmissionEntity = await this._dbUtils.writeMetaTransactionSubmissionAsync(partialEntity);\n                break;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n\n        const transactionHashFromSubmit = await this._blockchainUtils.submitSignedTransactionAsync(signedTransaction);\n\n        if (transactionHash !== transactionHashFromSubmit) {\n            // This should never ever happen\n            logger.error(\n                { kind, submissionType, identifier, transactionHashFromSubmit, transactionHash },\n                'Mismatch between transaction hash calculated before submit and after submit',\n            );\n            throw new Error('Mismatch between transaction hash calculated before submit and after submit');\n        }\n\n        logger.info(\n            { kind, submissionType, identifier, workerAddress, transactionHash },\n            'Transaction calldata submitted to exchange proxy',\n        );\n\n        const updatedTransactionSubmission = [\n            {\n                ...transactionSubmissionEntity,\n                status: RfqmTransactionSubmissionStatus.Submitted,\n            },\n        ] as RfqmV2TransactionSubmissionEntity[] | MetaTransactionSubmissionEntity[];\n\n        await this._dbUtils.updateRfqmTransactionSubmissionsAsync(updatedTransactionSubmission);\n\n        let updatedEntity;\n        switch (kind) {\n            case 'rfqm_v2_job':\n                updatedEntity = await this._dbUtils.findV2TransactionSubmissionByTransactionHashAsync(\n                    transactionHashFromSubmit,\n                );\n                break;\n            case 'meta_transaction_job':\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line no-case-declarations\n                const updatedSubmissionEntities =\n                    await this._dbUtils.findMetaTransactionSubmissionsByTransactionHashAsync(\n                        transactionHashFromSubmit,\n                        submissionType,\n                    );\n                if (updatedSubmissionEntities.length !== 1) {\n                    // A transaction hash should never be submitted twice in our system. However, RFQ-562 mentioned cases like this could\n                    // happen in our system. Add more log and throw the error to surface it.\n                    logger.error(\n                        { kind, submissionType, transactionHash },\n                        'Transaction hash have been submitted not exactly once',\n                    );\n                    throw new Error('Transaction hash have been submitted not exactly once');\n                }\n\n                updatedEntity = updatedSubmissionEntities[0];\n                break;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n\n        if (!updatedEntity) {\n            // This should never happen -- we just saved it\n            throw new Error(\n                `Could not find updated entity with transaction hash ${transactionHashFromSubmit} of kind ${kind} and submission type ${submissionType}`,\n            );\n        }\n\n        return updatedEntity;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/SubmissionContext.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/SubmissionContext.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { providers } from 'ethers';\n\nimport { ONE_SECOND_MS } from '../core/constants';\nimport { MetaTransactionSubmissionEntity, RfqmV2TransactionSubmissionEntity } from '../entities';\nimport { RfqmJobStatus, RfqmTransactionSubmissionStatus, SubmissionContextStatus } from '../entities/types';\n\nimport { RfqBlockchainUtils } from './rfq_blockchain_utils';\n\nexport const BLOCK_FINALITY_THRESHOLD = 3;\n\ntype TransactionReceipt = providers.TransactionReceipt;\n\n// https://stackoverflow.com/questions/47632622/typescript-and-filter-boolean\nfunction isDefined<T>(value: T): value is NonNullable<T> {\n    return value !== null && value !== undefined;\n}\n\n/**\n * Encapsulates the transaction submissions for an RFQM job.\n *\n * Since one job can have multiple transactions, this class is used to treat them\n * all as one unit. It ensures consistency across transactions and makes retrieval\n * of the mined transaction receipt, if one exists, easy.\n */\nexport class SubmissionContext<T extends RfqmV2TransactionSubmissionEntity[] | MetaTransactionSubmissionEntity[]> {\n    private _transactions: T;\n    private readonly _blockchainUtils: RfqBlockchainUtils;\n    private readonly _transactionType: 0 | 2;\n\n    public static isBlockConfirmed(currentBlock: number, receiptBlockNumber: number): boolean {\n        // We specify a finality threshold of n blocks deep to have greater confidence\n        // in the transaction receipt\n        return currentBlock - receiptBlockNumber >= BLOCK_FINALITY_THRESHOLD;\n    }\n\n    /**\n     * Get corresponding job status given status of submission context for `RfqmTransactionSubmissionType.Approval`.\n     * Different submission context status would trigger different job status transition.\n     *\n     * @returns Corresponding job status.\n     */\n    public static approvalSubmissionContextStatusToJobStatus(\n        submissionContextStatus: SubmissionContextStatus,\n    ): RfqmJobStatus {\n        switch (submissionContextStatus) {\n            case SubmissionContextStatus.FailedExpired:\n                return RfqmJobStatus.FailedExpired;\n            case SubmissionContextStatus.FailedRevertedConfirmed:\n                return RfqmJobStatus.FailedRevertedConfirmed;\n            case SubmissionContextStatus.FailedRevertedUnconfirmed:\n                return RfqmJobStatus.FailedRevertedUnconfirmed;\n            case SubmissionContextStatus.PendingSubmitted:\n            case SubmissionContextStatus.SucceededConfirmed:\n            case SubmissionContextStatus.SucceededUnconfirmed:\n                // For the first version of gasless approval, a successful approval submission\n                // would still keep the job in pending submitted status\n                return RfqmJobStatus.PendingSubmitted;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(submissionContextStatus);\n        }\n    }\n\n    /**\n     * Get corresponding job status given status of submission context for `RfqmTransactionSubmissionType.Trade`.\n     * Different submission context status would trigger different job status transition.\n     *\n     * @param submissionContextStatus Status of submission context.\n     */\n    public static tradeSubmissionContextStatusToJobStatus(\n        submissionContextStatus: SubmissionContextStatus,\n    ): RfqmJobStatus {\n        switch (submissionContextStatus) {\n            case SubmissionContextStatus.FailedExpired:\n                return RfqmJobStatus.FailedExpired;\n            case SubmissionContextStatus.FailedRevertedConfirmed:\n                return RfqmJobStatus.FailedRevertedConfirmed;\n            case SubmissionContextStatus.FailedRevertedUnconfirmed:\n                return RfqmJobStatus.FailedRevertedUnconfirmed;\n            case SubmissionContextStatus.PendingSubmitted:\n                return RfqmJobStatus.PendingSubmitted;\n            case SubmissionContextStatus.SucceededConfirmed:\n                return RfqmJobStatus.SucceededConfirmed;\n            case SubmissionContextStatus.SucceededUnconfirmed:\n                return RfqmJobStatus.SucceededUnconfirmed;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(submissionContextStatus);\n        }\n    }\n\n    constructor(blockchainUtils: RfqBlockchainUtils, transactions: T) {\n        this._ensureTransactionsAreConsistent(transactions);\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line no-extra-boolean-cast\n        this._transactionType = !!transactions[0].gasPrice ? 0 : 2;\n        this._transactions = transactions;\n        this._blockchainUtils = blockchainUtils;\n    }\n\n    public get transactions(): T {\n        return this._transactions;\n    }\n\n    // Gets the transaction hashes for the transactions in the SubmissionContext\n    public get transactionHashes(): string[] {\n        return this._transactions.map((t) => t.transactionHash).filter(isDefined);\n    }\n\n    /**\n     * Gets the type of the transactions in the `SubmissionContext`:\n     * 0 for non-EIP1559 transactions and 2 for EIP-1559 transactions.\n     */\n    public get transactionType(): 0 | 2 {\n        return this._transactionType;\n    }\n\n    /**\n     * Adds a transaction to the SubmissionContext. Throws if the transaction has a nonce or type\n     * different than the existing transactions.\n     */\n    public addTransaction(transaction: T[number]): void {\n        // TODO (Vic): Remove any[] once https://github.com/microsoft/TypeScript/issues/44373 is fixed\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (this._transactions as any[]).push(transaction);\n        this._ensureTransactionsAreConsistent(this._transactions);\n    }\n\n    /**\n     * Gets the nonce of the transactions of the `SubmissionContext`\n     */\n    public get nonce(): number {\n        const nonce = this._transactions[0].nonce;\n        if (nonce === undefined || nonce === null) {\n            throw new Error('Transaction does not have a nonce');\n        }\n        return nonce;\n    }\n\n    /**\n     * Gets the max gas price set for any transaction in the `SubmissionContext`\n     */\n    public get maxGasPrice(): BigNumber {\n        if (this._transactionType !== 0) {\n            throw new Error('Attempted to access the max gas price of a EIP-1559 transaction set');\n        }\n        return (\n            this._transactions\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                .map((t) => t.gasPrice!)\n                .filter(Boolean)\n                .reduce((result, gasPrice) => BigNumber.maximum(result, gasPrice))\n        );\n    }\n\n    /**\n     * Gets the maximum values for the `maxFeePerGas` and the `maxPriorityFeePerGas` for a\n     * set of EIP-1559 transactions.\n     */\n    public get maxGasFees(): { maxFeePerGas: BigNumber; maxPriorityFeePerGas: BigNumber } {\n        if (this._transactionType !== 2) {\n            throw new Error('Attempted to access the max gas fees for a non-EIP-1559 transaction set');\n        }\n        return {\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            maxFeePerGas: BigNumber.maximum(...this._transactions.map((t) => t.maxFeePerGas!)),\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            maxPriorityFeePerGas: BigNumber.maximum(...this._transactions.map((t) => t.maxPriorityFeePerGas!)),\n        };\n    }\n\n    /**\n     * Gets the epoch time, in seconds, of the earliest transaction submission.\n     * Note: This uses the database time the transaction submission was created,\n     * not the blockchain timestamp.\n     */\n    public get firstSubmissionTimestampS(): number {\n        const submissionCreationTimesS = this._transactions\n            .map((t) => t.createdAt.getTime() / ONE_SECOND_MS)\n            .map((t) => Math.round(t));\n        return submissionCreationTimesS.reduce((result, time) => Math.min(result, time), Infinity);\n    }\n\n    /**\n     * Returns the transaction receipt if one of the transactions in the SubmissionContext\n     * has been mined; otherwise returns `null`.\n     */\n    public async getReceiptAsync(): Promise<TransactionReceipt | null> {\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        /* eslint-disable @typescript-eslint/no-non-null-assertion */\n        const receipts = (\n            await this._blockchainUtils.getReceiptsAsync(this._transactions.map((t) => t.transactionHash!))\n        ).filter(isDefined);\n        /* eslint-enable @typescript-eslint/no-non-null-assertion */\n        if (receipts.length > 1) {\n            throw new Error('Found more than one transaction receipt');\n        }\n        return receipts.length ? receipts[0] : null;\n    }\n\n    /**\n     * 1. Updates the in-memory transactions in response to a mined transaction receipt.\n     * 2. Updates the statuses of all transaction submission.\n     */\n    public async updateForReceiptAsync(receipt: TransactionReceipt, now: Date = new Date()): Promise<void> {\n        const isTransactionSuccessful = receipt.status === 1;\n        const currentBlock = await this._blockchainUtils.getCurrentBlockAsync();\n        const isTransactionConfirmed = SubmissionContext.isBlockConfirmed(currentBlock, receipt.blockNumber);\n\n        this._transactions = this._transactions.map((transaction) => {\n            transaction.updatedAt = now;\n            if (transaction.transactionHash === receipt.transactionHash) {\n                const submissionStatus = isTransactionSuccessful\n                    ? isTransactionConfirmed\n                        ? RfqmTransactionSubmissionStatus.SucceededConfirmed\n                        : RfqmTransactionSubmissionStatus.SucceededUnconfirmed\n                    : isTransactionConfirmed\n                    ? RfqmTransactionSubmissionStatus.RevertedConfirmed\n                    : RfqmTransactionSubmissionStatus.RevertedUnconfirmed;\n\n                transaction.status = submissionStatus;\n                transaction.blockMined = new BigNumber(receipt.blockNumber);\n                transaction.gasUsed = new BigNumber(receipt.gasUsed.toString());\n                if (transaction.gasPrice === null) {\n                    transaction.gasPrice = new BigNumber(receipt.effectiveGasPrice.toString());\n                }\n            } else {\n                transaction.status = RfqmTransactionSubmissionStatus.DroppedAndReplaced;\n            }\n\n            return transaction;\n        }) as T;\n    }\n\n    /**\n     * Returns the appropriate job status given the statuses of the transactions\n     */\n    public get jobStatus():\n        | RfqmJobStatus.PendingSubmitted\n        | RfqmJobStatus.FailedRevertedConfirmed\n        | RfqmJobStatus.FailedRevertedUnconfirmed\n        | RfqmJobStatus.SucceededConfirmed\n        | RfqmJobStatus.SucceededUnconfirmed {\n        for (const transaction of this._transactions) {\n            switch (transaction.status) {\n                case RfqmTransactionSubmissionStatus.DroppedAndReplaced:\n                    continue;\n                case RfqmTransactionSubmissionStatus.Presubmit:\n                    continue;\n                case RfqmTransactionSubmissionStatus.RevertedConfirmed:\n                    return RfqmJobStatus.FailedRevertedConfirmed;\n                case RfqmTransactionSubmissionStatus.RevertedUnconfirmed:\n                    return RfqmJobStatus.FailedRevertedUnconfirmed;\n                case RfqmTransactionSubmissionStatus.Submitted:\n                    continue;\n                case RfqmTransactionSubmissionStatus.SucceededConfirmed:\n                    return RfqmJobStatus.SucceededConfirmed;\n                case RfqmTransactionSubmissionStatus.SucceededUnconfirmed:\n                    return RfqmJobStatus.SucceededUnconfirmed;\n                default:\n                    ((_x: never) => {\n                        throw new Error('unreachable');\n                    })(transaction.status);\n            }\n        }\n        return RfqmJobStatus.PendingSubmitted;\n    }\n\n    /**\n     * Returns the submission context status given the statuses of the transactions. A submission context contains\n     * multiple transactions and the submission context status is the collective status for all transactions.\n     */\n    public get submissionContextStatus():\n        | SubmissionContextStatus.PendingSubmitted\n        | SubmissionContextStatus.FailedRevertedConfirmed\n        | SubmissionContextStatus.FailedRevertedUnconfirmed\n        | SubmissionContextStatus.SucceededConfirmed\n        | SubmissionContextStatus.SucceededUnconfirmed {\n        for (const transaction of this._transactions) {\n            switch (transaction.status) {\n                case RfqmTransactionSubmissionStatus.DroppedAndReplaced:\n                    continue;\n                case RfqmTransactionSubmissionStatus.Presubmit:\n                    continue;\n                case RfqmTransactionSubmissionStatus.RevertedConfirmed:\n                    return SubmissionContextStatus.FailedRevertedConfirmed;\n                case RfqmTransactionSubmissionStatus.RevertedUnconfirmed:\n                    return SubmissionContextStatus.FailedRevertedUnconfirmed;\n                case RfqmTransactionSubmissionStatus.Submitted:\n                    continue;\n                case RfqmTransactionSubmissionStatus.SucceededConfirmed:\n                    return SubmissionContextStatus.SucceededConfirmed;\n                case RfqmTransactionSubmissionStatus.SucceededUnconfirmed:\n                    return SubmissionContextStatus.SucceededUnconfirmed;\n                default:\n                    throw new Error(`Transaction status ${transaction.status} should not be reached`);\n            }\n        }\n        return SubmissionContextStatus.PendingSubmitted;\n    }\n\n    /**\n     * Assesses whether the given transactions have the same nonce, type (EIP-1559 or not),\n     * and unique transaction hashes; throws if they do not.\n     *\n     * Throws if `transactions` has a zero length.\n     *\n     * `perfer-function-over-method` rule is disabled to since a function would not be able to use the\n     * `T` generic type.\n     */\n    // tslint:disable-next-line: prefer-function-over-method\n    private _ensureTransactionsAreConsistent(transactions: T): void {\n        if (!transactions.length) {\n            throw new Error('`transactions` must have a nonzero length');\n        }\n        if (!transactions.map((t) => t.nonce).every((n, _, nonces) => n === nonces[0])) {\n            throw new Error('Transactions do not have the same nonce');\n        }\n        if (new Set(transactions.map((t) => t.transactionHash)).size !== transactions.length) {\n            throw new Error('Transactions are not unique');\n        }\n        // TODO (Vic): Remove any[] once https://github.com/microsoft/TypeScript/issues/44373 is fixed\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const areAllGasPricesNonNull = (transactions as any[]).every((t) => t.gasPrice !== null);\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const areAllMaxFeesPerGasNonNull = (transactions as any[]).every((t) => t.maxFeePerGas !== null);\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const areAllMaxPriorityFeesPerGasNonNull = (transactions as any[]).every(\n            (t) => t.maxPriorityFeePerGas !== null,\n        );\n        if (!(areAllGasPricesNonNull || (areAllMaxFeesPerGasNonNull && areAllMaxPriorityFeesPerGasNonNull))) {\n            throw new Error('Transactions do not have the same gas type');\n        }\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts",{"fileContent":"import { BalanceCheckerContract } from '@0x/asset-swapper';\nimport { artifacts } from '@0x/asset-swapper/lib/src/artifacts';\nimport { BlockParamLiteral, SupportedProvider } from '@0x/dev-utils';\nimport { BigNumber } from '@0x/utils';\n\n// The eth_call will run out of gas if there are too many balance calls at once\nconst BALANCE_CHECKER_GAS_LIMIT = 5500000;\n\n// We use this random address on which to override the bytecode (unlikely to conflict with another address)\nconst RANDOM_ADDRESS = '0xffffffffffffffffffffffffffffffffffffffff';\n\n/**\n * BalanceChecker makes it easy and efficient to look up a large number of token balances at once\n */\nexport class BalanceChecker {\n    private readonly _balanceCheckerContract: BalanceCheckerContract;\n    private readonly _balanceCheckerBytecode: string;\n\n    constructor(provider: SupportedProvider, balanceCheckerContract?: BalanceCheckerContract) {\n        this._balanceCheckerContract =\n            balanceCheckerContract ||\n            new BalanceCheckerContract(RANDOM_ADDRESS, provider, { gas: BALANCE_CHECKER_GAS_LIMIT });\n        this._balanceCheckerBytecode = artifacts.BalanceChecker.compilerOutput.evm.deployedBytecode.object;\n    }\n\n    /**\n     * Fetches the tradeable balance for a list of addresses against the specified tokens.\n     * Tradeable means the minimum of the balance and allowance.\n     *\n     * The index of an address in `addresses` must correspond with the index of a token in `tokens`\n     *\n     * @param addresses - an array of addresses\n     * @param tokens - an array of tokens\n     * @param allowanceTarget - Target address to check for allowance.\n     * @returns - an array of BigNumbers\n     */\n    public async getMinOfBalancesAndAllowancesAsync(\n        addresses: string[],\n        tokens: string[],\n        allowanceTarget: string,\n    ): Promise<BigNumber[]> {\n        if (addresses.length !== tokens.length) {\n            throw new Error(\n                `expected length of addresses and tokens must be the same, actual: ${addresses.length} and ${tokens.length}`,\n            );\n        }\n\n        // HACK: this checks to see if we're using a real implementation of the balanceCheckerContract or using an override\n        // We do this because ganache doesn't allow for overrides. In all other environments, we should use overrides\n        const shouldUseOverrides = this._balanceCheckerContract.address.toLowerCase() === RANDOM_ADDRESS;\n\n        const txOpts = shouldUseOverrides\n            ? {\n                  overrides: {\n                      [RANDOM_ADDRESS]: {\n                          code: this._balanceCheckerBytecode,\n                      },\n                  },\n              }\n            : {};\n\n        return this._balanceCheckerContract\n            .getMinOfBalancesOrAllowances(addresses, tokens, allowanceTarget)\n            .callAsync(txOpts, BlockParamLiteral.Latest);\n    }\n\n    /**\n     * Fetches the balances for a list of addresses against the specified tokens.\n     *\n     * The index of an address in `addresses` must correspond with the index of a token in `tokens`.\n     */\n    public async getTokenBalancesAsync(addresses: string[], tokens: string[]): Promise<BigNumber[]> {\n        if (addresses.length !== tokens.length) {\n            throw new Error(\n                `expected length of addresses and tokens must be the same, actual: ${addresses.length} and ${tokens.length}`,\n            );\n        }\n\n        // HACK: this checks to see if we're using a real implementation of the balanceCheckerContract or using an override\n        // We do this because ganache doesn't allow for overrides. In all other environments, we should use overrides\n        const shouldUseOverrides = this._balanceCheckerContract.address.toLowerCase() === RANDOM_ADDRESS;\n\n        const txOpts = shouldUseOverrides\n            ? {\n                  overrides: {\n                      [RANDOM_ADDRESS]: {\n                          code: this._balanceCheckerBytecode,\n                      },\n                  },\n              }\n            : {};\n\n        return this._balanceCheckerContract.balances(addresses, tokens).callAsync(txOpts, BlockParamLiteral.Latest);\n    }\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts",{"fileContent":"import { ZERO } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport Redis from 'ioredis';\n\nimport { MAKER_TOKEN_BALANCE_EXPIRY_SECONDS } from '../core/constants';\nimport { ERC20Owner } from '../core/types';\n\nimport { splitAddresses } from './address_utils';\nimport { toPairString } from '../core/pair_utils';\n\nconst OTC_ORDER_NONCE_BUCKET_COUNTER_KEY = (chainId: number) => `otcorder.nonce.bucket.counter.chain.${chainId}`;\n// The value stored at this key is a set. The members of this set are each an ERC20_OWNER_BALANCE_KEY.\nconst ERC20_OWNERS_KEY = (chainId: number) => `erc20.owners.chain.${chainId}`;\nconst ERC20_OWNER_BALANCE_KEY = (chainId: number, ownerAddress: string, tokenAddress: string) =>\n    `erc20.owner.balance.chain.${chainId}.${ownerAddress}.${tokenAddress}`;\n// Use `chainId` and pair keys as Redis keys for sorted set entries, used for cooling down makers after bad last look rejection.\nconst LLR_COOLDOWN_SET_KEY = (chainId: number, tokenA: string, tokenB: string) =>\n    `coolingdown.makers.chain.${chainId}.pair.${toPairString(tokenA, tokenB)}`;\n\nexport class CacheClient {\n    constructor(private readonly _redis: Redis) {}\n\n    // Shut down the CacheClient safely\n    public async closeAsync(): Promise<'OK'> {\n        return this._redis.quit();\n    }\n\n    // Get the next OtcOrder Bucket\n    // NOTE: unliklely to ever hit this, but the node library we use tries to cast the response from Redis as a number.\n    // However, MAX_INT for js is lower than MAX_INT for Redis. We also need to be aware of if Redis' MAX_INT ever gets hit (error)\n    public async getNextOtcOrderBucketAsync(chainId: number): Promise<number> {\n        return this._redis.incr(OTC_ORDER_NONCE_BUCKET_COUNTER_KEY(chainId));\n    }\n\n    // Advance the current OtcOrder bucket by N buckets\n    // NOTE: unliklely to ever hit this, but the node library we use tries to cast the response from Redis as a number.\n    // However, MAX_INT for js is lower than MAX_INT for Redis. We also need to be aware of if Redis' MAX_INT ever gets hit (error)\n    public async getNextNOtcOrderBucketsAsync(chainId: number, n: number): Promise<number> {\n        return this._redis.incrby(OTC_ORDER_NONCE_BUCKET_COUNTER_KEY(chainId), n);\n    }\n\n    /**\n     * Fetches all maker token addresses to be updated.\n     * Token addresses set stores unique erc20Owners as balance cache keys.\n     */\n    public async getERC20OwnersAsync(chainId: number): Promise<ERC20Owner[]> {\n        const cacheKeys = await this._redis.smembers(ERC20_OWNERS_KEY(chainId));\n        // parse cache keys into ERC20Owner objects\n        // cache key follows the format of `prefix.${chainId}.${owner}.${token}`\n        return cacheKeys.map((cacheKey) => {\n            const addresses = cacheKey.split('.');\n            return {\n                owner: addresses[addresses.length - 2],\n                token: addresses[addresses.length - 1],\n            };\n        });\n    }\n\n    /**\n     * Adds a newly observed erc20Owner to the set of known maker tokens.\n     * The values in this set are keys used to retrieve the maker's balance.\n     * They are iterated upon in the next maker balance cache update.\n     */\n    public async addERC20OwnerAsync(chainId: number, erc20Owner: ERC20Owner): Promise<void> {\n        const { owners, tokens } = splitAddresses(erc20Owner);\n        await this._redis.sadd(ERC20_OWNERS_KEY(chainId), ERC20_OWNER_BALANCE_KEY(chainId, owners[0], tokens[0]));\n    }\n\n    /**\n     * Evicts maker token addresses with zero balances from the cache.\n     * We assume that market makers no longer supply liquidity for tokens with zero balances.\n     */\n    public async evictZeroBalancesAsync(chainId: number): Promise<number> {\n        const setKey = ERC20_OWNERS_KEY(chainId);\n        const cacheKeys = await this._redis.smembers(setKey);\n        if (cacheKeys.length === 0) {\n            return 0;\n        }\n        const balances = await this._redis.mget(cacheKeys);\n        const evictedKeys = cacheKeys.filter((_, idx) => {\n            const balance = balances[idx];\n            return balance != null && ZERO.eq(new BigNumber(balance));\n        });\n        if (evictedKeys.length === 0) {\n            return 0;\n        }\n        return this._redis.srem(setKey, evictedKeys);\n    }\n\n    /**\n     * Gets maker balances for provided erc20Owners from the cache.\n     * A cache miss will result in a null value, and otherwise a valid BigNumber.\n     * Throws an error if invalid addresses are passed.\n     * Each GET is a fast O(1) read request to the cache.\n     */\n    public async getERC20OwnerBalancesAsync(chainId: number, erc20Owners: ERC20Owner[]): Promise<(BigNumber | null)[]> {\n        const cacheKeys = this._validateAndGetBalanceCacheKeys(chainId, erc20Owners);\n        // Redis mGet only accepts non-empty arrays\n        // if erc20Owners is empty, balances should be empty as well\n        if (cacheKeys.length === 0) {\n            return [];\n        }\n        const balances = await this._redis.mget(cacheKeys);\n        return balances.map((balance) => (balance ? new BigNumber(balance) : null));\n    }\n\n    /**\n     * Sets and/or updates maker balances for provided maker and token addresses.\n     * Refreshes cache entry expiries to two minutes from now.\n     * Throws an error if invalid addresses or balances are passed.\n     * Each SET is a fast O(1) write request to the cache.\n     */\n    public async setERC20OwnerBalancesAsync(\n        chainId: number,\n        erc20Owners: ERC20Owner[],\n        balances: BigNumber[],\n    ): Promise<void> {\n        const cacheKeys = this._validateAndGetBalanceCacheKeys(chainId, erc20Owners, balances);\n        await Promise.all(\n            cacheKeys.map(async (cacheKey, i) =>\n                this._redis.set(cacheKey, balances[i].toString(), 'EX', MAKER_TOKEN_BALANCE_EXPIRY_SECONDS),\n            ),\n        );\n    }\n\n    /**\n     * Add maker to cooldown sorted set of given pair. Maker Ids in the sorted set are sorted by\n     * cooldown period endTime, so as to allow quickly filter out these with expired cooldown period.\n     *\n     * @param makerId ID of maker to be added or updated\n     * @param endTime time stamp to end the cooldown period, in millisecond\n     * @param chainId chainId of the pair\n     * @param tokenA address of one trading token\n     * @param tokenB address of the other trading token\n     * @returns whether the sorted set get updated\n     */\n    public async addMakerToCooldownAsync(\n        makerId: string,\n        endTime: number,\n        chainId: number,\n        tokenA: string,\n        tokenB: string,\n    ): Promise<boolean> {\n        const changedMemberCount = await this._redis.zadd(\n            LLR_COOLDOWN_SET_KEY(chainId, tokenA, tokenB),\n            'GT', // only update if setting a higher score\n            'CH', // return number of set members get changed (added and updated)\n            endTime, // score to be sorted by\n            makerId, // value of the entry\n        );\n        return changedMemberCount > 0;\n    }\n\n    /**\n     * Get a list of makers that are cooling down for given pair. Only includes unexpired entries.\n     *\n     * @param chainId chainId of the pair\n     * @param tokenA address of one trading token\n     * @param tokenB address of the other trading token\n     * @param now current timestamp (for testing)\n     * @returns array of maker IDs\n     */\n    public async getMakersInCooldownForPairAsync(\n        chainId: number,\n        tokenA: string,\n        tokenB: string,\n        now: number = Date.now(),\n    ): Promise<string[]> {\n        // Sorted set members use cooldown expiration time as scores, so selecting members with scores larger than `Date.now()`\n        // will give a complete list of makers in cooldown.\n        const minScore = now;\n        const maxScore = '+inf';\n        return this._redis.zrangebyscore(LLR_COOLDOWN_SET_KEY(chainId, tokenA, tokenB), minScore, maxScore);\n    }\n\n    /**\n     * Validates maker and token addresses.\n     * If balances are passed, validates that every cache key has a corresponding value.\n     * Generates a cache key for every pair through string concatenation.\n     */\n    // tslint:disable-next-line: prefer-function-over-method\n    private _validateAndGetBalanceCacheKeys(\n        chainId: number,\n        erc20Owners: ERC20Owner[],\n        balances?: BigNumber[],\n    ): string[] {\n        if (balances && erc20Owners.length !== balances.length) {\n            throw new Error('Maker addresses do not match balances');\n        }\n        const { owners, tokens } = splitAddresses(erc20Owners);\n        return owners.map((owner, i) => {\n            return ERC20_OWNER_BALANCE_KEY(chainId, owner, tokens[i]);\n        });\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts",{"fileContent":"import { ValidationError, ValidationErrorCodes } from '@0x/api-utils';\nimport { ChainId } from '@0x/contract-addresses';\nimport { findTokenAddressOrThrow } from '@0x/token-metadata';\nimport { addressUtils } from '@0x/utils';\n\nimport { ERC20Owner } from '../core/types';\n\n/**\n * Checks top level attributes of an object for values matching an ETH address\n * and normalizes the address by turning it to lowercase\n */\nexport const objectETHAddressNormalizer = <T>(obj: T) => {\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const normalized: { [key: string]: any } = {};\n    for (const [key, value] of Object.entries(obj)) {\n        if (value && addressUtils.isAddress(value as string)) {\n            normalized[key] = (value as string).toLowerCase();\n        }\n    }\n\n    return {\n        ...obj,\n        ...normalized,\n    };\n};\n\n/**\n * Attempts to find the address of the token and throws if not found\n *\n * @param address the uppercase symbol of the token (ex. `REP`) or the address of the contract\n * @param chainId the Network where the address should be hosted on.\n */\nexport function findTokenAddressOrThrowApiError(address: string, field: string, chainId: ChainId): string {\n    try {\n        return findTokenAddressOrThrow(address, chainId);\n    } catch (e) {\n        throw new ValidationError([\n            {\n                field,\n                code: ValidationErrorCodes.ValueOutOfRange,\n                reason: e.message,\n            },\n        ]);\n    }\n}\n\n/**\n * Splits an array of ERC20Owner objects into string arrays of owner and token addresses.\n * This serves as an intermediate step before passing the objects to the Balance Checker contract.\n */\nexport function splitAddresses(erc20Owners: ERC20Owner | ERC20Owner[]): { owners: string[]; tokens: string[] } {\n    const splitAddrs: { owners: string[]; tokens: string[] } = { owners: [], tokens: [] };\n    if (Array.isArray(erc20Owners)) {\n        return erc20Owners.reduce(({ owners, tokens }, erc20Owner) => {\n            return {\n                owners: owners.concat(erc20Owner.owner),\n                tokens: tokens.concat(erc20Owner.token),\n            };\n        }, splitAddrs);\n    } else {\n        return {\n            owners: [erc20Owners.owner],\n            tokens: [erc20Owners.token],\n        };\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts",{"fileContent":"// tslint:disable: prefer-function-over-method\nimport { createHash } from 'crypto';\n\nimport {\n    ADMIN_API_KEY,\n    DEFAULT_FEE_MODEL_CONFIGURATION,\n    FeeModelConfiguration,\n    FEE_MODEL_CONFIGURATION_MAP,\n    getIntegratorByIdOrThrow,\n    getIntegratorIdForApiKey,\n    Integrator,\n    MakerIdSet,\n    RFQM_API_KEY_WHITELIST,\n    RFQM_MAKER_ID_SET,\n    RFQM_MAKER_ID_SET_FOR_OTC_ORDER,\n    RFQT_MAKER_ID_SET_FOR_OTC_ORDER,\n    RFQT_MAKER_ID_SET_FOR_RFQ_ORDER,\n    RFQ_API_KEY_HASH_TO_MAKER_ID,\n} from '../config';\n\nimport { toPairString } from '../core/pair_utils';\n\nconst getApiKeyHash = (apiKey: string): string => createHash('sha256').update(apiKey).digest('base64');\n\n/**\n * ConfigManager is a simple wrapper around configs.\n *\n * It exists to provide a layer around our configs which can then be mocked while writing tests\n */\nexport class ConfigManager {\n    public getAdminApiKey(): string | undefined {\n        return ADMIN_API_KEY;\n    }\n\n    public getRfqmApiKeyWhitelist(): Set<string> {\n        return RFQM_API_KEY_WHITELIST;\n    }\n\n    public getRfqMakerIdForApiKey(apiKey: string): string | undefined {\n        return RFQ_API_KEY_HASH_TO_MAKER_ID.get(getApiKeyHash(apiKey));\n    }\n\n    public getIntegratorByIdOrThrow(integratorId: string): Integrator {\n        return getIntegratorByIdOrThrow(integratorId);\n    }\n\n    public getIntegratorIdForApiKey(apiKey: string): string | undefined {\n        return getIntegratorIdForApiKey(apiKey);\n    }\n\n    /**\n     * Get a set of makers that support RFQt workflow with rfq order type\n     */\n    public getRfqtMakerIdSetForRfqOrder(): MakerIdSet {\n        return RFQT_MAKER_ID_SET_FOR_RFQ_ORDER;\n    }\n\n    /**\n     * Get a set of makers that support RFQm workflow\n     */\n    public getRfqmMakerIdSet(): MakerIdSet {\n        return RFQM_MAKER_ID_SET;\n    }\n\n    /**\n     * Get a set of makers that support RFQt workflow with otc order type\n     */\n    public getRfqtMakerIdSetForOtcOrder(): MakerIdSet {\n        return RFQT_MAKER_ID_SET_FOR_OTC_ORDER;\n    }\n\n    /**\n     * Get a set of makers that support RFQm workflow with otc order type\n     */\n    public getRfqmMakerIdSetForOtcOrder(): MakerIdSet {\n        return RFQM_MAKER_ID_SET_FOR_OTC_ORDER;\n    }\n\n    /**\n     * Get fee model constant for given pair on a given chain.\n     */\n    public getFeeModelConfiguration(chainId: number, tokenA: string, tokenB: string): FeeModelConfiguration {\n        if (FEE_MODEL_CONFIGURATION_MAP.has(chainId)) {\n            const pairKey = toPairString(tokenA, tokenB);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const innerMap = FEE_MODEL_CONFIGURATION_MAP.get(chainId)!;\n            if (innerMap.has(pairKey)) {\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                return innerMap.get(pairKey)!;\n            }\n        }\n\n        return DEFAULT_FEE_MODEL_CONFIGURATION;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantUtils.ts",{"fileContent":"import { AxiosInstance } from 'axios';\n\nimport { ChainConfiguration } from '../config';\nimport { GasOracleType0 } from './GasOracleType0';\n\nimport { GasOracleType2 } from './GasOracleType2';\nimport { GasStationAttendant } from './GasStationAttendant';\nimport { GasStationAttendantEthereum } from './GasStationAttendantEthereum';\nimport { GasStationAttendantPolygon } from './GasStationAttendantPolygon';\n\nexport function getGasStationAttendant(chain: ChainConfiguration, axiosInstance: AxiosInstance): GasStationAttendant {\n    // tslint:disable: custom-no-magic-numbers\n    switch (chain.chainId) {\n        case /* ethereum */ 1:\n            return new GasStationAttendantEthereum(GasOracleType2.create(chain.gasStationUrl, axiosInstance));\n        case /* ganache */ 1337:\n            return new GasStationAttendantEthereum(GasOracleType2.create(chain.gasStationUrl, axiosInstance));\n        case /* polygon */ 137:\n            return new GasStationAttendantPolygon(GasOracleType0.create(chain.gasStationUrl, axiosInstance));\n        case /* mumbai */ 80001:\n            return new GasStationAttendantPolygon(GasOracleType0.create(chain.gasStationUrl, axiosInstance));\n        default:\n            throw new Error(`Gas station attendant not configured for chain: ${chain.name}`);\n    }\n    // tslint:enable: custom-no-magic-numbers\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType0.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType2.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantEthereum.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantPolygon.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracle.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { AxiosInstance } from 'axios';\nimport { OK } from 'http-status-codes';\n\n/**\n * Response format from https://github.com/0xProject/gas-price-oracle\n * for \"v2\" endpoints\n */\nexport interface T0xGasPriceOracleResponse {\n    result: TResult;\n}\n\nexport interface TResult {\n    source: string;\n    timestamp: number;\n    instant: TRates;\n    fast: TRates;\n    standard: TRates;\n    low: TRates;\n}\n\nexport interface TRates {\n    price: number;\n    maxPriorityFeePerGas: number;\n    maxFeePerGas: number;\n    baseFeePerGas: number;\n}\n\nconst TIMEOUT_MS = 250;\n\n/**\n * A client to wrap the functionality of the 0x Gas Price Oracle\n * (https://github.com/0xProject/gas-price-oracle) \"v2\" endpoints\n * which provide support for EIP1559\n */\nexport class GasOracle {\n    private readonly _url: string;\n    private readonly _axiosInstance: AxiosInstance;\n\n    /**\n     * Creates an instance of `GasOracle`.\n     *\n     * The URL is parsed so that we can use the \"eth gas station\" URL format\n     * present in the config, eg:\n     * \"http://gas-price-oracle-svc.gas-price-oracle/source/median?output=eth_gas_station\".\n     *\n     * The function transforms this URL into a v2 URL which will report EIP1559-data.\n     */\n    public static create(url: string, axiosInstance: AxiosInstance): GasOracle {\n        const domainRegex = /https?:\\/\\/(?<domain>(\\w|\\d|-|\\.)*)/;\n        const result = domainRegex.exec(url);\n        const domain = result?.groups?.domain;\n        if (!domain) {\n            throw new Error(`Unable to extract domain for url ${url}`);\n        }\n        return new GasOracle(`http://${domain}/v2/source/median`, axiosInstance);\n    }\n\n    /**\n     * Fetch the current baseFeePerGas being reported by the oracle\n     */\n    public async getBaseFeePerGasWeiAsync(): Promise<BigNumber> {\n        const response = await this._axiosInstance.get<T0xGasPriceOracleResponse>(this._url, {\n            timeout: TIMEOUT_MS,\n        });\n        if (response.status !== OK) {\n            throw new Error('Failed to request base fee from gas price oracle');\n        }\n        try {\n            // All the speed levels have the same base fee, so just use 'instant'\n            const baseFee = response.data.result.instant.baseFeePerGas;\n            return new BigNumber(baseFee);\n        } catch (e) {\n            throw new Error(`Response from gas price oracle did not include the base fee: ${e.message}`);\n        }\n    }\n\n    /**\n     * Fetch the current maxPriorityFeePerGas, aka \"tip\", being reported by the oracle\n     */\n    public async getMaxPriorityFeePerGasWeiAsync(speed: 'instant' | 'fast' | 'standard' | 'low'): Promise<BigNumber> {\n        const response = await this._axiosInstance.get<T0xGasPriceOracleResponse>(this._url, {\n            timeout: TIMEOUT_MS,\n        });\n        if (response.status !== OK) {\n            throw new Error('Failed to request base fee from gas price oracle');\n        }\n        try {\n            const maxPriorityFee = response.data.result[speed].maxPriorityFeePerGas;\n            return new BigNumber(maxPriorityFee);\n        } catch (e) {\n            throw new Error(\n                `Response from gas price oracle did not include the expected maxPriorityFeePerGas: ${e.message}`,\n            );\n        }\n    }\n\n    /**\n     * Constructor is marked `private` to force users to use the static\n     * creator functions, which validate the URL.\n     */\n    private constructor(url: string, axiosInsatnce: AxiosInstance) {\n        this._axiosInstance = axiosInsatnce;\n        this._url = url;\n    }\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantEthereum.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { logger } from '../logger';\n\nimport { GasOracleType2 } from './GasOracleType2';\nimport { GasStationAttendant, Wei, WeiPerGas } from './GasStationAttendant';\nimport { calculateGasEstimate } from './rfqm_gas_estimate_utils';\n\n/**\n * An implementation of `GasStationAttendant` designed for Ethereum Mainnet.\n */\nexport class GasStationAttendantEthereum implements GasStationAttendant {\n    private readonly _gasOracle: GasOracleType2;\n\n    constructor(gasOracle: GasOracleType2) {\n        this._gasOracle = gasOracle;\n    }\n\n    /**\n     * The Safe Balance For Trade is based on historical data as outlined here:\n     * https://0xproject.quip.com/qZdFAHLpT7JI/RFQm-healthz-System-Health-Endpoint#temp:C:cXH5851e0f15e8c4828bffc1339d\n     */\n    // tslint:disable-next-line: prefer-function-over-method\n    public async getSafeBalanceForTradeAsync(): Promise<Wei> {\n        return new BigNumber(82500000000000000);\n    }\n\n    /**\n     * Uses an estimate of the current base fee with 6\n     * 10% increases plus the \"instant\" maxPriorityFeePerGas\n     * as reported by the oracle.\n     *\n     * Gas amount is estimated for an unwrap of the AAVE-USDC pair.\n     */\n    public async getWorkerBalanceForTradeAsync(): Promise<WeiPerGas> {\n        const baseFee = await this._gasOracle.getBaseFeePerGasWeiAsync();\n        const instantTip = await this._gasOracle.getMaxPriorityFeePerGasWeiAsync('instant');\n        logger.info(\n            { baseFee: baseFee.toString(), instantTip: instantTip.toString() },\n            'Base fee and instant tip for gas rate',\n        );\n\n        // Pad the baseFee for 6 10% increases\n        const baseFeePad = Math.pow(1.1, 6); // tslint:disable-line: custom-no-magic-numbers\n        const paddedBaseFee = baseFee.times(baseFeePad);\n        const gasRate = paddedBaseFee.plus(instantTip);\n\n        // Use a gas estimate of a pretty high-cost pair\n        const gasEstimate = calculateGasEstimate(\n            '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9', // AAVE\n            '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC\n            'otc',\n            true,\n        );\n\n        return gasRate.times(gasEstimate);\n    }\n\n    /**\n     * Calculated by looking at historical data and seeing we average 1.5 transactions\n     * per job. This means we expect to pay 2.75 GWEI priority fee plus the base fee.\n     */\n    public async getExpectedTransactionGasRateAsync(): Promise<WeiPerGas> {\n        const baseFee = await this._gasOracle.getBaseFeePerGasWeiAsync();\n        logger.info({ baseFee: baseFee.toString() }, 'Base fee for gas rate calculation');\n        // Currently we submit a 2 GWEI tip then multiply it by 1.5 per submission\n        // Trades take ~1.5 submissions on average, so that's 2.75 GWEI\n        const avgMaxPriorityFeePerGasRate = 2750000000;\n        return baseFee.plus(avgMaxPriorityFeePerGasRate).integerValue(BigNumber.ROUND_CEIL);\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType2.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantPolygon.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\n\nimport { GWEI_DECIMALS, RFQM_TX_OTC_ORDER_GAS_ESTIMATE } from '../core/constants';\nimport { logger } from '../logger';\nimport { GasOracleType0 } from './GasOracleType0';\n\nimport { GasStationAttendant, Wei, WeiPerGas } from './GasStationAttendant';\n\n// The total minimum bid recommended by the post here:\n// https://forum.matic.network/t/recommended-min-gas-price-setting/2531\n// Expect bids lower than this to be rejected by the RPC node.\nconst MINIMUM_BID_WEI = 30000000000;\n\n// The maximum tip we're willing to pay, based on p99 historical data\n\n// Increase multiplier for tip with each resubmission cycle\nconst TEN_PERCENT_INCREASE = 1.1;\n\n/**\n * An implementation of `GasStationAttendant` designed for Polygon.\n *\n * Currently, the 0x Gas Oracle does not provide pricing for Polygon\n * in EIP-1559 format. Therefore, we'll use the 'fast' gas as a\n * `maxPriorityFeePerGas` estimate. This actually works out okay because\n * the Polygon base fee is always essentially zero as of April 2022.\n */\nexport class GasStationAttendantPolygon implements GasStationAttendant {\n    private readonly _gasOracleType0: GasOracleType0;\n\n    constructor(gasOracleType0: GasOracleType0) {\n        this._gasOracleType0 = gasOracleType0;\n    }\n\n    /**\n     * The Safe Balance For Trade is from the p95 data shown here:\n     * https://0xproject.slack.com/archives/CQG0ZGBFS/p1649708977452469\n     */\n    // tslint:disable-next-line: prefer-function-over-method\n    public async getSafeBalanceForTradeAsync(): Promise<Wei> {\n        const p95PriorityFeeGwei = 261;\n        // Base fee is essentially zero\n        // TODO (rhinodavid): Make this smarter as we have more historical data\n        const gasEstimate = RFQM_TX_OTC_ORDER_GAS_ESTIMATE;\n        // 0.0261 MATIC\n        return new BigNumber(p95PriorityFeeGwei).shiftedBy(GWEI_DECIMALS).times(gasEstimate);\n    }\n\n    /**\n     * Uses the current fast gas price as the `maxPriorityFeePerGas`\n     * estimate. Plans for 3 resubmits at a 10% tip increase. Assumes\n     * no base fee.\n     *\n     * Uses a fixed value of 110,000 for the transaction gas amount\n     * estimate.\n     */\n    public async getWorkerBalanceForTradeAsync(): Promise<WeiPerGas> {\n        // TODO (rhinodavid): Once the 0x gas oracle can give EIP-1559 data for Polygon\n        // use that instead of the legacy fast gas price.\n        const gasPriceEstimateWei = await this._gasOracleType0.getGasWeiAsync('fast');\n        logger.info({ gasPriceEstimateWei: gasPriceEstimateWei.toString() }, 'Polygon fast gas price estimate (wei)');\n\n        // Since the base fee is basically nothing, use this for our initial max priority fee\n        const maxPriorityFeePerGas = gasPriceEstimateWei;\n\n        // Pad the tip for 3 10% increases\n        const maxPriorityFeePad = Math.pow(TEN_PERCENT_INCREASE, 3); // tslint:disable-line: custom-no-magic-numbers\n        const paddedMaxPriorityFeePerGas = maxPriorityFeePerGas.times(maxPriorityFeePad);\n        const gasRateWei = BigNumber.max(paddedMaxPriorityFeePerGas.plus(0), MINIMUM_BID_WEI); // Amortizing the base fee to 0\n\n        // Pad a little until we get a better idea of token-specific costs\n        const padding = 1.1;\n        const gasEstimate = RFQM_TX_OTC_ORDER_GAS_ESTIMATE * padding;\n\n        return gasRateWei.times(gasEstimate);\n    }\n\n    /**\n     * Calculated using a similar methodology to `getWorkerBalanceForTradeAsync`,\n     * but assumes we submit and average 1.5 transactions per trade, which is\n     * what we see on Ethereum.\n     *\n     * TODO (rhinodavid): Update this once we have more historical data\n     */\n    public async getExpectedTransactionGasRateAsync(): Promise<WeiPerGas> {\n        const gasPriceEstimateWei = await this._gasOracleType0.getGasWeiAsync('fast');\n        logger.info({ gasPriceEstimateWei: gasPriceEstimateWei.toString() }, 'Polygon fast gas price estimate (wei)');\n\n        // Since the base fee is basically nothing, use this for our initial max priority fee\n        const maxPriorityFeePerGas = gasPriceEstimateWei;\n\n        // Pad the tip for 1.5 10% increases\n        const baseFeePad = Math.pow(TEN_PERCENT_INCREASE, 1.5); // tslint:disable-line: custom-no-magic-numbers\n        const paddedMaxPriorityFeePerGas = maxPriorityFeePerGas.times(baseFeePad);\n        const gasRateWei = paddedMaxPriorityFeePerGas.plus(0); // Amortizing the base fee to 0\n\n        logger.info(\n            {\n                gasPriceEstimateWei,\n                maxPriorityFeePerGas,\n                baseFeePad,\n                paddedMaxPriorityFeePerGas,\n                gasRateWei,\n            },\n            'Gas variables in Ploygon `getExpectedTransactionGasRateAsync`',\n        );\n\n        return gasRateWei.integerValue(BigNumber.ROUND_CEIL);\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType0.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantRopsten.ts",{"fileContent":"import { ProtocolFeeUtils } from '@0x/asset-swapper';\r\nimport { BigNumber } from '@0x/utils';\r\n\r\nimport { GWEI_DECIMALS, RFQM_TX_OTC_ORDER_GAS_ESTIMATE } from '../core/constants';\r\nimport { MetaTransactionSubmissionEntity, RfqmV2TransactionSubmissionEntity } from '../entities';\r\n\r\nimport { GasStationAttendant, Wei, WeiPerGas } from './GasStationAttendant';\r\nimport { SubmissionContext } from './SubmissionContext';\r\n\r\n// Increase multiplier for tip/base fee with each resubmission cycle\r\nconst TEN_PERCENT_INCREASE = 1.1;\r\n\r\n// No new trades will be submitted with a tip above 192 GWEI.\r\nconst MAXIMUM_TIP_WEI = new BigNumber(192).shiftedBy(GWEI_DECIMALS);\r\n\r\n/**\r\n * An implementation of `GasStationAttendant` designed for Ropsten.\r\n *\r\n * This should only be used for testing (I mean, it's on a test net)\r\n * and does not meet the standards of code we have for production.\r\n *\r\n * Currently, the 0x Gas Oracle does not provide pricing for Ropsten\r\n * in EIP-1559 format. Therefore, we'll use the \"pre-GasStationAttendant\"\r\n * strategy where the fast gas + padding is used for billing\r\n * and we use 1.5 GWEI tip, increasing by 2x every trade.\r\n *\r\n * Other values are best guesses.\r\n */\r\nexport class GasStationAttendantRopsten implements GasStationAttendant {\r\n    private readonly _protocolFeeUtils: ProtocolFeeUtils;\r\n\r\n    constructor(protocolFeeUtils: ProtocolFeeUtils) {\r\n        this._protocolFeeUtils = protocolFeeUtils;\r\n    }\r\n\r\n    /**\r\n     * Assumes ~100 GWEI for a trade\r\n     */\r\n    // tslint:disable-next-line: prefer-function-over-method\r\n    public async getSafeBalanceForTradeAsync(): Promise<Wei> {\r\n        const estimatedTradeRateGwei = 100;\r\n        const gasEstimate = RFQM_TX_OTC_ORDER_GAS_ESTIMATE;\r\n        return new BigNumber(estimatedTradeRateGwei).shiftedBy(GWEI_DECIMALS).times(gasEstimate);\r\n    }\r\n\r\n    /**\r\n     * Nave 2x the fast gas price for a trade\r\n     */\r\n    public async getWorkerBalanceForTradeAsync(): Promise<WeiPerGas> {\r\n        const gasPriceEstimateWei = await this._protocolFeeUtils.getGasPriceEstimationOrThrowAsync();\r\n        const gasEstimate = RFQM_TX_OTC_ORDER_GAS_ESTIMATE;\r\n\r\n        return gasPriceEstimateWei.times(2).times(gasEstimate);\r\n    }\r\n\r\n    /**\r\n     * Use the 'fast' gas plus a padding\r\n     */\r\n    public async getExpectedTransactionGasRateAsync(): Promise<WeiPerGas> {\r\n        // use that instead of the legacy fast gas price.\r\n        const gasPriceEstimateWei = await this._protocolFeeUtils.getGasPriceEstimationOrThrowAsync();\r\n        const padding = 1.5;\r\n        return gasPriceEstimateWei.times(padding).integerValue(BigNumber.ROUND_CEIL);\r\n    }\r\n\r\n    /**\r\n     * Double tip and increase maxFeePerGas by 10% to make nodes happy\r\n     */\r\n    public async getNextBidAsync(\r\n        submissionContext: SubmissionContext<\r\n            RfqmV2TransactionSubmissionEntity[] | MetaTransactionSubmissionEntity[]\r\n        > | null,\r\n    ): Promise<{ maxFeePerGas: BigNumber; maxPriorityFeePerGas: BigNumber } | null> {\r\n        const gasPriceEstimateWei = await this._protocolFeeUtils.getGasPriceEstimationOrThrowAsync();\r\n        const initialTip = new BigNumber(1.5).shiftedBy(GWEI_DECIMALS);\r\n        if (!submissionContext) {\r\n            const initialMaxPriorityFeePerGasWei = initialTip;\r\n            const initialBaseFee = gasPriceEstimateWei.times(2);\r\n            return {\r\n                maxPriorityFeePerGas: initialMaxPriorityFeePerGasWei,\r\n                maxFeePerGas: initialBaseFee.plus(initialMaxPriorityFeePerGasWei),\r\n            };\r\n        }\r\n\r\n        const { maxFeePerGas: oldMaxFeePerGas, maxPriorityFeePerGas: oldMaxPriorityFeePerGas } =\r\n            submissionContext.maxGasFees;\r\n\r\n        const newMaxPriorityFeePerGas = BigNumber.max(oldMaxPriorityFeePerGas.times(2), gasPriceEstimateWei);\r\n\r\n        if (newMaxPriorityFeePerGas.isGreaterThan(MAXIMUM_TIP_WEI)) {\r\n            return null;\r\n        }\r\n\r\n        const newMaxFeePerGas = oldMaxFeePerGas.multipliedBy(TEN_PERCENT_INCREASE);\r\n\r\n        return {\r\n            maxPriorityFeePerGas: newMaxPriorityFeePerGas.integerValue(BigNumber.ROUND_CEIL),\r\n            maxFeePerGas: newMaxFeePerGas.integerValue(BigNumber.ROUND_CEIL),\r\n        };\r\n    }\r\n}\r\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/SubmissionContext.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/provider_utils.ts",{"fileContent":"import { RPCSubprovider, SupportedProvider, Web3ProviderEngine } from '@0x/subproviders';\nimport { providerUtils as ZeroExProviderUtils } from '@0x/utils';\n\nexport const providerUtils = {\n    createWeb3Provider: (rpcHost: string): SupportedProvider => {\n        const providerEngine = new Web3ProviderEngine();\n        providerEngine.addProvider(new RPCSubprovider(rpcHost));\n        ZeroExProviderUtils.startProviderEngine(providerEngine);\n        return providerEngine;\n    },\n};\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts",{"fileContent":"// tslint:disable:max-file-line-count\n\nimport { ChainId } from '@0x/contract-addresses';\nimport { IZeroExOtcOrderFilledEventArgs, IZeroExRfqOrderFilledEventArgs } from '@0x/contract-wrappers';\nimport { IZeroExContract } from '@0x/contracts-zero-ex';\nimport { MetaTransaction, OtcOrder, RfqOrder, Signature } from '@0x/protocol-utils';\nimport { PrivateKeyWalletSubprovider, SupportedProvider, Web3ProviderEngine } from '@0x/subproviders';\nimport { AbiDecoder, BigNumber, providerUtils } from '@0x/utils';\nimport { HDNode } from '@ethersproject/hdnode';\nimport { AccessList } from '@ethersproject/transactions';\nimport { CallData, LogEntry, LogWithDecodedArgs, TxAccessList, TxData } from 'ethereum-types';\nimport { BigNumber as EthersBigNumber, constants, Contract, providers, utils, Wallet } from 'ethers';\nimport { resolveProperties } from 'ethers/lib/utils';\n\nimport { abis } from '../abis';\nimport {\n    EXECUTE_META_TRANSACTION_EIP_712_TYPES,\n    NULL_ADDRESS,\n    ONE_MINUTE_MS,\n    ONE_SECOND_MS,\n    PERMIT_EIP_712_TYPES,\n    RFQM_TX_GAS_ESTIMATE,\n    ZERO,\n    ZEROG_METATX_GAS_ESTIMATE,\n} from '../core/constants';\nimport { EIP_712_REGISTRY } from '../eip712registry';\nimport { logger } from '../logger';\nimport {\n    Approval,\n    ERC20Owner,\n    ExecuteMetaTransactionApproval,\n    GaslessApprovalTypes,\n    PermitApproval,\n} from '../core/types';\n\nimport { splitAddresses } from './address_utils';\nimport { BalanceChecker } from './balance_checker';\nimport { extractEIP712DomainType } from './Eip712Utils';\nimport { isWorkerReadyAndAbleAsync } from './rfqm_worker_balance_utils';\nimport { serviceUtils } from './service_utils';\nimport { SubproviderAdapter } from './subprovider_adapter';\n\n// allow a wide range for gas price for flexibility\nconst MIN_GAS_PRICE = new BigNumber(0);\n// 10K Gwei\nconst MAX_GAS_PRICE = new BigNumber(1e13);\nconst RFQ_ORDER_FILLED_EVENT_TOPIC0 = '0x829fa99d94dc4636925b38632e625736a614c154d55006b7ab6bea979c210c32';\nconst OTC_ORDER_FILLED_EVENT_TOPIC0 = '0xac75f773e3a92f1a02b12134d65e1f47f8a14eabe4eaf1e24624918e6a8b269f';\nconst ZERO_EX_FILL_EVENT_ABI = [\n    {\n        anonymous: false,\n        inputs: [\n            { indexed: false, internalType: 'bytes32', name: 'orderHash', type: 'bytes32' },\n            { indexed: false, internalType: 'address', name: 'maker', type: 'address' },\n            { indexed: false, internalType: 'address', name: 'taker', type: 'address' },\n            { indexed: false, internalType: 'address', name: 'makerToken', type: 'address' },\n            { indexed: false, internalType: 'address', name: 'takerToken', type: 'address' },\n            { indexed: false, internalType: 'uint128', name: 'takerTokenFilledAmount', type: 'uint128' },\n            { indexed: false, internalType: 'uint128', name: 'makerTokenFilledAmount', type: 'uint128' },\n            { indexed: false, internalType: 'bytes32', name: 'pool', type: 'bytes32' },\n        ],\n        name: 'RfqOrderFilled',\n        type: 'event',\n    },\n    {\n        anonymous: false,\n        inputs: [\n            { indexed: false, internalType: 'bytes32', name: 'orderHash', type: 'bytes32' },\n            { indexed: false, internalType: 'address', name: 'maker', type: 'address' },\n            { indexed: false, internalType: 'address', name: 'taker', type: 'address' },\n            { indexed: false, internalType: 'address', name: 'makerToken', type: 'address' },\n            { indexed: false, internalType: 'address', name: 'takerToken', type: 'address' },\n            { indexed: false, internalType: 'uint128', name: 'makerTokenFilledAmount', type: 'uint128' },\n            { indexed: false, internalType: 'uint128', name: 'takerTokenFilledAmount', type: 'uint128' },\n        ],\n        name: 'OtcOrderFilled',\n        type: 'event',\n    },\n];\n\nfunction toBigNumber(ethersBigNumber: EthersBigNumber): BigNumber {\n    return new BigNumber(ethersBigNumber.toString());\n}\n\nexport class RfqBlockchainUtils {\n    public readonly balanceCheckUtils: RfqBalanceCheckUtils;\n\n    private readonly _exchangeProxy: IZeroExContract;\n    private readonly _abiDecoder: AbiDecoder;\n    // An ethers.js provider.\n    private readonly _ethersProvider: providers.JsonRpcProvider;\n    // An ethers.js Wallet. Must be populated for RfqBlockchainUtils instances used by RFQM Workers.\n    private readonly _ethersWallet: Wallet | undefined;\n\n    public static getPrivateKeyFromIndexAndPhrase(mnemonic: string, index: number): string {\n        const hdNode = HDNode.fromMnemonic(mnemonic).derivePath(this._getPathByIndex(index));\n\n        // take '0x' off\n        return hdNode.privateKey.substring(2);\n    }\n\n    public static getAddressFromIndexAndPhrase(mnemonic: string, index: number): string {\n        const hdNode = HDNode.fromMnemonic(mnemonic).derivePath(this._getPathByIndex(index));\n\n        return hdNode.address;\n    }\n\n    public static createPrivateKeyProvider(\n        rpcProvider: SupportedProvider,\n        privateWalletSubprovider: PrivateKeyWalletSubprovider,\n    ): SupportedProvider {\n        const providerEngine = new Web3ProviderEngine();\n        providerEngine.addProvider(privateWalletSubprovider);\n        providerEngine.addProvider(new SubproviderAdapter(rpcProvider));\n        providerUtils.startProviderEngine(providerEngine);\n        return providerEngine;\n    }\n\n    // tslint:disable-next-line:prefer-function-over-method\n    private static _getPathByIndex(index: number): string {\n        // ensure index is a 0+ integer\n        if (index < 0 || index !== Math.floor(index)) {\n            throw new Error(`invalid index`);\n        }\n        return `m/44'/60'/0'/0/`.concat(String(index));\n    }\n\n    constructor(\n        provider: SupportedProvider,\n        private readonly _exchangeProxyAddress: string,\n        balanceChecker: BalanceChecker,\n        ethersProvider: providers.JsonRpcProvider,\n        ethersWallet?: Wallet,\n    ) {\n        this._abiDecoder = new AbiDecoder([ZERO_EX_FILL_EVENT_ABI]);\n        this.balanceCheckUtils = new RfqBalanceCheckUtils(balanceChecker, _exchangeProxyAddress);\n        this._ethersProvider = ethersProvider;\n        this._ethersWallet = ethersWallet;\n        this._exchangeProxy = new IZeroExContract(this._exchangeProxyAddress, provider);\n    }\n\n    /**\n     * Fetches min value between balance for a list of addresses against the specified tokens. The index of\n     * an address in `addresses` must correspond with the index of a token in `tokens`.\n     */\n    public async getMinOfBalancesAndAllowancesAsync(erc20Owners: ERC20Owner | ERC20Owner[]): Promise<BigNumber[]> {\n        return this.balanceCheckUtils.getMinOfBalancesAndAllowancesAsync(erc20Owners);\n    }\n\n    /**\n     * Fetches the balances for a list of addresses against the specified tokens. The index of\n     * an address in `addresses` must correspond with the index of a token in `tokens`.\n     */\n    public async getTokenBalancesAsync(erc20Owners: ERC20Owner | ERC20Owner[]): Promise<BigNumber[]> {\n        return this.balanceCheckUtils.getTokenBalancesAsync(erc20Owners);\n    }\n\n    // for use when 0x API operator submits an order on-chain on behalf of taker\n    public generateMetaTransaction(\n        rfqOrder: RfqOrder,\n        signature: Signature,\n        taker: string,\n        takerAmount: BigNumber,\n        chainId: ChainId,\n    ): MetaTransaction {\n        // generate call data for fillRfqOrder\n        const callData = this._exchangeProxy\n            .fillRfqOrder(rfqOrder, signature, takerAmount)\n            .getABIEncodedTransactionData();\n\n        return new MetaTransaction({\n            signer: taker,\n            sender: NULL_ADDRESS,\n            minGasPrice: MIN_GAS_PRICE,\n            maxGasPrice: MAX_GAS_PRICE,\n            expirationTimeSeconds: rfqOrder.expiry,\n            salt: new BigNumber(Date.now()),\n            callData,\n            value: ZERO,\n            feeToken: NULL_ADDRESS,\n            feeAmount: ZERO,\n            chainId,\n            verifyingContract: this._exchangeProxy.address,\n        });\n    }\n\n    public async decodeMetaTransactionCallDataAndValidateAsync(\n        calldata: string,\n        sender: string,\n        txOptions?: Partial<CallData>,\n    ): Promise<[BigNumber, BigNumber]> {\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const metaTxInput: any = this._exchangeProxy.getABIDecodedTransactionData('executeMetaTransaction', calldata);\n        return this.validateMetaTransactionOrThrowAsync(metaTxInput[0], metaTxInput[1], sender, txOptions);\n    }\n\n    /**\n     * Validates a metatransaction and its signature for a given sender\n     *\n     * @returns a Promise of [takerTokenFilledAmount, makerTokenFilledAmount]\n     * @throws an error if the metatransaction is not valid\n     */\n    public async validateMetaTransactionOrThrowAsync(\n        metaTx: MetaTransaction,\n        metaTxSig: Signature,\n        sender: string,\n        txOptions?: Partial<CallData>,\n    ): Promise<[BigNumber, BigNumber]> {\n        try {\n            const results = await this._exchangeProxy\n                .executeMetaTransaction(metaTx, metaTxSig)\n                .callAsync({ from: sender, ...txOptions });\n            const takerTokenFillAmount = // $eslint-fix-me github.com/rhinodavid/eslint-fix-me\n                /* eslint-disable @typescript-eslint/no-explicit-any */\n                (\n                    this._exchangeProxy.getABIDecodedTransactionData('fillRfqOrder', metaTx.callData) as any\n                ) /* eslint-enable @typescript-eslint/no-explicit-any */[2];\n            const decodedResults: [BigNumber, BigNumber] = this._exchangeProxy.getABIDecodedReturnData(\n                'fillRfqOrder',\n                results,\n            );\n            if (decodedResults[0].isLessThan(takerTokenFillAmount)) {\n                logger.error('validation failed because filled amount is less than requested fill amount');\n                throw new Error(`filled amount is less than requested fill amount`);\n            }\n            return decodedResults;\n        } catch (err) {\n            logger.error({ errorMessage: err?.message }, 'eth_call validation failed for executeMetaTransaction');\n            throw new Error(err);\n        }\n    }\n\n    /**\n     * Simulate the transaction with calldata.\n     *\n     * NOTE: In ethers.js, provider.call and provider.send('eth_call', ...) might not throw exception.\n     *       The behavior might be dependent on providers. Revisit this later.\n     */\n    public async simulateTransactionAsync(to: string, calldata: string): Promise<void> {\n        try {\n            await this._ethersProvider.call({\n                to,\n                data: calldata,\n            });\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `simulateTransactionAsync: ${e.message}`;\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Estimate the gas for fillTakerSignedOtcOrder and fillTakerSignedOtcOrderForEth\n     * NOTE: can also be used for validation\n     *\n     * @returns a Promise of the gas estimate\n     * @throws an error if transaction will revert\n     */\n    public async estimateGasForFillTakerSignedOtcOrderAsync(\n        order: OtcOrder,\n        makerSignature: Signature,\n        takerSignature: Signature,\n        sender: string,\n        isUnwrap: boolean,\n    ): Promise<number> {\n        try {\n            if (isUnwrap) {\n                return await this._exchangeProxy\n                    .fillTakerSignedOtcOrderForEth(order, makerSignature, takerSignature)\n                    .estimateGasAsync({ from: sender });\n            } else {\n                return await this._exchangeProxy\n                    .fillTakerSignedOtcOrder(order, makerSignature, takerSignature)\n                    .estimateGasAsync({ from: sender });\n            }\n        } catch (err) {\n            logger.error(\n                {\n                    orderHash: order.getHash(),\n                    maker: order.maker,\n                    taker: order.taker,\n                    isUnwrap,\n                    errorMessage: err?.message,\n                },\n                'validation failed for taker signed OtcOrder',\n            );\n            throw err;\n        }\n    }\n\n    /**\n     * Generates calldata for Taker Signed OtcOrder settlement\n     */\n    public generateTakerSignedOtcOrderCallData(\n        order: OtcOrder,\n        makerSignature: Signature,\n        takerSignature: Signature,\n        isUnwrap: boolean,\n        affiliateAddress: string | null,\n    ): string {\n        const callData = isUnwrap\n            ? this._exchangeProxy\n                  .fillTakerSignedOtcOrderForEth(order, makerSignature, takerSignature)\n                  .getABIEncodedTransactionData()\n            : this._exchangeProxy\n                  .fillTakerSignedOtcOrder(order, makerSignature, takerSignature)\n                  .getABIEncodedTransactionData();\n        return serviceUtils.attributeCallData(callData, affiliateAddress).affiliatedData;\n    }\n\n    public generateMetaTransactionCallData(\n        metaTx: MetaTransaction,\n        metaTxSig: Signature,\n        affiliateAddress: string | null,\n    ): string {\n        const callData = this._exchangeProxy.executeMetaTransaction(metaTx, metaTxSig).getABIEncodedTransactionData();\n        return serviceUtils.attributeCallData(callData, affiliateAddress).affiliatedData;\n    }\n\n    public async getNonceAsync(workerAddress: string): Promise<number> {\n        return this._ethersProvider.getTransactionCount(workerAddress);\n    }\n\n    public getExchangeProxyAddress(): string {\n        return this._exchangeProxyAddress;\n    }\n\n    /**\n     * Returns the transaction receipts for the given transaction hashes.\n     * If a receipt does not exist, returns `undefined`.\n     */\n    public async getReceiptsAsync(transactionHashes: string[]): Promise<(providers.TransactionReceipt | undefined)[]> {\n        return Promise.all(\n            transactionHashes.map(async (transactionHash) =>\n                this._ethersProvider.getTransactionReceipt(transactionHash),\n            ),\n        );\n    }\n\n    public async getCurrentBlockAsync(): Promise<number> {\n        return this._ethersProvider.getBlockNumber();\n    }\n\n    // Fetches a block from the block number or block hash\n    public async getBlockAsync(blockHash: providers.BlockTag): Promise<providers.Block> {\n        return this._ethersProvider.getBlock(blockHash);\n    }\n\n    /**\n     * Passthrough to the ethers `getTransaction` function\n     * https://docs.ethers.io/v5/api/providers/provider/#Provider-getTransaction:\n     *\n     * Returns the transaction with hash or null if the transaction is unknown.\n     * If a transaction has not been mined, this method will search the transaction pool.\n     * Various backends may have more restrictive transaction pool access\n     * (e.g. if the gas price is too low or the transaction was only recently sent and not yet indexed)\n     * in which case this method may also return null.\n     */\n    public async getTransactionAsync(transactionHash: string): Promise<providers.TransactionResponse | null> {\n        return this._ethersProvider.getTransaction(transactionHash);\n    }\n\n    /**\n     * Estimate gas (in wei) given a transaction request using `eth_estimateGas` JSON RPC method.\n     * The transaction request contains information related to the transaction (from, to, data, etc.).\n     *\n     * @param transactionRequest Transaction request object which contains information about the transaction.\n     * @returns The gas estimate for the transaction in wei.\n     */\n    public async estimateGasForAsync(transactionRequest: providers.TransactionRequest): Promise<number> {\n        try {\n            const gasEstimate = await this._ethersProvider.estimateGas(transactionRequest);\n            return gasEstimate.toNumber();\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `estimateGasForAsync: ${e.message}`;\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Get the access list and the gas estimation given a transaction request. Uses the provider\n     * to call the `eth_createAccessList` JSON RPC method.\n     *\n     * The transaction request contains information related to the transaction (from, to, data, etc.).\n     * Note that the implementation is similar to the one in @0x/web3-wrapper. This repo is\n     * migrating away from web3-wrapper in favor of ethers. The original implementation in\n     * web3-wrapper:\n     * https://github.com/0xProject/tools/blob/development/web3-wrapper/src/web3_wrapper.ts#L591\n     *\n     * @param transactionRequest Transaction request object which contains information about the transaction.\n     * @returns A TxAccessListWithGas object which contains access list and gas estimation for the transaction.\n     */\n    public async createAccessListForAsync(\n        transactionRequest: providers.TransactionRequest,\n    ): Promise<{ accessList: TxAccessList; gasEstimate: number }> {\n        try {\n            const rawResult = await this._ethersProvider.send('eth_createAccessList', [transactionRequest]);\n            const accessList: AccessList = rawResult.accessList;\n            const gasUsed: string = rawResult.gasUsed;\n\n            return {\n                // The type for `accessList` is `AccessList` (Array<{ address: string, storageKeys: Array<string> }>).\n                // The reduce operation is used to transform the array into type `TxAccessList` ([address: string]: string[]) whose keys\n                // are addresses and values are corresponding storage keys. This is useful if we need to remove an address from the object.\n                accessList: accessList.reduce((o: TxAccessList, v: { address: string; storageKeys: string[] }) => {\n                    o[v.address] = o[v.address] || [];\n                    o[v.address].push(...(v.storageKeys || []));\n                    return o;\n                }, {}),\n                gasEstimate: new BigNumber(gasUsed).toNumber(),\n            };\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `createAccessListForAsync: ${e.message}`;\n            }\n\n            throw e;\n        }\n    }\n\n    public getDecodedRfqOrderFillEventLogFromLogs(\n        logs: LogEntry[],\n    ): LogWithDecodedArgs<IZeroExRfqOrderFilledEventArgs> {\n        for (const log of logs) {\n            if (log.topics[0] === RFQ_ORDER_FILLED_EVENT_TOPIC0) {\n                return this._abiDecoder.tryToDecodeLogOrNoop(log) as LogWithDecodedArgs<IZeroExRfqOrderFilledEventArgs>;\n            }\n        }\n        throw new Error(\n            `no RfqOrderFilledEvent logs among the logs passed into getDecodedRfqOrderFillEventLogFromLogs`,\n        );\n    }\n\n    /**\n     * Decode the OtcOrder Filled Event\n     */\n    public getDecodedOtcOrderFillEventLogFromLogs(\n        logs: LogEntry[],\n    ): LogWithDecodedArgs<IZeroExOtcOrderFilledEventArgs> {\n        for (const log of logs) {\n            if (log.topics[0] === OTC_ORDER_FILLED_EVENT_TOPIC0) {\n                return this._abiDecoder.tryToDecodeLogOrNoop(log) as LogWithDecodedArgs<IZeroExRfqOrderFilledEventArgs>;\n            }\n        }\n        throw new Error(\n            `no OtcOrderFilledEvent logs among the logs passed into getDecodedOtcOrderFillEventLogFromLogs`,\n        );\n    }\n\n    /**\n     * Broadcasts a raw transaction via the `eth_sendRawTransaction` JSON RPC method.\n     * The transaction must be signed by this point, otherwise submission will fail.\n     *\n     * @returns The transaction hash returned by the RPC provider.\n     */\n    public async submitSignedTransactionAsync(signedTransaction: string): Promise<string> {\n        const response = await this._ethersProvider.sendTransaction(signedTransaction);\n        return response.hash;\n    }\n\n    public async getAccountBalanceAsync(accountAddress: string): Promise<BigNumber> {\n        return this._ethersProvider.getBalance(accountAddress).then((r) => toBigNumber(r));\n    }\n\n    /**\n     * Check if a worker is ready to pick up a new job:\n     * - the worker has enough balance\n     * - the worker has no pending transactions\n     *\n     * @param chainId Id of the chain.\n     * @param workerAddress Address of the worker to check.\n     * @param balance Balance of the worker to check.\n     * @param gasPrice Current gas price.\n     * @returns True if a worker is ready to pick up a new job and false otherwise.\n     */\n    public async isWorkerReadyAsync(\n        chainId: ChainId,\n        workerAddress: string,\n        balance: BigNumber,\n        gasPrice: BigNumber,\n    ): Promise<boolean> {\n        let gasEstimate;\n        switch (chainId) {\n            case ChainId.Polygon:\n                gasEstimate = ZEROG_METATX_GAS_ESTIMATE;\n                break;\n            default:\n                gasEstimate = RFQM_TX_GAS_ESTIMATE;\n                break;\n        }\n\n        return isWorkerReadyAndAbleAsync(this._ethersProvider, workerAddress, balance, gasPrice, gasEstimate);\n    }\n\n    /**\n     * Converts a @0x/web3-wrapper `TxData` object into an Ethers `TransactionRequest`.\n     *\n     * If the `from` address is not present in the `TxData`, the function uses the address\n     * of the Ethers Wallet passed to `rfqBlockchainUtils`\n     *\n     * If the `to` address is not present, the function uses the exchange proxy address.\n     */\n    public transformTxDataToTransactionRequest(\n        txOptions: Partial<TxData>,\n        chainId?: ChainId,\n        callData?: utils.BytesLike,\n    ): providers.TransactionRequest {\n        const baseRequest = {\n            chainId,\n            data: callData,\n            from: txOptions.from,\n            // web3wrappers \"gas\" field -> ethers \"gasLimit\" field\n            gasLimit: txOptions.gas instanceof BigNumber ? BigInt(txOptions.gas.toString()) : txOptions.gas,\n            nonce: txOptions.nonce,\n            to: txOptions.to || this._exchangeProxy.address,\n            value: txOptions.value instanceof BigNumber ? txOptions.value.toString() : txOptions.value,\n        };\n\n        // Handle Type 0 (Legacy) Tx\n        if (txOptions.gasPrice) {\n            return {\n                ...baseRequest,\n                type: 0,\n                gasPrice: txOptions.gasPrice instanceof BigNumber ? txOptions.gasPrice.toString() : txOptions.gasPrice,\n            };\n        }\n\n        // Handle Type 2 (EIP-1559) Tx\n        return {\n            ...baseRequest,\n            type: 2,\n            maxFeePerGas:\n                txOptions.maxFeePerGas instanceof BigNumber\n                    ? BigInt(txOptions.maxFeePerGas.toString())\n                    : txOptions.maxFeePerGas,\n            maxPriorityFeePerGas:\n                txOptions.maxPriorityFeePerGas instanceof BigNumber\n                    ? BigInt(txOptions.maxPriorityFeePerGas.toString())\n                    : txOptions.maxPriorityFeePerGas,\n        };\n    }\n\n    /**\n     * Uses the Ethers Wallet to sign a transaction. Returns both the signed transaction and its hash.\n     *\n     * If the containing class has been initialized without a wallet, the function throws.\n     */\n    public async signTransactionAsync(\n        transaction: providers.TransactionRequest,\n    ): Promise<{ signedTransaction: string; transactionHash: string }> {\n        if (!this._ethersWallet) {\n            throw new Error(\n                'RFQ Blockchain Utils must be initialized with an Ethers Wallet in order to get transaction hashes before submitting',\n            );\n        }\n\n        const checkedRequest = await resolveProperties(this._ethersWallet.checkTransaction(transaction));\n        const signedTransaction = await this._ethersWallet.signTransaction(checkedRequest);\n        const hash = utils.keccak256(signedTransaction);\n        return { signedTransaction, transactionHash: hash };\n    }\n\n    public async getTokenDecimalsAsync(tokenAddress: string): Promise<number> {\n        const erc20AbiDecimals = `[{\n            \"constant\": true,\n            \"inputs\": [],\n            \"name\": \"decimals\",\n            \"outputs\": [\n                {\n                    \"name\": \"\",\n                    \"type\": \"uint8\"\n                }\n            ],\n            \"payable\": false,\n            \"stateMutability\": \"view\",\n            \"type\": \"function\"\n        }]`;\n        const tokenContract = new Contract(tokenAddress, erc20AbiDecimals, this._ethersProvider);\n        const decimals = await tokenContract.decimals();\n        if (typeof decimals !== 'number') {\n            throw new Error('Decimals was not a number');\n        }\n        return decimals;\n    }\n\n    /**\n     * Calls the 0x Exchange Proxy to add an address to the list of allowed order signers for the msg's sender.\n     */\n    public async registerAllowedOrderSignerAsync(\n        from: string,\n        signerAddress: string,\n        isAllowed: boolean,\n    ): Promise<void> {\n        // tslint:disable-next-line: await-promise\n        await this._exchangeProxy\n            .registerAllowedOrderSigner(signerAddress, isAllowed)\n            .awaitTransactionSuccessAsync({ from });\n    }\n\n    /**\n     * Returns whether the signer address is an allowed order signer of the maker.\n     */\n    public async isValidOrderSignerAsync(makerAddress: string, signerAddress: string): Promise<boolean> {\n        return this._exchangeProxy.isValidOrderSigner(makerAddress, signerAddress).callAsync();\n    }\n\n    /**\n     * Get the gasless approval object which encapsulates the EIP-712 context that would be signed by the `takerAddress`\n     * for gasless approval. The two main schemes for gasless approvals are `executeMetaTransaction` and `permit`.\n     *\n     * @param chainId Id of the chain.\n     * @param token The address of the token.\n     * @param takerAddress The address of the taker.\n     * @param nowMs optional - the current timestamp in milliseconds\n     * @returns The corresponding gasless approval oject or null if the token does not support gasless approval (does not exist in our EIP-712 token registry).\n     */\n    public async getGaslessApprovalAsync(\n        chainId: number,\n        token: string,\n        takerAddress: string,\n        nowMs: number = Date.now(),\n    ): Promise<Approval | null> {\n        // If the token does not exist in the token registry, return null\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line no-prototype-builtins\n        if (!EIP_712_REGISTRY.hasOwnProperty(chainId) || !EIP_712_REGISTRY[chainId].hasOwnProperty(token)) {\n            return null;\n        }\n\n        const tokenEIP712 = EIP_712_REGISTRY[chainId][token];\n        const eip712DomainType = extractEIP712DomainType(tokenEIP712.domain);\n        switch (tokenEIP712.kind) {\n            case GaslessApprovalTypes.ExecuteMetaTransaction: {\n                const nonce = await this.getMetaTransactionNonceAsync(token, takerAddress);\n                // generate calldata for approve with max number of uint256 as amount\n                const erc20 = new Contract(token, abis.polygonBridgedERC20, this._ethersProvider);\n                const { data: approveCalldata } = await erc20.populateTransaction.approve(\n                    this._exchangeProxyAddress,\n                    constants.MaxUint256,\n                );\n\n                const executeMetaTransactionApproval: ExecuteMetaTransactionApproval = {\n                    kind: GaslessApprovalTypes.ExecuteMetaTransaction,\n                    eip712: {\n                        types: {\n                            ...eip712DomainType,\n                            ...EXECUTE_META_TRANSACTION_EIP_712_TYPES,\n                        },\n                        primaryType: 'MetaTransaction',\n                        domain: tokenEIP712.domain,\n                        message: {\n                            nonce: nonce.toNumber(),\n                            from: takerAddress,\n                            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            functionSignature: approveCalldata!,\n                        },\n                    },\n                };\n\n                return executeMetaTransactionApproval;\n            }\n            case GaslessApprovalTypes.Permit: {\n                const nonce = await this.getPermitNonceAsync(token, takerAddress);\n                const tenMinutesAfterNowS = new BigNumber(nowMs + ONE_MINUTE_MS * 10).div(ONE_SECOND_MS).integerValue();\n                const permitApproval: PermitApproval = {\n                    kind: GaslessApprovalTypes.Permit,\n                    eip712: {\n                        types: {\n                            ...eip712DomainType,\n                            ...PERMIT_EIP_712_TYPES,\n                        },\n                        primaryType: 'Permit',\n                        domain: tokenEIP712.domain,\n                        message: {\n                            owner: takerAddress,\n                            spender: this._exchangeProxyAddress,\n                            value: constants.MaxUint256.toString(),\n                            nonce: nonce.toNumber(),\n                            deadline: tenMinutesAfterNowS.toString(),\n                        },\n                    },\n                };\n\n                return permitApproval;\n            }\n            default:\n                throw new Error(`Gasless approval kind ${tokenEIP712.kind} is not implemented yet`);\n        }\n    }\n\n    /**\n     * Get the amount (in base unit) of `token` `spender` will be allowed to spend on behalf on `owner` (the allowance). Note that\n     * base unit means 10 ** decimals (decimals of the token).\n     *\n     * @param token The address of the token.\n     * @param owner The address that owns certain amount of `token`.\n     * @param spender The address that would like to spend token on behalf of `owner`.\n     * @returns The amount (in base unit) of tokens spender is allowed to spend.\n     */\n    public async getAllowanceAsync(token: string, owner: string, spender: string): Promise<BigNumber> {\n        const erc20 = new Contract(token, abis.polygonBridgedERC20, this._ethersProvider);\n        const allowance = await erc20.allowance(owner, spender);\n        return new BigNumber(allowance.toString());\n    }\n\n    /**\n     * Get nonce for meta transaction. This is used by contracts that support Biconomy's `executeMetaTransaction` which includes bridged tokens on Polygon.\n     *\n     * @param token The address of the token.\n     * @param takerAddress The address of the taker.\n     * @returns Nonce.\n     */\n    public async getMetaTransactionNonceAsync(token: string, takerAddress: string): Promise<BigNumber> {\n        const erc20 = new Contract(token, abis.polygonBridgedERC20, this._ethersProvider);\n        const nonce = await erc20.getNonce(takerAddress);\n        return new BigNumber(nonce.toString());\n    }\n\n    /**\n     * Get permit nonce, which is used by contracts that support EIP-2612 standards.\n     *\n     * @param token The address of the token.\n     * @param takerAddress The address of the taker.\n     * @returns Nonce.\n     */\n    public async getPermitNonceAsync(token: string, takerAddress: string): Promise<BigNumber> {\n        const erc20 = new Contract(token, abis.permitERC20, this._ethersProvider);\n        const nonce = await erc20.nonces(takerAddress);\n        return new BigNumber(nonce.toString());\n    }\n\n    /**\n     * Generates calldata for gasless approval submission.\n     *\n     * @param token The address of the token.\n     * @param approval The Approval object, which consists of 'kind' and eip712 object.\n     * @param signature The gasless approval transaction signed by taker.\n     * @returns Generated calldata.\n     */\n    public async generateApprovalCalldataAsync(\n        token: string,\n        approval: Approval,\n        signature: Signature,\n    ): Promise<string> {\n        const { kind, eip712 } = approval;\n        switch (kind) {\n            case GaslessApprovalTypes.ExecuteMetaTransaction: {\n                const erc20 = new Contract(token, abis.polygonBridgedERC20, this._ethersProvider);\n                const { data } = await erc20.populateTransaction.executeMetaTransaction(\n                    eip712.message.from,\n                    eip712.message.functionSignature,\n                    signature.r,\n                    signature.s,\n                    signature.v,\n                );\n                if (!data) {\n                    throw new Error(`Cannot generate approval submission calldata for ${kind}`);\n                }\n                return data;\n            }\n            case GaslessApprovalTypes.Permit: {\n                const erc20 = new Contract(token, abis.permitERC20, this._ethersProvider);\n                const { data } = await erc20.populateTransaction.permit(\n                    eip712.message.owner,\n                    eip712.message.spender,\n                    eip712.message.value,\n                    eip712.message.deadline,\n                    signature.v,\n                    signature.r,\n                    signature.s,\n                );\n                if (!data) {\n                    throw new Error(`Cannot generate approval submission calldata for ${kind}`);\n                }\n                return data;\n            }\n            default:\n                throw new Error(`Gasless approval kind ${kind} is not implemented yet`);\n        }\n    }\n}\n\nexport class RfqBalanceCheckUtils {\n    constructor(private readonly _balanceChecker: BalanceChecker, private readonly _exchangeProxyAddress: string) {}\n\n    /**\n     * Fetches min value between balance for a list of addresses against the specified tokens. The index of\n     * an address in `addresses` must correspond with the index of a token in `tokens`.\n     */\n    public async getMinOfBalancesAndAllowancesAsync(erc20Owners: ERC20Owner | ERC20Owner[]): Promise<BigNumber[]> {\n        const { owners, tokens } = splitAddresses(erc20Owners);\n        return this._balanceChecker.getMinOfBalancesAndAllowancesAsync(owners, tokens, this._exchangeProxyAddress);\n    }\n\n    /**\n     * Fetches the balances for a list of addresses against the specified tokens. The index of\n     * an address in `addresses` must correspond with the index of a token in `tokens`.\n     */\n    public async getTokenBalancesAsync(erc20Owners: ERC20Owner | ERC20Owner[]): Promise<BigNumber[]> {\n        const { owners, tokens } = splitAddresses(erc20Owners);\n        return this._balanceChecker.getTokenBalancesAsync(owners, tokens);\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/PermitERC20.json","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/PolygonBridgedERC20.json","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/ethereum.json","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/polygon.json","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/number_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts",{"fileContent":"// PermitERC20.json is extracted from https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2ERC20.sol\nimport * as permitERC20 from './PermitERC20.json';\n// PolygonBridgedERC20.json is from https://github.com/maticnetwork/pos-portal/blob/master/artifacts/ChildERC20.json\nimport * as polygonBridgedERC20 from './PolygonBridgedERC20.json';\n\nexport const abis = {\n    polygonBridgedERC20: polygonBridgedERC20.abi,\n    permitERC20: permitERC20.abi,\n};\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/abis/PermitERC20.json","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/PolygonBridgedERC20.json"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts",{"fileContent":"import { Eip712Domain } from '../core/types';\n\nimport * as ethereum from './ethereum.json';\nimport * as polygon from './polygon.json';\n\nexport const EIP_712_REGISTRY: Record<\n    number,\n    Record<string, { kind: string; domain: Eip712Domain; domainSeparator: string }>\n> = {\n    1: ethereum,\n    137: polygon,\n};\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/ethereum.json","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/polygon.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts",{"fileContent":"import { Eip712DataField, Eip712Domain } from '../core/types';\n\nconst NAME_TO_TYPES: Record<string, string> = {\n    name: 'string',\n    version: 'string',\n    chainId: 'uint256',\n    verifyingContract: 'address',\n    salt: 'bytes32',\n};\n\n// Beware, we use Eip lowercase in our code, but we must use \"EIP\" in caps to adhere\n// to eth_signTypedData_v4. Confusingly, ethers.js does not accept the EIP712Domain type,\n// but it's easier to delete this value than create it\nexport const extractEIP712DomainType = (domain: Eip712Domain): { EIP712Domain: Eip712DataField[] } => {\n    const fields = Object.keys(domain).map((name) => ({ name, type: NAME_TO_TYPES[name] }));\n    return {\n        EIP712Domain: fields,\n    };\n};\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { BlockParamLiteral } from 'ethereum-types';\nimport { providers } from 'ethers';\n\nimport { logger } from '../logger';\n\nconst MIN_NUM_TRADES_FOR_HEALTHCHECK = 3;\n\n/**\n * Returns true if a metatransaction worker is able to pick up new work, i.e. the\n * worker has enough balance to trade and has no pending transactions.\n *\n * The function will also emit logs if it was to find issues.\n *\n * @param wrapper the Web3Wrapper instance\n * @param accountAddress the EOA address of the worker\n * @param accountBalance the balance of the worker\n * @param gasPriceBaseUnits the current gas price\n * @param gasEstimatePerTx the gas estimate for a transaction. If a chain supports different types of trades (for example, RFQm and metatxn),\n *                        this value should be the max gas estimate among different types.\n * @returns true if the metatransaction worker can pick up work.\n */\nexport async function isWorkerReadyAndAbleAsync(\n    provider: providers.Provider,\n    accountAddress: string,\n    accountBalance: BigNumber,\n    gasPriceBaseUnits: BigNumber,\n    gasEstimatePerTx: number,\n): Promise<boolean> {\n    // Check worker has enough ETH to support 3 trades\n    const minimumCostToTrade = gasPriceBaseUnits.times(gasEstimatePerTx).times(MIN_NUM_TRADES_FOR_HEALTHCHECK);\n    const hasEnoughBalance = accountBalance.gte(minimumCostToTrade);\n    if (!hasEnoughBalance) {\n        logger.error(\n            {\n                accountAddress,\n                accountBalance: accountBalance.toString(),\n                minimumCostToTrade: minimumCostToTrade.toString(),\n                gasPriceBaseUnits: gasPriceBaseUnits.toString(),\n            },\n            'Worker does not have enough balance to trade.',\n        );\n    }\n    if (!hasEnoughBalance) {\n        return false;\n    }\n\n    // check worker has no pending transactions\n    const lastNonceOnChain = await provider.getTransactionCount(accountAddress);\n    const lastNoncePending = await provider.getTransactionCount(accountAddress, BlockParamLiteral.Pending);\n    const hasNoPendingTransactions = lastNonceOnChain.toString() === lastNoncePending.toString();\n    if (!hasNoPendingTransactions) {\n        logger.error(\n            {\n                accountAddress,\n                lastNonceOnChain: lastNonceOnChain.toString(),\n                lastNoncePending: lastNoncePending.toString(),\n            },\n            'Worker has pending transactions and cannot trade.',\n        );\n    }\n\n    return hasNoPendingTransactions;\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts",{"fileContent":"import { AbiEncoder, BigNumber } from '@0x/utils';\n\nimport { FEE_RECIPIENT_ADDRESS } from '../config';\nimport { HEX_BASE, ONE_SECOND_MS } from '../core/constants';\n\nimport { numberUtils } from './number_utils';\n\nexport const serviceUtils = {\n    attributeCallData(\n        data: string,\n        affiliateAddress: string | null,\n    ): {\n        affiliatedData: string;\n        decodedUniqueId: string;\n    } {\n        const affiliateAddressOrDefault = affiliateAddress ? affiliateAddress : FEE_RECIPIENT_ADDRESS;\n        const affiliateCallDataEncoder = new AbiEncoder.Method({\n            constant: true,\n            outputs: [],\n            name: 'ZeroExAPIAffiliate',\n            inputs: [\n                { name: 'affiliate', type: 'address' },\n                { name: 'timestamp', type: 'uint256' },\n            ],\n            payable: false,\n            stateMutability: 'view',\n            type: 'function',\n        });\n\n        // Generate unique identiifer\n        const timestampInSeconds = new BigNumber(Date.now() / ONE_SECOND_MS).integerValue();\n        const hexTimestamp = timestampInSeconds.toString(HEX_BASE);\n        const randomNumber = numberUtils.randomHexNumberOfLength(10);\n\n        // Concatenate the hex identifier with the hex timestamp\n        // In the final encoded call data, this will leave us with a 5-byte ID followed by\n        // a 4-byte timestamp, and won't break parsers of the timestamp made prior to the\n        // addition of the ID\n        const uniqueIdentifier = new BigNumber(`${randomNumber}${hexTimestamp}`, HEX_BASE);\n\n        // Encode additional call data and return\n        const encodedAffiliateData = affiliateCallDataEncoder.encode([affiliateAddressOrDefault, uniqueIdentifier]);\n        const affiliatedData = `${data}${encodedAffiliateData.slice(2)}`;\n        return { affiliatedData, decodedUniqueId: `${randomNumber}-${timestampInSeconds}` };\n    },\n};\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/number_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts",{"fileContent":"import {\n    Callback,\n    ErrorCallback,\n    JSONRPCRequestPayload,\n    Subprovider,\n    SupportedProvider,\n    ZeroExProvider,\n} from '@0x/subproviders';\nimport { providerUtils } from '@0x/utils';\n\nexport class SubproviderAdapter extends Subprovider {\n    private readonly _provider: ZeroExProvider;\n    constructor(provider: SupportedProvider) {\n        super();\n        this._provider = providerUtils.standardizeOrThrow(provider);\n    }\n    // tslint:disable-next-line:async-suffix\n    public async handleRequest(payload: JSONRPCRequestPayload, _next: Callback, end: ErrorCallback): Promise<void> {\n        this._provider.sendAsync(payload, (err, result) => {\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            result != null && result!.result != null\n                ? // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  end(null, result!.result)\n                : // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  end(err || new Error(result!.error?.message));\n        });\n    }\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts",{"fileContent":"import * as EventEmitter from 'events';\nimport { Counter, Summary } from 'prom-client';\n\nimport { MakerIdSet, RfqWorkFlowType, RFQ_MAKER_REFRESH_INTERVAL_MS } from '../config';\nimport { RfqMaker } from '../entities';\nimport { logger } from '../logger';\n\nimport { ConfigManager } from './config_manager';\nimport { toPairString } from '../core/pair_utils';\nimport { RfqMakerDbUtils } from './rfq_maker_db_utils';\n\n/**\n * A mapping from RFQ-T/M quote provider URLs to the trading pairs they support.\n * The value type represents an array of supported asset pairs, with each array element encoded as a 2-element array of token addresses.\n */\nexport interface RfqMakerAssetOfferings {\n    [endpoint: string]: Array<[string, string]>;\n}\n\nconst RFQ_MAKER_REFRESH_FAILED = new Counter({\n    name: 'rfq_maker_refresh_failed',\n    help: 'A maker refreshing job failed.',\n    labelNames: ['chainId'],\n});\nconst RFQ_MAKER_REFRESH_SUCCEEDED = new Counter({\n    name: 'rfq_maker_refresh_succeeded',\n    help: 'A maker refreshing job succeeded.',\n    labelNames: ['chainId'],\n});\nconst RFQ_MAKER_REFRESH_LATENCY = new Summary({\n    name: 'rfq_maker_refresh_latency',\n    help: 'Latency for the maker maker refreshing job.',\n    labelNames: ['chainId'],\n});\n\n/**\n * Filters an array of makers (fetched from the database) to remove\n * those (1) not in the set `ids`, and (2) who have no URI set for the\n * given `workflow`\n */\nfunction filterMakers(makers: RfqMaker[], workflow: RfqWorkFlowType, ids: MakerIdSet): RfqMaker[] {\n    return makers.filter(\n        (maker: RfqMaker) =>\n            ids.has(maker.makerId) &&\n            ((workflow === 'rfqm' && maker.rfqmUri !== null) || (workflow === 'rfqt' && maker.rfqtUri !== null)),\n    );\n}\n\n/**\n * Transforms an array of makers into their asset offerings for a given workflow\n */\nfunction makersToAssetOfferings(makers: RfqMaker[], workflow: RfqWorkFlowType): RfqMakerAssetOfferings {\n    return makers.reduce((result: RfqMakerAssetOfferings, m) => {\n        const uri: string | null = workflow === 'rfqm' ? m.rfqmUri : m.rfqtUri;\n\n        if (!uri) {\n            throw new Error();\n        }\n        result[uri] = m.pairs;\n        return result;\n    }, {});\n}\n\n/**\n * Filters the given `makers` to only those trading on the given `pair`\n */\nfunction makersForPair(makers: RfqMaker[], pair: string): RfqMaker[] {\n    return makers.filter((m: RfqMaker) => {\n        return m.pairs.map((p) => toPairString(...p)).includes(pair);\n    });\n}\n\n/**\n * Unifies the maker configuration collected from environment variables\n * and the `rfq_maker_pairs` database. Once initialized, refreshes itself\n * per the `RFQ_MAKER_REFRESH_INTERVAL_MS` configuration variable.\n *\n * Usage:\n * // Instantiate instance\n * const rfqMakerManager = new RfqMakerManager(configManager, dbUtils, chainId);\n * // Initialize\n * await rfqMakerManager.initializeAsync();\n */\nexport class RfqMakerManager extends EventEmitter {\n    public static REFRESHED_EVENT = 'refreshed';\n\n    private _rfqmMakers: RfqMaker[];\n    private _rfqtV1Makers: RfqMaker[];\n    private _rfqtV2Makers: RfqMaker[];\n\n    private _rfqMakerListUpdateHash: string | null;\n\n    constructor(\n        private readonly _configManager: ConfigManager,\n        private readonly _dbUtils: RfqMakerDbUtils,\n        private readonly _chainId: number,\n    ) {\n        super();\n\n        this._rfqmMakers = [];\n        this._rfqtV1Makers = [];\n        this._rfqtV2Makers = [];\n\n        this._rfqMakerListUpdateHash = null;\n    }\n\n    /**\n     * Initialize RfqMaker entities and set up periodical refreshing\n     */\n    public async initializeAsync(): Promise<void> {\n        await this._refreshAsync();\n\n        setInterval(async () => {\n            await this._refreshAsync();\n        }, RFQ_MAKER_REFRESH_INTERVAL_MS);\n    }\n\n    /**\n     * Get the RfqMakerAssetOfferings for rfqt orders with rfq order type\n     */\n    public getRfqtV1MakerOfferings(): RfqMakerAssetOfferings {\n        return makersToAssetOfferings(this._rfqtV1Makers, 'rfqt');\n    }\n\n    /**\n     * Get the Rfqt MakerAssetOfferings for Otc Order\n     */\n    public getRfqtV2MakerOfferings(): RfqMakerAssetOfferings {\n        return makersToAssetOfferings(this._rfqtV2Makers, 'rfqt');\n    }\n\n    /**\n     * Returns the `RfqMaker` entities trading the given token pair\n     * on RFQt V2\n     */\n    public getRfqtV2MakersForPair(tokenAAddress: string, tokenBAddress: string): RfqMaker[] {\n        return makersForPair(this._rfqtV2Makers, toPairString(tokenAAddress, tokenBAddress)) || [];\n    }\n\n    /**\n     * Get the RfqMakerAssetOfferings for RFQm orders.\n     * As of Q1 2022, the RFQ order type has been deprecated\n     * and only OTC orders are used on RFQm.\n     */\n    public getRfqmV2MakerOfferings(): RfqMakerAssetOfferings {\n        return makersToAssetOfferings(this._rfqmMakers, 'rfqm');\n    }\n\n    /**\n     * Get a list of RFQm Maker Uris that support this pair on OtcOrder\n     */\n    public getRfqmV2MakerUrisForPair(\n        makerToken: string,\n        takerToken: string,\n        whitelistMakerIds: string[] | null = null,\n        blacklistMakerIds: string[] | null = null,\n    ): string[] {\n        let makers = makersForPair(this._rfqmMakers, toPairString(makerToken, takerToken)) || [];\n\n        if (whitelistMakerIds !== null) {\n            makers = makers.filter((maker) => whitelistMakerIds.includes(maker.makerId));\n        }\n        if (blacklistMakerIds !== null) {\n            makers = makers.filter((maker) => !blacklistMakerIds.includes(maker.makerId));\n        }\n\n        return makers.map((m) => m.rfqmUri).filter((uri: string | null): uri is string => uri !== null);\n    }\n\n    /**\n     * Find maker ID from its RFQm URI\n     */\n    public findMakerIdWithRfqmUri(makerRfqmUri: string): string | null {\n        const maker = this._rfqmMakers.find((m) => m.rfqmUri === makerRfqmUri);\n        return maker?.makerId || null;\n    }\n\n    /**\n     * Refresh RfqMaker entities by querying database.\n     * Emit an 'refreshed' event for subscribers to refresh if the operation is successful.\n     */\n    private async _refreshAsync(): Promise<void> {\n        const chainId = this._chainId;\n        const refreshTime = new Date();\n        const timerStopFunction = RFQ_MAKER_REFRESH_LATENCY.labels(chainId.toString()).startTimer();\n\n        try {\n            const rfqMakerListUpdateHash = await this._dbUtils.getRfqMakersUpdateTimeHashAsync(chainId);\n            if (rfqMakerListUpdateHash === this._rfqMakerListUpdateHash) {\n                return;\n            }\n            this._rfqMakerListUpdateHash = rfqMakerListUpdateHash;\n\n            const rfqMakerList = await this._dbUtils.getRfqMakersAsync(chainId);\n\n            this._rfqtV1Makers = filterMakers(rfqMakerList, 'rfqt', this._configManager.getRfqtMakerIdSetForRfqOrder());\n            this._rfqtV2Makers = filterMakers(rfqMakerList, 'rfqt', this._configManager.getRfqtMakerIdSetForOtcOrder());\n            this._rfqmMakers = filterMakers(rfqMakerList, 'rfqm', this._configManager.getRfqmMakerIdSetForOtcOrder());\n\n            this.emit(RfqMakerManager.REFRESHED_EVENT);\n\n            logger.info({ chainId, refreshTime }, `Successfully refreshed makers.`);\n            RFQ_MAKER_REFRESH_SUCCEEDED.labels(chainId.toString()).inc();\n        } catch (error) {\n            logger.error({ chainId, refreshTime, errorMessage: error.message }, `Failed to refresh makers.`);\n            RFQ_MAKER_REFRESH_FAILED.labels(chainId.toString()).inc();\n        } finally {\n            timerStopFunction();\n        }\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts",{"fileContent":"import { getTokenMetadataIfExists } from '@0x/token-metadata';\nimport { logger } from '../logger';\nimport { RfqBlockchainUtils } from './rfq_blockchain_utils';\n\nexport class TokenMetadataManager {\n    private readonly _tokenDecimalsCache: Map<string, number> = new Map();\n\n    public constructor(private readonly _chainId: number, private readonly _blockchainUtils: RfqBlockchainUtils) {}\n\n    /**\n     * Utility function to get the decimals for an ERC20 token by its address.\n     * First checks 0x/token-metadata for the information, and if not present,\n     * queries the data from the blockchain.\n     *\n     * Uses an in-memory cache to store previously-fetched values.\n     *\n     * Throws if there is a problem fetching the data from on chain.\n     */\n    public async getTokenDecimalsAsync(tokenAddress: string): Promise<number> {\n        const localMetadata = getTokenMetadataIfExists(tokenAddress, this._chainId);\n        if (localMetadata) {\n            return localMetadata.decimals;\n        }\n        const cachedDecimals = this._tokenDecimalsCache.get(tokenAddress);\n        if (cachedDecimals) {\n            return cachedDecimals;\n        }\n        const onchainDecimals = await this._blockchainUtils.getTokenDecimalsAsync(tokenAddress);\n        logger.info(\n            { tokenAddress, decimals: onchainDecimals, cacheSize: this._tokenDecimalsCache.size },\n            'Token decimals fetched from blockchain',\n        );\n        this._tokenDecimalsCache.set(tokenAddress, onchainDecimals);\n        return onchainDecimals;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { AxiosInstance } from 'axios';\nimport { Summary } from 'prom-client';\n\nimport { ChainConfiguration } from '../config';\nimport { logger } from '../logger';\nimport { QuoteContext } from '../services/types';\n\n/**\n * With this summary metric, some of the things you can do are:\n * - Get the rate of failed requests\n * - Get the rate of success requests\n * - Get the p99 of request duration of success/failed requests (with the sliding window of 1 minute)\n */\nconst RFQ_AMM_QUOTE_FETCH_REQUEST_DURATION_SECONDS = new Summary({\n    name: 'rfq_amm_quote_fetch_request_duration_seconds',\n    help: 'Histogram of request duration of AMM Quote fetch request',\n    percentiles: [0.5, 0.9, 0.95, 0.99, 0.999], // tslint:disable-line: custom-no-magic-numbers\n    labelNames: ['chainId', 'success', 'errorType'],\n    // Set sliding window to 1 minutes\n    maxAgeSeconds: 60,\n    // The more number of age buckets, the smoother the time window is moved\n    // but it also consumes more memory & CPU for maintaining the bucket.\n    ageBuckets: 5,\n});\n\nenum FailedFetchErrorType {\n    InvalidBody = 'invalid_body',\n    Other = 'other',\n}\n\nexport interface AmmQuote {\n    makerAmount: BigNumber;\n    takerAmount: BigNumber;\n    expectedSlippage: BigNumber;\n    estimatedGasFeeWei: BigNumber;\n    decodedUniqueId?: string;\n}\n\ninterface ZeroExApiGetQuoteResponse {\n    buyAmount: string;\n    sellAmount: string;\n    estimatedGas: string;\n    gasPrice: string;\n    expectedSlippage: string;\n    decodedUniqueId?: string;\n}\n\nexport class ZeroExApiClient {\n    public constructor(\n        private readonly _axiosInstance: AxiosInstance,\n        private readonly _zeroExApiKey: string,\n        private readonly _chainConfiguration: Pick<ChainConfiguration, 'chainId' | 'zeroExClientBaseUrl'>,\n    ) {}\n\n    /**\n     * Fetch AMM Quote from 0x API. The quoteContext provided in the params will be transformed to match with 0x API definition:\n     * - takerAmount -> sellAmount\n     * - makerAmount -> buyAmount\n     *\n     * The response from 0x API will also be transformed (in reverse) to match with AmmQuote interface.\n     *\n     * @returns a promise resolved to AMM Quote if the fetch was successful. Otherwise, returns a promise resolved to null.\n     */\n    public async fetchAmmQuoteAsync(\n        quoteContext: Pick<\n            QuoteContext,\n            'takerAmount' | 'makerAmount' | 'takerToken' | 'makerToken' | 'takerAddress' | 'affiliateAddress'\n        >,\n    ): Promise<AmmQuote | null> {\n        const stopTimer = RFQ_AMM_QUOTE_FETCH_REQUEST_DURATION_SECONDS.startTimer({\n            chainId: this._chainConfiguration.chainId.toString(),\n        });\n\n        // Transform QuoteContext to 0xAPI Get Quote Params\n        const zeroExApiGetQuoteParams: {\n            buyAmount?: string;\n            buyToken: string;\n            sellAmount?: string;\n            sellToken: string;\n            takerAddress?: string;\n            affiliateAddress?: string;\n            excludedSources: string;\n        } = {\n            buyAmount: quoteContext.makerAmount?.toString(),\n            buyToken: quoteContext.makerToken,\n            sellAmount: quoteContext.takerAmount?.toString(),\n            sellToken: quoteContext.takerToken,\n            takerAddress: quoteContext.takerAddress,\n            affiliateAddress: quoteContext.affiliateAddress,\n            excludedSources: '0x', // Exclude 0x source to get quote from AMM only\n        };\n\n        try {\n            const { data }: { data: ZeroExApiGetQuoteResponse } = await this._axiosInstance.get('/swap/v1/quote', {\n                baseURL: this._chainConfiguration.zeroExClientBaseUrl,\n                params: zeroExApiGetQuoteParams,\n                headers: {\n                    '0x-api-key': this._zeroExApiKey,\n                },\n            });\n\n            // Parsing and validating 0xAPI response\n            const makerAmount = new BigNumber(data.buyAmount);\n            const takerAmount = new BigNumber(data.sellAmount);\n            const estimatedGas = new BigNumber(data.estimatedGas);\n            const gasPrice = new BigNumber(data.gasPrice);\n            const expectedSlippage = new BigNumber(data.expectedSlippage !== null ? data.expectedSlippage : 0);\n            const { decodedUniqueId } = data;\n            if (\n                makerAmount.isNaN() ||\n                takerAmount.isNaN() ||\n                estimatedGas.isNaN() ||\n                gasPrice.isNaN() ||\n                expectedSlippage.isNaN()\n            ) {\n                throw new Error(`Unexpected body returned from 0xAPI: ${JSON.stringify(data)}`);\n            }\n            if (!decodedUniqueId) {\n                logger.warn(`Missing decodedUniqueId from 0xAPI`);\n            }\n\n            // Mapping 0x API's response to AmmQuote\n            const ammQuote: AmmQuote = {\n                makerAmount,\n                takerAmount,\n                estimatedGasFeeWei: estimatedGas.times(gasPrice),\n                expectedSlippage,\n                decodedUniqueId,\n            };\n\n            stopTimer({ success: 'true' });\n            return ammQuote;\n        } catch (error) {\n            if (error.message.includes('Unexpected body returned from 0xAPI')) {\n                stopTimer({ success: 'false', errorType: FailedFetchErrorType.InvalidBody });\n            } else {\n                stopTimer({ success: 'false', errorType: FailedFetchErrorType.Other });\n            }\n            logger.error(\n                {\n                    chainId: this._chainConfiguration.chainId,\n                    zeroExApiGetQuoteParams,\n                    message: error.message,\n                    body: error.response?.data || null,\n                },\n                'Failed to fetch AMM Quote from 0x API',\n            );\n            return null;\n        }\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/background-jobs/maker_balance_cache_update.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\nimport { Job, Queue } from 'bullmq';\nimport { Counter } from 'prom-client';\n\nimport { CHAIN_CONFIGURATIONS } from '../config';\nimport { logger } from '../logger';\nimport { buildRfqMakerBalanceCacheServiceAsync } from '../utils/rfqm_service_builder';\n\nimport { BackgroundJobBlueprint } from './blueprint';\n\nconst QUEUE_NAME = 'maker-balance-cache-update';\n// keep successful job history for 1 day\nconst REMOVE_ON_COMPLETE_OPS = {\n    count: 24 * 60 * 6,\n};\n// keep failed job history for 3 days\nconst REMOVE_ON_FAILURE_OPS = {\n    count: 3 * 24 * 60 * 6,\n};\nconst MAKER_BALANCE_CACHE_UPDATE_SCHEDULE = '*/10 * * * * *'; // job will be scheduled at every 10 seconds\nconst DESCRIPTION = 'Periodically updates observed entries in maker balance cache through balance checks.';\n\nexport interface BackgroundJobMBCUpdateData {\n    chainId: number;\n    timestamp: number;\n}\n\nexport interface BackgroundJobMBCUpdateResult {\n    chainId: number;\n    jobName: string;\n    timestamp: number;\n}\n\nconst backgroundJobMBCUpdate: BackgroundJobBlueprint<BackgroundJobMBCUpdateData, BackgroundJobMBCUpdateResult> = {\n    queueName: QUEUE_NAME,\n    schedule: MAKER_BALANCE_CACHE_UPDATE_SCHEDULE,\n    description: DESCRIPTION,\n    createAsync,\n    processAsync,\n};\n// tslint:disable-next-line: no-default-export\nexport default backgroundJobMBCUpdate;\n\nconst MAKER_BALANCE_CACHE_UPDATE_PROCESS_COUNT = new Counter({\n    name: 'rfq_background_job_mbc_update_process_total',\n    help: 'Number of times the processor method of the maker balance cache update background job is triggered',\n});\n\n/**\n * Creates a background job by queues a message that performs an update on the maker balance cache.\n *\n * @param queue Queue to push the message.\n * @param data Necessary data for processor to execute the background job.\n * @returns Promise of the background job.\n */\nasync function createAsync(\n    queue: Queue,\n    data: Partial<BackgroundJobMBCUpdateData>,\n): Promise<Job<BackgroundJobMBCUpdateData, BackgroundJobMBCUpdateResult>> {\n    logger.info({ queue: QUEUE_NAME, data }, 'Creating the maker balance cache background job on queue');\n    return queue.add(`${QUEUE_NAME}.${data.timestamp}`, data, {\n        removeOnComplete: REMOVE_ON_COMPLETE_OPS,\n        removeOnFail: REMOVE_ON_FAILURE_OPS,\n    });\n}\n\n/**\n * Processor method for the maker balance cache update job. Runs a cache update,\n * performing balance checks on observed maker balances.\n *\n * @param job Maker balance cache update background job.\n * @returns Result of the update background job.\n */\nasync function processAsync(\n    job: Job<BackgroundJobMBCUpdateData, BackgroundJobMBCUpdateResult>,\n): Promise<BackgroundJobMBCUpdateResult> {\n    await job.updateProgress(0);\n    logger.info(\n        { jobName: job.name, queue: job.queueName, data: job.data, timestamp: Date.now() },\n        'Processing the maker balance cache update background job on queue',\n    );\n\n    const chainId = job.data.chainId;\n\n    // Build dependencies\n    const chain = CHAIN_CONFIGURATIONS.find((c) => c.chainId === chainId);\n    if (!chain) {\n        throw new Error(`Tried to start background job process for chain ${chainId}\n        but no chain configuration was present`);\n    }\n    const rfqMakerBalanceCacheService = await buildRfqMakerBalanceCacheServiceAsync(chain);\n\n    if (!rfqMakerBalanceCacheService) {\n        logger.error(\n            { jobName: job.name, queue: job.queueName, data: job.data, timestamp: Date.now() },\n            'Failed to initialize dependencies for maker-balance-cache-update',\n        );\n        throw new Error('Failed to initialize dependencies for maker-balance-cache-update');\n    }\n    await job.updateProgress(50);\n\n    // Perform update on maker balance cache\n    try {\n        await rfqMakerBalanceCacheService.updateERC20OwnerBalancesAsync(chainId);\n        MAKER_BALANCE_CACHE_UPDATE_PROCESS_COUNT.inc();\n    } catch (error) {\n        logger.error(\n            { jobName: job.name, queue: job.queueName, data: job.data, timestamp: Date.now() },\n            'Failed to update maker balance cache while running scheduled background job',\n        );\n        throw new Error('Failed to update maker balance cache while running scheduled background job');\n    } finally {\n        await rfqMakerBalanceCacheService.closeAsync();\n    }\n\n    await job.updateProgress(100);\n    return {\n        chainId,\n        jobName: job.name,\n        timestamp: Date.now(),\n    };\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_service_builder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/background-jobs/blueprint.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/WorkerService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/provider_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/services/WorkerService.test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\n// tslint:disable:no-empty\n// tslint:disable:max-file-line-count\n\nimport { pino } from '@0x/api-utils';\nimport { OtcOrder, SignatureType } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { expect } from 'chai';\nimport { BigNumber as EthersBigNumber, providers } from 'ethers';\nimport * as _ from 'lodash';\nimport { Producer } from 'sqs-producer';\nimport { anything, capture, deepEqual, instance, mock, spy, verify, when } from 'ts-mockito';\n\nimport { ETH_DECIMALS, GWEI_DECIMALS, ONE_SECOND_MS } from '../../src/core/constants';\nimport {\n    MetaTransactionJobEntity,\n    RfqmJobEntity,\n    RfqmTransactionSubmissionEntity,\n    RfqmV2JobEntity,\n    RfqmV2QuoteEntity,\n    RfqmV2TransactionSubmissionEntity,\n} from '../../src/entities';\nimport { MetaTransactionJobConstructorOpts } from '../../src/entities/MetaTransactionJobEntity';\nimport {\n    MetaTransactionSubmissionEntity,\n    MetaTransactionSubmissionEntityConstructorOpts,\n} from '../../src/entities/MetaTransactionSubmissionEntity';\nimport {\n    RfqmJobStatus,\n    RfqmOrderTypes,\n    RfqmTransactionSubmissionStatus,\n    RfqmTransactionSubmissionType,\n    SubmissionContextStatus,\n} from '../../src/entities/types';\nimport { logger } from '../../src/logger';\nimport { RfqMakerBalanceCacheService } from '../../src/services/rfq_maker_balance_cache_service';\nimport { WorkerService } from '../../src/services/WorkerService';\nimport { CacheClient } from '../../src/utils/cache_client';\nimport { GasStationAttendant } from '../../src/utils/GasStationAttendant';\nimport { GasStationAttendantEthereum } from '../../src/utils/GasStationAttendantEthereum';\nimport { QuoteServerClient } from '../../src/utils/quote_server_client';\nimport { RfqmDbUtils } from '../../src/utils/rfqm_db_utils';\nimport { RfqBlockchainUtils } from '../../src/utils/rfq_blockchain_utils';\nimport { RfqMakerManager } from '../../src/utils/rfq_maker_manager';\nimport { padSignature } from '../../src/utils/signature_utils';\nimport { SubmissionContext } from '../../src/utils/SubmissionContext';\nimport {\n    MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n    MOCK_EXECUTE_META_TRANSACTION_CALLDATA,\n    MOCK_META_TRANSACTION,\n} from '../constants';\n\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n// eslint-disable-next-line @typescript-eslint/no-loss-of-precision\nconst MOCK_WORKER_REGISTRY_ADDRESS = '0x1023331a469c6391730ff1E2749422CE8873EC38';\nconst MOCK_GAS_PRICE = new BigNumber(100);\nconst TEST_RFQM_TRANSACTION_WATCHER_SLEEP_TIME_MS = 50;\nconst WORKER_FULL_BALANCE_WEI = new BigNumber(1).shiftedBy(ETH_DECIMALS);\nlet loggerSpy: pino.Logger;\n\nconst buildWorkerServiceForUnitTest = (\n    overrides: {\n        cacheClient?: CacheClient;\n        dbUtils?: RfqmDbUtils;\n        rfqMakerBalanceCacheService?: RfqMakerBalanceCacheService;\n        rfqMakerManager?: RfqMakerManager;\n        gasStationAttendant?: GasStationAttendant;\n        quoteServerClient?: QuoteServerClient;\n        rfqBlockchainUtils?: RfqBlockchainUtils;\n        initialMaxPriorityFeePerGasGwei?: number;\n        maxFeePerGasGwei?: number;\n        enableAccessList?: boolean;\n    } = {},\n): WorkerService => {\n    const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n    when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(MOCK_GAS_PRICE);\n    const gasStationAttendantInstance = instance(gasStationAttendantMock);\n\n    const rfqBlockchainUtilsMock = mock(RfqBlockchainUtils);\n    when(rfqBlockchainUtilsMock.getAccountBalanceAsync(MOCK_WORKER_REGISTRY_ADDRESS)).thenResolve(\n        WORKER_FULL_BALANCE_WEI,\n    );\n    const sqsMock = mock(Producer);\n    when(sqsMock.queueSize()).thenResolve(0);\n    const quoteServerClientMock = mock(QuoteServerClient);\n\n    const cacheClientMock = mock(CacheClient);\n    const defaultDbUtilsMock = mock(RfqmDbUtils);\n    const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n    const rfqMakerManagerMock = mock(RfqMakerManager);\n\n    return new WorkerService(\n        1,\n        overrides.gasStationAttendant || gasStationAttendantInstance,\n        MOCK_WORKER_REGISTRY_ADDRESS,\n        overrides.rfqBlockchainUtils || instance(rfqBlockchainUtilsMock),\n        overrides.dbUtils || instance(defaultDbUtilsMock),\n        overrides.quoteServerClient || quoteServerClientMock,\n        TEST_RFQM_TRANSACTION_WATCHER_SLEEP_TIME_MS,\n        overrides.cacheClient || cacheClientMock,\n        overrides.rfqMakerBalanceCacheService || instance(rfqMakerBalanceCacheServiceMock),\n        overrides.rfqMakerManager || rfqMakerManagerMock,\n        overrides.initialMaxPriorityFeePerGasGwei || 2,\n        overrides.maxFeePerGasGwei || 128,\n        overrides.enableAccessList,\n    );\n};\n\nconst createMeaTrsanctionJobEntity = (\n    opts: MetaTransactionJobConstructorOpts,\n    id: string,\n): MetaTransactionJobEntity => {\n    const job = new MetaTransactionJobEntity(opts);\n    job.id = id;\n    return job;\n};\n\nconst createMetaTransactionSubmissionEntity = (\n    opts: MetaTransactionSubmissionEntityConstructorOpts,\n    id: string,\n): MetaTransactionSubmissionEntity => {\n    const submission = new MetaTransactionSubmissionEntity(opts);\n    submission.id = id;\n    return submission;\n};\n\nconst fakeClockMs = 1637722898000;\nconst fakeOneMinuteAgoS = fakeClockMs / ONE_SECOND_MS - 60;\nconst fakeFiveMinutesLater = fakeClockMs / ONE_SECOND_MS + 300;\n\nconst maker = '0xbb004090d26845b672f17c6da4b7d162df3bfc5e';\nconst orderHash = '0x112160fb0933ecde720f63b50b303ce64e52ded702bef78b9c20361f3652a462';\n\n// This sig actually belongs to the maker above\nconst validEIP712Sig = {\n    signatureType: SignatureType.EIP712,\n    v: 28,\n    r: '0xdc158f7b53b940863bc7b001552a90282e51033f29b73d44a2701bd16faa19d2',\n    s: '0x55f6c5470e41b39a5ddeb63c22f8ba1d34748f93265715b9dc4a0f10138985a6',\n};\n\n// This is a real signature that had a missing byte\nconst missingByteSig = {\n    r: '0x568b31076e1c65954adb1bccc723718b3460f1b699ce1252f8a83bda0d521005',\n    s: '0x0307cc7f4161df812f7e5a651b23dbd33981c0410df0dd820a52f61be7a5ab',\n    v: 28,\n    signatureType: SignatureType.EthSign,\n};\n\njest.setTimeout(ONE_SECOND_MS * 120);\n\ndescribe('WorkerService', () => {\n    beforeEach(() => {\n        loggerSpy = spy(logger);\n    });\n\n    describe('workerBeforeLogicAsync', () => {\n        it('calls `processJobAsync` with the correct arguments', async () => {\n            const workerIndex = 0;\n            const workerAddress = MOCK_WORKER_REGISTRY_ADDRESS;\n            const jobId = 'jobId';\n            const metaTransactionJob = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeFiveMinutesLater),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: '0xinputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                },\n                jobId,\n            );\n            const rfqmV2Job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker,\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash,\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress,\n            });\n\n            const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n            when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n            );\n\n            const blockchainUtilsMock = mock(RfqBlockchainUtils);\n            when(blockchainUtilsMock.getAccountBalanceAsync(workerAddress)).thenResolve(WORKER_FULL_BALANCE_WEI);\n\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.findV2UnresolvedJobsAsync(workerAddress, anything())).thenResolve([rfqmV2Job]);\n            when(dbUtilsMock.findUnresolvedMetaTransactionJobsAsync(workerAddress, anything())).thenResolve([\n                metaTransactionJob,\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(dbUtilsMock),\n                rfqBlockchainUtils: instance(blockchainUtilsMock),\n                gasStationAttendant: instance(gasStationAttendantMock),\n            });\n            const spiedRfqmService = spy(rfqmService);\n            when(spiedRfqmService.processJobAsync(anything(), anything(), anything())).thenResolve();\n\n            await rfqmService.workerBeforeLogicAsync(workerIndex, workerAddress);\n            verify(spiedRfqmService.processJobAsync(orderHash, workerAddress, 'rfqm_v2_job')).once();\n            verify(spiedRfqmService.processJobAsync(jobId, workerAddress, 'meta_transaction_job')).once();\n        });\n    });\n\n    describe('processJobAsync', () => {\n        it('fails if no rfqm v2 job is found', async () => {\n            // Return `undefined` for v1 and v2 job for orderhash\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.findV2JobByOrderHashAsync('0x01234567')).thenResolve(null);\n\n            const rfqmService = buildWorkerServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n            await rfqmService.processJobAsync('0x01234567', '0xworkeraddress');\n            expect(capture(loggerSpy.error).last()[0]).to.include({\n                errorMessage: 'No job found for identifier',\n            });\n        });\n\n        it('fails if a worker ends up with a job assigned to a different worker for a rfqm v2 job', async () => {\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.findV2JobByOrderHashAsync('0x01234567')).thenResolve(\n                new RfqmV2JobEntity({\n                    affiliateAddress: '',\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeOneMinuteAgoS),\n                    fee: {\n                        amount: '0',\n                        token: '',\n                        type: 'fixed',\n                    },\n                    integratorId: '',\n                    lastLookResult: null,\n                    makerUri: 'http://foo.bar',\n                    order: {\n                        order: {\n                            chainId: '1',\n                            expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                                new BigNumber(fakeOneMinuteAgoS.toString()),\n                                new BigNumber(1),\n                                new BigNumber(1),\n                            ).toString(),\n                            maker: '',\n                            makerAmount: '',\n                            makerToken: '',\n                            taker: '',\n                            takerAmount: '',\n                            takerToken: '',\n                            txOrigin: '',\n                            verifyingContract: '',\n                        },\n                        type: RfqmOrderTypes.Otc,\n                    },\n                    orderHash: '0x01234567',\n                    status: RfqmJobStatus.PendingEnqueued,\n                    updatedAt: new Date(),\n                    workerAddress: '0xwrongworkeraddress',\n                }),\n            );\n\n            const rfqmService = buildWorkerServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n            await rfqmService.processJobAsync('0x01234567', '0xworkeraddress');\n            expect(capture(loggerSpy.error).last()[0]).to.include({\n                errorMessage: 'Worker was sent a job claimed by a different worker',\n            });\n        });\n\n        it('fails if no meta-transaction job is found', async () => {\n            const dbUtilsMock = mock(RfqmDbUtils);\n            const jobId = 'jobId';\n            when(dbUtilsMock.findMetaTransactionJobByIdAsync(jobId)).thenResolve(null);\n\n            const rfqmService = buildWorkerServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n            await rfqmService.processJobAsync(jobId, '0xworkeraddress', 'meta_transaction_job');\n            expect(capture(loggerSpy.error).last()[0]).to.include({\n                errorMessage: 'No job found for identifier',\n            });\n        });\n\n        it('fails if a worker ends up with a job assigned to a different worker for a meta-transaction job', async () => {\n            const jobId = 'jobId';\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeFiveMinutesLater),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: 'inputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xwrongworkeraddress',\n                    approval: MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                    approvalSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                },\n                jobId,\n            );\n\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.findMetaTransactionJobByIdAsync(jobId)).thenResolve(job);\n\n            const rfqmService = buildWorkerServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n            await rfqmService.processJobAsync(jobId, '0xworkeraddress', 'meta_transaction_job');\n            expect(capture(loggerSpy.error).last()[0]).to.include({\n                errorMessage: 'Worker was sent a job claimed by a different worker',\n            });\n        });\n    });\n\n    describe('processApprovalAndTradeAsync', () => {\n        it('throws if non-approval job is supplied to the method for a rfqm v2 job', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n\n            const rfqmService = buildWorkerServiceForUnitTest();\n\n            try {\n                await rfqmService.processApprovalAndTradeAsync(job, '0xworkeraddress');\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain(\n                    'Non-approval job should not be processed by `processApprovalAndTradeAsync`',\n                );\n            }\n        });\n\n        it('should not proceed to trade transaction if the status of approval transaction is not `SucceededConfirmed` for a rfqm v2 job', async () => {\n            const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(nowS + 10),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(nowS + 10),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker,\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash,\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n                approval: MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                approvalSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n            });\n            const mockPresubmitTransaction = new RfqmV2TransactionSubmissionEntity({\n                createdAt: new Date(1233),\n                from: '0xworkeraddress',\n                maxFeePerGas: new BigNumber(100000),\n                maxPriorityFeePerGas: new BigNumber(100),\n                nonce: 0,\n                orderHash: '0x01234567',\n                status: RfqmTransactionSubmissionStatus.Submitted,\n                to: '0xexchangeproxyaddress',\n                transactionHash: '0xpresubmittransactionhash',\n                type: RfqmTransactionSubmissionType.Approval,\n            });\n            const mockTransactionReceipt: providers.TransactionReceipt = {\n                blockHash: '0xblockhash',\n                blockNumber: 1,\n                byzantium: true,\n                confirmations: 3,\n                contractAddress: '0xexchangeproxyaddress',\n                cumulativeGasUsed: EthersBigNumber.from(1000),\n                effectiveGasPrice: EthersBigNumber.from(1000),\n                from: '0xworkeraddress',\n                gasUsed: EthersBigNumber.from(10000),\n                logs: [],\n                logsBloom: '',\n                status: 0,\n                to: '0xexchangeproxyaddress',\n                transactionHash: '0xpresubmittransactionhash',\n                transactionIndex: 0,\n                type: 2,\n            };\n            const mockMinedBlock: providers.Block = {\n                _difficulty: EthersBigNumber.from(2),\n                difficulty: 2,\n                extraData: '',\n                gasLimit: EthersBigNumber.from(1000),\n                gasUsed: EthersBigNumber.from(1000),\n                hash: '0xblockhash',\n                miner: '0xminer',\n                nonce: '0x000',\n                number: 21,\n                parentHash: '0xparentblockhash',\n                timestamp: 12345,\n                transactions: ['0xpresubmittransactionhash'],\n            };\n            const mockNonce = 0;\n\n            const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n            when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n            );\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            // when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(anything())).thenResolve([]);\n            when(\n                mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                    anything(),\n                    RfqmTransactionSubmissionType.Approval,\n                ),\n            ).thenResolve([mockPresubmitTransaction]);\n            const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n\n            const mockQuoteServerClient = mock(QuoteServerClient);\n            when(mockQuoteServerClient.signV2Async(anything(), anything(), anything())).thenResolve(validEIP712Sig);\n\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.isValidOrderSignerAsync(anything(), anything())).thenResolve(true);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            when(mockBlockchainUtils.getTokenBalancesAsync(anything())).thenResolve([new BigNumber(1000000000)]);\n            when(mockBlockchainUtils.generateApprovalCalldataAsync(anything(), anything(), anything())).thenResolve(\n                '0xcalldata',\n            );\n            when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n            when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xpresubmittransactionhash']))).thenResolve([\n                mockTransactionReceipt,\n            ]);\n            when(mockBlockchainUtils.getBlockAsync('0xblockhash')).thenResolve(mockMinedBlock);\n            when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n            when(mockBlockchainUtils.getDecodedRfqOrderFillEventLogFromLogs(anything())).thenReturn({\n                event: '',\n                logIndex: null,\n                transactionIndex: null,\n                transactionHash: '',\n                blockHash: '',\n                address: '',\n                data: '',\n                blockNumber: 0,\n                topics: [],\n                args: {\n                    maker: '',\n                    makerToken: '',\n                    makerTokenFilledAmount: new BigNumber(1234),\n                    orderHash: '',\n                    pool: '',\n                    taker: '',\n                    takerToken: '',\n                    takerTokenFilledAmount: new BigNumber(5),\n                },\n            });\n\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                quoteServerClient: instance(mockQuoteServerClient),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            await rfqmService.processApprovalAndTradeAsync(job, '0xworkeraddress');\n            expect(updateRfqmJobCalledArgs[0].status).to.equal(RfqmJobStatus.PendingProcessing);\n            expect(updateRfqmJobCalledArgs[1].status).to.equal(RfqmJobStatus.PendingLastLookAccepted);\n            expect(updateRfqmJobCalledArgs[updateRfqmJobCalledArgs.length - 1].status).to.equal(\n                RfqmJobStatus.FailedRevertedConfirmed,\n            );\n            expect(job.status).to.equal(RfqmJobStatus.FailedRevertedConfirmed);\n        });\n\n        it('should proceed to trade transaction if the status of approval transaction is `SucceededConfirmed` for a rfqm v2 job', async () => {\n            const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(nowS + 10),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(nowS + 10),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker,\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash,\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n                approval: MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                approvalSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n            });\n            const mockPresubmitApprovalTransaction = new RfqmV2TransactionSubmissionEntity({\n                createdAt: new Date(1233),\n                from: '0xworkeraddress',\n                maxFeePerGas: new BigNumber(100000),\n                maxPriorityFeePerGas: new BigNumber(100),\n                nonce: 0,\n                orderHash: '0x01234567',\n                status: RfqmTransactionSubmissionStatus.Submitted,\n                to: '0xexchangeproxyaddress',\n                transactionHash: '0xpresubmittransactionhash',\n                type: RfqmTransactionSubmissionType.Approval,\n            });\n            const mockPresubmitTradeTransaction = new RfqmV2TransactionSubmissionEntity({\n                createdAt: new Date(1233),\n                from: '0xworkeraddress',\n                maxFeePerGas: new BigNumber(100000),\n                maxPriorityFeePerGas: new BigNumber(100),\n                nonce: 0,\n                orderHash: '0x01234567',\n                status: RfqmTransactionSubmissionStatus.Submitted,\n                to: '0xexchangeproxyaddress',\n                transactionHash: '0xpresubmittransactionhash',\n                type: RfqmTransactionSubmissionType.Trade,\n            });\n            const mockTransactionReceipt: providers.TransactionReceipt = {\n                blockHash: '0xblockhash',\n                blockNumber: 1,\n                byzantium: true,\n                confirmations: 3,\n                contractAddress: '0xexchangeproxyaddress',\n                cumulativeGasUsed: EthersBigNumber.from(1000),\n                effectiveGasPrice: EthersBigNumber.from(1000),\n                from: '0xworkeraddress',\n                gasUsed: EthersBigNumber.from(10000),\n                logs: [],\n                logsBloom: '',\n                status: 1,\n                to: '0xexchangeproxyaddress',\n                transactionHash: '0xpresubmittransactionhash',\n                transactionIndex: 0,\n                type: 2,\n            };\n            const mockMinedBlock: providers.Block = {\n                _difficulty: EthersBigNumber.from(2),\n                difficulty: 2,\n                extraData: '',\n                gasLimit: EthersBigNumber.from(1000),\n                gasUsed: EthersBigNumber.from(1000),\n                hash: '0xblockhash',\n                miner: '0xminer',\n                nonce: '0x000',\n                number: 21,\n                parentHash: '0xparentblockhash',\n                timestamp: 12345,\n                transactions: ['0xpresubmittransactionhash'],\n            };\n            const mockNonce = 0;\n\n            const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n            when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n            );\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            // when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(anything())).thenResolve([]);\n            when(\n                mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                    anything(),\n                    RfqmTransactionSubmissionType.Approval,\n                ),\n            ).thenResolve([mockPresubmitApprovalTransaction]);\n            when(\n                mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                    anything(),\n                    RfqmTransactionSubmissionType.Trade,\n                ),\n            ).thenResolve([mockPresubmitTradeTransaction]);\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(anything())).thenResolve([\n                mockPresubmitTradeTransaction,\n            ]);\n            const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n\n            const mockQuoteServerClient = mock(QuoteServerClient);\n            when(mockQuoteServerClient.signV2Async(anything(), anything(), anything())).thenResolve(validEIP712Sig);\n\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.isValidOrderSignerAsync(anything(), anything())).thenResolve(true);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            when(mockBlockchainUtils.getTokenBalancesAsync(anything())).thenResolve([new BigNumber(1000000000)]);\n            when(\n                mockBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenResolve(0);\n            when(\n                mockBlockchainUtils.generateTakerSignedOtcOrderCallData(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenReturn('0xcalldata');\n            when(mockBlockchainUtils.generateApprovalCalldataAsync(anything(), anything(), anything())).thenResolve(\n                '0xcalldata',\n            );\n            when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n            when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xpresubmittransactionhash']))).thenResolve([\n                mockTransactionReceipt,\n            ]);\n            when(mockBlockchainUtils.getBlockAsync('0xblockhash')).thenResolve(mockMinedBlock);\n            when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n            when(mockBlockchainUtils.getDecodedRfqOrderFillEventLogFromLogs(anything())).thenReturn({\n                event: '',\n                logIndex: null,\n                transactionIndex: null,\n                transactionHash: '',\n                blockHash: '',\n                address: '',\n                data: '',\n                blockNumber: 0,\n                topics: [],\n                args: {\n                    maker: '',\n                    makerToken: '',\n                    makerTokenFilledAmount: new BigNumber(1234),\n                    orderHash: '',\n                    pool: '',\n                    taker: '',\n                    takerToken: '',\n                    takerTokenFilledAmount: new BigNumber(5),\n                },\n            });\n\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                quoteServerClient: instance(mockQuoteServerClient),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            await rfqmService.processApprovalAndTradeAsync(job, '0xworkeraddress');\n            expect(updateRfqmJobCalledArgs[0].status).to.equal(RfqmJobStatus.PendingProcessing);\n            expect(updateRfqmJobCalledArgs[1].status).to.equal(RfqmJobStatus.PendingLastLookAccepted);\n            expect(updateRfqmJobCalledArgs[2].status).to.equal(RfqmJobStatus.PendingSubmitted);\n            expect(updateRfqmJobCalledArgs[updateRfqmJobCalledArgs.length - 1].status).to.equal(\n                RfqmJobStatus.SucceededConfirmed,\n            );\n            expect(job.status).to.equal(RfqmJobStatus.SucceededConfirmed);\n        });\n\n        it('throws if non-approval job is supplied to the method for a meta-transaction job', async () => {\n            const jobId = 'jobId';\n\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeFiveMinutesLater),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: '0xinputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                },\n                jobId,\n            );\n\n            const rfqmService = buildWorkerServiceForUnitTest();\n\n            try {\n                await rfqmService.processApprovalAndTradeAsync(job, '0xworkeraddress');\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain(\n                    'Non-approval job should not be processed by `processApprovalAndTradeAsync`',\n                );\n            }\n        });\n\n        it('should not proceed to trade transaction if the status of approval transaction is not `SucceededConfirmed` for a meta-transaction job', async () => {\n            const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n            const jobId = 'jobId';\n            const transactionSubmissionId = 'submissionId';\n            const inputToken = '0xinputToken';\n\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(nowS + 600),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken,\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                    approval: MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                    approvalSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                },\n                jobId,\n            );\n            const mockTransaction = createMetaTransactionSubmissionEntity(\n                {\n                    from: '0xworkeraddress',\n                    metaTransactionJobId: jobId,\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xsignedtransactionhash',\n                    type: RfqmTransactionSubmissionType.Approval,\n                    status: RfqmTransactionSubmissionStatus.Submitted,\n                },\n                transactionSubmissionId,\n            );\n            const mockTransactionReceipt: providers.TransactionReceipt = {\n                blockHash: '0xblockhash',\n                blockNumber: 1,\n                byzantium: true,\n                confirmations: 3,\n                contractAddress: '0xexchangeproxyaddress',\n                cumulativeGasUsed: EthersBigNumber.from(1000),\n                effectiveGasPrice: EthersBigNumber.from(1000),\n                from: '0xworkeraddress',\n                gasUsed: EthersBigNumber.from(10000),\n                logs: [],\n                logsBloom: '',\n                status: 0,\n                to: '0xexchangeproxyaddress',\n                transactionHash: '0xsignedtransactionhash',\n                transactionIndex: 0,\n                type: 2,\n            };\n            const mockMinedBlock: providers.Block = {\n                _difficulty: EthersBigNumber.from(2),\n                difficulty: 2,\n                extraData: '',\n                gasLimit: EthersBigNumber.from(1000),\n                gasUsed: EthersBigNumber.from(1000),\n                hash: '0xblockhash',\n                miner: '0xminer',\n                nonce: '0x000',\n                number: 21,\n                parentHash: '0xparentblockhash',\n                timestamp: 12345,\n                transactions: ['0xsignedtransactionhash'],\n            };\n            const mockNonce = 0;\n\n            const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n            when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n            );\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(\n                mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId, RfqmTransactionSubmissionType.Approval),\n            ).thenResolve([mockTransaction]);\n            const updateRfqmJobCalledArgs: MetaTransactionJobEntity[] = [];\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.isValidOrderSignerAsync(anything(), anything())).thenResolve(true);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            when(mockBlockchainUtils.getTokenBalancesAsync(anything())).thenResolve([new BigNumber(1000000000)]);\n            when(mockBlockchainUtils.generateApprovalCalldataAsync(inputToken, anything(), anything())).thenResolve(\n                '0xcalldata',\n            );\n            when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n            when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xsignedtransactionhash']))).thenResolve([\n                mockTransactionReceipt,\n            ]);\n            when(mockBlockchainUtils.getBlockAsync('0xblockhash')).thenResolve(mockMinedBlock);\n            when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n            });\n\n            await rfqmService.processApprovalAndTradeAsync(job, '0xworkeraddress');\n            expect(updateRfqmJobCalledArgs[0].status).to.equal(RfqmJobStatus.PendingProcessing);\n            expect(updateRfqmJobCalledArgs[updateRfqmJobCalledArgs.length - 1].status).to.equal(\n                RfqmJobStatus.FailedRevertedConfirmed,\n            );\n            expect(job.status).to.equal(RfqmJobStatus.FailedRevertedConfirmed);\n        });\n\n        it('should proceed to trade transaction if the status of approval transaction is `SucceededConfirmed` for a meta-transaction job', async () => {\n            const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n            const jobId = 'jobId';\n            const transactionSubmissionId1 = 'submissionId1';\n            const transactionSubmissionId2 = 'submissionId2';\n            const inputToken = '0xinputToken';\n\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(nowS + 600),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken,\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                    approval: MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                    approvalSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                },\n                jobId,\n            );\n            const mockApprovalTransaction = createMetaTransactionSubmissionEntity(\n                {\n                    from: '0xworkeraddress',\n                    metaTransactionJobId: jobId,\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xsignedtransactionhash1',\n                    type: RfqmTransactionSubmissionType.Approval,\n                    status: RfqmTransactionSubmissionStatus.Submitted,\n                },\n                transactionSubmissionId1,\n            );\n            const mockTradeTransaction = createMetaTransactionSubmissionEntity(\n                {\n                    from: '0xworkeraddress',\n                    metaTransactionJobId: jobId,\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xsignedtransactionhash2',\n                    type: RfqmTransactionSubmissionType.Trade,\n                    status: RfqmTransactionSubmissionStatus.Submitted,\n                },\n                transactionSubmissionId2,\n            );\n            const mockApprovalTransactionReceipt: providers.TransactionReceipt = {\n                blockHash: '0xblockhash',\n                blockNumber: 1,\n                byzantium: true,\n                confirmations: 3,\n                contractAddress: '0xexchangeproxyaddress',\n                cumulativeGasUsed: EthersBigNumber.from(1000),\n                effectiveGasPrice: EthersBigNumber.from(1000),\n                from: '0xworkeraddress',\n                gasUsed: EthersBigNumber.from(10000),\n                logs: [],\n                logsBloom: '',\n                status: 1,\n                to: '0xexchangeproxyaddress',\n                transactionHash: '0xsignedtransactionhash1',\n                transactionIndex: 0,\n                type: 2,\n            };\n            const mockTradeTransactionReceipt: providers.TransactionReceipt = {\n                blockHash: '0xblockhash',\n                blockNumber: 1,\n                byzantium: true,\n                confirmations: 3,\n                contractAddress: '0xexchangeproxyaddress',\n                cumulativeGasUsed: EthersBigNumber.from(1000),\n                effectiveGasPrice: EthersBigNumber.from(1000),\n                from: '0xworkeraddress',\n                gasUsed: EthersBigNumber.from(10000),\n                logs: [],\n                logsBloom: '',\n                status: 1,\n                to: '0xexchangeproxyaddress',\n                transactionHash: '0xsignedtransactionhash2',\n                transactionIndex: 0,\n                type: 2,\n            };\n            const mockMinedBlock: providers.Block = {\n                _difficulty: EthersBigNumber.from(2),\n                difficulty: 2,\n                extraData: '',\n                gasLimit: EthersBigNumber.from(1000),\n                gasUsed: EthersBigNumber.from(1000),\n                hash: '0xblockhash',\n                miner: '0xminer',\n                nonce: '0x000',\n                number: 21,\n                parentHash: '0xparentblockhash',\n                timestamp: 12345,\n                transactions: ['0xsignedtransactionhash1', '0xsignedtransactionhash2'],\n            };\n            const mockNonce = 0;\n\n            const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n            when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n            );\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(\n                mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId, RfqmTransactionSubmissionType.Approval),\n            ).thenResolve([mockApprovalTransaction]);\n            when(\n                mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId, RfqmTransactionSubmissionType.Trade),\n            ).thenResolve([mockTradeTransaction]);\n            when(mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId)).thenResolve([mockTradeTransaction]);\n            const updateRfqmJobCalledArgs: MetaTransactionJobEntity[] = [];\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.isValidOrderSignerAsync(anything(), anything())).thenResolve(true);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            when(mockBlockchainUtils.getTokenBalancesAsync(anything())).thenResolve([new BigNumber(1000000000)]);\n            when(mockBlockchainUtils.estimateGasForAsync(anything())).thenResolve(0);\n            when(mockBlockchainUtils.generateMetaTransactionCallData(anything(), anything(), anything())).thenReturn(\n                '0xcalldata',\n            );\n            when(mockBlockchainUtils.generateApprovalCalldataAsync(anything(), anything(), anything())).thenResolve(\n                '0xcalldata',\n            );\n            when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n            when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xsignedtransactionhash1']))).thenResolve([\n                mockApprovalTransactionReceipt,\n            ]);\n            when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xsignedtransactionhash2']))).thenResolve([\n                mockTradeTransactionReceipt,\n            ]);\n            when(mockBlockchainUtils.getBlockAsync('0xblockhash')).thenResolve(mockMinedBlock);\n            when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n            });\n\n            await rfqmService.processApprovalAndTradeAsync(job, '0xworkeraddress');\n            expect(updateRfqmJobCalledArgs[0].status).to.equal(RfqmJobStatus.PendingProcessing);\n            expect(updateRfqmJobCalledArgs[1].status).to.equal(RfqmJobStatus.PendingSubmitted);\n            expect(updateRfqmJobCalledArgs[updateRfqmJobCalledArgs.length - 1].status).to.equal(\n                RfqmJobStatus.SucceededConfirmed,\n            );\n            expect(job.status).to.equal(RfqmJobStatus.SucceededConfirmed);\n        });\n    });\n\n    describe('processTradeAsync', () => {\n        it('should process a rfqm v2 job trade successfully', async () => {\n            const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(nowS + 10),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(nowS + 10),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker,\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash,\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '0xworkeraddress',\n            });\n\n            const mockTransactionRequest: providers.TransactionRequest = {};\n            const mockTransaction = new RfqmV2TransactionSubmissionEntity({\n                from: '0xworkeraddress',\n                maxFeePerGas: new BigNumber(100000),\n                maxPriorityFeePerGas: new BigNumber(100),\n                nonce: 0,\n                orderHash: '0x01234567',\n                to: '0xexchangeproxyaddress',\n                transactionHash: '0xsignedtransactionhash',\n                type: RfqmTransactionSubmissionType.Trade,\n            });\n            const mockTransactionReceipt: providers.TransactionReceipt = {\n                blockHash: '0xblockhash',\n                blockNumber: 1,\n                byzantium: true,\n                confirmations: 3,\n                contractAddress: '0xexchangeproxyaddress',\n                cumulativeGasUsed: EthersBigNumber.from(1000),\n                effectiveGasPrice: EthersBigNumber.from(1000),\n                from: '0xworkeraddress',\n                gasUsed: EthersBigNumber.from(10000),\n                logs: [],\n                logsBloom: '',\n                status: 1,\n                to: '0xexchangeproxyaddress',\n                transactionHash: '0xsignedtransactionhash',\n                transactionIndex: 0,\n                type: 2,\n            };\n            const mockMinedBlock: providers.Block = {\n                _difficulty: EthersBigNumber.from(2),\n                difficulty: 2,\n                extraData: '',\n                gasLimit: EthersBigNumber.from(1000),\n                gasUsed: EthersBigNumber.from(1000),\n                hash: '0xblockhash',\n                miner: '0xminer',\n                nonce: '0x000',\n                number: 21,\n                parentHash: '0xparentblockhash',\n                timestamp: 12345,\n                transactions: ['0xpresubmittransactionhash'],\n            };\n            const mockNonce = 0;\n\n            const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n            when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n            );\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(anything())).thenResolve([]);\n            const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n            when(\n                mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                    anything(),\n                    RfqmTransactionSubmissionType.Trade,\n                ),\n            ).thenResolve([]);\n            when(mockDbUtils.findV2TransactionSubmissionByTransactionHashAsync('0xsignedtransactionhash')).thenResolve(\n                _.cloneDeep(mockTransaction),\n            );\n\n            const mockQuoteServerClient = mock(QuoteServerClient);\n            when(mockQuoteServerClient.signV2Async(anything(), anything(), anything())).thenResolve(validEIP712Sig);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getExchangeProxyAddress()).thenReturn('0xexchangeproxyaddress');\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            when(\n                mockBlockchainUtils.generateTakerSignedOtcOrderCallData(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenReturn('0xcalldata');\n            when(\n                mockBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenResolve(0);\n            when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n            when(mockBlockchainUtils.estimateGasForAsync(anything())).thenResolve(100);\n            when(\n                mockBlockchainUtils.transformTxDataToTransactionRequest(anything(), anything(), anything()),\n            ).thenReturn(mockTransactionRequest);\n            when(mockBlockchainUtils.submitSignedTransactionAsync(anything())).thenResolve('0xsignedtransactionhash');\n            when(mockBlockchainUtils.signTransactionAsync(anything())).thenResolve({\n                signedTransaction: 'signedTransaction',\n                transactionHash: '0xsignedtransactionhash',\n            });\n            when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xsignedtransactionhash']))).thenResolve([\n                mockTransactionReceipt,\n            ]);\n            when(mockBlockchainUtils.getBlockAsync('0xblockhash')).thenResolve(mockMinedBlock);\n            when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                quoteServerClient: instance(mockQuoteServerClient),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            await rfqmService.processTradeAsync(job, '0xworkeraddress');\n            expect(updateRfqmJobCalledArgs[0].status).to.equal(RfqmJobStatus.PendingProcessing);\n            expect(updateRfqmJobCalledArgs[1].status).to.equal(RfqmJobStatus.PendingLastLookAccepted);\n            expect(updateRfqmJobCalledArgs[2].status).to.equal(RfqmJobStatus.PendingSubmitted);\n            expect(updateRfqmJobCalledArgs[updateRfqmJobCalledArgs.length - 1].status).to.equal(\n                RfqmJobStatus.SucceededConfirmed,\n            );\n            expect(job.status).to.equal(RfqmJobStatus.SucceededConfirmed);\n        });\n\n        it('should process a meta-transaction job trade successfully', async () => {\n            const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n            const jobId = 'jobId';\n            const transactionSubmissionId = 'submissionId';\n\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(nowS + 600),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: '0xinputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                },\n                jobId,\n            );\n\n            const mockTransactionRequest: providers.TransactionRequest = {};\n            const mockTransaction = createMetaTransactionSubmissionEntity(\n                {\n                    from: '0xworkeraddress',\n                    metaTransactionJobId: jobId,\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xsignedtransactionhash',\n                    type: RfqmTransactionSubmissionType.Trade,\n                },\n                transactionSubmissionId,\n            );\n            const mockTransactionReceipt: providers.TransactionReceipt = {\n                blockHash: '0xblockhash',\n                blockNumber: 1,\n                byzantium: true,\n                confirmations: 3,\n                contractAddress: '0xexchangeproxyaddress',\n                cumulativeGasUsed: EthersBigNumber.from(1000),\n                effectiveGasPrice: EthersBigNumber.from(1000),\n                from: '0xworkeraddress',\n                gasUsed: EthersBigNumber.from(10000),\n                logs: [],\n                logsBloom: '',\n                status: 1,\n                to: '0xexchangeproxyaddress',\n                transactionHash: '0xsignedtransactionhash',\n                transactionIndex: 0,\n                type: 2,\n            };\n            const mockMinedBlock: providers.Block = {\n                _difficulty: EthersBigNumber.from(2),\n                difficulty: 2,\n                extraData: '',\n                gasLimit: EthersBigNumber.from(1000),\n                gasUsed: EthersBigNumber.from(1000),\n                hash: '0xblockhash',\n                miner: '0xminer',\n                nonce: '0x000',\n                number: 21,\n                parentHash: '0xparentblockhash',\n                timestamp: 12345,\n                transactions: ['0xpresubmittransactionhash'],\n            };\n            const mockNonce = 0;\n\n            const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n            when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n            );\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId)).thenResolve([]);\n            const updateRfqmJobCalledArgs: MetaTransactionJobEntity[] = [];\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n            when(\n                mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId, RfqmTransactionSubmissionType.Trade),\n            ).thenResolve([]);\n            when(\n                mockDbUtils.findMetaTransactionSubmissionsByTransactionHashAsync(\n                    '0xsignedtransactionhash',\n                    RfqmTransactionSubmissionType.Trade,\n                ),\n            ).thenResolve([_.cloneDeep(mockTransaction)]);\n\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getExchangeProxyAddress()).thenReturn('0xexchangeproxyaddress');\n            when(mockBlockchainUtils.generateMetaTransactionCallData(anything(), anything(), anything())).thenReturn(\n                '0xcalldata',\n            );\n            when(mockBlockchainUtils.estimateGasForAsync(anything())).thenResolve(0);\n            when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n            when(\n                mockBlockchainUtils.transformTxDataToTransactionRequest(anything(), anything(), anything()),\n            ).thenReturn(mockTransactionRequest);\n            when(mockBlockchainUtils.submitSignedTransactionAsync(anything())).thenResolve('0xsignedtransactionhash');\n            when(mockBlockchainUtils.signTransactionAsync(anything())).thenResolve({\n                signedTransaction: 'signedTransaction',\n                transactionHash: '0xsignedtransactionhash',\n            });\n            when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xsignedtransactionhash']))).thenResolve([\n                mockTransactionReceipt,\n            ]);\n            when(mockBlockchainUtils.getBlockAsync('0xblockhash')).thenResolve(mockMinedBlock);\n            when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n            });\n\n            await rfqmService.processTradeAsync(job, '0xworkeraddress');\n            expect(updateRfqmJobCalledArgs[0].status).to.equal(RfqmJobStatus.PendingProcessing);\n            expect(updateRfqmJobCalledArgs[1].status).to.equal(RfqmJobStatus.PendingSubmitted);\n            expect(updateRfqmJobCalledArgs[updateRfqmJobCalledArgs.length - 1].status).to.equal(\n                RfqmJobStatus.SucceededConfirmed,\n            );\n            expect(job.status).to.equal(RfqmJobStatus.SucceededConfirmed);\n        });\n    });\n\n    describe('validate job methods', () => {\n        it('should return null for valid, unexpired v2 jobs', () => {\n            const fakeInFiveMinutesS = fakeClockMs / ONE_SECOND_MS + 360;\n\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeInFiveMinutesS),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            /* expiry */ new BigNumber(fakeInFiveMinutesS),\n                            /* nonceBucket */ new BigNumber(21),\n                            /* nonce */ new BigNumber(0),\n                        ).toString(),\n                        maker: '',\n                        makerAmount: '',\n                        makerToken: '',\n                        taker: '',\n                        takerAmount: '',\n                        takerToken: '',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '',\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n\n            const result = WorkerService.validateRfqmV2Job(job, new Date(fakeClockMs));\n            expect(result).to.equal(null);\n        });\n\n        it('should return a No Taker Signature status for v2 jobs with no taker signature', () => {\n            const fakeInFiveMinutesS = fakeClockMs / ONE_SECOND_MS + 360;\n\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeInFiveMinutesS),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            /* expiry */ new BigNumber(fakeInFiveMinutesS),\n                            /* nonceBucket */ new BigNumber(21),\n                            /* nonce */ new BigNumber(0),\n                        ).toString(),\n                        maker: '',\n                        makerAmount: '',\n                        makerToken: '',\n                        taker: '',\n                        takerAmount: '',\n                        takerToken: '',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '',\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: null,\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n\n            const result = WorkerService.validateRfqmV2Job(job, new Date(fakeClockMs));\n            expect(result).to.equal(RfqmJobStatus.FailedValidationNoTakerSignature);\n        });\n\n        it('should return null for a valid, unexpired meta-transaction job', () => {\n            const fakeInFiveMinutesS = fakeClockMs / ONE_SECOND_MS + 360;\n\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeInFiveMinutesS),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: '0xinputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                },\n                'jobId',\n            );\n\n            const result = WorkerService.validateMetaTransactionJob(job, new Date(fakeClockMs));\n            expect(result).to.equal(null);\n        });\n\n        it('should return a failed expired status for a meta-transaction job that expires', () => {\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeClockMs / ONE_SECOND_MS),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: '0xinputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                },\n                'jobId',\n            );\n\n            const result = WorkerService.validateMetaTransactionJob(job, new Date(fakeClockMs + 1000000));\n            expect(result).to.equal(RfqmJobStatus.FailedExpired);\n        });\n    });\n\n    describe('shouldResubmitTransaction', () => {\n        it('should return false if new gas price < 10% greater than previous', async () => {\n            const gasFees = { maxFeePerGas: new BigNumber(100), maxPriorityFeePerGas: new BigNumber(10) };\n            const newGasPrice = new BigNumber(105);\n\n            expect(WorkerService.shouldResubmitTransaction(gasFees, newGasPrice)).to.equal(false);\n        });\n        it('should return true if new gas price is 10% greater than previous', async () => {\n            const gasFees = { maxFeePerGas: new BigNumber(100), maxPriorityFeePerGas: new BigNumber(10) };\n            const newGasPrice = new BigNumber(110);\n\n            expect(WorkerService.shouldResubmitTransaction(gasFees, newGasPrice)).to.equal(true);\n        });\n        it('should return true if new gas price > 10% greater than previous', async () => {\n            const gasFees = { maxFeePerGas: new BigNumber(100), maxPriorityFeePerGas: new BigNumber(10) };\n            const newGasPrice = new BigNumber(120);\n\n            expect(WorkerService.shouldResubmitTransaction(gasFees, newGasPrice)).to.equal(true);\n        });\n    });\n\n    describe('checkJobPreprocessingAsync', () => {\n        it('should update job staus and throw error if job validation failed for a rfqm v2 job', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeOneMinuteAgoS),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeOneMinuteAgoS.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker,\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash,\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n            });\n\n            try {\n                await rfqmService.checkJobPreprocessingAsync(job, new Date(fakeClockMs));\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Job failed validation');\n                expect(job.status).to.deep.equal(RfqmJobStatus.FailedExpired);\n            }\n        });\n\n        it('should throw error if there is no taker signature for a rfqm v2 job', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker,\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash,\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: null,\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n            });\n\n            try {\n                await rfqmService.checkJobPreprocessingAsync(job, new Date(fakeClockMs));\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Job failed validation');\n                expect(job.status).to.deep.equal(RfqmJobStatus.FailedValidationNoTakerSignature);\n            }\n        });\n\n        it('should update job staus to `PendingProcessing` if job status is `PendingEnqueued` for a rfqm v2 job', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker,\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash,\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n            });\n\n            await rfqmService.checkJobPreprocessingAsync(job, new Date(fakeClockMs));\n            expect(job.status).to.deep.equal(RfqmJobStatus.PendingProcessing);\n        });\n\n        it('should update job staus and throw error if job validation failed for a meta-transaction job', async () => {\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeOneMinuteAgoS),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: '0xinputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                },\n                'jobId',\n            );\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n            });\n\n            try {\n                await rfqmService.checkJobPreprocessingAsync(job, new Date(fakeClockMs));\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Job failed validation');\n                expect(job.status).to.deep.equal(RfqmJobStatus.FailedExpired);\n            }\n        });\n\n        it('should update job staus to `PendingProcessing` if job status is `PendingEnqueued` for a meta-transaction job', async () => {\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeFiveMinutesLater),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: '0xinputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                },\n                'jobId',\n            );\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n            });\n\n            await rfqmService.checkJobPreprocessingAsync(job, new Date(fakeClockMs));\n            expect(job.status).to.deep.equal(RfqmJobStatus.PendingProcessing);\n        });\n    });\n\n    describe('prepareApprovalAsync', () => {\n        it('should throw exception if there are submitted transactions but job maker signature is null for a rfqm v2 job', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const mockTransaction = new RfqmV2TransactionSubmissionEntity({\n                createdAt: new Date(1233),\n                from: '0xworkeraddress',\n                maxFeePerGas: new BigNumber(100000),\n                maxPriorityFeePerGas: new BigNumber(100),\n                nonce: 0,\n                orderHash: '0x01234567',\n                status: RfqmTransactionSubmissionStatus.Submitted,\n                to: '0xexchangeproxyaddress',\n                transactionHash: '0xpresubmittransactionhash',\n                type: RfqmTransactionSubmissionType.Trade,\n            });\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(\n                mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                    '0x01234567',\n                    RfqmTransactionSubmissionType.Approval,\n                ),\n            ).thenResolve([mockTransaction]);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.generateApprovalCalldataAsync(anything(), anything(), anything())).thenResolve(\n                MOCK_EXECUTE_META_TRANSACTION_CALLDATA,\n            );\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n            });\n\n            try {\n                await rfqmService.prepareApprovalAsync(job, '0xtoken', MOCK_EXECUTE_META_TRANSACTION_APPROVAL, {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                });\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Encountered a job with submissions but no maker signature');\n            }\n        });\n\n        it('should return generated calldata if there are submitted transactions for a rfqm v2 job', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const mockTransaction = new RfqmV2TransactionSubmissionEntity({\n                createdAt: new Date(1233),\n                from: '0xworkeraddress',\n                maxFeePerGas: new BigNumber(100000),\n                maxPriorityFeePerGas: new BigNumber(100),\n                nonce: 0,\n                orderHash: '0x01234567',\n                status: RfqmTransactionSubmissionStatus.Submitted,\n                to: '0xexchangeproxyaddress',\n                transactionHash: '0xpresubmittransactionhash',\n                type: RfqmTransactionSubmissionType.Trade,\n            });\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(\n                mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                    '0x01234567',\n                    RfqmTransactionSubmissionType.Approval,\n                ),\n            ).thenResolve([mockTransaction]);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.generateApprovalCalldataAsync(anything(), anything(), anything())).thenResolve(\n                MOCK_EXECUTE_META_TRANSACTION_CALLDATA,\n            );\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n            });\n\n            const calldata = await rfqmService.prepareApprovalAsync(\n                job,\n                '0xtoken',\n                MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n            );\n            expect(calldata).to.deep.equal(MOCK_EXECUTE_META_TRANSACTION_CALLDATA);\n        });\n\n        it('should throw exception if eth_call failed for a rfqm v2 job', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(\n                mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                    '0x01234567',\n                    RfqmTransactionSubmissionType.Approval,\n                ),\n            ).thenResolve([]);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.generateApprovalCalldataAsync(anything(), anything(), anything())).thenResolve(\n                MOCK_EXECUTE_META_TRANSACTION_CALLDATA,\n            );\n            when(mockBlockchainUtils.estimateGasForAsync(anything())).thenThrow(new Error('error'));\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n            });\n\n            try {\n                await rfqmService.prepareApprovalAsync(job, '0xtoken', MOCK_EXECUTE_META_TRANSACTION_APPROVAL, {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                });\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Eth call approval validation failed');\n                expect(job.status).to.deep.equal(RfqmJobStatus.FailedEthCallFailed);\n            }\n        });\n\n        it('should return correct calldata if there is no submitted transaction for a rfqm v2 job', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(\n                mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                    '0x01234567',\n                    RfqmTransactionSubmissionType.Approval,\n                ),\n            ).thenResolve([]);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.generateApprovalCalldataAsync(anything(), anything(), anything())).thenResolve(\n                MOCK_EXECUTE_META_TRANSACTION_CALLDATA,\n            );\n            when(mockBlockchainUtils.estimateGasForAsync(anything())).thenResolve(10);\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n            });\n\n            const calldata = await rfqmService.prepareApprovalAsync(\n                job,\n                '0xtoken',\n                MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n            );\n            expect(calldata).to.deep.equal(MOCK_EXECUTE_META_TRANSACTION_CALLDATA);\n        });\n\n        it('should return generated calldata if there are submitted transactions for a meta-transaction job', async () => {\n            const jobId = 'jobId';\n            const transactionSubmissionId = 'submissionId';\n\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeFiveMinutesLater),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: '0xinputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                },\n                jobId,\n            );\n\n            const mockTransaction = createMetaTransactionSubmissionEntity(\n                {\n                    from: '0xworkeraddress',\n                    metaTransactionJobId: jobId,\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xsignedtransactionhash',\n                    type: RfqmTransactionSubmissionType.Approval,\n                },\n                transactionSubmissionId,\n            );\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(\n                mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId, RfqmTransactionSubmissionType.Approval),\n            ).thenResolve([mockTransaction]);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.generateApprovalCalldataAsync(anything(), anything(), anything())).thenResolve(\n                MOCK_EXECUTE_META_TRANSACTION_CALLDATA,\n            );\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n            });\n\n            const calldata = await rfqmService.prepareApprovalAsync(\n                job,\n                '0xtoken',\n                MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n            );\n            expect(calldata).to.deep.equal(MOCK_EXECUTE_META_TRANSACTION_CALLDATA);\n            verify(mockBlockchainUtils.estimateGasForAsync(anything())).never();\n        });\n\n        it('should throw exception if eth_call failed for a meta-transaction job', async () => {\n            const jobId = 'jobId';\n\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeFiveMinutesLater),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: '0xinputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                },\n                jobId,\n            );\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(\n                mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId, RfqmTransactionSubmissionType.Approval),\n            ).thenResolve([]);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.generateApprovalCalldataAsync(anything(), anything(), anything())).thenResolve(\n                MOCK_EXECUTE_META_TRANSACTION_CALLDATA,\n            );\n            when(mockBlockchainUtils.estimateGasForAsync(anything())).thenThrow(new Error('error'));\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n            });\n\n            try {\n                await rfqmService.prepareApprovalAsync(job, '0xtoken', MOCK_EXECUTE_META_TRANSACTION_APPROVAL, {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                });\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Eth call approval validation failed');\n                expect(job.status).to.deep.equal(RfqmJobStatus.FailedEthCallFailed);\n            }\n        });\n\n        it('should return correct calldata if there is no submitted transaction for a meta-transaction job', async () => {\n            const jobId = 'jobId';\n\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeFiveMinutesLater),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: '0xinputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                },\n                jobId,\n            );\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(\n                mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId, RfqmTransactionSubmissionType.Approval),\n            ).thenResolve([]);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.generateApprovalCalldataAsync(anything(), anything(), anything())).thenResolve(\n                MOCK_EXECUTE_META_TRANSACTION_CALLDATA,\n            );\n            when(mockBlockchainUtils.estimateGasForAsync(anything())).thenResolve(10);\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n            });\n\n            const calldata = await rfqmService.prepareApprovalAsync(\n                job,\n                '0xtoken',\n                MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n            );\n            expect(calldata).to.deep.equal(MOCK_EXECUTE_META_TRANSACTION_CALLDATA);\n        });\n    });\n\n    describe('preparerfqmV2TradeAsync', () => {\n        it('updates the job and throws upon validation failure when `shouldCheckLastLook` is true', async () => {\n            const expiredJob = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeOneMinuteAgoS),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeOneMinuteAgoS.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '',\n                        makerAmount: '',\n                        makerToken: '',\n                        taker: '',\n                        takerAmount: '',\n                        takerToken: '',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const _job = _.cloneDeep(expiredJob);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync('0x01234567')).thenResolve([]);\n            const rfqmService = buildWorkerServiceForUnitTest({ dbUtils: instance(mockDbUtils) });\n\n            try {\n                await rfqmService.preparerfqmV2TradeAsync(expiredJob, '0xworkeraddress', true, new Date(fakeClockMs));\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Job failed validation');\n                expect(expiredJob).to.deep.equal({ ..._job, status: RfqmJobStatus.FailedExpired });\n            }\n        });\n\n        it('handles a balance check failure', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const _job = _.cloneDeep(job);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync('0x01234567')).thenResolve([]);\n            const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([new BigNumber(100)]);\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(5),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            try {\n                await rfqmService.preparerfqmV2TradeAsync(job, '0xworkeraddress', true, new Date(fakeClockMs));\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Order failed pre-sign validation');\n                expect(updateRfqmJobCalledArgs[0]).to.deep.equal({\n                    ..._job,\n                    status: RfqmJobStatus.PendingProcessing,\n                });\n                expect(updateRfqmJobCalledArgs[1]).to.deep.equal({\n                    ..._job,\n                    status: RfqmJobStatus.FailedPresignValidationFailed,\n                });\n                expect(job).to.deep.equal({\n                    ..._job,\n                    status: RfqmJobStatus.FailedPresignValidationFailed,\n                });\n            }\n        });\n\n        it('handles a decline to sign', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const _job = _.cloneDeep(job);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync('0x01234567')).thenResolve([]);\n            const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n            const mockQuoteServerClient = mock(QuoteServerClient);\n            when(mockQuoteServerClient.signV2Async(anything(), anything(), anything())).thenResolve(undefined);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                quoteServerClient: instance(mockQuoteServerClient),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            try {\n                await rfqmService.preparerfqmV2TradeAsync(job, '0xworkeraddress', true, new Date(fakeClockMs));\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Market Maker declined to sign');\n                expect(job).to.deep.equal({\n                    ..._job,\n                    lastLookResult: false,\n                    status: RfqmJobStatus.FailedLastLookDeclined,\n                });\n            }\n        });\n\n        it('handles a signature failure', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const _job = _.cloneDeep(job);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync('0x01234567')).thenResolve([]);\n            const mockQuoteServerClient = mock(QuoteServerClient);\n            when(mockQuoteServerClient.signV2Async(anything(), anything(), anything())).thenReject(\n                new Error('fake timeout'),\n            );\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                quoteServerClient: instance(mockQuoteServerClient),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            try {\n                await rfqmService.preparerfqmV2TradeAsync(job, '0xworkeraddress', true, new Date(fakeClockMs));\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Job failed during market maker sign attempt');\n                expect(job).to.deep.equal({\n                    ..._job,\n                    status: RfqmJobStatus.FailedSignFailed,\n                });\n            }\n        });\n\n        it('handles signer is not the maker', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker,\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash,\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(orderHash)).thenResolve([]);\n            const mockQuoteServerClient = mock(QuoteServerClient);\n            const invalidEIP712Sig = _.cloneDeep(validEIP712Sig);\n            invalidEIP712Sig.r = '0xdc158f7b53b940863bc7b001552a90282e51033f29b73d44a2701bd16faa19d3';\n            when(mockQuoteServerClient.signV2Async(anything(), anything(), anything())).thenResolve(invalidEIP712Sig);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                quoteServerClient: instance(mockQuoteServerClient),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            try {\n                await rfqmService.preparerfqmV2TradeAsync(job, '0xworkeraddress', true, new Date(fakeClockMs));\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Invalid order signer address');\n                expect(job.status).to.deep.equal(RfqmJobStatus.FailedSignFailed);\n            }\n        });\n\n        it('handles an eth_call failure', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker,\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash,\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const _job = _.cloneDeep(job);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(orderHash)).thenResolve([]);\n            const mockQuoteServerClient = mock(QuoteServerClient);\n            when(mockQuoteServerClient.signV2Async(anything(), anything(), anything())).thenResolve(validEIP712Sig);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            when(\n                mockBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenReject(new Error('fake eth call failure'));\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                quoteServerClient: instance(mockQuoteServerClient),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            try {\n                await rfqmService.preparerfqmV2TradeAsync(job, '0xworkeraddress', true, new Date(fakeClockMs));\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Eth call validation failed');\n                expect(job).to.deep.equal({\n                    ..._job,\n                    lastLookResult: true,\n                    makerSignature: validEIP712Sig,\n                    status: RfqmJobStatus.FailedEthCallFailed,\n                });\n            }\n        });\n\n        it('updates market maker signatures missing bytes', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker,\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash,\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const _job = _.cloneDeep(job);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(anything())).thenResolve([]);\n            const mockQuoteServerClient = mock(QuoteServerClient);\n            when(mockQuoteServerClient.signV2Async(anything(), anything(), anything())).thenResolve(missingByteSig);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.isValidOrderSignerAsync(anything(), anything())).thenResolve(true);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            when(\n                mockBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenResolve(0);\n            when(\n                mockBlockchainUtils.generateTakerSignedOtcOrderCallData(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenReturn('0xvalidcalldata');\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                quoteServerClient: instance(mockQuoteServerClient),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            await rfqmService.preparerfqmV2TradeAsync(job, '0xworkeraddress', true, new Date(fakeClockMs));\n            expect(job).to.deep.equal({\n                ..._job,\n                lastLookResult: true,\n                makerSignature: padSignature(missingByteSig),\n                status: RfqmJobStatus.PendingLastLookAccepted,\n            });\n        });\n\n        it('skips the eth_call for jobs with existing submissions', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: true,\n                makerUri: 'http://foo.bar',\n                makerSignature: validEIP712Sig,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingLastLookAccepted,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const transaction = new RfqmV2TransactionSubmissionEntity({\n                orderHash,\n                to: '0xexchangeproxyaddress',\n                from: '0xworkeraddress',\n                transactionHash: '0xsignedtransactionhash',\n                maxFeePerGas: new BigNumber(100000),\n                maxPriorityFeePerGas: new BigNumber(100),\n                nonce: 21,\n                type: RfqmTransactionSubmissionType.Trade,\n            });\n            const _job = _.cloneDeep(job);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync('0x01234567')).thenResolve([transaction]);\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n            const mockQuoteServerClient = mock(QuoteServerClient);\n            when(mockQuoteServerClient.signV2Async(anything(), anything(), anything())).thenResolve(validEIP712Sig);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            when(\n                mockBlockchainUtils.generateTakerSignedOtcOrderCallData(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenReturn('0xvalidcalldata');\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                quoteServerClient: instance(mockQuoteServerClient),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            const calldata = await rfqmService.preparerfqmV2TradeAsync(\n                job,\n                '0xworkeraddress',\n                true,\n                new Date(fakeClockMs),\n            );\n            expect(job).to.deep.equal({\n                ..._job,\n                lastLookResult: true,\n                makerSignature: validEIP712Sig,\n                status: RfqmJobStatus.PendingLastLookAccepted,\n            });\n            expect(calldata).to.equal('0xvalidcalldata');\n            verify(\n                mockBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).never();\n        });\n\n        it('lets expired jobs with existing submissions fall through', async () => {\n            // If the job isn't in a terminal status but there are existing submissions,\n            // `prepareTradeAsync` will let the job continue to the submission step which\n            // will allow the worker to check receipts for those submissions.\n            const expiredJob = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeOneMinuteAgoS),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: true,\n                makerUri: 'http://foo.bar',\n                makerSignature: {\n                    r: '0x01',\n                    s: '0x02',\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                },\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeOneMinuteAgoS.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingSubmitted,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n\n            const transaction = new RfqmV2TransactionSubmissionEntity({\n                orderHash: '0x01234567',\n                to: '0xexchangeproxyaddress',\n                from: '0xworkeraddress',\n                transactionHash: '0xsignedtransactionhash',\n                maxFeePerGas: new BigNumber(100000),\n                maxPriorityFeePerGas: new BigNumber(100),\n                nonce: 21,\n                type: RfqmTransactionSubmissionType.Trade,\n            });\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync('0x01234567')).thenResolve([transaction]);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(\n                mockBlockchainUtils.generateTakerSignedOtcOrderCallData(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenReturn('0xvalidcalldata');\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n            });\n\n            await rfqmService.preparerfqmV2TradeAsync(expiredJob, '0xworkeraddress', true, new Date(fakeClockMs));\n            expect(expiredJob.status).to.equal(RfqmJobStatus.PendingSubmitted);\n        });\n\n        it('successfully prepares a job when checking last look', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker,\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash,\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '0xworkeraddress',\n            });\n            const _job = _.cloneDeep(job);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(orderHash)).thenResolve([]);\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n            const mockQuoteServerClient = mock(QuoteServerClient);\n            when(mockQuoteServerClient.signV2Async(anything(), anything(), anything())).thenResolve(validEIP712Sig);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            when(\n                mockBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenResolve(0);\n            when(\n                mockBlockchainUtils.generateTakerSignedOtcOrderCallData(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenReturn('0xvalidcalldata');\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                quoteServerClient: instance(mockQuoteServerClient),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            const calldata = await rfqmService.preparerfqmV2TradeAsync(\n                job,\n                '0xworkeraddress',\n                true,\n                new Date(fakeClockMs),\n            );\n            expect(job).to.deep.equal({\n                ..._job,\n                lastLookResult: true,\n                makerSignature: validEIP712Sig,\n                status: RfqmJobStatus.PendingLastLookAccepted,\n            });\n            expect(calldata).to.equal('0xvalidcalldata');\n            expect(updateRfqmJobCalledArgs[0]).to.deep.equal({\n                ..._job,\n                status: RfqmJobStatus.PendingProcessing,\n            });\n            expect(updateRfqmJobCalledArgs[1]).to.deep.equal({\n                ..._job,\n                lastLookResult: true,\n                makerSignature: validEIP712Sig,\n                status: RfqmJobStatus.PendingLastLookAccepted,\n            });\n        });\n\n        it('successfully prepares a job if no last look is necessary', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: true,\n                makerUri: 'http://foo.bar',\n                makerSignature: validEIP712Sig,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker,\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash,\n                status: RfqmJobStatus.PendingLastLookAccepted,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '0xworkeraddress',\n            });\n            const _job = _.cloneDeep(job);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(orderHash)).thenResolve([]);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            when(\n                mockBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenResolve(0);\n            when(\n                mockBlockchainUtils.generateTakerSignedOtcOrderCallData(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenReturn('0xvalidcalldata');\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n            const spiedRfqmService = spy(rfqmService);\n\n            const calldata = await rfqmService.preparerfqmV2TradeAsync(\n                job,\n                '0xworkeraddress',\n                false,\n                new Date(fakeClockMs),\n            );\n            expect(job).to.deep.equal(_job);\n            expect(calldata).to.equal('0xvalidcalldata');\n            verify(spiedRfqmService.checkJobPreprocessingAsync(anything(), anything())).never();\n            verify(spiedRfqmService.checkLastLookAsync(anything(), anything(), anything())).never();\n        });\n    });\n\n    describe('prepareMetaTransactionTradeAsync', () => {\n        it('updates the job and throws upon validation failure if `shouldValidateJob` is true', async () => {\n            const jobId = 'jobId';\n            const expiredJob = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeOneMinuteAgoS),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: '0xinputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                },\n                jobId,\n            );\n\n            const _job = _.cloneDeep(expiredJob);\n            const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n            when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n            );\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId)).thenResolve([]);\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                gasStationAttendant: instance(gasStationAttendantMock),\n            });\n\n            try {\n                await rfqmService.prepareMetaTransactionTradeAsync(\n                    expiredJob,\n                    '0xworkeraddress',\n                    true,\n                    new Date(fakeClockMs),\n                );\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Job failed validation');\n                expect(expiredJob).to.deep.equal({ ..._job, status: RfqmJobStatus.FailedExpired });\n            }\n        });\n\n        it('handles an eth_call failure', async () => {\n            const jobId = 'jobId';\n\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeFiveMinutesLater),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: '0xinputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                },\n                jobId,\n            );\n            const _job = _.cloneDeep(job);\n\n            const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n            when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n            );\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId)).thenResolve([]);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            when(mockBlockchainUtils.estimateGasForAsync(anything())).thenReject(new Error('fake eth call failure'));\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                gasStationAttendant: instance(gasStationAttendantMock),\n            });\n\n            try {\n                await rfqmService.prepareMetaTransactionTradeAsync(job, '0xworkeraddress', true, new Date(fakeClockMs));\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Eth call validation failed');\n                expect(job).to.deep.equal({\n                    ..._job,\n                    status: RfqmJobStatus.FailedEthCallFailed,\n                });\n            }\n        });\n\n        it('skips the eth_call for jobs with existing submissions', async () => {\n            const jobId = 'jobId';\n\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeFiveMinutesLater),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: '0xinputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingProcessing,\n                    workerAddress: '0xworkeraddress',\n                },\n                jobId,\n            );\n            const transaction = createMetaTransactionSubmissionEntity(\n                {\n                    from: '0xworkeraddress',\n                    metaTransactionJobId: jobId,\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xsignedtransactionhash',\n                    type: RfqmTransactionSubmissionType.Trade,\n                },\n                'submissionId',\n            );\n            const _job = _.cloneDeep(job);\n\n            const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n            when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n            );\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId)).thenResolve([transaction]);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.generateMetaTransactionCallData(anything(), anything(), anything())).thenReturn(\n                '0xvalidcalldata',\n            );\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                gasStationAttendant: instance(gasStationAttendantMock),\n            });\n\n            const calldata = await rfqmService.prepareMetaTransactionTradeAsync(\n                job,\n                '0xworkeraddress',\n                true,\n                new Date(fakeClockMs),\n            );\n            expect(job).to.deep.equal(_job);\n            expect(calldata).to.equal('0xvalidcalldata');\n            verify(mockBlockchainUtils.estimateGasForAsync(anything())).never();\n        });\n\n        it('successfully prepares a job if `shouldValidateJob` is true', async () => {\n            const jobId = 'jobId';\n\n            const job = createMeaTrsanctionJobEntity(\n                {\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(fakeFiveMinutesLater),\n                    fee: {\n                        amount: new BigNumber(0),\n                        token: '',\n                        type: 'fixed',\n                    },\n                    inputToken: '0xinputToken',\n                    inputTokenAmount: new BigNumber(10),\n                    integratorId: '0xintegrator',\n                    metaTransaction: MOCK_META_TRANSACTION,\n                    metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                    minOutputTokenAmount: new BigNumber(10),\n                    outputToken: '0xoutputToken',\n                    takerAddress: '0xtakerAddress',\n                    takerSignature: {\n                        signatureType: SignatureType.EthSign,\n                        v: 27,\n                        r: '0x01',\n                        s: '0x02',\n                    },\n                    status: RfqmJobStatus.PendingEnqueued,\n                    workerAddress: '0xworkeraddress',\n                },\n                jobId,\n            );\n            const _job = _.cloneDeep(job);\n\n            const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n            when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n            );\n            const mockDbUtils = mock(RfqmDbUtils);\n            const updateRfqmJobCalledArgs: MetaTransactionJobEntity[] = [];\n            when(mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId)).thenResolve([]);\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.estimateGasForAsync(anything())).thenResolve(0);\n            when(mockBlockchainUtils.generateMetaTransactionCallData(anything(), anything(), anything())).thenReturn(\n                '0xvalidcalldata',\n            );\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                gasStationAttendant: instance(gasStationAttendantMock),\n            });\n\n            const calldata = await rfqmService.prepareMetaTransactionTradeAsync(\n                job,\n                '0xworkeraddress',\n                true,\n                new Date(fakeClockMs),\n            );\n            expect(job).to.deep.equal({\n                ..._job,\n                status: RfqmJobStatus.PendingProcessing,\n            });\n            expect(calldata).to.equal('0xvalidcalldata');\n            expect(updateRfqmJobCalledArgs[0]).to.deep.equal({\n                ..._job,\n                status: RfqmJobStatus.PendingProcessing,\n            });\n        });\n    });\n\n    describe('checkLastLookAsync', () => {\n        it('should call `getMinOfBalancesAndAllowancesAsync` when `shouldCheckAllowance` is true and throws when balance check fails', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingProcessing,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const _job = _.cloneDeep(job);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([new BigNumber(100)]);\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(5),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            try {\n                await rfqmService.checkLastLookAsync(job, '0xworkeraddress', true);\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Order failed pre-sign validation');\n                expect(updateRfqmJobCalledArgs[0]).to.deep.equal({\n                    ..._job,\n                    status: RfqmJobStatus.FailedPresignValidationFailed,\n                });\n                expect(job).to.deep.equal({\n                    ..._job,\n                    status: RfqmJobStatus.FailedPresignValidationFailed,\n                });\n                verify(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).once();\n                verify(mockBlockchainUtils.getTokenBalancesAsync(anything())).never();\n            }\n        });\n\n        it('should call `getTokenBalancesAsync` when `shouldCheckAllowance` is false and throws when balance check fails', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingProcessing,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const _job = _.cloneDeep(job);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getTokenBalancesAsync(anything())).thenResolve([new BigNumber(100)]);\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(5),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            try {\n                await rfqmService.checkLastLookAsync(job, '0xworkeraddress', false);\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Order failed pre-sign validation');\n                expect(updateRfqmJobCalledArgs[0]).to.deep.equal({\n                    ..._job,\n                    status: RfqmJobStatus.FailedPresignValidationFailed,\n                });\n                expect(job).to.deep.equal({\n                    ..._job,\n                    status: RfqmJobStatus.FailedPresignValidationFailed,\n                });\n\n                verify(mockBlockchainUtils.getTokenBalancesAsync(anything())).once();\n                verify(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).never();\n            }\n        });\n\n        it('should throw when taker signature is not present', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingProcessing,\n                takerSignature: null,\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const _job = _.cloneDeep(job);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            try {\n                await rfqmService.checkLastLookAsync(job, '0xworkeraddress', true);\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Order failed pre-sign validation due to empty takerSignature');\n                expect(updateRfqmJobCalledArgs[0]).to.deep.equal({\n                    ..._job,\n                    status: RfqmJobStatus.FailedPresignValidationFailed,\n                });\n                expect(job).to.deep.equal({\n                    ..._job,\n                    status: RfqmJobStatus.FailedPresignValidationFailed,\n                });\n            }\n        });\n\n        it('handles decline to sign', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const _job = _.cloneDeep(job);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync('0x01234567')).thenResolve([]);\n            when(mockDbUtils.findV2QuoteByOrderHashAsync('0x01234567')).thenResolve(\n                new RfqmV2QuoteEntity({\n                    createdAt: new Date(),\n                    chainId: job.chainId,\n                    fee: job.fee,\n                    makerUri: job.makerUri,\n                    order: job.order,\n                    orderHash: job.orderHash,\n                }),\n            );\n            const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n            const mockQuoteServerClient = mock(QuoteServerClient);\n            when(mockQuoteServerClient.signV2Async(anything(), anything(), anything())).thenResolve(undefined);\n\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const mockCacheClient = mock(CacheClient);\n\n            const mockRfqMakerManager = mock(RfqMakerManager);\n            when(mockRfqMakerManager.findMakerIdWithRfqmUri(job.makerUri)).thenReturn('makerId1');\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                quoteServerClient: instance(mockQuoteServerClient),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n                rfqMakerManager: instance(mockRfqMakerManager),\n                cacheClient: instance(mockCacheClient),\n            });\n\n            try {\n                await rfqmService.checkLastLookAsync(job, '0xworkeraddress', true);\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Market Maker declined to sign');\n                expect(job).to.deep.equal({\n                    ..._job,\n                    lastLookResult: false,\n                    status: RfqmJobStatus.FailedLastLookDeclined,\n                });\n\n                verify(\n                    mockCacheClient.addMakerToCooldownAsync(\n                        'makerId1',\n                        anything(),\n                        job.chainId,\n                        job.order.order.makerToken,\n                        job.order.order.takerToken,\n                    ),\n                ).once();\n\n                verify(\n                    mockDbUtils.writeV2LastLookRejectionCooldownAsync(\n                        'makerId1',\n                        job.chainId,\n                        job.order.order.makerToken,\n                        job.order.order.takerToken,\n                        anything(),\n                        anything(),\n                        job.orderHash,\n                    ),\n                ).once();\n            }\n        });\n\n        it('handles a signature failure', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker: '0xmaker',\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '0x01234567',\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const _job = _.cloneDeep(job);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync('0x01234567')).thenResolve([]);\n            const mockQuoteServerClient = mock(QuoteServerClient);\n            when(mockQuoteServerClient.signV2Async(anything(), anything(), anything())).thenReject(\n                new Error('fake timeout'),\n            );\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                quoteServerClient: instance(mockQuoteServerClient),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            try {\n                await rfqmService.checkLastLookAsync(job, '0xworkeraddress', true);\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Job failed during market maker sign attempt');\n                expect(job).to.deep.equal({\n                    ..._job,\n                    status: RfqmJobStatus.FailedSignFailed,\n                });\n            }\n        });\n\n        it('handles signer is not the maker', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker,\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash,\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n            when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n            });\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(orderHash)).thenResolve([]);\n            const mockQuoteServerClient = mock(QuoteServerClient);\n            const invalidEIP712Sig = _.cloneDeep(validEIP712Sig);\n            invalidEIP712Sig.r = '0xdc158f7b53b940863bc7b001552a90282e51033f29b73d44a2701bd16faa19d3';\n            when(mockQuoteServerClient.signV2Async(anything(), anything(), anything())).thenResolve(invalidEIP712Sig);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                quoteServerClient: instance(mockQuoteServerClient),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            try {\n                await rfqmService.checkLastLookAsync(job, '0xworkeraddress', true);\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('Invalid order signer address');\n                expect(job.status).to.deep.equal(RfqmJobStatus.FailedSignFailed);\n            }\n        });\n\n        it('updates market maker signatures missing bytes', async () => {\n            const job = new RfqmV2JobEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                expiry: new BigNumber(fakeFiveMinutesLater),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                lastLookResult: null,\n                makerUri: 'http://foo.bar',\n                makerSignature: null,\n                order: {\n                    order: {\n                        chainId: '1',\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                            new BigNumber(fakeFiveMinutesLater.toString()),\n                            new BigNumber(1),\n                            new BigNumber(1),\n                        ).toString(),\n                        maker,\n                        makerAmount: '1000000',\n                        makerToken: '0xmakertoken',\n                        taker: '0xtaker',\n                        takerAmount: '10000000',\n                        takerToken: '0xtakertoken',\n                        txOrigin: '',\n                        verifyingContract: '',\n                    },\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash,\n                status: RfqmJobStatus.PendingEnqueued,\n                takerSignature: {\n                    signatureType: SignatureType.EthSign,\n                    v: 27,\n                    r: '0x01',\n                    s: '0x02',\n                },\n                updatedAt: new Date(),\n                workerAddress: '',\n            });\n            const _job = _.cloneDeep(job);\n\n            const mockDbUtils = mock(RfqmDbUtils);\n            when(mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(anything())).thenResolve([]);\n            const mockQuoteServerClient = mock(QuoteServerClient);\n            when(mockQuoteServerClient.signV2Async(anything(), anything(), anything())).thenResolve(missingByteSig);\n            const mockBlockchainUtils = mock(RfqBlockchainUtils);\n            when(mockBlockchainUtils.isValidOrderSignerAsync(anything(), anything())).thenResolve(true);\n            when(mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n            when(\n                mockBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenResolve(0);\n            when(\n                mockBlockchainUtils.generateTakerSignedOtcOrderCallData(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenReturn('0xvalidcalldata');\n            const mockRfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n            when(mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(1000000000),\n            ]);\n\n            const rfqmService = buildWorkerServiceForUnitTest({\n                dbUtils: instance(mockDbUtils),\n                quoteServerClient: instance(mockQuoteServerClient),\n                rfqBlockchainUtils: instance(mockBlockchainUtils),\n                rfqMakerBalanceCacheService: instance(mockRfqMakerBalanceCacheService),\n            });\n\n            await rfqmService.checkLastLookAsync(job, '0xworkeraddress', true);\n            expect(job).to.deep.equal({\n                ..._job,\n                lastLookResult: true,\n                makerSignature: padSignature(missingByteSig),\n                status: RfqmJobStatus.PendingLastLookAccepted,\n            });\n        });\n    });\n\n    describe('submitToChainAsync', () => {\n        describe('kind is `rfqm_v2_job`', () => {\n            it('submits a transaction successfully when there is no previous transaction', async () => {\n                const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n                const job = new RfqmV2JobEntity({\n                    affiliateAddress: '',\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(nowS + 600),\n                    fee: {\n                        amount: '0',\n                        token: '',\n                        type: 'fixed',\n                    },\n                    integratorId: '',\n                    lastLookResult: true,\n                    makerUri: 'http://foo.bar',\n                    order: {\n                        order: {\n                            chainId: '1',\n                            expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                                new BigNumber(nowS + 600),\n                                new BigNumber(1),\n                                new BigNumber(1),\n                            ).toString(),\n                            maker: '0xmaker',\n                            makerAmount: '1000000',\n                            makerToken: '0xmakertoken',\n                            taker: '0xtaker',\n                            takerAmount: '10000000',\n                            takerToken: '0xtakertoken',\n                            txOrigin: '',\n                            verifyingContract: '',\n                        },\n                        type: RfqmOrderTypes.Otc,\n                    },\n                    orderHash: '0x01234567',\n                    status: RfqmJobStatus.PendingLastLookAccepted,\n                    updatedAt: new Date(),\n                    workerAddress: '',\n                });\n\n                const mockTransactionRequest: providers.TransactionRequest = {};\n                const mockTransaction = new RfqmV2TransactionSubmissionEntity({\n                    from: '0xworkeraddress',\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    orderHash: '0x01234567',\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xsignedtransactionhash',\n                    type: RfqmTransactionSubmissionType.Trade,\n                });\n                const mockTransactionReceipt: providers.TransactionReceipt = {\n                    to: '0xto',\n                    from: '0xfrom',\n                    contractAddress: '0xexchangeproxyaddress',\n                    transactionIndex: 0,\n                    gasUsed: EthersBigNumber.from(10000),\n                    logsBloom: '',\n                    blockHash: '0xblockhash',\n                    transactionHash: '0xsignedtransactionhash',\n                    logs: [],\n                    blockNumber: 1,\n                    confirmations: 3,\n                    cumulativeGasUsed: EthersBigNumber.from(1000),\n                    effectiveGasPrice: EthersBigNumber.from(1000),\n                    byzantium: true,\n                    type: 2,\n                    status: 1,\n                };\n                const mockNonce = 0;\n\n                const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n                when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                    new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n                );\n                const mockDbUtils = mock(RfqmDbUtils);\n                when(\n                    mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                        '0x01234567',\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([]);\n                const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n                when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                    updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n                });\n                const writeV2RfqmTransactionSubmissionToDbCalledArgs: RfqmTransactionSubmissionEntity[] = [];\n                when(mockDbUtils.writeV2RfqmTransactionSubmissionToDbAsync(anything())).thenCall(\n                    async (transactionArg) => {\n                        writeV2RfqmTransactionSubmissionToDbCalledArgs.push(_.cloneDeep(transactionArg));\n                        return _.cloneDeep(mockTransaction);\n                    },\n                );\n                when(\n                    mockDbUtils.findV2TransactionSubmissionByTransactionHashAsync('0xsignedtransactionhash'),\n                ).thenResolve(_.cloneDeep(mockTransaction));\n                const updateRfqmTransactionSubmissionsCalledArgs: RfqmTransactionSubmissionEntity[][] = [];\n                when(mockDbUtils.updateRfqmTransactionSubmissionsAsync(anything())).thenCall(async (tranactionArg) => {\n                    updateRfqmTransactionSubmissionsCalledArgs.push(_.cloneDeep(tranactionArg));\n                });\n                const mockBlockchainUtils = mock(RfqBlockchainUtils);\n                when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n                when(mockBlockchainUtils.estimateGasForAsync(anything())).thenResolve(100);\n                when(\n                    mockBlockchainUtils.transformTxDataToTransactionRequest(anything(), anything(), anything()),\n                ).thenReturn(mockTransactionRequest);\n                when(mockBlockchainUtils.signTransactionAsync(anything())).thenResolve({\n                    signedTransaction: 'signedTransaction',\n                    transactionHash: '0xsignedtransactionhash',\n                });\n                when(mockBlockchainUtils.getExchangeProxyAddress()).thenReturn('0xexchangeproxyaddress');\n                when(mockBlockchainUtils.submitSignedTransactionAsync(anything())).thenResolve(\n                    '0xsignedtransactionhash',\n                );\n                when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xsignedtransactionhash']))).thenResolve([\n                    mockTransactionReceipt,\n                ]);\n                when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n                when(mockBlockchainUtils.getDecodedRfqOrderFillEventLogFromLogs(anything())).thenReturn({\n                    event: '',\n                    logIndex: null,\n                    transactionIndex: null,\n                    transactionHash: '',\n                    blockHash: '',\n                    address: '',\n                    data: '',\n                    blockNumber: 0,\n                    topics: [],\n                    args: {\n                        maker: '',\n                        makerToken: '',\n                        makerTokenFilledAmount: new BigNumber(1234),\n                        orderHash: '',\n                        pool: '',\n                        taker: '',\n                        takerToken: '',\n                        takerTokenFilledAmount: new BigNumber(5),\n                    },\n                });\n                const rfqmService = buildWorkerServiceForUnitTest({\n                    dbUtils: instance(mockDbUtils),\n                    gasStationAttendant: instance(gasStationAttendantMock),\n                    rfqBlockchainUtils: instance(mockBlockchainUtils),\n                });\n\n                const callback = async (\n                    newSubmissionContextStatus: SubmissionContextStatus,\n                    oldSubmissionContextStatus?: SubmissionContextStatus,\n                ): Promise<void> => {\n                    if (newSubmissionContextStatus !== oldSubmissionContextStatus) {\n                        const newJobStatus =\n                            SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\n                        job.status = newJobStatus;\n                        await mockDbUtils.updateRfqmJobAsync(job);\n                    }\n                };\n                await rfqmService.submitToChainAsync({\n                    kind: job.kind,\n                    to: '0xexchangeproxyaddress',\n                    from: '0xworkeraddress',\n                    calldata: '0xcalldata',\n                    expiry: job.expiry,\n                    identifier: job.orderHash,\n                    submissionType: RfqmTransactionSubmissionType.Trade,\n                    onSubmissionContextStatusUpdate: callback,\n                });\n                verify(mockBlockchainUtils.estimateGasForAsync(anything()));\n                // eth_createAccessList should not be called when not enabled\n                verify(mockBlockchainUtils.createAccessListForAsync(anything())).never();\n                expect(job.status).to.equal(RfqmJobStatus.SucceededConfirmed);\n                expect(writeV2RfqmTransactionSubmissionToDbCalledArgs[0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.Presubmit,\n                );\n                expect(updateRfqmTransactionSubmissionsCalledArgs[0][0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.Submitted,\n                );\n                expect(updateRfqmTransactionSubmissionsCalledArgs[1][0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                );\n            });\n\n            it(\"ignores an existing PRESUBMIT transaction which isn't found in the mempool or on chain\", async () => {\n                const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n                const job = new RfqmV2JobEntity({\n                    affiliateAddress: '',\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(nowS + 600),\n                    fee: {\n                        amount: '0',\n                        token: '',\n                        type: 'fixed',\n                    },\n                    integratorId: '',\n                    lastLookResult: true,\n                    makerUri: 'http://foo.bar',\n                    order: {\n                        order: {\n                            chainId: '1',\n                            expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                                new BigNumber(nowS + 600),\n                                new BigNumber(1),\n                                new BigNumber(1),\n                            ).toString(),\n                            maker: '0xmaker',\n                            makerAmount: '1000000',\n                            makerToken: '0xmakertoken',\n                            taker: '0xtaker',\n                            takerAmount: '10000000',\n                            takerToken: '0xtakertoken',\n                            txOrigin: '',\n                            verifyingContract: '',\n                        },\n                        type: RfqmOrderTypes.Otc,\n                    },\n                    orderHash: '0x01234567',\n                    status: RfqmJobStatus.PendingLastLookAccepted,\n                    updatedAt: new Date(),\n                    workerAddress: '',\n                });\n\n                const mockPresubmitTransaction = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(1233),\n                    from: '0xworkeraddress',\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    orderHash: '0x01234567',\n                    status: RfqmTransactionSubmissionStatus.Presubmit,\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xpresubmittransactionhash',\n                    type: RfqmTransactionSubmissionType.Trade,\n                });\n\n                const mockTransactionRequest: providers.TransactionRequest = {};\n                const mockTransaction = new RfqmV2TransactionSubmissionEntity({\n                    from: '0xworkeraddress',\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    orderHash: '0x01234567',\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xsignedtransactionhash',\n                    type: RfqmTransactionSubmissionType.Trade,\n                });\n                const mockTransactionReceipt: providers.TransactionReceipt = {\n                    to: '0xexchangeproxyaddress',\n                    from: '0xworkeraddress',\n                    contractAddress: '0xexchangeproxyaddress',\n                    transactionIndex: 0,\n                    gasUsed: EthersBigNumber.from(10000),\n                    logsBloom: '',\n                    blockHash: '0xblockhash',\n                    transactionHash: '0xsignedtransactionhash',\n                    logs: [],\n                    blockNumber: 1,\n                    confirmations: 3,\n                    cumulativeGasUsed: EthersBigNumber.from(1000),\n                    effectiveGasPrice: EthersBigNumber.from(1000),\n                    byzantium: true,\n                    type: 2,\n                    status: 1,\n                };\n                const mockNonce = 0;\n\n                const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n                when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                    new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n                );\n                const mockDbUtils = mock(RfqmDbUtils);\n                when(\n                    mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                        '0x01234567',\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([mockPresubmitTransaction]);\n                const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n                when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                    updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n                });\n                const writeV2RfqmTransactionSubmissionToDbCalledArgs: RfqmTransactionSubmissionEntity[] = [];\n                when(mockDbUtils.writeV2RfqmTransactionSubmissionToDbAsync(anything())).thenCall(\n                    async (transactionArg) => {\n                        writeV2RfqmTransactionSubmissionToDbCalledArgs.push(_.cloneDeep(transactionArg));\n                        return _.cloneDeep(mockTransaction);\n                    },\n                );\n                when(\n                    mockDbUtils.findV2TransactionSubmissionByTransactionHashAsync('0xsignedtransactionhash'),\n                ).thenResolve(_.cloneDeep(mockTransaction));\n                const updateRfqmTransactionSubmissionsCalledArgs: RfqmV2TransactionSubmissionEntity[][] = [];\n                when(mockDbUtils.updateRfqmTransactionSubmissionsAsync(anything())).thenCall(async (tranactionArg) => {\n                    updateRfqmTransactionSubmissionsCalledArgs.push(_.cloneDeep(tranactionArg));\n                });\n                const mockBlockchainUtils = mock(RfqBlockchainUtils);\n                // This mock response indicates that the presubmit transaction can't be found\n                // on chain or in the mempool\n                when(mockBlockchainUtils.getTransactionAsync('0xpresubmittransactionhash')).thenResolve(null);\n                when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n                when(mockBlockchainUtils.estimateGasForAsync(anything())).thenResolve(100);\n                when(\n                    mockBlockchainUtils.transformTxDataToTransactionRequest(anything(), anything(), anything()),\n                ).thenReturn(mockTransactionRequest);\n                when(mockBlockchainUtils.signTransactionAsync(anything())).thenResolve({\n                    signedTransaction: 'signedTransaction',\n                    transactionHash: '0xsignedtransactionhash',\n                });\n                when(mockBlockchainUtils.getExchangeProxyAddress()).thenReturn('0xexchangeproxyaddress');\n                when(mockBlockchainUtils.submitSignedTransactionAsync(anything())).thenResolve(\n                    '0xsignedtransactionhash',\n                );\n                when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xsignedtransactionhash']))).thenResolve([\n                    mockTransactionReceipt,\n                ]);\n                when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n                when(mockBlockchainUtils.getDecodedRfqOrderFillEventLogFromLogs(anything())).thenReturn({\n                    event: '',\n                    logIndex: null,\n                    transactionIndex: null,\n                    transactionHash: '',\n                    blockHash: '',\n                    address: '',\n                    data: '',\n                    blockNumber: 0,\n                    topics: [],\n                    args: {\n                        maker: '',\n                        makerToken: '',\n                        makerTokenFilledAmount: new BigNumber(1234),\n                        orderHash: '',\n                        pool: '',\n                        taker: '',\n                        takerToken: '',\n                        takerTokenFilledAmount: new BigNumber(5),\n                    },\n                });\n                const rfqmService = buildWorkerServiceForUnitTest({\n                    dbUtils: instance(mockDbUtils),\n                    gasStationAttendant: instance(gasStationAttendantMock),\n                    rfqBlockchainUtils: instance(mockBlockchainUtils),\n                });\n\n                const callback = async (\n                    newSubmissionContextStatus: SubmissionContextStatus,\n                    oldSubmissionContextStatus?: SubmissionContextStatus,\n                ): Promise<void> => {\n                    if (newSubmissionContextStatus !== oldSubmissionContextStatus) {\n                        const newJobStatus =\n                            SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\n                        job.status = newJobStatus;\n                        await mockDbUtils.updateRfqmJobAsync(job);\n                    }\n                };\n                await rfqmService.submitToChainAsync({\n                    kind: job.kind,\n                    to: '0xexchangeproxyaddress',\n                    from: '0xworkeraddress',\n                    calldata: '0xcalldata',\n                    expiry: job.expiry,\n                    identifier: job.orderHash,\n                    submissionType: RfqmTransactionSubmissionType.Trade,\n                    onSubmissionContextStatusUpdate: callback,\n                });\n\n                // eth_createAccessList should not be called when not enabled\n                verify(mockBlockchainUtils.createAccessListForAsync(anything())).never();\n                expect(job.status).to.equal(RfqmJobStatus.SucceededConfirmed);\n                // Expectations are the same as if the presubmit transaction never existed\n                expect(writeV2RfqmTransactionSubmissionToDbCalledArgs[0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.Presubmit,\n                );\n                expect(updateRfqmTransactionSubmissionsCalledArgs[0][0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.Submitted,\n                );\n                expect(updateRfqmTransactionSubmissionsCalledArgs[1][0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                );\n            });\n\n            it(\"marks a PRESUBMIT job as expired when existing transactions aren't found in \\\n            the mempool or on chain and the expiration time has passed\", async () => {\n                const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n                const job = new RfqmV2JobEntity({\n                    affiliateAddress: '',\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(nowS - 60),\n                    fee: {\n                        amount: '0',\n                        token: '',\n                        type: 'fixed',\n                    },\n                    integratorId: '',\n                    lastLookResult: true,\n                    makerUri: 'http://foo.bar',\n                    order: {\n                        order: {\n                            chainId: '1',\n                            expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                                new BigNumber(nowS - 60),\n                                new BigNumber(1),\n                                new BigNumber(1),\n                            ).toString(),\n                            maker: '0xmaker',\n                            makerAmount: '1000000',\n                            makerToken: '0xmakertoken',\n                            taker: '0xtaker',\n                            takerAmount: '10000000',\n                            takerToken: '0xtakertoken',\n                            txOrigin: '',\n                            verifyingContract: '',\n                        },\n                        type: RfqmOrderTypes.Otc,\n                    },\n                    orderHash: '0x01234567',\n                    status: RfqmJobStatus.PendingLastLookAccepted,\n                    updatedAt: new Date(),\n                    workerAddress: '',\n                });\n\n                const mockPresubmitTransaction = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(1233),\n                    from: '0xworkeraddress',\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    orderHash: '0x01234567',\n                    status: RfqmTransactionSubmissionStatus.Presubmit,\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xpresubmittransactionhash',\n                    type: RfqmTransactionSubmissionType.Trade,\n                });\n\n                const mockTransactionRequest: providers.TransactionRequest = {};\n                const mockTransaction = new RfqmV2TransactionSubmissionEntity({\n                    from: '0xworkeraddress',\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    orderHash: '0x01234567',\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xsignedtransactionhash',\n                    type: RfqmTransactionSubmissionType.Trade,\n                });\n                const mockTransactionReceipt: providers.TransactionReceipt = {\n                    to: '0xexchangeproxyaddress',\n                    from: '0xworkeraddress',\n                    contractAddress: '0xexchangeproxyaddress',\n                    transactionIndex: 0,\n                    gasUsed: EthersBigNumber.from(10000),\n                    logsBloom: '',\n                    blockHash: '0xblockhash',\n                    transactionHash: '0xsignedtransactionhash',\n                    logs: [],\n                    blockNumber: 1,\n                    confirmations: 3,\n                    cumulativeGasUsed: EthersBigNumber.from(1000),\n                    effectiveGasPrice: EthersBigNumber.from(1000),\n                    byzantium: true,\n                    type: 2,\n                    status: 1,\n                };\n                const mockNonce = 0;\n\n                const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n                when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                    new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n                );\n                const mockDbUtils = mock(RfqmDbUtils);\n                when(\n                    mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                        '0x01234567',\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([mockPresubmitTransaction]);\n                const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n                when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                    updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n                });\n                const writeV2RfqmTransactionSubmissionToDbCalledArgs: RfqmTransactionSubmissionEntity[] = [];\n                when(mockDbUtils.writeV2RfqmTransactionSubmissionToDbAsync(anything())).thenCall(\n                    async (transactionArg) => {\n                        writeV2RfqmTransactionSubmissionToDbCalledArgs.push(_.cloneDeep(transactionArg));\n                        return _.cloneDeep(mockTransaction);\n                    },\n                );\n                when(\n                    mockDbUtils.findV2TransactionSubmissionByTransactionHashAsync('0xsignedtransactionhash'),\n                ).thenResolve(_.cloneDeep(mockTransaction));\n                const updateRfqmTransactionSubmissionsCalledArgs: RfqmV2TransactionSubmissionEntity[][] = [];\n                when(mockDbUtils.updateRfqmTransactionSubmissionsAsync(anything())).thenCall(async (tranactionArg) => {\n                    updateRfqmTransactionSubmissionsCalledArgs.push(_.cloneDeep(tranactionArg));\n                });\n                const mockBlockchainUtils = mock(RfqBlockchainUtils);\n                // This mock response indicates that the presubmit transaction can't be found\n                // on chain or in the mempool\n                when(mockBlockchainUtils.getTransactionAsync('0xpresubmittransactionhash')).thenResolve(null);\n                when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n                when(mockBlockchainUtils.estimateGasForAsync(anything())).thenResolve(100);\n                when(\n                    mockBlockchainUtils.transformTxDataToTransactionRequest(anything(), anything(), anything()),\n                ).thenReturn(mockTransactionRequest);\n                when(mockBlockchainUtils.signTransactionAsync(anything())).thenResolve({\n                    signedTransaction: 'signedTransaction',\n                    transactionHash: '0xsignedtransactionhash',\n                });\n                when(mockBlockchainUtils.getExchangeProxyAddress()).thenReturn('0xexchangeproxyaddress');\n                when(mockBlockchainUtils.submitSignedTransactionAsync(anything())).thenResolve(\n                    '0xsignedtransactionhash',\n                );\n                when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xsignedtransactionhash']))).thenResolve([\n                    mockTransactionReceipt,\n                ]);\n                when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n                when(mockBlockchainUtils.getDecodedRfqOrderFillEventLogFromLogs(anything())).thenReturn({\n                    event: '',\n                    logIndex: null,\n                    transactionIndex: null,\n                    transactionHash: '',\n                    blockHash: '',\n                    address: '',\n                    data: '',\n                    blockNumber: 0,\n                    topics: [],\n                    args: {\n                        maker: '',\n                        makerToken: '',\n                        makerTokenFilledAmount: new BigNumber(1234),\n                        orderHash: '',\n                        pool: '',\n                        taker: '',\n                        takerToken: '',\n                        takerTokenFilledAmount: new BigNumber(5),\n                    },\n                });\n                const rfqmService = buildWorkerServiceForUnitTest({\n                    dbUtils: instance(mockDbUtils),\n                    gasStationAttendant: instance(gasStationAttendantMock),\n                    rfqBlockchainUtils: instance(mockBlockchainUtils),\n                });\n                const callback = async (\n                    newSubmissionContextStatus: SubmissionContextStatus,\n                    oldSubmissionContextStatus?: SubmissionContextStatus,\n                ): Promise<void> => {\n                    if (newSubmissionContextStatus !== oldSubmissionContextStatus) {\n                        const newJobStatus =\n                            SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\n                        job.status = newJobStatus;\n                        await mockDbUtils.updateRfqmJobAsync(job);\n                    }\n                };\n\n                try {\n                    await rfqmService.submitToChainAsync({\n                        kind: job.kind,\n                        to: '0xexchangeproxyaddress',\n                        from: '0xworkeraddress',\n                        calldata: '0xcalldata',\n                        expiry: job.expiry,\n                        identifier: job.orderHash,\n                        submissionType: RfqmTransactionSubmissionType.Trade,\n                        onSubmissionContextStatusUpdate: callback,\n                    });\n                    expect.fail();\n                } catch (e) {\n                    expect(e.message).to.contain('Exceed expiry');\n                    // eth_createAccessList should not be called when not enabled\n                    verify(mockBlockchainUtils.createAccessListForAsync(anything())).never();\n                    expect(job.status).to.equal(RfqmJobStatus.FailedExpired);\n                }\n            });\n\n            it('recovers a PRESUBMIT transaction which actually submitted', async () => {\n                const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n                const job = new RfqmV2JobEntity({\n                    affiliateAddress: '',\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(nowS + 600),\n                    fee: {\n                        amount: '0',\n                        token: '',\n                        type: 'fixed',\n                    },\n                    integratorId: '',\n                    lastLookResult: true,\n                    makerUri: 'http://foo.bar',\n                    order: {\n                        order: {\n                            chainId: '1',\n                            expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                                new BigNumber(nowS + 600),\n                                new BigNumber(1),\n                                new BigNumber(1),\n                            ).toString(),\n                            maker: '0xmaker',\n                            makerAmount: '1000000',\n                            makerToken: '0xmakertoken',\n                            taker: '0xtaker',\n                            takerAmount: '10000000',\n                            takerToken: '0xtakertoken',\n                            txOrigin: '',\n                            verifyingContract: '',\n                        },\n                        type: RfqmOrderTypes.Otc,\n                    },\n                    orderHash: '0x01234567',\n                    status: RfqmJobStatus.PendingLastLookAccepted,\n                    updatedAt: new Date(),\n                    workerAddress: '',\n                });\n\n                const mockPresubmitTransaction = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(1233),\n                    from: '0xworkeraddress',\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    orderHash: '0x01234567',\n                    status: RfqmTransactionSubmissionStatus.Presubmit,\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xpresubmittransactionhash',\n                    type: RfqmTransactionSubmissionType.Trade,\n                });\n                const mockTransactionReceipt: providers.TransactionReceipt = {\n                    blockHash: '0xblockhash',\n                    blockNumber: 1,\n                    byzantium: true,\n                    confirmations: 3,\n                    contractAddress: '0xexchangeproxyaddress',\n                    cumulativeGasUsed: EthersBigNumber.from(1000),\n                    effectiveGasPrice: EthersBigNumber.from(1000),\n                    from: '0xworkeraddress',\n                    gasUsed: EthersBigNumber.from(10000),\n                    logs: [],\n                    logsBloom: '',\n                    status: 1,\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xpresubmittransactionhash',\n                    transactionIndex: 0,\n                    type: 2,\n                };\n                const mockTransactionResponse: providers.TransactionResponse = {\n                    chainId: 1,\n                    confirmations: 0,\n                    data: '',\n                    from: '0xworkeraddress',\n                    gasLimit: EthersBigNumber.from(1000000),\n                    hash: '0xpresubmittransactionhash',\n                    nonce: 0,\n                    type: 2,\n                    value: EthersBigNumber.from(0),\n                    wait: (_confirmations: number | undefined) => Promise.resolve(mockTransactionReceipt),\n                };\n                const mockMinedBlock: providers.Block = {\n                    _difficulty: EthersBigNumber.from(2),\n                    difficulty: 2,\n                    extraData: '',\n                    gasLimit: EthersBigNumber.from(1000),\n                    gasUsed: EthersBigNumber.from(1000),\n                    hash: '0xblockhash',\n                    miner: '0xminer',\n                    nonce: '0x000',\n                    number: 21,\n                    parentHash: '0xparentblockhash',\n                    timestamp: 12345,\n                    transactions: ['0xpresubmittransactionhash'],\n                };\n                const mockNonce = 0;\n\n                const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n                when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                    new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n                );\n                const mockDbUtils = mock(RfqmDbUtils);\n                when(\n                    mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                        '0x01234567',\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([mockPresubmitTransaction]);\n                const updateRfqmTransactionSubmissionsCalledArgs: RfqmV2TransactionSubmissionEntity[][] = [];\n                when(mockDbUtils.updateRfqmTransactionSubmissionsAsync(anything())).thenCall(async (tranactionArg) => {\n                    updateRfqmTransactionSubmissionsCalledArgs.push(_.cloneDeep(tranactionArg));\n                });\n                const mockBlockchainUtils = mock(RfqBlockchainUtils);\n                // This mock response indicates that the transaction is present in the mempool\n                when(mockBlockchainUtils.getTransactionAsync('0xpresubmittransactionhash')).thenResolve(\n                    mockTransactionResponse,\n                );\n                when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n                when(mockBlockchainUtils.estimateGasForAsync(anything())).thenReject(\n                    new Error('estimateGasForAsync called during recovery'),\n                );\n                when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xpresubmittransactionhash']))).thenResolve([\n                    mockTransactionReceipt,\n                ]);\n                when(mockBlockchainUtils.getBlockAsync('0xblockhash')).thenResolve(mockMinedBlock);\n                when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n                when(mockBlockchainUtils.getDecodedRfqOrderFillEventLogFromLogs(anything())).thenReturn({\n                    event: '',\n                    logIndex: null,\n                    transactionIndex: null,\n                    transactionHash: '',\n                    blockHash: '',\n                    address: '',\n                    data: '',\n                    blockNumber: 0,\n                    topics: [],\n                    args: {\n                        maker: '',\n                        makerToken: '',\n                        makerTokenFilledAmount: new BigNumber(1234),\n                        orderHash: '',\n                        pool: '',\n                        taker: '',\n                        takerToken: '',\n                        takerTokenFilledAmount: new BigNumber(5),\n                    },\n                });\n                const rfqmService = buildWorkerServiceForUnitTest({\n                    dbUtils: instance(mockDbUtils),\n                    gasStationAttendant: instance(gasStationAttendantMock),\n                    rfqBlockchainUtils: instance(mockBlockchainUtils),\n                });\n                const callback = async (\n                    newSubmissionContextStatus: SubmissionContextStatus,\n                    oldSubmissionContextStatus?: SubmissionContextStatus,\n                ): Promise<void> => {\n                    if (newSubmissionContextStatus !== oldSubmissionContextStatus) {\n                        const newJobStatus =\n                            SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\n                        job.status = newJobStatus;\n                        await mockDbUtils.updateRfqmJobAsync(job);\n                    }\n                };\n\n                await rfqmService.submitToChainAsync({\n                    kind: job.kind,\n                    to: '0xexchangeproxyaddress',\n                    from: '0xworkeraddress',\n                    calldata: '0xcalldata',\n                    expiry: job.expiry,\n                    identifier: job.orderHash,\n                    submissionType: RfqmTransactionSubmissionType.Trade,\n                    onSubmissionContextStatusUpdate: callback,\n                });\n\n                // eth_createAccessList should not be called when not enabled\n                verify(mockBlockchainUtils.createAccessListForAsync(anything())).never();\n                // Logic should first check to see if the transaction was actually sent.\n                // If it was (and it is being mock so in this test) then the logic first\n                // updates the status of the transaction to \"Submitted\"\n                expect(updateRfqmTransactionSubmissionsCalledArgs[0][0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.Submitted,\n                );\n                // The logic then enters the watch loop. On the first check, a transaction\n                // receipt exists for this transaction and it will be marked \"confirmed\"\n                expect(updateRfqmTransactionSubmissionsCalledArgs[1][0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                );\n                expect(job.status).to.equal(RfqmJobStatus.SucceededConfirmed);\n            });\n\n            it('finalizes a job to FAILED_EXPIRED once the expiration window has passed', async () => {\n                const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n                const ninetySecondsAgo = nowS - 100;\n                const job = new RfqmV2JobEntity({\n                    affiliateAddress: '',\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(ninetySecondsAgo),\n                    fee: {\n                        amount: '0',\n                        token: '',\n                        type: 'fixed',\n                    },\n                    integratorId: '',\n                    lastLookResult: true,\n                    makerUri: 'http://foo.bar',\n                    order: {\n                        order: {\n                            chainId: '1',\n                            expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                                new BigNumber(ninetySecondsAgo.toString()),\n                                new BigNumber(1),\n                                new BigNumber(1),\n                            ).toString(),\n                            maker: '0xmaker',\n                            makerAmount: '1000000',\n                            makerToken: '0xmakertoken',\n                            taker: '0xtaker',\n                            takerAmount: '10000000',\n                            takerToken: '0xtakertoken',\n                            txOrigin: '',\n                            verifyingContract: '',\n                        },\n                        type: RfqmOrderTypes.Otc,\n                    },\n                    orderHash: '0x01234567',\n                    status: RfqmJobStatus.PendingSubmitted,\n                    updatedAt: new Date(),\n                    workerAddress: '',\n                });\n\n                const mockTransaction = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(1233),\n                    from: '0xworkeraddress',\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    orderHash: '0x01234567',\n                    status: RfqmTransactionSubmissionStatus.Submitted,\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xpresubmittransactionhash',\n                    type: RfqmTransactionSubmissionType.Trade,\n                });\n\n                const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n                when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                    new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n                );\n                const mockDbUtils = mock(RfqmDbUtils);\n                when(\n                    mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                        '0x01234567',\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([mockTransaction]);\n                const mockBlockchainUtils = mock(RfqBlockchainUtils);\n                when(mockBlockchainUtils.estimateGasForAsync(anything())).thenResolve(100);\n                when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xpresubmittransactionhash']))).thenResolve([]);\n                const rfqmService = buildWorkerServiceForUnitTest({\n                    dbUtils: instance(mockDbUtils),\n                    gasStationAttendant: instance(gasStationAttendantMock),\n                    rfqBlockchainUtils: instance(mockBlockchainUtils),\n                });\n                const callback = async (\n                    newSubmissionContextStatus: SubmissionContextStatus,\n                    oldSubmissionContextStatus?: SubmissionContextStatus,\n                ): Promise<void> => {\n                    if (newSubmissionContextStatus !== oldSubmissionContextStatus) {\n                        const newJobStatus =\n                            SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\n                        job.status = newJobStatus;\n                        await mockDbUtils.updateRfqmJobAsync(job);\n                    }\n                };\n\n                try {\n                    await rfqmService.submitToChainAsync({\n                        kind: job.kind,\n                        to: '0xexchangeproxyaddress',\n                        from: '0xworkeraddress',\n                        calldata: '0xcalldata',\n                        expiry: job.expiry,\n                        identifier: job.orderHash,\n                        submissionType: RfqmTransactionSubmissionType.Trade,\n                        onSubmissionContextStatusUpdate: callback,\n                    });\n                } catch (e) {\n                    expect(e.message).to.contain('Exceed expiry');\n                    // eth_createAccessList should not be called when not enabled\n                    verify(mockBlockchainUtils.createAccessListForAsync(anything())).never();\n                    expect(job.status).to.equal(RfqmJobStatus.FailedExpired);\n                }\n            });\n\n            it('should call createAccessListForAsync and should not affect the overall method when RPC returns properly', async () => {\n                const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n                const job = new RfqmV2JobEntity({\n                    affiliateAddress: '',\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(nowS + 600),\n                    fee: {\n                        amount: '0',\n                        token: '',\n                        type: 'fixed',\n                    },\n                    integratorId: '',\n                    lastLookResult: true,\n                    makerUri: 'http://foo.bar',\n                    order: {\n                        order: {\n                            chainId: '1',\n                            expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                                new BigNumber(nowS + 600),\n                                new BigNumber(1),\n                                new BigNumber(1),\n                            ).toString(),\n                            maker: '0xmaker',\n                            makerAmount: '1000000',\n                            makerToken: '0xmakertoken',\n                            taker: '0xtaker',\n                            takerAmount: '10000000',\n                            takerToken: '0xtakertoken',\n                            txOrigin: '',\n                            verifyingContract: '',\n                        },\n                        type: RfqmOrderTypes.Otc,\n                    },\n                    orderHash: '0x01234567',\n                    status: RfqmJobStatus.PendingLastLookAccepted,\n                    updatedAt: new Date(),\n                    workerAddress: '',\n                });\n\n                const mockTransactionRequest: providers.TransactionRequest = {};\n                const mockTransaction = new RfqmV2TransactionSubmissionEntity({\n                    from: '0xworkeraddress',\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    orderHash: '0x01234567',\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xsignedtransactionhash',\n                    type: RfqmTransactionSubmissionType.Trade,\n                });\n                const mockTransactionReceipt: providers.TransactionReceipt = {\n                    to: '0xexchangeproxyaddress',\n                    from: '0xworkeraddress',\n                    contractAddress: '0xexchangeproxyaddress',\n                    transactionIndex: 0,\n                    gasUsed: EthersBigNumber.from(10000),\n                    logsBloom: '',\n                    blockHash: '0xblockhash',\n                    transactionHash: '0xsignedtransactionhash',\n                    logs: [],\n                    blockNumber: 1,\n                    confirmations: 3,\n                    cumulativeGasUsed: EthersBigNumber.from(1000),\n                    effectiveGasPrice: EthersBigNumber.from(1000),\n                    byzantium: true,\n                    type: 2,\n                    status: 1,\n                };\n                const mockNonce = 0;\n\n                const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n                when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                    new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n                );\n                const mockDbUtils = mock(RfqmDbUtils);\n                when(\n                    mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                        '0x01234567',\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([]);\n                const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n                when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                    updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n                });\n                const writeV2RfqmTransactionSubmissionToDbCalledArgs: RfqmTransactionSubmissionEntity[] = [];\n                when(mockDbUtils.writeV2RfqmTransactionSubmissionToDbAsync(anything())).thenCall(\n                    async (transactionArg) => {\n                        writeV2RfqmTransactionSubmissionToDbCalledArgs.push(_.cloneDeep(transactionArg));\n                        return _.cloneDeep(mockTransaction);\n                    },\n                );\n                when(\n                    mockDbUtils.findV2TransactionSubmissionByTransactionHashAsync('0xsignedtransactionhash'),\n                ).thenResolve(_.cloneDeep(mockTransaction));\n                const updateRfqmTransactionSubmissionsCalledArgs: RfqmTransactionSubmissionEntity[][] = [];\n                when(mockDbUtils.updateRfqmTransactionSubmissionsAsync(anything())).thenCall(async (tranactionArg) => {\n                    updateRfqmTransactionSubmissionsCalledArgs.push(_.cloneDeep(tranactionArg));\n                });\n                const mockBlockchainUtils = mock(RfqBlockchainUtils);\n                when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n                when(mockBlockchainUtils.estimateGasForAsync(anything())).thenResolve(100);\n                when(\n                    mockBlockchainUtils.transformTxDataToTransactionRequest(anything(), anything(), anything()),\n                ).thenReturn(mockTransactionRequest);\n                when(mockBlockchainUtils.signTransactionAsync(anything())).thenResolve({\n                    signedTransaction: 'signedTransaction',\n                    transactionHash: '0xsignedtransactionhash',\n                });\n                when(mockBlockchainUtils.getExchangeProxyAddress()).thenReturn('0xexchangeproxyaddress');\n                when(mockBlockchainUtils.submitSignedTransactionAsync(anything())).thenResolve(\n                    '0xsignedtransactionhash',\n                );\n                when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xsignedtransactionhash']))).thenResolve([\n                    mockTransactionReceipt,\n                ]);\n                when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n                when(mockBlockchainUtils.getDecodedRfqOrderFillEventLogFromLogs(anything())).thenReturn({\n                    event: '',\n                    logIndex: null,\n                    transactionIndex: null,\n                    transactionHash: '',\n                    blockHash: '',\n                    address: '',\n                    data: '',\n                    blockNumber: 0,\n                    topics: [],\n                    args: {\n                        maker: '',\n                        makerToken: '',\n                        makerTokenFilledAmount: new BigNumber(1234),\n                        orderHash: '',\n                        pool: '',\n                        taker: '',\n                        takerToken: '',\n                        takerTokenFilledAmount: new BigNumber(5),\n                    },\n                });\n                when(mockBlockchainUtils.createAccessListForAsync(anything())).thenResolve({\n                    accessList: {\n                        '0x1234': ['0x0'],\n                        '0x12345': ['0x1'],\n                    },\n                    gasEstimate: 1000,\n                });\n                const rfqmService = buildWorkerServiceForUnitTest({\n                    dbUtils: instance(mockDbUtils),\n                    gasStationAttendant: instance(gasStationAttendantMock),\n                    rfqBlockchainUtils: instance(mockBlockchainUtils),\n                    enableAccessList: true,\n                });\n                const callback = async (\n                    newSubmissionContextStatus: SubmissionContextStatus,\n                    oldSubmissionContextStatus?: SubmissionContextStatus,\n                ): Promise<void> => {\n                    if (newSubmissionContextStatus !== oldSubmissionContextStatus) {\n                        const newJobStatus =\n                            SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\n                        job.status = newJobStatus;\n                        await mockDbUtils.updateRfqmJobAsync(job);\n                    }\n                };\n\n                await rfqmService.submitToChainAsync({\n                    kind: job.kind,\n                    to: '0xexchangeproxyaddress',\n                    from: '0xworkeraddress',\n                    calldata: '0xcalldata',\n                    expiry: job.expiry,\n                    identifier: job.orderHash,\n                    submissionType: RfqmTransactionSubmissionType.Trade,\n                    onSubmissionContextStatusUpdate: callback,\n                });\n                verify(mockBlockchainUtils.estimateGasForAsync(anything()));\n                verify(mockBlockchainUtils.createAccessListForAsync(anything())).once();\n                expect(job.status).to.equal(RfqmJobStatus.SucceededConfirmed);\n                expect(writeV2RfqmTransactionSubmissionToDbCalledArgs[0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.Presubmit,\n                );\n                expect(updateRfqmTransactionSubmissionsCalledArgs[0][0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.Submitted,\n                );\n                expect(updateRfqmTransactionSubmissionsCalledArgs[1][0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                );\n            });\n\n            it('should call createAccessListForAsync and should not affect the overall method when RPC errors out', async () => {\n                const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n                const job = new RfqmV2JobEntity({\n                    affiliateAddress: '',\n                    chainId: 1,\n                    createdAt: new Date(),\n                    expiry: new BigNumber(nowS + 600),\n                    fee: {\n                        amount: '0',\n                        token: '',\n                        type: 'fixed',\n                    },\n                    integratorId: '',\n                    lastLookResult: true,\n                    makerUri: 'http://foo.bar',\n                    order: {\n                        order: {\n                            chainId: '1',\n                            expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                                new BigNumber(nowS + 600),\n                                new BigNumber(1),\n                                new BigNumber(1),\n                            ).toString(),\n                            maker: '0xmaker',\n                            makerAmount: '1000000',\n                            makerToken: '0xmakertoken',\n                            taker: '0xtaker',\n                            takerAmount: '10000000',\n                            takerToken: '0xtakertoken',\n                            txOrigin: '',\n                            verifyingContract: '',\n                        },\n                        type: RfqmOrderTypes.Otc,\n                    },\n                    orderHash: '0x01234567',\n                    status: RfqmJobStatus.PendingLastLookAccepted,\n                    updatedAt: new Date(),\n                    workerAddress: '',\n                });\n\n                const mockTransactionRequest: providers.TransactionRequest = {};\n                const mockTransaction = new RfqmV2TransactionSubmissionEntity({\n                    from: '0xworkeraddress',\n                    maxFeePerGas: new BigNumber(100000),\n                    maxPriorityFeePerGas: new BigNumber(100),\n                    nonce: 0,\n                    orderHash: '0x01234567',\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xsignedtransactionhash',\n                    type: RfqmTransactionSubmissionType.Trade,\n                });\n                const mockTransactionReceipt: providers.TransactionReceipt = {\n                    to: '0xto',\n                    from: '0xfrom',\n                    contractAddress: '0xexchangeproxyaddress',\n                    transactionIndex: 0,\n                    gasUsed: EthersBigNumber.from(10000),\n                    logsBloom: '',\n                    blockHash: '0xblockhash',\n                    transactionHash: '0xsignedtransactionhash',\n                    logs: [],\n                    blockNumber: 1,\n                    confirmations: 3,\n                    cumulativeGasUsed: EthersBigNumber.from(1000),\n                    effectiveGasPrice: EthersBigNumber.from(1000),\n                    byzantium: true,\n                    type: 2,\n                    status: 1,\n                };\n                const mockNonce = 0;\n\n                const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n                when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                    new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n                );\n                const mockDbUtils = mock(RfqmDbUtils);\n                when(\n                    mockDbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                        '0x01234567',\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([]);\n                const updateRfqmJobCalledArgs: RfqmJobEntity[] = [];\n                when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                    updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n                });\n                const writeV2RfqmTransactionSubmissionToDbCalledArgs: RfqmTransactionSubmissionEntity[] = [];\n                when(mockDbUtils.writeV2RfqmTransactionSubmissionToDbAsync(anything())).thenCall(\n                    async (transactionArg) => {\n                        writeV2RfqmTransactionSubmissionToDbCalledArgs.push(_.cloneDeep(transactionArg));\n                        return _.cloneDeep(mockTransaction);\n                    },\n                );\n                when(\n                    mockDbUtils.findV2TransactionSubmissionByTransactionHashAsync('0xsignedtransactionhash'),\n                ).thenResolve(_.cloneDeep(mockTransaction));\n                const updateRfqmTransactionSubmissionsCalledArgs: RfqmTransactionSubmissionEntity[][] = [];\n                when(mockDbUtils.updateRfqmTransactionSubmissionsAsync(anything())).thenCall(async (tranactionArg) => {\n                    updateRfqmTransactionSubmissionsCalledArgs.push(_.cloneDeep(tranactionArg));\n                });\n                const mockBlockchainUtils = mock(RfqBlockchainUtils);\n                when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n                when(mockBlockchainUtils.estimateGasForAsync(anything())).thenResolve(100);\n                when(\n                    mockBlockchainUtils.transformTxDataToTransactionRequest(anything(), anything(), anything()),\n                ).thenReturn(mockTransactionRequest);\n                when(mockBlockchainUtils.signTransactionAsync(anything())).thenResolve({\n                    signedTransaction: 'signedTransaction',\n                    transactionHash: '0xsignedtransactionhash',\n                });\n                when(mockBlockchainUtils.getExchangeProxyAddress()).thenReturn('0xexchangeproxyaddress');\n                when(mockBlockchainUtils.submitSignedTransactionAsync(anything())).thenResolve(\n                    '0xsignedtransactionhash',\n                );\n                when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xsignedtransactionhash']))).thenResolve([\n                    mockTransactionReceipt,\n                ]);\n                when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n                when(mockBlockchainUtils.getDecodedRfqOrderFillEventLogFromLogs(anything())).thenReturn({\n                    event: '',\n                    logIndex: null,\n                    transactionIndex: null,\n                    transactionHash: '',\n                    blockHash: '',\n                    address: '',\n                    data: '',\n                    blockNumber: 0,\n                    topics: [],\n                    args: {\n                        maker: '',\n                        makerToken: '',\n                        makerTokenFilledAmount: new BigNumber(1234),\n                        orderHash: '',\n                        pool: '',\n                        taker: '',\n                        takerToken: '',\n                        takerTokenFilledAmount: new BigNumber(5),\n                    },\n                });\n                when(mockBlockchainUtils.createAccessListForAsync(anything())).thenReject(new Error('error'));\n                const rfqmService = buildWorkerServiceForUnitTest({\n                    dbUtils: instance(mockDbUtils),\n                    gasStationAttendant: instance(gasStationAttendantMock),\n                    rfqBlockchainUtils: instance(mockBlockchainUtils),\n                    enableAccessList: true,\n                });\n                const callback = async (\n                    newSubmissionContextStatus: SubmissionContextStatus,\n                    oldSubmissionContextStatus?: SubmissionContextStatus,\n                ): Promise<void> => {\n                    if (newSubmissionContextStatus !== oldSubmissionContextStatus) {\n                        const newJobStatus =\n                            SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\n                        job.status = newJobStatus;\n                        await mockDbUtils.updateRfqmJobAsync(job);\n                    }\n                };\n\n                await rfqmService.submitToChainAsync({\n                    kind: job.kind,\n                    to: '0xexchangeproxyaddress',\n                    from: '0xworkeraddress',\n                    calldata: '0xcalldata',\n                    expiry: job.expiry,\n                    identifier: job.orderHash,\n                    submissionType: RfqmTransactionSubmissionType.Trade,\n                    onSubmissionContextStatusUpdate: callback,\n                });\n                verify(mockBlockchainUtils.estimateGasForAsync(anything()));\n                verify(mockBlockchainUtils.createAccessListForAsync(anything())).once();\n                expect(job.status).to.equal(RfqmJobStatus.SucceededConfirmed);\n                expect(writeV2RfqmTransactionSubmissionToDbCalledArgs[0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.Presubmit,\n                );\n                expect(updateRfqmTransactionSubmissionsCalledArgs[0][0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.Submitted,\n                );\n                expect(updateRfqmTransactionSubmissionsCalledArgs[1][0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                );\n            });\n        });\n\n        // Not all tests from test block 'kind is `rfqm_v2_job`' is included here as most of the tests are similiar.\n        // The tests below specifically test if corresponding methods are called for job kind `meta_transaction_job`.\n        describe('kind is `meta_transaction_job`', () => {\n            it('submits a transaction successfully when there is no previous transaction', async () => {\n                const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n                const jobId = 'jobId';\n                const transactionSubmissionId = 'submissionId';\n                const job = createMeaTrsanctionJobEntity(\n                    {\n                        chainId: 1,\n                        createdAt: new Date(),\n                        expiry: new BigNumber(nowS + 600),\n                        fee: {\n                            amount: new BigNumber(0),\n                            token: '',\n                            type: 'fixed',\n                        },\n                        inputToken: '0xinputToken',\n                        inputTokenAmount: new BigNumber(10),\n                        integratorId: '0xintegrator',\n                        metaTransaction: MOCK_META_TRANSACTION,\n                        metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                        minOutputTokenAmount: new BigNumber(10),\n                        outputToken: '0xoutputToken',\n                        takerAddress: '0xtakerAddress',\n                        takerSignature: {\n                            signatureType: SignatureType.EthSign,\n                            v: 27,\n                            r: '0x01',\n                            s: '0x02',\n                        },\n                        status: RfqmJobStatus.PendingLastLookAccepted,\n                        workerAddress: '0xworkeraddress',\n                    },\n                    jobId,\n                );\n\n                const mockTransactionRequest: providers.TransactionRequest = {};\n                const mockTransaction = createMetaTransactionSubmissionEntity(\n                    {\n                        from: '0xworkeraddress',\n                        metaTransactionJobId: jobId,\n                        maxFeePerGas: new BigNumber(100000),\n                        maxPriorityFeePerGas: new BigNumber(100),\n                        nonce: 0,\n                        to: '0xexchangeproxyaddress',\n                        transactionHash: '0xsignedtransactionhash',\n                        type: RfqmTransactionSubmissionType.Trade,\n                    },\n                    transactionSubmissionId,\n                );\n                const mockTransactionReceipt: providers.TransactionReceipt = {\n                    to: '0xto',\n                    from: '0xfrom',\n                    contractAddress: '0xexchangeproxyaddress',\n                    transactionIndex: 0,\n                    gasUsed: EthersBigNumber.from(10000),\n                    logsBloom: '',\n                    blockHash: '0xblockhash',\n                    transactionHash: '0xsignedtransactionhash',\n                    logs: [],\n                    blockNumber: 1,\n                    confirmations: 3,\n                    cumulativeGasUsed: EthersBigNumber.from(1000),\n                    effectiveGasPrice: EthersBigNumber.from(1000),\n                    byzantium: true,\n                    type: 2,\n                    status: 1,\n                };\n                const mockNonce = 0;\n\n                const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n                when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                    new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n                );\n                const mockDbUtils = mock(RfqmDbUtils);\n                when(\n                    mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId, RfqmTransactionSubmissionType.Trade),\n                ).thenResolve([]);\n                const updateRfqmJobCalledArgs: MetaTransactionJobEntity[] = [];\n                when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                    updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n                });\n                const writeMetaTransactionSubmissionAsyncCalledArgs: MetaTransactionSubmissionEntity[] = [];\n                when(mockDbUtils.writeMetaTransactionSubmissionAsync(anything())).thenCall(async (transactionArg) => {\n                    writeMetaTransactionSubmissionAsyncCalledArgs.push(_.cloneDeep(transactionArg));\n                    return _.cloneDeep(mockTransaction);\n                });\n                when(\n                    mockDbUtils.findMetaTransactionSubmissionsByTransactionHashAsync(\n                        '0xsignedtransactionhash',\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([_.cloneDeep(mockTransaction)]);\n                const updateRfqmTransactionSubmissionsCalledArgs: MetaTransactionSubmissionEntity[][] = [];\n                when(mockDbUtils.updateRfqmTransactionSubmissionsAsync(anything())).thenCall(async (tranactionArg) => {\n                    updateRfqmTransactionSubmissionsCalledArgs.push(_.cloneDeep(tranactionArg));\n                });\n                const mockBlockchainUtils = mock(RfqBlockchainUtils);\n                when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n                when(mockBlockchainUtils.estimateGasForAsync(anything())).thenResolve(100);\n                when(\n                    mockBlockchainUtils.transformTxDataToTransactionRequest(anything(), anything(), anything()),\n                ).thenReturn(mockTransactionRequest);\n                when(mockBlockchainUtils.signTransactionAsync(anything())).thenResolve({\n                    signedTransaction: 'signedTransaction',\n                    transactionHash: '0xsignedtransactionhash',\n                });\n                when(mockBlockchainUtils.getExchangeProxyAddress()).thenReturn('0xexchangeproxyaddress');\n                when(mockBlockchainUtils.submitSignedTransactionAsync(anything())).thenResolve(\n                    '0xsignedtransactionhash',\n                );\n                when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xsignedtransactionhash']))).thenResolve([\n                    mockTransactionReceipt,\n                ]);\n                when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n                const rfqmService = buildWorkerServiceForUnitTest({\n                    dbUtils: instance(mockDbUtils),\n                    gasStationAttendant: instance(gasStationAttendantMock),\n                    rfqBlockchainUtils: instance(mockBlockchainUtils),\n                });\n\n                const callback = async (\n                    newSubmissionContextStatus: SubmissionContextStatus,\n                    oldSubmissionContextStatus?: SubmissionContextStatus,\n                ): Promise<void> => {\n                    if (newSubmissionContextStatus !== oldSubmissionContextStatus) {\n                        const newJobStatus =\n                            SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\n                        job.status = newJobStatus;\n                        await mockDbUtils.updateRfqmJobAsync(job);\n                    }\n                };\n                await rfqmService.submitToChainAsync({\n                    kind: job.kind,\n                    to: '0xexchangeproxyaddress',\n                    from: '0xworkeraddress',\n                    calldata: '0xcalldata',\n                    expiry: job.expiry,\n                    identifier: job.id,\n                    submissionType: RfqmTransactionSubmissionType.Trade,\n                    onSubmissionContextStatusUpdate: callback,\n                });\n                verify(mockBlockchainUtils.estimateGasForAsync(anything()));\n                // eth_createAccessList should not be called when not enabled\n                verify(mockBlockchainUtils.createAccessListForAsync(anything())).never();\n                expect(job.status).to.equal(RfqmJobStatus.SucceededConfirmed);\n                expect(writeMetaTransactionSubmissionAsyncCalledArgs[0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.Presubmit,\n                );\n                expect(updateRfqmTransactionSubmissionsCalledArgs[0][0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.Submitted,\n                );\n                expect(updateRfqmTransactionSubmissionsCalledArgs[1][0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                );\n            });\n\n            it('recovers a PRESUBMIT transaction which actually submitted', async () => {\n                const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n                const jobId = 'jobId';\n                const transactionSubmissionId = 'submissionId';\n                const job = createMeaTrsanctionJobEntity(\n                    {\n                        chainId: 1,\n                        createdAt: new Date(),\n                        expiry: new BigNumber(nowS + 600),\n                        fee: {\n                            amount: new BigNumber(0),\n                            token: '',\n                            type: 'fixed',\n                        },\n                        inputToken: '0xinputToken',\n                        inputTokenAmount: new BigNumber(10),\n                        integratorId: '0xintegrator',\n                        metaTransaction: MOCK_META_TRANSACTION,\n                        metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                        minOutputTokenAmount: new BigNumber(10),\n                        outputToken: '0xoutputToken',\n                        takerAddress: '0xtakerAddress',\n                        takerSignature: {\n                            signatureType: SignatureType.EthSign,\n                            v: 27,\n                            r: '0x01',\n                            s: '0x02',\n                        },\n                        status: RfqmJobStatus.PendingLastLookAccepted,\n                        workerAddress: '0xworkeraddress',\n                    },\n                    jobId,\n                );\n\n                const mockPresubmitTransaction = createMetaTransactionSubmissionEntity(\n                    {\n                        from: '0xworkeraddress',\n                        metaTransactionJobId: jobId,\n                        maxFeePerGas: new BigNumber(100000),\n                        maxPriorityFeePerGas: new BigNumber(100),\n                        nonce: 0,\n                        status: RfqmTransactionSubmissionStatus.Presubmit,\n                        to: '0xexchangeproxyaddress',\n                        transactionHash: '0xpresubmittransactionhash',\n                        type: RfqmTransactionSubmissionType.Trade,\n                    },\n                    transactionSubmissionId,\n                );\n                const mockTransactionReceipt: providers.TransactionReceipt = {\n                    blockHash: '0xblockhash',\n                    blockNumber: 1,\n                    byzantium: true,\n                    confirmations: 3,\n                    contractAddress: '0xexchangeproxyaddress',\n                    cumulativeGasUsed: EthersBigNumber.from(1000),\n                    effectiveGasPrice: EthersBigNumber.from(1000),\n                    from: '0xworkeraddress',\n                    gasUsed: EthersBigNumber.from(10000),\n                    logs: [],\n                    logsBloom: '',\n                    status: 1,\n                    to: '0xexchangeproxyaddress',\n                    transactionHash: '0xpresubmittransactionhash',\n                    transactionIndex: 0,\n                    type: 2,\n                };\n                const mockTransactionResponse: providers.TransactionResponse = {\n                    chainId: 1,\n                    confirmations: 0,\n                    data: '',\n                    from: '0xworkeraddress',\n                    gasLimit: EthersBigNumber.from(1000000),\n                    hash: '0xpresubmittransactionhash',\n                    nonce: 0,\n                    type: 2,\n                    value: EthersBigNumber.from(0),\n                    wait: (_confirmations: number | undefined) => Promise.resolve(mockTransactionReceipt),\n                };\n                const mockMinedBlock: providers.Block = {\n                    _difficulty: EthersBigNumber.from(2),\n                    difficulty: 2,\n                    extraData: '',\n                    gasLimit: EthersBigNumber.from(1000),\n                    gasUsed: EthersBigNumber.from(1000),\n                    hash: '0xblockhash',\n                    miner: '0xminer',\n                    nonce: '0x000',\n                    number: 21,\n                    parentHash: '0xparentblockhash',\n                    timestamp: 12345,\n                    transactions: ['0xpresubmittransactionhash'],\n                };\n                const mockNonce = 0;\n\n                const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n                when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                    new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n                );\n                const mockDbUtils = mock(RfqmDbUtils);\n                when(\n                    mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId, RfqmTransactionSubmissionType.Trade),\n                ).thenResolve([mockPresubmitTransaction]);\n                const updateRfqmTransactionSubmissionsCalledArgs: MetaTransactionSubmissionEntity[][] = [];\n                when(mockDbUtils.updateRfqmTransactionSubmissionsAsync(anything())).thenCall(async (tranactionArg) => {\n                    updateRfqmTransactionSubmissionsCalledArgs.push(_.cloneDeep(tranactionArg));\n                });\n                const mockBlockchainUtils = mock(RfqBlockchainUtils);\n                // This mock response indicates that the transaction is present in the mempool\n                when(mockBlockchainUtils.getTransactionAsync('0xpresubmittransactionhash')).thenResolve(\n                    mockTransactionResponse,\n                );\n                when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n                when(mockBlockchainUtils.estimateGasForAsync(anything())).thenReject(\n                    new Error('estimateGasForAsync called during recovery'),\n                );\n                when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xpresubmittransactionhash']))).thenResolve([\n                    mockTransactionReceipt,\n                ]);\n                when(mockBlockchainUtils.getBlockAsync('0xblockhash')).thenResolve(mockMinedBlock);\n                when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n                const rfqmService = buildWorkerServiceForUnitTest({\n                    dbUtils: instance(mockDbUtils),\n                    gasStationAttendant: instance(gasStationAttendantMock),\n                    rfqBlockchainUtils: instance(mockBlockchainUtils),\n                });\n                const callback = async (\n                    newSubmissionContextStatus: SubmissionContextStatus,\n                    oldSubmissionContextStatus?: SubmissionContextStatus,\n                ): Promise<void> => {\n                    if (newSubmissionContextStatus !== oldSubmissionContextStatus) {\n                        const newJobStatus =\n                            SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\n                        job.status = newJobStatus;\n                        await mockDbUtils.updateRfqmJobAsync(job);\n                    }\n                };\n\n                await rfqmService.submitToChainAsync({\n                    kind: job.kind,\n                    to: '0xexchangeproxyaddress',\n                    from: '0xworkeraddress',\n                    calldata: '0xcalldata',\n                    expiry: job.expiry,\n                    identifier: job.id,\n                    submissionType: RfqmTransactionSubmissionType.Trade,\n                    onSubmissionContextStatusUpdate: callback,\n                });\n\n                // eth_createAccessList should not be called when not enabled\n                verify(mockBlockchainUtils.createAccessListForAsync(anything())).never();\n                // Logic should first check to see if the transaction was actually sent.\n                // If it was (and it is being mock so in this test) then the logic first\n                // updates the status of the transaction to \"Submitted\"\n                expect(updateRfqmTransactionSubmissionsCalledArgs[0][0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.Submitted,\n                );\n                // The logic then enters the watch loop. On the first check, a transaction\n                // receipt exists for this transaction and it will be marked \"confirmed\"\n                expect(updateRfqmTransactionSubmissionsCalledArgs[1][0].status).to.equal(\n                    RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                );\n                expect(job.status).to.equal(RfqmJobStatus.SucceededConfirmed);\n            });\n\n            it('throws exception if there are more than 1 transaction submissions with the same transaction hash', async () => {\n                const nowS = Math.round(new Date().getTime() / ONE_SECOND_MS);\n                const jobId = 'jobId';\n                const transactionSubmissionId = 'submissionId';\n                const job = createMeaTrsanctionJobEntity(\n                    {\n                        chainId: 1,\n                        createdAt: new Date(),\n                        expiry: new BigNumber(nowS + 600),\n                        fee: {\n                            amount: new BigNumber(0),\n                            token: '',\n                            type: 'fixed',\n                        },\n                        inputToken: '0xinputToken',\n                        inputTokenAmount: new BigNumber(10),\n                        integratorId: '0xintegrator',\n                        metaTransaction: MOCK_META_TRANSACTION,\n                        metaTransactionHash: MOCK_META_TRANSACTION.getHash(),\n                        minOutputTokenAmount: new BigNumber(10),\n                        outputToken: '0xoutputToken',\n                        takerAddress: '0xtakerAddress',\n                        takerSignature: {\n                            signatureType: SignatureType.EthSign,\n                            v: 27,\n                            r: '0x01',\n                            s: '0x02',\n                        },\n                        status: RfqmJobStatus.PendingLastLookAccepted,\n                        workerAddress: '0xworkeraddress',\n                    },\n                    jobId,\n                );\n\n                const mockTransactionRequest: providers.TransactionRequest = {};\n                const mockTransaction = createMetaTransactionSubmissionEntity(\n                    {\n                        from: '0xworkeraddress',\n                        metaTransactionJobId: jobId,\n                        maxFeePerGas: new BigNumber(100000),\n                        maxPriorityFeePerGas: new BigNumber(100),\n                        nonce: 0,\n                        to: '0xexchangeproxyaddress',\n                        transactionHash: '0xsignedtransactionhash',\n                        type: RfqmTransactionSubmissionType.Trade,\n                    },\n                    transactionSubmissionId,\n                );\n                const mockTransactionReceipt: providers.TransactionReceipt = {\n                    to: '0xto',\n                    from: '0xfrom',\n                    contractAddress: '0xexchangeproxyaddress',\n                    transactionIndex: 0,\n                    gasUsed: EthersBigNumber.from(10000),\n                    logsBloom: '',\n                    blockHash: '0xblockhash',\n                    transactionHash: '0xsignedtransactionhash',\n                    logs: [],\n                    blockNumber: 1,\n                    confirmations: 3,\n                    cumulativeGasUsed: EthersBigNumber.from(1000),\n                    effectiveGasPrice: EthersBigNumber.from(1000),\n                    byzantium: true,\n                    type: 2,\n                    status: 1,\n                };\n                const mockNonce = 0;\n\n                const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n                when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(\n                    new BigNumber(10).shiftedBy(GWEI_DECIMALS),\n                );\n                const mockDbUtils = mock(RfqmDbUtils);\n                when(\n                    mockDbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId, RfqmTransactionSubmissionType.Trade),\n                ).thenResolve([]);\n                const updateRfqmJobCalledArgs: MetaTransactionJobEntity[] = [];\n                when(mockDbUtils.updateRfqmJobAsync(anything())).thenCall(async (jobArg) => {\n                    updateRfqmJobCalledArgs.push(_.cloneDeep(jobArg));\n                });\n                const writeMetaTransactionSubmissionAsyncCalledArgs: MetaTransactionSubmissionEntity[] = [];\n                when(mockDbUtils.writeMetaTransactionSubmissionAsync(anything())).thenCall(async (transactionArg) => {\n                    writeMetaTransactionSubmissionAsyncCalledArgs.push(_.cloneDeep(transactionArg));\n                    return _.cloneDeep(mockTransaction);\n                });\n                when(\n                    mockDbUtils.findMetaTransactionSubmissionsByTransactionHashAsync(\n                        '0xsignedtransactionhash',\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([_.cloneDeep(mockTransaction), _.cloneDeep(mockTransaction)]);\n                const updateRfqmTransactionSubmissionsCalledArgs: MetaTransactionSubmissionEntity[][] = [];\n                when(mockDbUtils.updateRfqmTransactionSubmissionsAsync(anything())).thenCall(async (tranactionArg) => {\n                    updateRfqmTransactionSubmissionsCalledArgs.push(_.cloneDeep(tranactionArg));\n                });\n                const mockBlockchainUtils = mock(RfqBlockchainUtils);\n                when(mockBlockchainUtils.getNonceAsync('0xworkeraddress')).thenResolve(mockNonce);\n                when(mockBlockchainUtils.estimateGasForAsync(anything())).thenResolve(100);\n                when(\n                    mockBlockchainUtils.transformTxDataToTransactionRequest(anything(), anything(), anything()),\n                ).thenReturn(mockTransactionRequest);\n                when(mockBlockchainUtils.signTransactionAsync(anything())).thenResolve({\n                    signedTransaction: 'signedTransaction',\n                    transactionHash: '0xsignedtransactionhash',\n                });\n                when(mockBlockchainUtils.getExchangeProxyAddress()).thenReturn('0xexchangeproxyaddress');\n                when(mockBlockchainUtils.submitSignedTransactionAsync(anything())).thenResolve(\n                    '0xsignedtransactionhash',\n                );\n                when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0xsignedtransactionhash']))).thenResolve([\n                    mockTransactionReceipt,\n                ]);\n                when(mockBlockchainUtils.getCurrentBlockAsync()).thenResolve(4);\n                const rfqmService = buildWorkerServiceForUnitTest({\n                    dbUtils: instance(mockDbUtils),\n                    gasStationAttendant: instance(gasStationAttendantMock),\n                    rfqBlockchainUtils: instance(mockBlockchainUtils),\n                });\n\n                const callback = async (\n                    newSubmissionContextStatus: SubmissionContextStatus,\n                    oldSubmissionContextStatus?: SubmissionContextStatus,\n                ): Promise<void> => {\n                    if (newSubmissionContextStatus !== oldSubmissionContextStatus) {\n                        const newJobStatus =\n                            SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\n                        job.status = newJobStatus;\n                        await mockDbUtils.updateRfqmJobAsync(job);\n                    }\n                };\n\n                try {\n                    await rfqmService.submitToChainAsync({\n                        kind: job.kind,\n                        to: '0xexchangeproxyaddress',\n                        from: '0xworkeraddress',\n                        calldata: '0xcalldata',\n                        expiry: job.expiry,\n                        identifier: job.id,\n                        submissionType: RfqmTransactionSubmissionType.Trade,\n                        onSubmissionContextStatusUpdate: callback,\n                    });\n                    expect.fail();\n                } catch (e) {\n                    expect(e.message).to.contain('Transaction hash have been submitted not exactly once');\n                }\n            });\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/WorkerService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantEthereum.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/SubmissionContext.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType2.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/services/rfqm_service_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\n// tslint:disable:no-empty\n// tslint:disable:max-file-line-count\n\nimport { TooManyRequestsError } from '@0x/api-utils';\nimport { getContractAddressesForChainOrThrow } from '@0x/contract-addresses';\nimport {\n    eip712SignHashWithKey,\n    ethSignHashWithKey,\n    MetaTransaction,\n    OtcOrder,\n    SignatureType,\n} from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { expect } from 'chai';\nimport { constants } from 'ethers';\nimport { Producer } from 'sqs-producer';\nimport { anything, capture, instance, mock, spy, verify, when } from 'ts-mockito';\n\nimport { Integrator } from '../../src/config';\nimport {\n    DEFAULT_MIN_EXPIRY_DURATION_MS,\n    ETH_DECIMALS,\n    ONE_MINUTE_MS,\n    ONE_SECOND_MS,\n    ZERO,\n} from '../../src/core/constants';\nimport { RfqmV2JobEntity, RfqmV2QuoteEntity, RfqmV2TransactionSubmissionEntity } from '../../src/entities';\nimport {\n    RfqmJobStatus,\n    RfqmOrderTypes,\n    RfqmTransactionSubmissionStatus,\n    RfqmTransactionSubmissionType,\n} from '../../src/entities/types';\nimport { FeeService } from '../../src/services/fee_service';\nimport { RfqmService } from '../../src/services/rfqm_service';\nimport { RfqMakerBalanceCacheService } from '../../src/services/rfq_maker_balance_cache_service';\nimport {\n    ApprovalResponse,\n    OtcOrderSubmitRfqmSignedQuoteParams,\n    SubmitRfqmSignedQuoteWithApprovalParams,\n} from '../../src/services/types';\nimport {\n    ExecuteMetaTransactionEip712Context,\n    FeeModelVersion,\n    GaslessApprovalTypes,\n    GaslessTypes,\n    IndicativeQuote,\n    PermitEip712Context,\n} from '../../src/core/types';\nimport { CacheClient } from '../../src/utils/cache_client';\nimport { QuoteServerClient } from '../../src/utils/quote_server_client';\nimport { otcOrderToStoredOtcOrder, RfqmDbUtils } from '../../src/utils/rfqm_db_utils';\nimport { HealthCheckStatus } from '../../src/utils/rfqm_health_check';\nimport { RfqBlockchainUtils } from '../../src/utils/rfq_blockchain_utils';\nimport { RfqMakerManager } from '../../src/utils/rfq_maker_manager';\nimport { TokenMetadataManager } from '../../src/utils/TokenMetadataManager';\nimport { MOCK_EXECUTE_META_TRANSACTION_APPROVAL } from '../constants';\n\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n// eslint-disable-next-line @typescript-eslint/no-loss-of-precision\nconst NEVER_EXPIRES = new BigNumber(9999999999999999);\nconst MOCK_WORKER_REGISTRY_ADDRESS = '0x1023331a469c6391730ff1E2749422CE8873EC38';\nconst MOCK_TOKEN = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48';\nconst MOCK_GAS_PRICE = new BigNumber(100000000000);\nconst MOCK_MM_URI = 'https://mm-address';\nconst WORKER_FULL_BALANCE_WEI = new BigNumber(1).shiftedBy(ETH_DECIMALS);\nconst MOCK_INTEGRATOR: Integrator = {\n    apiKeys: ['an-integrator-id'],\n    integratorId: 'an-integrator-id',\n    allowedChainIds: [1337],\n    label: 'Test',\n    plp: false,\n    rfqm: true,\n    rfqt: true,\n};\n\nconst buildRfqmServiceForUnitTest = (\n    overrides: {\n        chainId?: number;\n        feeService?: FeeService;\n        feeModelVersion?: FeeModelVersion;\n        rfqBlockchainUtils?: RfqBlockchainUtils;\n        dbUtils?: RfqmDbUtils;\n        producer?: Producer;\n        quoteServerClient?: QuoteServerClient;\n        cacheClient?: CacheClient;\n        rfqMakerBalanceCacheService?: RfqMakerBalanceCacheService;\n        rfqMakerManager?: RfqMakerManager;\n        tokenMetadataManager?: TokenMetadataManager;\n    } = {},\n): RfqmService => {\n    const contractAddresses = getContractAddressesForChainOrThrow(1);\n    const feeServiceMock = mock(FeeService);\n    when(feeServiceMock.getGasPriceEstimationAsync()).thenResolve(MOCK_GAS_PRICE);\n    when(feeServiceMock.calculateFeeAsync(anything(), anything())).thenResolve({\n        feeWithDetails: {\n            token: '0xToken',\n            amount: new BigNumber(300),\n            type: 'fixed',\n            details: {\n                feeModelVersion: 1,\n                kind: 'default',\n                gasFeeAmount: new BigNumber(100),\n                gasPrice: MOCK_GAS_PRICE,\n                zeroExFeeAmount: new BigNumber(200),\n                tradeSizeBps: 4,\n                feeTokenBaseUnitPriceUsd: new BigNumber(30),\n                takerTokenBaseUnitPriceUsd: null,\n                makerTokenBaseUnitPriceUsd: new BigNumber(20),\n            },\n            breakdown: {\n                gas: {\n                    amount: new BigNumber(100),\n                    details: {\n                        gasPrice: MOCK_GAS_PRICE,\n                        estimatedGas: new BigNumber(1),\n                    },\n                },\n                zeroEx: {\n                    amount: new BigNumber(200),\n                    details: {\n                        kind: 'volume',\n                        tradeSizeBps: 4,\n                    },\n                },\n            },\n            conversionRates: {\n                nativeTokenBaseUnitPriceUsd: new BigNumber(30),\n                feeTokenBaseUnitPriceUsd: new BigNumber(30),\n                takerTokenBaseUnitPriceUsd: null,\n                makerTokenBaseUnitPriceUsd: new BigNumber(20),\n            },\n        },\n    });\n    const feeServiceInstance = instance(feeServiceMock);\n\n    const rfqBlockchainUtilsMock = mock(RfqBlockchainUtils);\n    when(rfqBlockchainUtilsMock.getAccountBalanceAsync(MOCK_WORKER_REGISTRY_ADDRESS)).thenResolve(\n        WORKER_FULL_BALANCE_WEI,\n    );\n    when(rfqBlockchainUtilsMock.getAllowanceAsync(anything(), anything(), anything())).thenResolve(\n        new BigNumber(constants.MaxUint256.toString()),\n        new BigNumber(0),\n        new BigNumber(0),\n    );\n    when(rfqBlockchainUtilsMock.getGaslessApprovalAsync(anything(), anything(), anything())).thenResolve(\n        null,\n        MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n    );\n    const dbUtilsMock = mock(RfqmDbUtils);\n    const sqsMock = mock(Producer);\n    when(sqsMock.queueSize()).thenResolve(0);\n    const quoteServerClientMock = mock(QuoteServerClient);\n    const cacheClientMock = mock(CacheClient);\n    when(cacheClientMock.getMakersInCooldownForPairAsync(anything(), anything(), anything())).thenResolve([]);\n    const rfqMakerBalanceCacheService = mock(RfqMakerBalanceCacheService);\n    const rfqMakerManagerMock = mock(RfqMakerManager);\n\n    const tokenMetadataManagerMock = mock(TokenMetadataManager);\n    when(tokenMetadataManagerMock.getTokenDecimalsAsync(anything())).thenResolve(18);\n    const tokenMetadataManager = instance(tokenMetadataManagerMock);\n\n    return new RfqmService(\n        overrides.chainId || 1337,\n        overrides.feeService || feeServiceInstance,\n        overrides.feeModelVersion || 0,\n        contractAddresses,\n        MOCK_WORKER_REGISTRY_ADDRESS,\n        overrides.rfqBlockchainUtils || instance(rfqBlockchainUtilsMock),\n        overrides.dbUtils || dbUtilsMock,\n        overrides.producer || sqsMock,\n        overrides.quoteServerClient || quoteServerClientMock,\n        DEFAULT_MIN_EXPIRY_DURATION_MS,\n        overrides.cacheClient || instance(cacheClientMock),\n        overrides.rfqMakerBalanceCacheService || rfqMakerBalanceCacheService,\n        overrides.rfqMakerManager || rfqMakerManagerMock,\n        overrides.tokenMetadataManager || tokenMetadataManager,\n    );\n};\n\ndescribe('RfqmService HTTP Logic', () => {\n    describe('submitTakerSignedOtcOrderAsync', () => {\n        it('should fail if there is already a pending trade for the taker and taker token', async () => {\n            const expiry = new BigNumber(Date.now() + 1_000_000).dividedBy(ONE_SECOND_MS).decimalPlaces(0);\n            const otcOrder = new OtcOrder({\n                txOrigin: '0x0000000000000000000000000000000000000000',\n                taker: '0x1111111111111111111111111111111111111111',\n                maker: '0x2222222222222222222222222222222222222222',\n                makerToken: '0x3333333333333333333333333333333333333333',\n                takerToken: '0x4444444444444444444444444444444444444444',\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(expiry, ZERO, expiry),\n                chainId: 1337,\n                verifyingContract: '0x0000000000000000000000000000000000000000',\n            });\n            const existingJob = new RfqmV2JobEntity({\n                chainId: 1337,\n                expiry,\n                makerUri: '',\n                orderHash: '0x00',\n                fee: {\n                    token: '0xToken',\n                    amount: '100',\n                    type: 'fixed',\n                },\n                order: otcOrderToStoredOtcOrder(otcOrder),\n            });\n\n            const quote = new RfqmV2QuoteEntity({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                makerUri: 'http://foo.bar',\n                order: {\n                    order: existingJob.order.order,\n                    type: RfqmOrderTypes.Otc,\n                },\n                orderHash: '',\n                isUnwrap: false,\n            });\n\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.findV2JobsWithStatusesAsync(anything())).thenResolve([existingJob]);\n            when(dbUtilsMock.findV2QuoteByOrderHashAsync(otcOrder.getHash())).thenResolve(quote);\n            const params: OtcOrderSubmitRfqmSignedQuoteParams = {\n                type: GaslessTypes.OtcOrder,\n                order: otcOrder,\n                signature: {\n                    r: '',\n                    s: '',\n                    signatureType: SignatureType.EthSign,\n                    v: 1,\n                },\n            };\n            const metatransactionMock = mock(MetaTransaction);\n            when(metatransactionMock.getHash()).thenReturn('0xmetatransactionhash');\n            when(metatransactionMock.expirationTimeSeconds).thenReturn(NEVER_EXPIRES);\n\n            const service = buildRfqmServiceForUnitTest({\n                chainId: 1,\n                dbUtils: instance(dbUtilsMock),\n                feeModelVersion: 0,\n            });\n\n            expect(service.submitTakerSignedOtcOrderAsync(params)).to.be.rejectedWith(\n                TooManyRequestsError,\n                'a pending trade for this taker and takertoken already exists',\n            ); // tslint:disable-line no-unused-expression\n        });\n\n        it('should allow two trades by the same taker with different taker tokens', async () => {\n            const takerPrivateKey = '0xe13ae9fa0166b501a2ab50e7b6fbb65819add7376da9b4fbb3bf3ae48cd9dcd3';\n            const takerAddress = '0x4e2145eDC29f27E126154B9c716Df70c429C291B';\n            const expiry = new BigNumber(Date.now() + 1_000_000).dividedBy(ONE_SECOND_MS).decimalPlaces(0);\n            const existingOtcOrder = new OtcOrder({\n                txOrigin: '0x0000000000000000000000000000000000000000',\n                taker: takerAddress,\n                maker: '0x2222222222222222222222222222222222222222',\n                makerToken: '0x3333333333333333333333333333333333333333',\n                takerToken: '0x4444444444444444444444444444444444444444',\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(expiry, ZERO, expiry),\n                chainId: 1337,\n                verifyingContract: '0x0000000000000000000000000000000000000000',\n            });\n            const newOtcOrder = new OtcOrder({\n                txOrigin: '0x0000000000000000000000000000000000000000',\n                taker: takerAddress,\n                maker: '0x2222222222222222222222222222222222222222',\n                makerToken: '0x3333333333333333333333333333333333333333',\n                takerToken: '0x9999999999999999999999999999999999999999',\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(expiry, ZERO, expiry),\n                chainId: 1337,\n                verifyingContract: '0x0000000000000000000000000000000000000000',\n            });\n            const existingJob = new RfqmV2JobEntity({\n                chainId: 1337,\n                expiry,\n                makerUri: '',\n                orderHash: '0x00',\n                fee: {\n                    token: '0xToken',\n                    amount: '100',\n                    type: 'fixed',\n                },\n                order: otcOrderToStoredOtcOrder(existingOtcOrder),\n            });\n\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.findV2JobsWithStatusesAsync(anything())).thenResolve([existingJob]);\n            when(dbUtilsMock.findV2QuoteByOrderHashAsync(newOtcOrder.getHash())).thenResolve({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                makerUri: 'http://foo.bar',\n                order: otcOrderToStoredOtcOrder(newOtcOrder),\n                orderHash: '',\n                isUnwrap: false,\n                takerSpecifiedSide: null,\n            });\n            const metatransactionMock = mock(MetaTransaction);\n            when(metatransactionMock.getHash()).thenReturn('0xmetatransactionhash');\n            when(metatransactionMock.expirationTimeSeconds).thenReturn(NEVER_EXPIRES);\n            const blockchainUtilsMock = mock(RfqBlockchainUtils);\n            when(blockchainUtilsMock.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(10000),\n            ]);\n            const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n            when(rfqMakerBalanceCacheServiceMock.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(10000),\n            ]);\n\n            const service = buildRfqmServiceForUnitTest({\n                chainId: 1,\n                dbUtils: instance(dbUtilsMock),\n                rfqBlockchainUtils: instance(blockchainUtilsMock),\n                rfqMakerBalanceCacheService: instance(rfqMakerBalanceCacheServiceMock),\n                feeModelVersion: 0,\n            });\n\n            const submitParams: OtcOrderSubmitRfqmSignedQuoteParams = {\n                type: GaslessTypes.OtcOrder,\n                order: newOtcOrder,\n                signature: ethSignHashWithKey(newOtcOrder.getHash(), takerPrivateKey),\n            };\n            const result = await service.submitTakerSignedOtcOrderAsync(submitParams);\n            expect(result.type).to.equal('otc');\n        });\n    });\n\n    describe('submitTakerSignedOtcOrderWithApprovalAsync', () => {\n        it('should fail if approval params generate an invalid calldata', async () => {\n            const takerAddress = '0x4e2145eDC29f27E126154B9c716Df70c429C291B';\n            const expiry = new BigNumber(Date.now() + 1_000_000).dividedBy(ONE_SECOND_MS).decimalPlaces(0);\n            const otcOrder = new OtcOrder({\n                txOrigin: '0x0000000000000000000000000000000000000000',\n                taker: '0x1111111111111111111111111111111111111111',\n                maker: '0x2222222222222222222222222222222222222222',\n                makerToken: '0x3333333333333333333333333333333333333333',\n                takerToken: '0x4444444444444444444444444444444444444444',\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(expiry, ZERO, expiry),\n                chainId: 1,\n                verifyingContract: '0x0000000000000000000000000000000000000000',\n            });\n            const eip712Context: ExecuteMetaTransactionEip712Context = {\n                types: {\n                    EIP712Domain: [\n                        { name: 'name', type: 'string' },\n                        { name: 'version', type: 'string' },\n                        { name: 'verifyingContract', type: 'address' },\n                        { name: 'salt', type: 'bytes32' },\n                    ],\n                    MetaTransaction: [\n                        { name: 'nonce', type: 'uint256' },\n                        { name: 'from', type: 'address' },\n                        { name: 'functionSignature', type: 'bytes' },\n                    ],\n                },\n                primaryType: 'MetaTransaction',\n                domain: {},\n                message: {\n                    nonce: expiry.toNumber(),\n                    from: takerAddress,\n                    functionSignature: '',\n                },\n            };\n            const submitParams: SubmitRfqmSignedQuoteWithApprovalParams<ExecuteMetaTransactionEip712Context> = {\n                approval: {\n                    type: GaslessApprovalTypes.ExecuteMetaTransaction,\n                    eip712: eip712Context,\n                    signature: {\n                        r: '',\n                        s: '',\n                        v: 28,\n                        signatureType: SignatureType.EIP712,\n                    },\n                },\n                trade: {\n                    type: GaslessTypes.OtcOrder,\n                    order: otcOrder,\n                    signature: {\n                        r: '',\n                        s: '',\n                        v: 28,\n                        signatureType: SignatureType.EthSign,\n                    },\n                },\n                kind: GaslessTypes.OtcOrder,\n            };\n            const blockchainUtilsMock = mock(RfqBlockchainUtils);\n            when(blockchainUtilsMock.generateApprovalCalldataAsync(anything(), anything(), anything())).thenResolve(\n                '0xinvalidcalldata',\n            );\n            when(blockchainUtilsMock.estimateGasForAsync(anything())).thenReject();\n            const service = buildRfqmServiceForUnitTest({\n                chainId: 1,\n                feeModelVersion: 0,\n                rfqBlockchainUtils: instance(blockchainUtilsMock),\n            });\n            try {\n                await service.submitTakerSignedOtcOrderWithApprovalAsync(submitParams);\n                expect.fail('should fail eth call approval validation');\n            } catch (e) {\n                expect(e.message).to.contain('Eth call approval validation failed');\n                verify(blockchainUtilsMock.generateApprovalCalldataAsync(anything(), anything(), anything())).once();\n                verify(blockchainUtilsMock.estimateGasForAsync(anything())).thrice();\n            }\n        });\n        it('should proceed with trade submission if approval is empty', async () => {\n            const takerPrivateKey = '0xe13ae9fa0166b501a2ab50e7b6fbb65819add7376da9b4fbb3bf3ae48cd9dcd3';\n            const takerAddress = '0x4e2145eDC29f27E126154B9c716Df70c429C291B';\n            const expiry = new BigNumber(Date.now() + 1_000_000).dividedBy(ONE_SECOND_MS).decimalPlaces(0);\n            const otcOrder = new OtcOrder({\n                txOrigin: '0x0000000000000000000000000000000000000000',\n                taker: takerAddress,\n                maker: '0x2222222222222222222222222222222222222222',\n                makerToken: '0x3333333333333333333333333333333333333333',\n                takerToken: '0x4444444444444444444444444444444444444444',\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(expiry, ZERO, expiry),\n                chainId: 1,\n                verifyingContract: '0x0000000000000000000000000000000000000000',\n            });\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.findV2JobsWithStatusesAsync(anything())).thenResolve([]);\n            when(dbUtilsMock.findV2QuoteByOrderHashAsync(otcOrder.getHash())).thenResolve({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                makerUri: 'http://foo.bar',\n                order: otcOrderToStoredOtcOrder(otcOrder),\n                orderHash: '',\n                isUnwrap: false,\n                takerSpecifiedSide: null,\n            });\n            const blockchainUtilsMock = mock(RfqBlockchainUtils);\n            when(blockchainUtilsMock.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(10000),\n            ]);\n            const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n            when(rfqMakerBalanceCacheServiceMock.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(10000),\n            ]);\n            const service = buildRfqmServiceForUnitTest({\n                chainId: 1,\n                feeModelVersion: 0,\n                dbUtils: instance(dbUtilsMock),\n                rfqBlockchainUtils: instance(blockchainUtilsMock),\n                rfqMakerBalanceCacheService: instance(rfqMakerBalanceCacheServiceMock),\n            });\n            const submitParams: SubmitRfqmSignedQuoteWithApprovalParams<\n                ExecuteMetaTransactionEip712Context | PermitEip712Context\n            > = {\n                kind: GaslessTypes.OtcOrder,\n                trade: {\n                    type: GaslessTypes.OtcOrder,\n                    order: otcOrder,\n                    signature: ethSignHashWithKey(otcOrder.getHash(), takerPrivateKey),\n                },\n            };\n            const result = await service.submitTakerSignedOtcOrderWithApprovalAsync(submitParams);\n            expect(result.type).to.equal('otc');\n            verify(dbUtilsMock.writeV2JobAsync(anything())).once();\n        });\n        it('should save job with executeMetaTransaction params to DB', async () => {\n            const takerPrivateKey = '0xe13ae9fa0166b501a2ab50e7b6fbb65819add7376da9b4fbb3bf3ae48cd9dcd3';\n            const takerAddress = '0x4e2145eDC29f27E126154B9c716Df70c429C291B';\n            const expiry = new BigNumber(Date.now() + 1_000_000).dividedBy(ONE_SECOND_MS).decimalPlaces(0);\n            const otcOrder = new OtcOrder({\n                txOrigin: '0x0000000000000000000000000000000000000000',\n                taker: takerAddress,\n                maker: '0x2222222222222222222222222222222222222222',\n                makerToken: '0x3333333333333333333333333333333333333333',\n                takerToken: '0x4444444444444444444444444444444444444444',\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(expiry, ZERO, expiry),\n                chainId: 1,\n                verifyingContract: '0x0000000000000000000000000000000000000000',\n            });\n            const eip712Context: ExecuteMetaTransactionEip712Context = {\n                types: {\n                    EIP712Domain: [\n                        { name: 'name', type: 'string' },\n                        { name: 'version', type: 'string' },\n                        { name: 'verifyingContract', type: 'address' },\n                        { name: 'salt', type: 'bytes32' },\n                    ],\n                    MetaTransaction: [\n                        { name: 'nonce', type: 'uint256' },\n                        { name: 'from', type: 'address' },\n                        { name: 'functionSignature', type: 'bytes' },\n                    ],\n                },\n                primaryType: 'MetaTransaction',\n                domain: {},\n                message: {\n                    from: takerAddress,\n                    functionSignature: '',\n                    nonce: expiry.toNumber(),\n                },\n            };\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.findV2JobsWithStatusesAsync(anything())).thenResolve([]);\n            when(dbUtilsMock.findV2QuoteByOrderHashAsync(otcOrder.getHash())).thenResolve({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                makerUri: 'http://foo.bar',\n                order: otcOrderToStoredOtcOrder(otcOrder),\n                orderHash: '',\n                isUnwrap: false,\n                takerSpecifiedSide: null,\n            });\n            const blockchainUtilsMock = mock(RfqBlockchainUtils);\n            when(blockchainUtilsMock.getTokenBalancesAsync(anything())).thenResolve([new BigNumber(10000)]);\n            when(blockchainUtilsMock.generateApprovalCalldataAsync(anything(), anything(), anything())).thenResolve(\n                '0xvalidcalldata',\n            );\n            when(blockchainUtilsMock.simulateTransactionAsync(anything(), anything())).thenResolve();\n            const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n            when(rfqMakerBalanceCacheServiceMock.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(10000),\n            ]);\n            const service = buildRfqmServiceForUnitTest({\n                chainId: 1,\n                feeModelVersion: 0,\n                dbUtils: instance(dbUtilsMock),\n                rfqBlockchainUtils: instance(blockchainUtilsMock),\n                rfqMakerBalanceCacheService: instance(rfqMakerBalanceCacheServiceMock),\n            });\n            const submitParams: SubmitRfqmSignedQuoteWithApprovalParams<ExecuteMetaTransactionEip712Context> = {\n                trade: {\n                    type: GaslessTypes.OtcOrder,\n                    order: otcOrder,\n                    signature: ethSignHashWithKey(otcOrder.getHash(), takerPrivateKey),\n                },\n                approval: {\n                    type: GaslessApprovalTypes.ExecuteMetaTransaction,\n                    eip712: eip712Context,\n                    signature: eip712SignHashWithKey(otcOrder.getHash(), takerPrivateKey),\n                },\n                kind: GaslessTypes.OtcOrder,\n            };\n            const result = await service.submitTakerSignedOtcOrderWithApprovalAsync(submitParams);\n            expect(result.type).to.equal('otc');\n            verify(blockchainUtilsMock.getMinOfBalancesAndAllowancesAsync(anything())).never();\n            verify(dbUtilsMock.writeV2JobAsync(anything())).once();\n        });\n        it('should save job with permit params to DB', async () => {\n            const takerPrivateKey = '0xe13ae9fa0166b501a2ab50e7b6fbb65819add7376da9b4fbb3bf3ae48cd9dcd3';\n            const takerAddress = '0x4e2145eDC29f27E126154B9c716Df70c429C291B';\n            const expiry = new BigNumber(Date.now() + 1_000_000).dividedBy(ONE_SECOND_MS).decimalPlaces(0);\n            const otcOrder = new OtcOrder({\n                txOrigin: '0x0000000000000000000000000000000000000000',\n                taker: takerAddress,\n                maker: '0x2222222222222222222222222222222222222222',\n                makerToken: '0x3333333333333333333333333333333333333333',\n                takerToken: '0x4444444444444444444444444444444444444444',\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(expiry, ZERO, expiry),\n                chainId: 1,\n                verifyingContract: '0x0000000000000000000000000000000000000000',\n            });\n            const eip712Context: PermitEip712Context = {\n                types: {\n                    EIP712Domain: [\n                        { name: 'name', type: 'string' },\n                        { name: 'version', type: 'string' },\n                        { name: 'verifyingContract', type: 'address' },\n                        { name: 'salt', type: 'bytes32' },\n                    ],\n                    Permit: [\n                        { name: 'owner', type: 'address' },\n                        { name: 'spender', type: 'address' },\n                        { name: 'value', type: 'uint256' },\n                        { name: 'nonce', type: 'uint256' },\n                        { name: 'deadline', type: 'uint256' },\n                    ],\n                },\n                primaryType: 'Permit',\n                domain: {},\n                message: {\n                    deadline: '12345',\n                    owner: takerAddress,\n                    spender: '0x0000000000000000000000000000000000000000',\n                    value: '0xffffffffffffffffffffffffffffffffffffffff',\n                    nonce: expiry.toNumber(),\n                },\n            };\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.findV2JobsWithStatusesAsync(anything())).thenResolve([]);\n            when(dbUtilsMock.findV2QuoteByOrderHashAsync(otcOrder.getHash())).thenResolve({\n                affiliateAddress: '',\n                chainId: 1,\n                createdAt: new Date(),\n                fee: {\n                    amount: '0',\n                    token: '',\n                    type: 'fixed',\n                },\n                integratorId: '',\n                makerUri: 'http://foo.bar',\n                order: otcOrderToStoredOtcOrder(otcOrder),\n                orderHash: '',\n                isUnwrap: false,\n                takerSpecifiedSide: null,\n            });\n            const blockchainUtilsMock = mock(RfqBlockchainUtils);\n            when(blockchainUtilsMock.getTokenBalancesAsync(anything())).thenResolve([new BigNumber(10000)]);\n            when(blockchainUtilsMock.generateApprovalCalldataAsync(anything(), anything(), anything())).thenResolve(\n                '0xvalidcalldata',\n            );\n            when(blockchainUtilsMock.estimateGasForAsync(anything())).thenResolve(10);\n            const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n            when(rfqMakerBalanceCacheServiceMock.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(10000),\n            ]);\n            const service = buildRfqmServiceForUnitTest({\n                chainId: 1,\n                feeModelVersion: 0,\n                dbUtils: instance(dbUtilsMock),\n                rfqBlockchainUtils: instance(blockchainUtilsMock),\n                rfqMakerBalanceCacheService: instance(rfqMakerBalanceCacheServiceMock),\n            });\n            const submitParams: SubmitRfqmSignedQuoteWithApprovalParams<PermitEip712Context> = {\n                trade: {\n                    type: GaslessTypes.OtcOrder,\n                    order: otcOrder,\n                    signature: ethSignHashWithKey(otcOrder.getHash(), takerPrivateKey),\n                },\n                approval: {\n                    type: GaslessApprovalTypes.Permit,\n                    eip712: eip712Context,\n                    signature: eip712SignHashWithKey(otcOrder.getHash(), takerPrivateKey),\n                },\n                kind: GaslessTypes.OtcOrder,\n            };\n            const result = await service.submitTakerSignedOtcOrderWithApprovalAsync(submitParams);\n            expect(result.type).to.equal('otc');\n            verify(blockchainUtilsMock.getMinOfBalancesAndAllowancesAsync(anything())).never();\n            verify(dbUtilsMock.writeV2JobAsync(anything())).once();\n        });\n    });\n\n    describe('fetchIndicativeQuoteAsync', () => {\n        describe('sells', () => {\n            it('should fetch indicative quote', async () => {\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n\n                const quote: IndicativeQuote = {\n                    maker: '0xmaker',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(101),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(100),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    quote,\n                ]);\n\n                const service = buildRfqmServiceForUnitTest({\n                    quoteServerClient: instance(quoteServerClientMock),\n                    feeModelVersion: 0,\n                });\n\n                const res = await service.fetchIndicativeQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    sellAmount: new BigNumber(100),\n                });\n\n                if (res === null) {\n                    expect.fail('res is null, but not expected to be null');\n                    return;\n                }\n                expect(res.sellAmount.toNumber()).to.be.at.least(100);\n                expect(res.price.toNumber()).to.equal(1.01);\n            });\n\n            it('should round price to six decimal places', async () => {\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const quote: IndicativeQuote = {\n                    maker: '0xmaker',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(111),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(333),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    quote,\n                ]);\n\n                const service = buildRfqmServiceForUnitTest({\n                    quoteServerClient: instance(quoteServerClientMock),\n                    feeModelVersion: 0,\n                });\n\n                const res = await service.fetchIndicativeQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    sellAmount: new BigNumber(333),\n                });\n\n                if (res === null) {\n                    expect.fail('res is null, but not expected to be null');\n                    return;\n                }\n\n                expect(res.price.toNumber()).to.equal(0.3333333);\n            });\n\n            it('should only return an indicative quote that is 100% filled when selling', async () => {\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const quote1: IndicativeQuote = {\n                    maker: '0xmaker',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(55),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(50),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n                const quote2: IndicativeQuote = {\n                    maker: '0xmaker',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(105),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(100),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    quote1,\n                    quote2,\n                ]);\n                const service = buildRfqmServiceForUnitTest({ quoteServerClient: instance(quoteServerClientMock) });\n\n                const res = await service.fetchIndicativeQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    sellAmount: new BigNumber(100),\n                });\n\n                if (res === null) {\n                    expect.fail('res is null, but not expected to be null');\n                    return;\n                }\n                expect(res.sellAmount.toNumber()).to.equal(100);\n                expect(res.price.toNumber()).to.equal(1.05);\n            });\n\n            it('should return null if no quotes are valid', async () => {\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const partialFillQuote: IndicativeQuote = {\n                    maker: '0xmaker',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(55),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(50),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    partialFillQuote,\n                ]);\n                const service = buildRfqmServiceForUnitTest({ quoteServerClient: instance(quoteServerClientMock) });\n\n                const res = await service.fetchIndicativeQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    sellAmount: new BigNumber(100),\n                });\n                expect(res).to.equal(null);\n            });\n\n            // TODO: we may want to reintroduce this test very soon. However, if not addressed by June 2022, remove\n            it.skip('should return an indicative quote that can fill more than 100%', async () => {\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const worseQuote: IndicativeQuote = {\n                    maker: '0xmaker',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(101),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(100),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n                const betterQuote: IndicativeQuote = {\n                    maker: '0xmaker2',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(222),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(200),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    worseQuote,\n                    betterQuote,\n                ]);\n                const service = buildRfqmServiceForUnitTest({ quoteServerClient: instance(quoteServerClientMock) });\n\n                const res = await service.fetchIndicativeQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    sellAmount: new BigNumber(100),\n                });\n\n                if (res === null) {\n                    expect.fail('res is null, but not expected to be null');\n                    return;\n                }\n                expect(res.sellAmount.toNumber()).to.equal(200);\n                expect(res.price.toNumber()).to.equal(1.11);\n            });\n\n            it('should ignore quotes that are for the wrong pair', async () => {\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const worseQuote: IndicativeQuote = {\n                    maker: '0xmaker',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(101),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(100),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n                const betterQuote: IndicativeQuote = {\n                    maker: '0xmaker2',\n                    makerToken: '0x1111111111111111111111111111111111111111',\n                    makerAmount: new BigNumber(111),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(100),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    worseQuote,\n                    betterQuote,\n                ]);\n                const service = buildRfqmServiceForUnitTest({ quoteServerClient: instance(quoteServerClientMock) });\n\n                const res = await service.fetchIndicativeQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    sellAmount: new BigNumber(100),\n                });\n\n                if (res === null) {\n                    expect.fail('res is null, but not expected to be null');\n                    return;\n                }\n                expect(res.sellAmount.toNumber()).to.equal(100);\n                expect(res.price.toNumber()).to.equal(1.01); // Worse pricing wins because better pricing is for wrong pair\n            });\n\n            it('should ignore quotes that expire within 3 minutes', async () => {\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const inOneMinute = (Date.now() + ONE_MINUTE_MS) / ONE_SECOND_MS;\n                const expiresSoon: IndicativeQuote = {\n                    maker: '0xmaker',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(111),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(100),\n                    expiry: new BigNumber(inOneMinute),\n                    makerUri: MOCK_MM_URI,\n                };\n                const neverExpires: IndicativeQuote = {\n                    maker: '0xmaker2',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(101),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(100),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    expiresSoon,\n                    neverExpires,\n                ]);\n                const service = buildRfqmServiceForUnitTest({ quoteServerClient: instance(quoteServerClientMock) });\n\n                const res = await service.fetchIndicativeQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    sellAmount: new BigNumber(100),\n                });\n\n                if (res === null) {\n                    expect.fail('res is null, but not expected to be null');\n                    return;\n                }\n                expect(res.sellAmount.toNumber()).to.equal(100);\n                expect(res.price.toNumber()).to.equal(1.01); // Worse pricing wins because better pricing expires too soon\n            });\n        });\n\n        describe('buys', () => {\n            it('should fetch indicative quote when buying', async () => {\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const quote: IndicativeQuote = {\n                    maker: '0xmaker',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(100),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(80),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    quote,\n                ]);\n                const service = buildRfqmServiceForUnitTest({ quoteServerClient: instance(quoteServerClientMock) });\n\n                const res = await service.fetchIndicativeQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    buyAmount: new BigNumber(100),\n                });\n\n                if (res === null) {\n                    expect.fail('res is null, but not expected to be null');\n                    return;\n                }\n                expect(res.buyAmount.toNumber()).to.be.at.least(100);\n                expect(res.price.toNumber()).to.equal(0.8);\n            });\n\n            it('should only return an indicative quote that is 100% filled when buying', async () => {\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const overFillQuoteGoodPricing: IndicativeQuote = {\n                    maker: '0xmaker',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(160),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(80),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n                const partialFillQuoteGoodPricing: IndicativeQuote = {\n                    maker: '0xmaker2',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(80),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(40),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n                const fullQuote: IndicativeQuote = {\n                    maker: '0xmaker3',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(100),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(80),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    overFillQuoteGoodPricing,\n                    partialFillQuoteGoodPricing,\n                    fullQuote,\n                ]);\n                const service = buildRfqmServiceForUnitTest({ quoteServerClient: instance(quoteServerClientMock) });\n\n                const res = await service.fetchIndicativeQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    buyAmount: new BigNumber(100),\n                });\n\n                if (res === null) {\n                    expect.fail('res is null, but not expected to be null');\n                    return;\n                }\n                expect(res.buyAmount.toNumber()).to.equal(100);\n                expect(res.price.toNumber()).to.equal(0.8);\n            });\n        });\n    });\n\n    describe('fetchFirmQuoteAsync', () => {\n        const takerAddress = '0xf003A9418DE2620f935181259C0Fa1595E871234';\n\n        it('should use an affiliate address provided in the quote request even if one is present in configuration', async () => {\n            const sellAmount = new BigNumber(100);\n            const contractAddresses = getContractAddressesForChainOrThrow(1);\n            const quote: IndicativeQuote = {\n                maker: '0x64B92f5d9E5b5f20603de8498385c3a3d3048E22',\n                makerToken: contractAddresses.zrxToken,\n                makerAmount: new BigNumber(101),\n                takerToken: contractAddresses.etherToken,\n                takerAmount: new BigNumber(100),\n                expiry: NEVER_EXPIRES,\n                makerUri: MOCK_MM_URI,\n            };\n\n            const cacheClientMock = mock(CacheClient);\n            when(cacheClientMock.getNextOtcOrderBucketAsync(1337)).thenResolve(420);\n            when(cacheClientMock.getMakersInCooldownForPairAsync(anything(), anything(), anything())).thenResolve([]);\n\n            // Mock out the dbUtils\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.writeV2QuoteAsync(anything())).thenResolve();\n            const dbUtils = instance(dbUtilsMock);\n\n            const quoteServerClientMock = mock(QuoteServerClient);\n            when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([quote]);\n            const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n            when(rfqMakerBalanceCacheServiceMock.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(150),\n            ]);\n\n            const service = buildRfqmServiceForUnitTest({\n                quoteServerClient: instance(quoteServerClientMock),\n                dbUtils,\n                cacheClient: instance(cacheClientMock),\n                rfqMakerBalanceCacheService: instance(rfqMakerBalanceCacheServiceMock),\n            });\n\n            await service.fetchFirmQuoteAsync({\n                affiliateAddress: '0xaffiliateAddress',\n                buyToken: contractAddresses.zrxToken,\n                buyTokenDecimals: 18,\n                checkApproval: false,\n                integrator: { ...MOCK_INTEGRATOR, affiliateAddress: '0xaffiliateAddressNotThisOne' },\n                sellAmount,\n                sellToken: contractAddresses.etherToken,\n                sellTokenDecimals: 18,\n                takerAddress,\n            });\n\n            const writeV2QuoteArgs = capture(dbUtilsMock.writeV2QuoteAsync).last();\n            expect(writeV2QuoteArgs[0]['affiliateAddress']).to.equal('0xaffiliateAddress');\n        });\n\n        it('should use a configured affiliate address when none is provide in the quote request', async () => {\n            const sellAmount = new BigNumber(100);\n            const contractAddresses = getContractAddressesForChainOrThrow(1);\n            const quote: IndicativeQuote = {\n                maker: '0x64B92f5d9E5b5f20603de8498385c3a3d3048E22',\n                makerToken: contractAddresses.zrxToken,\n                makerAmount: new BigNumber(101),\n                takerToken: contractAddresses.etherToken,\n                takerAmount: new BigNumber(100),\n                expiry: NEVER_EXPIRES,\n                makerUri: MOCK_MM_URI,\n            };\n\n            const cacheClientMock = mock(CacheClient);\n            when(cacheClientMock.getNextOtcOrderBucketAsync(1337)).thenResolve(420);\n            when(cacheClientMock.getMakersInCooldownForPairAsync(anything(), anything(), anything())).thenResolve([]);\n\n            // Mock out the dbUtils\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.writeV2QuoteAsync(anything())).thenResolve();\n            const dbUtils = instance(dbUtilsMock);\n\n            const quoteServerClientMock = mock(QuoteServerClient);\n            when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([quote]);\n            const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n            when(rfqMakerBalanceCacheServiceMock.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                new BigNumber(150),\n            ]);\n\n            const service = buildRfqmServiceForUnitTest({\n                quoteServerClient: instance(quoteServerClientMock),\n                dbUtils,\n                cacheClient: instance(cacheClientMock),\n                rfqMakerBalanceCacheService: instance(rfqMakerBalanceCacheServiceMock),\n            });\n\n            await service.fetchFirmQuoteAsync({\n                buyToken: contractAddresses.zrxToken,\n                buyTokenDecimals: 18,\n                checkApproval: false,\n                integrator: { ...MOCK_INTEGRATOR, affiliateAddress: '0xaffiliateAddress' },\n                sellAmount,\n                sellToken: contractAddresses.etherToken,\n                sellTokenDecimals: 18,\n                takerAddress,\n            });\n\n            const writeV2QuoteArgs = capture(dbUtilsMock.writeV2QuoteAsync).last();\n            expect(writeV2QuoteArgs[0]['affiliateAddress']).to.equal('0xaffiliateAddress');\n        });\n\n        describe('sells', () => {\n            it('should fetch a firm quote', async () => {\n                const sellAmount = new BigNumber(100);\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const quote: IndicativeQuote = {\n                    maker: '0x64B92f5d9E5b5f20603de8498385c3a3d3048E22',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(101),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(100),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n\n                const cacheClientMock = mock(CacheClient);\n                when(cacheClientMock.getNextOtcOrderBucketAsync(1337)).thenResolve(420);\n                when(cacheClientMock.getMakersInCooldownForPairAsync(anything(), anything(), anything())).thenResolve(\n                    [],\n                );\n\n                // Mock out the dbUtils\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.writeV2QuoteAsync(anything())).thenResolve();\n                const dbUtils = instance(dbUtilsMock);\n\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    quote,\n                ]);\n                const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n                when(rfqMakerBalanceCacheServiceMock.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                    new BigNumber(150),\n                ]);\n\n                const service = buildRfqmServiceForUnitTest({\n                    quoteServerClient: instance(quoteServerClientMock),\n                    dbUtils,\n                    cacheClient: instance(cacheClientMock),\n                    rfqMakerBalanceCacheService: instance(rfqMakerBalanceCacheServiceMock),\n                });\n\n                const { quote: res } = await service.fetchFirmQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    takerAddress,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    sellAmount,\n                    checkApproval: false,\n                });\n\n                expect(res).to.exist; // tslint:disable-line: no-unused-expression\n                expect(res?.type).to.equal(GaslessTypes.OtcOrder);\n\n                expect(res?.sellAmount).to.equal(sellAmount);\n                expect(res?.price.toNumber()).to.equal(1.01);\n                expect(res?.orderHash).to.match(/^0x[0-9a-fA-F]+/);\n            });\n\n            // TODO: we may want to reintroduce this test very soon. However, if not addressed by June 2022, remove\n            it.skip('should scale a firm quote if MM returns too much', async () => {\n                const sellAmount = new BigNumber(100);\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const quote: IndicativeQuote = {\n                    maker: '0x64B92f5d9E5b5f20603de8498385c3a3d3048E22',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(202),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(200),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n\n                const cacheClientMock = mock(CacheClient);\n                when(cacheClientMock.getNextOtcOrderBucketAsync(1337)).thenResolve(420);\n                when(cacheClientMock.getMakersInCooldownForPairAsync(anything(), anything(), anything())).thenResolve(\n                    [],\n                );\n\n                // Mock out the dbUtils\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.writeV2QuoteAsync(anything())).thenResolve();\n                const dbUtils = instance(dbUtilsMock);\n\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    quote,\n                ]);\n                const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n                when(rfqMakerBalanceCacheServiceMock.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                    new BigNumber(150),\n                ]);\n\n                const service = buildRfqmServiceForUnitTest({\n                    quoteServerClient: instance(quoteServerClientMock),\n                    dbUtils,\n                    cacheClient: instance(cacheClientMock),\n                    rfqMakerBalanceCacheService: instance(rfqMakerBalanceCacheServiceMock),\n                });\n\n                const { quote: res } = await service.fetchFirmQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    takerAddress,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    sellAmount,\n                    checkApproval: false,\n                });\n\n                expect(res).to.exist; // tslint:disable-line: no-unused-expression\n                expect(res?.type).to.equal(GaslessTypes.OtcOrder);\n                expect(res?.sellAmount).to.equal(sellAmount);\n                expect(res?.buyAmount.toNumber()).to.equal(101); // result is scaled\n                expect(res?.price.toNumber()).to.equal(1.01);\n                expect(res?.orderHash).to.match(/^0x[0-9a-fA-F]+/);\n            });\n\n            it('should round price to six decimal places', async () => {\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const quote: IndicativeQuote = {\n                    maker: '0x64B92f5d9E5b5f20603de8498385c3a3d3048E22',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(111),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(333),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n\n                const cacheClientMock = mock(CacheClient);\n                when(cacheClientMock.getNextOtcOrderBucketAsync(1337)).thenResolve(420);\n                when(cacheClientMock.getMakersInCooldownForPairAsync(anything(), anything(), anything())).thenResolve(\n                    [],\n                );\n\n                // Mock out the dbUtils\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.writeV2QuoteAsync(anything())).thenResolve();\n                const dbUtils = instance(dbUtilsMock);\n\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    quote,\n                ]);\n                const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n                when(rfqMakerBalanceCacheServiceMock.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                    new BigNumber(150),\n                ]);\n\n                const service = buildRfqmServiceForUnitTest({\n                    quoteServerClient: instance(quoteServerClientMock),\n                    dbUtils,\n                    cacheClient: instance(cacheClientMock),\n                    rfqMakerBalanceCacheService: instance(rfqMakerBalanceCacheServiceMock),\n                });\n\n                const { quote: res } = await service.fetchFirmQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    takerAddress,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    sellAmount: new BigNumber(333),\n                    checkApproval: false,\n                });\n\n                if (res === null) {\n                    expect.fail('res is null, but not expected to be null');\n                    return;\n                }\n\n                expect(res.price.toNumber()).to.equal(0.3333333);\n            });\n\n            it('should not call `getGaslessApprovalResponseAsync` if checkApproval is false', async () => {\n                const sellAmount = new BigNumber(100);\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const quote: IndicativeQuote = {\n                    maker: '0x64B92f5d9E5b5f20603de8498385c3a3d3048E22',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(101),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(100),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n\n                const cacheClientMock = mock(CacheClient);\n                when(cacheClientMock.getNextOtcOrderBucketAsync(1337)).thenResolve(420);\n                when(cacheClientMock.getMakersInCooldownForPairAsync(anything(), anything(), anything())).thenResolve(\n                    [],\n                );\n\n                // Mock out the dbUtils\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.writeV2QuoteAsync(anything())).thenResolve();\n                const dbUtils = instance(dbUtilsMock);\n\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    quote,\n                ]);\n                const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n                when(rfqMakerBalanceCacheServiceMock.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                    new BigNumber(150),\n                ]);\n\n                const service = buildRfqmServiceForUnitTest({\n                    quoteServerClient: instance(quoteServerClientMock),\n                    dbUtils,\n                    cacheClient: instance(cacheClientMock),\n                    rfqMakerBalanceCacheService: instance(rfqMakerBalanceCacheServiceMock),\n                });\n                const spiedService = spy(service);\n                when(spiedService.getGaslessApprovalResponseAsync(anything(), anything(), anything())).thenThrow(\n                    new Error('`getGaslessApprovalResponseAsync` should not be called'),\n                );\n\n                const { quote: res } = await service.fetchFirmQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    takerAddress,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    sellAmount,\n                    checkApproval: false,\n                });\n\n                expect(res).to.exist; // tslint:disable-line: no-unused-expression\n                expect(res?.type).to.equal(GaslessTypes.OtcOrder);\n\n                expect(res?.sellAmount).to.equal(sellAmount);\n                expect(res?.price.toNumber()).to.equal(1.01);\n                expect(res?.orderHash).to.match(/^0x[0-9a-fA-F]+/);\n                expect(res?.approval).to.equal(undefined);\n            });\n\n            it('should return the correct approval if checkApproval is true', async () => {\n                const sellAmount = new BigNumber(100);\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const quote: IndicativeQuote = {\n                    maker: '0x64B92f5d9E5b5f20603de8498385c3a3d3048E22',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(101),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(100),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n\n                const cacheClientMock = mock(CacheClient);\n                when(cacheClientMock.getNextOtcOrderBucketAsync(1337)).thenResolve(420);\n                when(cacheClientMock.getMakersInCooldownForPairAsync(anything(), anything(), anything())).thenResolve(\n                    [],\n                );\n\n                // Mock out the dbUtils\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.writeV2QuoteAsync(anything())).thenResolve();\n                const dbUtils = instance(dbUtilsMock);\n\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    quote,\n                ]);\n                const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n                when(rfqMakerBalanceCacheServiceMock.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                    new BigNumber(150),\n                ]);\n\n                const service = buildRfqmServiceForUnitTest({\n                    quoteServerClient: instance(quoteServerClientMock),\n                    dbUtils,\n                    cacheClient: instance(cacheClientMock),\n                    rfqMakerBalanceCacheService: instance(rfqMakerBalanceCacheServiceMock),\n                });\n                const approval: ApprovalResponse = {\n                    isRequired: true,\n                    isGaslessAvailable: true,\n                    type: MOCK_EXECUTE_META_TRANSACTION_APPROVAL.kind,\n                    eip712: MOCK_EXECUTE_META_TRANSACTION_APPROVAL.eip712,\n                };\n                const spiedService = spy(service);\n                when(spiedService.getGaslessApprovalResponseAsync(anything(), anything(), anything())).thenResolve(\n                    approval,\n                );\n\n                const { quote: res } = await service.fetchFirmQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    takerAddress,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    sellAmount,\n                    checkApproval: true,\n                });\n\n                expect(res).to.exist; // tslint:disable-line: no-unused-expression\n                expect(res?.type).to.equal(GaslessTypes.OtcOrder);\n\n                expect(res?.sellAmount).to.equal(sellAmount);\n                expect(res?.price.toNumber()).to.equal(1.01);\n                expect(res?.orderHash).to.match(/^0x[0-9a-fA-F]+/);\n                expect(res?.approval).to.eql(approval);\n            });\n        });\n\n        describe('buys', () => {\n            it('should fetch a firm quote', async () => {\n                const buyAmount = new BigNumber(100);\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const quote: IndicativeQuote = {\n                    maker: '0x64B92f5d9E5b5f20603de8498385c3a3d3048E22',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(100),\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(80),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n\n                const cacheClientMock = mock(CacheClient);\n                when(cacheClientMock.getNextOtcOrderBucketAsync(1337)).thenResolve(420);\n                when(cacheClientMock.getMakersInCooldownForPairAsync(anything(), anything(), anything())).thenResolve(\n                    [],\n                );\n\n                // Mock out the dbUtils\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.writeV2QuoteAsync(anything())).thenResolve();\n                const dbUtils = instance(dbUtilsMock);\n\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    quote,\n                ]);\n                const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n                when(rfqMakerBalanceCacheServiceMock.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                    new BigNumber(150),\n                ]);\n\n                const service = buildRfqmServiceForUnitTest({\n                    quoteServerClient: instance(quoteServerClientMock),\n                    dbUtils,\n                    cacheClient: instance(cacheClientMock),\n                    rfqMakerBalanceCacheService: instance(rfqMakerBalanceCacheServiceMock),\n                });\n\n                const { quote: res } = await service.fetchFirmQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    takerAddress,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    buyAmount: new BigNumber(100),\n                    checkApproval: false,\n                });\n\n                expect(res).to.exist; // tslint:disable-line: no-unused-expression\n                expect(res?.type).to.equal(GaslessTypes.OtcOrder);\n                expect(res?.buyAmount.toNumber()).to.equal(buyAmount.toNumber());\n                expect(res?.price.toNumber()).to.equal(0.8);\n                expect(res?.orderHash).to.match(/^0x[0-9a-fA-F]+/);\n            });\n\n            // TODO: we may want to reintroduce this test very soon. However, if not addressed by June 2022, remove\n            it.skip('should scale a firm quote to desired buyAmount if MM returns too much', async () => {\n                const buyAmount = new BigNumber(100);\n                const contractAddresses = getContractAddressesForChainOrThrow(1);\n                const quote: IndicativeQuote = {\n                    maker: '0x64B92f5d9E5b5f20603de8498385c3a3d3048E22',\n                    makerToken: contractAddresses.zrxToken,\n                    makerAmount: new BigNumber(125), // more than buyAmount\n                    takerToken: contractAddresses.etherToken,\n                    takerAmount: new BigNumber(100),\n                    expiry: NEVER_EXPIRES,\n                    makerUri: MOCK_MM_URI,\n                };\n\n                const cacheClientMock = mock(CacheClient);\n                when(cacheClientMock.getNextOtcOrderBucketAsync(1337)).thenResolve(420);\n                when(cacheClientMock.getMakersInCooldownForPairAsync(anything(), anything(), anything())).thenResolve(\n                    [],\n                );\n\n                // Mock out the dbUtils\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.writeV2QuoteAsync(anything())).thenResolve();\n                const dbUtils = instance(dbUtilsMock);\n\n                const quoteServerClientMock = mock(QuoteServerClient);\n                when(quoteServerClientMock.batchGetPriceV2Async(anything(), anything(), anything())).thenResolve([\n                    quote,\n                ]);\n                const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n                when(rfqMakerBalanceCacheServiceMock.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve([\n                    new BigNumber(150),\n                ]);\n\n                const service = buildRfqmServiceForUnitTest({\n                    quoteServerClient: instance(quoteServerClientMock),\n                    dbUtils,\n                    cacheClient: instance(cacheClientMock),\n                    rfqMakerBalanceCacheService: instance(rfqMakerBalanceCacheServiceMock),\n                });\n\n                const { quote: res } = await service.fetchFirmQuoteAsync({\n                    integrator: MOCK_INTEGRATOR,\n                    takerAddress,\n                    buyToken: contractAddresses.zrxToken,\n                    sellToken: contractAddresses.etherToken,\n                    buyTokenDecimals: 18,\n                    sellTokenDecimals: 18,\n                    buyAmount: new BigNumber(100),\n                    checkApproval: false,\n                });\n\n                expect(res).to.exist; // tslint:disable-line: no-unused-expression\n                expect(res?.type).to.equal(GaslessTypes.OtcOrder);\n                expect(res?.buyAmount.toNumber()).to.equal(buyAmount.toNumber());\n                expect(res?.sellAmount.toNumber()).to.equal(80); // result is scaled\n                expect(res?.price.toNumber()).to.equal(0.8);\n                expect(res?.orderHash).to.match(/^0x[0-9a-fA-F]+/);\n            });\n        });\n    });\n\n    describe('getGaslessApprovalResponseAsync', () => {\n        it('returns correct approval field', async () => {\n            const service = buildRfqmServiceForUnitTest();\n\n            let approval = await service.getGaslessApprovalResponseAsync(\n                MOCK_WORKER_REGISTRY_ADDRESS,\n                MOCK_TOKEN,\n                new BigNumber(100),\n            );\n            expect(approval).to.eql({ isRequired: false });\n\n            approval = await service.getGaslessApprovalResponseAsync(\n                MOCK_WORKER_REGISTRY_ADDRESS,\n                MOCK_TOKEN,\n                new BigNumber(100),\n            );\n            expect(approval).to.eql({ isRequired: true, isGaslessAvailable: false });\n\n            approval = await service.getGaslessApprovalResponseAsync(\n                MOCK_WORKER_REGISTRY_ADDRESS,\n                MOCK_TOKEN,\n                new BigNumber(100),\n            );\n            expect(approval).to.eql({\n                isRequired: true,\n                isGaslessAvailable: true,\n                type: MOCK_EXECUTE_META_TRANSACTION_APPROVAL.kind,\n                eip712: MOCK_EXECUTE_META_TRANSACTION_APPROVAL.eip712,\n            });\n        });\n    });\n\n    describe('runHealthCheckAsync', () => {\n        it('returns active pairs', async () => {\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.findRfqmWorkerHeartbeatsAsync(1337)).thenResolve([]);\n\n            const rfqMakerManagerMock = mock(RfqMakerManager);\n            when(rfqMakerManagerMock.getRfqmV2MakerOfferings()).thenReturn({\n                'https://mock-rfqm1.club': [\n                    ['0x871dd7c2b4b25e1aa18728e9d5f2af4c4e431f5c', '0x0b1ba0af832d7c05fd64161e0db78e85978e8082'],\n                ],\n            });\n\n            const service = buildRfqmServiceForUnitTest({\n                dbUtils: instance(dbUtilsMock),\n                rfqMakerManager: instance(rfqMakerManagerMock),\n            });\n\n            const result = await service.runHealthCheckAsync();\n\n            expect(result.pairs).to.have.key(\n                '0x0b1ba0af832d7c05fd64161e0db78e85978e8082-0x871dd7c2b4b25e1aa18728e9d5f2af4c4e431f5c',\n            );\n            expect(\n                result.pairs['0x0b1ba0af832d7c05fd64161e0db78e85978e8082-0x871dd7c2b4b25e1aa18728e9d5f2af4c4e431f5c'],\n            ).to.equal(HealthCheckStatus.Operational);\n        });\n    });\n\n    describe('status', () => {\n        describe('v2', () => {\n            const expiry = new BigNumber(Date.now() + 1_000_000).dividedBy(ONE_SECOND_MS).decimalPlaces(0);\n            const chainId = 1337;\n            const otcOrder = new OtcOrder({\n                txOrigin: '0x0000000000000000000000000000000000000000',\n                taker: '0x1111111111111111111111111111111111111111',\n                maker: '0x2222222222222222222222222222222222222222',\n                makerToken: '0x3333333333333333333333333333333333333333',\n                takerToken: '0x4444444444444444444444444444444444444444',\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(expiry, ZERO, expiry),\n                chainId,\n                verifyingContract: '0x0000000000000000000000000000000000000000',\n            });\n            const BASE_JOB = new RfqmV2JobEntity({\n                chainId,\n                expiry,\n                makerUri: '',\n                orderHash: '0x00',\n                fee: {\n                    token: '0xToken',\n                    amount: '100',\n                    type: 'fixed',\n                },\n                order: otcOrderToStoredOtcOrder(otcOrder),\n            });\n            it('should return failed for jobs that have sat in queue past expiry', async () => {\n                const expired = new BigNumber(Date.now() - 10000).dividedBy(ONE_SECOND_MS).decimalPlaces(0);\n                const oldJob = new RfqmV2JobEntity({ ...BASE_JOB, expiry: expired });\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(oldJob);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                const jobStatus = await service.getStatusAsync('0x00');\n\n                if (jobStatus === null) {\n                    expect.fail('Status should exist');\n                    throw new Error();\n                }\n                expect(jobStatus.status).to.equal('failed');\n\n                if (jobStatus.status !== 'failed') {\n                    expect.fail('Status should be failed');\n                    throw new Error();\n                }\n                expect(jobStatus.transactions).to.have.length(0); // tslint:disable-line no-unused-expression\n            });\n\n            it('should return pending for unexpired enqueued jobs', async () => {\n                const newJob = BASE_JOB; // BASE_JOB has a valid expiry\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(newJob);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                const jobStatus = await service.getStatusAsync('0x00');\n\n                if (jobStatus === null) {\n                    expect.fail('Status should exist');\n                    throw new Error();\n                }\n                expect(jobStatus.status).to.equal('pending');\n            });\n\n            it('should return pending for jobs in processing', async () => {\n                const job = new RfqmV2JobEntity({ ...BASE_JOB, status: RfqmJobStatus.PendingProcessing });\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                const jobStatus = await service.getStatusAsync('0x00');\n\n                if (jobStatus === null) {\n                    expect.fail('Status should exist');\n                    throw new Error();\n                }\n                expect(jobStatus.status).to.equal('pending');\n            });\n\n            it('should return submitted with transaction submissions for submitted jobs', async () => {\n                const now = Date.now();\n                const transaction1Time = now + 10;\n                const transaction2Time = now + 20;\n\n                const job = new RfqmV2JobEntity({\n                    ...BASE_JOB,\n                    status: RfqmJobStatus.PendingSubmitted,\n                });\n\n                const submission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(transaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x01',\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 0,\n                });\n                const submission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(transaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x02',\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 1,\n                });\n\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([submission1, submission2]);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                const jobStatus = await service.getStatusAsync('0x00');\n\n                if (jobStatus === null) {\n                    expect.fail('Status should exist');\n                    throw new Error();\n                }\n\n                if (jobStatus.status !== 'submitted') {\n                    expect.fail('Status should be submitted');\n                    throw new Error();\n                }\n                expect(jobStatus.transactions).to.have.length(2);\n                expect(jobStatus.transactions).to.deep.include({\n                    hash: '0x01',\n                    timestamp: +transaction1Time.valueOf(),\n                });\n                expect(jobStatus.transactions).to.deep.include({\n                    hash: '0x02',\n                    timestamp: +transaction2Time.valueOf(),\n                });\n            });\n\n            it('should return succeeded for a successful job, with the succeeded job', async () => {\n                const now = Date.now();\n                const transaction1Time = now + 10;\n                const transaction2Time = now + 20;\n\n                const job = new RfqmV2JobEntity({\n                    ...BASE_JOB,\n                    status: RfqmJobStatus.SucceededUnconfirmed,\n                });\n\n                const submission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(transaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x01',\n                    status: RfqmTransactionSubmissionStatus.DroppedAndReplaced,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 0,\n                });\n                const submission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(transaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x02',\n                    status: RfqmTransactionSubmissionStatus.SucceededUnconfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 1,\n                });\n\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([submission1, submission2]);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                const jobStatus = await service.getStatusAsync('0x00');\n\n                if (jobStatus === null) {\n                    expect.fail('Status should exist');\n                    throw new Error();\n                }\n\n                if (jobStatus.status !== 'succeeded') {\n                    expect.fail('Status should be succeeded');\n                    throw new Error();\n                }\n                expect(jobStatus.transactions[0]).to.contain({ hash: '0x02', timestamp: +transaction2Time.valueOf() });\n            });\n\n            it('should return confirmed for a successful confirmed job', async () => {\n                const now = Date.now();\n                const transaction1Time = now + 10;\n                const transaction2Time = now + 20;\n\n                const job = new RfqmV2JobEntity({\n                    ...BASE_JOB,\n                    status: RfqmJobStatus.SucceededConfirmed,\n                });\n\n                const submission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(transaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x01',\n                    status: RfqmTransactionSubmissionStatus.DroppedAndReplaced,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 0,\n                });\n                const submission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(transaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x02',\n                    status: RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 1,\n                });\n\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([submission1, submission2]);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                const jobStatus = await service.getStatusAsync('0x00');\n\n                if (jobStatus === null) {\n                    expect.fail('Status should exist');\n                    throw new Error();\n                }\n\n                if (jobStatus.status !== 'confirmed') {\n                    expect.fail('Status should be confirmed');\n                    throw new Error();\n                }\n                expect(jobStatus.transactions[0]).to.contain({ hash: '0x02', timestamp: +transaction2Time.valueOf() });\n            });\n\n            it('should throw if the job is successful but there are no successful transactions', async () => {\n                const now = Date.now();\n                const transaction1Time = now + 10;\n                const transaction2Time = now + 20;\n\n                const job = new RfqmV2JobEntity({\n                    ...BASE_JOB,\n                    status: RfqmJobStatus.SucceededUnconfirmed,\n                });\n\n                const submission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(transaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x01',\n                    status: RfqmTransactionSubmissionStatus.DroppedAndReplaced,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 0,\n                });\n                const submission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(transaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x02',\n                    status: RfqmTransactionSubmissionStatus.RevertedUnconfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 1,\n                });\n\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([submission1, submission2]);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                try {\n                    await service.getStatusAsync('0x00');\n                    expect.fail();\n                } catch (e) {\n                    expect(e.message).to.contain('Expected exactly one successful transaction submission');\n                }\n            });\n\n            it('should throw if the job is successful but there are multiple successful transactions', async () => {\n                const now = Date.now();\n                const transaction1Time = now + 10;\n                const transaction2Time = now + 20;\n\n                const job = new RfqmV2JobEntity({\n                    ...BASE_JOB,\n                    status: RfqmJobStatus.SucceededUnconfirmed,\n                });\n\n                const submission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(transaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x01',\n                    status: RfqmTransactionSubmissionStatus.SucceededUnconfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 0,\n                });\n                const submission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(transaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x02',\n                    status: RfqmTransactionSubmissionStatus.SucceededUnconfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 1,\n                });\n\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([submission1, submission2]);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                try {\n                    await service.getStatusAsync('0x00');\n                    expect.fail();\n                } catch (e) {\n                    expect(e.message).to.contain('Expected exactly one successful transaction submission');\n                }\n            });\n\n            it('should return submitted with approval and trade transaction submissions for submitted jobs', async () => {\n                const now = Date.now();\n                const approvalTransaction1Time = now + 3;\n                const approvalTransaction2Time = now + 7;\n                const tradeTransaction1Time = now + 10;\n                const tradeTransaction2Time = now + 20;\n\n                const job = new RfqmV2JobEntity({\n                    ...BASE_JOB,\n                    approval: MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                    status: RfqmJobStatus.PendingSubmitted,\n                });\n\n                const approvalSubmission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(approvalTransaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x01',\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Approval,\n                    nonce: 0,\n                });\n                const approvalSubmission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(approvalTransaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x02',\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Approval,\n                    nonce: 1,\n                });\n                const tradeSubmission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(tradeTransaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x03',\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 2,\n                });\n                const tradeSubmission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(tradeTransaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x04',\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 3,\n                });\n\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Approval,\n                    ),\n                ).thenResolve([approvalSubmission1, approvalSubmission2]);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([tradeSubmission1, tradeSubmission2]);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                const orderStatus = await service.getStatusAsync('0x00');\n\n                if (orderStatus === null) {\n                    expect.fail('Status should exist');\n                    throw new Error();\n                }\n\n                if (orderStatus.status !== 'submitted') {\n                    expect.fail('Status should be submitted');\n                    throw new Error();\n                }\n                expect(orderStatus.approvalTransactions).to.have.length(2);\n                expect(orderStatus.approvalTransactions).to.deep.include({\n                    hash: '0x01',\n                    timestamp: +approvalTransaction1Time.valueOf(),\n                });\n                expect(orderStatus.approvalTransactions).to.deep.include({\n                    hash: '0x02',\n                    timestamp: +approvalTransaction2Time.valueOf(),\n                });\n                expect(orderStatus.transactions).to.have.length(2);\n                expect(orderStatus.transactions).to.deep.include({\n                    hash: '0x03',\n                    timestamp: +tradeTransaction1Time.valueOf(),\n                });\n                expect(orderStatus.transactions).to.deep.include({\n                    hash: '0x04',\n                    timestamp: +tradeTransaction2Time.valueOf(),\n                });\n            });\n\n            it('should return failed with approval and trade transaction submissions for failed jobs', async () => {\n                const now = Date.now();\n                const approvalTransaction1Time = now + 3;\n                const approvalTransaction2Time = now + 7;\n                const tradeTransaction1Time = now + 10;\n                const tradeTransaction2Time = now + 20;\n\n                const job = new RfqmV2JobEntity({\n                    ...BASE_JOB,\n                    approval: MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                    status: RfqmJobStatus.FailedExpired,\n                });\n\n                const approvalSubmission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(approvalTransaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x01',\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Approval,\n                    nonce: 0,\n                });\n                const approvalSubmission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(approvalTransaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x02',\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Approval,\n                    nonce: 1,\n                });\n                const tradeSubmission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(tradeTransaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x03',\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 2,\n                });\n                const tradeSubmission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(tradeTransaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x04',\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 3,\n                });\n\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Approval,\n                    ),\n                ).thenResolve([approvalSubmission1, approvalSubmission2]);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([tradeSubmission1, tradeSubmission2]);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                const orderStatus = await service.getStatusAsync('0x00');\n\n                if (orderStatus === null) {\n                    expect.fail('Status should exist');\n                    throw new Error();\n                }\n\n                if (orderStatus.status !== 'failed') {\n                    expect.fail('Status should be failed');\n                    throw new Error();\n                }\n                expect(orderStatus.approvalTransactions).to.have.length(2);\n                expect(orderStatus.approvalTransactions).to.deep.include({\n                    hash: '0x01',\n                    timestamp: +approvalTransaction1Time.valueOf(),\n                });\n                expect(orderStatus.approvalTransactions).to.deep.include({\n                    hash: '0x02',\n                    timestamp: +approvalTransaction2Time.valueOf(),\n                });\n                expect(orderStatus.transactions).to.have.length(2);\n                expect(orderStatus.transactions).to.deep.include({\n                    hash: '0x03',\n                    timestamp: +tradeTransaction1Time.valueOf(),\n                });\n                expect(orderStatus.transactions).to.deep.include({\n                    hash: '0x04',\n                    timestamp: +tradeTransaction2Time.valueOf(),\n                });\n            });\n\n            it('should return declined for a job that was declined on the last look', async () => {\n                const job = new RfqmV2JobEntity({\n                    ...BASE_JOB,\n                    status: RfqmJobStatus.FailedLastLookDeclined,\n                });\n\n                const dbUtilsMock = mock(RfqmDbUtils);\n                //what is this dummy first attempt?\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve();\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([]);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                const jobStatus = await service.getStatusAsync('0x00');\n\n                if (jobStatus === null) {\n                    expect.fail('Status should exist');\n                    throw new Error();\n                }\n\n                expect(jobStatus.status).to.eq('failed');\n                if (jobStatus.status == 'failed') {\n                    expect(jobStatus.reason).to.eq('last_look_declined');\n                }\n            });\n\n            it('should return succeeded for a successful job, with the succeeded job and include correct `transactions` and `approvalTransactions`', async () => {\n                const now = Date.now();\n                const approvalTransaction1Time = now + 3;\n                const approvalTransaction2Time = now + 7;\n                const tradeTransaction1Time = now + 10;\n                const tradeTransaction2Time = now + 20;\n\n                const job = new RfqmV2JobEntity({\n                    ...BASE_JOB,\n                    approval: MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                    status: RfqmJobStatus.SucceededUnconfirmed,\n                });\n\n                const approvalSubmission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(approvalTransaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x01',\n                    status: RfqmTransactionSubmissionStatus.DroppedAndReplaced,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Approval,\n                    nonce: 0,\n                });\n                const approvalSubmission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(approvalTransaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x02',\n                    status: RfqmTransactionSubmissionStatus.SucceededUnconfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Approval,\n                    nonce: 1,\n                });\n                const tradeSubmission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(tradeTransaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x03',\n                    status: RfqmTransactionSubmissionStatus.DroppedAndReplaced,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 2,\n                });\n                const tradeSubmission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(tradeTransaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x04',\n                    status: RfqmTransactionSubmissionStatus.SucceededUnconfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 3,\n                });\n\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Approval,\n                    ),\n                ).thenResolve([approvalSubmission1, approvalSubmission2]);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([tradeSubmission1, tradeSubmission2]);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                const orderStatus = await service.getStatusAsync('0x00');\n\n                if (orderStatus === null) {\n                    expect.fail('Status should exist');\n                    throw new Error();\n                }\n\n                if (orderStatus.status !== 'succeeded') {\n                    expect.fail('Status should be succeeded');\n                    throw new Error();\n                }\n\n                if (!orderStatus.approvalTransactions) {\n                    expect.fail('Approval transactions not present');\n                    throw new Error();\n                }\n\n                expect(orderStatus.approvalTransactions[0]).to.contain({\n                    hash: '0x02',\n                    timestamp: +approvalTransaction2Time.valueOf(),\n                });\n                expect(orderStatus.transactions[0]).to.contain({\n                    hash: '0x04',\n                    timestamp: +tradeTransaction2Time.valueOf(),\n                });\n            });\n\n            it('should return confirmed for a successful confirmed job and include correct `transactions` and `approvalTransactions`', async () => {\n                const now = Date.now();\n                const approvalTransaction1Time = now + 3;\n                const approvalTransaction2Time = now + 7;\n                const tradeTransaction1Time = now + 10;\n                const tradeTransaction2Time = now + 20;\n\n                const job = new RfqmV2JobEntity({\n                    ...BASE_JOB,\n                    approval: MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                    status: RfqmJobStatus.SucceededConfirmed,\n                });\n\n                const approvalSubmission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(approvalTransaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x01',\n                    status: RfqmTransactionSubmissionStatus.DroppedAndReplaced,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Approval,\n                    nonce: 0,\n                });\n                const approvalSubmission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(approvalTransaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x02',\n                    status: RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Approval,\n                    nonce: 1,\n                });\n                const tradeSubmission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(tradeTransaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x03',\n                    status: RfqmTransactionSubmissionStatus.DroppedAndReplaced,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 2,\n                });\n                const tradeSubmission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(tradeTransaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x04',\n                    status: RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 3,\n                });\n\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Approval,\n                    ),\n                ).thenResolve([approvalSubmission1, approvalSubmission2]);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([tradeSubmission1, tradeSubmission2]);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                const orderStatus = await service.getStatusAsync('0x00');\n\n                if (orderStatus === null) {\n                    expect.fail('Status should exist');\n                    throw new Error();\n                }\n\n                if (orderStatus.status !== 'confirmed') {\n                    expect.fail('Status should be confirmed');\n                    throw new Error();\n                }\n\n                if (!orderStatus.approvalTransactions) {\n                    expect.fail('Approval transactions not present');\n                    throw new Error();\n                }\n\n                expect(orderStatus.approvalTransactions[0]).to.contain({\n                    hash: '0x02',\n                    timestamp: +approvalTransaction2Time.valueOf(),\n                });\n                expect(orderStatus.transactions[0]).to.contain({\n                    hash: '0x04',\n                    timestamp: +tradeTransaction2Time.valueOf(),\n                });\n            });\n\n            it('should throw if the job is successful but there are no successful transactions for approval', async () => {\n                const now = Date.now();\n                const approvalTransaction1Time = now + 3;\n                const approvalTransaction2Time = now + 7;\n                const tradeTransaction1Time = now + 10;\n                const tradeTransaction2Time = now + 20;\n\n                const job = new RfqmV2JobEntity({\n                    ...BASE_JOB,\n                    approval: MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                    status: RfqmJobStatus.SucceededUnconfirmed,\n                });\n\n                const approvalSubmission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(approvalTransaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x01',\n                    status: RfqmTransactionSubmissionStatus.DroppedAndReplaced,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Approval,\n                    nonce: 0,\n                });\n                const approvalSubmission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(approvalTransaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x02',\n                    status: RfqmTransactionSubmissionStatus.RevertedUnconfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Approval,\n                    nonce: 1,\n                });\n                const tradeSubmission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(tradeTransaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x03',\n                    status: RfqmTransactionSubmissionStatus.DroppedAndReplaced,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 2,\n                });\n                const tradeSubmission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(tradeTransaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x04',\n                    status: RfqmTransactionSubmissionStatus.SucceededUnconfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 3,\n                });\n\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Approval,\n                    ),\n                ).thenResolve([approvalSubmission1, approvalSubmission2]);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([tradeSubmission1, tradeSubmission2]);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                try {\n                    await service.getStatusAsync('0x00');\n                    expect.fail();\n                } catch (e) {\n                    expect(e.message).to.contain('Expected exactly one successful transaction submission');\n                }\n            });\n\n            it('should throw if the job is successful but there are multiple successful transactions for approval', async () => {\n                const now = Date.now();\n                const approvalTransaction1Time = now + 3;\n                const approvalTransaction2Time = now + 7;\n                const tradeTransaction1Time = now + 10;\n                const tradeTransaction2Time = now + 20;\n\n                const job = new RfqmV2JobEntity({\n                    ...BASE_JOB,\n                    approval: MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                    status: RfqmJobStatus.SucceededUnconfirmed,\n                });\n\n                const approvalSubmission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(approvalTransaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x01',\n                    status: RfqmTransactionSubmissionStatus.SucceededUnconfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Approval,\n                    nonce: 0,\n                });\n                const approvalSubmission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(approvalTransaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x02',\n                    status: RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Approval,\n                    nonce: 1,\n                });\n                const tradeSubmission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(tradeTransaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x03',\n                    status: RfqmTransactionSubmissionStatus.DroppedAndReplaced,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 2,\n                });\n                const tradeSubmission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(tradeTransaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x04',\n                    status: RfqmTransactionSubmissionStatus.SucceededUnconfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 3,\n                });\n\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Approval,\n                    ),\n                ).thenResolve([approvalSubmission1, approvalSubmission2]);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([tradeSubmission1, tradeSubmission2]);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                try {\n                    await service.getStatusAsync('0x00');\n                    expect.fail();\n                } catch (e) {\n                    expect(e.message).to.contain('Expected exactly one successful transaction submission');\n                }\n            });\n\n            it('should throw if the job is successful but the successful transaciton has no hash for approval', async () => {\n                const now = Date.now();\n                const approvalTransaction1Time = now + 3;\n                const approvalTransaction2Time = now + 7;\n                const tradeTransaction1Time = now + 10;\n                const tradeTransaction2Time = now + 20;\n\n                const job = new RfqmV2JobEntity({\n                    ...BASE_JOB,\n                    approval: MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n                    status: RfqmJobStatus.SucceededUnconfirmed,\n                });\n\n                const approvalSubmission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(approvalTransaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x01',\n                    status: RfqmTransactionSubmissionStatus.DroppedAndReplaced,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Approval,\n                    nonce: 0,\n                });\n                const approvalSubmission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(approvalTransaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '',\n                    status: RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Approval,\n                    nonce: 1,\n                });\n                const tradeSubmission1 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(tradeTransaction1Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x03',\n                    status: RfqmTransactionSubmissionStatus.DroppedAndReplaced,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 2,\n                });\n                const tradeSubmission2 = new RfqmV2TransactionSubmissionEntity({\n                    createdAt: new Date(tradeTransaction2Time),\n                    orderHash: job.orderHash,\n                    transactionHash: '0x04',\n                    status: RfqmTransactionSubmissionStatus.SucceededUnconfirmed,\n                    from: job.order.order.txOrigin,\n                    to: job.order.order.verifyingContract,\n                    type: RfqmTransactionSubmissionType.Trade,\n                    nonce: 3,\n                });\n\n                const dbUtilsMock = mock(RfqmDbUtils);\n                when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Approval,\n                    ),\n                ).thenResolve([approvalSubmission1, approvalSubmission2]);\n                when(\n                    dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(\n                        job.orderHash,\n                        RfqmTransactionSubmissionType.Trade,\n                    ),\n                ).thenResolve([tradeSubmission1, tradeSubmission2]);\n                const service = buildRfqmServiceForUnitTest({ dbUtils: instance(dbUtilsMock) });\n\n                try {\n                    await service.getStatusAsync('0x00');\n                    expect.fail();\n                } catch (e) {\n                    expect(e.message).to.contain('does not have a hash');\n                }\n            });\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_health_check.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/services/fee_service_test.ts",{"fileContent":"// tslint:disable:max-file-line-count\n// tslint:disable:custom-no-magic-numbers\n\nimport { BigNumber } from '@0x/utils';\nimport { anything, instance, mock, when } from 'ts-mockito';\n\nimport { DEFAULT_FEE_MODEL_CONFIGURATION, FeeModelConfiguration } from '../../src/config';\nimport {\n    BPS_TO_RATIO,\n    DEFAULT_MIN_EXPIRY_DURATION_MS,\n    RFQM_TX_OTC_ORDER_GAS_ESTIMATE,\n    ZERO,\n} from '../../src/core/constants';\nimport {\n    calculateDefaultFeeAmount,\n    calculatePriceImprovementAmount,\n    reviseQuoteWithFees,\n    FeeService,\n} from '../../src/services/fee_service';\nimport { QuoteContext } from '../../src/services/types';\nimport { FeeWithDetails, IndicativeQuote, TokenMetadata } from '../../src/core/types';\nimport { ConfigManager } from '../../src/utils/config_manager';\nimport { GasStationAttendantEthereum } from '../../src/utils/GasStationAttendantEthereum';\nimport { TokenPriceOracle } from '../../src/utils/TokenPriceOracle';\nimport { AmmQuote, ZeroExApiClient } from '../../src/utils/ZeroExApiClient';\n\nconst feeTokenSymbol = 'fee';\nconst feeTokenAddress = 'feeTokenAddress';\nconst feeTokenDecimals = 18;\n\nconst buildFeeService = (overrides: {\n    feeModelConfiguration?: FeeModelConfiguration;\n    gasPrice?: BigNumber;\n    tradeTokenPrice?: BigNumber | null;\n    feeTokenPrice?: BigNumber | null;\n    ammQuote?: AmmQuote | null;\n    chainId?: number;\n    feeTokenMetadata?: TokenMetadata;\n    configManagerMock?: ConfigManager;\n    gasStationAttendantMock?: GasStationAttendantEthereum;\n    tokenPriceOracleMock?: TokenPriceOracle;\n    zeroExApiClientMock?: ZeroExApiClient;\n}): FeeService => {\n    const chainId = overrides?.chainId || 1337;\n    const feeTokenMetadata = overrides?.feeTokenMetadata || {\n        symbol: feeTokenSymbol,\n        decimals: feeTokenDecimals,\n        tokenAddress: feeTokenAddress,\n    };\n    const feeModelConfiguration = overrides?.feeModelConfiguration || DEFAULT_FEE_MODEL_CONFIGURATION;\n    const gasPrice = overrides?.gasPrice || new BigNumber(1e9);\n    const tradeTokenPrice = overrides?.tradeTokenPrice || null;\n    const feeTokenPrice = overrides?.feeTokenPrice || null;\n    const ammQuote = overrides?.ammQuote || null;\n\n    const configManagerMock = mock(ConfigManager);\n    when(configManagerMock.getFeeModelConfiguration(chainId, anything(), anything())).thenReturn(feeModelConfiguration);\n\n    const gasStationAttendantMock = mock(GasStationAttendantEthereum);\n    when(gasStationAttendantMock.getExpectedTransactionGasRateAsync()).thenResolve(gasPrice);\n\n    const tokenPriceOracleMock = mock(TokenPriceOracle);\n    when(tokenPriceOracleMock.batchFetchTokenPriceAsync(anything())).thenResolve([tradeTokenPrice, feeTokenPrice]);\n\n    const zeroExApiClientMock = mock(ZeroExApiClient);\n    when(zeroExApiClientMock.fetchAmmQuoteAsync(anything())).thenResolve(ammQuote);\n\n    return new FeeService(\n        chainId,\n        feeTokenMetadata,\n        instance(overrides?.configManagerMock || configManagerMock),\n        instance(overrides?.gasStationAttendantMock || gasStationAttendantMock),\n        instance(overrides?.tokenPriceOracleMock || tokenPriceOracleMock),\n        instance(overrides?.zeroExApiClientMock || zeroExApiClientMock),\n        DEFAULT_MIN_EXPIRY_DURATION_MS,\n    );\n};\n\ndescribe('FeeService', () => {\n    const workflow = 'rfqm';\n    const txOrigin = 'registryAddress';\n    const makerToken = 'UsdcAddress';\n    const makerTokenDecimals = 6;\n    const makerTokenPrice = new BigNumber(1e-6);\n\n    const takerToken = 'WbtcAddress';\n    const takerTokenDecimals = 18;\n    const takerTokenPrice = new BigNumber(6e-14);\n\n    const gasPrice = new BigNumber(1e9);\n    const gasEstimate = RFQM_TX_OTC_ORDER_GAS_ESTIMATE;\n\n    const feeTokenPrice = new BigNumber(3e-15);\n\n    const integrator = {\n        apiKeys: [],\n        integratorId: 'integratorId',\n        allowedChainIds: [1, 3, 137, 1337],\n        label: 'dummy integrator',\n        plp: true,\n        rfqm: true,\n        rfqt: true,\n    };\n\n    const takerAddress = 'takerAddress';\n\n    afterAll(() => {\n        jest.useRealTimers();\n    });\n\n    describe('calculateFeeAsync v0', () => {\n        const feeModelVersion = 0;\n        it('should calculate v0 fee for RFQm correctly', async () => {\n            // Given\n            const isSelling = true;\n            const isUnwrap = false;\n            const assetFillAmount = new BigNumber(0.345e18);\n            const tradeSizeBps = 5;\n\n            const feeService: FeeService = buildFeeService({\n                feeModelConfiguration: {\n                    marginRakeRatio: 0,\n                    tradeSizeBps,\n                },\n                gasPrice,\n                tradeTokenPrice: takerTokenPrice,\n                feeTokenPrice,\n            });\n\n            // When\n            const { feeWithDetails: fee } = await feeService.calculateFeeAsync({\n                workflow,\n                chainId: 1337,\n                feeModelVersion,\n                txOrigin,\n                makerToken,\n                takerToken,\n                originalMakerToken: makerToken,\n                makerTokenDecimals,\n                takerTokenDecimals,\n                isUnwrap,\n                isSelling,\n                assetFillAmount,\n                takerAmount: assetFillAmount,\n                isFirm: true,\n                takerAddress,\n                trader: takerAddress,\n                integrator,\n            });\n\n            // Then\n            const expectedGasFeeAmount = gasPrice.times(gasEstimate);\n\n            const expectedFee: FeeWithDetails = {\n                type: 'fixed',\n                token: feeTokenAddress,\n                amount: expectedGasFeeAmount,\n                details: {\n                    kind: 'gasOnly',\n                    feeModelVersion,\n                    gasFeeAmount: expectedGasFeeAmount,\n                    gasPrice,\n                },\n                breakdown: {\n                    gas: {\n                        amount: expectedGasFeeAmount,\n                        details: {\n                            gasPrice,\n                            estimatedGas: new BigNumber(gasEstimate),\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: null,\n                    feeTokenBaseUnitPriceUsd: null,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n            };\n            expect(fee).toMatchObject(expectedFee);\n        });\n        it('should calculate v0 fee for RFQt correctly', async () => {\n            // Given\n            const isSelling = true;\n            const isUnwrap = false;\n            const assetFillAmount = new BigNumber(0.345e18);\n            const tradeSizeBps = 5;\n\n            const feeService: FeeService = buildFeeService({\n                feeModelConfiguration: {\n                    marginRakeRatio: 0,\n                    tradeSizeBps,\n                },\n                gasPrice,\n                tradeTokenPrice: takerTokenPrice,\n                feeTokenPrice,\n            });\n\n            // When\n            const { feeWithDetails: fee } = await feeService.calculateFeeAsync({\n                workflow: 'rfqt',\n                chainId: 1337,\n                feeModelVersion,\n                txOrigin,\n                makerToken,\n                takerToken,\n                originalMakerToken: makerToken,\n                makerTokenDecimals,\n                takerTokenDecimals,\n                isUnwrap,\n                isSelling,\n                assetFillAmount,\n                takerAmount: assetFillAmount,\n                isFirm: true,\n                takerAddress,\n                trader: takerAddress,\n                integrator,\n            });\n\n            // Then\n            const expectedFee: FeeWithDetails = {\n                type: 'fixed',\n                token: feeTokenAddress,\n                amount: new BigNumber(0),\n                details: {\n                    kind: 'gasOnly',\n                    feeModelVersion,\n                    gasFeeAmount: new BigNumber(0),\n                    gasPrice: new BigNumber(0),\n                },\n                breakdown: {},\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: null,\n                    feeTokenBaseUnitPriceUsd: null,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n            };\n            expect(fee).toMatchObject(expectedFee);\n        });\n    });\n\n    describe('calculateFeeAsync v1', () => {\n        const feeModelVersion = 1;\n        it('should calculate v1 fee for RFQm selling correctly', async () => {\n            // Given\n            const isSelling = true;\n            const isUnwrap = false;\n            const assetFillAmount = new BigNumber(0.345e18);\n            const tradeSizeBps = 5;\n\n            const feeService: FeeService = buildFeeService({\n                feeModelConfiguration: {\n                    marginRakeRatio: 0,\n                    tradeSizeBps,\n                },\n                gasPrice,\n                tradeTokenPrice: takerTokenPrice,\n                feeTokenPrice,\n            });\n\n            // When\n            const { feeWithDetails: fee } = await feeService.calculateFeeAsync({\n                workflow,\n                chainId: 1337,\n                feeModelVersion,\n                txOrigin,\n                makerToken,\n                takerToken,\n                originalMakerToken: makerToken,\n                makerTokenDecimals,\n                takerTokenDecimals,\n                isUnwrap,\n                isSelling,\n                assetFillAmount,\n                takerAmount: assetFillAmount,\n                isFirm: true,\n                takerAddress,\n                trader: takerAddress,\n                integrator,\n            });\n\n            // Then\n            const expectedGasFeeAmount = gasPrice.times(gasEstimate);\n            const expectedZeroExFeeAmount = assetFillAmount\n                .times(tradeSizeBps * BPS_TO_RATIO)\n                .times(takerTokenPrice)\n                .div(feeTokenPrice)\n                .integerValue();\n            const expectedTotalFeeAmount = expectedZeroExFeeAmount.plus(expectedGasFeeAmount);\n\n            const expectedFee: FeeWithDetails = {\n                type: 'fixed',\n                token: feeTokenAddress,\n                amount: expectedTotalFeeAmount,\n                details: {\n                    kind: 'default',\n                    feeModelVersion,\n                    gasFeeAmount: expectedGasFeeAmount,\n                    gasPrice,\n                    zeroExFeeAmount: expectedZeroExFeeAmount,\n                    tradeSizeBps,\n                    feeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    takerTokenBaseUnitPriceUsd: takerTokenPrice,\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n                breakdown: {\n                    gas: {\n                        amount: expectedGasFeeAmount,\n                        details: {\n                            gasPrice,\n                            estimatedGas: new BigNumber(gasEstimate),\n                        },\n                    },\n                    zeroEx: {\n                        amount: expectedZeroExFeeAmount,\n                        details: {\n                            kind: 'volume',\n                            tradeSizeBps,\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    feeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    takerTokenBaseUnitPriceUsd: takerTokenPrice,\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n            };\n            expect(fee).toMatchObject(expectedFee);\n        });\n        it('should calculate v1 fee for RFQm buying correctly', async () => {\n            // Given\n            const isSelling = false;\n            const isUnwrap = false;\n            const assetFillAmount = new BigNumber(5000e6);\n            const tradeSizeBps = 4;\n\n            const feeService: FeeService = buildFeeService({\n                feeModelConfiguration: {\n                    marginRakeRatio: 0,\n                    tradeSizeBps,\n                },\n                gasPrice,\n                tradeTokenPrice: makerTokenPrice,\n                feeTokenPrice,\n            });\n\n            // When\n            const { feeWithDetails: fee } = await feeService.calculateFeeAsync({\n                workflow,\n                chainId: 1337,\n                feeModelVersion,\n                makerToken,\n                takerToken,\n                originalMakerToken: makerToken,\n                makerTokenDecimals,\n                takerTokenDecimals,\n                isUnwrap,\n                isSelling,\n                assetFillAmount,\n                makerAmount: assetFillAmount,\n                isFirm: false,\n                takerAddress,\n                integrator,\n            });\n\n            // Then\n            const expectedGasFeeAmount = gasPrice.times(gasEstimate);\n            const expectedZeroExFeeAmount = assetFillAmount\n                .times(tradeSizeBps * BPS_TO_RATIO)\n                .times(makerTokenPrice)\n                .div(feeTokenPrice)\n                .integerValue();\n            const expectedTotalFeeAmount = expectedZeroExFeeAmount.plus(expectedGasFeeAmount);\n\n            const expectedFee: FeeWithDetails = {\n                type: 'fixed',\n                token: feeTokenAddress,\n                amount: expectedTotalFeeAmount,\n                details: {\n                    kind: 'default',\n                    feeModelVersion,\n                    gasFeeAmount: expectedGasFeeAmount,\n                    gasPrice,\n                    zeroExFeeAmount: expectedZeroExFeeAmount,\n                    tradeSizeBps,\n                    feeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: makerTokenPrice,\n                },\n                breakdown: {\n                    gas: {\n                        amount: expectedGasFeeAmount,\n                        details: {\n                            gasPrice,\n                            estimatedGas: new BigNumber(gasEstimate),\n                        },\n                    },\n                    zeroEx: {\n                        amount: expectedZeroExFeeAmount,\n                        details: {\n                            kind: 'volume',\n                            tradeSizeBps,\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    feeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: makerTokenPrice,\n                },\n            };\n            expect(fee).toMatchObject(expectedFee);\n        });\n        it('should calculate v1 fee for RFQt selling correctly', async () => {\n            // Given\n            const isSelling = true;\n            const isUnwrap = false;\n            const assetFillAmount = new BigNumber(0.345e18);\n            const tradeSizeBps = 5;\n\n            const feeService: FeeService = buildFeeService({\n                feeModelConfiguration: {\n                    marginRakeRatio: 0,\n                    tradeSizeBps,\n                },\n                gasPrice,\n                tradeTokenPrice: takerTokenPrice,\n                feeTokenPrice,\n            });\n\n            // When\n            const { feeWithDetails: fee } = await feeService.calculateFeeAsync({\n                workflow: 'rfqt',\n                chainId: 1337,\n                feeModelVersion,\n                txOrigin,\n                makerToken,\n                takerToken,\n                originalMakerToken: makerToken,\n                makerTokenDecimals,\n                takerTokenDecimals,\n                isUnwrap,\n                isSelling,\n                assetFillAmount,\n                takerAmount: assetFillAmount,\n                isFirm: true,\n                takerAddress,\n                trader: takerAddress,\n                integrator,\n            });\n\n            // Then\n            const expectedZeroExFeeAmount = assetFillAmount\n                .times(tradeSizeBps * BPS_TO_RATIO)\n                .times(takerTokenPrice)\n                .div(feeTokenPrice)\n                .integerValue();\n\n            const expectedFee: FeeWithDetails = {\n                type: 'fixed',\n                token: feeTokenAddress,\n                amount: expectedZeroExFeeAmount,\n                details: {\n                    kind: 'default',\n                    feeModelVersion,\n                    gasFeeAmount: new BigNumber(0),\n                    gasPrice: new BigNumber(0),\n                    zeroExFeeAmount: expectedZeroExFeeAmount,\n                    tradeSizeBps,\n                    feeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    takerTokenBaseUnitPriceUsd: takerTokenPrice,\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n                breakdown: {\n                    zeroEx: {\n                        amount: expectedZeroExFeeAmount,\n                        details: {\n                            kind: 'volume',\n                            tradeSizeBps,\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    feeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    takerTokenBaseUnitPriceUsd: takerTokenPrice,\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n            };\n            expect(fee).toMatchObject(expectedFee);\n        });\n        it('should not include zeroEx fee for non-configured pairs', async () => {\n            // Given\n            const isSelling = true;\n            const isUnwrap = false;\n            const assetFillAmount = new BigNumber(0.345e18);\n\n            const feeService: FeeService = buildFeeService({\n                gasPrice,\n                tradeTokenPrice: takerTokenPrice,\n                feeTokenPrice,\n            });\n\n            // When\n            const { feeWithDetails: fee } = await feeService.calculateFeeAsync({\n                workflow,\n                chainId: 1337,\n                feeModelVersion,\n                makerToken,\n                takerToken,\n                originalMakerToken: makerToken,\n                makerTokenDecimals,\n                takerTokenDecimals,\n                isUnwrap,\n                isSelling,\n                assetFillAmount,\n                takerAmount: assetFillAmount,\n                isFirm: false,\n                takerAddress,\n                integrator,\n            });\n\n            // Then\n            const expectedGasFeeAmount = gasPrice.times(gasEstimate);\n\n            const expectedFee: FeeWithDetails = {\n                type: 'fixed',\n                token: feeTokenAddress,\n                amount: expectedGasFeeAmount,\n                details: {\n                    kind: 'default',\n                    feeModelVersion,\n                    gasFeeAmount: expectedGasFeeAmount,\n                    gasPrice,\n                    zeroExFeeAmount: new BigNumber(0),\n                    tradeSizeBps: 0,\n                    feeTokenBaseUnitPriceUsd: null,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n                breakdown: {\n                    gas: {\n                        amount: expectedGasFeeAmount,\n                        details: {\n                            gasPrice,\n                            estimatedGas: new BigNumber(gasEstimate),\n                        },\n                    },\n                    zeroEx: {\n                        amount: new BigNumber(0),\n                        details: {\n                            kind: 'volume',\n                            tradeSizeBps: 0,\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: null,\n                    feeTokenBaseUnitPriceUsd: null,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n            };\n            expect(fee).toMatchObject(expectedFee);\n        });\n        it('should not include zeroEx fee if price oracle is down', async () => {\n            // Given\n            const isSelling = false;\n            const isUnwrap = false;\n            const assetFillAmount = new BigNumber(5000e6);\n            const tradeSizeBps = 4;\n\n            const feeService: FeeService = buildFeeService({\n                feeModelConfiguration: {\n                    marginRakeRatio: 0,\n                    tradeSizeBps,\n                },\n                gasPrice,\n                tradeTokenPrice: makerTokenPrice,\n                feeTokenPrice: null,\n            });\n\n            // When\n            const { feeWithDetails: fee } = await feeService.calculateFeeAsync({\n                workflow,\n                chainId: 1337,\n                feeModelVersion,\n                txOrigin,\n                makerToken,\n                takerToken,\n                originalMakerToken: makerToken,\n                makerTokenDecimals,\n                takerTokenDecimals,\n                isUnwrap,\n                isSelling,\n                assetFillAmount,\n                makerAmount: assetFillAmount,\n                isFirm: true,\n                takerAddress,\n                trader: takerAddress,\n                integrator,\n            });\n\n            // Then\n            const expectedGasFeeAmount = gasPrice.times(gasEstimate);\n\n            const expectedFee: FeeWithDetails = {\n                type: 'fixed',\n                token: feeTokenAddress,\n                amount: expectedGasFeeAmount,\n                details: {\n                    kind: 'gasOnly',\n                    feeModelVersion,\n                    gasFeeAmount: expectedGasFeeAmount,\n                    gasPrice,\n                },\n                breakdown: {\n                    gas: {\n                        amount: expectedGasFeeAmount,\n                        details: {\n                            gasPrice,\n                            estimatedGas: new BigNumber(gasEstimate),\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: null,\n                    feeTokenBaseUnitPriceUsd: null,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n            };\n            expect(fee).toMatchObject(expectedFee);\n        });\n    });\n\n    describe('calculateFeeAsync v2', () => {\n        const feeModelVersion = 2;\n        it('should calculate v2 `price improvement` based fee for sell correctly if price improvement detection succeeded', async () => {\n            // Given\n            const isSelling = true;\n            const isUnwrap = false;\n            const assetFillAmount = new BigNumber(1e18);\n            const marginRakeRatio = 0.5;\n\n            const ammMakerAmount = new BigNumber(3450e6);\n            const expectedSlippage = new BigNumber(-0.01);\n            const estimatedAmmGasFeeWei = new BigNumber(100e9);\n            const decodedUniqueId = '1234-5678';\n            const ammQuote: AmmQuote = {\n                makerAmount: ammMakerAmount,\n                takerAmount: assetFillAmount,\n                expectedSlippage,\n                estimatedGasFeeWei: estimatedAmmGasFeeWei,\n                decodedUniqueId,\n            };\n\n            const mm1MakerAmount = new BigNumber(3550e6);\n            const mm2MakerAmount = new BigNumber(3600e6);\n            const mmQuotes: IndicativeQuote[] = [\n                {\n                    maker: 'maker1Address',\n                    makerUri: 'http://maker1.com',\n                    makerToken,\n                    takerToken,\n                    makerAmount: mm1MakerAmount,\n                    takerAmount: assetFillAmount,\n                    expiry: new BigNumber(1652722767),\n                },\n                {\n                    maker: 'maker2Address',\n                    makerUri: 'http://maker2.com',\n                    makerToken,\n                    takerToken,\n                    makerAmount: mm2MakerAmount,\n                    takerAmount: assetFillAmount,\n                    expiry: new BigNumber(1652722767),\n                },\n            ];\n\n            const feeService: FeeService = buildFeeService({\n                feeModelConfiguration: {\n                    marginRakeRatio,\n                    tradeSizeBps: 0,\n                },\n                gasPrice,\n                tradeTokenPrice: makerTokenPrice,\n                feeTokenPrice,\n                ammQuote,\n            });\n\n            const quoteContext: QuoteContext = {\n                workflow,\n                chainId: 1337,\n                isFirm: true,\n                feeModelVersion,\n                txOrigin,\n                makerToken,\n                takerToken,\n                originalMakerToken: makerToken,\n                makerTokenDecimals,\n                takerTokenDecimals,\n                isUnwrap,\n                isSelling,\n                assetFillAmount,\n                takerAmount: assetFillAmount,\n                takerAddress,\n                trader: takerAddress,\n                integrator,\n            };\n\n            // When\n            jest.useFakeTimers().setSystemTime(1650000000000);\n            const { feeWithDetails, quotesWithGasFee, ammQuoteUniqueId } = await feeService.calculateFeeAsync(\n                quoteContext,\n                async () => {\n                    return Promise.resolve(mmQuotes);\n                },\n            );\n\n            // Then\n            const expectedGasFeeAmount = gasPrice.times(gasEstimate);\n            const expectedMargin = mm2MakerAmount\n                .minus(ammMakerAmount.times(new BigNumber(1).plus(expectedSlippage)))\n                .times(makerTokenPrice)\n                .div(feeTokenPrice)\n                .plus(estimatedAmmGasFeeWei)\n                .integerValue();\n            const expectedZeroExFeeAmount = expectedMargin.times(marginRakeRatio).integerValue();\n            const expectedTotalFeeAmount = expectedZeroExFeeAmount.plus(expectedGasFeeAmount);\n\n            const expectedFee: FeeWithDetails = {\n                type: 'fixed',\n                token: feeTokenAddress,\n                amount: expectedTotalFeeAmount,\n                details: {\n                    kind: 'margin',\n                    feeModelVersion,\n                    gasFeeAmount: expectedGasFeeAmount,\n                    gasPrice,\n                    zeroExFeeAmount: expectedZeroExFeeAmount,\n                    margin: expectedMargin,\n                    marginRakeRatio,\n                    feeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: makerTokenPrice,\n                },\n                breakdown: {\n                    gas: {\n                        amount: expectedGasFeeAmount,\n                        details: {\n                            gasPrice,\n                            estimatedGas: new BigNumber(gasEstimate),\n                        },\n                    },\n                    zeroEx: {\n                        amount: expectedZeroExFeeAmount,\n                        details: {\n                            kind: 'price_improvement',\n                            priceImprovement: expectedMargin,\n                            rakeRatio: marginRakeRatio,\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    feeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: makerTokenPrice,\n                },\n            };\n            expect(feeWithDetails).toMatchObject(expectedFee);\n            expect(quotesWithGasFee).toMatchObject(mmQuotes);\n            expect(ammQuoteUniqueId).toBe(decodedUniqueId);\n\n            // When\n            const revisedQuotes = await feeService.reviseQuotesAsync(\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                quotesWithGasFee!,\n                expectedZeroExFeeAmount,\n                quoteContext,\n            );\n\n            // Then\n            const expectedRevisedQuotes = mmQuotes.map((quote) =>\n                reviseQuoteWithFees(quote, expectedZeroExFeeAmount, isSelling, makerTokenPrice, feeTokenPrice),\n            );\n\n            expect(revisedQuotes).toMatchObject(expectedRevisedQuotes);\n        });\n        it('should calculate v2 `price improvement` based fee for buy correctly if price improvement detection succeeded', async () => {\n            // Given\n            const isSelling = false;\n            const isUnwrap = false;\n            const assetFillAmount = new BigNumber(1e18);\n            const marginRakeRatio = 0.4;\n\n            const ammTakerAmount = new BigNumber(3450e6);\n            const expectedSlippage = new BigNumber(-0.1);\n            const estimatedAmmGasFeeWei = new BigNumber(100e9);\n            const decodedUniqueId = '1234-5678';\n            const ammQuote: AmmQuote = {\n                makerAmount: assetFillAmount,\n                takerAmount: ammTakerAmount,\n                expectedSlippage,\n                estimatedGasFeeWei: estimatedAmmGasFeeWei,\n                decodedUniqueId,\n            };\n\n            const mm1TakerAmount = new BigNumber(3400e6);\n            const mm2TakerAmount = new BigNumber(3350e6);\n            const mmQuotes: IndicativeQuote[] = [\n                {\n                    maker: 'maker1Address',\n                    makerUri: 'http://maker1.com',\n                    makerToken,\n                    takerToken,\n                    makerAmount: assetFillAmount,\n                    takerAmount: mm1TakerAmount,\n                    expiry: new BigNumber(1652722767),\n                },\n                {\n                    maker: 'maker2Address',\n                    makerUri: 'http://maker2.com',\n                    makerToken,\n                    takerToken,\n                    makerAmount: assetFillAmount,\n                    takerAmount: mm2TakerAmount,\n                    expiry: new BigNumber(1652722767),\n                },\n            ];\n\n            const feeService: FeeService = buildFeeService({\n                feeModelConfiguration: {\n                    marginRakeRatio,\n                    tradeSizeBps: 0,\n                },\n                gasPrice,\n                tradeTokenPrice: takerTokenPrice,\n                feeTokenPrice,\n                ammQuote,\n            });\n\n            const quoteContext: QuoteContext = {\n                workflow,\n                chainId: 1337,\n                feeModelVersion,\n                makerToken,\n                takerToken,\n                originalMakerToken: makerToken,\n                makerTokenDecimals,\n                takerTokenDecimals,\n                isUnwrap,\n                isSelling,\n                assetFillAmount,\n                makerAmount: assetFillAmount,\n                isFirm: false,\n                takerAddress,\n                integrator,\n            };\n\n            // When\n            jest.useFakeTimers().setSystemTime(1650000000000);\n            const { feeWithDetails, quotesWithGasFee, ammQuoteUniqueId } = await feeService.calculateFeeAsync(\n                quoteContext,\n                async () => {\n                    return Promise.resolve(mmQuotes);\n                },\n            );\n\n            // Then\n            const expectedGasFeeAmount = gasPrice.times(gasEstimate);\n            const expectedMargin = ammTakerAmount\n                .times(new BigNumber(1).minus(expectedSlippage))\n                .minus(mm2TakerAmount)\n                .times(takerTokenPrice)\n                .div(feeTokenPrice)\n                .plus(estimatedAmmGasFeeWei)\n                .integerValue();\n            const expectedZeroExFeeAmount = expectedMargin.times(marginRakeRatio).integerValue();\n            const expectedTotalFeeAmount = expectedZeroExFeeAmount.plus(expectedGasFeeAmount);\n\n            const expectedFee: FeeWithDetails = {\n                type: 'fixed',\n                token: feeTokenAddress,\n                amount: expectedTotalFeeAmount,\n                details: {\n                    kind: 'margin',\n                    feeModelVersion,\n                    gasFeeAmount: expectedGasFeeAmount,\n                    gasPrice,\n                    zeroExFeeAmount: expectedZeroExFeeAmount,\n                    margin: expectedMargin,\n                    marginRakeRatio,\n                    feeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    takerTokenBaseUnitPriceUsd: takerTokenPrice,\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n                breakdown: {\n                    gas: {\n                        amount: expectedGasFeeAmount,\n                        details: {\n                            gasPrice,\n                            estimatedGas: new BigNumber(gasEstimate),\n                        },\n                    },\n                    zeroEx: {\n                        amount: expectedZeroExFeeAmount,\n                        details: {\n                            kind: 'price_improvement',\n                            priceImprovement: expectedMargin,\n                            rakeRatio: marginRakeRatio,\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    feeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    takerTokenBaseUnitPriceUsd: takerTokenPrice,\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n            };\n            expect(feeWithDetails).toMatchObject(expectedFee);\n            expect(quotesWithGasFee).toMatchObject(mmQuotes);\n            expect(ammQuoteUniqueId).toBe(decodedUniqueId);\n\n            // When\n            const revisedQuotes = await feeService.reviseQuotesAsync(\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                quotesWithGasFee!,\n                expectedZeroExFeeAmount,\n                quoteContext,\n            );\n\n            // Then\n            const expectedRevisedQuotes = mmQuotes.map((quote) =>\n                reviseQuoteWithFees(quote, expectedZeroExFeeAmount, isSelling, takerTokenPrice, feeTokenPrice),\n            );\n\n            expect(revisedQuotes).toMatchObject(expectedRevisedQuotes);\n        });\n        it('should calculate v2 `default` fee correctly if token price query succeeded but 0x-api query failed', async () => {\n            // Given\n            const isSelling = true;\n            const isUnwrap = false;\n            const assetFillAmount = new BigNumber(1e18);\n            const marginRakeRatio = 0.5;\n            const tradeSizeBps = 5;\n\n            const ammQuote = null;\n\n            const mm1MakerAmount = new BigNumber(3550e6);\n            const mm2MakerAmount = new BigNumber(3600e6);\n            const mmQuotes: IndicativeQuote[] = [\n                {\n                    maker: 'maker1Address',\n                    makerUri: 'http://maker1.com',\n                    makerToken,\n                    takerToken,\n                    makerAmount: mm1MakerAmount,\n                    takerAmount: assetFillAmount,\n                    expiry: new BigNumber(1652722767),\n                },\n                {\n                    maker: 'maker2Address',\n                    makerUri: 'http://maker2.com',\n                    makerToken,\n                    takerToken,\n                    makerAmount: mm2MakerAmount,\n                    takerAmount: assetFillAmount,\n                    expiry: new BigNumber(1652722767),\n                },\n            ];\n\n            const feeService: FeeService = buildFeeService({\n                feeModelConfiguration: {\n                    marginRakeRatio,\n                    tradeSizeBps,\n                },\n                gasPrice,\n                tradeTokenPrice: makerTokenPrice,\n                feeTokenPrice,\n                ammQuote,\n            });\n\n            const quoteContext: QuoteContext = {\n                workflow,\n                chainId: 1337,\n                feeModelVersion,\n                txOrigin,\n                makerToken,\n                takerToken,\n                originalMakerToken: makerToken,\n                makerTokenDecimals,\n                takerTokenDecimals,\n                isUnwrap,\n                isSelling,\n                assetFillAmount,\n                takerAmount: assetFillAmount,\n                isFirm: true,\n                takerAddress,\n                trader: takerAddress,\n                integrator,\n            };\n\n            // When\n            jest.useFakeTimers().setSystemTime(1650000000000);\n            const { feeWithDetails, quotesWithGasFee, ammQuoteUniqueId } = await feeService.calculateFeeAsync(\n                quoteContext,\n                async () => {\n                    return Promise.resolve(mmQuotes);\n                },\n            );\n\n            // Then\n            const expectedGasFeeAmount = gasPrice.times(gasEstimate);\n            const expectedZeroExFeeAmount = calculateDefaultFeeAmount(\n                mm2MakerAmount,\n                tradeSizeBps,\n                makerTokenPrice,\n                feeTokenPrice,\n            );\n            const expectedTotalFeeAmount = expectedZeroExFeeAmount.plus(expectedGasFeeAmount);\n\n            const expectedFee: FeeWithDetails = {\n                type: 'fixed',\n                token: feeTokenAddress,\n                amount: expectedTotalFeeAmount,\n                details: {\n                    kind: 'default',\n                    feeModelVersion,\n                    gasFeeAmount: expectedGasFeeAmount,\n                    gasPrice,\n                    zeroExFeeAmount: expectedZeroExFeeAmount,\n                    tradeSizeBps,\n                    feeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: makerTokenPrice,\n                },\n                breakdown: {\n                    gas: {\n                        amount: expectedGasFeeAmount,\n                        details: {\n                            gasPrice,\n                            estimatedGas: new BigNumber(gasEstimate),\n                        },\n                    },\n                    zeroEx: {\n                        amount: expectedZeroExFeeAmount,\n                        details: {\n                            kind: 'volume',\n                            tradeSizeBps,\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    feeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: makerTokenPrice,\n                },\n            };\n            expect(feeWithDetails).toMatchObject(expectedFee);\n            expect(quotesWithGasFee).toMatchObject(mmQuotes);\n            expect(ammQuoteUniqueId).toBe(undefined);\n\n            // When\n            const revisedQuotes = await feeService.reviseQuotesAsync(\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                quotesWithGasFee!,\n                expectedZeroExFeeAmount,\n                quoteContext,\n            );\n\n            // Then\n            const expectedRevisedQuotes = mmQuotes.map((quote) =>\n                reviseQuoteWithFees(quote, expectedZeroExFeeAmount, isSelling, makerTokenPrice, feeTokenPrice),\n            );\n\n            expect(revisedQuotes).toMatchObject(expectedRevisedQuotes);\n        });\n        it('should calculate v2 `gasOnly` fee correctly if token price query failed', async () => {\n            // Given\n            const isSelling = true;\n            const isUnwrap = false;\n            const assetFillAmount = new BigNumber(1e18);\n            const marginRakeRatio = 0.5;\n            const tradeSizeBps = 5;\n\n            const ammMakerAmount = new BigNumber(3450e6);\n            const expectedSlippage = new BigNumber(-0.01);\n            const estimatedAmmGasFeeWei = new BigNumber(100e9);\n            const decodedUniqueId = '1234-5678';\n            const ammQuote: AmmQuote = {\n                makerAmount: ammMakerAmount,\n                takerAmount: assetFillAmount,\n                expectedSlippage,\n                estimatedGasFeeWei: estimatedAmmGasFeeWei,\n                decodedUniqueId,\n            };\n\n            const mm1MakerAmount = new BigNumber(3550e6);\n            const mm2MakerAmount = new BigNumber(3600e6);\n            const mmQuotes: IndicativeQuote[] = [\n                {\n                    maker: 'maker1Address',\n                    makerUri: 'http://maker1.com',\n                    makerToken,\n                    takerToken,\n                    makerAmount: mm1MakerAmount,\n                    takerAmount: assetFillAmount,\n                    expiry: new BigNumber(1652722767),\n                },\n                {\n                    maker: 'maker2Address',\n                    makerUri: 'http://maker2.com',\n                    makerToken,\n                    takerToken,\n                    makerAmount: mm2MakerAmount,\n                    takerAmount: assetFillAmount,\n                    expiry: new BigNumber(1652722767),\n                },\n            ];\n\n            const feeService: FeeService = buildFeeService({\n                feeModelConfiguration: {\n                    marginRakeRatio,\n                    tradeSizeBps,\n                },\n                gasPrice,\n                tradeTokenPrice: makerTokenPrice,\n                feeTokenPrice: null,\n                ammQuote,\n            });\n\n            // When\n            jest.useFakeTimers().setSystemTime(1650000000000);\n            const { feeWithDetails, quotesWithGasFee, ammQuoteUniqueId } = await feeService.calculateFeeAsync(\n                {\n                    workflow,\n                    chainId: 1337,\n                    feeModelVersion,\n                    txOrigin,\n                    makerToken,\n                    takerToken,\n                    originalMakerToken: makerToken,\n                    makerTokenDecimals,\n                    takerTokenDecimals,\n                    isUnwrap,\n                    isSelling,\n                    assetFillAmount,\n                    takerAmount: assetFillAmount,\n                    isFirm: true,\n                    takerAddress,\n                    trader: takerAddress,\n                    integrator,\n                },\n                async () => {\n                    return Promise.resolve(mmQuotes);\n                },\n            );\n\n            // Then\n            const expectedGasFeeAmount = gasPrice.times(gasEstimate);\n\n            const expectedFee: FeeWithDetails = {\n                type: 'fixed',\n                token: feeTokenAddress,\n                amount: expectedGasFeeAmount,\n                details: {\n                    kind: 'gasOnly',\n                    feeModelVersion,\n                    gasFeeAmount: expectedGasFeeAmount,\n                    gasPrice,\n                },\n                breakdown: {\n                    gas: {\n                        amount: expectedGasFeeAmount,\n                        details: {\n                            gasPrice,\n                            estimatedGas: new BigNumber(gasEstimate),\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: null,\n                    feeTokenBaseUnitPriceUsd: null,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n            };\n            expect(feeWithDetails).toMatchObject(expectedFee);\n            expect(quotesWithGasFee).toMatchObject(mmQuotes);\n            expect(ammQuoteUniqueId).toBe(decodedUniqueId);\n        });\n        it('should calculate v2 `price improvement` based fee with zero zeroExFee if price improvement is zero', async () => {\n            // Given\n            const isSelling = true;\n            const isUnwrap = false;\n            const assetFillAmount = new BigNumber(1e18);\n            const marginRakeRatio = 0.5;\n\n            const ammMakerAmount = new BigNumber(4000e6);\n            const expectedSlippage = new BigNumber(-0.01);\n            const estimatedAmmGasFeeWei = new BigNumber(100e9);\n            const decodedUniqueId = '1234-5678';\n            const ammQuote: AmmQuote = {\n                makerAmount: ammMakerAmount,\n                takerAmount: assetFillAmount,\n                expectedSlippage,\n                estimatedGasFeeWei: estimatedAmmGasFeeWei,\n                decodedUniqueId,\n            };\n\n            const mm1MakerAmount = new BigNumber(3550e6);\n            const mm2MakerAmount = new BigNumber(3600e6);\n            const mmQuotes: IndicativeQuote[] = [\n                {\n                    maker: 'maker1Address',\n                    makerUri: 'http://maker1.com',\n                    makerToken,\n                    takerToken,\n                    makerAmount: mm1MakerAmount,\n                    takerAmount: assetFillAmount,\n                    expiry: new BigNumber(1652722767),\n                },\n                {\n                    maker: 'maker2Address',\n                    makerUri: 'http://maker2.com',\n                    makerToken,\n                    takerToken,\n                    makerAmount: mm2MakerAmount,\n                    takerAmount: assetFillAmount,\n                    expiry: new BigNumber(1652722767),\n                },\n            ];\n\n            const feeService: FeeService = buildFeeService({\n                feeModelConfiguration: {\n                    marginRakeRatio,\n                    tradeSizeBps: 0,\n                },\n                gasPrice,\n                tradeTokenPrice: makerTokenPrice,\n                feeTokenPrice,\n                ammQuote,\n            });\n\n            // When\n            jest.useFakeTimers().setSystemTime(1650000000000);\n            const { feeWithDetails, quotesWithGasFee, ammQuoteUniqueId } = await feeService.calculateFeeAsync(\n                {\n                    workflow,\n                    chainId: 1337,\n                    feeModelVersion,\n                    txOrigin,\n                    makerToken,\n                    takerToken,\n                    originalMakerToken: makerToken,\n                    makerTokenDecimals,\n                    takerTokenDecimals,\n                    isUnwrap,\n                    isSelling,\n                    assetFillAmount,\n                    takerAmount: assetFillAmount,\n                    isFirm: true,\n                    takerAddress,\n                    trader: takerAddress,\n                    integrator,\n                },\n                async () => {\n                    return Promise.resolve(mmQuotes);\n                },\n            );\n\n            // Then\n            const expectedGasFeeAmount = gasPrice.times(gasEstimate);\n\n            const expectedFee: FeeWithDetails = {\n                type: 'fixed',\n                token: feeTokenAddress,\n                amount: expectedGasFeeAmount,\n                details: {\n                    kind: 'margin',\n                    feeModelVersion,\n                    gasFeeAmount: expectedGasFeeAmount,\n                    gasPrice,\n                    zeroExFeeAmount: ZERO,\n                    margin: ZERO,\n                    marginRakeRatio,\n                    feeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: makerTokenPrice,\n                },\n                breakdown: {\n                    gas: {\n                        amount: expectedGasFeeAmount,\n                        details: {\n                            gasPrice,\n                            estimatedGas: new BigNumber(gasEstimate),\n                        },\n                    },\n                    zeroEx: {\n                        amount: ZERO,\n                        details: {\n                            kind: 'price_improvement',\n                            priceImprovement: ZERO,\n                            rakeRatio: marginRakeRatio,\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    feeTokenBaseUnitPriceUsd: feeTokenPrice,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: makerTokenPrice,\n                },\n            };\n            expect(feeWithDetails).toMatchObject(expectedFee);\n            expect(quotesWithGasFee).toMatchObject(mmQuotes);\n            expect(ammQuoteUniqueId).toBe(decodedUniqueId);\n        });\n        it('should throw if called from RFQt workflow', async () => {\n            // Given\n            const isSelling = true;\n            const isUnwrap = false;\n            const assetFillAmount = new BigNumber(1e18);\n            const marginRakeRatio = 0.5;\n\n            const ammMakerAmount = new BigNumber(3450e6);\n            const expectedSlippage = new BigNumber(-0.01);\n            const estimatedAmmGasFeeWei = new BigNumber(100e9);\n            const decodedUniqueId = '1234-5678';\n            const ammQuote: AmmQuote = {\n                makerAmount: ammMakerAmount,\n                takerAmount: assetFillAmount,\n                expectedSlippage,\n                estimatedGasFeeWei: estimatedAmmGasFeeWei,\n                decodedUniqueId,\n            };\n\n            const feeService: FeeService = buildFeeService({\n                feeModelConfiguration: {\n                    marginRakeRatio,\n                    tradeSizeBps: 0,\n                },\n                gasPrice,\n                tradeTokenPrice: makerTokenPrice,\n                feeTokenPrice,\n                ammQuote,\n            });\n\n            const quoteContext: QuoteContext = {\n                workflow: 'rfqt',\n                chainId: 1337,\n                isFirm: true,\n                feeModelVersion,\n                txOrigin,\n                makerToken,\n                takerToken,\n                originalMakerToken: makerToken,\n                makerTokenDecimals,\n                takerTokenDecimals,\n                isUnwrap,\n                isSelling,\n                assetFillAmount,\n                takerAmount: assetFillAmount,\n                takerAddress,\n                trader: takerAddress,\n                integrator,\n            };\n\n            // When\n            await expect(() => feeService.calculateFeeAsync(quoteContext)).rejects.toThrow('Not implemented');\n        });\n    });\n\n    describe('pure function calculateDefaultFeeAmount()', () => {\n        it('should calculate default fee amount correctly', async () => {\n            // Given\n            const tradeTokenAmount = new BigNumber(1e18);\n            const feeRateBps = 5;\n            const tradeTokenBaseUnitPriceUsd = new BigNumber(6e-14);\n            const feeTokenBaseUnitPriceUsd = new BigNumber(3e-15);\n\n            // When\n            const defaultFeeAmount = calculateDefaultFeeAmount(\n                tradeTokenAmount,\n                feeRateBps,\n                tradeTokenBaseUnitPriceUsd,\n                feeTokenBaseUnitPriceUsd,\n            );\n\n            // Then\n            const expectedDefaultFeeAmount = new BigNumber(1e16);\n            expect(defaultFeeAmount).toMatchObject(expectedDefaultFeeAmount);\n        });\n        it('should return zero if bps is zero', async () => {\n            // Given\n            const tradeTokenAmount = new BigNumber(1e18);\n            const feeRateBps = 0;\n            const tradeTokenBaseUnitPriceUsd = new BigNumber(6e-14);\n            const feeTokenBaseUnitPriceUsd = new BigNumber(3e-15);\n\n            // When\n            const defaultFeeAmount = calculateDefaultFeeAmount(\n                tradeTokenAmount,\n                feeRateBps,\n                tradeTokenBaseUnitPriceUsd,\n                feeTokenBaseUnitPriceUsd,\n            );\n\n            // Then\n            expect(defaultFeeAmount).toMatchObject(ZERO);\n        });\n        it('should return zero if either trade token price or fee token price is null', async () => {\n            // Given\n            const tradeTokenAmount = new BigNumber(1e18);\n            const feeRateBps = 5;\n            const tradeTokenBaseUnitPriceUsd = new BigNumber(6e-14);\n            const feeTokenBaseUnitPriceUsd = new BigNumber(3e-15);\n\n            // When\n            const defaultFeeAmount1 = calculateDefaultFeeAmount(\n                tradeTokenAmount,\n                feeRateBps,\n                null,\n                feeTokenBaseUnitPriceUsd,\n            );\n            const defaultFeeAmount2 = calculateDefaultFeeAmount(\n                tradeTokenAmount,\n                feeRateBps,\n                tradeTokenBaseUnitPriceUsd,\n                null,\n            );\n\n            // Then\n            expect(defaultFeeAmount1).toMatchObject(ZERO);\n            expect(defaultFeeAmount2).toMatchObject(ZERO);\n        });\n    });\n    describe('pure function calculatePriceImprovementAmount()', () => {\n        it('should calculate price improvement amount for selling correctly', async () => {\n            // Given\n            const isSelling = true;\n            const assetFillAmount = new BigNumber(3e17);\n            const makerQuoteWithGasFee: IndicativeQuote = {\n                maker: 'maker1Address',\n                makerUri: 'http://maker1.com',\n                makerToken,\n                takerToken,\n                makerAmount: new BigNumber(1100e6),\n                takerAmount: assetFillAmount,\n                expiry: new BigNumber(1652722767),\n            };\n\n            const ammQuote: AmmQuote = {\n                makerAmount: new BigNumber(1000e6),\n                takerAmount: assetFillAmount,\n                expectedSlippage: new BigNumber(-0.02),\n                estimatedGasFeeWei: new BigNumber(10e15),\n            };\n\n            const quoteTokenBaseUnitPriceUsd = new BigNumber(1e-6);\n            const feeTokenBaseUnitPriceUsd = new BigNumber(3e-15);\n\n            // When\n            const priceImprovementAmount = calculatePriceImprovementAmount(\n                makerQuoteWithGasFee,\n                ammQuote,\n                isSelling,\n                quoteTokenBaseUnitPriceUsd,\n                feeTokenBaseUnitPriceUsd,\n            );\n\n            // Then\n            const expectedPriceImprovementAmount = new BigNumber(50e15);\n            expect(priceImprovementAmount).toMatchObject(expectedPriceImprovementAmount);\n        });\n        it('should calculate price improvement amount for buying correctly', async () => {\n            // Given\n            const isSelling = false;\n            const assetFillAmount = new BigNumber(3e17);\n            const makerQuoteWithGasFee: IndicativeQuote = {\n                maker: 'maker1Address',\n                makerUri: 'http://maker1.com',\n                makerToken,\n                takerToken,\n                makerAmount: assetFillAmount,\n                takerAmount: new BigNumber(900e6),\n                expiry: new BigNumber(1652722767),\n            };\n\n            const ammQuote: AmmQuote = {\n                makerAmount: assetFillAmount,\n                takerAmount: new BigNumber(1000e6),\n                expectedSlippage: new BigNumber(-0.02),\n                estimatedGasFeeWei: new BigNumber(10e15),\n            };\n\n            const quoteTokenBaseUnitPriceUsd = new BigNumber(1e-6);\n            const feeTokenBaseUnitPriceUsd = new BigNumber(3e-15);\n\n            // When\n            const priceImprovementAmount = calculatePriceImprovementAmount(\n                makerQuoteWithGasFee,\n                ammQuote,\n                isSelling,\n                quoteTokenBaseUnitPriceUsd,\n                feeTokenBaseUnitPriceUsd,\n            );\n\n            // Then\n            const expectedPriceImprovementAmount = new BigNumber(50e15);\n            expect(priceImprovementAmount).toMatchObject(expectedPriceImprovementAmount);\n        });\n        it('should return zero if there is no price improvement', async () => {\n            // Given\n            const isSelling = false;\n            const assetFillAmount = new BigNumber(3e17);\n            const makerQuoteWithGasFee: IndicativeQuote = {\n                maker: 'maker1Address',\n                makerUri: 'http://maker1.com',\n                makerToken,\n                takerToken,\n                makerAmount: assetFillAmount,\n                takerAmount: new BigNumber(1051e6),\n                expiry: new BigNumber(1652722767),\n            };\n\n            const ammQuote: AmmQuote = {\n                makerAmount: assetFillAmount,\n                takerAmount: new BigNumber(1000e6),\n                expectedSlippage: new BigNumber(-0.02),\n                estimatedGasFeeWei: new BigNumber(10e15),\n            };\n\n            const quoteTokenBaseUnitPriceUsd = new BigNumber(1e-6);\n            const feeTokenBaseUnitPriceUsd = new BigNumber(3e-15);\n\n            // When\n            const priceImprovementAmount = calculatePriceImprovementAmount(\n                makerQuoteWithGasFee,\n                ammQuote,\n                isSelling,\n                quoteTokenBaseUnitPriceUsd,\n                feeTokenBaseUnitPriceUsd,\n            );\n\n            // Then\n            expect(priceImprovementAmount).toMatchObject(ZERO);\n        });\n    });\n    describe('pure function reviseQuoteWithZeroExFee()', () => {\n        it('should revise quote correctly for selling', async () => {\n            // Given\n            const isSelling = true;\n            const assetFillAmount = new BigNumber(3e17);\n            const makerQuoteWithGasFee: IndicativeQuote = {\n                maker: 'maker1Address',\n                makerUri: 'http://maker1.com',\n                makerToken,\n                takerToken,\n                makerAmount: new BigNumber(1000e6),\n                takerAmount: assetFillAmount,\n                expiry: new BigNumber(1652722767),\n            };\n\n            const zeroExFeeAmount = new BigNumber(10e15);\n\n            const quoteTokenBaseUnitPriceUsd = new BigNumber(1e-6);\n            const feeTokenBaseUnitPriceUsd = new BigNumber(3e-15);\n\n            // When\n            const revisedQuote = reviseQuoteWithFees(\n                makerQuoteWithGasFee,\n                zeroExFeeAmount,\n                isSelling,\n                quoteTokenBaseUnitPriceUsd,\n                feeTokenBaseUnitPriceUsd,\n            );\n\n            // Then\n            const expectedRevisedMakerAmount = new BigNumber(970e6);\n            expect(revisedQuote.makerAmount).toMatchObject(expectedRevisedMakerAmount);\n        });\n        it('should revise quote correctly for buying', async () => {\n            // Given\n            const isSelling = false;\n            const assetFillAmount = new BigNumber(3e17);\n            const makerQuoteWithGasFee: IndicativeQuote = {\n                maker: 'maker1Address',\n                makerUri: 'http://maker1.com',\n                makerToken,\n                takerToken,\n                makerAmount: assetFillAmount,\n                takerAmount: new BigNumber(1000e6),\n                expiry: new BigNumber(1652722767),\n            };\n\n            const zeroExFeeAmount = new BigNumber(10e15);\n\n            const quoteTokenBaseUnitPriceUsd = new BigNumber(1e-6);\n            const feeTokenBaseUnitPriceUsd = new BigNumber(3e-15);\n\n            // When\n            const revisedQuote = reviseQuoteWithFees(\n                makerQuoteWithGasFee,\n                zeroExFeeAmount,\n                isSelling,\n                quoteTokenBaseUnitPriceUsd,\n                feeTokenBaseUnitPriceUsd,\n            );\n\n            // Then\n            const expectedRevisedTakerAmount = new BigNumber(1030e6);\n            expect(revisedQuote.takerAmount).toMatchObject(expectedRevisedTakerAmount);\n        });\n        it('should not revise quote correctly for zero zeroExFee', async () => {\n            // Given\n            const isSelling = true;\n            const assetFillAmount = new BigNumber(3e17);\n            const makerQuoteWithGasFee: IndicativeQuote = {\n                maker: 'maker1Address',\n                makerUri: 'http://maker1.com',\n                makerToken,\n                takerToken,\n                makerAmount: new BigNumber(1000e6),\n                takerAmount: assetFillAmount,\n                expiry: new BigNumber(1652722767),\n            };\n\n            const zeroExFeeAmount = ZERO;\n\n            const quoteTokenBaseUnitPriceUsd = new BigNumber(1e-6);\n            const feeTokenBaseUnitPriceUsd = new BigNumber(3e-15);\n\n            // When\n            const revisedQuote = reviseQuoteWithFees(\n                makerQuoteWithGasFee,\n                zeroExFeeAmount,\n                isSelling,\n                quoteTokenBaseUnitPriceUsd,\n                feeTokenBaseUnitPriceUsd,\n            );\n\n            // Then\n            const expectedRevisedMakerAmount = new BigNumber(1000e6);\n            expect(revisedQuote.makerAmount).toMatchObject(expectedRevisedMakerAmount);\n            expect(revisedQuote.takerAmount).toMatchObject(assetFillAmount);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantEthereum.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType2.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { AxiosInstance } from 'axios';\nimport { Summary } from 'prom-client';\n\nimport { logger } from '../logger';\n\n/**\n * With this summary metric, some of the things you can do are:\n * - Get the rate of failed price fetch requests:\n *      rate(rfq_token_price_fetch_request_duration_seconds_count{success=\"false\"}[5m])\n * - Get the rate of success price fetch requests:\n *      rate(rfq_token_price_fetch_request_duration_seconds_count{success=\"true\"}[5m])\n * - Get the p95 of request duration of all success price fetch (with the sliding window of 1 minute):\n *      rfq_token_price_fetch_request_duration_seconds{quantile=\"0.99\", success=\"true\"}\n */\nconst RFQ_TOKEN_PRICE_FETCH_REQUEST_DURATION_SECONDS = new Summary({\n    name: 'rfq_token_price_fetch_request_duration_seconds',\n    help: 'Histogram of request duration of token price fetch request',\n    percentiles: [0.5, 0.9, 0.95, 0.99, 0.999], // tslint:disable-line: custom-no-magic-numbers\n    labelNames: ['chainId', 'success'],\n    // Set sliding window to 1 minutes\n    maxAgeSeconds: 60,\n    // The more number of age buckets, the smoother the time window is moved\n    // but it also consumes more memory & CPU for maintaining the bucket.\n    ageBuckets: 5,\n});\n\nexport interface FetchTokenPriceParams {\n    chainId: number;\n    /**\n     * Must be a valid ERC-20 contract address\n     */\n    tokenAddress: string;\n    tokenDecimals: number;\n}\n\ntype TokenPriceFetchResponse = BigNumber | null;\n\nexport class TokenPriceOracle {\n    /**\n     * In-memory cache implementation for token price. A map with:\n     * - Key is `${chainId}:${tokenAddress}`\n     * - Value is a 2-items array with the first item is cache expiry timestamp (ms), second item\n     *   is the cached response.\n     */\n    private readonly _tokenPriceCache: Map<string, [number, TokenPriceFetchResponse]>;\n\n    public constructor(\n        private readonly _axiosInstance: AxiosInstance,\n        private readonly _definedFiApiKey: string,\n        private readonly _definedFiEndpoint: string,\n        private readonly _cacheTTLMs: number = 20000,\n    ) {\n        if (!_definedFiApiKey) {\n            throw new Error('Missing Defined.Fi API Key');\n        }\n        this._tokenPriceCache = new Map();\n    }\n\n    /**\n     * Fetch the current price of multiple tokens. The returned array will be a list\n     * of result for each item in passed via params in the same order.\n     */\n    public async batchFetchTokenPriceAsync(params: FetchTokenPriceParams[]): Promise<TokenPriceFetchResponse[]> {\n        // Note: we can actually batching the getPrice requests in a single GraphQL query\n        // but this is for future improvement. For now, batching via sending multiple graphql requests\n        // in parallel should be sufficient\n        return Promise.all(params.map((p) => this._fetchTokenPriceCachedAsync(p)));\n    }\n\n    private async _fetchTokenPriceCachedAsync(params: FetchTokenPriceParams): Promise<TokenPriceFetchResponse> {\n        const cacheKey = `${params.chainId}:${params.tokenAddress}`;\n        const cacheData = this._tokenPriceCache.get(cacheKey);\n        if (cacheData && cacheData[0] > Date.now()) {\n            return cacheData[1];\n        }\n        const freshData = await this._fetchTokenPriceAsync(params);\n        this._tokenPriceCache.set(cacheKey, [Date.now() + this._cacheTTLMs, freshData]);\n        return freshData;\n    }\n\n    private async _fetchTokenPriceAsync(params: FetchTokenPriceParams): Promise<TokenPriceFetchResponse> {\n        const stopTimer = RFQ_TOKEN_PRICE_FETCH_REQUEST_DURATION_SECONDS.startTimer({\n            chainId: params.chainId.toString(),\n        });\n        try {\n            const { data } = await this._axiosInstance.post(\n                this._definedFiEndpoint,\n                {\n                    query: `\n                        query getPrice {\n                            getPrice(address: \"${params.tokenAddress}\", networkId: ${params.chainId}) {\n                              priceUsd\n                            }\n                        }\n                    `,\n                },\n                {\n                    headers: { 'x-api-key': this._definedFiApiKey },\n                },\n            );\n\n            const priceInUsd = data?.data?.getPrice?.priceUsd || null;\n            logger.info(\n                {\n                    priceInUsd,\n                    params,\n                },\n                'price and params in `_fetchTokenPriceAsync`',\n            );\n            if (!priceInUsd) {\n                throw new Error(`Got 200 but without price value. Response body: ${JSON.stringify(data)}`);\n            }\n\n            stopTimer({ success: 'true' });\n            return new BigNumber(priceInUsd).shiftedBy(params.tokenDecimals * -1); // USD price of 1 base unit\n        } catch (error) {\n            logger.error({ ...params, message: error.message }, 'Failed to fetch token price');\n\n            stopTimer({ success: 'false' });\n            return null;\n        }\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/rfqm_test.ts",{"fileContent":"// tslint:disable:max-file-line-count custom-no-magic-numbers\nimport { ContractAddresses } from '@0x/contract-addresses';\nimport { ethSignHashWithKey, MetaTransaction, OtcOrder, SignatureType } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { Web3Wrapper } from '@0x/web3-wrapper';\nimport Axios, { AxiosInstance } from 'axios';\nimport AxiosMockAdapter from 'axios-mock-adapter';\nimport { expect } from 'chai';\nimport { TransactionReceiptStatus } from 'ethereum-types';\nimport { BigNumber as EthersBigNumber, ethers } from 'ethers';\nimport { Server } from 'http';\nimport * as HttpStatus from 'http-status-codes';\nimport Redis from 'ioredis';\nimport { Producer } from 'sqs-producer';\nimport * as request from 'supertest';\nimport { anyString, anything, deepEqual, instance, mock, when } from 'ts-mockito';\nimport { DataSource } from 'typeorm';\n\nimport * as config from '../src/config';\nimport {\n    ADMIN_PATH,\n    DEFAULT_MIN_EXPIRY_DURATION_MS,\n    ETH_DECIMALS,\n    ONE_MINUTE_MS,\n    ONE_SECOND_MS,\n    RFQM_PATH,\n    ZERO,\n} from '../src/core/constants';\nimport { RfqmV2JobEntity, RfqmV2QuoteEntity } from '../src/entities';\nimport { RfqmJobStatus, RfqmOrderTypes, StoredOtcOrder } from '../src/entities/types';\nimport {\n    buildRfqAdminService,\n    buildRfqMakerService,\n    runHttpRfqmServiceAsync,\n} from '../src/runners/http_rfqm_service_runner';\nimport { FeeService } from '../src/services/fee_service';\nimport { RfqmService } from '../src/services/rfqm_service';\nimport { RfqMakerBalanceCacheService } from '../src/services/rfq_maker_balance_cache_service';\nimport { GaslessApprovalTypes, GaslessTypes, PermitEip712Types, StoredFee } from '../src/core/types';\nimport { CacheClient } from '../src/utils/cache_client';\nimport { ConfigManager } from '../src/utils/config_manager';\nimport { QuoteServerClient } from '../src/utils/quote_server_client';\nimport { RfqmDbUtils, storedOtcOrderToOtcOrder } from '../src/utils/rfqm_db_utils';\nimport { RfqBlockchainUtils } from '../src/utils/rfq_blockchain_utils';\nimport { RfqMakerDbUtils } from '../src/utils/rfq_maker_db_utils';\nimport { RfqMakerManager } from '../src/utils/rfq_maker_manager';\nimport { BLOCK_FINALITY_THRESHOLD } from '../src/utils/SubmissionContext';\nimport { TokenMetadataManager } from '../src/utils/TokenMetadataManager';\n\nimport {\n    CONTRACT_ADDRESSES,\n    getProvider,\n    MATCHA_AFFILIATE_ADDRESS,\n    MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n    MOCK_PERMIT_APPROVAL,\n    TEST_DECODED_RFQ_ORDER_FILLED_EVENT_LOG,\n    TEST_RFQ_ORDER_FILLED_EVENT_LOG,\n} from './constants';\nimport { setupDependenciesAsync, TeardownDependenciesFunctionHandle } from './test_utils/deployment';\nimport { initDbDataSourceAsync } from './test_utils/initDbDataSourceAsync';\n\nconst MOCK_WORKER_REGISTRY_ADDRESS = '0x1023331a469c6391730ff1E2749422CE8873EC38';\nconst API_KEY = 'koolApiKey';\nconst ADMIN_API_KEY = 'adminApiKey';\nconst INTEGRATOR_ID = 'koolIntegratorId';\nconst contractAddresses: ContractAddresses = CONTRACT_ADDRESSES;\nconst WORKER_FULL_BALANCE_WEI = new BigNumber(1).shiftedBy(ETH_DECIMALS);\n\n// RFQM Market Maker request specific constants\nconst MARKET_MAKER_1 = 'https://mock-rfqt1.club';\nconst MARKET_MAKER_2 = 'https://mock-rfqt2.club';\nconst MARKET_MAKER_3 = 'https://mock-rfqt3.club';\nconst MARKET_MAKER_2_ADDR = '0xbEA29fE10caed0E1a65A7AdBddd254dD372e83Ff';\nconst MARKET_MAKER_3_ADDR = '0xA84f003D3a6F62c5dF218c7fb7b0EFB766b5AC07';\nconst GAS_PRICE = new BigNumber(100);\n\nconst MOCK_META_TX_CALL_DATA = '0x123';\nconst RANDOM_VALID_SIGNATURE = {\n    r: '0x72ba2125d4efe1f9cc77882138ed94cbd485f8897fe6d9fe34854906634fc59d',\n    s: '0x1e19d3d29ab2855debc62a1df98a727673b8bf31c4da3a391a6eaea465920ff2',\n    v: 27,\n    signatureType: SignatureType.EthSign,\n};\nconst SAFE_EXPIRY = '1903620548';\nconst GAS_ESTIMATE = 165000;\nconst WORKER_ADDRESS = '0xaWorkerAddress';\nconst FIRST_TRANSACTION_HASH = '0xfirstTxHash';\nconst FIRST_SIGNED_TRANSACTION = '0xfirstSignedTransaction';\nconst TX_STATUS: TransactionReceiptStatus = 1;\n// it's over 9K\nconst MINED_BLOCK = 9001;\n// the tx should be finalized\nconst CURRENT_BLOCK = MINED_BLOCK + BLOCK_FINALITY_THRESHOLD;\nconst MOCK_EXCHANGE_PROXY = '0xtheExchangeProxy';\nconst SUCCESSFUL_TRANSACTION_RECEIPT = {\n    blockHash: '0xaBlockHash',\n    blockNumber: MINED_BLOCK,\n    byzantium: true,\n    confirmations: 2,\n    contractAddress: '',\n    cumulativeGasUsed: EthersBigNumber.from(150000),\n    effectiveGasPrice: EthersBigNumber.from(1000),\n    from: WORKER_ADDRESS,\n    gasUsed: EthersBigNumber.from(GAS_ESTIMATE),\n    logs: [TEST_RFQ_ORDER_FILLED_EVENT_LOG],\n    logsBloom: '',\n    status: TX_STATUS,\n    to: MOCK_EXCHANGE_PROXY,\n    transactionHash: FIRST_TRANSACTION_HASH,\n    transactionIndex: 5,\n    type: 2,\n};\n\nconst MOCK_RFQM_JOB = new RfqmV2JobEntity({\n    chainId: 1337,\n    createdAt: new Date(),\n    expiry: new BigNumber(Date.now()),\n    fee: {\n        amount: '1000',\n        token: '0x123',\n        type: 'fixed',\n    },\n    integratorId: null,\n    makerUri: MARKET_MAKER_1,\n    order: {\n        order: {\n            chainId: '1337',\n            expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                new BigNumber(SAFE_EXPIRY),\n                ZERO,\n                new BigNumber(SAFE_EXPIRY),\n            ).toString(),\n            maker: '0x123',\n            makerAmount: '1',\n            makerToken: '0x123',\n            taker: '0x123',\n            takerAmount: '1',\n            takerToken: '0x123',\n            txOrigin: '0x123',\n            verifyingContract: '0x123',\n        },\n        type: RfqmOrderTypes.Otc,\n    },\n    orderHash: '0x288d4d771179738ee9ca60f14df74612fb1ca43dfbc3bbb49dd9226a19747c11',\n    status: RfqmJobStatus.PendingSubmitted,\n    updatedAt: new Date(),\n    workerAddress: null,\n    lastLookResult: null,\n    affiliateAddress: MATCHA_AFFILIATE_ADDRESS,\n    takerSpecifiedSide: 'makerToken',\n});\n\njest.setTimeout(ONE_MINUTE_MS * 2);\nlet teardownDependencies: TeardownDependenciesFunctionHandle;\n\ndescribe('RFQM Integration', () => {\n    let app: Express.Application;\n    let axiosClient: AxiosInstance;\n    let cacheClient: CacheClient;\n    let dataSource: DataSource;\n    let dbUtils: RfqmDbUtils;\n    let mockAxios: AxiosMockAdapter;\n    let rfqBlockchainUtilsMock: RfqBlockchainUtils;\n    let rfqmServiceChainId1337: RfqmService;\n    let rfqmServiceChainId3: RfqmService;\n    let server: Server;\n    let takerAddress: string;\n\n    beforeAll(async () => {\n        teardownDependencies = await setupDependenciesAsync(['postgres', 'ganache', 'redis']);\n\n        // Create a Provider\n        const provider = getProvider();\n        const web3Wrapper = new Web3Wrapper(provider);\n        [takerAddress] = await web3Wrapper.getAvailableAddressesAsync();\n\n        // Build dependencies\n        // Create the mock FeeService\n        const feeServiceMock = mock(FeeService);\n        when(feeServiceMock.getGasPriceEstimationAsync()).thenResolve(GAS_PRICE);\n        when(feeServiceMock.calculateFeeAsync(anything(), anything())).thenResolve({\n            feeWithDetails: {\n                token: '0xToken',\n                amount: new BigNumber(300),\n                type: 'fixed',\n                details: {\n                    feeModelVersion: 1,\n                    kind: 'default',\n                    gasFeeAmount: new BigNumber(100),\n                    gasPrice: GAS_PRICE,\n                    zeroExFeeAmount: new BigNumber(200),\n                    tradeSizeBps: 4,\n                    feeTokenBaseUnitPriceUsd: new BigNumber(30),\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: new BigNumber(20),\n                },\n                breakdown: {\n                    gas: {\n                        amount: new BigNumber(100),\n                        details: {\n                            gasPrice: GAS_PRICE,\n                            estimatedGas: new BigNumber(1),\n                        },\n                    },\n                    zeroEx: {\n                        amount: new BigNumber(200),\n                        details: {\n                            kind: 'volume',\n                            tradeSizeBps: 4,\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: new BigNumber(30),\n                    feeTokenBaseUnitPriceUsd: new BigNumber(30),\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: new BigNumber(20),\n                },\n            },\n        });\n        const feeServiceInstance = instance(feeServiceMock);\n\n        // Create the mock ConfigManager\n        const configManagerMock = mock(ConfigManager);\n        when(configManagerMock.getAdminApiKey()).thenReturn(ADMIN_API_KEY);\n        when(configManagerMock.getRfqmApiKeyWhitelist()).thenReturn(new Set([API_KEY]));\n        when(configManagerMock.getIntegratorIdForApiKey(API_KEY)).thenReturn(INTEGRATOR_ID);\n        when(configManagerMock.getIntegratorByIdOrThrow(INTEGRATOR_ID)).thenReturn({\n            integratorId: INTEGRATOR_ID,\n            apiKeys: [API_KEY],\n            allowedChainIds: [1337],\n            label: 'Test',\n            rfqm: true,\n            plp: false,\n            rfqt: false,\n        });\n        const configManager = instance(configManagerMock);\n\n        // Create Axios client and mock\n        axiosClient = Axios.create();\n        mockAxios = new AxiosMockAdapter(axiosClient);\n\n        // Create the mock rfqBlockchainUtils\n        const validationResponse: [BigNumber, BigNumber] = [new BigNumber(1), new BigNumber(1)];\n        rfqBlockchainUtilsMock = mock(RfqBlockchainUtils);\n        when(\n            rfqBlockchainUtilsMock.generateMetaTransaction(anything(), anything(), anything(), anything(), anything()),\n        ).thenCall((_rfqOrder, _signature, _taker, _takerAmount, chainId) => new MetaTransaction({ chainId }));\n        when(rfqBlockchainUtilsMock.generateMetaTransactionCallData(anything(), anything(), anything())).thenReturn(\n            MOCK_META_TX_CALL_DATA,\n        );\n        when(\n            rfqBlockchainUtilsMock.validateMetaTransactionOrThrowAsync(anything(), anything(), anything(), anything()),\n        ).thenResolve(validationResponse);\n        when(rfqBlockchainUtilsMock.getTokenBalancesAsync(anything())).thenResolve([new BigNumber(1)]);\n        when(rfqBlockchainUtilsMock.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([new BigNumber(1)]);\n        when(rfqBlockchainUtilsMock.getNonceAsync(anything())).thenResolve(1);\n        when(rfqBlockchainUtilsMock.estimateGasForAsync(anything())).thenResolve(GAS_ESTIMATE);\n        when(rfqBlockchainUtilsMock.signTransactionAsync(anything())).thenResolve({\n            signedTransaction: FIRST_SIGNED_TRANSACTION,\n            transactionHash: FIRST_TRANSACTION_HASH,\n        });\n        when(rfqBlockchainUtilsMock.submitSignedTransactionAsync(FIRST_SIGNED_TRANSACTION)).thenResolve(\n            FIRST_TRANSACTION_HASH,\n        );\n        when(rfqBlockchainUtilsMock.getReceiptsAsync(deepEqual([FIRST_TRANSACTION_HASH]))).thenResolve([\n            SUCCESSFUL_TRANSACTION_RECEIPT,\n        ]);\n        when(rfqBlockchainUtilsMock.getCurrentBlockAsync()).thenResolve(CURRENT_BLOCK);\n        when(rfqBlockchainUtilsMock.getExchangeProxyAddress()).thenReturn(MOCK_EXCHANGE_PROXY);\n        when(\n            rfqBlockchainUtilsMock.decodeMetaTransactionCallDataAndValidateAsync(anyString(), anyString(), anything()),\n        ).thenResolve(validationResponse);\n        when(rfqBlockchainUtilsMock.getDecodedRfqOrderFillEventLogFromLogs(anything())).thenReturn(\n            TEST_DECODED_RFQ_ORDER_FILLED_EVENT_LOG,\n        );\n        when(rfqBlockchainUtilsMock.getAccountBalanceAsync(MOCK_WORKER_REGISTRY_ADDRESS)).thenResolve(\n            WORKER_FULL_BALANCE_WEI,\n        );\n        const rfqBlockchainUtils = instance(rfqBlockchainUtilsMock);\n\n        const tokenMetadataManagerMock = mock(TokenMetadataManager);\n        when(tokenMetadataManagerMock.getTokenDecimalsAsync(anything())).thenResolve(18);\n        const tokenMetadataManager = instance(tokenMetadataManagerMock);\n\n        interface SqsResponse {\n            Id: string;\n            MD5OfMessageBody: string;\n            MessageId: string;\n        }\n        const sqsResponse: SqsResponse[] = [\n            {\n                Id: 'id',\n                MD5OfMessageBody: 'MD5OfMessageBody',\n                MessageId: 'MessageId',\n            },\n        ];\n\n        // Create the dbUtils\n        dataSource = await initDbDataSourceAsync();\n        dbUtils = new RfqmDbUtils(dataSource);\n\n        // Create the mock sqsProducer\n        const sqsProducerMock = mock(Producer);\n        when(sqsProducerMock.send(anything())).thenResolve(sqsResponse);\n        when(sqsProducerMock.queueSize()).thenResolve(0);\n        const sqsProducer = instance(sqsProducerMock);\n\n        // Create the quote server client\n        const quoteServerClient = new QuoteServerClient(axiosClient);\n\n        // Create the CacheClient\n        const redis = new Redis();\n        cacheClient = new CacheClient(redis);\n\n        // Create the maker balance cache service\n        const rfqMakerBalanceCacheServiceMock = mock(RfqMakerBalanceCacheService);\n        when(rfqMakerBalanceCacheServiceMock.getERC20OwnerBalancesAsync(anything(), anything())).thenResolve(\n            [new BigNumber(200000000000000000)],\n            [new BigNumber(200000000000000000), new BigNumber(200000000000000000)],\n        );\n        const rfqMakerBalanceCacheService = instance(rfqMakerBalanceCacheServiceMock);\n\n        // Create the mock RfqMakerManager\n        const rfqMakerManagerMock = mock(RfqMakerManager);\n        when(\n            rfqMakerManagerMock.getRfqmV2MakerUrisForPair(anyString(), anyString(), anything(), anything()),\n        ).thenReturn([MARKET_MAKER_2, MARKET_MAKER_3]);\n        when(rfqMakerManagerMock.getRfqmV2MakerOfferings()).thenReturn({\n            'https://mock-rfqm1.club': [\n                ['0x871dd7c2b4b25e1aa18728e9d5f2af4c4e431f5c', '0x0b1ba0af832d7c05fd64161e0db78e85978e8082'],\n            ],\n        });\n        const rfqMakerManager = instance(rfqMakerManagerMock);\n        rfqmServiceChainId1337 = new RfqmService(\n            1337,\n            feeServiceInstance,\n            /* feeModelVersion */ 0,\n            contractAddresses,\n            MOCK_WORKER_REGISTRY_ADDRESS,\n            rfqBlockchainUtils,\n            dbUtils,\n            sqsProducer,\n            quoteServerClient,\n            DEFAULT_MIN_EXPIRY_DURATION_MS,\n            cacheClient,\n            rfqMakerBalanceCacheService,\n            rfqMakerManager,\n            tokenMetadataManager,\n        );\n\n        // Create another RFQM Service for chain ID 3 that returns 0 offering\n        const rfqMakerManagerChain3Mock = mock(RfqMakerManager);\n        when(rfqMakerManagerChain3Mock.getRfqmV2MakerOfferings()).thenReturn({\n            'https://mock-rfqm1.club': [],\n        });\n        const rfqMakerManagerChainId3 = instance(rfqMakerManagerChain3Mock);\n        rfqmServiceChainId3 = new RfqmService(\n            3,\n            feeServiceInstance,\n            /* feeModelVersion */ 0,\n            contractAddresses,\n            MOCK_WORKER_REGISTRY_ADDRESS,\n            rfqBlockchainUtils,\n            dbUtils,\n            sqsProducer,\n            quoteServerClient,\n            DEFAULT_MIN_EXPIRY_DURATION_MS,\n            cacheClient,\n            rfqMakerBalanceCacheService,\n            rfqMakerManagerChainId3,\n            tokenMetadataManager,\n        );\n\n        const rfqAdminService = buildRfqAdminService(dbUtils);\n        const rfqMakerService = buildRfqMakerService(new RfqMakerDbUtils(dataSource), configManager);\n\n        // Start the server\n        const res = await runHttpRfqmServiceAsync(\n            new Map([\n                [1337, rfqmServiceChainId1337],\n                [3, rfqmServiceChainId3],\n            ]),\n            new Map(),\n            rfqAdminService,\n            rfqMakerService,\n            configManager,\n            config.defaultHttpServiceConfig,\n            dataSource,\n            false,\n        );\n        app = res.app;\n        server = res.server;\n    });\n\n    afterEach(async () => {\n        await dataSource.query('TRUNCATE TABLE rfqm_quotes CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_jobs CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_transaction_submissions CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_v2_quotes CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_v2_jobs CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_v2_transaction_submissions CASCADE;');\n    });\n\n    afterAll(async () => {\n        await new Promise<void>((resolve, reject) => {\n            server.close((err?: Error) => {\n                if (err) {\n                    reject(err);\n                }\n                resolve();\n            });\n        });\n        await cacheClient.closeAsync();\n        if (!teardownDependencies()) {\n            throw new Error('Failed to tear down dependencies');\n        }\n    });\n\n    describe('rfqm/v1/healthz', () => {\n        it('should return a 200 OK with active pairs', async () => {\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/healthz`)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.OK)\n                .expect('Content-Type', /json/);\n            expect(appResponse.body.pairs[0][0]).to.equal('0x0b1ba0af832d7c05fd64161e0db78e85978e8082');\n            expect(appResponse.body.pairs[0][1]).to.equal('0x871dd7c2b4b25e1aa18728e9d5f2af4c4e431f5c');\n        });\n\n        // This test is to cover this issue: https://github.com/0xProject/0x-rfq-api/pull/200\n        it('should return correct values for different chains', async () => {\n            const chainId3HealthzResponse = await request(app)\n                .get(`${RFQM_PATH}/healthz`)\n                .set('0x-chain-id', '3')\n                .expect(HttpStatus.OK)\n                .expect('Content-Type', /json/);\n            // tslint:disable-next-line: no-unused-expression\n            expect(chainId3HealthzResponse.body.pairs).to.be.an('array').that.is.empty;\n\n            const chainId1337HealthzResponse = await request(app)\n                .get(`${RFQM_PATH}/healthz`)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.OK)\n                .expect('Content-Type', /json/);\n            expect(chainId1337HealthzResponse.body.pairs[0][0]).to.equal('0x0b1ba0af832d7c05fd64161e0db78e85978e8082');\n            expect(chainId1337HealthzResponse.body.pairs[0][1]).to.equal('0x871dd7c2b4b25e1aa18728e9d5f2af4c4e431f5c');\n        });\n    });\n\n    describe('rfqm/v1/price', () => {\n        it('should return a 200 OK with an indicative quote for buys', async () => {\n            const buyAmount = 200000000000000000;\n            const winningQuote = 100000000000000000;\n            const losingQuote = 150000000000000000;\n            const zeroExApiParams = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'WETH',\n                buyAmount: buyAmount.toString(),\n                takerAddress,\n                intentOnFilling: 'false',\n                skipValidation: 'true',\n            });\n\n            const baseResponse = {\n                makerAmount: buyAmount.toString(),\n                makerToken: contractAddresses.zrxToken,\n                takerToken: contractAddresses.etherToken,\n                expiry: '1903620548', // in the year 2030\n            };\n\n            mockAxios.onGet(`${MARKET_MAKER_2}/rfqm/v2/price`).replyOnce(HttpStatus.OK, {\n                ...baseResponse,\n                takerAmount: winningQuote.toString(),\n                maker: MARKET_MAKER_2_ADDR,\n            });\n            mockAxios.onGet(`${MARKET_MAKER_3}/rfqm/v2/price`).replyOnce(HttpStatus.OK, {\n                ...baseResponse,\n                takerAmount: losingQuote.toString(),\n                maker: MARKET_MAKER_3_ADDR,\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/price?${zeroExApiParams.toString()}`)\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.OK)\n                .expect('Content-Type', /json/);\n\n            const expectedPrice = '0.5';\n            expect(appResponse.body.liquidityAvailable).to.equal(true);\n            expect(appResponse.body.price).to.equal(expectedPrice);\n        });\n\n        it('should return a 200 OK with an indicative quote for sells', async () => {\n            const sellAmount = 100000000000000000;\n            const winningQuote = 200000000000000000;\n            const losingQuote = 150000000000000000;\n            const zeroExApiParams = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'WETH',\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n                intentOnFilling: 'false',\n                skipValidation: 'true',\n            });\n\n            const baseResponse = {\n                takerAmount: sellAmount.toString(),\n                makerToken: contractAddresses.zrxToken,\n                takerToken: contractAddresses.etherToken,\n                expiry: '1903620548', // in the year 2030\n            };\n\n            mockAxios.onGet(`${MARKET_MAKER_2}/rfqm/v2/price`).replyOnce(HttpStatus.OK, {\n                ...baseResponse,\n                makerAmount: winningQuote.toString(),\n                maker: MARKET_MAKER_2_ADDR,\n            });\n            mockAxios.onGet(`${MARKET_MAKER_3}/rfqm/v2/price`).replyOnce(HttpStatus.OK, {\n                ...baseResponse,\n                makerAmount: losingQuote.toString(),\n                maker: MARKET_MAKER_3_ADDR,\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/price?${zeroExApiParams.toString()}`)\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.OK)\n                .expect('Content-Type', /json/);\n\n            const expectedPrice = '2';\n            expect(appResponse.body.liquidityAvailable).to.equal(true);\n            expect(appResponse.body.price).to.equal(expectedPrice);\n        });\n\n        it('should return a 200 OK, liquidityAvailable === false if no valid quotes found', async () => {\n            const sellAmount = 100000000000000000;\n            const quotedAmount = 200000000000000000;\n            const params = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'WETH',\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n                intentOnFilling: 'false',\n                skipValidation: 'true',\n            });\n\n            mockAxios.onGet(`${MARKET_MAKER_2}/rfqm/v2/price`).replyOnce(HttpStatus.OK, {\n                makerAmount: quotedAmount.toString(),\n                takerAmount: sellAmount.toString(),\n                makerToken: contractAddresses.zrxToken,\n                takerToken: contractAddresses.etherToken,\n                expiry: '0', // already expired\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/price?${params.toString()}`)\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.OK)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.liquidityAvailable).to.equal(false);\n            expect(appResponse.body.price).to.equal(undefined);\n        });\n\n        it('should return a 400 BAD REQUEST if API Key is not permitted access', async () => {\n            const sellAmount = 100000000000000000;\n            const params = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'WETH',\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n                intentOnFilling: 'false',\n                skipValidation: 'true',\n            });\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/price?${params.toString()}`)\n                .set('0x-api-key', 'unknown-key')\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Invalid API key');\n        });\n\n        it('should return a 400 BAD REQUEST if API Key does not have access to the chain', async () => {\n            const sellAmount = 100000000000000000;\n            const params = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'WETH',\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n                intentOnFilling: 'false',\n                skipValidation: 'true',\n            });\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/price?${params.toString()}`)\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1')\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Invalid API key');\n        });\n\n        it('should return a 400 BAD REQUEST Validation Error if Chain Id cannot be parsed', async () => {\n            const sellAmount = 100000000000000000;\n            const params = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'WETH',\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n                intentOnFilling: 'false',\n                skipValidation: 'true',\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/price?${params.toString()}`)\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', 'invalid-id')\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Validation Failed');\n            expect(appResponse.body.validationErrors[0].reason).to.equal('Invalid chain id');\n        });\n\n        it('should return a 400 BAD REQUEST Validation Error if sending ETH, not WETH', async () => {\n            const sellAmount = 100000000000000000;\n            const params = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'ETH',\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n                intentOnFilling: 'false',\n                skipValidation: 'true',\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/price?${params.toString()}`)\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Validation Failed');\n            expect(appResponse.body.validationErrors[0].reason).to.equal(\n                'Unwrapped Native Asset is not supported. Use WETH instead',\n            );\n        });\n\n        it('should return a 400 BAD REQUEST if buyToken is missing', async () => {\n            const sellAmount = 100000000000000000;\n            const params = new URLSearchParams({\n                sellToken: 'WETH',\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n            });\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/price?${params.toString()}`)\n                .set('0x-api-key', API_KEY)\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Validation Failed');\n        });\n\n        it('should return a 400 BAD REQUEST if sellToken is missing', async () => {\n            const sellAmount = 100000000000000000;\n            const params = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n            });\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/price?${params.toString()}`)\n                .set('0x-api-key', API_KEY)\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Validation Failed');\n        });\n\n        it('should return a 400 BAD REQUEST if both sellAmount and buyAmount are missing', async () => {\n            const params = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'WETH',\n                takerAddress,\n            });\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/price?${params.toString()}`)\n                .set('0x-api-key', API_KEY)\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Validation Failed');\n        });\n\n        it('should return a 400 BAD REQUEST Error if trading an unknown token', async () => {\n            const sellAmount = 100000000000000000;\n            const UNKNOWN_TOKEN = 'RACCOONS_FOREVER';\n            const params = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: UNKNOWN_TOKEN,\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n                intentOnFilling: 'false',\n                skipValidation: 'true',\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/price?${params.toString()}`)\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Validation Failed');\n            expect(appResponse.body.validationErrors[0].reason).to.equal(\n                `Token ${UNKNOWN_TOKEN} is currently unsupported`,\n            );\n        });\n    });\n\n    describe('rfqm/v1/quote', () => {\n        it('should return a 200 OK, liquidityAvailable === false if no valid firm quotes found', async () => {\n            const sellAmount = 100000000000000000;\n            const insufficientSellAmount = 1;\n\n            const params = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'WETH',\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n                intentOnFilling: 'false',\n                skipValidation: 'true',\n            });\n\n            const baseResponse = {\n                makerToken: contractAddresses.zrxToken,\n                takerToken: contractAddresses.etherToken,\n                expiry: '1903620548', // in the year 2030\n            };\n\n            mockAxios.onGet(`${MARKET_MAKER_2}/rfqm/v2/price`).replyOnce(HttpStatus.OK, {\n                ...baseResponse,\n                takerAmount: insufficientSellAmount,\n                makerAmount: insufficientSellAmount,\n                maker: MARKET_MAKER_2_ADDR,\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/quote?${params.toString()}`)\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.OK)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.liquidityAvailable).to.equal(false);\n            expect(appResponse.body.price).to.equal(undefined);\n        });\n\n        it('should return a 200 OK with a firm quote for buys', async () => {\n            const buyAmount = 200000000000000000;\n            const winningQuote = 100000000000000000;\n            const losingQuote = 150000000000000000;\n            const zeroExApiParams = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'WETH',\n                buyAmount: buyAmount.toString(),\n                takerAddress,\n                intentOnFilling: 'true',\n                skipValidation: 'true',\n            });\n\n            const headers = {\n                Accept: 'application/json, text/plain, */*',\n                '0x-api-key': INTEGRATOR_ID,\n                '0x-integrator-id': INTEGRATOR_ID,\n            };\n\n            const baseResponse = {\n                makerAmount: buyAmount.toString(),\n                makerToken: contractAddresses.zrxToken,\n                takerToken: contractAddresses.etherToken,\n                expiry: '1903620548', // in the year 2030\n            };\n\n            mockAxios.onGet(`${MARKET_MAKER_2}/rfqm/v2/price`, { headers }).replyOnce(HttpStatus.OK, {\n                ...baseResponse,\n                takerAmount: winningQuote.toString(),\n                maker: MARKET_MAKER_2_ADDR,\n            });\n            mockAxios.onGet(`${MARKET_MAKER_3}/rfqm/v2/price`, { headers }).replyOnce(HttpStatus.OK, {\n                ...baseResponse,\n                takerAmount: losingQuote.toString(),\n                maker: MARKET_MAKER_3_ADDR,\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/quote?${zeroExApiParams.toString()}`)\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.OK)\n                .expect('Content-Type', /json/);\n\n            const expectedPrice = '0.5';\n            expect(appResponse.body.price).to.equal(expectedPrice);\n            expect(appResponse.body.type).to.equal(GaslessTypes.OtcOrder);\n            expect(appResponse.body.orderHash).to.match(/^0x[0-9a-fA-F]+/);\n            expect(appResponse.body.order.maker).to.equal(MARKET_MAKER_2_ADDR);\n            expect(appResponse.body.approval).to.equal(undefined);\n        });\n\n        it('should return a 200 OK with a firm quote when OtcOrder pricing is available for sells', async () => {\n            const sellAmount = 100000000000000000;\n            const winningQuote = 200000000000000000;\n            const losingQuote = 150000000000000000;\n            const zeroExApiParams = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'WETH',\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n                intentOnFilling: 'true',\n                skipValidation: 'true',\n            });\n\n            const headers = {\n                Accept: 'application/json, text/plain, */*',\n                '0x-api-key': INTEGRATOR_ID,\n                '0x-integrator-id': INTEGRATOR_ID,\n            };\n\n            const baseResponse = {\n                takerAmount: sellAmount.toString(),\n                makerToken: contractAddresses.zrxToken,\n                takerToken: contractAddresses.etherToken,\n                expiry: '1903620548', // in the year 2030\n            };\n\n            mockAxios.onGet(`${MARKET_MAKER_2}/rfqm/v2/price`, { headers }).replyOnce(HttpStatus.OK, {\n                ...baseResponse,\n                makerAmount: winningQuote.toString(),\n                maker: MARKET_MAKER_2_ADDR,\n            });\n            mockAxios.onGet(`${MARKET_MAKER_3}/rfqm/v2/price`, { headers }).replyOnce(HttpStatus.OK, {\n                ...baseResponse,\n                makerAmount: losingQuote.toString(),\n                maker: MARKET_MAKER_3_ADDR,\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/quote?${zeroExApiParams.toString()}`)\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.OK)\n                .expect('Content-Type', /json/);\n\n            const expectedPrice = '2';\n            expect(appResponse.body.price).to.equal(expectedPrice);\n            expect(appResponse.body.type).to.equal(GaslessTypes.OtcOrder);\n            expect(appResponse.body.orderHash).to.match(/^0x[0-9a-fA-F]+/);\n            expect(appResponse.body.order.maker).to.equal(MARKET_MAKER_2_ADDR);\n            expect(appResponse.body.approval).to.equal(undefined);\n        });\n\n        it('should return a 200 OK with a firm quote when OtcOrder pricing is available for sells and checkApproval is true', async () => {\n            when(rfqBlockchainUtilsMock.getAllowanceAsync(anything(), anything(), anything())).thenResolve(\n                new BigNumber(0),\n            );\n            when(rfqBlockchainUtilsMock.getGaslessApprovalAsync(anything(), anything(), anything())).thenResolve(\n                MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n            );\n\n            const sellAmount = 100000000000000000;\n            const winningQuote = 200000000000000000;\n            const losingQuote = 150000000000000000;\n            const zeroExApiParams = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'WETH',\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n                checkApproval: 'true',\n            });\n\n            const headers = {\n                Accept: 'application/json, text/plain, */*',\n                '0x-api-key': INTEGRATOR_ID,\n                '0x-integrator-id': INTEGRATOR_ID,\n            };\n\n            const baseResponse = {\n                takerAmount: sellAmount.toString(),\n                makerToken: contractAddresses.zrxToken,\n                takerToken: contractAddresses.etherToken,\n                expiry: '1903620548', // in the year 2030\n            };\n\n            mockAxios.onGet(`${MARKET_MAKER_2}/rfqm/v2/price`, { headers }).replyOnce(HttpStatus.OK, {\n                ...baseResponse,\n                makerAmount: winningQuote.toString(),\n                maker: MARKET_MAKER_2_ADDR,\n            });\n            mockAxios.onGet(`${MARKET_MAKER_3}/rfqm/v2/price`, { headers }).replyOnce(HttpStatus.OK, {\n                ...baseResponse,\n                makerAmount: losingQuote.toString(),\n                maker: MARKET_MAKER_3_ADDR,\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/quote?${zeroExApiParams.toString()}`)\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.OK)\n                .expect('Content-Type', /json/);\n\n            const expectedPrice = '2';\n            const expectedApproval = {\n                isRequired: true,\n                isGaslessAvailable: true,\n                type: MOCK_EXECUTE_META_TRANSACTION_APPROVAL.kind,\n                eip712: MOCK_EXECUTE_META_TRANSACTION_APPROVAL.eip712,\n            };\n            expect(appResponse.body.price).to.equal(expectedPrice);\n            expect(appResponse.body.type).to.equal(GaslessTypes.OtcOrder);\n            expect(appResponse.body.orderHash).to.match(/^0x[0-9a-fA-F]+/);\n            expect(appResponse.body.order.maker).to.equal(MARKET_MAKER_2_ADDR);\n            expect(appResponse.body.approval).to.eql(expectedApproval);\n        });\n\n        it('should return a 400 BAD REQUEST if api key is missing', async () => {\n            const sellAmount = 100000000000000000;\n            const params = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'WETH',\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n                intentOnFilling: 'false',\n                skipValidation: 'true',\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/quote?${params.toString()}`)\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Invalid API key');\n        });\n\n        it('should return a 400 BAD REQUEST if takerAddress is missing', async () => {\n            const sellAmount = 100000000000000000;\n            const params = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'WETH',\n                sellAmount: sellAmount.toString(),\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/quote?${params.toString()}`)\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Validation Failed');\n        });\n\n        it('should return a 400 BAD REQUEST if buyToken is missing', async () => {\n            const sellAmount = 100000000000000000;\n            const params = new URLSearchParams({\n                sellToken: 'WETH',\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/quote?${params.toString()}`)\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Validation Failed');\n        });\n\n        it('should return a 400 BAD REQUEST if sellToken is missing', async () => {\n            const sellAmount = 100000000000000000;\n            const params = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellAmount: sellAmount.toString(),\n                takerAddress,\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/quote?${params.toString()}`)\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Validation Failed');\n        });\n\n        it('should return a 400 BAD REQUEST if both sellAmount and buyAmount are missing', async () => {\n            const params = new URLSearchParams({\n                buyToken: 'ZRX',\n                sellToken: 'WETH',\n                takerAddress,\n            });\n\n            const appResponse = await request(app)\n                .get(`${RFQM_PATH}/quote?${params.toString()}`)\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Validation Failed');\n        });\n    });\n\n    describe('rfqm/v1/submit', () => {\n        const mockStoredFee: StoredFee = {\n            token: '0x123',\n            amount: '1000',\n            type: 'fixed',\n        };\n        const mockStoredOrder: StoredOtcOrder = {\n            type: RfqmOrderTypes.Otc,\n            order: {\n                chainId: '1337',\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                    new BigNumber(SAFE_EXPIRY),\n                    ZERO,\n                    new BigNumber(SAFE_EXPIRY),\n                ).toString(),\n                maker: '0x123',\n                makerAmount: '1',\n                makerToken: '0x123',\n                taker: '0x123',\n                takerAmount: '1',\n                takerToken: '0x123',\n                txOrigin: '0x123',\n                verifyingContract: '0x123',\n            },\n        };\n        // OtcOrder Taker\n        const otcOrderTakerAddress = '0xdA9AC423442169588DE6b4305f4E820D708d0cE5';\n        const otcOrderTakerPrivateKey = '0x653fa328df81be180b58e42737bc4cef037a19a3b9673b15d20ee2eebb2e509d';\n\n        // OtcOrder\n        const mockStoredOtcOrder: StoredOtcOrder = {\n            type: RfqmOrderTypes.Otc,\n            order: {\n                txOrigin: '0x123',\n                maker: '0x123',\n                taker: otcOrderTakerAddress,\n                makerToken: '0x123',\n                takerToken: '0x123',\n                makerAmount: '1',\n                takerAmount: '1',\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                    new BigNumber(SAFE_EXPIRY),\n                    ZERO,\n                    new BigNumber(SAFE_EXPIRY),\n                ).toString(),\n                chainId: '1337',\n                verifyingContract: '0x123',\n            },\n        };\n        const otcOrder = storedOtcOrderToOtcOrder(mockStoredOtcOrder);\n        it('[v2] should return status 201 created and queue up a job with a successful request', async () => {\n            // OtcOrder\n            const order = otcOrder;\n            const orderHash = order.getHash();\n\n            // Taker Signature\n            const takerSignature = ethSignHashWithKey(orderHash, otcOrderTakerPrivateKey);\n\n            const mockQuote = new RfqmV2QuoteEntity({\n                orderHash,\n                makerUri: MARKET_MAKER_1,\n                fee: mockStoredFee,\n                order: mockStoredOtcOrder,\n                chainId: 1337,\n                affiliateAddress: MATCHA_AFFILIATE_ADDRESS,\n                takerSpecifiedSide: 'makerToken',\n            });\n\n            // write a corresponding quote entity to validate against\n            await dataSource.getRepository(RfqmV2QuoteEntity).insert(mockQuote);\n\n            const appResponse = await request(app)\n                .post(`${RFQM_PATH}/submit`)\n                .send({ type: GaslessTypes.OtcOrder, order, signature: takerSignature })\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.CREATED)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.orderHash).to.equal(orderHash);\n\n            const dbJobEntity = await dataSource.getRepository(RfqmV2JobEntity).findOne({\n                where: {\n                    orderHash,\n                },\n            });\n            expect(dbJobEntity).to.not.equal(null);\n            expect(dbJobEntity?.orderHash).to.equal(mockQuote.orderHash);\n            expect(dbJobEntity?.makerUri).to.equal(MARKET_MAKER_1);\n            expect(dbJobEntity?.affiliateAddress).to.equal(MATCHA_AFFILIATE_ADDRESS);\n            expect(dbJobEntity?.takerSignature).to.deep.eq(takerSignature);\n        });\n\n        it('[v2] should return status 404 not found if there is not a pre-existing quote', async () => {\n            const order = otcOrder;\n\n            // Taker Signature\n            const takerSignature = ethSignHashWithKey(order.getHash(), otcOrderTakerPrivateKey);\n\n            const appResponse = await request(app)\n                .post(`${RFQM_PATH}/submit`)\n                .send({\n                    type: GaslessTypes.OtcOrder,\n                    order,\n                    signature: takerSignature,\n                })\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.NOT_FOUND)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Not Found');\n        });\n\n        it('should return a 400 BAD REQUEST Error the type is not supported', async () => {\n            const invalidType = 'v10rfq';\n\n            const appResponse = await request(app)\n                .post(`${RFQM_PATH}/submit`)\n                .send({ type: invalidType, order: mockStoredOrder, signature: RANDOM_VALID_SIGNATURE })\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Validation Failed');\n            expect(appResponse.body.validationErrors[0].reason).to.equal(\n                `${invalidType} is an invalid value for 'type'`,\n            );\n        });\n\n        it('[v2] should fail with status code 500 if a quote has already been submitted', async () => {\n            // OtcOrder\n            const order = otcOrder;\n            const orderHash = order.getHash();\n\n            // Taker Signature\n            const takerSignature = ethSignHashWithKey(orderHash, otcOrderTakerPrivateKey);\n\n            const mockQuote = new RfqmV2QuoteEntity({\n                orderHash,\n                makerUri: MARKET_MAKER_1,\n                fee: mockStoredFee,\n                order: mockStoredOtcOrder,\n                chainId: 1337,\n                affiliateAddress: MATCHA_AFFILIATE_ADDRESS,\n                takerSpecifiedSide: 'makerToken',\n            });\n\n            // write a corresponding quote entity to validate against\n            await dataSource.getRepository(RfqmV2QuoteEntity).insert(mockQuote);\n\n            await request(app)\n                .post(`${RFQM_PATH}/submit`)\n                .send({ type: GaslessTypes.OtcOrder, order, signature: takerSignature })\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.CREATED)\n                .expect('Content-Type', /json/);\n\n            // try to submit again\n            await request(app)\n                .post(`${RFQM_PATH}/submit`)\n                .send({ type: GaslessTypes.OtcOrder, order, signature: takerSignature })\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.INTERNAL_SERVER_ERROR)\n                .expect('Content-Type', /json/);\n        });\n\n        it('[v2] should fail with 400 BAD REQUEST if meta tx is too close to expiration', async () => {\n            const order = new OtcOrder({\n                ...otcOrder,\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(ZERO, ZERO, ZERO),\n            });\n            const orderHash = order.getHash();\n\n            const mockQuote = new RfqmV2QuoteEntity({\n                orderHash,\n                makerUri: MARKET_MAKER_1,\n                fee: mockStoredFee,\n                order: mockStoredOtcOrder,\n                chainId: 1337,\n                affiliateAddress: MATCHA_AFFILIATE_ADDRESS,\n                takerSpecifiedSide: 'makerToken',\n            });\n\n            await dataSource.getRepository(RfqmV2QuoteEntity).insert(mockQuote);\n\n            const appResponse = await request(app)\n                .post(`${RFQM_PATH}/submit`)\n                .send({ type: GaslessTypes.OtcOrder, order, signature: RANDOM_VALID_SIGNATURE })\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Validation Failed');\n            expect(appResponse.body.validationErrors[0].reason).to.equal(`order will expire too soon`);\n        });\n\n        it('[v2] should fail with 400 BAD REQUEST if signature is invalid', async () => {\n            const order = otcOrder;\n            const orderHash = order.getHash();\n\n            const mockQuote = new RfqmV2QuoteEntity({\n                orderHash,\n                makerUri: MARKET_MAKER_1,\n                fee: mockStoredFee,\n                order: mockStoredOtcOrder,\n                chainId: 1337,\n                affiliateAddress: MATCHA_AFFILIATE_ADDRESS,\n                takerSpecifiedSide: 'makerToken',\n            });\n\n            await dataSource.getRepository(RfqmV2QuoteEntity).insert(mockQuote);\n\n            const appResponse = await request(app)\n                .post(`${RFQM_PATH}/submit`)\n                .send({ type: GaslessTypes.OtcOrder, order, signature: RANDOM_VALID_SIGNATURE })\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.reason).to.equal('Validation Failed');\n            expect(appResponse.body.validationErrors[0].reason).to.equal(`signature is not valid`);\n        });\n    });\n\n    describe('rfqm/v1/submit-with-approval', () => {\n        const mockStoredFee: StoredFee = {\n            token: '0x123',\n            amount: '1000',\n            type: 'fixed',\n        };\n\n        // OtcOrder Taker\n        const otcOrderTakerAddress = '0xdA9AC423442169588DE6b4305f4E820D708d0cE5';\n        const otcOrderTakerPrivateKey = '0x653fa328df81be180b58e42737bc4cef037a19a3b9673b15d20ee2eebb2e509d';\n\n        // OtcOrder\n        const mockStoredOtcOrder: StoredOtcOrder = {\n            type: RfqmOrderTypes.Otc,\n            order: {\n                txOrigin: '0x123',\n                maker: '0x123',\n                taker: otcOrderTakerAddress,\n                makerToken: '0x123',\n                takerToken: '0x123',\n                makerAmount: '1',\n                takerAmount: '1',\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                    new BigNumber(SAFE_EXPIRY),\n                    ZERO,\n                    new BigNumber(SAFE_EXPIRY),\n                ).toString(),\n                chainId: '1337',\n                verifyingContract: '0x123',\n            },\n        };\n\n        // Approval\n        const approval = {\n            type: MOCK_PERMIT_APPROVAL.kind,\n            eip712: MOCK_PERMIT_APPROVAL.eip712,\n        };\n        const otcOrder = storedOtcOrderToOtcOrder(mockStoredOtcOrder);\n        it('[v2] should return status 201 created and queue up a job with a successful request', async () => {\n            // OtcOrder\n            const order = otcOrder;\n            const orderHash = order.getHash();\n\n            // Taker Signature\n            const takerSignature = ethSignHashWithKey(orderHash, otcOrderTakerPrivateKey);\n\n            // Approval signature\n            const signer = new ethers.Wallet(otcOrderTakerPrivateKey);\n            const typesCopy: Partial<PermitEip712Types> = { ...approval.eip712.types };\n            delete typesCopy.EIP712Domain;\n            const rawApprovalSignature = await signer._signTypedData(\n                approval.eip712.domain,\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                typesCopy as any,\n                approval.eip712.message,\n            );\n            const { v, r, s } = ethers.utils.splitSignature(rawApprovalSignature);\n            const approvalSignature = {\n                v,\n                r,\n                s,\n                signatureType: 3,\n            };\n\n            const mockQuote = new RfqmV2QuoteEntity({\n                orderHash,\n                makerUri: MARKET_MAKER_1,\n                fee: mockStoredFee,\n                order: mockStoredOtcOrder,\n                chainId: 1337,\n                affiliateAddress: MATCHA_AFFILIATE_ADDRESS,\n                takerSpecifiedSide: 'makerToken',\n            });\n\n            // write a corresponding quote entity to validate against\n            await dataSource.getRepository(RfqmV2QuoteEntity).insert(mockQuote);\n\n            const appResponse = await request(app)\n                .post(`${RFQM_PATH}/submit-with-approval`)\n                .send({\n                    trade: { type: GaslessTypes.OtcOrder, order, signature: takerSignature },\n                    approval: {\n                        type: GaslessApprovalTypes.Permit,\n                        eip712: approval.eip712,\n                        signature: approvalSignature,\n                    },\n                })\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.CREATED)\n                .expect('Content-Type', /json/);\n\n            expect(appResponse.body.orderHash).to.equal(orderHash);\n\n            const dbJobEntity = await dataSource.getRepository(RfqmV2JobEntity).findOne({\n                where: {\n                    orderHash,\n                },\n            });\n\n            expect(dbJobEntity).to.not.equal(null);\n            expect(dbJobEntity?.orderHash).to.equal(mockQuote.orderHash);\n            expect(dbJobEntity?.makerUri).to.equal(MARKET_MAKER_1);\n            expect(dbJobEntity?.affiliateAddress).to.equal(MATCHA_AFFILIATE_ADDRESS);\n            expect(dbJobEntity?.takerSignature).to.deep.eq(takerSignature);\n            expect(dbJobEntity?.approval?.eip712).to.deep.eq(approval.eip712);\n            expect(dbJobEntity?.approval?.kind).to.deep.eq(approval.type);\n            expect(dbJobEntity?.approvalSignature).to.deep.eq(approvalSignature);\n        });\n    });\n\n    describe('rfqm/v1/status/:orderHash', () => {\n        it('should return a 404 NOT FOUND if the order hash is not found', () => {\n            const orderHash = '0x00';\n            return request(app)\n                .get(`${RFQM_PATH}/status/${orderHash}`)\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.NOT_FOUND);\n        });\n\n        it('should return a 200 when the order exists', async () => {\n            await dbUtils.writeV2JobAsync(MOCK_RFQM_JOB);\n\n            const response = await request(app)\n                .get(`${RFQM_PATH}/status/${MOCK_RFQM_JOB.orderHash}`)\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.OK)\n                .expect('Content-Type', /json/);\n\n            // Response details are covered by the service test, but do one small check for sanity\n            expect(response.body.status).to.equal('submitted');\n        });\n\n        it('should return status reason for failures', async () => {\n            await dbUtils.writeV2JobAsync({\n                ...MOCK_RFQM_JOB,\n                status: RfqmJobStatus.FailedRevertedConfirmed,\n            });\n\n            const response = await request(app)\n                .get(`${RFQM_PATH}/status/${MOCK_RFQM_JOB.orderHash}`)\n                .set('0x-api-key', API_KEY)\n                .set('0x-chain-id', '1337')\n                .expect(HttpStatus.OK)\n                .expect('Content-Type', /json/);\n\n            // Response details are covered by the service test, but do one small check for sanity\n            expect(response.body.reason).to.equal('transaction_reverted');\n        });\n    });\n\n    describe('/admin/v1/cleanup', () => {\n        it('should return a 400 BAD REQUEST if the order hash is not found', () => {\n            const orderHash = '0x00';\n            return request(app)\n                .post(`${ADMIN_PATH}/cleanup`)\n                .send({ orderHashes: [orderHash] })\n                .set('0x-admin-api-key', ADMIN_API_KEY)\n                .expect(HttpStatus.BAD_REQUEST);\n        });\n\n        it('should return a 400 BAD REQUEST if no order hashes are sent', async () => {\n            await request(app)\n                .post(`${ADMIN_PATH}/cleanup`)\n                .send({ orderHashes: [] })\n                .set('0x-admin-api-key', ADMIN_API_KEY)\n                .expect(HttpStatus.BAD_REQUEST);\n        });\n\n        it('should return a 400 BAD REQUEST if all job updates fail', async () => {\n            await dbUtils.writeV2JobAsync({ ...MOCK_RFQM_JOB, status: RfqmJobStatus.SucceededConfirmed });\n            const response = await request(app)\n                .post(`${ADMIN_PATH}/cleanup`)\n                .send({ orderHashes: [MOCK_RFQM_JOB.orderHash] })\n                .set('0x-admin-api-key', ADMIN_API_KEY)\n                .expect(HttpStatus.BAD_REQUEST);\n\n            expect(response.body.unmodifiedJobs[0]).to.equal(MOCK_RFQM_JOB.orderHash);\n        });\n\n        it('should return a 401 UNAUTHORIZED if the API key is not an admin key', async () => {\n            await dbUtils.writeV2JobAsync(MOCK_RFQM_JOB);\n            const badApiKey = '0xbadapikey';\n\n            return request(app)\n                .post(`${ADMIN_PATH}/cleanup`)\n                .send({ orderHashes: [MOCK_RFQM_JOB.orderHash] })\n                .set('0x-admin-api-key', badApiKey)\n                .expect(HttpStatus.UNAUTHORIZED);\n        });\n\n        it('should return a 200 OK when the jobs are successfully set to failure', async () => {\n            await dbUtils.writeV2JobAsync({\n                ...MOCK_RFQM_JOB,\n                expiry: new BigNumber(Date.now() - 60_000).dividedBy(ONE_SECOND_MS).decimalPlaces(0),\n            });\n\n            const response = await request(app)\n                .post(`${ADMIN_PATH}/cleanup`)\n                .send({ orderHashes: [MOCK_RFQM_JOB.orderHash] })\n                .set('0x-admin-api-key', ADMIN_API_KEY)\n                .expect(HttpStatus.OK)\n                .expect('Content-Type', /json/);\n\n            expect(response.body.modifiedJobs[0]).to.equal(MOCK_RFQM_JOB.orderHash);\n        });\n\n        it('should return a 207 MULTI STATUS if some jobs succeed and some jobs fail', async () => {\n            await dbUtils.writeV2JobAsync({\n                ...MOCK_RFQM_JOB,\n                status: RfqmJobStatus.SucceededConfirmed,\n                orderHash: '0x01',\n            });\n            await dbUtils.writeV2JobAsync({\n                ...MOCK_RFQM_JOB,\n                expiry: new BigNumber(Date.now() - 60_000).dividedBy(ONE_SECOND_MS).decimalPlaces(0),\n                orderHash: '0x02',\n            });\n\n            const response = await request(app)\n                .post(`${ADMIN_PATH}/cleanup`)\n                .send({ orderHashes: ['0x01', '0x02'] })\n                .set('0x-admin-api-key', ADMIN_API_KEY)\n                .expect(HttpStatus.MULTI_STATUS);\n\n            expect(response.body.unmodifiedJobs[0]).to.equal('0x01');\n            expect(response.body.modifiedJobs[0]).to.equal('0x02');\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/runners/http_rfqm_service_runner.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/SubmissionContext.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/deployment.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/initDbDataSourceAsync.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/getDbDataSourceAsync.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/root_handler.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/middleware/address_normalizer.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/middleware/error_handling.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/routers/rfqm_router.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/routers/RfqtRouter.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/routers/rfq_admin_router.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/routers/rfq_maker_router.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_admin_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_service_builder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqtServiceBuilder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/runner_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_health_check.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/runners/http_rfqm_service_runner.ts",{"fileContent":"/**\n * This module can be used to run the RFQM HTTP service standalone\n */\nimport { createDefaultServer, HttpServiceConfig } from '@0x/api-utils';\nimport * as Sentry from '@sentry/node';\nimport * as Tracing from '@sentry/tracing';\nimport Axios from 'axios';\nimport * as express from 'express';\nimport * as promBundle from 'express-prom-bundle';\n// tslint:disable-next-line:no-implicit-dependencies\nimport * as core from 'express-serve-static-core';\nimport { Server } from 'http';\nimport * as HttpStatus from 'http-status-codes';\nimport Redis from 'ioredis';\nimport { DataSource } from 'typeorm';\n\nimport {\n    CHAIN_CONFIGURATIONS,\n    defaultHttpServiceConfig,\n    DEFINED_FI_API_KEY,\n    DEFINED_FI_ENDPOINT,\n    REDIS_URI,\n    SENTRY_DSN,\n    SENTRY_ENVIRONMENT,\n    SENTRY_TRACES_SAMPLE_RATE,\n    TOKEN_PRICE_ORACLE_TIMEOUT,\n} from '../config';\nimport { ADMIN_PATH, RFQM_PATH, RFQT_V1_PATH, RFQT_V2_PATH, RFQ_MAKER_PATH } from '../core/constants';\nimport { getDbDataSourceAsync } from '../getDbDataSourceAsync';\nimport { rootHandler } from '../handlers/root_handler';\nimport { logger } from '../logger';\nimport { addressNormalizer } from '../middleware/address_normalizer';\nimport { errorHandler } from '../middleware/error_handling';\nimport { createRfqmRouter } from '../routers/rfqm_router';\nimport { createRfqtV1Router, createRfqtV2Router } from '../routers/RfqtRouter';\nimport { createRfqAdminRouter } from '../routers/rfq_admin_router';\nimport { createRfqMakerRouter } from '../routers/rfq_maker_router';\nimport { RfqAdminService } from '../services/rfq_admin_service';\nimport { RfqMakerService } from '../services/rfq_maker_service';\nimport { ConfigManager } from '../utils/config_manager';\nimport { RfqmDbUtils } from '../utils/rfqm_db_utils';\nimport { buildRfqmServicesAsync, getAxiosRequestConfig, RfqmServices } from '../utils/rfqm_service_builder';\nimport { buildRfqtServicesAsync, RfqtServices } from '../utils/rfqtServiceBuilder';\nimport { RfqMakerDbUtils } from '../utils/rfq_maker_db_utils';\nimport { closeRedisConnectionsAsync } from '../utils/runner_utils';\nimport { TokenPriceOracle } from '../utils/TokenPriceOracle';\n\nconst redisInstances: Redis[] = [];\n\nprocess.on('uncaughtException', (err) => {\n    logger.error(err);\n    process.exit(1);\n});\n\nprocess.on('unhandledRejection', (err) => {\n    if (err) {\n        logger.error(err as Error);\n    }\n});\n\nprocess.on('SIGTERM', async () => {\n    logger.info('Received SIGTERM. Start to shutdown RFQ services');\n    await closeRedisConnectionsAsync(redisInstances);\n    process.exit(0);\n});\n\n// Used for shutting down locally\nprocess.on('SIGINT', async () => {\n    logger.info('Received SIGINT. Start to shutdown RFQ services');\n    await closeRedisConnectionsAsync(redisInstances);\n    process.exit(0);\n});\n\nif (require.main === module) {\n    (async () => {\n        // Build dependencies\n        const config: HttpServiceConfig = {\n            ...defaultHttpServiceConfig,\n        };\n        const connection = await getDbDataSourceAsync();\n        const rfqmDbUtils = new RfqmDbUtils(connection);\n        const rfqMakerDbUtils = new RfqMakerDbUtils(connection);\n        const configManager = new ConfigManager();\n        const axiosInstance = Axios.create(getAxiosRequestConfig(TOKEN_PRICE_ORACLE_TIMEOUT));\n        const tokenPriceOracle = new TokenPriceOracle(axiosInstance, DEFINED_FI_API_KEY, DEFINED_FI_ENDPOINT);\n\n        if (!REDIS_URI) {\n            throw new Error('No redis URI provided to RFQ Service');\n        }\n        const redis = new Redis(REDIS_URI);\n        redisInstances.push(redis);\n\n        const rfqmServices = await buildRfqmServicesAsync(\n            /* asWorker = */ false,\n            rfqmDbUtils,\n            rfqMakerDbUtils,\n            CHAIN_CONFIGURATIONS,\n            tokenPriceOracle,\n            configManager,\n            redis,\n        );\n\n        const rfqtServices = await buildRfqtServicesAsync(CHAIN_CONFIGURATIONS, rfqMakerDbUtils, redis);\n\n        const rfqAdminService = buildRfqAdminService(rfqmDbUtils);\n        const rfqMakerService = buildRfqMakerService(rfqMakerDbUtils, configManager);\n        await runHttpRfqmServiceAsync(\n            rfqmServices,\n            rfqtServices,\n            rfqAdminService,\n            rfqMakerService,\n            configManager,\n            config,\n            connection,\n        );\n    })().catch((error) => logger.error(error.stack));\n}\n\n/**\n * Builds an instance of RfqAdminService\n */\nexport function buildRfqAdminService(dbUtils: RfqmDbUtils): RfqAdminService {\n    return new RfqAdminService(dbUtils);\n}\n\n/**\n * Builds an instance of RfqMakerService\n */\nexport function buildRfqMakerService(dbUtils: RfqMakerDbUtils, configManager: ConfigManager): RfqMakerService {\n    return new RfqMakerService(dbUtils, configManager);\n}\n\n/**\n * Runs the Rfqm Service in isolation\n */\nexport async function runHttpRfqmServiceAsync(\n    rfqmServices: RfqmServices,\n    rfqtServices: RfqtServices,\n    rfqAdminService: RfqAdminService,\n    rfqMakerService: RfqMakerService,\n    configManager: ConfigManager,\n    config: HttpServiceConfig,\n    connection: DataSource,\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    // eslint-disable-next-line @typescript-eslint/no-inferrable-types\n    useMetricsMiddleware: boolean = true,\n    _app?: core.Express,\n): Promise<{ app: express.Application; server: Server }> {\n    const app = _app || express();\n\n    if (SENTRY_DSN) {\n        Sentry.init({\n            dsn: SENTRY_DSN,\n            integrations: [\n                // enable HTTP calls tracing\n                new Sentry.Integrations.Http({ tracing: true }),\n                // enable Express.js middleware tracing\n                new Tracing.Integrations.Express({ app }),\n            ],\n            environment: SENTRY_ENVIRONMENT,\n\n            // Set tracesSampleRate to 1.0 to capture 100%\n            // of transactions for performance monitoring.\n            // We recommend adjusting this value in production\n            tracesSampleRate: SENTRY_TRACES_SAMPLE_RATE,\n        });\n\n        // RequestHandler creates a separate execution context using domains, so that every\n        // transaction/span/breadcrumb is attached to its own Hub instance\n        app.use(Sentry.Handlers.requestHandler());\n        // TracingHandler creates a trace for every incoming request\n        app.use(Sentry.Handlers.tracingHandler());\n    }\n\n    if (useMetricsMiddleware) {\n        /**\n         * express-prom-bundle will create a histogram metric called \"http_request_duration_seconds\"\n         * The official prometheus docs describe how to use this exact histogram metric: https://prometheus.io/docs/practices/histograms/\n         * We use the following labels: statusCode, path\n         */\n        const metricsMiddleware = promBundle({\n            autoregister: false,\n            includeStatusCode: true,\n            includePath: true,\n            customLabels: { chainId: undefined },\n            normalizePath: [\n                ['/status/.*', '/status/#orderHash'], // converts all /status/0xdeadbeef... => /status/#orderHash\n                ['/api-docs.*', '/api-docs'], // converts all /api-docs/favicon... => /api-docs\n            ],\n            transformLabels: (labels, req, _res) => {\n                Object.assign(labels, { chainId: req.header('0x-chain-id') || 1 });\n            },\n            // buckets used for the http_request_duration_seconds histogram. All numbers (in seconds) represents boundaries of buckets.\n            // tslint:disable-next-line: custom-no-magic-numbers\n            buckets: [0.01, 0.04, 0.1, 0.3, 0.6, 1, 1.5, 2, 2.5, 3, 4, 6, 9],\n        });\n        app.use(metricsMiddleware);\n    }\n    app.use(addressNormalizer);\n    app.get('/', rootHandler);\n    const server = createDefaultServer(config, app, logger, async () => {\n        await connection.close();\n    });\n\n    app.use(RFQM_PATH, createRfqmRouter(rfqmServices, configManager));\n    app.use(RFQT_V1_PATH, createRfqtV1Router(rfqtServices, configManager));\n    app.use(RFQT_V2_PATH, createRfqtV2Router(rfqtServices, configManager));\n    app.use(RFQ_MAKER_PATH, createRfqMakerRouter(rfqMakerService));\n    app.use(ADMIN_PATH, createRfqAdminRouter(rfqAdminService, configManager));\n\n    if (SENTRY_DSN) {\n        // The error handler must be before any other error middleware and after all controllers\n        app.use(\n            Sentry.Handlers.errorHandler({\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                shouldHandleError(error: any): boolean {\n                    if (error.status === undefined || error.status >= HttpStatus.BAD_REQUEST) {\n                        return true;\n                    }\n                    return false;\n                },\n            }),\n        );\n    }\n\n    app.use(errorHandler);\n\n    server.listen(config.httpPort);\n    return { app, server };\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/getDbDataSourceAsync.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/root_handler.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/middleware/address_normalizer.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/middleware/error_handling.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/routers/rfqm_router.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/routers/RfqtRouter.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/routers/rfq_admin_router.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/routers/rfq_maker_router.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_admin_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_service_builder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqtServiceBuilder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/runner_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/createOrmConfig.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/rfqm_handlers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/RfqtHandlers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/rfq_admin_handler.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/api-docs/rfq_maker_docs.json","/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/rfq_maker_handlers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/WorkerService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/provider_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/RefreshingQuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/RfqtService.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/root_handler.ts",{"fileContent":"import * as express from 'express';\n\nexport const rootHandler = (_req: express.Request, res: express.Response) => {\n    res.send({\n        message: 'This is the root of the 0x API. Visit https://0x.org/docs/api for documentation.',\n    });\n};\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/middleware/address_normalizer.ts",{"fileContent":"import * as express from 'express';\n// tslint:disable-next-line:no-implicit-dependencies\nimport * as core from 'express-serve-static-core';\n\nimport { objectETHAddressNormalizer } from '../utils/address_utils';\n\n/**\n * Searches for query param values that match the ETH address format, and transforms them to lowercase\n */\nexport function addressNormalizer(req: express.Request, _: express.Response, next: core.NextFunction): void {\n    const normalizedQuery = objectETHAddressNormalizer(req.query);\n    req.query = normalizedQuery;\n\n    next();\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/middleware/error_handling.ts",{"fileContent":"import { APIBaseError, BadRequestError, ErrorUtils as BaseErrorUtils, isAPIError } from '@0x/api-utils';\nimport * as HttpStatus from 'http-status-codes';\n\nimport { APIErrorCodes, apiErrorCodesToReasons } from '../core/errors';\n\nclass ErrorUtils extends BaseErrorUtils {\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    public generateError(err: Error): any {\n        // handle error codes that are specific to 0x API\n        if (\n            isAPIError(err) &&\n            isAPIBadRequestError(err) &&\n            Object.values(APIErrorCodes).includes(err.generalErrorCode)\n        ) {\n            const statusCode = err.statusCode;\n            const code = err.generalErrorCode;\n            return {\n                statusCode,\n                errorBody: {\n                    code,\n                    reason: apiErrorCodesToReasons[code],\n                },\n            };\n        }\n        // otherwise use general error handling\n        return super.generateError(err);\n    }\n}\n\nfunction isAPIBadRequestError(error: APIBaseError): error is APIBaseError & BadRequestError<APIErrorCodes> {\n    return error.statusCode === HttpStatus.BAD_REQUEST;\n}\n\nexport const errorUtils = new ErrorUtils();\nexport const errorHandler = errorUtils.getErrorHandler();\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/routers/rfqm_router.ts",{"fileContent":"import * as express from 'express';\nimport * as asyncHandler from 'express-async-handler';\n\nimport { RfqmHandlers } from '../handlers/rfqm_handlers';\nimport { ConfigManager } from '../utils/config_manager';\nimport { RfqmServices } from '../utils/rfqm_service_builder';\n\n// tslint:disable-next-line:completed-docs\nexport function createRfqmRouter(rfqmServices: RfqmServices, configManager: ConfigManager): express.Router {\n    const router = express.Router();\n    const handlers = new RfqmHandlers(rfqmServices, configManager);\n\n    // Routes\n    router.get('/healthz', asyncHandler(handlers.getHealthAsync.bind(handlers)));\n    router.get('/price', asyncHandler(handlers.getIndicativeQuoteAsync.bind(handlers)));\n    router.get('/quote', asyncHandler(handlers.getFirmQuoteAsync.bind(handlers)));\n    router.get('/status/:orderHash', asyncHandler(handlers.getStatusAsync.bind(handlers)));\n    router.post('/submit', asyncHandler(handlers.submitSignedQuoteAsync.bind(handlers)));\n    router.post('/submit-with-approval', asyncHandler(handlers.submitSignedQuoteWithApprovalAsync.bind(handlers)));\n\n    return router;\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/rfqm_handlers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_service_builder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_health_check.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_request_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/WorkerService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/provider_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/rfqm_handlers.ts",{"fileContent":"// tslint:disable:max-file-line-count\nimport { InvalidAPIKeyError, ValidationError, ValidationErrorCodes } from '@0x/api-utils';\nimport { OtcOrder } from '@0x/protocol-utils';\nimport { getTokenMetadataIfExists, isNativeSymbolOrAddress, nativeWrappedTokenSymbol } from '@0x/token-metadata';\nimport { addressUtils, BigNumber } from '@0x/utils';\nimport * as express from 'express';\nimport * as HttpStatus from 'http-status-codes';\nimport { Counter } from 'prom-client';\n\nimport { Integrator } from '../config';\nimport { schemas } from '../core/schemas';\nimport { RfqmService } from '../services/rfqm_service';\nimport {\n    FetchFirmQuoteParams,\n    FetchIndicativeQuoteParams,\n    FetchQuoteParamsBase,\n    OtcOrderRfqmQuoteResponse,\n    OtcOrderSubmitRfqmSignedQuoteParams,\n    SubmitRfqmSignedQuoteWithApprovalParams,\n} from '../services/types';\nimport {\n    ExecuteMetaTransactionEip712Context,\n    GaslessApprovalTypes,\n    GaslessTypes,\n    PermitEip712Context,\n} from '../core/types';\nimport { ConfigManager } from '../utils/config_manager';\nimport { HealthCheckResult, transformResultToShortResponse } from '../utils/rfqm_health_check';\nimport {\n    RawOtcOrderFields,\n    StringSignatureFields,\n    stringsToEIP712Context,\n    stringsToOtcOrderFields,\n    stringsToSignature,\n} from '../utils/rfqm_request_utils';\nimport { RfqmServices } from '../utils/rfqm_service_builder';\nimport { schemaUtils } from '../core/schema_utils';\n\nconst RFQM_INDICATIVE_QUOTE_REQUEST = new Counter({\n    name: 'rfqm_handler_indicative_quote_requested',\n    help: 'Request made to fetch rfqm indicative quote',\n    labelNames: ['integratorLabel', 'chainId'],\n});\n\nconst RFQM_INDICATIVE_QUOTE_NOT_FOUND = new Counter({\n    name: 'rfqm_handler_indicative_quote_not_found',\n    help: 'Request to fetch rfqm indicative quote returned no quote',\n    labelNames: ['integratorLabel', 'chainId'],\n});\n\nconst RFQM_INDICATIVE_QUOTE_ERROR = new Counter({\n    name: 'rfqm_handler_indicative_quote_error',\n    help: 'Request to fetch rfqm indicative quote resulted in error',\n    labelNames: ['integratorLabel', 'chainId'],\n});\n\nconst RFQM_FIRM_QUOTE_REQUEST = new Counter({\n    name: 'rfqm_handler_firm_quote_requested',\n    help: 'Request made to fetch rfqm firm quote',\n    labelNames: ['integratorLabel', 'chainId'],\n});\n\nconst RFQM_FIRM_QUOTE_NOT_FOUND = new Counter({\n    name: 'rfqm_handler_firm_quote_not_found',\n    help: 'Request to fetch rfqm firm quote returned no quote',\n    labelNames: ['integratorLabel', 'chainId'],\n});\n\nconst RFQM_FIRM_QUOTE_ERROR = new Counter({\n    name: 'rfqm_handler_firm_quote_error',\n    help: 'Request to fetch rfqm firm quote resulted in error',\n    labelNames: ['integratorLabel', 'chainId'],\n});\n\nconst RFQM_SIGNED_QUOTE_SUBMITTED = new Counter({\n    name: 'rfqm_handler_signed_quote_submitted',\n    help: 'Request received to submit a signed rfqm quote',\n    labelNames: ['integratorLabel', 'chainId'],\n});\n\n// If the cache is more milliseconds old than the value specified here, it will be refreshed.\nconst HEALTH_CHECK_RESULT_CACHE_DURATION_MS = 30000;\n\ntype RfqmHealthCheckResultCache = [HealthCheckResult, Date];\n\nexport class RfqmHandlers {\n    private readonly _cachedHealthCheckResultByChainId = new Map<number, RfqmHealthCheckResultCache>();\n    constructor(private readonly _rfqmServices: RfqmServices, private readonly _configManager: ConfigManager) {}\n\n    public async getIndicativeQuoteAsync(req: express.Request, res: express.Response): Promise<void> {\n        // Parse request\n        const { chainId, params } = await this._parseFetchIndicativeQuoteParamsAsync(req);\n        // NOTE: not all requests are emitted if they fail parsing\n        RFQM_INDICATIVE_QUOTE_REQUEST.inc({\n            integratorLabel: params.integrator.label,\n            chainId,\n        });\n\n        // Try to get indicative quote\n        let indicativeQuote;\n        try {\n            indicativeQuote = await this._getServiceForChain(chainId).fetchIndicativeQuoteAsync(params);\n        } catch (e) {\n            req.log.error(e, 'Encountered an error while fetching an rfqm indicative quote');\n            RFQM_INDICATIVE_QUOTE_ERROR.inc({\n                integratorLabel: params.integrator.label,\n                chainId,\n            });\n            throw e;\n        }\n\n        // Log no quote returned\n        if (indicativeQuote === null) {\n            RFQM_INDICATIVE_QUOTE_NOT_FOUND.inc({\n                integratorLabel: params.integrator.label,\n                chainId,\n            });\n        }\n\n        // Result\n        res.status(HttpStatus.OK).send({\n            liquidityAvailable: indicativeQuote !== null,\n            ...indicativeQuote,\n        });\n    }\n\n    public async getFirmQuoteAsync(req: express.Request, res: express.Response): Promise<void> {\n        // Parse request\n        const { chainId, params } = await this._parseFetchFirmQuoteParamsAsync(req);\n        // NOTE: not all requests are emitted if they fail parsing\n        RFQM_FIRM_QUOTE_REQUEST.inc({\n            integratorLabel: params.integrator.label,\n            chainId,\n        });\n\n        // Try to get firm quote\n        let firmQuote: OtcOrderRfqmQuoteResponse | null;\n        try {\n            const result = await this._getServiceForChain(chainId).fetchFirmQuoteAsync(params);\n            firmQuote = result.quote;\n        } catch (e) {\n            req.log.error(e, 'Encountered an error while fetching an rfqm firm quote');\n            RFQM_FIRM_QUOTE_ERROR.inc({\n                integratorLabel: params.integrator.label,\n                chainId,\n            });\n            throw e;\n        }\n\n        // Log no quote returned\n        if (firmQuote === null) {\n            RFQM_FIRM_QUOTE_NOT_FOUND.inc({\n                integratorLabel: params.integrator.label,\n                chainId,\n            });\n        }\n\n        // Result\n        res.status(HttpStatus.OK).send({\n            liquidityAvailable: firmQuote !== null,\n            ...firmQuote,\n        });\n    }\n\n    /**\n     * Handler for the `/rfqm/v1/healthz` endpoint.\n     */\n    public async getHealthAsync(req: express.Request, res: express.Response): Promise<void> {\n        const chainId = extractChainId(req);\n        const cachedResult = this._cachedHealthCheckResultByChainId.get(chainId);\n        let result: HealthCheckResult;\n        if (!cachedResult) {\n            result = await this._getServiceForChain(chainId).runHealthCheckAsync();\n            this._cachedHealthCheckResultByChainId.set(chainId, [result, new Date()]);\n        } else {\n            const cacheAgeMs = Date.now() - cachedResult[1].getTime();\n            if (cacheAgeMs >= HEALTH_CHECK_RESULT_CACHE_DURATION_MS) {\n                result = await this._getServiceForChain(chainId).runHealthCheckAsync();\n                this._cachedHealthCheckResultByChainId.set(chainId, [result, new Date()]);\n            } else {\n                result = cachedResult[0];\n            }\n        }\n\n        const response = transformResultToShortResponse(result);\n        res.status(HttpStatus.OK).send(response);\n    }\n\n    public async getStatusAsync(req: express.Request, res: express.Response): Promise<void> {\n        const chainId = extractChainId(req);\n        const { orderHash } = req.params;\n\n        const status = await this._getServiceForChain(chainId).getStatusAsync(orderHash);\n\n        status ? res.status(HttpStatus.OK).send(status) : res.status(HttpStatus.NOT_FOUND).send();\n    }\n\n    public async submitSignedQuoteAsync(req: express.Request, res: express.Response): Promise<void> {\n        const { chainId, integrator, params } = this._parseSubmitSignedQuoteParams(req);\n        RFQM_SIGNED_QUOTE_SUBMITTED.inc({\n            integratorLabel: integrator.label,\n            chainId,\n        });\n        try {\n            const response = await this._getServiceForChain(chainId).submitTakerSignedOtcOrderAsync(params);\n            res.status(HttpStatus.CREATED).send(response);\n        } catch (e) {\n            req.log.error(e, 'Encountered an error while queuing a signed quote');\n            throw e;\n        }\n    }\n\n    public async submitSignedQuoteWithApprovalAsync(req: express.Request, res: express.Response): Promise<void> {\n        const { chainId, integrator, params } = this._parseSubmitSignedQuoteWithApprovalParams(req);\n        RFQM_SIGNED_QUOTE_SUBMITTED.inc({\n            integratorLabel: integrator.label,\n            chainId,\n        });\n        try {\n            const response = await this._getServiceForChain(chainId).submitTakerSignedOtcOrderWithApprovalAsync(params);\n            res.status(HttpStatus.CREATED).send(response);\n        } catch (e) {\n            req.log.error(e, 'Encountered an error while queuing a signed quote with approval');\n            throw e;\n        }\n    }\n\n    private async _parseFetchFirmQuoteParamsAsync(\n        req: express.Request,\n    ): Promise<{ chainId: number; params: FetchFirmQuoteParams }> {\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        schemaUtils.validateSchema(req.query, schemas.firmQuoteRequestSchema as any);\n        const takerAddress = req.query.takerAddress;\n        const shouldCheckApproval = req.query.checkApproval === 'true' ? true : false;\n        const { chainId, params } = await this._parseIndicativeAndFirmQuoteSharedParamsAsync(req);\n        if (!addressUtils.isAddress(takerAddress as string)) {\n            throw new ValidationError([\n                {\n                    field: 'takerAddress',\n                    code: ValidationErrorCodes.InvalidAddress,\n                    reason: `Must provide a valid takerAddress`,\n                },\n            ]);\n        }\n        return {\n            chainId,\n            params: {\n                ...params,\n                takerAddress: takerAddress as string,\n                checkApproval: shouldCheckApproval,\n            },\n        };\n    }\n\n    private _getServiceForChain(chainId: number): RfqmService {\n        const service = this._rfqmServices.get(chainId);\n\n        if (!service) {\n            throw new Error('No configuration exists for chain');\n        }\n        return service;\n    }\n\n    /**\n     * Examines the API key provided in the request, ensures it is valid for RFQM, and fetches the associated\n     * integrator ID.\n     */\n    private _validateApiKey(apiKey: string | undefined, chainId: number): { apiKey: string; integrator: Integrator } {\n        if (apiKey === undefined) {\n            throw new InvalidAPIKeyError('Must access with an API key');\n        }\n        if (!this._configManager.getRfqmApiKeyWhitelist().has(apiKey)) {\n            throw new InvalidAPIKeyError('API key not authorized for RFQM access');\n        }\n        const integratorId = this._configManager.getIntegratorIdForApiKey(apiKey);\n        if (!integratorId) {\n            // With a valid configuration this should never happen\n            throw new InvalidAPIKeyError('API key has no associated Integrator ID');\n        }\n        const integrator = this._configManager.getIntegratorByIdOrThrow(integratorId);\n        if (!integrator.allowedChainIds.includes(chainId)) {\n            throw new InvalidAPIKeyError(`API Key not authorized to access chain ${chainId}`);\n        }\n        return { apiKey, integrator };\n    }\n\n    private async _parseFetchIndicativeQuoteParamsAsync(\n        req: express.Request,\n    ): Promise<{ chainId: number; params: FetchIndicativeQuoteParams }> {\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        schemaUtils.validateSchema(req.query, schemas.indicativeQuoteRequestSchema as any);\n        const { takerAddress } = req.query;\n        const { chainId, params } = await this._parseIndicativeAndFirmQuoteSharedParamsAsync(req);\n\n        return {\n            chainId,\n            params: {\n                ...params,\n                takerAddress: takerAddress as string,\n            },\n        };\n    }\n\n    /**\n     * Parse shared params of indicative and firm quotes.\n     *\n     * @param req The request object.\n     * @returns Chain ID and parsed shared params of indicative and firm quotes.\n     */\n    private async _parseIndicativeAndFirmQuoteSharedParamsAsync(\n        req: express.Request,\n    ): Promise<{ chainId: number; params: FetchQuoteParamsBase }> {\n        const chainId = extractChainId(req);\n        const { integrator } = this._validateApiKey(req.header('0x-api-key'), chainId);\n        const { affiliateAddress } = req.query;\n\n        // Parse tokens\n        const sellTokenRaw = req.query.sellToken as string;\n        const buyTokenRaw = req.query.buyToken as string;\n        validateNotNativeTokenOrThrow(sellTokenRaw, chainId, 'sellToken');\n\n        let buyTokenDecimals: number;\n        let sellTokenDecimals: number;\n        let buyTokenContractAddress: string;\n        let sellTokenContractAddress: string;\n\n        try {\n            buyTokenContractAddress = buyTokenRaw.toLocaleLowerCase().startsWith('0x')\n                ? buyTokenRaw\n                : contractAddressForSymbol(buyTokenRaw, chainId);\n            buyTokenDecimals = await this._getServiceForChain(chainId).getTokenDecimalsAsync(buyTokenRaw);\n        } catch {\n            throw new ValidationError([\n                {\n                    field: 'buyToken',\n                    code: ValidationErrorCodes.AddressNotSupported,\n                    reason: `Token ${buyTokenRaw} is currently unsupported`,\n                },\n            ]);\n        }\n\n        try {\n            sellTokenContractAddress = sellTokenRaw.toLocaleLowerCase().startsWith('0x')\n                ? sellTokenRaw\n                : contractAddressForSymbol(sellTokenRaw, chainId);\n            sellTokenDecimals = await this._getServiceForChain(chainId).getTokenDecimalsAsync(sellTokenRaw);\n        } catch {\n            throw new ValidationError([\n                {\n                    field: 'sellToken',\n                    code: ValidationErrorCodes.AddressNotSupported,\n                    reason: `Token ${sellTokenRaw} is currently unsupported`,\n                },\n            ]);\n        }\n\n        // Parse number params\n        const sellAmount =\n            req.query.sellAmount === undefined ? undefined : new BigNumber(req.query.sellAmount as string);\n        const buyAmount = req.query.buyAmount === undefined ? undefined : new BigNumber(req.query.buyAmount as string);\n\n        return {\n            chainId,\n            params: {\n                buyAmount,\n                buyToken: buyTokenContractAddress,\n                buyTokenDecimals,\n                integrator,\n                sellAmount,\n                sellToken: sellTokenContractAddress,\n                sellTokenDecimals,\n                affiliateAddress: affiliateAddress as string,\n            },\n        };\n    }\n\n    private _parseSubmitSignedQuoteParams(req: express.Request): {\n        chainId: number;\n        integrator: Integrator;\n        params: OtcOrderSubmitRfqmSignedQuoteParams;\n    } {\n        const type = req.body.type as GaslessTypes;\n        const chainId = extractChainId(req);\n        const { integrator } = this._validateApiKey(req.header('0x-api-key'), chainId);\n\n        if (type === GaslessTypes.OtcOrder) {\n            const order = new OtcOrder(stringsToOtcOrderFields(req.body.order as RawOtcOrderFields));\n            const signature = stringsToSignature(req.body.signature as StringSignatureFields);\n            return {\n                chainId,\n                integrator,\n                params: {\n                    type,\n                    order,\n                    signature,\n                },\n            };\n        } else {\n            throw new ValidationError([\n                {\n                    field: 'type',\n                    code: ValidationErrorCodes.FieldInvalid,\n                    reason: `${type} is an invalid value for 'type'`,\n                },\n            ]);\n        }\n    }\n\n    private _parseSubmitSignedQuoteWithApprovalParams<\n        T extends ExecuteMetaTransactionEip712Context | PermitEip712Context,\n    >(\n        req: express.Request,\n    ): {\n        chainId: number;\n        integrator: Integrator;\n        params: SubmitRfqmSignedQuoteWithApprovalParams<T>;\n    } {\n        const chainId = extractChainId(req);\n        const { integrator } = this._validateApiKey(req.header('0x-api-key'), chainId);\n\n        const { approval, trade } = req.body;\n\n        const parsedParams: Partial<SubmitRfqmSignedQuoteWithApprovalParams<T>> = {};\n\n        // Parse approval params\n        if (approval) {\n            if (\n                approval.type === GaslessApprovalTypes.ExecuteMetaTransaction ||\n                approval.type === GaslessApprovalTypes.Permit\n            ) {\n                const eip712 = stringsToEIP712Context(approval.eip712);\n                const signature = stringsToSignature(approval.signature as StringSignatureFields);\n                parsedParams.approval = {\n                    type: approval.type,\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    eip712: eip712 as any,\n                    signature,\n                };\n            } else {\n                throw new ValidationError([\n                    {\n                        field: 'approval',\n                        code: ValidationErrorCodes.FieldInvalid,\n                        reason: `${approval.type} is an invalid value for Approval 'type'`,\n                    },\n                ]);\n            }\n        }\n\n        // Parse trade params\n        const tradeType = trade.type;\n        let otcOrderSubmitRfqmSignedQuoteParams: OtcOrderSubmitRfqmSignedQuoteParams;\n        if (tradeType === GaslessTypes.OtcOrder) {\n            const order = new OtcOrder(stringsToOtcOrderFields(trade.order as RawOtcOrderFields));\n            const signature = stringsToSignature(trade.signature as StringSignatureFields);\n            otcOrderSubmitRfqmSignedQuoteParams = {\n                type: trade.type,\n                order,\n                signature,\n            };\n        } else {\n            throw new ValidationError([\n                {\n                    field: 'type',\n                    code: ValidationErrorCodes.FieldInvalid,\n                    reason: `${trade.type} is an invalid value for Trade 'type'`,\n                },\n            ]);\n        }\n\n        return {\n            chainId,\n            integrator,\n            params: {\n                ...parsedParams,\n                kind: GaslessTypes.OtcOrder, // Must be of type OtcOrder for this flow\n                trade: otcOrderSubmitRfqmSignedQuoteParams,\n            },\n        };\n    }\n}\n\n/**\n * Extracts the Chain Id from the request. If none is provided, assumes a Chain Id of 1 (for backwards compatibility)\n *\n * @param req - the Express Request object\n * @returns the chain Id for this request\n */\nconst extractChainId = (req: express.Request): number => {\n    const chainIdFromHeader = req.header('0x-chain-id');\n    if (chainIdFromHeader === undefined) {\n        return 1;\n    } else {\n        const parsedInt = parseInt(chainIdFromHeader, 10);\n        if (Number.isNaN(parsedInt)) {\n            throw new ValidationError([\n                {\n                    field: '0x-chain-id',\n                    code: ValidationErrorCodes.FieldInvalid,\n                    reason: 'Invalid chain id',\n                },\n            ]);\n        }\n        return parsedInt;\n    }\n};\n\n/**\n * Gets the token address for a given symbol.\n *\n * Throws if the symbol is not present in @0x/token-metadata\n */\nconst contractAddressForSymbol = (symbol: string, chainId: number): string => {\n    const address = getTokenMetadataIfExists(symbol, chainId)?.tokenAddress;\n    if (!address) {\n        throw new Error('Unsupported token');\n    }\n    return address;\n};\n\nconst validateNotNativeTokenOrThrow = (token: string, chainId: number, field: string): boolean => {\n    if (isNativeSymbolOrAddress(token, chainId)) {\n        const symbol = nativeWrappedTokenSymbol(chainId);\n        throw new ValidationError([\n            {\n                field,\n                code: ValidationErrorCodes.TokenNotSupported,\n                reason: `Unwrapped Native Asset is not supported. Use ${symbol} instead`,\n            },\n        ]);\n    }\n\n    return true;\n};\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_health_check.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_request_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_service_builder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/chain_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/chain_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/fee_model_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/fee_model_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/firm_quote_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/indicative_otc_quote_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/indicative_quote_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/integrators_acl_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/integrator_acl_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/rfq_maker_config.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/rfq_maker_config_list.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/sign_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configuration_entry.json","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/WorkerService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/provider_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_request_utils.ts",{"fileContent":"import { MetaTransactionFields, OtcOrderFields, Signature } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\n\nimport { Eip712DataField, Eip712Domain, ExecuteMetaTransactionEip712Context, PermitEip712Context } from '../core/types';\n\nexport interface StringSignatureFields {\n    signatureType: string;\n    v: string;\n    r: string;\n    s: string;\n}\n\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type RawOtcOrderFields = Record<keyof Omit<OtcOrderFields, 'chainId'>, string> & { chainId: any };\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type RawMetaTransactionFields = Record<keyof Omit<MetaTransactionFields, 'chainId'>, string> & { chainId: any };\nexport interface RawEIP712ContextFields {\n    types: Record<string, Record<keyof Eip712DataField, string>[]>;\n    primaryType: string;\n    domain: Record<keyof Eip712Domain, string>;\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    message: Record<string, any>;\n}\n\n/**\n * convert a Signature response into the data types expected by protocol-utils\n */\nexport function stringsToSignature(strings: StringSignatureFields): Signature {\n    return {\n        signatureType: Number(strings.signatureType),\n        v: Number(strings.v),\n        r: strings.r,\n        s: strings.s,\n    };\n}\n\n/**\n * Converts the request payload for a gasless swap metatransaction into\n * the appropriate types\n */\nexport function stringsToMetaTransactionFields(strings: RawMetaTransactionFields): MetaTransactionFields {\n    return {\n        callData: strings.callData,\n        chainId: Number(strings.chainId),\n        expirationTimeSeconds: new BigNumber(strings.expirationTimeSeconds),\n        feeAmount: new BigNumber(strings.feeAmount),\n        feeToken: strings.feeToken,\n        maxGasPrice: new BigNumber(strings.maxGasPrice),\n        minGasPrice: new BigNumber(strings.minGasPrice),\n        salt: new BigNumber(strings.salt),\n        sender: strings.sender,\n        signer: strings.signer,\n        value: new BigNumber(strings.value),\n        verifyingContract: strings.verifyingContract,\n    };\n}\n\n/**\n * convert a JSON OtcOrder into an OtcOrder\n */\nexport function stringsToOtcOrderFields(strings: RawOtcOrderFields): OtcOrderFields {\n    return {\n        maker: strings.maker,\n        taker: strings.taker,\n        makerAmount: new BigNumber(strings.makerAmount),\n        takerAmount: new BigNumber(strings.takerAmount),\n        makerToken: strings.makerToken,\n        takerToken: strings.takerToken,\n        txOrigin: strings.txOrigin,\n        expiryAndNonce: new BigNumber(strings.expiryAndNonce),\n        chainId: Number(strings.chainId),\n        verifyingContract: strings.verifyingContract,\n    };\n}\n\n// Internal function for handling the domain\nfunction _stringsToEIP712Domain(strings: RawEIP712ContextFields['domain']): Eip712Domain {\n    const res: Eip712Domain = {\n        ...strings,\n        chainId: Number(strings.chainId),\n    };\n\n    // remove chainId if its NaN\n    if (Number.isNaN(res.chainId)) {\n        delete res.chainId;\n    }\n\n    return res;\n}\n\n/**\n * convert a JSON EIP712Context into an EIP712Context\n */\nexport function stringsToEIP712Context(\n    strings: RawEIP712ContextFields,\n): ExecuteMetaTransactionEip712Context | PermitEip712Context {\n    return {\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        types: strings.types as any,\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        primaryType: strings.primaryType as any,\n        domain: _stringsToEIP712Domain(strings.domain),\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        message: strings.message as any,\n    };\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/routers/RfqtRouter.ts",{"fileContent":"import * as express from 'express';\nimport * as asyncHandler from 'express-async-handler';\n\nimport { RfqtHandlers } from '../handlers/RfqtHandlers';\nimport { ConfigManager } from '../utils/config_manager';\nimport { RfqtServices } from '../utils/rfqtServiceBuilder';\n\n/**\n * Creates an express router for RFQt v1 related routes\n */\nexport function createRfqtV1Router(rfqtServices: RfqtServices, configManager: ConfigManager): express.Router {\n    const router = express.Router();\n    const handlers = new RfqtHandlers(rfqtServices, configManager);\n\n    router.post('/prices', asyncHandler(handlers.getV1PricesAsync.bind(handlers)));\n    router.post('/quotes', asyncHandler(handlers.getV1QuotesAsync.bind(handlers)));\n\n    return router;\n}\n\n/**\n * Creates an express router for RFQt v2 related routes\n */\nexport function createRfqtV2Router(rfqtServices: RfqtServices, configManager: ConfigManager): express.Router {\n    const router = express.Router();\n    const handlers = new RfqtHandlers(rfqtServices, configManager);\n\n    router.post('/prices', asyncHandler(handlers.getV2PricesAsync.bind(handlers)));\n    router.post('/quotes', asyncHandler(handlers.getV2QuotesAsync.bind(handlers)));\n\n    return router;\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/RfqtHandlers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqtServiceBuilder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/QuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/RfqtService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/RefreshingQuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/provider_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/RfqtHandlers.ts",{"fileContent":"// tslint:disable:max-file-line-count\nimport { MarketOperation } from '@0x/types';\nimport { BigNumber } from '@0x/utils';\nimport * as express from 'express';\nimport * as HttpStatus from 'http-status-codes';\nimport { Counter } from 'prom-client';\n\nimport { Integrator } from '../config';\nimport { logger } from '../logger';\nimport { V4RFQIndicativeQuoteMM } from '../quoteRequestor/QuoteRequestor';\nimport { RfqtService } from '../services/RfqtService';\nimport { FirmQuoteContext, QuoteContext } from '../services/types';\nimport type { RfqtV2Price, RfqtV2Quote, RfqtV2Request, SignedNativeOrder } from '../core/types';\nimport { ConfigManager } from '../utils/config_manager';\nimport { RfqtServices } from '../utils/rfqtServiceBuilder';\nimport type { AltRfqMakerAssetOfferings } from '../quoteRequestor/altMmTypes';\n\nconst RFQT_V1_PRICE_REQUEST_SUCCEEDED = new Counter({\n    name: 'rfqt_v1_price_request_succeeded_total',\n    help: 'Request made to fetch rfqt v1 price succeeded',\n});\n\nconst RFQT_V1_PRICE_REQUEST_FAILED = new Counter({\n    name: 'rfqt_v1_price_request_failed_total',\n    help: 'Request made to fetch rfqt v1 price failed',\n});\n\nconst RFQT_V1_QUOTE_REQUEST_SUCCEEDED = new Counter({\n    name: 'rfqt_v1_quote_request_succeeded_total',\n    help: 'Request to fetch rfqt v1 quote succeeded',\n});\n\nconst RFQT_V1_QUOTE_REQUEST_FAILED = new Counter({\n    name: 'rfqt_v1_quote_request_failed_total',\n    help: 'Request to fetch rfqt v1 quote failed',\n});\n\nconst RFQT_V2_PRICE_REQUEST_SUCCEEDED = new Counter({\n    name: 'rfqt_v2_price_request_succeeded_total',\n    help: 'Request made to fetch rfqt v2 price succeeded',\n});\n\nconst RFQT_V2_PRICE_REQUEST_FAILED = new Counter({\n    name: 'rfqt_v2_price_request_failed_total',\n    help: 'Request made to fetch rfqt v2 price failed',\n});\n\nconst RFQT_V2_QUOTE_REQUEST_SUCCEEDED = new Counter({\n    name: 'rfqt_v2_quote_request_succeeded_total',\n    help: 'Request to fetch rfqt v2 quote succeeded',\n});\n\nconst RFQT_V2_QUOTE_REQUEST_FAILED = new Counter({\n    name: 'rfqt_v2_quote_request_failed_total',\n    help: 'Request to fetch rfqt v2 quote failed',\n});\n\n/**\n * Typed parameters for both the V1 prices endpoint\n * and the V1 quotes endpoint\n */\ninterface V1RequestParameters {\n    altRfqAssetOfferings: AltRfqMakerAssetOfferings;\n    assetFillAmount: BigNumber;\n    chainId: number;\n    comparisonPrice: BigNumber | undefined;\n    makerToken: string;\n    marketOperation: MarketOperation;\n    takerAddress: string; // expect this to be NULL_ADDRESS\n    takerToken: string;\n    txOrigin?: string; // expect this to be the taker address, can be missing for /price but not /quote\n    intentOnFilling: boolean;\n    integratorId: string;\n}\n\ninterface TypedRequest<TBody> extends express.Request {\n    body: TBody;\n}\n\n/**\n * Handles parsing the request from RFQt routes, meters calls with prometheus counters,\n * calls the appropriate service method and returns the result.\n *\n * Error boundary for http calls; all errors should be caught and returned to the\n * caller as part of the response.\n */\nexport class RfqtHandlers {\n    constructor(private readonly _rfqtServices: RfqtServices, private readonly _configManager: ConfigManager) {}\n\n    /**\n     * Gets prices (\"indicative quotes\") for the given asset pair from market makers\n     * operating on the `RfqOrder` RFQt platform\n     */\n    public async getV1PricesAsync(\n        req: TypedRequest<V1RequestParameters>,\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        res: express.Response<{ prices: V4RFQIndicativeQuoteMM[] } | { error: any }>,\n    ): Promise<void> {\n        let parsedParameters: Omit<V1RequestParameters, 'integratorId'> & { integrator: Integrator };\n        let service: RfqtService;\n        try {\n            parsedParameters = this._parseV1RequestParameters(req);\n            service = this._getServiceForChain(parsedParameters.chainId);\n        } catch (error) {\n            RFQT_V1_PRICE_REQUEST_FAILED.inc();\n            logger.error({ error: error.message }, 'Rfqt V1 price request failed');\n            res.status(HttpStatus.BAD_REQUEST).json({ error: error.message });\n            return;\n        }\n\n        try {\n            const prices = await service.getV1PricesAsync(parsedParameters);\n            RFQT_V1_PRICE_REQUEST_SUCCEEDED.inc();\n            logger.info('Rfqt V1 price request succeeded');\n            res.status(HttpStatus.OK).json({\n                prices,\n            });\n        } catch (error) {\n            RFQT_V1_PRICE_REQUEST_FAILED.inc();\n            logger.error({ error: error.message }, 'Rfqt V1 price request failed');\n            res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({ error: error.message });\n        }\n    }\n\n    /**\n     * Gets prices (\"firm quotes\") for the given asset pair from market makers\n     * operating on the `RfqOrder` RFQt platform\n     */\n    public async getV1QuotesAsync(\n        req: TypedRequest<V1RequestParameters>,\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        res: express.Response<{ quotes: SignedNativeOrder[] } | { error: any }>,\n    ): Promise<void> {\n        let parsedParameters: Omit<V1RequestParameters, 'integratorId'> & { integrator: Integrator };\n        let service: RfqtService;\n        let txOrigin: string;\n        try {\n            parsedParameters = this._parseV1RequestParameters(req);\n            if (parsedParameters.txOrigin === undefined) {\n                throw new Error('Received request with missing parameter txOrigin');\n            }\n            txOrigin = parsedParameters.txOrigin;\n            service = this._getServiceForChain(parsedParameters.chainId);\n        } catch (error) {\n            RFQT_V1_QUOTE_REQUEST_FAILED.inc();\n            logger.error({ error }, 'Rfqt V1 quote request failed');\n            res.status(HttpStatus.BAD_REQUEST).json({ error });\n            return;\n        }\n\n        try {\n            const quotes = await service.getV1QuotesAsync({\n                ...parsedParameters,\n                txOrigin,\n            });\n            RFQT_V1_QUOTE_REQUEST_SUCCEEDED.inc();\n            logger.info('Rfqt V1 quote request succeeded');\n            res.status(HttpStatus.OK).json({\n                quotes,\n            });\n        } catch (error) {\n            RFQT_V1_QUOTE_REQUEST_FAILED.inc();\n            logger.error({ error }, 'Rfqt V1 quote request failed');\n            res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({ error: error.message });\n        }\n    }\n\n    /**\n     * Gets prices (\"indicative quotes\") for the given asset pair from market makers\n     * operating on the `OtcOrder` RFQt platform\n     */\n    public async getV2PricesAsync(\n        req: TypedRequest<RfqtV2Request>,\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        res: express.Response<{ prices: RfqtV2Price[] } | { error: any }>,\n    ): Promise<void> {\n        let quoteContext: QuoteContext;\n        let service: RfqtService;\n        try {\n            const chainId = this._extractChainId(req);\n            service = this._getServiceForChain(chainId);\n            quoteContext = await this._extractQuoteContextAsync(req, chainId, false, service);\n        } catch (error) {\n            RFQT_V2_PRICE_REQUEST_FAILED.inc();\n            logger.error({ error: error.message }, 'Rfqt V2 price request failed');\n            res.status(HttpStatus.BAD_REQUEST).json({ error: error.message });\n            return;\n        }\n\n        try {\n            const prices = await service.getV2PricesAsync(quoteContext);\n            RFQT_V2_PRICE_REQUEST_SUCCEEDED.inc();\n            logger.info('Rfqt V2 price request succeeded');\n            res.status(HttpStatus.OK).json({\n                prices,\n            });\n        } catch (error) {\n            RFQT_V2_PRICE_REQUEST_FAILED.inc();\n            logger.error({ error: error.message }, 'Rfqt V2 price request failed');\n            res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({ error: error.message });\n        }\n    }\n\n    /**\n     * Gets quotes (\"firm quotes\") for the given asset pair from market makers\n     * operating on the `OtcOrder` RFQt platform\n     */\n    public async getV2QuotesAsync(\n        req: TypedRequest<RfqtV2Request>,\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        res: express.Response<{ quotes: RfqtV2Quote[] } | { error: any }>,\n    ): Promise<void> {\n        let quoteContext: FirmQuoteContext;\n        let service: RfqtService;\n        try {\n            const chainId = this._extractChainId(req);\n            service = this._getServiceForChain(chainId);\n            quoteContext = (await this._extractQuoteContextAsync(req, chainId, true, service)) as FirmQuoteContext;\n        } catch (error) {\n            RFQT_V2_QUOTE_REQUEST_FAILED.inc();\n            logger.error({ error }, 'Rfqt V2 quote request failed');\n            res.status(HttpStatus.BAD_REQUEST).json({ error });\n            return;\n        }\n\n        try {\n            const quotes = await service.getV2QuotesAsync(quoteContext);\n            RFQT_V2_QUOTE_REQUEST_SUCCEEDED.inc();\n            logger.info('Rfqt V2 quote request succeeded');\n            res.status(HttpStatus.OK).json({\n                quotes,\n            });\n        } catch (error) {\n            RFQT_V2_QUOTE_REQUEST_FAILED.inc();\n            logger.error({ error }, 'Rfqt V2 quote request failed');\n            res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({ error: error.message });\n        }\n    }\n\n    /**\n     * Parses and runtime-checks request parameters. After running the method, the parameters\n     * should match their TypeScript types.\n     */\n    private _parseV1RequestParameters<TRequest extends TypedRequest<V1RequestParameters>>(\n        request: TRequest,\n    ): V1RequestParameters & { integrator: Integrator } {\n        const { body } = request;\n\n        // Doing this before destructuring the body, otherwise the error\n        // thrown will be something like:\n        // 'Cannot destructure property 'altRfqAssetOfferings' of 'request.body' as it is undefined.'\n        if (\n            !body.altRfqAssetOfferings ||\n            !body.assetFillAmount ||\n            !body.makerToken ||\n            !body.marketOperation ||\n            !body.takerToken ||\n            !body.takerAddress ||\n            typeof body.intentOnFilling !== 'boolean' ||\n            !body.integratorId\n        ) {\n            throw new Error('Received request with missing parameters');\n        }\n\n        const { assetFillAmount, comparisonPrice, marketOperation, integratorId } = request.body;\n\n        const parsedChainId = this._extractChainId(request);\n        if (Number.isNaN(parsedChainId)) {\n            throw new Error('Chain ID is invalid');\n        }\n\n        if (\n            (marketOperation as string) !== MarketOperation.Buy.toString() &&\n            (marketOperation as string) !== MarketOperation.Sell.toString()\n        ) {\n            throw new Error('Received request with invalid market operation');\n        }\n\n        let integrator: Integrator;\n        try {\n            integrator = this._configManager.getIntegratorByIdOrThrow(integratorId);\n        } catch (error) {\n            throw new Error('No integrator found for integrator ID');\n        }\n\n        return {\n            ...request.body,\n            assetFillAmount: new BigNumber(assetFillAmount),\n            chainId: parsedChainId,\n            comparisonPrice: comparisonPrice ? new BigNumber(comparisonPrice) : undefined,\n            integrator,\n        };\n    }\n\n    /**\n     * Extract chainId from request parameters.\n     */\n    private _extractChainId<TRequest extends TypedRequest<RfqtV2Request>>(request: TRequest): number {\n        const chainIdFromHeader = request.header('0x-chain-id');\n        if (chainIdFromHeader === undefined) {\n            throw new Error('Chain ID is not provided');\n        } else {\n            const parsedChainId = parseInt(chainIdFromHeader, 10);\n            if (Number.isNaN(parsedChainId)) {\n                throw new Error('Chain ID is invalid');\n            }\n            return parsedChainId;\n        }\n    }\n\n    /**\n     * Extract quote context from request parameters. After running the method, the parameters\n     * should match their TypeScript types.\n     */\n    private async _extractQuoteContextAsync<TRequest extends TypedRequest<RfqtV2Request>>(\n        request: TRequest,\n        chainId: number,\n        isFirm: boolean,\n        service: RfqtService,\n    ): Promise<QuoteContext> {\n        const { body } = request;\n\n        // Doing this before destructuring the body, otherwise the error\n        // thrown will be something like:\n        // 'Cannot destructure property 'assetFillAmount' of 'request.body' as it is undefined.'\n        if (\n            !body.assetFillAmount ||\n            !body.makerToken ||\n            !body.marketOperation ||\n            !body.takerToken ||\n            !body.takerAddress ||\n            // TODO: add body.trader to these checks once we've rolled out completely\n            typeof body.intentOnFilling !== 'boolean' ||\n            !body.integratorId\n        ) {\n            throw new Error('Received request with missing parameters');\n        }\n\n        const {\n            takerToken,\n            makerToken,\n            trader,\n            gasless,\n            takerAddress,\n            txOrigin,\n            assetFillAmount: assetFillAmountStr,\n            marketOperation,\n            integratorId,\n            bucket,\n        } = request.body;\n\n        if (\n            (marketOperation as string) !== MarketOperation.Buy.toString() &&\n            (marketOperation as string) !== MarketOperation.Sell.toString()\n        ) {\n            throw new Error('Received request with invalid market operation');\n        }\n\n        let integrator: Integrator;\n        try {\n            integrator = this._configManager.getIntegratorByIdOrThrow(integratorId);\n        } catch (error) {\n            throw new Error('No integrator found for integrator ID');\n        }\n\n        if (isFirm && txOrigin === undefined) {\n            throw new Error('Received request with missing parameter txOrigin');\n        }\n\n        const isSelling = (marketOperation as string) === MarketOperation.Sell.toString();\n        const assetFillAmount = new BigNumber(assetFillAmountStr);\n        let takerAmount, makerAmount;\n        if (isSelling) {\n            takerAmount = assetFillAmount;\n        } else {\n            makerAmount = assetFillAmount;\n        }\n        const takerTokenDecimals = await service.getTokenDecimalsAsync(takerToken);\n        const makerTokenDecimals = await service.getTokenDecimalsAsync(makerToken);\n\n        return {\n            workflow: gasless ? 'gasless-rfqt' : 'rfqt',\n            chainId,\n            isFirm,\n            takerToken,\n            makerToken,\n            originalMakerToken: makerToken,\n            trader: trader || takerAddress, // TODO: remove the takerAddress fallback once we've rolled out completely\n            takerAddress,\n            txOrigin,\n            takerAmount,\n            makerAmount,\n            takerTokenDecimals,\n            makerTokenDecimals,\n            integrator,\n            isUnwrap: false,\n            isSelling,\n            assetFillAmount,\n            feeModelVersion: service.feeModelVersion,\n            bucket,\n        } as QuoteContext;\n    }\n\n    /**\n     * Gets the appropriate `RfqtService` instance from the\n     * Chain ID -> Rfqt Service Map. Throws if no service is found\n     * for `chainId`.\n     */\n    private _getServiceForChain(chainId: number): RfqtService {\n        const service = this._rfqtServices.get(chainId);\n\n        if (!service) {\n            throw new Error('No configuration exists for chain');\n        }\n        return service;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/QuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/RfqtService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqtServiceBuilder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmTypes.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmImplementaionUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/rfqMakerBlacklist.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/number_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/RfqtQuoteValidator.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/RefreshingQuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/provider_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/routers/rfq_admin_router.ts",{"fileContent":"import * as express from 'express';\nimport * as asyncHandler from 'express-async-handler';\n\nimport { RfqAdminHandler } from '../handlers/rfq_admin_handler';\nimport { RfqAdminService } from '../services/rfq_admin_service';\nimport { ConfigManager } from '../utils/config_manager';\n\n// tslint:disable-next-line:completed-docs\nexport function createRfqAdminRouter(rfqAdminService: RfqAdminService, configManager: ConfigManager): express.Router {\n    const router = express.Router();\n    const handlers = new RfqAdminHandler(rfqAdminService, configManager);\n\n    // Admin Routes\n    router.post('/cleanup', asyncHandler(handlers.cleanupJobsAsync.bind(handlers)));\n\n    return router;\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/rfq_admin_handler.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_admin_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/rfq_admin_handler.ts",{"fileContent":"import * as express from 'express';\nimport * as HttpStatus from 'http-status-codes';\n\nimport { RfqAdminService } from '../services/rfq_admin_service';\nimport { ConfigManager } from '../utils/config_manager';\n\nexport class RfqAdminHandler {\n    constructor(private readonly _rfqAdminService: RfqAdminService, private readonly _configManager: ConfigManager) {}\n\n    /**\n     * Handler for the `/cleanup` endpoint. Fetches jobs from their order hashes and puts them to\n     * `failed_expired` state. Requires an admin API key.\n     */\n    public async cleanupJobsAsync(req: express.Request, res: express.Response): Promise<void> {\n        // validate admin api key\n        try {\n            this._validateAdminApiKey(req.header('0x-admin-api-key'));\n        } catch (err) {\n            const message = 'Invalid admin API key provided';\n            req.log.error(err, message);\n            res.status(HttpStatus.UNAUTHORIZED).send({ error: message });\n        }\n\n        try {\n            if (req.body.orderHashes.length === 0) {\n                res.status(HttpStatus.BAD_REQUEST).send({ error: 'Must send at least one order hash' });\n            }\n\n            const response = await this._rfqAdminService.cleanupJobsAsync(req.body.orderHashes);\n            if (response.unmodifiedJobs.length > 0 && response.modifiedJobs.length > 0) {\n                res.status(HttpStatus.MULTI_STATUS).send(response);\n            } else if (response.unmodifiedJobs.length !== 0) {\n                res.status(HttpStatus.BAD_REQUEST).send(response);\n            } else {\n                res.status(HttpStatus.OK).send(response);\n            }\n        } catch (err) {\n            const message = 'Encountered an unexpected error while manually cleaning up jobs';\n            req.log.error(err, message);\n            res.status(HttpStatus.INTERNAL_SERVER_ERROR).send({ error: message });\n        }\n    }\n\n    private _validateAdminApiKey(apiKey: string | undefined): void {\n        if (apiKey === undefined) {\n            throw new Error('Must access with an API key');\n        }\n        if (apiKey !== this._configManager.getAdminApiKey()) {\n            throw new Error('API key not authorized for RFQM admin access');\n        }\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_admin_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/routers/rfq_maker_router.ts",{"fileContent":"import * as express from 'express';\nimport * as asyncHandler from 'express-async-handler';\nimport * as swaggerUi from 'swagger-ui-express';\n\nimport * as apiDocs from '../api-docs/rfq_maker_docs.json';\nimport { RfqMakerHandlers } from '../handlers/rfq_maker_handlers';\nimport { RfqMakerService } from '../services/rfq_maker_service';\n\n/**\n * Create a RFQ maker API router, which routes incoming requests to RFQ maker API handler.\n * Also provides swagger endpoints to serve the documentation of the maker API.\n * @param rfqMakerService Injected service object which validate incoming requests and do the jobs.\n * @returns the RFQ maker API router\n */\nexport function createRfqMakerRouter(rfqMakerService: RfqMakerService): express.Router {\n    const router = express.Router();\n    const handlers = new RfqMakerHandlers(rfqMakerService);\n\n    // Routes\n    router.get('/chain-id/:chainId', asyncHandler(handlers.getRfqMakerAsync.bind(handlers)));\n    router.put('/chain-id/:chainId', asyncHandler(handlers.putRfqMakerAsync.bind(handlers)));\n    router.patch('/chain-id/:chainId', asyncHandler(handlers.patchRfqMakerAsync.bind(handlers)));\n\n    // Swagger\n    const swaggerOptions = {\n        swaggerOptions: {\n            url: '/api-docs/swagger.json',\n        },\n    };\n\n    router.use('/api-docs', swaggerUi.serveFiles(apiDocs, swaggerOptions));\n    router.get('/api-docs', swaggerUi.setup(apiDocs, swaggerOptions));\n    router.get('/api-docs/swagger.json', (_req, res) => res.json(apiDocs));\n\n    return router;\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/api-docs/rfq_maker_docs.json","/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/rfq_maker_handlers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/rfq_maker_handlers.ts",{"fileContent":"import * as express from 'express';\nimport * as HttpStatus from 'http-status-codes';\nimport { Counter } from 'prom-client';\n\nimport { RFQ_MAKER_API_KEY_HEADER } from '../core/constants';\nimport { RfqMaker } from '../entities';\nimport { logger } from '../logger';\nimport { RfqMakerService } from '../services/rfq_maker_service';\n\nconst RFQ_MAKER_INVALID_KEY = new Counter({\n    name: 'rfq_maker_invalid_key',\n    help: 'A request to maker endpoints failed because of invalid api key.',\n});\nconst RFQ_MAKER_UPDATE_CLIENT_ERROR = new Counter({\n    name: 'rfq_maker_update_client_error',\n    help: 'A request to update maker configs failed because of client side error.',\n    labelNames: ['makerId'],\n});\nconst RFQ_MAKER_UPDATE_SEVER_ERROR = new Counter({\n    name: 'rfq_maker_update_sever_error',\n    help: 'A request to update maker configs failed because of sever side error.',\n    labelNames: ['makerId'],\n});\nconst RFQ_MAKER_UPDATE_SUCCEED = new Counter({\n    name: 'rfq_maker_update_succeed',\n    help: 'A request to update maker configs succeeded.',\n    labelNames: ['makerId'],\n});\nconst RFQ_MAKER_GET_CLIENT_ERROR = new Counter({\n    name: 'rfq_maker_get_client_error',\n    help: 'A request to GET maker failed because of client side error.',\n    labelNames: ['makerId'],\n});\nconst RFQ_MAKER_GET_SEVER_ERROR = new Counter({\n    name: 'rfq_maker_get_sever_error',\n    help: 'A request to GET maker endpoint failed because of sever side error.',\n    labelNames: ['makerId'],\n});\nconst RFQ_MAKER_GET_SUCCEED = new Counter({\n    name: 'rfq_maker_get_succeed',\n    help: 'A request to GET maker succeeded.',\n    labelNames: ['makerId'],\n});\n\nconst convertToLowerCase = (pairs: [string, string][]): [string, string][] => {\n    return pairs.map((pair) => {\n        return [pair[0].toLowerCase(), pair[1].toLowerCase()];\n    });\n};\n\n/**\n * Validates the request body of a PUT request.\n */\nconst validatePutPayloadOrThrow = (body: { pairs: []; rfqtUri: string; rfqmUri: string }) => {\n    RfqMakerService.validatePairsPayloadOrThrow(body.pairs);\n    RfqMakerService.validateUriOrThrow('rfqtUri', body.rfqtUri);\n    RfqMakerService.validateUriOrThrow('rfqmUri', body.rfqmUri);\n};\n\n/**\n * Validates the request body of a PATCH request.\n */\nconst validatePatchPayloadOrThrow = (body: { pairs?: []; rfqtUri?: string; rfqmUri?: string }) => {\n    if (body.pairs !== undefined) {\n        RfqMakerService.validatePairsPayloadOrThrow(body.pairs);\n    }\n\n    if (body.rfqtUri !== undefined) {\n        RfqMakerService.validateUriOrThrow('rfqtUri', body.rfqtUri);\n    }\n\n    if (body.rfqmUri !== undefined) {\n        RfqMakerService.validateUriOrThrow('rfqmUri', body.rfqmUri);\n    }\n\n    if (body.pairs === undefined && body.rfqtUri === undefined && body.rfqmUri === undefined) {\n        throw new Error('No valid field is specified.');\n    }\n};\n\nexport class RfqMakerHandlers {\n    constructor(private readonly _rfqMakerService: RfqMakerService) {}\n\n    /**\n     * Handler for PUT operation of the `/maker/v1/chain-id/:chainId` endpoint.\n     */\n    public async putRfqMakerAsync(req: express.Request, res: express.Response): Promise<void> {\n        const requestId = req.id;\n        const makerApiKey = req.headers[RFQ_MAKER_API_KEY_HEADER] as string;\n        const makerId = this._rfqMakerService.mapMakerApiKeyToId(makerApiKey);\n\n        if (makerId === null) {\n            const message = `Invalid api key.`;\n            logger.info({ requestId, apiKey: makerApiKey }, message);\n            RFQ_MAKER_INVALID_KEY.inc();\n            res.status(HttpStatus.UNAUTHORIZED).send({ error: message });\n            return;\n        }\n\n        if (!RfqMakerService.isValidChainId(req.params.chainId)) {\n            const message = `Invalid chainId.`;\n            logger.info({ requestId, makerId, chainId: req.params.chainId }, message);\n            RFQ_MAKER_UPDATE_CLIENT_ERROR.labels(makerId).inc();\n            res.status(HttpStatus.BAD_REQUEST).send({ error: message });\n            return;\n        }\n\n        const chainId = Number(req.params.chainId);\n        try {\n            validatePutPayloadOrThrow(req.body);\n        } catch ({ message }) {\n            logger.info({ requestId, makerId, chainId }, message);\n            RFQ_MAKER_UPDATE_CLIENT_ERROR.labels(makerId).inc();\n            res.status(HttpStatus.BAD_REQUEST).send({ error: message });\n            return;\n        }\n\n        try {\n            const pairs = req.body.pairs;\n            const rfqtUri = req.body.rfqtUri;\n            const rfqmUri = req.body.rfqmUri;\n            const rfqMaker: RfqMaker = await this._rfqMakerService.createOrUpdateRfqMakerAsync(\n                makerId,\n                chainId,\n                convertToLowerCase(pairs),\n                rfqtUri,\n                rfqmUri,\n            );\n            res.status(HttpStatus.CREATED).send(rfqMaker);\n            const rfqmMakerUri = rfqMaker.rfqmUri;\n            logger.info(\n                { requestId, makerId, chainId, rfqmMakerUri },\n                'Successfully created or updated RfqMaker entity.',\n            );\n            RFQ_MAKER_UPDATE_SUCCEED.labels(makerId).inc();\n        } catch (error) {\n            const message = `Failed to create or update RfqMaker entity.`;\n            logger.error({ requestId, makerId, chainId, errorMessage: error.message }, message);\n            RFQ_MAKER_UPDATE_SEVER_ERROR.labels(makerId).inc();\n            res.status(HttpStatus.INTERNAL_SERVER_ERROR).send({ message });\n        }\n    }\n\n    /**\n     * Handler for PATCH operation of the `/maker/v1/chain-id/:chainId` endpoint.\n     */\n    public async patchRfqMakerAsync(req: express.Request, res: express.Response): Promise<void> {\n        const requestId = req.id;\n        const makerApiKey = req.headers[RFQ_MAKER_API_KEY_HEADER] as string;\n        const makerId = this._rfqMakerService.mapMakerApiKeyToId(makerApiKey);\n\n        if (makerId === null) {\n            const message = `Invalid api key.`;\n            logger.info({ requestId, apiKey: makerApiKey }, message);\n            RFQ_MAKER_INVALID_KEY.inc();\n            res.status(HttpStatus.UNAUTHORIZED).send({ error: message });\n            return;\n        }\n\n        if (!RfqMakerService.isValidChainId(req.params.chainId)) {\n            const message = `Invalid chainId.`;\n            logger.info({ requestId, makerId, chainId: req.params.chainId }, message);\n            RFQ_MAKER_UPDATE_CLIENT_ERROR.labels(makerId).inc();\n            res.status(HttpStatus.BAD_REQUEST).send({ error: message });\n            return;\n        }\n\n        const chainId = Number(req.params.chainId);\n        try {\n            validatePatchPayloadOrThrow(req.body);\n        } catch ({ message }) {\n            logger.info({ requestId, makerId, chainId }, message);\n            RFQ_MAKER_UPDATE_CLIENT_ERROR.labels(makerId).inc();\n            res.status(HttpStatus.BAD_REQUEST).send({ error: message });\n            return;\n        }\n\n        try {\n            const pairs = req.body.pairs;\n            const rfqtUri = req.body.rfqtUri;\n            const rfqmUri = req.body.rfqmUri;\n            const rfqMaker: RfqMaker = await this._rfqMakerService.patchRfqMakerAsync(\n                makerId,\n                chainId,\n                pairs !== undefined ? convertToLowerCase(pairs) : undefined,\n                rfqtUri,\n                rfqmUri,\n            );\n            res.status(HttpStatus.OK).send(rfqMaker);\n            const rfqmMakerUri = rfqMaker.rfqmUri;\n            logger.info({ requestId, makerId, chainId, rfqmMakerUri }, 'Successfully patched RfqMaker entity.');\n            RFQ_MAKER_UPDATE_SUCCEED.labels(makerId).inc();\n        } catch (error) {\n            const message = `Failed to patch RfqMaker entity.`;\n            logger.error({ requestId, makerId, chainId, errorMessage: error.message }, message);\n            RFQ_MAKER_UPDATE_SEVER_ERROR.labels(makerId).inc();\n            res.status(HttpStatus.INTERNAL_SERVER_ERROR).send({ message });\n        }\n    }\n\n    /**\n     * Handler for GET operation of the `/maker/v1/chain-id/:chainId` endpoint.\n     */\n    public async getRfqMakerAsync(req: express.Request, res: express.Response): Promise<void> {\n        const requestId = req.id;\n        const makerApiKey = req.headers[RFQ_MAKER_API_KEY_HEADER] as string;\n        const makerId = this._rfqMakerService.mapMakerApiKeyToId(makerApiKey);\n\n        if (makerId === null) {\n            const message = `Invalid api key.`;\n            logger.info({ requestId, apiKey: makerApiKey }, message);\n            RFQ_MAKER_INVALID_KEY.inc();\n            res.status(HttpStatus.UNAUTHORIZED).send({ error: message });\n            return;\n        }\n\n        if (!RfqMakerService.isValidChainId(req.params.chainId)) {\n            const message = `Invalid chainId.`;\n            logger.info({ requestId, makerId, chainId: req.params.chainId }, message);\n            RFQ_MAKER_GET_CLIENT_ERROR.labels(makerId).inc();\n            res.status(HttpStatus.BAD_REQUEST).send({ error: message });\n            return;\n        }\n\n        const chainId = Number(req.params.chainId);\n\n        try {\n            const rfqMaker: RfqMaker = await this._rfqMakerService.getRfqMakerAsync(makerId, chainId);\n            res.status(HttpStatus.OK).send(rfqMaker);\n            logger.info({ requestId, makerId, chainId }, 'Successfully got RfqMaker entity.');\n            RFQ_MAKER_GET_SUCCEED.labels(makerId).inc();\n        } catch (error) {\n            const message = `Failed to get RfqMaker entity.`;\n            logger.error({ requestId, makerId, chainId, errorMessage: error.message }, message);\n            RFQ_MAKER_GET_SEVER_ERROR.labels(makerId).inc();\n            res.status(HttpStatus.INTERNAL_SERVER_ERROR).send({ message });\n        }\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_service.ts",{"fileContent":"import { ChainId } from '@0x/contract-addresses';\nimport { addressUtils } from '@0x/utils';\nimport { isArray } from 'lodash';\n\nimport { RfqMaker } from '../entities';\nimport { ConfigManager } from '../utils/config_manager';\nimport { RfqMakerDbUtils } from '../utils/rfq_maker_db_utils';\n\n/**\n * RfqMakerService is the coordination layer for HTTP maker services.\n */\nexport class RfqMakerService {\n    /**\n     * Validates that the chainId specified by client is a valid (and known) chain ID.\n     */\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    public static isValidChainId(chainId: any): chainId is ChainId {\n        return Object.values(ChainId).includes(Number(chainId));\n    }\n\n    /**\n     * Validates that the URIs (either rfqtUri or rfqmUri) specified by client is a valid URI or null.\n     */\n    public static validateUriOrThrow(fieldName: string, uri: string | null | undefined): void {\n        if (uri === null) {\n            return;\n        }\n\n        if (uri === undefined || !uri.startsWith('http')) {\n            throw new Error(`Invalid value of ${fieldName}: ${uri}`);\n        }\n    }\n\n    /**\n     * Validates that a payload of market maker pairs is well-formed\n     * and contains valid contract addresses.\n     *\n     * @throws if the payload is invalid\n     */\n    public static validatePairsPayloadOrThrow(pairs: [string, string][]): void {\n        if (!isArray(pairs)) {\n            throw new Error('pairs is not an array.');\n        }\n\n        pairs.forEach((pair, i) => {\n            if (!isArray(pair)) {\n                throw new Error(`pair ${i} is not an array.`);\n            }\n            if (pair.length !== 2) {\n                throw new Error(`pair ${i} array does not consist of exactly two elements.`);\n            }\n            if (!addressUtils.isAddress(pair[0])) {\n                throw new Error(`address of first token for pair ${i} is invalid.`);\n            }\n            if (!addressUtils.isAddress(pair[1])) {\n                throw new Error(`address of second token for pair ${i} is invalid.`);\n            }\n            if (pair[0] === pair[1]) {\n                throw new Error(`pair array ${i} has identical assets.`);\n            }\n        });\n    }\n\n    constructor(private readonly _dbUtils: RfqMakerDbUtils, private readonly _configManager: ConfigManager) {}\n\n    /**\n     * Get the config of a maker on a given blockchain from DB.\n     * Return a `RfqMaker` which specifies makerId, chainId, update time, the pairs array, rfqtUri and rfqmUir.\n     * If not found in DB, return the default entity for the makerId and chainId with empty pairs array, and `null` URIs.\n     */\n    public async getRfqMakerAsync(makerId: string, chainId: number): Promise<RfqMaker> {\n        const result = await this._dbUtils.getRfqMakerAsync(makerId, chainId);\n        return result ?? new RfqMaker({ makerId, chainId, updatedAt: null, pairs: [], rfqtUri: null, rfqmUri: null });\n    }\n\n    /**\n     * Create or update a record in the `rfq_maker_pairs` DB table for the maker on a given blockchain.\n     * Return the `RfqMaker` entity which represents the new record.\n     */\n    public async createOrUpdateRfqMakerAsync(\n        makerId: string,\n        chainId: number,\n        pairs: [string, string][],\n        rfqtUri: string | null,\n        rfqmUri: string | null,\n    ): Promise<RfqMaker> {\n        return this._dbUtils.createOrUpdateRfqMakerAsync(makerId, chainId, pairs, rfqtUri, rfqmUri);\n    }\n\n    /**\n     * Update one or more fields of a record in the `rfq_maker_pairs` DB table for the maker on a given blockchain.\n     * Return the `RfqMaker` entity which represents the new record.\n     */\n    public async patchRfqMakerAsync(\n        makerId: string,\n        chainId: number,\n        pairs: [string, string][] | undefined,\n        rfqtUri: string | null | undefined,\n        rfqmUri: string | null | undefined,\n    ): Promise<RfqMaker> {\n        const oldRfqMaker = await this.getRfqMakerAsync(makerId, chainId);\n\n        return this.createOrUpdateRfqMakerAsync(\n            makerId,\n            chainId,\n            pairs !== undefined ? pairs : oldRfqMaker.pairs,\n            rfqtUri !== undefined ? rfqtUri : oldRfqMaker.rfqtUri,\n            rfqmUri !== undefined ? rfqmUri : oldRfqMaker.rfqmUri,\n        );\n    }\n\n    /**\n     * Maps the given maker API key to makerId.\n     * Returns null is the input key is `undefined` or unknown.\n     */\n    public mapMakerApiKeyToId(apiKey: string | undefined): string | null {\n        if (apiKey === undefined) {\n            return null;\n        }\n\n        return this._configManager.getRfqMakerIdForApiKey(apiKey) || null;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_admin_service.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\n\nimport { ONE_SECOND_MS } from '../core/constants';\nimport { RfqmJobStatus, UnresolvedRfqmJobStatuses } from '../entities/types';\nimport { logger } from '../logger';\nimport { RfqmDbUtils } from '../utils/rfqm_db_utils';\n\nimport { CleanupJobsResponse } from './types';\n\n/**\n * RfqAdminService is the coordination layer for admin HTTP services.\n * It currently uses the admin API key for authentication, but\n * this can be replaced with a more sophisticated means of authentication.\n */\nexport class RfqAdminService {\n    constructor(private readonly _dbUtils: RfqmDbUtils) {}\n\n    /**\n     * Cleans up pending jobs by manually setting the status to `FailedExpired`.\n     * Ignores jobs not in a pending status.\n     */\n    public async cleanupJobsAsync(orderHashes: string[], now: Date = new Date()): Promise<CleanupJobsResponse> {\n        const modifiedJobs: string[] = [];\n        const unmodifiedJobs: string[] = [];\n\n        const handleJob = async (orderHash: string): Promise<void> => {\n            const job = await this._dbUtils.findV2JobByOrderHashAsync(orderHash);\n\n            if (!job) {\n                logger.error({ orderHash }, `No job found for order hash`);\n                unmodifiedJobs.push(orderHash);\n                return;\n            }\n\n            if (!UnresolvedRfqmJobStatuses.includes(job.status)) {\n                logger.error({ orderHash, status: job.status }, 'Tried to clean up a resolved job');\n                unmodifiedJobs.push(orderHash);\n                return;\n            }\n\n            try {\n                const { expiry } = job;\n                const thirtySecondsPastExpiry = expiry.plus(new BigNumber(30));\n                const nowSeconds = new BigNumber(now.getTime() / ONE_SECOND_MS);\n\n                if (nowSeconds.isGreaterThan(thirtySecondsPastExpiry)) {\n                    job.status = RfqmJobStatus.FailedExpired;\n                    await this._dbUtils.updateRfqmJobAsync(job);\n                    logger.info({ orderHash }, 'Job status manually updated to failure');\n                    modifiedJobs.push(orderHash);\n                } else {\n                    logger.error({ orderHash }, 'Tried to clean up an unexpired job');\n                    unmodifiedJobs.push(orderHash);\n                }\n            } catch (error) {\n                logger.error({ orderHash }, 'Failed to clean up the job');\n                unmodifiedJobs.push(orderHash);\n            }\n        };\n\n        await Promise.all(orderHashes.map((h) => handleJob(h)));\n\n        return {\n            modifiedJobs,\n            unmodifiedJobs,\n        };\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqtServiceBuilder.ts",{"fileContent":"import { SupportedProvider } from '@0x/asset-swapper';\nimport { getContractAddressesForChainOrThrow } from '@0x/contract-addresses';\nimport { getTokenMetadataIfExists } from '@0x/token-metadata';\nimport Axios, { AxiosRequestConfig } from 'axios';\nimport { providers } from 'ethers';\nimport { Agent as HttpAgent } from 'http';\nimport { Agent as HttpsAgent } from 'https';\nimport Redis from 'ioredis';\nimport { Kafka, Producer as KafkaProducer } from 'kafkajs';\n\nimport {\n    ALT_RFQ_MM_API_KEY,\n    ALT_RFQ_MM_PROFILE,\n    ChainConfigurations,\n    DEFINED_FI_API_KEY,\n    DEFINED_FI_ENDPOINT,\n    KAFKA_BROKERS,\n    RFQ_PROXY_ADDRESS,\n    RFQ_PROXY_PORT,\n    ZERO_EX_API_KEY,\n} from '../config';\nimport { DEFAULT_MIN_EXPIRY_DURATION_MS, KEEP_ALIVE_TTL } from '../core/constants';\nimport { RefreshingQuoteRequestor } from '../quoteRequestor/RefreshingQuoteRequestor';\nimport { FeeService } from '../services/fee_service';\nimport { RfqtService } from '../services/RfqtService';\nimport { RfqMakerBalanceCacheService } from '../services/rfq_maker_balance_cache_service';\n\nimport { BalanceChecker } from './balance_checker';\nimport { CacheClient } from './cache_client';\nimport { ConfigManager } from './config_manager';\nimport { getGasStationAttendant } from './GasStationAttendantUtils';\nimport { providerUtils } from './provider_utils';\nimport { QuoteServerClient } from './quote_server_client';\nimport { RfqBalanceCheckUtils, RfqBlockchainUtils } from './rfq_blockchain_utils';\nimport { RfqMakerDbUtils } from './rfq_maker_db_utils';\nimport { RfqMakerManager } from './rfq_maker_manager';\nimport { TokenMetadataManager } from './TokenMetadataManager';\nimport { TokenPriceOracle } from './TokenPriceOracle';\nimport { ZeroExApiClient } from './ZeroExApiClient';\n\nexport type RfqtServices = Map<number, RfqtService>;\n\nconst DEFAULT_AXIOS_TIMEOUT = 600; // ms\n\n/**\n * Creates an RFQT Service for each chain present in `ChainConfigurations`.\n *\n * Intended for use by the top-level runners.\n */\nexport async function buildRfqtServicesAsync(\n    chainConfigurations: ChainConfigurations,\n    rfqMakerDbUtils: RfqMakerDbUtils,\n    redis: Redis,\n): Promise<RfqtServices> {\n    const proxiedAxiosInstance = Axios.create(getAxiosRequestConfigWithProxy());\n    const axiosInstance = Axios.create(getAxiosRequestConfig());\n    const configManager = new ConfigManager();\n    const altRfqOptions =\n        ALT_RFQ_MM_API_KEY !== undefined && ALT_RFQ_MM_PROFILE !== undefined\n            ? {\n                  // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  altRfqApiKey: ALT_RFQ_MM_API_KEY!,\n                  // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  altRfqProfile: ALT_RFQ_MM_PROFILE!,\n              }\n            : undefined;\n    const services = await Promise.all(\n        chainConfigurations.map(async (chain) => {\n            const { rfqt: rfqtConfiguration, chainId } = chain;\n            if (!rfqtConfiguration) {\n                throw new Error(`RFQt Service for chain ${chainId} does not exist`);\n            }\n\n            const rfqMakerManager = new RfqMakerManager(configManager, rfqMakerDbUtils, chainId);\n            await rfqMakerManager.initializeAsync();\n            const quoteRequestor = new RefreshingQuoteRequestor(rfqMakerManager, proxiedAxiosInstance, altRfqOptions);\n            const quoteServerClient = new QuoteServerClient(proxiedAxiosInstance);\n            const contractAddresses = getContractAddressesForChainOrThrow(chainId);\n            const ethersProvider = new providers.JsonRpcProvider(chain.rpcUrl, chainId);\n            const provider: SupportedProvider = providerUtils.createWeb3Provider(chain.rpcUrl);\n\n            const balanceChecker = new BalanceChecker(provider);\n            const rfqBlockchainUtils = new RfqBlockchainUtils(\n                provider,\n                contractAddresses.exchangeProxy,\n                balanceChecker,\n                ethersProvider,\n            );\n            const tokenMetadataManager = new TokenMetadataManager(chainId, rfqBlockchainUtils);\n\n            const balanceCheckUtils = new RfqBalanceCheckUtils(balanceChecker, contractAddresses.exchangeProxy);\n            const cacheClient = new CacheClient(redis);\n            const rfqMakerBalanceCacheService = new RfqMakerBalanceCacheService(cacheClient, balanceCheckUtils);\n\n            const kafkaProducer = getKafkaProducer();\n\n            const feeTokenMetadata = getTokenMetadataIfExists(contractAddresses.etherToken, chainId);\n            if (feeTokenMetadata === undefined) {\n                throw new Error(`Fee token ${contractAddresses.etherToken} on chain ${chainId} could not be found!`);\n            }\n\n            const gasStationAttendant = getGasStationAttendant(chain, axiosInstance);\n            const tokenPriceOracle = new TokenPriceOracle(axiosInstance, DEFINED_FI_API_KEY, DEFINED_FI_ENDPOINT);\n            const zeroExApiClient = new ZeroExApiClient(Axios.create(), ZERO_EX_API_KEY, chain);\n            const feeService = new FeeService(\n                chainId,\n                feeTokenMetadata,\n                configManager,\n                gasStationAttendant,\n                tokenPriceOracle,\n                zeroExApiClient,\n                rfqtConfiguration.minExpiryDurationMs || DEFAULT_MIN_EXPIRY_DURATION_MS,\n            );\n\n            return new RfqtService(\n                chainId,\n                rfqMakerManager,\n                quoteRequestor,\n                quoteServerClient,\n                rfqtConfiguration.minExpiryDurationMs || DEFAULT_MIN_EXPIRY_DURATION_MS,\n                rfqBlockchainUtils,\n                tokenMetadataManager,\n                contractAddresses,\n                feeService,\n                rfqtConfiguration.feeModelVersion || 0,\n                rfqMakerBalanceCacheService,\n                cacheClient,\n                kafkaProducer,\n                rfqtConfiguration.feeEventTopic,\n            );\n        }),\n    );\n    return new Map(services.map((s, i) => [chainConfigurations[i].chainId, s]));\n}\n\n/**\n * Creates the default Axios Request Config\n */\nexport function getAxiosRequestConfig(timeout: number = DEFAULT_AXIOS_TIMEOUT): AxiosRequestConfig {\n    return {\n        httpAgent: new HttpAgent({ keepAlive: true, timeout: KEEP_ALIVE_TTL }),\n        httpsAgent: new HttpsAgent({ keepAlive: true, timeout: KEEP_ALIVE_TTL }),\n        timeout,\n    };\n}\n\n/**\n * Creates the Axios Request Config with egress proxy\n */\nexport function getAxiosRequestConfigWithProxy(): AxiosRequestConfig {\n    const axiosRequestConfig: AxiosRequestConfig = getAxiosRequestConfig();\n    if (RFQ_PROXY_ADDRESS !== undefined && RFQ_PROXY_PORT !== undefined) {\n        axiosRequestConfig.proxy = {\n            host: RFQ_PROXY_ADDRESS,\n            port: RFQ_PROXY_PORT,\n        };\n    }\n\n    return axiosRequestConfig;\n}\n\n/**\n * Initialize a kafka producer if KAFKA_BROKERS is set\n */\nfunction getKafkaProducer(): KafkaProducer | undefined {\n    let kafkaProducer: KafkaProducer | undefined;\n    if (KAFKA_BROKERS !== undefined) {\n        const kafka = new Kafka({\n            clientId: '0x-api',\n            brokers: KAFKA_BROKERS,\n        });\n\n        kafkaProducer = kafka.producer();\n        // tslint:disable-next-line: no-floating-promises\n        kafkaProducer.connect();\n    }\n    return kafkaProducer;\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/RefreshingQuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/RfqtService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/provider_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/MetricsProxyImpl.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/QuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/QuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmTypes.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/number_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/RfqtQuoteValidator.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType0.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType2.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantEthereum.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantPolygon.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/RefreshingQuoteRequestor.ts",{"fileContent":"import { Signature } from '@0x/protocol-utils';\nimport type { MarketOperation } from '@0x/types';\nimport { BigNumber } from '@0x/utils';\nimport { AxiosInstance } from 'axios';\n\nimport { ONE_SECOND_MS } from '../core/constants';\nimport type { SignedNativeOrder } from '../core/types';\nimport { RfqMakerManager } from '../utils/rfq_maker_manager';\n\nimport { METRICS_PROXY } from './MetricsProxyImpl';\nimport type { RfqRequestOpts } from './QuoteRequestor';\nimport { MetricsProxy, QuoteRequestor, V4RFQIndicativeQuoteMM } from './QuoteRequestor';\n\n// This number should not be greater than 90s. Otherwise, the RFQt quotes from Jump and WM are likely to be filtered out\n// tslint:disable-next-line: custom-no-magic-numbers\nconst DEFAULT_EXPIRY_BUFFER_MS = ONE_SECOND_MS * 80;\n\n/**\n * A wrapper of `QuoteRequestor` constructed with an instance of `RfqMakerManager`\n * instead of `rfqAssetOfferings`. This allows the underlying Quote Requestor\n * to be refreshed with the pairs of RfqMakerManager are refreshed.\n */\nexport class RefreshingQuoteRequestor {\n    private _quoteRequestor: QuoteRequestor;\n    private readonly _metrics: MetricsProxy;\n    constructor(\n        private readonly _rfqMakerManager: RfqMakerManager,\n        private readonly _quoteRequestorHttpClient: AxiosInstance,\n        private readonly _altRfqCreds?: { altRfqApiKey: string; altRfqProfile: string },\n        private readonly _expiryBufferMs: number = DEFAULT_EXPIRY_BUFFER_MS,\n    ) {\n        this._metrics = METRICS_PROXY;\n        this._quoteRequestor = this._createQuoteRequestor();\n        this._rfqMakerManager.on(\n            RfqMakerManager.REFRESHED_EVENT,\n            () => (this._quoteRequestor = this._createQuoteRequestor()),\n        );\n    }\n\n    /**\n     * Passthrough to the internal `QuoteRequestor`'s `requestRfqtIndicativeQuotesAsync`\n     * method.\n     */\n    public async requestRfqtIndicativeQuotesAsync(\n        makerToken: string,\n        takerToken: string,\n        assetFillAmount: BigNumber,\n        marketOperation: MarketOperation,\n        comparisonPrice: BigNumber | undefined,\n        options: RfqRequestOpts,\n    ): Promise<V4RFQIndicativeQuoteMM[]> {\n        return this._quoteRequestor.requestRfqtIndicativeQuotesAsync(\n            makerToken,\n            takerToken,\n            assetFillAmount,\n            marketOperation,\n            comparisonPrice,\n            options,\n        );\n    }\n\n    /**\n     * Passthrough to the internal `QuoteRequestor`'s `requestRfqtFirmQuotesAsync`\n     * method.\n     */\n    public async requestRfqtFirmQuotesAsync(\n        makerToken: string, // maker token\n        takerToken: string, // taker token\n        assetFillAmount: BigNumber,\n        marketOperation: MarketOperation,\n        comparisonPrice: BigNumber | undefined,\n        options: RfqRequestOpts,\n    ): Promise<SignedNativeOrder[]> {\n        return this._quoteRequestor.requestRfqtFirmQuotesAsync(\n            makerToken,\n            takerToken,\n            assetFillAmount,\n            marketOperation,\n            comparisonPrice,\n            options,\n        );\n    }\n\n    /**\n     * Passthrough to the internal `QuoteRequestor`'s `getMakerUriForSignature`\n     * method.\n     */\n    public getMakerUriForSignature(signature: Signature): string | undefined {\n        return this._quoteRequestor.getMakerUriForSignature(signature);\n    }\n\n    /**\n     * Handler for when the RFQ Maker Manager emits a pairs refreshed event.\n     * Creates a new `QuoteRequestor` instance with new pairs.\n     */\n    private _createQuoteRequestor(): QuoteRequestor {\n        const rfqAssetOfferings = this._rfqMakerManager.getRfqtV1MakerOfferings();\n        return new QuoteRequestor(\n            rfqAssetOfferings,\n            this._quoteRequestorHttpClient,\n            this._altRfqCreds,\n            this._expiryBufferMs,\n            this._metrics,\n        );\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/MetricsProxyImpl.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/QuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmImplementaionUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmTypes.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/rfqMakerBlacklist.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/MetricsProxyImpl.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { Counter, Histogram, Summary } from 'prom-client';\n\nimport { Integrator } from '../config';\n\nimport { MetricsProxy } from './QuoteRequestor';\n\nconst ORDER_EXPIRED_TOO_SOON = new Counter({\n    name: 'rfq_order_expired_too_soon',\n    help: 'RFQ Order expired too soon',\n    labelNames: ['maker', 'isLastLook'],\n});\n\nconst EXPIRATION_FOR_VALID_ORDER_SECONDS = new Histogram({\n    name: 'rfq_expiration_for_valid_order',\n    help: 'Order expiration in seconds for ',\n    labelNames: ['maker', 'isLastLook'],\n    // Buckets go from 30 seconds all the way to 5 minutes\n\n    // tslint:disable-next-line: custom-no-magic-numbers\n    buckets: [0, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 255, 270, 285, 300],\n});\n\nconst ORDER_FILL_RATIO_WARNING_RANGE = new Counter({\n    name: 'rfq_fill_ratio_warning',\n    help: 'Fill ratio is in warning range (99%) usually due to a bug',\n    labelNames: ['maker', 'isLastLook'],\n});\n\nconst RFQ_MAKER_NETWORK_INTERACTION_COUNTER = new Counter({\n    name: 'rfq_maker_network_interaction_counter',\n    help: 'Provides stats around market maker network interactions',\n    labelNames: ['isLastLook', 'integratorLabel', 'url', 'quoteType', 'included', 'statusCode', 'market'],\n});\n\nconst RFQ_MAKER_NETWORK_INTERACTION_SUMMARY = new Summary({\n    name: 'rfq_maker_network_interaction_summary',\n    help: 'Provides stats around market maker network interactions',\n    labelNames: ['isLastLook', 'integratorLabel', 'url', 'quoteType', 'included', 'statusCode', 'market'],\n});\n\n// NOTE: Do not use this map for anything sensitive. This is only used for\n// metrics/datavis purposes.\nconst KNOWN_TOKENS: { [key: string]: string } = {\n    '0x6b175474e89094c44da98b954eedeac495271d0f': 'DAI',\n    '0xdac17f958d2ee523a2206206994597c13d831ec7': 'USDT',\n    '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': 'USDC',\n    '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599': 'WBTC',\n    '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2': 'WETH',\n};\n\n/**\n * Returns a human-readible label for Prometheus counters. Only popular most relevant pairs\n * should be displayed in Prometheus (since it overload the service) and any other market that does\n * not contain popular pairs will simply return \"Other\".\n *\n * @param tokenSold the token being sold\n * @param tokenPurchased the token being purchased\n * @returns a market like \"WETH-DAI\", or \"Other\" is a pair is unknown\n */\nfunction getMarketLabel(tokenSold: string, tokenPurchased: string): string {\n    const items = [tokenSold.toLowerCase(), tokenPurchased.toLowerCase()];\n    items.sort();\n\n    const tokenA: string | undefined = KNOWN_TOKENS[items[0]];\n    const tokenB: string | undefined = KNOWN_TOKENS[items[1]];\n    if (!tokenA || !tokenB) {\n        return 'Other';\n    }\n    return `${tokenA}-${tokenB}`;\n}\n\nexport const METRICS_PROXY: MetricsProxy = {\n    incrementExpirationToSoonCounter: (isLastLook: boolean, maker: string) => {\n        ORDER_EXPIRED_TOO_SOON.labels(maker, isLastLook.toString()).inc();\n    },\n\n    measureExpirationForValidOrder: (isLastLook: boolean, maker: string, expirationTimeSeconds: BigNumber | number) => {\n        EXPIRATION_FOR_VALID_ORDER_SECONDS.labels(maker, isLastLook.toString()).observe(\n            new BigNumber(expirationTimeSeconds).toNumber(),\n        );\n    },\n\n    incrementFillRatioWarningCounter: (isLastLook: boolean, maker: string) => {\n        ORDER_FILL_RATIO_WARNING_RANGE.labels(maker, isLastLook.toString()).inc();\n    },\n\n    logRfqMakerNetworkInteraction: (interaction: {\n        isLastLook: boolean;\n        integrator: Integrator;\n        url: string;\n        quoteType: 'firm' | 'indicative';\n        statusCode: number | undefined;\n        latencyMs: number;\n        included: boolean;\n        sellTokenAddress: string;\n        buyTokenAddress: string;\n    }) => {\n        const {\n            isLastLook,\n            integrator,\n            url,\n            quoteType,\n            included: isIncluded,\n            statusCode,\n            sellTokenAddress,\n            buyTokenAddress,\n            latencyMs,\n        } = interaction;\n\n        const market = getMarketLabel(sellTokenAddress, buyTokenAddress);\n        const payload = [\n            isLastLook.toString(),\n            integrator.label,\n            url,\n            quoteType,\n            isIncluded.toString(),\n            `${statusCode || 'N/A'}`,\n            market,\n        ];\n        RFQ_MAKER_NETWORK_INTERACTION_COUNTER.labels(...payload).inc();\n        RFQ_MAKER_NETWORK_INTERACTION_SUMMARY.labels(...payload).observe(latencyMs);\n    },\n};\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/QuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmImplementaionUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/rfqMakerBlacklist.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/QuoteRequestor.ts",{"fileContent":"// tslint:disable: max-file-line-count\nimport { schemas, SchemaValidator } from '@0x/json-schemas';\nimport { FillQuoteTransformerOrderType, Signature } from '@0x/protocol-utils';\nimport { MarketOperation } from '@0x/types';\nimport { BigNumber, NULL_ADDRESS } from '@0x/utils';\nimport axios, { AxiosInstance } from 'axios';\n\nimport { Integrator, RFQ_PRICE_ENDPOINT_TIMEOUT_MS } from '../config';\nimport { ONE_SECOND_MS } from '../core/constants';\nimport { toPairString } from '../core/pair_utils';\nimport { Fee, SignedNativeOrder } from '../core/types';\nimport { logger } from '../logger';\nimport {\n    TakerRequestQueryParamsUnnested,\n    V4RFQFirmQuote,\n    V4SignedRfqOrder,\n    V4RFQIndicativeQuote,\n} from '../quote-server/types';\nimport { RfqMakerAssetOfferings } from '../utils/rfq_maker_manager';\n\nimport { returnQuoteFromAltMMAsync } from './altMmImplementaionUtils';\nimport { AltQuoteModel, AltRfqMakerAssetOfferings } from './altMmTypes';\nimport { RfqMakerBlacklist } from './rfqMakerBlacklist';\n\n// Matches value at\n// https://github.com/0xProject/protocol/blob/d3d4a08f917a084f72b649fc1b0b322c22f98129/packages/asset-swapper/src/constants.ts#L34\nconst EXPIRY_BUFFER_MS = 120000;\nconst MAKER_TIMEOUT_STREAK_LENGTH = 10;\nconst MAKER_TIMEOUT_BLACKLIST_DURATION_MINUTES = 10;\nconst FILL_RATIO_WARNING_LEVEL = 0.99;\nconst rfqMakerBlacklist = new RfqMakerBlacklist(MAKER_TIMEOUT_STREAK_LENGTH, MAKER_TIMEOUT_BLACKLIST_DURATION_MINUTES);\n\n// Stables\nconst USDC = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48';\nconst USDT = '0xdac17f958d2ee523a2206206994597c13d831ec7';\nconst DAI = '0x6b175474e89094c44da98b954eedeac495271d0f';\nconst BUSD = '0x4fabb145d64652a948d72533023f6e7a623c7c53';\nconst TUSD = '0x0000000000085d4780b73119b644ae5ecd22b376';\n\n// Other assets\nconst WETH = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2';\nconst WBTC = '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599';\nconst MATIC = '0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0';\nconst DISABLED_RFQT_V1_TOKENS = [USDC, USDT, DAI, BUSD, TUSD, WETH, WBTC, MATIC];\nconst DISABLED_RFQT_V1_PAIRS_SET = new Set(\n    DISABLED_RFQT_V1_TOKENS.flatMap((token) =>\n        DISABLED_RFQT_V1_TOKENS.filter((t) => t !== token).map((otherToken) => toPairString(token, otherToken)),\n    ),\n);\n\nenum RfqPairType {\n    Standard = 'standard',\n    Alt = 'alt',\n}\n\ninterface TypedMakerUrl {\n    url: string;\n    pairType: RfqPairType;\n}\n\nexport interface RfqRequestOpts {\n    takerAddress: string;\n    txOrigin: string;\n    integrator: Integrator;\n    intentOnFilling: boolean;\n    isIndicative?: boolean;\n    makerEndpointMaxResponseTimeMs?: number;\n    nativeExclusivelyRFQ?: boolean;\n    altRfqAssetOfferings?: AltRfqMakerAssetOfferings;\n    isLastLook?: boolean;\n    fee?: Fee;\n}\n\ninterface RfqQuote<T> {\n    response: T;\n    makerUri: string;\n}\n\nexport interface V4RFQIndicativeQuoteMM extends V4RFQIndicativeQuote {\n    makerUri: string;\n}\n\nexport type SignedNativeOrderMM = SignedNativeOrder & { makerUri?: string };\n\nexport interface MetricsProxy {\n    /**\n     * Increments a counter that is tracking valid Firm Quotes that are dropped due to low expiration.\n     * @param isLastLook mark if call is coming from RFQM\n     * @param maker the maker address\n     */\n    incrementExpirationToSoonCounter(isLastLook: boolean, maker: string): void;\n\n    /**\n     * Keeps track of summary statistics for expiration on Firm Quotes.\n     * @param isLastLook mark if call is coming from RFQM\n     * @param maker the maker address\n     * @param expirationTimeSeconds the expiration time in seconds\n     */\n    measureExpirationForValidOrder(isLastLook: boolean, maker: string, expirationTimeSeconds: BigNumber): void;\n\n    /**\n     * Increments a counter that tracks when an order is not fully fillable.\n     * @param isLastLook mark if call is coming from RFQM\n     * @param maker the maker address\n     * @param expirationTimeSeconds the expiration time in seconds\n     */\n    incrementFillRatioWarningCounter(isLastLook: boolean, maker: string): void;\n\n    /**\n     * Logs the outcome of a network (HTTP) interaction with a market maker.\n     *\n     * @param interaction.isLastLook true if the request is RFQM\n     * @param interaction.integrator the integrator that is requesting the RFQ quote\n     * @param interaction.url the URL of the market maker\n     * @param interaction.quoteType indicative or firm quote\n     * @param interaction.statusCode the statusCode returned by a market maker\n     * @param interaction.latencyMs the latency of the HTTP request (in ms)\n     * @param interaction.included if a firm quote that was returned got included in the next step of processing.\n     *                             NOTE: this does not mean that the request returned a valid fillable order. It just\n     *                             means that the network response was successful.\n     */\n    logRfqMakerNetworkInteraction(interaction: {\n        isLastLook: boolean;\n        integrator: Integrator;\n        url: string;\n        quoteType: 'firm' | 'indicative';\n        statusCode: number | undefined;\n        latencyMs: number;\n        included: boolean;\n        sellTokenAddress: string;\n        buyTokenAddress: string;\n    }): void;\n}\n\n/**\n * Request quotes from RFQ-T providers\n */\n\nfunction hasExpectedAddresses(comparisons: [string, string][]): boolean {\n    return comparisons.every((c) => c[0].toLowerCase() === c[1].toLowerCase());\n}\n\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction convertIfAxiosError(error: any): Error | object /* axios' .d.ts has AxiosError.toJSON() returning object */ {\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    // eslint-disable-next-line no-prototype-builtins\n    if (error.hasOwnProperty('isAxiosError') && error.isAxiosError) {\n        const { message, name, config } = error;\n        const { headers, timeout, httpsAgent } = config;\n        const { keepAlive, keepAliveMsecs, sockets } = httpsAgent;\n\n        const socketCounts: { [key: string]: number } = {};\n        for (const socket of Object.keys(sockets)) {\n            socketCounts[socket] = sockets[socket].length;\n        }\n\n        return {\n            message,\n            name,\n            config: {\n                headers,\n                timeout,\n                httpsAgent: {\n                    keepAlive,\n                    keepAliveMsecs,\n                    socketCounts,\n                },\n            },\n        };\n    } else {\n        return error;\n    }\n}\n\nfunction nativeDataToId(data: { signature: Signature }): string {\n    const { v, r, s } = data.signature;\n    return `${v}${r}${s}`;\n}\n\nexport class QuoteRequestor {\n    private readonly _schemaValidator: SchemaValidator = new SchemaValidator();\n    private readonly _orderSignatureToMakerUri: { [signature: string]: string } = {};\n\n    public static makeQueryParameters(\n        txOrigin: string,\n        takerAddress: string,\n        marketOperation: MarketOperation,\n        buyTokenAddress: string, // maker token\n        sellTokenAddress: string, // taker token\n        assetFillAmount: BigNumber,\n        comparisonPrice?: BigNumber,\n        isLastLook?: boolean | undefined,\n        fee?: Fee | undefined,\n    ): TakerRequestQueryParamsUnnested {\n        const { buyAmountBaseUnits, sellAmountBaseUnits } =\n            marketOperation === MarketOperation.Buy\n                ? {\n                      buyAmountBaseUnits: assetFillAmount,\n                      sellAmountBaseUnits: undefined,\n                  }\n                : {\n                      sellAmountBaseUnits: assetFillAmount,\n                      buyAmountBaseUnits: undefined,\n                  };\n\n        const requestParamsWithBigNumbers: Pick<\n            TakerRequestQueryParamsUnnested,\n            | 'txOrigin'\n            | 'takerAddress'\n            | 'buyTokenAddress'\n            | 'sellTokenAddress'\n            | 'comparisonPrice'\n            | 'isLastLook'\n            | 'protocolVersion'\n            | 'feeAmount'\n            | 'feeToken'\n            | 'feeType'\n        > = {\n            txOrigin,\n            takerAddress,\n            buyTokenAddress,\n            sellTokenAddress,\n            comparisonPrice: comparisonPrice === undefined ? undefined : comparisonPrice.toString(),\n            protocolVersion: '4',\n        };\n        if (isLastLook) {\n            if (fee === undefined) {\n                throw new Error(`isLastLook cannot be passed without a fee parameter`);\n            }\n            requestParamsWithBigNumbers.isLastLook = isLastLook.toString();\n            requestParamsWithBigNumbers.feeAmount = fee.amount.toString();\n            requestParamsWithBigNumbers.feeToken = fee.token;\n            requestParamsWithBigNumbers.feeType = fee.type;\n        }\n\n        // convert BigNumbers to strings\n        // so they are digestible by axios\n        if (sellAmountBaseUnits) {\n            return {\n                ...requestParamsWithBigNumbers,\n                sellAmountBaseUnits: sellAmountBaseUnits.toString(),\n            };\n        } else if (buyAmountBaseUnits) {\n            return {\n                ...requestParamsWithBigNumbers,\n                buyAmountBaseUnits: buyAmountBaseUnits.toString(),\n            };\n        } else {\n            throw new Error('Neither \"buyAmountBaseUnits\" or \"sellAmountBaseUnits\" were defined');\n        }\n    }\n\n    /**\n     * Gets both standard RFQ makers and \"alternative\" RFQ makers and combines them together\n     * in a single configuration map. If an integration key whitelist is present, it will be used\n     * to filter a specific makers.\n     *\n     * @param options the RfqmRequestOptions passed in\n     * @param assetOfferings the RFQM or RFQT maker offerings\n     * @returns a list of TypedMakerUrl instances\n     */\n    public static getTypedMakerUrlsAndWhitelist(\n        options: { integrator: Integrator; altRfqAssetOfferings?: AltRfqMakerAssetOfferings },\n        assetOfferings: RfqMakerAssetOfferings,\n    ): TypedMakerUrl[] {\n        const standardUrls = Object.keys(assetOfferings).map((mm: string): TypedMakerUrl => {\n            return { pairType: RfqPairType.Standard, url: mm };\n        });\n        const altUrls = options.altRfqAssetOfferings\n            ? Object.keys(options.altRfqAssetOfferings).map((mm: string): TypedMakerUrl => {\n                  return { pairType: RfqPairType.Alt, url: mm };\n              })\n            : [];\n\n        let typedMakerUrls = standardUrls.concat(altUrls);\n\n        // If there is a whitelist, only allow approved maker URLs\n        if (options.integrator.whitelistIntegratorUrls !== undefined) {\n            const whitelist = new Set(options.integrator.whitelistIntegratorUrls.map((key) => key.toLowerCase()));\n            typedMakerUrls = typedMakerUrls.filter((makerUrl) => whitelist.has(makerUrl.url.toLowerCase()));\n        }\n        return typedMakerUrls;\n    }\n\n    public static getDurationUntilExpirationMs(expirationTimeSeconds: BigNumber): BigNumber {\n        const expirationTimeMs = expirationTimeSeconds.times(ONE_SECOND_MS);\n        const currentTimeMs = new BigNumber(Date.now());\n        return BigNumber.max(expirationTimeMs.minus(currentTimeMs), 0);\n    }\n\n    private static _makerSupportsPair(\n        typedMakerUrl: TypedMakerUrl,\n        makerToken: string,\n        takerToken: string,\n        altMakerAssetOfferings: AltRfqMakerAssetOfferings | undefined,\n        assetOfferings: RfqMakerAssetOfferings | undefined,\n    ): boolean {\n        // Turn off RFQt v1 for these pairs\n        if (DISABLED_RFQT_V1_PAIRS_SET.has(toPairString(makerToken, takerToken))) {\n            return false;\n        }\n        if (typedMakerUrl.pairType === RfqPairType.Standard && assetOfferings) {\n            for (const assetPair of assetOfferings[typedMakerUrl.url]) {\n                if (\n                    (assetPair[0] === makerToken && assetPair[1] === takerToken) ||\n                    (assetPair[0] === takerToken && assetPair[1] === makerToken)\n                ) {\n                    return true;\n                }\n            }\n        } else if (typedMakerUrl.pairType === RfqPairType.Alt && altMakerAssetOfferings) {\n            for (const altAssetPair of altMakerAssetOfferings[typedMakerUrl.url]) {\n                if (\n                    (altAssetPair.baseAsset === makerToken && altAssetPair.quoteAsset === takerToken) ||\n                    (altAssetPair.baseAsset === takerToken && altAssetPair.quoteAsset === makerToken)\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    constructor(\n        private readonly _rfqtAssetOfferings: RfqMakerAssetOfferings,\n        private readonly _quoteRequestorHttpClient: AxiosInstance,\n        private readonly _altRfqCreds?: { altRfqApiKey: string; altRfqProfile: string },\n        private readonly _expiryBufferMs: number = EXPIRY_BUFFER_MS,\n        private readonly _metrics?: MetricsProxy,\n    ) {}\n\n    public async requestRfqtFirmQuotesAsync(\n        makerToken: string, // maker token\n        takerToken: string, // taker token\n        assetFillAmount: BigNumber,\n        marketOperation: MarketOperation,\n        comparisonPrice: BigNumber | undefined,\n        options: RfqRequestOpts,\n    ): Promise<SignedNativeOrder[]> {\n        const _opts: RfqRequestOpts = { makerEndpointMaxResponseTimeMs: RFQ_PRICE_ENDPOINT_TIMEOUT_MS, ...options };\n        if (!_opts.txOrigin || [undefined, '', '0x', NULL_ADDRESS].includes(_opts.txOrigin)) {\n            throw new Error('RFQ-T firm quotes require the presence of a tx origin');\n        }\n\n        return this._fetchAndValidateFirmQuotesAsync(\n            makerToken,\n            takerToken,\n            assetFillAmount,\n            marketOperation,\n            comparisonPrice,\n            _opts,\n            this._rfqtAssetOfferings,\n        );\n    }\n\n    public async requestRfqtIndicativeQuotesAsync(\n        makerToken: string,\n        takerToken: string,\n        assetFillAmount: BigNumber,\n        marketOperation: MarketOperation,\n        comparisonPrice: BigNumber | undefined,\n        options: RfqRequestOpts,\n    ): Promise<V4RFQIndicativeQuoteMM[]> {\n        const _opts: RfqRequestOpts = { makerEndpointMaxResponseTimeMs: RFQ_PRICE_ENDPOINT_TIMEOUT_MS, ...options };\n        // Originally a takerAddress was required for indicative quotes, but\n        // now we've eliminated that requirement.  @0x/quote-server, however,\n        // is still coded to expect a takerAddress.  So if the client didn't\n        // send one, just use the null address to satisfy the quote server's\n        // expectations.\n        if (!_opts.takerAddress) {\n            _opts.takerAddress = NULL_ADDRESS;\n        }\n        if (!_opts.txOrigin) {\n            _opts.txOrigin = NULL_ADDRESS;\n        }\n        return this._fetchAndValidateIndicativeQuotesAsync(\n            makerToken,\n            takerToken,\n            assetFillAmount,\n            marketOperation,\n            comparisonPrice,\n            _opts,\n            this._rfqtAssetOfferings,\n        );\n    }\n\n    /**\n     * Given an order signature, returns the makerUri that the order originated from\n     */\n    public getMakerUriForSignature(signature: Signature): string | undefined {\n        return this._orderSignatureToMakerUri[nativeDataToId({ signature })];\n    }\n\n    private _isValidRfqtIndicativeQuoteResponse(response: V4RFQIndicativeQuoteMM): boolean {\n        const requiredKeys: (keyof V4RFQIndicativeQuoteMM)[] = [\n            'makerAmount',\n            'takerAmount',\n            'makerToken',\n            'takerToken',\n            'expiry',\n        ];\n\n        for (const k of requiredKeys) {\n            if (response[k] === undefined) {\n                return false;\n            }\n        }\n        // TODO (jacob): I have a feeling checking 5 schemas is slower then checking one\n        const hasValidMakerAssetAmount = this._schemaValidator.isValid(response.makerAmount, schemas.wholeNumberSchema);\n        const hasValidTakerAssetAmount = this._schemaValidator.isValid(response.takerAmount, schemas.wholeNumberSchema);\n        const hasValidMakerToken = this._schemaValidator.isValid(response.makerToken, schemas.hexSchema);\n        const hasValidTakerToken = this._schemaValidator.isValid(response.takerToken, schemas.hexSchema);\n        const hasValidExpirationTimeSeconds = this._schemaValidator.isValid(response.expiry, schemas.wholeNumberSchema);\n        if (\n            !hasValidMakerAssetAmount ||\n            !hasValidTakerAssetAmount ||\n            !hasValidMakerToken ||\n            !hasValidTakerToken ||\n            !hasValidExpirationTimeSeconds\n        ) {\n            return false;\n        }\n        return true;\n    }\n\n    private async _getQuotesAsync<ResponseT>(\n        makerToken: string,\n        takerToken: string,\n        assetFillAmount: BigNumber,\n        marketOperation: MarketOperation,\n        comparisonPrice: BigNumber | undefined,\n        options: RfqRequestOpts,\n        quoteType: 'firm' | 'indicative',\n        assetOfferings: RfqMakerAssetOfferings,\n    ): Promise<RfqQuote<ResponseT>[]> {\n        const requestParams = QuoteRequestor.makeQueryParameters(\n            options.txOrigin,\n            options.takerAddress,\n            marketOperation,\n            makerToken,\n            takerToken,\n            assetFillAmount,\n            comparisonPrice,\n            options.isLastLook,\n            options.fee,\n        );\n\n        const quotePath = (() => {\n            switch (quoteType) {\n                case 'firm':\n                    return 'quote';\n                case 'indicative':\n                    return 'price';\n                default:\n                    throw new Error(`Unexpected quote type ${quoteType}`);\n            }\n        })();\n\n        const timeoutMs = options.makerEndpointMaxResponseTimeMs || RFQ_PRICE_ENDPOINT_TIMEOUT_MS;\n        const bufferMs = 20;\n\n        // Set Timeout on CancelToken\n        const cancelTokenSource = axios.CancelToken.source();\n        setTimeout(() => {\n            cancelTokenSource.cancel('timeout via cancel token');\n        }, timeoutMs + bufferMs);\n\n        const typedMakerUrls = QuoteRequestor.getTypedMakerUrlsAndWhitelist(options, assetOfferings);\n        const quotePromises = typedMakerUrls.map(async (typedMakerUrl) => {\n            // filter out requests to skip\n            const isBlacklisted = rfqMakerBlacklist.isMakerBlacklisted(typedMakerUrl.url);\n            const partialLogEntry = { url: typedMakerUrl.url, quoteType, requestParams, isBlacklisted };\n            const { isLastLook, integrator } = options;\n            const { sellTokenAddress, buyTokenAddress } = requestParams;\n            if (isBlacklisted) {\n                this._metrics?.logRfqMakerNetworkInteraction({\n                    isLastLook: false,\n                    url: typedMakerUrl.url,\n                    quoteType,\n                    statusCode: undefined,\n                    sellTokenAddress,\n                    buyTokenAddress,\n                    latencyMs: 0,\n                    included: false,\n                    integrator,\n                });\n                logger.info({ rfqtMakerInteraction: { ...partialLogEntry } });\n                return;\n            } else if (\n                !QuoteRequestor._makerSupportsPair(\n                    typedMakerUrl,\n                    makerToken,\n                    takerToken,\n                    options.altRfqAssetOfferings,\n                    assetOfferings,\n                )\n            ) {\n                return;\n            } else {\n                // make request to MM\n                const timeBeforeAwait = Date.now();\n                try {\n                    if (typedMakerUrl.pairType === RfqPairType.Standard) {\n                        const response = await this._quoteRequestorHttpClient.get(`${typedMakerUrl.url}/${quotePath}`, {\n                            headers: {\n                                '0x-api-key': options.integrator.integratorId,\n                                '0x-integrator-id': options.integrator.integratorId,\n                            },\n                            params: requestParams,\n                            timeout: timeoutMs,\n                            cancelToken: cancelTokenSource.token,\n                        });\n                        const latencyMs = Date.now() - timeBeforeAwait;\n                        this._metrics?.logRfqMakerNetworkInteraction({\n                            isLastLook: isLastLook || false,\n                            url: typedMakerUrl.url,\n                            quoteType,\n                            statusCode: response.status,\n                            sellTokenAddress,\n                            buyTokenAddress,\n                            latencyMs,\n                            included: true,\n                            integrator,\n                        });\n                        logger.info({\n                            rfqtMakerInteraction: {\n                                ...partialLogEntry,\n                                response: {\n                                    included: true,\n                                    apiKey: options.integrator.integratorId,\n                                    takerAddress: requestParams.takerAddress,\n                                    txOrigin: requestParams.txOrigin,\n                                    statusCode: response.status,\n                                    latencyMs,\n                                },\n                            },\n                        });\n                        rfqMakerBlacklist.logTimeoutOrLackThereof(typedMakerUrl.url, latencyMs >= timeoutMs);\n                        return {\n                            response: { ...response.data, makerUri: typedMakerUrl.url },\n                            makerUri: typedMakerUrl.url,\n                        };\n                    } else {\n                        if (this._altRfqCreds === undefined) {\n                            throw new Error(`don't have credentials for alt MM`);\n                        }\n                        const quote = await returnQuoteFromAltMMAsync<ResponseT>(\n                            typedMakerUrl.url,\n                            this._altRfqCreds.altRfqApiKey,\n                            this._altRfqCreds.altRfqProfile,\n                            options.integrator.integratorId,\n                            quoteType === 'firm' ? AltQuoteModel.Firm : AltQuoteModel.Indicative,\n                            makerToken,\n                            takerToken,\n                            timeoutMs,\n                            options.altRfqAssetOfferings || {},\n                            requestParams,\n                            this._quoteRequestorHttpClient,\n                            cancelTokenSource.token,\n                        );\n\n                        const latencyMs = Date.now() - timeBeforeAwait;\n                        this._metrics?.logRfqMakerNetworkInteraction({\n                            isLastLook: isLastLook || false,\n                            url: typedMakerUrl.url,\n                            quoteType,\n                            statusCode: quote.status,\n                            sellTokenAddress,\n                            buyTokenAddress,\n                            latencyMs,\n                            included: true,\n                            integrator,\n                        });\n                        logger.info({\n                            rfqtMakerInteraction: {\n                                ...partialLogEntry,\n                                response: {\n                                    included: true,\n                                    apiKey: options.integrator.integratorId,\n                                    takerAddress: requestParams.takerAddress,\n                                    txOrigin: requestParams.txOrigin,\n                                    statusCode: quote.status,\n                                    latencyMs,\n                                },\n                            },\n                        });\n                        rfqMakerBlacklist.logTimeoutOrLackThereof(typedMakerUrl.url, latencyMs >= timeoutMs);\n                        return { response: quote.data, makerUri: typedMakerUrl.url };\n                    }\n                } catch (err) {\n                    // log error if any\n                    const latencyMs = Date.now() - timeBeforeAwait;\n                    this._metrics?.logRfqMakerNetworkInteraction({\n                        isLastLook: isLastLook || false,\n                        url: typedMakerUrl.url,\n                        quoteType,\n                        statusCode: err.response?.status,\n                        sellTokenAddress,\n                        buyTokenAddress,\n                        latencyMs,\n                        included: false,\n                        integrator,\n                    });\n                    logger.info({\n                        rfqtMakerInteraction: {\n                            ...partialLogEntry,\n                            response: {\n                                included: false,\n                                apiKey: options.integrator.integratorId,\n                                takerAddress: requestParams.takerAddress,\n                                txOrigin: requestParams.txOrigin,\n                                statusCode: err.response ? err.response.status : undefined,\n                                latencyMs,\n                            },\n                        },\n                    });\n                    rfqMakerBlacklist.logTimeoutOrLackThereof(typedMakerUrl.url, latencyMs >= timeoutMs);\n                    logger.warn(\n                        convertIfAxiosError(err),\n                        `Failed to get RFQ-T ${quoteType} quote from market maker endpoint ${typedMakerUrl.url} for integrator ${options.integrator.integratorId} (${options.integrator.label}) for taker address ${options.takerAddress} and tx origin ${options.txOrigin}`,\n                    );\n                    return;\n                }\n            }\n        });\n\n        const results = (await Promise.all(quotePromises)).filter((x) => x !== undefined);\n        return results as RfqQuote<ResponseT>[];\n    }\n    private async _fetchAndValidateFirmQuotesAsync(\n        makerToken: string,\n        takerToken: string,\n        assetFillAmount: BigNumber,\n        marketOperation: MarketOperation,\n        comparisonPrice: BigNumber | undefined,\n        options: RfqRequestOpts,\n        assetOfferings: RfqMakerAssetOfferings,\n    ): Promise<SignedNativeOrder[]> {\n        const quotesRaw = await this._getQuotesAsync<V4RFQFirmQuote>(\n            makerToken,\n            takerToken,\n            assetFillAmount,\n            marketOperation,\n            comparisonPrice,\n            options,\n            'firm',\n            assetOfferings,\n        );\n        const quotes = quotesRaw.map((result) => ({ ...result, response: result.response.signedOrder }));\n\n        // validate\n        const validationFunction = (o: V4SignedRfqOrder) => {\n            try {\n                // Handle the validate throwing, i.e if it isn't an object or json response\n                return this._schemaValidator.isValid(o, schemas.v4RfqSignedOrderSchema);\n            } catch (e) {\n                return false;\n            }\n        };\n        const validQuotes = quotes.filter((result) => {\n            const order = result.response;\n            if (!validationFunction(order)) {\n                logger.warn(result, 'Invalid RFQ-T firm quote received, filtering out');\n                return false;\n            }\n            if (\n                !hasExpectedAddresses([\n                    [makerToken, order.makerToken],\n                    [takerToken, order.takerToken],\n                    [options.takerAddress, order.taker],\n                    [options.txOrigin, order.txOrigin],\n                ])\n            ) {\n                logger.warn(order, 'Unexpected token, tx origin or taker address in RFQ-T order, filtering out');\n                return false;\n            }\n            const isLastLook = Boolean(options.isLastLook);\n            const msRemainingUntilExpiration = QuoteRequestor.getDurationUntilExpirationMs(new BigNumber(order.expiry));\n            const isExpirationTooSoon = msRemainingUntilExpiration.lt(this._expiryBufferMs);\n            if (isExpirationTooSoon) {\n                logger.warn(order, 'Expiry too soon in RFQ-T firm quote, filtering out');\n                this._metrics?.incrementExpirationToSoonCounter(isLastLook, order.maker);\n                return false;\n            } else {\n                const secondsRemaining = msRemainingUntilExpiration.div(ONE_SECOND_MS);\n                this._metrics?.measureExpirationForValidOrder(isLastLook, order.maker, secondsRemaining);\n                const takerAmount = new BigNumber(order.takerAmount);\n                const fillRatio = takerAmount.div(assetFillAmount);\n                if (fillRatio.lt(1) && fillRatio.gte(FILL_RATIO_WARNING_LEVEL)) {\n                    logger.warn(\n                        {\n                            makerUri: result.makerUri,\n                            fillRatio,\n                            assetFillAmount,\n                            takerToken,\n                            makerToken,\n                            takerAmount: order.takerAmount,\n                            makerAmount: order.makerAmount,\n                        },\n                        'Fill ratio in warning range',\n                    );\n                    this._metrics?.incrementFillRatioWarningCounter(isLastLook, order.maker);\n                }\n                return true;\n            }\n        });\n\n        // Save the maker URI for later and return just the order\n        const rfqQuotes = validQuotes.map((result) => {\n            const { signature, ...rest } = result.response;\n            const order: SignedNativeOrder = {\n                order: {\n                    ...rest,\n                    makerAmount: new BigNumber(result.response.makerAmount),\n                    takerAmount: new BigNumber(result.response.takerAmount),\n                    expiry: new BigNumber(result.response.expiry),\n                    salt: new BigNumber(result.response.salt),\n                },\n                type: FillQuoteTransformerOrderType.Rfq,\n                signature,\n            };\n            this._orderSignatureToMakerUri[nativeDataToId(result.response)] = result.makerUri;\n            return order;\n        });\n        return rfqQuotes;\n    }\n\n    private async _fetchAndValidateIndicativeQuotesAsync(\n        makerToken: string,\n        takerToken: string,\n        assetFillAmount: BigNumber,\n        marketOperation: MarketOperation,\n        comparisonPrice: BigNumber | undefined,\n        options: RfqRequestOpts,\n        assetOfferings: RfqMakerAssetOfferings,\n    ): Promise<V4RFQIndicativeQuoteMM[]> {\n        // fetch quotes\n        const rawQuotes = await this._getQuotesAsync<V4RFQIndicativeQuoteMM>(\n            makerToken,\n            takerToken,\n            assetFillAmount,\n            marketOperation,\n            comparisonPrice,\n            options,\n            'indicative',\n            assetOfferings,\n        );\n\n        // validate\n        const validationFunction = (o: V4RFQIndicativeQuoteMM) => this._isValidRfqtIndicativeQuoteResponse(o);\n        const validQuotes = rawQuotes.filter((result) => {\n            const order = result.response;\n            if (!validationFunction(order)) {\n                logger.warn(result, 'Invalid RFQ indicative quote received, filtering out');\n                return false;\n            }\n            if (\n                !hasExpectedAddresses([\n                    [makerToken, order.makerToken],\n                    [takerToken, order.takerToken],\n                ])\n            ) {\n                logger.warn(order, 'Unexpected token or taker address in RFQ order, filtering out');\n                return false;\n            }\n            const msRemainingUntilExpiration = QuoteRequestor.getDurationUntilExpirationMs(new BigNumber(order.expiry));\n            const isExpirationTooSoon = msRemainingUntilExpiration.lt(this._expiryBufferMs);\n            if (isExpirationTooSoon) {\n                logger.warn(order, 'Expiry too soon in RFQ indicative quote, filtering out');\n                return false;\n            } else {\n                return true;\n            }\n        });\n        const quotes = validQuotes.map((r) => r.response);\n        quotes.forEach((q) => {\n            q.makerAmount = new BigNumber(q.makerAmount);\n            q.takerAmount = new BigNumber(q.takerAmount);\n            q.expiry = new BigNumber(q.expiry);\n        });\n        return quotes;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmImplementaionUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmTypes.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/rfqMakerBlacklist.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmImplementaionUtils.ts",{"fileContent":"import { Web3Wrapper } from '@0x/dev-utils';\nimport { BigNumber } from '@0x/utils';\nimport { AxiosInstance, CancelToken } from 'axios';\n\nimport { logger } from '../logger';\nimport { TakerRequestQueryParamsUnnested, V4RFQFirmQuote, V4RFQIndicativeQuote } from '../quote-server/types';\nimport {\n    AltFirmQuoteResponse,\n    AltIndicativeQuoteResponse,\n    AltOffering,\n    AltQuoteModel,\n    AltQuoteRequestData,\n    AltQuoteSide,\n    AltRfqMakerAssetOfferings,\n} from './altMmTypes';\n\nconst SUCCESS_CODE = 201;\n\n// https://github.com/0xProject/protocol/blob/fe935f787cbe8c9116ff702195f3161e86c1aea4/packages/asset-swapper/src/constants.ts#L31\nconst ALT_MM_IMPUTED_INDICATIVE_EXPIRY_SECONDS = 180;\n\nfunction getAltMarketInfo(\n    offerings: AltOffering[],\n    buyTokenAddress: string,\n    sellTokenAddress: string,\n): AltOffering | undefined {\n    for (const offering of offerings) {\n        if (\n            (buyTokenAddress.toLowerCase() === offering.baseAsset.toLowerCase() &&\n                sellTokenAddress.toLowerCase() === offering.quoteAsset.toLowerCase()) ||\n            (sellTokenAddress.toLowerCase() === offering.baseAsset.toLowerCase() &&\n                buyTokenAddress.toLowerCase() === offering.quoteAsset.toLowerCase())\n        ) {\n            return offering;\n        }\n    }\n    return undefined;\n}\n\nfunction parseFirmQuoteResponseFromAltMM(altFirmQuoteReponse: AltFirmQuoteResponse): V4RFQFirmQuote {\n    return {\n        signedOrder: altFirmQuoteReponse.data['0xv4order'],\n    };\n}\n\nfunction parseIndicativeQuoteResponseFromAltMM(\n    altIndicativeQuoteResponse: AltIndicativeQuoteResponse,\n    altPair: AltOffering,\n    makerToken: string,\n    takerToken: string,\n): V4RFQIndicativeQuote {\n    let makerAmount: BigNumber;\n    let takerAmount: BigNumber;\n    let quoteAmount: BigNumber;\n    let baseAmount: BigNumber;\n\n    if (!altIndicativeQuoteResponse.price) {\n        throw new Error('Price not returned by alt MM');\n    }\n    if (altIndicativeQuoteResponse.amount) {\n        // if amount is specified, amount is the base token amount\n        baseAmount = Web3Wrapper.toBaseUnitAmount(\n            new BigNumber(altIndicativeQuoteResponse.amount),\n            altPair.baseAssetDecimals,\n        );\n        // if amount is specified, use the price (quote/base) to get the quote amount\n        quoteAmount = Web3Wrapper.toBaseUnitAmount(\n            new BigNumber(altIndicativeQuoteResponse.amount)\n                .times(new BigNumber(altIndicativeQuoteResponse.price))\n                .decimalPlaces(altPair.quoteAssetDecimals, BigNumber.ROUND_DOWN),\n            altPair.quoteAssetDecimals,\n        );\n    } else if (altIndicativeQuoteResponse.value) {\n        // if value is specified, value is the quote token amount\n        quoteAmount = Web3Wrapper.toBaseUnitAmount(\n            new BigNumber(altIndicativeQuoteResponse.value),\n            altPair.quoteAssetDecimals,\n        );\n        // if value is specified, use the price (quote/base) to get the base amount\n        baseAmount = Web3Wrapper.toBaseUnitAmount(\n            new BigNumber(altIndicativeQuoteResponse.value)\n                .dividedBy(new BigNumber(altIndicativeQuoteResponse.price))\n                .decimalPlaces(altPair.baseAssetDecimals, BigNumber.ROUND_DOWN),\n            altPair.baseAssetDecimals,\n        );\n    } else {\n        throw new Error('neither amount or value were specified');\n    }\n    if (makerToken.toLowerCase() === altPair.baseAsset.toLowerCase()) {\n        makerAmount = baseAmount;\n        takerAmount = quoteAmount;\n    } else if (makerToken.toLowerCase() === altPair.quoteAsset.toLowerCase()) {\n        makerAmount = quoteAmount;\n        takerAmount = baseAmount;\n    } else {\n        throw new Error(`Base, quote tokens don't align with maker, taker tokens`);\n    }\n\n    return {\n        makerToken,\n        makerAmount,\n        takerToken,\n        takerAmount,\n        // HACK: alt implementation does not return an expiration with indicative quotes\n        // return now + { IMPUTED EXPIRY SECONDS } to have it included after order checks\n        expiry:\n            // tslint:disable-next-line:custom-no-magic-numbers\n            new BigNumber(Date.now() / 1000)\n                .integerValue(BigNumber.ROUND_DOWN)\n                .plus(ALT_MM_IMPUTED_INDICATIVE_EXPIRY_SECONDS),\n    };\n}\n\n/**\n * Turn a standard quote request into an alt quote request\n * and return the appropriate standard quote response\n */\nexport async function returnQuoteFromAltMMAsync<ResponseT>(\n    url: string,\n    apiKey: string,\n    profile: string,\n    integratorKey: string,\n    quoteModel: AltQuoteModel,\n    makerToken: string,\n    takerToken: string,\n    maxResponseTimeMs: number,\n    altRfqAssetOfferings: AltRfqMakerAssetOfferings,\n    takerRequestQueryParams: TakerRequestQueryParamsUnnested,\n    axiosInstance: AxiosInstance,\n    cancelToken: CancelToken,\n): Promise<{ data: ResponseT; status: number }> {\n    const altPair = getAltMarketInfo(\n        altRfqAssetOfferings[url],\n        takerRequestQueryParams.buyTokenAddress,\n        takerRequestQueryParams.sellTokenAddress,\n    );\n\n    if (!altPair) {\n        throw new Error(`Alt pair not found`);\n    }\n    const side = altPair.baseAsset === takerRequestQueryParams.buyTokenAddress ? AltQuoteSide.Sell : AltQuoteSide.Buy;\n\n    // comparison price needs to be quote/base\n    // in the standard implementation, it's maker/taker\n    let altComparisonPrice: string | undefined;\n    if (altPair.quoteAsset === makerToken) {\n        altComparisonPrice = takerRequestQueryParams.comparisonPrice\n            ? takerRequestQueryParams.comparisonPrice\n            : undefined;\n    } else {\n        altComparisonPrice = takerRequestQueryParams.comparisonPrice\n            ? new BigNumber(takerRequestQueryParams.comparisonPrice).pow(-1).toString()\n            : undefined;\n    }\n\n    let data: AltQuoteRequestData;\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    // eslint-disable-next-line prefer-const\n    data = {\n        market: `${altPair.id}`,\n        model: quoteModel,\n        profile,\n        side,\n        meta: {\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            txOrigin: takerRequestQueryParams.txOrigin!,\n            taker: takerRequestQueryParams.takerAddress,\n            client: integratorKey,\n        },\n    };\n\n    // specify a comparison price if it exists\n    if (altComparisonPrice) {\n        data.meta.existingOrder = {\n            price: altComparisonPrice,\n        };\n    }\n\n    // need to specify amount or value\n    // amount is units of the base asset\n    // value is units of the quote asset\n    let requestSize: string;\n    if (takerRequestQueryParams.buyAmountBaseUnits) {\n        requestSize = Web3Wrapper.toUnitAmount(\n            new BigNumber(takerRequestQueryParams.buyAmountBaseUnits),\n            takerRequestQueryParams.buyTokenAddress === altPair.baseAsset\n                ? altPair.baseAssetDecimals\n                : altPair.quoteAssetDecimals,\n        ).toString();\n        if (takerRequestQueryParams.buyTokenAddress === altPair.baseAsset) {\n            data.amount = requestSize;\n            // add to 'existing order' if there is a comparison price\n            if (data.meta.existingOrder) {\n                data.meta.existingOrder.amount = requestSize;\n            }\n        } else {\n            data.value = requestSize;\n            // add to 'existing order' if there is a comparison price\n            if (data.meta.existingOrder) {\n                data.meta.existingOrder.value = requestSize;\n            }\n        }\n    } else if (takerRequestQueryParams.sellAmountBaseUnits) {\n        requestSize = Web3Wrapper.toUnitAmount(\n            new BigNumber(takerRequestQueryParams.sellAmountBaseUnits),\n            takerRequestQueryParams.sellTokenAddress === altPair.baseAsset\n                ? altPair.baseAssetDecimals\n                : altPair.quoteAssetDecimals,\n        ).toString();\n        if (takerRequestQueryParams.sellTokenAddress === altPair.baseAsset) {\n            data.amount = requestSize;\n            if (data.meta.existingOrder) {\n                data.meta.existingOrder.amount = requestSize;\n            }\n        } else {\n            data.value = requestSize;\n            if (data.meta.existingOrder) {\n                data.meta.existingOrder.value = requestSize;\n            }\n        }\n    }\n\n    const response = await axiosInstance\n        .post(`${url}/quotes`, data, {\n            headers: { Authorization: `Bearer ${apiKey}` },\n            timeout: maxResponseTimeMs,\n            cancelToken,\n        })\n        .catch((err) => {\n            if (err.response) {\n                // request was made and market maker responded\n                logger.warn(\n                    { data: err.response.data, status: err.response.status, headers: err.response.headers },\n                    `Alt RFQ MM request failed`,\n                );\n            } else if (err.request) {\n                logger.warn({}, 'Alt RFQ MM no response received');\n            } else {\n                logger.warn({ err: err.message }, 'Failed to construct Alt RFQ MM request');\n            }\n            throw new Error(`Alt RFQ MM request failed`);\n        });\n\n    // empty response will get filtered out in validation\n    const emptyResponse = {};\n\n    // tslint:disable-next-line:custom-no-magic-numbers\n    if (response.status !== SUCCESS_CODE) {\n        const rejectedRequestInfo = {\n            status: response.status,\n            message: response.data,\n        };\n        logger.warn(rejectedRequestInfo, `Alt RFQ MM did not return a status of ${SUCCESS_CODE}`);\n        return {\n            data: emptyResponse as unknown as ResponseT,\n            status: response.status,\n        };\n    }\n    // successful handling but no quote is indicated by status = 'rejected'\n    if (response.data.status === 'rejected') {\n        logger.warn(\n            response.data.id,\n            `Alt RFQ MM handled the request successfully but did not return a quote (status = 'rejected')`,\n        );\n        return {\n            data: emptyResponse as unknown as ResponseT,\n            // hack: set the http status to 204 no content so we can more\n            // easily track when no quote is returned\n            status: 204,\n        };\n    }\n\n    const parsedResponse =\n        quoteModel === 'firm'\n            ? parseFirmQuoteResponseFromAltMM(response.data)\n            : parseIndicativeQuoteResponseFromAltMM(response.data, altPair, makerToken, takerToken);\n\n    return {\n        // hack to appease type checking\n        data: parsedResponse as unknown as ResponseT,\n        status: response.status,\n    };\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmTypes.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/rfqMakerBlacklist.ts",{"fileContent":"/**\n * Tracks a maker's history of timely responses, and manages whether a given\n * maker should be avoided for being too latent.\n */\n\nimport { ONE_MINUTE_MS } from '../core/constants';\nimport { logger } from '../logger';\n\nexport class RfqMakerBlacklist {\n    private readonly _makerTimeoutStreakLength: { [makerUrl: string]: number } = {};\n    private readonly _makerBlacklistedUntilDate: { [makerUrl: string]: number } = {};\n    constructor(\n        private readonly _blacklistDurationMinutes: number,\n        private readonly _timeoutStreakThreshold: number, //  public infoLogger: LogFunction = constants.DEFAULT_INFO_LOGGER,\n    ) {}\n    public logTimeoutOrLackThereof(makerUrl: string, didTimeout: boolean): void {\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line no-prototype-builtins\n        if (!this._makerTimeoutStreakLength.hasOwnProperty(makerUrl)) {\n            this._makerTimeoutStreakLength[makerUrl] = 0;\n        }\n        if (didTimeout) {\n            this._makerTimeoutStreakLength[makerUrl] += 1;\n            if (this._makerTimeoutStreakLength[makerUrl] === this._timeoutStreakThreshold) {\n                const blacklistEnd = Date.now() + this._blacklistDurationMinutes * ONE_MINUTE_MS;\n                this._makerBlacklistedUntilDate[makerUrl] = blacklistEnd;\n                logger.info({ makerUrl, blacklistedUntil: new Date(blacklistEnd).toISOString() }, 'maker blacklisted');\n            }\n        } else {\n            this._makerTimeoutStreakLength[makerUrl] = 0;\n        }\n    }\n    public isMakerBlacklisted(makerUrl: string): boolean {\n        const now = Date.now();\n        if (now > this._makerBlacklistedUntilDate[makerUrl]) {\n            delete this._makerBlacklistedUntilDate[makerUrl];\n            logger.info({ makerUrl }, 'maker unblacklisted');\n        }\n        return this._makerBlacklistedUntilDate[makerUrl] > now;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/services/RfqtService.ts",{"fileContent":"import { AssetSwapperContractAddresses } from '@0x/asset-swapper/lib/src/types';\nimport { OtcOrder } from '@0x/protocol-utils/lib/src/orders';\nimport { Signature } from '@0x/protocol-utils/lib/src/signature_utils';\nimport {\n    getTokenMetadataIfExists,\n    nativeTokenSymbol,\n    nativeWrappedTokenSymbol,\n    TokenMetadata,\n} from '@0x/token-metadata';\nimport { MarketOperation } from '@0x/types';\nimport { BigNumber } from '@0x/utils';\nimport { Producer as KafkaProducer } from 'kafkajs';\n\nimport { Integrator } from '../config';\nimport { GASLESS_OTC_ORDER_NUM_BUCKETS, NULL_ADDRESS, ONE_SECOND_MS } from '../core/constants';\nimport { feeToStoredFee } from '../core/fee_utils';\nimport {\n    Fee,\n    FeeModelVersion,\n    QuoteServerPriceParams,\n    RequireOnlyOne,\n    RfqtV2Price,\n    RfqtV2Quote,\n    StoredFee,\n} from '../core/types';\nimport { logger } from '../logger';\nimport { AltRfqMakerAssetOfferings } from '../quoteRequestor/altMmTypes';\nimport { QuoteRequestor, SignedNativeOrderMM, V4RFQIndicativeQuoteMM } from '../quoteRequestor/QuoteRequestor';\nimport { CacheClient } from '../utils/cache_client';\nimport { modulo } from '../utils/number_utils';\nimport { quoteReportUtils } from '../utils/quote_report_utils';\nimport { QuoteServerClient } from '../utils/quote_server_client';\nimport { getRfqtV2FillableAmounts, validateV2Prices } from '../utils/RfqtQuoteValidator';\nimport { RfqBlockchainUtils } from '../utils/rfq_blockchain_utils';\nimport { RfqMakerManager } from '../utils/rfq_maker_manager';\nimport { getSignerFromHash, padSignature } from '../utils/signature_utils';\nimport { TokenMetadataManager } from '../utils/TokenMetadataManager';\n\nimport { FeeService } from './fee_service';\nimport { RfqMakerBalanceCacheService } from './rfq_maker_balance_cache_service';\nimport { FirmQuoteContext, QuoteContext } from './types';\n\nconst getTokenAddressFromSymbol = (symbol: string, chainId: number): string => {\n    return (getTokenMetadataIfExists(symbol, chainId) as TokenMetadata).tokenAddress;\n};\n\n/**\n * Converts the parameters of an RFQt v2 prices request from 0x API\n * into the format needed for `QuoteServerClient` to call the market makers\n */\nfunction transformRfqtV2PricesParameters(p: QuoteContext, fee: Fee, chainId: number): QuoteServerPriceParams {\n    const buyTokenAddress = p.makerToken;\n    const sellTokenAddress = p.takerToken;\n    // Typescript gymnastics with `baseUnits` to caputure the \"oneof\" nature--\n    // By packaging them in their own little object, the type becomes:\n    //\n    // { buyAmountBaseUnits: BigNumber, sellAmountBaseUnits: undefined } |\n    // { buyAmountBaseUnits: undefined, sellAmountBaseUnits: BigNumber }\n    //\n    // This is different from not packaging them together, where the types would be:\n    //\n    // buyAmountBaseUnits: BigNumber | undefined\n    // sellAmountBaseUnits: BigNumber | undefined\n    const baseUnits =\n        p.isSelling === false\n            ? {\n                  buyAmountBaseUnits: p.assetFillAmount,\n                  sellAmountBaseUnits: undefined,\n              }\n            : {\n                  // This is a SELL\n                  buyAmountBaseUnits: undefined,\n                  sellAmountBaseUnits: p.assetFillAmount,\n              };\n\n    const mmRequestParameters = {\n        ...baseUnits,\n        buyTokenAddress,\n        sellTokenAddress,\n        chainId,\n        feeAmount: fee.amount,\n        feeToken: fee.token,\n        integratorId: p.integrator.integratorId,\n        takerAddress: p.takerAddress,\n        txOrigin: p.txOrigin,\n        // trader: p.trader,\n        // workflow: p.workflow,\n        protocolVersion: '4', //hardcode - will break some MMs if missing!\n    };\n\n    // Convert mmRequestParameters values to strings\n    const stringParameters = ((\n        o: typeof mmRequestParameters,\n    ): RequireOnlyOne<\n        Record<keyof typeof mmRequestParameters, string>,\n        'buyAmountBaseUnits' | 'sellAmountBaseUnits'\n    > => {\n        return Object.keys(o).reduce((result, key) => {\n            const value: { toString: () => string } | undefined = o[key as keyof typeof mmRequestParameters];\n            if (value !== undefined && value.toString) {\n                const stringValue = value.toString();\n                result[key] = stringValue;\n            }\n            return result;\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }, {} as any);\n    })(mmRequestParameters);\n\n    return stringParameters;\n}\n\n/**\n * Contains the logic to handle RFQT Trades.\n *\n * `\"v1\"` functions support `MetaTransaction` trades while\n * `\"v2\"` functions (will) support `OtcOrder` trades.\n *\n * `v1` relies heavily on `QuoteRequestor` which has been copied over\n * from `0x/asset-swapper`.\n */\nexport class RfqtService {\n    private readonly _nativeTokenSymbol: string;\n    private readonly _nativeTokenAddress: string;\n    private readonly _nativeWrappedTokenSymbol: string;\n    private readonly _nativeWrappedTokenAddress: string;\n    constructor(\n        private readonly _chainId: number,\n        private readonly _rfqMakerManager: RfqMakerManager,\n        // Used for RFQt v1 requests\n        private readonly _quoteRequestor: Pick<\n            QuoteRequestor,\n            'requestRfqtIndicativeQuotesAsync' | 'requestRfqtFirmQuotesAsync' | 'getMakerUriForSignature'\n        >,\n        // Used for RFQt v2 requests\n        private readonly _quoteServerClient: QuoteServerClient,\n        private readonly _minExpiryDurationMs: number,\n        private readonly _blockchainUtils: RfqBlockchainUtils,\n        private readonly _tokenMetadataManager: TokenMetadataManager,\n        private readonly _contractAddresses: AssetSwapperContractAddresses,\n        private readonly _feeService: FeeService,\n        private readonly _feeModelVersion: FeeModelVersion,\n        private readonly _rfqMakerBalanceCacheService: RfqMakerBalanceCacheService,\n        private readonly _cacheClient: CacheClient,\n        private readonly _kafkaProducer?: KafkaProducer,\n        private readonly _feeEventTopic?: string,\n    ) {\n        this._nativeTokenSymbol = nativeTokenSymbol(this._chainId);\n        this._nativeTokenAddress = getTokenAddressFromSymbol(this._nativeTokenSymbol, this._chainId);\n        this._nativeWrappedTokenSymbol = nativeWrappedTokenSymbol(this._chainId);\n        this._nativeWrappedTokenAddress = getTokenAddressFromSymbol(this._nativeWrappedTokenSymbol, this._chainId);\n    }\n\n    /**\n     * Pass through to `QuoteRequestor::requestRfqtIndicativeQuotesAsync` to fetch\n     * indicative quotes from market makers.\n     *\n     * Note that by this point, 0x API should be sending the null address\n     * as the `takerAddress` and the taker's address as the `txOrigin`.\n     */\n    public async getV1PricesAsync(parameters: {\n        altRfqAssetOfferings: AltRfqMakerAssetOfferings;\n        assetFillAmount: BigNumber;\n        comparisonPrice: BigNumber | undefined;\n        makerToken: string;\n        marketOperation: MarketOperation;\n        takerToken: string; // expect this to be NULL_ADDRESS\n        takerAddress: string;\n        txOrigin?: string; // expect this to be the taker address\n        intentOnFilling: boolean;\n        integrator: Integrator;\n    }): Promise<V4RFQIndicativeQuoteMM[]> {\n        const {\n            altRfqAssetOfferings,\n            assetFillAmount,\n            comparisonPrice,\n            integrator,\n            intentOnFilling, // tslint:disable-line boolean-naming\n            makerToken,\n            marketOperation,\n            takerAddress,\n            takerToken,\n            txOrigin,\n        } = parameters;\n\n        return this._quoteRequestor.requestRfqtIndicativeQuotesAsync(\n            makerToken,\n            takerToken,\n            assetFillAmount,\n            marketOperation,\n            comparisonPrice,\n            {\n                altRfqAssetOfferings,\n                integrator,\n                intentOnFilling,\n                isIndicative: true,\n                isLastLook: false,\n                makerEndpointMaxResponseTimeMs: 600,\n                takerAddress,\n                txOrigin: txOrigin || NULL_ADDRESS,\n            },\n        );\n    }\n\n    /**\n     * Pass through to `QuoteRequestor::requestRfqtFirmQuotesAsync` to fetch\n     * firm quotes from market makers.\n     *\n     * Note that by this point, 0x API should be sending the null address\n     * as the `takerAddress` and the taker's address as the `txOrigin`.\n     */\n    public async getV1QuotesAsync(parameters: {\n        altRfqAssetOfferings: AltRfqMakerAssetOfferings;\n        assetFillAmount: BigNumber;\n        comparisonPrice: BigNumber | undefined;\n        integrator: Integrator;\n        intentOnFilling: boolean;\n        makerToken: string;\n        marketOperation: MarketOperation;\n        takerAddress: string; // expect this to be the taker address\n        takerToken: string;\n        txOrigin: string;\n    }): Promise<SignedNativeOrderMM[]> {\n        const {\n            altRfqAssetOfferings,\n            assetFillAmount,\n            comparisonPrice,\n            integrator,\n            intentOnFilling, // tslint:disable-line boolean-naming\n            makerToken,\n            marketOperation,\n            takerAddress,\n            takerToken,\n            txOrigin,\n        } = parameters;\n\n        const quotes = await this._quoteRequestor.requestRfqtFirmQuotesAsync(\n            makerToken,\n            takerToken,\n            assetFillAmount,\n            marketOperation,\n            comparisonPrice,\n            {\n                altRfqAssetOfferings,\n                integrator,\n                intentOnFilling,\n                isIndicative: false,\n                isLastLook: false,\n                makerEndpointMaxResponseTimeMs: 600,\n                takerAddress,\n                txOrigin,\n            },\n        );\n\n        return quotes.map((q) => {\n            return {\n                ...q,\n                makerUri: this._quoteRequestor.getMakerUriForSignature(q.signature),\n            };\n        });\n    }\n\n    /**\n     * Accepts data sent by 0x API and fetches prices from Market Makers\n     * configured on the given pair.\n     *\n     * Note that by this point, 0x API should be sending the null address\n     * as the `takerAddress` and the taker's address as the `txOrigin`.\n     */\n    public async getV2PricesAsync(quoteContext: QuoteContext, now: Date = new Date()): Promise<RfqtV2Price[]> {\n        const { feeWithDetails: fee } = await this._feeService.calculateFeeAsync(quoteContext);\n        return this._getV2PricesInternalAsync(quoteContext, fee, now);\n    }\n\n    /**\n     * Accepts data sent by 0x API and fetches quotes from market makers\n     * configured on the given pair.\n     *\n     * Preparing quotes is a two step process:\n     *  1. Requests are made to the market makers' `/price` endpoint using\n     *     logic similar to that of `getV2PricesAsync`\n     *  2. Valid prices are then sent to the market makers' `/sign`\n     *     endpoint to get a signed quote\n     */\n    public async getV2QuotesAsync(quoteContext: FirmQuoteContext, now: Date = new Date()): Promise<RfqtV2Quote[]> {\n        const { feeWithDetails: fee } = await this._feeService.calculateFeeAsync(quoteContext);\n        const storedFee: StoredFee = feeToStoredFee(fee);\n\n        // TODO (rhinodavid): put a meter on this response time\n        const prices = await this._getV2PricesInternalAsync(quoteContext, fee, now);\n\n        // Handle nonce\n        let pricesAndOrders: { price: RfqtV2Price; order: OtcOrder }[] = [];\n\n        if (quoteContext.workflow === 'gasless-rfqt') {\n            // For gasless RFQt, each order needs a different bucket\n            // \"Reserve\" the next N buckets and get the last one\n            const lastReservedBucket =\n                (await this._cacheClient.getNextNOtcOrderBucketsAsync(quoteContext.chainId, prices.length)) %\n                GASLESS_OTC_ORDER_NUM_BUCKETS;\n\n            // Starting with the last bucket, we give each request its own bucket by decrementing\n            // and wrapping around if negative (via modulo)\n            const baseNonce = new BigNumber(Math.floor(now.getTime() / ONE_SECOND_MS));\n            pricesAndOrders = prices.map((price, i) => ({\n                order: this._v2priceToOrder(\n                    price,\n                    quoteContext.txOrigin,\n                    baseNonce,\n                    new BigNumber(modulo(lastReservedBucket - i, GASLESS_OTC_ORDER_NUM_BUCKETS)), // decrement from last bucket and wrap around if negative\n                ),\n                price,\n            }));\n        } else if (quoteContext.workflow === 'rfqt') {\n            // For RFQt, all orders share the same bucket, but must have different nonces\n            // For RFQtMultiHop all orders have different buckets and nonces\n            const baseNonce = new BigNumber(Math.floor(now.getTime() / ONE_SECOND_MS));\n            pricesAndOrders = prices.map((price, i) => ({\n                order: this._v2priceToOrder(\n                    price,\n                    quoteContext.txOrigin,\n                    baseNonce.plus(i),\n                    quoteContext.bucket !== undefined ? new BigNumber(quoteContext.bucket + i) : new BigNumber(0), // bucket\n                ),\n                price,\n            }));\n        }\n\n        const pricesAndOrdersAndSignatures = await Promise.all(\n            pricesAndOrders.map(async ({ price, order }) => {\n                let signature: Signature | undefined;\n                try {\n                    const orderHash = order.getHash();\n                    signature = await this._quoteServerClient.signV2Async(\n                        price.makerUri,\n                        quoteContext.integrator.integratorId,\n                        {\n                            order,\n                            orderHash,\n                            expiry: price.expiry,\n                            fee,\n                            trader: quoteContext.trader,\n                            workflow: quoteContext.workflow,\n                        },\n                        (u: string) => `${u}/rfqt/v2/sign`,\n                        /* requireProceedWithFill */ false,\n                    );\n\n                    if (signature) {\n                        // Certain market makers are returning signature components which are missing\n                        // leading bytes. Add them if they don't exist.\n                        const paddedSignature = padSignature(signature);\n                        if (paddedSignature.r !== signature.r || paddedSignature.s !== signature.s) {\n                            logger.warn(\n                                { orderHash, r: paddedSignature.r, s: paddedSignature.s },\n                                'Got market maker signature with missing bytes',\n                            );\n                            signature = paddedSignature;\n                        }\n\n                        // Verify the signer was the maker\n                        const signerAddress = getSignerFromHash(orderHash, signature).toLowerCase();\n                        const makerAddress = order.maker.toLowerCase();\n                        if (signerAddress !== makerAddress) {\n                            const isValidSigner = await this._blockchainUtils.isValidOrderSignerAsync(\n                                makerAddress,\n                                signerAddress,\n                            );\n                            if (!isValidSigner) {\n                                logger.warn(\n                                    { signerAddress, makerAddress, orderHash, makerUri: price.makerUri },\n                                    'Invalid maker signature',\n                                );\n\n                                // Quotes with `undefined` signature will be filtered out later\n                                signature = undefined;\n                            }\n                        }\n                    }\n                } catch (e) {\n                    logger.warn(\n                        { orderHash: order.getHash(), makerId: price.makerId },\n                        'Failed trying to get rfqt signature from market maker',\n                    );\n                }\n                return {\n                    price,\n                    order,\n                    signature: signature ?? null,\n                };\n            }),\n        );\n\n        // (Maker Balance Cache) Fetch maker balances to calculate fillable amounts\n        let quotedMakerBalances: BigNumber[] | undefined;\n        const quotedERC20Owners = prices.map((price) => ({\n            owner: price.makerAddress,\n            token: price.makerToken,\n        }));\n        try {\n            quotedMakerBalances = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(\n                this._chainId,\n                quotedERC20Owners,\n            );\n        } catch (e) {\n            logger.error(\n                { chainId: this._chainId, quotedERC20Owners, errorMessage: e.message },\n                'Failed to fetch maker balances to calculate fillable amounts',\n            );\n        }\n\n        const fillableAmounts = getRfqtV2FillableAmounts(prices, this._chainId, quotedMakerBalances);\n\n        const quotes = pricesAndOrdersAndSignatures\n            .filter((pos) => pos.signature)\n            .map(({ price, order, signature }, i) => ({\n                ...fillableAmounts[i],\n                fillableTakerFeeAmount: new BigNumber(0),\n                makerId: price.makerId,\n                makerUri: price.makerUri,\n                order,\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                signature: signature!, // `null` signatures already filtered out\n            }));\n\n        // Write to Fee Event Report\n        if (this._kafkaProducer) {\n            try {\n                await quoteReportUtils.publishRfqtV2FeeEvent(\n                    {\n                        requestedBuyAmount: quoteContext.makerAmount ?? null,\n                        requestedSellAmount: quoteContext.takerAmount ?? null,\n                        requestedTakerAddress: quoteContext.takerAddress,\n                        buyTokenAddress: quoteContext.makerToken,\n                        sellTokenAddress: quoteContext.takerToken,\n                        integratorId: quoteContext.integrator.integratorId,\n                        quotes,\n                        fee: storedFee,\n                    },\n                    this._kafkaProducer,\n                    this._feeEventTopic,\n                );\n            } catch (e) {\n                logger.error(\n                    {\n                        chainId: this._chainId,\n                        requestedBuyAmount: quoteContext.makerAmount,\n                        requestedSellAmount: quoteContext.takerAmount,\n                        requestedTakerAddress: quoteContext.takerAddress,\n                        buyTokenAddress: quoteContext.makerToken,\n                        sellTokenAddress: quoteContext.takerToken,\n                        integratorId: quoteContext.integrator.integratorId,\n                        errorMessage: e.message,\n                    },\n                    'Failed to publish RFQt quote to Fee Event Report',\n                );\n            }\n        }\n\n        return quotes;\n    }\n\n    public get feeModelVersion(): FeeModelVersion {\n        return this._feeModelVersion;\n    }\n\n    /**\n     * Passthrough to TokenMetadataManager's `getTokenDecimalsAsync` method\n     */\n    public async getTokenDecimalsAsync(tokenAddress: string): Promise<number> {\n        return this._tokenMetadataManager.getTokenDecimalsAsync(tokenAddress);\n    }\n\n    /**\n     * Get prices from MMs for given quote context and fee.\n     */\n    public async _getV2PricesInternalAsync(\n        quoteContext: QuoteContext,\n        fee: Fee,\n        now: Date = new Date(),\n    ): Promise<RfqtV2Price[]> {\n        const { integrator, makerToken, takerToken } = quoteContext;\n        // Fetch the makers active on this pair\n        const makers = this._rfqMakerManager.getRfqtV2MakersForPair(makerToken, takerToken).filter((m) => {\n            if (m.rfqtUri === null) {\n                return false;\n            }\n            if (integrator.whitelistMakerIds && !integrator.whitelistMakerIds.includes(m.makerId)) {\n                return false;\n            }\n            return true;\n        });\n\n        // Short circuit if no makers are active\n        if (!makers.length) {\n            return [];\n        }\n\n        // TODO (haozhuo): check to see if MM passes circuit breaker\n\n        const prices = (\n            await this._quoteServerClient.batchGetPriceV2Async(\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                makers.map((m) => /* won't be null because of previous `filter` operation */ m.rfqtUri!),\n                integrator,\n                transformRfqtV2PricesParameters(quoteContext, fee, this._chainId),\n                (url) => `${url}/rfqt/v2/price`,\n            )\n        ).map((price) => {\n            const maker = makers.find((m) => m.rfqtUri === price.makerUri);\n            if (!maker) {\n                throw new Error(`Could not find maker with URI ${price.makerUri}`);\n            }\n            return {\n                expiry: price.expiry,\n                makerAddress: price.maker,\n                makerAmount: price.makerAmount,\n                makerId: maker.makerId,\n                makerToken: price.makerToken,\n                makerUri: price.makerUri,\n                takerAmount: price.takerAmount,\n                takerToken: price.takerToken,\n            };\n        });\n\n        // Filter out invalid prices\n        const validatedPrices = validateV2Prices(prices, quoteContext, this._minExpiryDurationMs, now);\n\n        return validatedPrices;\n    }\n\n    /**\n     * Converts a price returned from the market maker's `price` endpoint\n     * into an v2 order\n     */\n    private _v2priceToOrder(price: RfqtV2Price, txOrigin: string, nonce: BigNumber, nonceBucket: BigNumber): OtcOrder {\n        return new OtcOrder({\n            chainId: this._chainId,\n            expiryAndNonce: OtcOrder.encodeExpiryAndNonce(price.expiry, nonceBucket, nonce),\n            maker: price.makerAddress,\n            makerAmount: price.makerAmount,\n            makerToken: price.makerToken,\n            taker: NULL_ADDRESS,\n            takerAmount: price.takerAmount,\n            takerToken: price.takerToken,\n            txOrigin,\n            verifyingContract: this._contractAddresses.exchangeProxy,\n        });\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmTypes.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/QuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/number_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/RfqtQuoteValidator.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmImplementaionUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/rfqMakerBlacklist.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/RfqtQuoteValidator.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { Counter } from 'prom-client';\n\nimport { ONE_SECOND_MS } from '../core/constants';\nimport { logger } from '../logger';\nimport { QuoteContext } from '../services/types';\nimport { RfqtV2Price } from '../core/types';\n\nconst ORDER_FULLY_FILLABLE = new Counter({\n    name: 'rfqt_order_fully_fillable',\n    help: 'Number of fully fillable rfqt orders',\n    labelNames: ['chainId', 'makerUri'],\n});\nconst ORDER_PARTIALLY_FILLABLE = new Counter({\n    name: 'rfqt_order_partially_fillable',\n    help: 'Number of partially fillable rfqt orders',\n    labelNames: ['chainId', 'makerUri'],\n});\nconst ORDER_NOT_FILLABLE = new Counter({\n    name: 'rfqt_order_not_fillable',\n    help: 'Number of rfqt orders that are not fillable',\n    labelNames: ['chainId', 'makerUri'],\n});\n\n/**\n * Performs basic validation on fetched prices from Market Makers.\n *\n * Filters prices that:\n * - are for the wrong pair\n * - expire in less than the validity window\n *\n * @param prices Prices fetched from Market Makers\n * @returns Array of valid prices\n */\nexport function validateV2Prices(\n    prices: RfqtV2Price[],\n    quoteContext: QuoteContext,\n    validityWindowMs: number,\n    now: Date = new Date(),\n): RfqtV2Price[] {\n    // calculate minimum expiry threshold\n    const nowSeconds = new BigNumber(now.getTime()).div(ONE_SECOND_MS);\n    const validityWindowS = new BigNumber(validityWindowMs).div(ONE_SECOND_MS);\n    const expiryThreshold = nowSeconds.plus(validityWindowS);\n\n    return prices\n        .filter((price) => price.makerToken === quoteContext.makerToken && price.takerToken === quoteContext.takerToken)\n        .filter((price) => price.expiry.gte(expiryThreshold));\n}\n\n/**\n * Calculates fillable amounts based on the amount of assets Market Makers can provide for the trading pair.\n * If the maker has enough balance, return full amounts originally requested from the order.\n * If not, scale down fillable taker amount based on maker balance.\n *\n * @param prices Prices fetched from Market Makers\n * @param chainId Chain ID of fetched prices\n * @param quotedMakerBalances Array of cached market maker balances\n * @returns Array of maker and taker fillable amounts\n */\nexport function getRfqtV2FillableAmounts(\n    prices: RfqtV2Price[],\n    chainId: number,\n    quotedMakerBalances?: BigNumber[],\n): { fillableMakerAmount: BigNumber; fillableTakerAmount: BigNumber }[] {\n    // if no maker balances are present, assume all orders are fully fillable\n    if (!quotedMakerBalances) {\n        return prices.map((price) => ({\n            fillableMakerAmount: price.makerAmount,\n            fillableTakerAmount: price.takerAmount,\n        }));\n    }\n\n    return prices.map((price, i) => {\n        // if requested maker amount is zero, order is not fillable\n        if (price.makerAmount.lte(0)) {\n            ORDER_NOT_FILLABLE.inc({\n                chainId,\n                makerUri: price.makerUri,\n            });\n            logger.warn({ price }, 'Market maker provided an empty order');\n            return {\n                fillableMakerAmount: new BigNumber(0),\n                fillableTakerAmount: new BigNumber(0),\n            };\n        }\n\n        const makerBalance: BigNumber = quotedMakerBalances[i];\n\n        // quote is fully fillable\n        if (makerBalance.gte(price.makerAmount)) {\n            ORDER_FULLY_FILLABLE.inc({\n                chainId,\n                makerUri: price.makerUri,\n            });\n            return {\n                fillableMakerAmount: price.makerAmount,\n                fillableTakerAmount: price.takerAmount,\n            };\n        }\n\n        // order may be partially fillable\n        // scale down fillable taker amount according to available maker balance\n        const partialFillableTakerAmount = price.takerAmount.times(makerBalance).idiv(price.makerAmount);\n        ORDER_PARTIALLY_FILLABLE.inc({\n            chainId,\n            makerUri: price.makerUri,\n        });\n        logger.warn(\n            {\n                price,\n                makerAmount: price.makerAmount,\n                makerBalance,\n                takerAmount: price.takerAmount,\n                partialFillableTakerAmount,\n            },\n            'Market maker can only partially cover an order',\n        );\n        return {\n            fillableMakerAmount: makerBalance,\n            fillableTakerAmount: partialFillableTakerAmount,\n        };\n    });\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts",{"fileContent":"import { Connection } from 'typeorm';\n\nimport { RfqMaker, RfqMakerUpdateTimeHash } from '../entities';\n\n/**\n * RfqMakerDbUtils provides tools for maker services to interact with the database\n */\nexport class RfqMakerDbUtils {\n    constructor(private readonly _connection: Connection) {}\n\n    /**\n     * [RFQ maker] find RfqMaker for given maker and blockchain\n     */\n    public async getRfqMakerAsync(makerId: string, chainId: number): Promise<RfqMaker | null> {\n        return this._connection.getRepository(RfqMaker).findOne({\n            where: { makerId, chainId },\n        });\n    }\n\n    /**\n     * [RFQ maker] find all RfqMaker for given blockchain\n     */\n    public async getRfqMakersAsync(chainId: number): Promise<RfqMaker[]> {\n        return this._connection.getRepository(RfqMaker).find({\n            where: { chainId },\n        });\n    }\n\n    /**\n     * [RFQ maker] find a hash for all RfqMaker update time\n     */\n    public async getRfqMakersUpdateTimeHashAsync(chainId: number): Promise<string | null> {\n        const rfqMakerUpdateTimeHash = await this._connection.getRepository(RfqMakerUpdateTimeHash).findOne({\n            where: { chainId },\n        });\n\n        return rfqMakerUpdateTimeHash ? rfqMakerUpdateTimeHash.hash : null;\n    }\n\n    /**\n     * [RFQ maker] create or update RfqMaker for given maker and blockchain\n     */\n    public async createOrUpdateRfqMakerAsync(\n        makerId: string,\n        chainId: number,\n        pairs: [string, string][],\n        rfqtUri: string | null,\n        rfqmUri: string | null,\n    ): Promise<RfqMaker> {\n        const rfqMaker = new RfqMaker({\n            makerId,\n            chainId,\n            updatedAt: new Date(),\n            pairs,\n            rfqtUri,\n            rfqmUri,\n        });\n        await this._connection.getRepository(RfqMaker).save(rfqMaker);\n        await this._connection.query(`REFRESH MATERIALIZED VIEW rfq_maker_pairs_update_time_hashes`);\n        return rfqMaker;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/runner_utils.ts",{"fileContent":"import { createMetricsRouter, MetricsService } from '@0x/api-utils';\nimport { Worker } from 'bullmq';\nimport * as express from 'express';\n\nimport { ENABLE_PROMETHEUS_METRICS, PROMETHEUS_PORT } from '../config';\nimport { METRICS_PATH } from '../core/constants';\nimport { logger } from '../logger';\n\n/**\n * Close redis connections.\n *\n * @param redisConnections Redis connections to close.\n */\nexport async function closeRedisConnectionsAsync<T>(redisConnections: { quit: () => Promise<T> }[]): Promise<T[]> {\n    const results: T[] = [];\n    for (const connection of redisConnections) {\n        try {\n            const result = await connection.quit();\n            results.push(result);\n        } catch (error) {\n            logger.error({ errorMessage: error.message, stack: error.stack }, 'Faied to shutdown redis connection');\n        }\n    }\n    return results;\n}\n\n/**\n * Close bullmq workers.\n *\n * @param workers Bullmq workers to close.\n */\nexport async function closeWorkersAsync(workers: Worker[]): Promise<void> {\n    for (const worker of workers) {\n        try {\n            await worker.close();\n        } catch (error) {\n            logger.error(\n                { errorMessage: error.message, stack: error.stack },\n                `Failed to shutdown worker ${worker.name}`,\n            );\n        }\n    }\n}\n\n/**\n * Start the metrics server.\n */\nexport function startMetricsServer(): void {\n    if (ENABLE_PROMETHEUS_METRICS) {\n        const metricsService = new MetricsService();\n        const metricsRouter = createMetricsRouter(metricsService);\n        const metricsApp = express();\n\n        metricsApp.use(METRICS_PATH, metricsRouter);\n        const metricsServer = metricsApp.listen(PROMETHEUS_PORT, () => {\n            logger.info(`Metrics (HTTP) listening on port ${PROMETHEUS_PORT}`);\n        });\n\n        metricsServer.on('error', (error) => {\n            logger.error({ errorMessage: error, stack: error.stack }, 'Error in metrics server');\n        });\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/__tests__/GaslessSwapHandlers.test.ts",{"fileContent":"// tslint:disable: max-file-line-count\nimport { ValidationErrorCodes } from '@0x/api-utils';\nimport { ethSignHashWithKey, MetaTransaction, OtcOrder } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { AxiosInstance } from 'axios';\nimport * as express from 'express';\nimport * as HttpStatus from 'http-status-codes';\nimport Redis from 'ioredis';\nimport { mapValues } from 'lodash';\nimport { Producer } from 'sqs-producer';\nimport * as supertest from 'supertest';\n\nimport { Integrator } from '../../config';\nimport { TX_RELAY_V1_PATH, ZERO_G_ALIAS_PATH, ZERO_G_PATH } from '../../core/constants';\nimport { GaslessTypes } from '../../core/types';\nimport { TruncatedFees } from '../../core/types/meta_transaction_fees';\nimport { errorHandler } from '../../middleware/error_handling';\nimport { createTxRelayV1Router, createZeroGRouter } from '../../routers/GaslessSwapRouter';\nimport { GaslessSwapService } from '../../services/GaslessSwapService';\nimport { RfqmService } from '../../services/rfqm_service';\nimport {\n    FetchIndicativeQuoteResponse,\n    LiquiditySource,\n    MetaTransactionV1QuoteResponse,\n    MetaTransactionV2,\n    MetaTransactionV2QuoteResponse,\n    OtcOrderRfqmQuoteResponse,\n    SubmitMetaTransactionSignedQuoteResponse,\n    SubmitMetaTransactionV2SignedQuoteResponse,\n} from '../../services/types';\nimport { ConfigManager } from '../../utils/config_manager';\nimport { RfqmDbUtils } from '../../utils/rfqm_db_utils';\nimport { RfqBlockchainUtils } from '../../utils/rfq_blockchain_utils';\n\njest.mock('../../services/GaslessSwapService', () => {\n    return {\n        GaslessSwapService: jest.fn().mockImplementation(() => {\n            return {\n                fetchPriceAsync: jest.fn(),\n                fetchQuoteAsync: jest.fn(),\n                processSubmitAsync: jest.fn(),\n                // tslint:disable-next-line: custom-no-magic-numbers\n                getTokenDecimalsAsync: jest.fn().mockResolvedValue(18),\n            };\n        }),\n    };\n});\n\njest.mock('../../utils/config_manager', () => {\n    return {\n        ConfigManager: jest.fn().mockImplementation(() => {\n            return {\n                getRfqmApiKeyWhitelist: jest.fn().mockReturnValue(new Set(['integrator-api-key'])),\n                getIntegratorIdForApiKey: jest.fn().mockReturnValue('integrator-id'),\n                getIntegratorByIdOrThrow: jest.fn().mockImplementation((id) => {\n                    if (id !== 'integrator-id') {\n                        throw new Error();\n                    }\n                    const integrator: Integrator = {\n                        apiKeys: ['integrator-api-key'],\n                        allowedChainIds: [420, 1337], // tslint:disable-line: custom-no-magic-numbers\n                        integratorId: 'integrator-id',\n                        label: 'test integrator',\n                        plp: false,\n                        rfqt: false,\n                        rfqm: true,\n                    };\n                    return integrator;\n                }),\n            };\n        }),\n    };\n});\n\n// tslint:disable: no-object-literal-type-assertion\nconst mockGaslessSwapService = jest.mocked(\n    new GaslessSwapService(\n        0,\n        {} as RfqmService,\n        new URL('http://meta.transaction.service'),\n        {} as AxiosInstance,\n        {} as Redis,\n        {} as RfqmDbUtils,\n        {} as RfqBlockchainUtils,\n        {} as Producer,\n    ),\n);\nconst mockConfigManager = jest.mocked(new ConfigManager());\n// tslint:enable: no-object-literal-type-assertion\n\nconst testChainId = 1337;\n\n/**\n * Verifies the proper response to a request using a mocked `GaslessSwapService`.\n *\n * Each case sets up its own little Express app to avoid coupiling this\n * test to the upstream router.\n */\ndescribe('GaslessSwapHandlers', () => {\n    const takerAddress = '0x4c42a706410f1190f97d26fe3c999c90070aa40f';\n    const takerPrivateKey = '0xd2c2349e10170e4219d9febd1c663ea5c7334f79c38d25f4f52c85af796c7c05';\n    const feeRecipient = '0x5fb321349ace5303c82f0d1d491041e042f2ad22';\n    const app = express()\n        .use(express.json())\n        .use(ZERO_G_PATH, createZeroGRouter(new Map([[testChainId, mockGaslessSwapService]]), mockConfigManager))\n        .use(ZERO_G_ALIAS_PATH, createZeroGRouter(new Map([[testChainId, mockGaslessSwapService]]), mockConfigManager))\n        .use(\n            TX_RELAY_V1_PATH,\n            createTxRelayV1Router(new Map([[testChainId, mockGaslessSwapService]]), mockConfigManager),\n        )\n        .use(errorHandler);\n\n    afterEach(() => {\n        jest.clearAllMocks();\n    });\n\n    describe('parameter verification', () => {\n        it('throws if a required parameter is missing', async () => {\n            const response = await supertest(app)\n                .get(`${ZERO_G_ALIAS_PATH}/price`)\n                .query({ makerToken: '0xmakertoken' })\n                .set('Accept', 'application/json');\n\n            expect(response.body.validationErrors[0].code).toEqual(ValidationErrorCodes.RequiredField);\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n\n        it('throws if the chain ID is invalid', async () => {\n            const response = await supertest(app)\n                .get(`${ZERO_G_ALIAS_PATH}/price`)\n                .set('Content-type', 'application/json')\n                .set('0x-api-key', 'integrator-api-key')\n                .set('0x-chain-id', '420') // tslint:disable-line: custom-no-magic-numbers\n                .query({\n                    buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                    sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                    buyAmount: 1000,\n                    takerAddress,\n                    intentOnFilling: 'false',\n                    skipValidation: 'true',\n                });\n\n            expect(response.body.validationErrors[0].code).toEqual(ValidationErrorCodes.FieldInvalid);\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n\n        describe('zero-g', () => {\n            it('throws if the `slippagePercentage` is out of range for /price', async () => {\n                const response = await supertest(app)\n                    .get(`${ZERO_G_ALIAS_PATH}/price`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337') // tslint:disable-line: custom-no-magic-numbers\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        slippagePercentage: 2.1,\n                    });\n\n                expect(response.body.validationErrors[0].code).toEqual(ValidationErrorCodes.ValueOutOfRange);\n                expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n            });\n\n            it('throws if the `slippagePercentage` is out of range for /quote', async () => {\n                const response = await supertest(app)\n                    .get(`${ZERO_G_ALIAS_PATH}/quote`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337') // tslint:disable-line: custom-no-magic-numbers\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        slippagePercentage: 0.00001,\n                    });\n\n                expect(response.body.validationErrors[0].code).toEqual(ValidationErrorCodes.ValueOutOfRange);\n                expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n            });\n\n            it('throws if the `slippagePercentage` is invalid for /quote', async () => {\n                const response = await supertest(app)\n                    .get(`${ZERO_G_ALIAS_PATH}/quote`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337') // tslint:disable-line: custom-no-magic-numbers\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        slippagePercentage: 'invalid',\n                    });\n\n                expect(response.body.validationErrors[0].code).toEqual(ValidationErrorCodes.IncorrectFormat);\n                expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n            });\n        });\n\n        describe('tx relay v1', () => {\n            it('throws if the `slippagePercentage` is out of range for /price', async () => {\n                const response = await supertest(app)\n                    .get(`${TX_RELAY_V1_PATH}/price`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337') // tslint:disable-line: custom-no-magic-numbers\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        slippagePercentage: 101,\n                    });\n\n                expect(response.body.validationErrors[0].code).toEqual(ValidationErrorCodes.ValueOutOfRange);\n                expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n            });\n\n            it('throws if the `slippagePercentage` is out of range for /quote', async () => {\n                const response = await supertest(app)\n                    .get(`${TX_RELAY_V1_PATH}/quote`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337') // tslint:disable-line: custom-no-magic-numbers\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        slippagePercentage: 0.001,\n                    });\n\n                expect(response.body.validationErrors[0].code).toEqual(ValidationErrorCodes.ValueOutOfRange);\n                expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n            });\n\n            it('throws if the `slippagePercentage` is invalid for /quote', async () => {\n                const response = await supertest(app)\n                    .get(`${TX_RELAY_V1_PATH}/quote`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337') // tslint:disable-line: custom-no-magic-numbers\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        slippagePercentage: 'invalid',\n                    });\n\n                expect(response.body.validationErrors[0].code).toEqual(ValidationErrorCodes.IncorrectFormat);\n                expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n            });\n\n            it('throws if the `feeType` is invalid for /quote', async () => {\n                const response = await supertest(app)\n                    .get(`${TX_RELAY_V1_PATH}/quote`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337') // tslint:disable-line: custom-no-magic-numbers\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        slippagePercentage: 10,\n                        feeType: 'invalid',\n                        feeSellTokenPercentage: 10,\n                        feeRecipient,\n                    });\n\n                expect(response.body.validationErrors[0].code).toEqual(ValidationErrorCodes.ValueOutOfRange);\n                expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n            });\n\n            it('throws if the `feeSellTokenPercentage` is undefined when `feeType` is provided for /quote', async () => {\n                const response = await supertest(app)\n                    .get(`${TX_RELAY_V1_PATH}/quote`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337') // tslint:disable-line: custom-no-magic-numbers\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        slippagePercentage: 10,\n                        feeType: 'volume',\n                        feeRecipient,\n                    });\n\n                expect(response.body.validationErrors[0].code).toEqual(ValidationErrorCodes.RequiredField);\n                expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n            });\n\n            it('throws if the `feeSellTokenPercentage` is out of range for /quote', async () => {\n                const response = await supertest(app)\n                    .get(`${TX_RELAY_V1_PATH}/quote`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337') // tslint:disable-line: custom-no-magic-numbers\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        slippagePercentage: 10,\n                        feeType: 'volume',\n                        feeSellTokenPercentage: 101,\n                        feeRecipient,\n                    });\n\n                expect(response.body.validationErrors[0].code).toEqual(ValidationErrorCodes.ValueOutOfRange);\n                expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n            });\n\n            it('throws if the `feeSellTokenPercentage` is out of range for /price', async () => {\n                const response = await supertest(app)\n                    .get(`${TX_RELAY_V1_PATH}/price`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337') // tslint:disable-line: custom-no-magic-numbers\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        slippagePercentage: 10,\n                        feeType: 'volume',\n                        feeSellTokenPercentage: 101,\n                        feeRecipient,\n                    });\n\n                expect(response.body.validationErrors[0].code).toEqual(ValidationErrorCodes.ValueOutOfRange);\n                expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n            });\n\n            it('throws if the `feeRecipient` is undefined when `feeType` is provided for /quote', async () => {\n                const response = await supertest(app)\n                    .get(`${TX_RELAY_V1_PATH}/quote`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337') // tslint:disable-line: custom-no-magic-numbers\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        slippagePercentage: 10,\n                        feeType: 'volume',\n                        feeSellTokenPercentage: 5,\n                    });\n\n                expect(response.body.validationErrors[0].code).toEqual(ValidationErrorCodes.RequiredField);\n                expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n            });\n        });\n    });\n\n    describe('getPriceAsync', () => {\n        describe('zero-g', () => {\n            it('responds with an error if the underlying service call fails', async () => {\n                mockGaslessSwapService.fetchPriceAsync.mockRejectedValueOnce(new Error('The service blew up'));\n\n                const response = await supertest(app)\n                    .get(`${ZERO_G_ALIAS_PATH}/price`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337')\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        intentOnFilling: 'false',\n                        skipValidation: 'true',\n                    });\n\n                expect(response.statusCode).toEqual(HttpStatus.INTERNAL_SERVER_ERROR);\n            });\n\n            it('passes calls on to Gasless Swap Service', async () => {\n                mockGaslessSwapService.fetchPriceAsync.mockResolvedValue(null);\n\n                await supertest(app)\n                    .get(`${ZERO_G_ALIAS_PATH}/price`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337')\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        intentOnFilling: 'false',\n                        skipValidation: 'true',\n                    });\n\n                expect(mockGaslessSwapService.fetchPriceAsync.mock.calls[0]).toMatchInlineSnapshot(`\n                    Array [\n                      Object {\n                        \"affiliateAddress\": undefined,\n                        \"buyAmount\": \"1000\",\n                        \"buyToken\": \"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619\",\n                        \"buyTokenDecimals\": 18,\n                        \"feeRecipient\": undefined,\n                        \"feeSellTokenPercentage\": undefined,\n                        \"feeType\": undefined,\n                        \"integrator\": Object {\n                          \"allowedChainIds\": Array [\n                            420,\n                            1337,\n                          ],\n                          \"apiKeys\": Array [\n                            \"integrator-api-key\",\n                          ],\n                          \"integratorId\": \"integrator-id\",\n                          \"label\": \"test integrator\",\n                          \"plp\": false,\n                          \"rfqm\": true,\n                          \"rfqt\": false,\n                        },\n                        \"sellAmount\": undefined,\n                        \"sellToken\": \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n                        \"sellTokenDecimals\": 18,\n                        \"slippagePercentage\": undefined,\n                        \"takerAddress\": \"0x4c42a706410f1190f97d26fe3c999c90070aa40f\",\n                      },\n                      \"metatransaction\",\n                    ]\n                `);\n            });\n\n            it('returns returns an RFQ Price', async () => {\n                const price: FetchIndicativeQuoteResponse & { liquiditySource: 'rfq' } = {\n                    allowanceTarget: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                    buyAmount: new BigNumber(1000),\n                    sellAmount: new BigNumber(2000),\n                    buyTokenAddress: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                    sellTokenAddress: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                    gas: new BigNumber(1043459),\n                    price: new BigNumber(2),\n                    liquiditySource: 'rfq',\n                };\n\n                mockGaslessSwapService.fetchPriceAsync.mockResolvedValue(price);\n\n                const response = await supertest(app)\n                    .get(`${ZERO_G_ALIAS_PATH}/price`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337')\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        intentOnFilling: 'false',\n                        skipValidation: 'true',\n                    });\n\n                expect(response.body).toStrictEqual({ ...convertBigNumbersToJson(price), liquidityAvailable: true });\n                expect(response.statusCode).toEqual(HttpStatus.OK);\n            });\n\n            it('returns returns an AMM Price', async () => {\n                const price: FetchIndicativeQuoteResponse & { liquiditySource: 'amm' } = {\n                    allowanceTarget: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                    buyAmount: new BigNumber(1000),\n                    sellAmount: new BigNumber(2000),\n                    buyTokenAddress: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                    sellTokenAddress: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                    gas: new BigNumber(1043459),\n                    price: new BigNumber(2),\n                    liquiditySource: 'amm',\n                };\n\n                mockGaslessSwapService.fetchPriceAsync.mockResolvedValue(price);\n\n                const response = await supertest(app)\n                    .get(`${ZERO_G_ALIAS_PATH}/price`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337')\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        intentOnFilling: 'false',\n                        skipValidation: 'true',\n                    });\n\n                expect(response.body).toStrictEqual({ ...convertBigNumbersToJson(price), liquidityAvailable: true });\n                expect(response.statusCode).toEqual(HttpStatus.OK);\n            });\n        });\n\n        describe('tx relay v1', () => {\n            it('passes calls on to Gasless Swap Service', async () => {\n                mockGaslessSwapService.fetchPriceAsync.mockResolvedValue(null);\n\n                await supertest(app)\n                    .get(`${TX_RELAY_V1_PATH}/price`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337')\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        intentOnFilling: 'false',\n                        skipValidation: 'true',\n                        feeType: 'volume',\n                        feeSellTokenPercentage: 10,\n                        feeRecipient,\n                    });\n\n                expect(mockGaslessSwapService.fetchPriceAsync.mock.calls[0]).toMatchInlineSnapshot(`\n                    Array [\n                      Object {\n                        \"affiliateAddress\": undefined,\n                        \"buyAmount\": \"1000\",\n                        \"buyToken\": \"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619\",\n                        \"buyTokenDecimals\": 18,\n                        \"feeRecipient\": \"${feeRecipient}\",\n                        \"feeSellTokenPercentage\": \"10\",\n                        \"feeType\": \"volume\",\n                        \"integrator\": Object {\n                          \"allowedChainIds\": Array [\n                            420,\n                            1337,\n                          ],\n                          \"apiKeys\": Array [\n                            \"integrator-api-key\",\n                          ],\n                          \"integratorId\": \"integrator-id\",\n                          \"label\": \"test integrator\",\n                          \"plp\": false,\n                          \"rfqm\": true,\n                          \"rfqt\": false,\n                        },\n                        \"sellAmount\": undefined,\n                        \"sellToken\": \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n                        \"sellTokenDecimals\": 18,\n                        \"slippagePercentage\": undefined,\n                        \"takerAddress\": \"0x4c42a706410f1190f97d26fe3c999c90070aa40f\",\n                      },\n                      \"metatransaction_v2\",\n                    ]\n                `);\n            });\n\n            it('returns returns a meta-transaction price', async () => {\n                const price: FetchIndicativeQuoteResponse & { sources: LiquiditySource[]; fees?: TruncatedFees } = {\n                    allowanceTarget: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                    buyAmount: new BigNumber(1000),\n                    sellAmount: new BigNumber(2000),\n                    buyTokenAddress: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                    sellTokenAddress: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                    gas: new BigNumber(1043459),\n                    price: new BigNumber(2),\n                    sources: [\n                        {\n                            name: 'QuickSwap',\n                            proportion: new BigNumber(0.2308),\n                        },\n                        {\n                            name: 'DODO_V2',\n                            proportion: new BigNumber(0.07692),\n                        },\n                        {\n                            name: 'Uniswap_V3',\n                            proportion: new BigNumber(0.6923),\n                        },\n                    ],\n                    fees: {\n                        integratorFee: {\n                            feeType: 'volume',\n                            feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                            feeAmount: new BigNumber(100),\n                        },\n                        zeroExFee: {\n                            feeType: 'integrator_share',\n                            feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                            feeAmount: new BigNumber(10),\n                        },\n                        gasFee: {\n                            feeType: 'gas',\n                            feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                            feeAmount: new BigNumber(1),\n                        },\n                    },\n                };\n\n                mockGaslessSwapService.fetchPriceAsync.mockResolvedValue(price);\n\n                const response = await supertest(app)\n                    .get(`${TX_RELAY_V1_PATH}/price`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337')\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        intentOnFilling: 'false',\n                        skipValidation: 'true',\n                    });\n\n                expect(response.body).toStrictEqual({ ...convertBigNumbersToJson(price), liquidityAvailable: true });\n                expect(response.statusCode).toEqual(HttpStatus.OK);\n            });\n        });\n    });\n\n    describe('getQuoteAsync', () => {\n        describe('zero-g', () => {\n            it('passes calls on to Gasless Swap Service', async () => {\n                mockGaslessSwapService.fetchQuoteAsync.mockResolvedValue(null);\n\n                await supertest(app)\n                    .get(`${ZERO_G_ALIAS_PATH}/quote`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337')\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        intentOnFilling: 'false',\n                        skipValidation: 'true',\n                    });\n\n                expect(mockGaslessSwapService.fetchQuoteAsync.mock.calls[0]).toMatchInlineSnapshot(`\n                    Array [\n                      Object {\n                        \"affiliateAddress\": undefined,\n                        \"buyAmount\": \"1000\",\n                        \"buyToken\": \"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619\",\n                        \"buyTokenDecimals\": 18,\n                        \"checkApproval\": false,\n                        \"feeRecipient\": undefined,\n                        \"feeSellTokenPercentage\": undefined,\n                        \"feeType\": undefined,\n                        \"integrator\": Object {\n                          \"allowedChainIds\": Array [\n                            420,\n                            1337,\n                          ],\n                          \"apiKeys\": Array [\n                            \"integrator-api-key\",\n                          ],\n                          \"integratorId\": \"integrator-id\",\n                          \"label\": \"test integrator\",\n                          \"plp\": false,\n                          \"rfqm\": true,\n                          \"rfqt\": false,\n                        },\n                        \"sellAmount\": undefined,\n                        \"sellToken\": \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n                        \"sellTokenDecimals\": 18,\n                        \"slippagePercentage\": undefined,\n                        \"takerAddress\": \"0x4c42a706410f1190f97d26fe3c999c90070aa40f\",\n                      },\n                      \"metatransaction\",\n                    ]\n                `);\n            });\n\n            it('returns an RFQ quote', async () => {\n                const quote: OtcOrderRfqmQuoteResponse & { liquiditySource: 'rfq' } = {\n                    buyAmount: new BigNumber('1800054805473'),\n                    buyTokenAddress: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                    gas: new BigNumber('1043459'),\n                    order: new OtcOrder({\n                        chainId: 1337,\n                        expiryAndNonce: new BigNumber(\n                            '62771017353866807638357894232076664161023554444640345128970000000000000000',\n                        ),\n                        maker: '0x2222222222222222222222222222222222222222',\n                        makerAmount: new BigNumber('0'),\n                        makerToken: '0x3333333333333333333333333333333333333333',\n                        taker: '0x1111111111111111111111111111111111111111',\n                        takerAmount: new BigNumber('0'),\n                        takerToken: '0x4444444444444444444444444444444444444444',\n                        txOrigin: '0x0000000000000000000000000000000000000000',\n                        verifyingContract: '0x0000000000000000000000000000000000000000',\n                    }),\n                    orderHash: '0x69b784087387d37e2361a40146420a5a68b08375238a5ba0329f612d5673b2ea',\n                    price: new BigNumber('1800.054805'),\n                    sellAmount: new BigNumber('1000000000000000000000'),\n                    sellTokenAddress: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                    type: GaslessTypes.OtcOrder,\n                    liquiditySource: 'rfq',\n                };\n                mockGaslessSwapService.fetchQuoteAsync.mockResolvedValue(quote);\n\n                const response = await supertest(app)\n                    .get(`${ZERO_G_ALIAS_PATH}/quote`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337')\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1800054805473,\n                        takerAddress,\n                        intentOnFilling: 'true',\n                        skipValidation: 'true',\n                    });\n\n                expect(response.body).toStrictEqual({ ...convertBigNumbersToJson(quote), liquidityAvailable: true });\n                expect(response.statusCode).toEqual(HttpStatus.OK);\n            });\n\n            it('returns an AMM quote', async () => {\n                const quote: MetaTransactionV1QuoteResponse & { liquiditySource: 'amm' } = {\n                    buyAmount: new BigNumber('1800054805473'),\n                    buyTokenAddress: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                    gas: new BigNumber('1043459'),\n                    metaTransaction: new MetaTransaction({\n                        callData:\n                            '0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000017b9e2a304f00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac18858000000000000000000000000000000000000000000000000000000039d0b9efd1000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001c94ebec37000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001db5156c13000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e69737761705633000000000000000000000000000000000000000000000000000000000000190522016f044a05b0000000000000000000000000000000000000000000000000000000b08217af9400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000000c829100b78224ef50000000000000000000000000000000000000000000000000000000570157389f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c6300000000000000000000000000000000000000000000005b89d96b4863067a6b',\n                        chainId: 137,\n                        expirationTimeSeconds: new BigNumber('9990868679'),\n                        feeAmount: new BigNumber('0'),\n                        feeToken: '0x0000000000000000000000000000000000000000',\n                        maxGasPrice: new BigNumber('4294967296'),\n                        minGasPrice: new BigNumber('1'),\n                        salt: new BigNumber(\n                            '32606650794224190000000000000000000000000000000000000000000000000000000000000',\n                        ),\n                        sender: '0x0000000000000000000000000000000000000000',\n                        signer: '0x4c42a706410f1190f97d26fe3c999c90070aa40f',\n                        value: new BigNumber('0'),\n                        verifyingContract: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                    }),\n                    metaTransactionHash: '0xde5a11983edd012047dd3107532f007a73ae488bfb354f35b8a40580e2a775a1',\n                    price: new BigNumber('1800.054805'),\n                    sellAmount: new BigNumber('1000000000000000000000'),\n                    sellTokenAddress: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                    type: GaslessTypes.MetaTransaction,\n                    liquiditySource: 'amm',\n                };\n                mockGaslessSwapService.fetchQuoteAsync.mockResolvedValue(quote);\n\n                const response = await supertest(app)\n                    .get(`${ZERO_G_ALIAS_PATH}/quote`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337')\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1800054805473,\n                        takerAddress,\n                        intentOnFilling: 'true',\n                        skipValidation: 'true',\n                    });\n\n                expect(response.body).toStrictEqual({ ...convertBigNumbersToJson(quote), liquidityAvailable: true });\n                expect(response.statusCode).toEqual(HttpStatus.OK);\n            });\n        });\n\n        describe('tx relay v1', () => {\n            it('passes calls on to Gasless Swap Service', async () => {\n                mockGaslessSwapService.fetchQuoteAsync.mockResolvedValue(null);\n\n                await supertest(app)\n                    .get(`${TX_RELAY_V1_PATH}/quote`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337')\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1000,\n                        takerAddress,\n                        intentOnFilling: 'false',\n                        skipValidation: 'true',\n                        feeType: 'volume',\n                        feeSellTokenPercentage: 10,\n                        feeRecipient,\n                    });\n\n                expect(mockGaslessSwapService.fetchQuoteAsync.mock.calls[0]).toMatchInlineSnapshot(`\n                    Array [\n                      Object {\n                        \"affiliateAddress\": undefined,\n                        \"buyAmount\": \"1000\",\n                        \"buyToken\": \"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619\",\n                        \"buyTokenDecimals\": 18,\n                        \"checkApproval\": false,\n                        \"feeRecipient\": \"${feeRecipient}\",\n                        \"feeSellTokenPercentage\": \"10\",\n                        \"feeType\": \"volume\",\n                        \"integrator\": Object {\n                          \"allowedChainIds\": Array [\n                            420,\n                            1337,\n                          ],\n                          \"apiKeys\": Array [\n                            \"integrator-api-key\",\n                          ],\n                          \"integratorId\": \"integrator-id\",\n                          \"label\": \"test integrator\",\n                          \"plp\": false,\n                          \"rfqm\": true,\n                          \"rfqt\": false,\n                        },\n                        \"sellAmount\": undefined,\n                        \"sellToken\": \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n                        \"sellTokenDecimals\": 18,\n                        \"slippagePercentage\": undefined,\n                        \"takerAddress\": \"0x4c42a706410f1190f97d26fe3c999c90070aa40f\",\n                      },\n                      \"metatransaction_v2\",\n                    ]\n                `);\n            });\n\n            it('returns a meta-transaction quote', async () => {\n                const quote: MetaTransactionV2QuoteResponse = {\n                    buyAmount: new BigNumber('1800054805473'),\n                    buyTokenAddress: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                    gas: new BigNumber('1043459'),\n                    trade: {\n                        kind: GaslessTypes.MetaTransaction,\n                        hash: '0xde5a11983edd012047dd3107532f007a73ae488bfb354f35b8a40580e2a775a1',\n                        metaTransaction: new MetaTransaction({\n                            callData:\n                                '0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000017b9e2a304f00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac18858000000000000000000000000000000000000000000000000000000039d0b9efd1000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001c94ebec37000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001db5156c13000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e69737761705633000000000000000000000000000000000000000000000000000000000000190522016f044a05b0000000000000000000000000000000000000000000000000000000b08217af9400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000000c829100b78224ef50000000000000000000000000000000000000000000000000000000570157389f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c6300000000000000000000000000000000000000000000005b89d96b4863067a6b',\n                            chainId: 137,\n                            expirationTimeSeconds: new BigNumber('9990868679'),\n                            feeAmount: new BigNumber('0'),\n                            feeToken: '0x0000000000000000000000000000000000000000',\n                            maxGasPrice: new BigNumber('4294967296'),\n                            minGasPrice: new BigNumber('1'),\n                            salt: new BigNumber(\n                                '32606650794224190000000000000000000000000000000000000000000000000000000000000',\n                            ),\n                            sender: '0x0000000000000000000000000000000000000000',\n                            signer: '0x4c42a706410f1190f97d26fe3c999c90070aa40f',\n                            value: new BigNumber('0'),\n                            verifyingContract: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                        }),\n                    },\n                    price: new BigNumber('1800.054805'),\n                    sellAmount: new BigNumber('1000000000000000000000'),\n                    sellTokenAddress: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                    sources: [\n                        {\n                            name: 'QuickSwap',\n                            proportion: new BigNumber(0.2308),\n                        },\n                        {\n                            name: 'DODO_V2',\n                            proportion: new BigNumber(0.07692),\n                        },\n                        {\n                            name: 'Uniswap_V3',\n                            proportion: new BigNumber(0.6923),\n                        },\n                    ],\n                    fees: {\n                        integratorFee: {\n                            feeType: 'volume',\n                            feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                            feeAmount: new BigNumber(100),\n                        },\n                        zeroExFee: {\n                            feeType: 'integrator_share',\n                            feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                            feeAmount: new BigNumber(10),\n                        },\n                        gasFee: {\n                            feeType: 'gas',\n                            feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                            feeAmount: new BigNumber(1),\n                        },\n                    },\n                };\n                mockGaslessSwapService.fetchQuoteAsync.mockResolvedValue(quote);\n                const response = await supertest(app)\n                    .get(`${TX_RELAY_V1_PATH}/quote`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337')\n                    .query({\n                        buyToken: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619',\n                        sellToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyAmount: 1800054805473,\n                        takerAddress,\n                        intentOnFilling: 'true',\n                        skipValidation: 'true',\n                    });\n\n                expect(response.body).toStrictEqual({ ...convertBigNumbersToJson(quote), liquidityAvailable: true });\n                expect(response.statusCode).toEqual(HttpStatus.OK);\n            });\n        });\n    });\n\n    describe('processSubmitAsync', () => {\n        describe('zero-g', () => {\n            it('returns a metatransaction result', async () => {\n                const metaTransaction = new MetaTransaction({\n                    callData:\n                        '0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000017b9e2a304f00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac18858000000000000000000000000000000000000000000000000000000039d0b9efd1000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001c94ebec37000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001db5156c13000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e69737761705633000000000000000000000000000000000000000000000000000000000000190522016f044a05b0000000000000000000000000000000000000000000000000000000b08217af9400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000000c829100b78224ef50000000000000000000000000000000000000000000000000000000570157389f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c6300000000000000000000000000000000000000000000005b89d96b4863067a6b',\n                    chainId: 137,\n                    expirationTimeSeconds: new BigNumber('9990868679'),\n                    feeAmount: new BigNumber('0'),\n                    feeToken: '0x0000000000000000000000000000000000000000',\n                    maxGasPrice: new BigNumber('4294967296'),\n                    minGasPrice: new BigNumber('1'),\n                    salt: new BigNumber(\n                        '32606650794224190000000000000000000000000000000000000000000000000000000000000',\n                    ),\n                    sender: '0x0000000000000000000000000000000000000000',\n                    signer: '0x4c42a706410f1190f97d26fe3c999c90070aa40f',\n                    value: new BigNumber('0'),\n                    verifyingContract: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                });\n                const submitResult: SubmitMetaTransactionSignedQuoteResponse = {\n                    metaTransactionHash: '0xde5a11983edd012047dd3107532f007a73ae488bfb354f35b8a40580e2a775a1',\n                    type: GaslessTypes.MetaTransaction,\n                };\n\n                mockGaslessSwapService.processSubmitAsync.mockResolvedValue(submitResult);\n\n                const response = await supertest(app)\n                    .post(`${ZERO_G_ALIAS_PATH}/submit`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337')\n                    .send({\n                        kind: GaslessTypes.MetaTransaction,\n                        trade: {\n                            metaTransaction,\n                            type: GaslessTypes.MetaTransaction,\n                            signature: ethSignHashWithKey(metaTransaction.getHash(), takerPrivateKey),\n                        },\n                    });\n\n                expect(mockGaslessSwapService.processSubmitAsync.mock.calls[0]).toMatchInlineSnapshot(`\n                    Array [\n                      Object {\n                        \"kind\": \"metatransaction\",\n                        \"trade\": Object {\n                          \"metaTransaction\": MetaTransaction {\n                            \"callData\": \"0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000017b9e2a304f00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac18858000000000000000000000000000000000000000000000000000000039d0b9efd1000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001c94ebec37000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001db5156c13000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e69737761705633000000000000000000000000000000000000000000000000000000000000190522016f044a05b0000000000000000000000000000000000000000000000000000000b08217af9400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000000c829100b78224ef50000000000000000000000000000000000000000000000000000000570157389f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c6300000000000000000000000000000000000000000000005b89d96b4863067a6b\",\n                            \"chainId\": 137,\n                            \"expirationTimeSeconds\": \"9990868679\",\n                            \"feeAmount\": \"0\",\n                            \"feeToken\": \"0x0000000000000000000000000000000000000000\",\n                            \"maxGasPrice\": \"4294967296\",\n                            \"minGasPrice\": \"1\",\n                            \"salt\": \"32606650794224190000000000000000000000000000000000000000000000000000000000000\",\n                            \"sender\": \"0x0000000000000000000000000000000000000000\",\n                            \"signer\": \"0x4c42a706410f1190f97d26fe3c999c90070aa40f\",\n                            \"value\": \"0\",\n                            \"verifyingContract\": \"0xdef1c0ded9bec7f1a1670819833240f027b25eff\",\n                          },\n                          \"signature\": Object {\n                            \"r\": \"0x7247ed156081c767781834b122d4e9317f3cc2d5ed529cb74aaaa11d8b5a93f8\",\n                            \"s\": \"0x19a0b795609483b9fcbc42b574e4401401308b4c24347b0bda8a2cf2332efd78\",\n                            \"signatureType\": 3,\n                            \"v\": 28,\n                          },\n                          \"type\": \"metatransaction\",\n                        },\n                      },\n                      \"integrator-id\",\n                    ]\n                `);\n                expect(response.statusCode).toEqual(HttpStatus.CREATED);\n                expect(response.body).toEqual(submitResult);\n            });\n        });\n\n        describe('tx relay v1', () => {\n            it('returns a metatransaction result', async () => {\n                const metaTransaction = new MetaTransactionV2({\n                    callData:\n                        '0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000017b9e2a304f00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac18858000000000000000000000000000000000000000000000000000000039d0b9efd1000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001c94ebec37000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001db5156c13000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e69737761705633000000000000000000000000000000000000000000000000000000000000190522016f044a05b0000000000000000000000000000000000000000000000000000000b08217af9400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000000c829100b78224ef50000000000000000000000000000000000000000000000000000000570157389f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c6300000000000000000000000000000000000000000000005b89d96b4863067a6b',\n                    chainId: 137,\n                    expirationTimeSeconds: new BigNumber('9990868679'),\n                    feeAmount: new BigNumber('0'),\n                    feeToken: '0x0000000000000000000000000000000000000000',\n                    maxGasPrice: new BigNumber('4294967296'),\n                    minGasPrice: new BigNumber('1'),\n                    salt: new BigNumber(\n                        '32606650794224190000000000000000000000000000000000000000000000000000000000000',\n                    ),\n                    sender: '0x0000000000000000000000000000000000000000',\n                    signer: '0x4c42a706410f1190f97d26fe3c999c90070aa40f',\n                    value: new BigNumber('0'),\n                    verifyingContract: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                });\n                const submitResult: SubmitMetaTransactionV2SignedQuoteResponse = {\n                    metaTransactionHash: '0xde5a11983edd012047dd3107532f007a73ae488bfb354f35b8a40580e2a775a1',\n                    type: GaslessTypes.MetaTransactionV2,\n                };\n\n                mockGaslessSwapService.processSubmitAsync.mockResolvedValue(submitResult);\n\n                const response = await supertest(app)\n                    .post(`${TX_RELAY_V1_PATH}/submit`)\n                    .set('Content-type', 'application/json')\n                    .set('0x-api-key', 'integrator-api-key')\n                    .set('0x-chain-id', '1337')\n                    .send({\n                        kind: GaslessTypes.MetaTransactionV2,\n                        trade: {\n                            metaTransaction,\n                            type: GaslessTypes.MetaTransactionV2,\n                            signature: ethSignHashWithKey(metaTransaction.getHash(), takerPrivateKey),\n                        },\n                    });\n\n                expect(mockGaslessSwapService.processSubmitAsync.mock.calls[0]).toMatchInlineSnapshot(`\n                    Array [\n                      Object {\n                        \"kind\": \"metatransaction_v2\",\n                        \"trade\": Object {\n                          \"metaTransaction\": MetaTransactionV2 {\n                            \"callData\": \"0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000017b9e2a304f00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac18858000000000000000000000000000000000000000000000000000000039d0b9efd1000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001c94ebec37000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001db5156c13000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e69737761705633000000000000000000000000000000000000000000000000000000000000190522016f044a05b0000000000000000000000000000000000000000000000000000000b08217af9400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000000c829100b78224ef50000000000000000000000000000000000000000000000000000000570157389f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c6300000000000000000000000000000000000000000000005b89d96b4863067a6b\",\n                            \"chainId\": 137,\n                            \"expirationTimeSeconds\": \"9990868679\",\n                            \"feeAmount\": \"0\",\n                            \"feeToken\": \"0x0000000000000000000000000000000000000000\",\n                            \"maxGasPrice\": \"4294967296\",\n                            \"minGasPrice\": \"1\",\n                            \"salt\": \"32606650794224190000000000000000000000000000000000000000000000000000000000000\",\n                            \"sender\": \"0x0000000000000000000000000000000000000000\",\n                            \"signer\": \"0x4c42a706410f1190f97d26fe3c999c90070aa40f\",\n                            \"value\": \"0\",\n                            \"verifyingContract\": \"0xdef1c0ded9bec7f1a1670819833240f027b25eff\",\n                          },\n                          \"signature\": Object {\n                            \"r\": \"0x7247ed156081c767781834b122d4e9317f3cc2d5ed529cb74aaaa11d8b5a93f8\",\n                            \"s\": \"0x19a0b795609483b9fcbc42b574e4401401308b4c24347b0bda8a2cf2332efd78\",\n                            \"signatureType\": 3,\n                            \"v\": 28,\n                          },\n                          \"type\": \"metatransaction_v2\",\n                        },\n                      },\n                      \"integrator-id\",\n                    ]\n                `);\n                expect(response.statusCode).toEqual(HttpStatus.CREATED);\n                expect(response.body).toEqual(submitResult);\n            });\n        });\n    });\n});\n\n/**\n * Deeply transforms object keys from BigNumber to JSON\n */\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction convertBigNumbersToJson(x: Record<string, any>): Record<string, any> {\n    return mapValues(x, (v) => {\n        if (v instanceof BigNumber) {\n            return v.toJSON();\n        }\n        if (v instanceof Array) {\n            const jsonArray = [];\n            for (const item of v) {\n                jsonArray.push(convertBigNumbersToJson(item));\n            }\n            return jsonArray;\n        }\n        if (v instanceof Object) {\n            return convertBigNumbersToJson(v);\n        }\n        return v;\n    });\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/middleware/error_handling.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/routers/GaslessSwapRouter.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/GaslessSwapService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/GaslessSwapHandlers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/MetaTransactionClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_health_check.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/meta_transaction_fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/routers/GaslessSwapRouter.ts",{"fileContent":"import * as express from 'express';\nimport * as asyncHandler from 'express-async-handler';\n\nimport { GaslessSwapHandlers } from '../handlers/GaslessSwapHandlers';\nimport { GaslessSwapService } from '../services/GaslessSwapService';\nimport { ConfigManager } from '../utils/config_manager';\n\n/**\n * Creates an express router for zero-g related routes.\n */\nexport function createZeroGRouter(\n    gaslessSwapServices: Map<number, GaslessSwapService>,\n    configManager: ConfigManager,\n): express.Router {\n    const router = express.Router();\n    const handlers = new GaslessSwapHandlers(gaslessSwapServices, configManager);\n\n    // Routes\n    router.get('/healthz', asyncHandler(handlers.getHealthAsync.bind(handlers)));\n    router.get('/price', asyncHandler(handlers.getPriceAsync.bind(handlers)));\n    router.get('/quote', asyncHandler(handlers.getQuoteAsync.bind(handlers)));\n    router.get('/status/:hash', asyncHandler(handlers.getStatusAsync.bind(handlers)));\n    router.post('/submit', asyncHandler(handlers.processSubmitAsync.bind(handlers)));\n\n    return router;\n}\n\n/**\n * Creates an express router for tx relay v1 related routes.\n */\nexport function createTxRelayV1Router(\n    gaslessSwapServices: Map<number, GaslessSwapService>,\n    configManager: ConfigManager,\n): express.Router {\n    const router = express.Router();\n    const handlers = new GaslessSwapHandlers(gaslessSwapServices, configManager);\n\n    // Routes\n    router.get('/healthz', asyncHandler(handlers.getHealthAsync.bind(handlers)));\n    router.get('/price', asyncHandler(handlers.getPriceAsync.bind(handlers)));\n    router.get('/quote', asyncHandler(handlers.getQuoteAsync.bind(handlers)));\n    router.get('/status/:hash', asyncHandler(handlers.getStatusAsync.bind(handlers)));\n    router.post('/submit', asyncHandler(handlers.processSubmitAsync.bind(handlers)));\n\n    return router;\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/GaslessSwapHandlers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/GaslessSwapService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_health_check.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_request_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/MetaTransactionClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/meta_transaction_fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/GaslessSwapHandlers.ts",{"fileContent":"// tslint:disable:max-file-line-count\nimport {\n    InternalServerError,\n    InvalidAPIKeyError,\n    isAPIError,\n    ValidationError,\n    ValidationErrorCodes,\n} from '@0x/api-utils';\nimport { MetaTransaction, OtcOrder } from '@0x/protocol-utils';\nimport { getTokenMetadataIfExists, isNativeSymbolOrAddress, nativeWrappedTokenSymbol } from '@0x/token-metadata';\nimport { addressUtils, BigNumber } from '@0x/utils';\nimport * as express from 'express';\nimport * as HttpStatus from 'http-status-codes';\nimport { Counter } from 'prom-client';\n\nimport { Integrator } from '../config';\nimport { schemas } from '../core/schemas';\nimport { GaslessSwapService } from '../services/GaslessSwapService';\nimport {\n    FetchFirmQuoteParams,\n    FetchIndicativeQuoteParams,\n    FetchQuoteParamsBase,\n    MetaTransactionV2,\n    SubmitMetaTransactionSignedQuoteParams,\n    SubmitMetaTransactionV2SignedQuoteParams,\n    SubmitRfqmSignedQuoteWithApprovalParams,\n} from '../services/types';\nimport {\n    ExecuteMetaTransactionEip712Context,\n    GaslessApprovalTypes,\n    GaslessTypes,\n    PermitEip712Context,\n} from '../core/types';\nimport { ConfigManager } from '../utils/config_manager';\nimport { HealthCheckResult, transformResultToShortResponse } from '../utils/rfqm_health_check';\nimport {\n    RawMetaTransactionFields,\n    RawOtcOrderFields,\n    StringSignatureFields,\n    stringsToEIP712Context,\n    stringsToMetaTransactionFields,\n    stringsToOtcOrderFields,\n    stringsToSignature,\n} from '../utils/rfqm_request_utils';\nimport { schemaUtils } from '../core/schema_utils';\nimport { TX_RELAY_V1_PATH, ZERO_G_PATH, ZERO_G_ALIAS_PATH } from '../core/constants';\n\n// Minimum slippage allowed. This value should be kept consistent with the value set in 0x-api\nconst MIN_ALLOWED_SLIPPAGE = 0.001; // 0.1%\n\n// If the cache is more milliseconds old than the value specified here, it will be refreshed.\nconst HEALTH_CHECK_RESULT_CACHE_DURATION_MS = 30000;\n\nconst ZEROG_GASLESS_SWAP_REQUEST = new Counter({\n    name: 'zerog_gasless_swap_request_total',\n    help: 'Number of requests of a gasless swap endpoint',\n    labelNames: ['chainId', 'integratorLabel', 'endpoint'],\n});\nconst ZEROG_GASLESS_SWAP_REQUEST_ERROR = new Counter({\n    name: 'zerog_gasless_swap_request_error',\n    help: 'Number of request errors of a gasless swap endpoint',\n    labelNames: ['chainId', 'integratorLabel', 'endpoint'],\n});\n\ntype HealthCheckResultCache = [HealthCheckResult, Date];\n\n/**\n * Logic to bridge Gasless Swap API requests to the `GaslessSwapService` and translate\n * results from the `GaslessSwapService` back to API responses.\n */\nexport class GaslessSwapHandlers {\n    private readonly _cachedHealthCheckResultByChainId = new Map<number, HealthCheckResultCache>();\n    constructor(\n        private readonly _gaslessSwapServices: Map<number, GaslessSwapService>,\n        private readonly _configManager: ConfigManager,\n    ) {}\n\n    /**\n     * Handler for the /price endpoint\n     */\n    public async getPriceAsync(req: express.Request, res: express.Response): Promise<void> {\n        const metaTransactionType = getMetaTransactionType(req.baseUrl);\n        const { chainId, params } = await this._parsePriceParamsAsync(req, metaTransactionType);\n        // Consistent with `rfqm_handlers`: not all requests are emitted if they fail parsing\n        ZEROG_GASLESS_SWAP_REQUEST.inc({\n            chainId,\n            integratorLabel: params.integrator.label,\n            endpoint: '/price',\n        });\n\n        let price;\n        try {\n            price = await this._getServiceForChain(chainId).fetchPriceAsync(params, metaTransactionType);\n        } catch (err) {\n            ZEROG_GASLESS_SWAP_REQUEST_ERROR.inc({\n                chainId,\n                integratorLabel: params.integrator.label,\n                endpoint: '/price',\n            });\n            throw err;\n        }\n\n        // Result\n        res.status(HttpStatus.OK).send({\n            liquidityAvailable: price !== null,\n            ...price,\n        });\n    }\n\n    /**\n     * Handler for the /quote endpoint\n     */\n    public async getQuoteAsync(req: express.Request, res: express.Response): Promise<void> {\n        const metaTransactionType = getMetaTransactionType(req.baseUrl);\n        // Parse request\n        const { chainId, params } = await this._parseFetchFirmQuoteParamsAsync(req, metaTransactionType);\n        // Consistent with `rfqm_handlers`: not all requests are emitted if they fail parsing\n        ZEROG_GASLESS_SWAP_REQUEST.inc({\n            chainId,\n            integratorLabel: params.integrator.label,\n            endpoint: '/quote',\n        });\n\n        let quote;\n        try {\n            quote = await this._getServiceForChain(chainId).fetchQuoteAsync(params, metaTransactionType);\n        } catch (err) {\n            ZEROG_GASLESS_SWAP_REQUEST_ERROR.inc({\n                chainId,\n                integratorLabel: params.integrator.label,\n                endpoint: '/quote',\n            });\n            throw err;\n        }\n        // Result\n        res.status(HttpStatus.OK).send({\n            liquidityAvailable: quote !== null,\n            ...quote,\n        });\n    }\n\n    /**\n     * Handler for the `/healthz` endpoint.\n     */\n    public async getHealthAsync(req: express.Request, res: express.Response): Promise<void> {\n        const chainId = extractChainId(req, this._gaslessSwapServices);\n        const cachedResult = this._cachedHealthCheckResultByChainId.get(chainId);\n        let result: HealthCheckResult;\n        if (!cachedResult) {\n            result = await this._getServiceForChain(chainId).runHealthCheckAsync();\n            this._cachedHealthCheckResultByChainId.set(chainId, [result, new Date()]);\n        } else {\n            const cacheAgeMs = Date.now() - cachedResult[1].getTime();\n            if (cacheAgeMs >= HEALTH_CHECK_RESULT_CACHE_DURATION_MS) {\n                result = await this._getServiceForChain(chainId).runHealthCheckAsync();\n                this._cachedHealthCheckResultByChainId.set(chainId, [result, new Date()]);\n            } else {\n                result = cachedResult[0];\n            }\n        }\n\n        const response = transformResultToShortResponse(result);\n        res.status(HttpStatus.OK).send(response);\n    }\n\n    /**\n     * Handler for the /status/:hash endpoint\n     */\n    public async getStatusAsync(req: express.Request, res: express.Response): Promise<void> {\n        const chainId = extractChainId(req, this._gaslessSwapServices);\n        const { hash } = req.params;\n\n        const status = await this._getServiceForChain(chainId).getStatusAsync(hash);\n\n        status ? res.status(HttpStatus.OK).send(status) : res.status(HttpStatus.NOT_FOUND).send();\n    }\n\n    /**\n     * Handler for the /submit endpoint\n     */\n    public async processSubmitAsync(req: express.Request, res: express.Response): Promise<void> {\n        const { chainId, integrator, params } = this._parseSubmitParams(req);\n        // Consistent with `rfqm_handlers`: not all requests are emitted if they fail parsing\n        ZEROG_GASLESS_SWAP_REQUEST.inc({\n            chainId,\n            integratorLabel: integrator.label,\n            endpoint: '/submit',\n        });\n\n        try {\n            const response = await this._getServiceForChain(chainId).processSubmitAsync(\n                params,\n                integrator.integratorId,\n            );\n            res.status(HttpStatus.CREATED).send(response);\n        } catch (err) {\n            ZEROG_GASLESS_SWAP_REQUEST_ERROR.inc({\n                chainId,\n                integratorLabel: integrator.label,\n                endpoint: '/submit',\n            });\n            req.log.error(err, 'Encountered an error while queuing a signed quote');\n            if (isAPIError(err)) {\n                throw err;\n            } else {\n                throw new InternalServerError(`An unexpected error occurred`);\n            }\n        }\n    }\n\n    private async _parseFetchFirmQuoteParamsAsync(\n        req: express.Request,\n        metaTransactionType: GaslessTypes,\n    ): Promise<{ chainId: number; params: FetchFirmQuoteParams }> {\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        schemaUtils.validateSchema(req.query, schemas.firmQuoteRequestSchema as any);\n        const takerAddress = req.query.takerAddress;\n        const shouldCheckApproval = req.query.checkApproval === 'true' ? true : false;\n        const { chainId, params } = await this._parseIndicativeAndFirmQuoteSharedParamsAsync(req, metaTransactionType);\n        if (!addressUtils.isAddress(takerAddress as string)) {\n            throw new ValidationError([\n                {\n                    field: 'takerAddress',\n                    code: ValidationErrorCodes.InvalidAddress,\n                    reason: `Must provide a valid takerAddress`,\n                },\n            ]);\n        }\n        return {\n            chainId,\n            params: {\n                ...params,\n                takerAddress: takerAddress as string,\n                checkApproval: shouldCheckApproval,\n            },\n        };\n    }\n\n    private _getServiceForChain(chainId: number): GaslessSwapService {\n        const service = this._gaslessSwapServices.get(chainId);\n\n        if (!service) {\n            throw new Error('No configuration exists for chain');\n        }\n        return service;\n    }\n\n    /**\n     * Examines the API key provided in the request, ensures it is valid for RFQM, and fetches the associated\n     * integrator ID.\n     */\n    private _validateApiKey(apiKey: string | undefined, chainId: number): { apiKey: string; integrator: Integrator } {\n        if (apiKey === undefined) {\n            throw new InvalidAPIKeyError('Must access with an API key');\n        }\n        if (!this._configManager.getRfqmApiKeyWhitelist().has(apiKey)) {\n            throw new InvalidAPIKeyError('API key not authorized for RFQM access');\n        }\n        const integratorId = this._configManager.getIntegratorIdForApiKey(apiKey);\n        if (!integratorId) {\n            // With a valid configuration this should never happen\n            throw new InvalidAPIKeyError('API key has no associated Integrator ID');\n        }\n        const integrator = this._configManager.getIntegratorByIdOrThrow(integratorId);\n        if (!integrator.allowedChainIds.includes(chainId)) {\n            throw new InvalidAPIKeyError(`API Key not authorized to access chain ${chainId}`);\n        }\n        return { apiKey, integrator };\n    }\n\n    private async _parsePriceParamsAsync(\n        req: express.Request,\n        metaTransactionType: GaslessTypes,\n    ): Promise<{ chainId: number; params: FetchIndicativeQuoteParams }> {\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        schemaUtils.validateSchema(req.query, schemas.indicativeQuoteRequestSchema as any);\n        const { takerAddress } = req.query;\n        const { chainId, params } = await this._parseIndicativeAndFirmQuoteSharedParamsAsync(req, metaTransactionType);\n\n        return {\n            chainId,\n            params: {\n                ...params,\n                takerAddress: takerAddress as string,\n            },\n        };\n    }\n\n    /**\n     * Parse shared params of indicative and firm quotes\n     */\n    private async _parseIndicativeAndFirmQuoteSharedParamsAsync(\n        req: express.Request,\n        metaTransactionType: GaslessTypes,\n    ): Promise<{ chainId: number; params: FetchQuoteParamsBase }> {\n        const chainId = extractChainId(req, this._gaslessSwapServices);\n        const { integrator } = this._validateApiKey(req.header('0x-api-key'), chainId);\n        const { affiliateAddress } = req.query;\n\n        // Parse tokens\n        const sellTokenRaw = req.query.sellToken as string;\n        const buyTokenRaw = req.query.buyToken as string;\n        validateNotNativeTokenOrThrow(sellTokenRaw, chainId, 'sellToken');\n\n        let buyTokenDecimals: number;\n        let sellTokenDecimals: number;\n        let buyTokenContractAddress: string;\n        let sellTokenContractAddress: string;\n\n        try {\n            buyTokenContractAddress = buyTokenRaw.toLocaleLowerCase().startsWith('0x')\n                ? buyTokenRaw\n                : contractAddressForSymbol(buyTokenRaw, chainId);\n            buyTokenDecimals = await this._getServiceForChain(chainId).getTokenDecimalsAsync(buyTokenRaw);\n        } catch (e) {\n            throw new ValidationError([\n                {\n                    field: 'buyToken',\n                    code: ValidationErrorCodes.AddressNotSupported,\n                    reason: `Token ${buyTokenRaw} is currently unsupported`,\n                },\n            ]);\n        }\n\n        try {\n            sellTokenContractAddress = sellTokenRaw.toLocaleLowerCase().startsWith('0x')\n                ? sellTokenRaw\n                : contractAddressForSymbol(sellTokenRaw, chainId);\n            sellTokenDecimals = await this._getServiceForChain(chainId).getTokenDecimalsAsync(sellTokenRaw);\n        } catch {\n            throw new ValidationError([\n                {\n                    field: 'sellToken',\n                    code: ValidationErrorCodes.AddressNotSupported,\n                    reason: `Token ${sellTokenRaw} is currently unsupported`,\n                },\n            ]);\n        }\n\n        // Parse number params\n        const sellAmount =\n            req.query.sellAmount === undefined ? undefined : new BigNumber(req.query.sellAmount as string);\n        const buyAmount = req.query.buyAmount === undefined ? undefined : new BigNumber(req.query.buyAmount as string);\n        const slippagePercentage =\n            req.query.slippagePercentage === undefined\n                ? undefined\n                : new BigNumber(req.query.slippagePercentage as string);\n\n        let feeType: 'volume' | undefined;\n        let feeSellTokenPercentage: BigNumber | undefined;\n        let feeRecipient: string | undefined;\n\n        if (metaTransactionType === GaslessTypes.MetaTransaction) {\n            if (slippagePercentage?.lt(MIN_ALLOWED_SLIPPAGE) || slippagePercentage?.gt(1)) {\n                throw new ValidationError([\n                    {\n                        field: 'slippagePercentage',\n                        code: ValidationErrorCodes.ValueOutOfRange,\n                        reason: `slippagePercentage ${slippagePercentage} is out of range`,\n                    },\n                ]);\n            }\n        } else if (metaTransactionType === GaslessTypes.MetaTransactionV2) {\n            // slippage percentage of tx relay v1 is on scale of 100 which is what percentage means (a fix from zero-g)\n            if (slippagePercentage?.lt(MIN_ALLOWED_SLIPPAGE * 100) || slippagePercentage?.gt(100)) {\n                throw new ValidationError([\n                    {\n                        field: 'slippagePercentage',\n                        code: ValidationErrorCodes.ValueOutOfRange,\n                        reason: `slippagePercentage ${slippagePercentage} is out of range`,\n                    },\n                ]);\n            }\n\n            if (req.query.feeType) {\n                if (req.query.feeType !== 'volume') {\n                    throw new ValidationError([\n                        {\n                            field: 'feeType',\n                            code: ValidationErrorCodes.IncorrectFormat,\n                            reason: `feeType ${req.query.feeType} is of wrong format`,\n                        },\n                    ]);\n                }\n\n                feeType = 'volume';\n                if (req.query.feeSellTokenPercentage === undefined) {\n                    throw new ValidationError([\n                        {\n                            field: 'feeSellTokenPercentage',\n                            code: ValidationErrorCodes.RequiredField,\n                            reason: `feeSellTokenPercentage is a required field when feeType ${feeType} is specified`,\n                        },\n                    ]);\n                }\n                feeSellTokenPercentage = new BigNumber(req.query.feeSellTokenPercentage as string);\n                if (feeSellTokenPercentage.lt(0) || feeSellTokenPercentage.gte(100)) {\n                    throw new ValidationError([\n                        {\n                            field: 'feeSellTokenPercentage',\n                            code: ValidationErrorCodes.ValueOutOfRange,\n                            reason: `feeSellTokenPercentage ${feeSellTokenPercentage} is out of range`,\n                        },\n                    ]);\n                }\n\n                if (req.query.feeRecipient === undefined) {\n                    throw new ValidationError([\n                        {\n                            field: 'feeRecipient',\n                            code: ValidationErrorCodes.RequiredField,\n                            reason: `feeRecipient is a required field when feeType ${feeType} is specified`,\n                        },\n                    ]);\n                }\n                feeRecipient = req.query.feeRecipient as string;\n            }\n        }\n\n        return {\n            chainId,\n            params: {\n                buyAmount,\n                buyToken: buyTokenContractAddress,\n                buyTokenDecimals,\n                integrator,\n                sellAmount,\n                sellToken: sellTokenContractAddress,\n                sellTokenDecimals,\n                affiliateAddress: affiliateAddress as string,\n                slippagePercentage,\n                feeType,\n                feeSellTokenPercentage,\n                feeRecipient,\n            },\n        };\n    }\n\n    private _parseSubmitParams<T extends ExecuteMetaTransactionEip712Context | PermitEip712Context>(\n        req: express.Request,\n    ): {\n        chainId: number;\n        integrator: Integrator;\n        params:\n            | SubmitRfqmSignedQuoteWithApprovalParams<T>\n            | SubmitMetaTransactionSignedQuoteParams<T>\n            | SubmitMetaTransactionV2SignedQuoteParams<T>;\n    } {\n        const chainId = extractChainId(req, this._gaslessSwapServices);\n        const { integrator } = this._validateApiKey(req.header('0x-api-key'), chainId);\n\n        const { approval, trade } = req.body;\n\n        const parsedParams: Partial<\n            SubmitRfqmSignedQuoteWithApprovalParams<T> | SubmitMetaTransactionSignedQuoteParams<T>\n        > = {};\n\n        // Parse approval params\n        if (approval) {\n            if (\n                approval.type === GaslessApprovalTypes.ExecuteMetaTransaction ||\n                approval.type === GaslessApprovalTypes.Permit\n            ) {\n                const eip712 = stringsToEIP712Context(approval.eip712) as T;\n                const signature = stringsToSignature(approval.signature as StringSignatureFields);\n                parsedParams.approval = {\n                    type: approval.type,\n                    eip712,\n                    signature,\n                };\n            } else {\n                throw new ValidationError([\n                    {\n                        field: 'approval',\n                        code: ValidationErrorCodes.FieldInvalid,\n                        reason: `${approval.type} is an invalid value for Approval 'type'`,\n                    },\n                ]);\n            }\n        }\n\n        // Parse trade params\n        if (trade.type === GaslessTypes.OtcOrder) {\n            const order = new OtcOrder(stringsToOtcOrderFields(trade.order as RawOtcOrderFields));\n            const signature = stringsToSignature(trade.signature as StringSignatureFields);\n            parsedParams.trade = {\n                type: trade.type,\n                order,\n                signature,\n            };\n        } else if (trade.type === GaslessTypes.MetaTransaction) {\n            const metaTransaction = new MetaTransaction(\n                stringsToMetaTransactionFields(trade.metaTransaction as RawMetaTransactionFields),\n            );\n            const signature = stringsToSignature(trade.signature as StringSignatureFields);\n            parsedParams.trade = {\n                type: trade.type,\n                metaTransaction,\n                signature,\n            };\n        } else if (trade.type === GaslessTypes.MetaTransactionV2) {\n            // TODO: This needs to be changed\n            const metaTransaction = new MetaTransactionV2(\n                stringsToMetaTransactionFields(trade.metaTransaction as RawMetaTransactionFields),\n            );\n            const signature = stringsToSignature(trade.signature as StringSignatureFields);\n            parsedParams.trade = {\n                type: trade.type,\n                metaTransaction,\n                signature,\n            };\n        } else {\n            throw new ValidationError([\n                {\n                    field: 'type',\n                    code: ValidationErrorCodes.FieldInvalid,\n                    reason: `${trade.type} is an invalid value for Trade 'type'`,\n                },\n            ]);\n        }\n\n        parsedParams.kind = trade.type;\n\n        return {\n            chainId,\n            integrator,\n            params: parsedParams as\n                | SubmitRfqmSignedQuoteWithApprovalParams<T>\n                | SubmitMetaTransactionSignedQuoteParams<T>\n                | SubmitMetaTransactionV2SignedQuoteParams<T>,\n        };\n    }\n}\n\n/**\n * Extracts the Chain Id from the request.\n *\n * Note that legacy RFQm defaulted to a chain ID of \"1\",\n * but that default has been removed for Gasless Swap.\n */\nfunction extractChainId(req: express.Request, services: Map<number, GaslessSwapService>): number {\n    const chainIdFromHeader = req.header('0x-chain-id');\n    if (chainIdFromHeader === undefined) {\n        throw new ValidationError([\n            {\n                field: '0x-chain-id',\n                code: ValidationErrorCodes.FieldInvalid,\n                reason: 'Request must include a chain ID header',\n            },\n        ]);\n    }\n    const chainId = parseInt(chainIdFromHeader, 10);\n    if (Number.isNaN(chainId)) {\n        throw new ValidationError([\n            {\n                field: '0x-chain-id',\n                code: ValidationErrorCodes.FieldInvalid,\n                reason: 'Invalid chain id',\n            },\n        ]);\n    }\n\n    if (!services.has(chainId)) {\n        throw new ValidationError([\n            {\n                field: '0x-chain-id',\n                code: ValidationErrorCodes.FieldInvalid,\n                reason: 'Service unavailable on specified chain',\n            },\n        ]);\n    }\n    return chainId;\n}\n\n/**\n * Gets the token address for a given symbol.\n *\n * Throws if the symbol is not present in @0x/token-metadata\n */\nfunction contractAddressForSymbol(symbol: string, chainId: number): string {\n    const address = getTokenMetadataIfExists(symbol, chainId)?.tokenAddress;\n    if (!address) {\n        throw new Error('Unsupported token');\n    }\n    return address;\n}\n\nfunction validateNotNativeTokenOrThrow(token: string, chainId: number, field: string): boolean {\n    if (isNativeSymbolOrAddress(token, chainId)) {\n        const symbol = nativeWrappedTokenSymbol(chainId);\n        throw new ValidationError([\n            {\n                field,\n                code: ValidationErrorCodes.TokenNotSupported,\n                reason: `Unwrapped Native Asset is not supported. Use ${symbol} instead`,\n            },\n        ]);\n    }\n\n    return true;\n}\n\n/**\n * Get the meta-transaction type to pass to service.\n */\nfunction getMetaTransactionType(baseURL: string): GaslessTypes {\n    if (ZERO_G_PATH.includes(baseURL) || ZERO_G_ALIAS_PATH.includes(baseURL)) {\n        return GaslessTypes.MetaTransaction;\n    }\n    if (TX_RELAY_V1_PATH.includes(baseURL)) {\n        return GaslessTypes.MetaTransactionV2;\n    }\n\n    // This should never happen\n    throw new Error('Unknown gasless base URL');\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/GaslessSwapService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_health_check.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_request_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/chain_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/chain_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/fee_model_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/fee_model_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/firm_quote_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/indicative_otc_quote_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/indicative_quote_request_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/integrators_acl_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/integrator_acl_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/rfq_maker_config.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/rfq_maker_config_list.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/sign_response_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configurations_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configuration_schema.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/zero_ex_fee_configuration_entry.json","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/MetaTransactionClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/meta_transaction_fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/services/GaslessSwapService.test.ts",{"fileContent":"// tslint:disable: max-file-line-count\nimport { ValidationError, ValidationErrorCodes } from '@0x/api-utils';\nimport { AssetSwapperContractAddresses as ContractAddresses, SupportedProvider } from '@0x/asset-swapper';\nimport { ethSignHashWithKey, MetaTransaction, OtcOrder, SignatureType } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { AxiosInstance } from 'axios';\nimport { providers } from 'ethers';\nimport Redis from 'ioredis';\nimport { Producer } from 'sqs-producer';\nimport { Connection } from 'typeorm';\n\nimport { Integrator } from '../../src/config';\nimport { DEFAULT_MIN_EXPIRY_DURATION_MS, ZERO } from '../../src/core/constants';\nimport { MetaTransactionJobEntity } from '../../src/entities';\nimport { RfqmJobStatus } from '../../src/entities/types';\nimport { GaslessSwapService } from '../../src/services/GaslessSwapService';\nimport { FeeService } from '../../src/services/fee_service';\nimport { RfqmService } from '../../src/services/rfqm_service';\nimport { RfqMakerBalanceCacheService } from '../../src/services/rfq_maker_balance_cache_service';\nimport {\n    ApprovalResponse,\n    FetchIndicativeQuoteResponse,\n    LiquiditySource,\n    MetaTransactionV1QuoteResponse,\n    MetaTransactionV2QuoteResponse,\n    MetaTransactionV2,\n    OtcOrderRfqmQuoteResponse,\n} from '../../src/services/types';\nimport { BalanceChecker } from '../../src/utils/balance_checker';\nimport { CacheClient } from '../../src/utils/cache_client';\nimport { getV1QuoteAsync, getV2QuoteAsync } from '../../src/utils/MetaTransactionClient';\nimport { QuoteServerClient } from '../../src/utils/quote_server_client';\nimport { RfqmDbUtils } from '../../src/utils/rfqm_db_utils';\nimport { RfqBlockchainUtils } from '../../src/utils/rfq_blockchain_utils';\nimport { RfqMakerManager } from '../../src/utils/rfq_maker_manager';\nimport { TokenMetadataManager } from '../../src/utils/TokenMetadataManager';\nimport { GaslessTypes } from '../../src/core/types';\nimport { Fees } from '../../src/core/types/meta_transaction_fees';\n\njest.mock('../../src/services/rfqm_service', () => {\n    return {\n        RfqmService: jest.fn().mockImplementation(() => {\n            return {\n                fetchFirmQuoteAsync: jest.fn(),\n                fetchIndicativeQuoteAsync: jest.fn(),\n                getGaslessApprovalResponseAsync: jest.fn(),\n            };\n        }),\n    };\n});\n\njest.mock('../../src/utils/MetaTransactionClient', () => {\n    return {\n        getV1QuoteAsync: jest.fn(),\n        getV2QuoteAsync: jest.fn(),\n    };\n});\n\njest.mock('../../src/utils/rfq_blockchain_utils', () => {\n    return {\n        RfqBlockchainUtils: jest.fn().mockImplementation(() => {\n            return {\n                getTokenBalancesAsync: jest.fn(),\n                getMinOfBalancesAndAllowancesAsync: jest.fn(),\n                getExchangeProxyAddress: jest.fn(),\n            };\n        }),\n    };\n});\n\njest.mock('../../src/utils/rfqm_db_utils', () => {\n    return {\n        RfqmDbUtils: jest.fn().mockImplementation(() => {\n            return {\n                findMetaTransactionJobsWithStatusesAsync: jest.fn().mockResolvedValue([]),\n                writeMetaTransactionJobAsync: jest.fn(),\n            };\n        }),\n    };\n});\n\njest.mock('ioredis', () => {\n    return {\n        default: jest.fn().mockImplementation(() => {\n            return {\n                set: jest.fn(),\n                get: jest.fn(),\n            };\n        }),\n    };\n});\n\njest.mock('sqs-producer', () => {\n    return {\n        Producer: jest.fn().mockImplementation(() => {\n            return {\n                send: jest.fn(),\n            };\n        }),\n    };\n});\n\n// tslint:disable: no-object-literal-type-assertion\nconst getMetaTransactionV1QuoteAsyncMock = getV1QuoteAsync as jest.Mock<\n    ReturnType<typeof getV1QuoteAsync>,\n    Parameters<typeof getV1QuoteAsync>\n>;\nconst getMetaTransactionV2QuoteAsyncMock = getV2QuoteAsync as jest.Mock<\n    ReturnType<typeof getV2QuoteAsync>,\n    Parameters<typeof getV2QuoteAsync>\n>;\nconst mockSqsProducer = jest.mocked(new Producer({}));\nconst mockDbUtils = jest.mocked(new RfqmDbUtils({} as Connection));\nconst mockBlockchainUtils = jest.mocked(\n    new RfqBlockchainUtils({} as SupportedProvider, '0xdefi', {} as BalanceChecker, {} as providers.JsonRpcProvider),\n);\n\nconst mockRfqmService = jest.mocked(\n    new RfqmService(\n        0,\n        {} as FeeService,\n        0,\n        {} as ContractAddresses,\n        '0x0',\n        {} as RfqBlockchainUtils,\n        {} as RfqmDbUtils,\n        {} as Producer,\n        {} as QuoteServerClient,\n        DEFAULT_MIN_EXPIRY_DURATION_MS,\n        {} as CacheClient,\n        {} as RfqMakerBalanceCacheService,\n        {} as RfqMakerManager,\n        {} as TokenMetadataManager,\n    ),\n);\n\nconst mockRedis = jest.mocked(new Redis());\n\nconst gaslessSwapService = new GaslessSwapService(\n    /* chainId */ 1337, // tslint:disable-line: custom-no-magic-numbers\n    mockRfqmService,\n    new URL('https://hokiesports.com/quote'),\n    {} as AxiosInstance,\n    mockRedis,\n    mockDbUtils,\n    mockBlockchainUtils,\n    mockSqsProducer,\n);\n\ndescribe('GaslessSwapService', () => {\n    const takerPrivateKey = '0xd2c2349e10170e4219d9febd1c663ea5c7334f79c38d25f4f52c85af796c7c05';\n    const integratorAddress = '0x4ea754349ace5303c82f0d1d491041e042f2ad22';\n    const zeroExAddress = '0x4ea754349ace5303c82f0d1d491041e042f2ad22';\n    const metaTransactionV1 = new MetaTransaction({\n        callData:\n            '0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000017b9e2a304f00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac18858000000000000000000000000000000000000000000000000000000039d0b9efd1000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001c94ebec37000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001db5156c13000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e69737761705633000000000000000000000000000000000000000000000000000000000000190522016f044a05b0000000000000000000000000000000000000000000000000000000b08217af9400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000000c829100b78224ef50000000000000000000000000000000000000000000000000000000570157389f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c6300000000000000000000000000000000000000000000005b89d96b4863067a6b',\n        chainId: 137,\n        verifyingContract: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n        expirationTimeSeconds: new BigNumber('9990868679'),\n        feeAmount: new BigNumber(0),\n        feeToken: '0x0000000000000000000000000000000000000000',\n        maxGasPrice: new BigNumber(4294967296),\n        minGasPrice: new BigNumber(1),\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-loss-of-precision\n        salt: new BigNumber(32606650794224189614795510724011106220035660490560169776986607186708081701146),\n        sender: '0x0000000000000000000000000000000000000000',\n        signer: '0x4c42a706410f1190f97d26fe3c999c90070aa40f',\n        value: new BigNumber(0),\n    });\n    // TODO: This needs to be updated to the new meta-transaction type when smart contract changes are finished and corresponding types are published in packages\n    const metaTransactionV2 = new MetaTransactionV2({\n        callData:\n            '0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000017b9e2a304f00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac18858000000000000000000000000000000000000000000000000000000039d0b9efd1000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001c94ebec37000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001db5156c13000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e69737761705633000000000000000000000000000000000000000000000000000000000000190522016f044a05b0000000000000000000000000000000000000000000000000000000b08217af9400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000000c829100b78224ef50000000000000000000000000000000000000000000000000000000570157389f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c6300000000000000000000000000000000000000000000005b89d96b4863067a6b',\n        chainId: 137,\n        verifyingContract: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n        expirationTimeSeconds: new BigNumber('9990868679'),\n        feeAmount: new BigNumber(0),\n        feeToken: '0x0000000000000000000000000000000000000000',\n        maxGasPrice: new BigNumber(4294967296),\n        minGasPrice: new BigNumber(1),\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-loss-of-precision\n        salt: new BigNumber(32606650794224189614795510724011106220035660490560169776986607186708081701146),\n        sender: '0x0000000000000000000000000000000000000000',\n        signer: '0x4c42a706410f1190f97d26fe3c999c90070aa40f',\n        value: new BigNumber(0),\n    });\n    const price: FetchIndicativeQuoteResponse = {\n        allowanceTarget: '0x12345',\n        buyAmount: new BigNumber(1800054805473),\n        sellAmount: new BigNumber(1000000000000000000000),\n        buyTokenAddress: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n        sellTokenAddress: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n        gas: new BigNumber(1043459),\n        price: new BigNumber(1800.054805),\n    };\n    const sources: LiquiditySource[] = [\n        {\n            name: 'QuickSwap',\n            proportion: new BigNumber('0.2308'),\n        },\n        {\n            name: 'DODO_V2',\n            proportion: new BigNumber('0.07692'),\n        },\n        {\n            name: 'Uniswap_V3',\n            proportion: new BigNumber('0.6923'),\n        },\n    ];\n    const fees: Fees = {\n        integratorFee: {\n            type: 'volume',\n            feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n            feeAmount: new BigNumber(1000000000000000000),\n            feeRecipient: integratorAddress,\n            billingType: 'on-chain',\n            volumePercentage: new BigNumber(0.1),\n        },\n        zeroExFee: {\n            type: 'integrator_share',\n            feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n            feeAmount: new BigNumber(1000000000000000),\n            feeRecipient: zeroExAddress,\n            billingType: 'on-chain',\n            integratorSharePercentage: new BigNumber(0.1),\n        },\n        gasFee: {\n            type: 'gas',\n            gasPrice: new BigNumber(115200000000),\n            feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n            feeAmount: new BigNumber(10000000),\n            feeRecipient: null,\n            billingType: 'off-chain',\n            estimatedGas: new BigNumber(1043459),\n            feeTokenAmountPerBaseUnitNativeToken: new BigNumber(0.001),\n        },\n    };\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    // eslint-disable-next-line @typescript-eslint/no-loss-of-precision\n    const expiry = new BigNumber(9999999999999999); // tslint:disable-line custom-no-magic-numbers\n    const otcOrder = new OtcOrder({\n        txOrigin: '0x0000000000000000000000000000000000000000',\n        taker: '0x1111111111111111111111111111111111111111',\n        maker: '0x2222222222222222222222222222222222222222',\n        makerToken: '0x3333333333333333333333333333333333333333',\n        takerToken: '0x4444444444444444444444444444444444444444',\n        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(expiry, ZERO, expiry),\n        chainId: 1337,\n        verifyingContract: '0x0000000000000000000000000000000000000000',\n    });\n    const otcQuote: OtcOrderRfqmQuoteResponse = {\n        allowanceTarget: '0x12345',\n        buyAmount: new BigNumber(1800054805473),\n        sellAmount: new BigNumber(1000000000000000000000),\n        buyTokenAddress: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n        sellTokenAddress: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n        gas: new BigNumber(1043459),\n        price: new BigNumber(1800.054805),\n        type: GaslessTypes.OtcOrder,\n        order: otcOrder,\n        orderHash: otcOrder.getHash(),\n    };\n\n    beforeEach(() => {\n        mockBlockchainUtils.getExchangeProxyAddress.mockReturnValue('0x12345');\n        jest.clearAllMocks();\n    });\n\n    describe('fetchPriceAsync', () => {\n        describe('zero-g', () => {\n            it('gets an RFQ price if available', async () => {\n                mockRfqmService.fetchIndicativeQuoteAsync.mockResolvedValueOnce(price);\n\n                const result = (await gaslessSwapService.fetchPriceAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                    },\n                    GaslessTypes.MetaTransaction,\n                )) as FetchIndicativeQuoteResponse & { liquiditySource: 'rfq' | 'amm' };\n\n                expect(result?.liquiditySource).toEqual('rfq');\n                expect(result).toMatchInlineSnapshot(`\n                    Object {\n                      \"allowanceTarget\": \"0x12345\",\n                      \"buyAmount\": \"1800054805473\",\n                      \"buyTokenAddress\": \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n                      \"gas\": \"1043459\",\n                      \"liquiditySource\": \"rfq\",\n                      \"price\": \"1800.054805\",\n                      \"sellAmount\": \"1000000000000000000000\",\n                      \"sellTokenAddress\": \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\",\n                    }\n                `);\n                expect(getMetaTransactionV1QuoteAsyncMock).not.toBeCalled();\n            });\n\n            it('gets an AMM price if no RFQ liquidity is available', async () => {\n                getMetaTransactionV1QuoteAsyncMock.mockResolvedValueOnce({\n                    trade: {\n                        kind: GaslessTypes.MetaTransaction,\n                        hash: metaTransactionV1.getHash(),\n                        metaTransaction: metaTransactionV1,\n                    },\n                    price,\n                });\n                mockRfqmService.fetchIndicativeQuoteAsync.mockResolvedValueOnce(null);\n\n                const result = (await gaslessSwapService.fetchPriceAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                    },\n                    GaslessTypes.MetaTransaction,\n                )) as FetchIndicativeQuoteResponse & { liquiditySource: 'rfq' | 'amm' };\n\n                expect(result?.liquiditySource).toEqual('amm');\n                expect(result).toMatchInlineSnapshot(`\n                    Object {\n                      \"allowanceTarget\": \"0x12345\",\n                      \"buyAmount\": \"1800054805473\",\n                      \"buyTokenAddress\": \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n                      \"gas\": \"1043459\",\n                      \"liquiditySource\": \"amm\",\n                      \"price\": \"1800.054805\",\n                      \"sellAmount\": \"1000000000000000000000\",\n                      \"sellTokenAddress\": \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\",\n                    }\n                `);\n            });\n\n            it('gets an AMM price if RFQ request throws', async () => {\n                getMetaTransactionV1QuoteAsyncMock.mockResolvedValueOnce({\n                    trade: {\n                        kind: GaslessTypes.MetaTransaction,\n                        hash: metaTransactionV1.getHash(),\n                        metaTransaction: metaTransactionV1,\n                    },\n                    price,\n                });\n                mockRfqmService.fetchIndicativeQuoteAsync.mockImplementationOnce(() => {\n                    throw new Error('rfqm quote threw up');\n                });\n\n                const result = (await gaslessSwapService.fetchPriceAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                    },\n                    GaslessTypes.MetaTransaction,\n                )) as FetchIndicativeQuoteResponse & { liquiditySource: 'rfq' | 'amm' };\n\n                expect(result?.liquiditySource).toEqual('amm');\n                expect(result).toMatchInlineSnapshot(`\n                    Object {\n                      \"allowanceTarget\": \"0x12345\",\n                      \"buyAmount\": \"1800054805473\",\n                      \"buyTokenAddress\": \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n                      \"gas\": \"1043459\",\n                      \"liquiditySource\": \"amm\",\n                      \"price\": \"1800.054805\",\n                      \"sellAmount\": \"1000000000000000000000\",\n                      \"sellTokenAddress\": \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\",\n                    }\n                `);\n            });\n\n            it('returns `null` if no liquidity is available', async () => {\n                getMetaTransactionV1QuoteAsyncMock.mockResolvedValueOnce(null);\n                mockRfqmService.fetchIndicativeQuoteAsync.mockResolvedValueOnce(null);\n\n                const result = await gaslessSwapService.fetchPriceAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                    },\n                    GaslessTypes.MetaTransaction,\n                );\n\n                expect(result).toBeNull();\n            });\n\n            it('throws if AMM request throws and RFQ has no liquidity / request throws', async () => {\n                mockRfqmService.fetchIndicativeQuoteAsync.mockImplementationOnce(() => {\n                    throw new Error('rfqm price threw up');\n                });\n                getMetaTransactionV1QuoteAsyncMock.mockImplementationOnce(() => {\n                    throw new Error('amm price threw up');\n                });\n\n                await expect(() =>\n                    gaslessSwapService.fetchPriceAsync(\n                        {\n                            buyAmount: new BigNumber(1800054805473),\n                            buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                            buyTokenDecimals: 6,\n                            integrator: {} as Integrator,\n                            sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                            sellTokenDecimals: 18,\n                        },\n                        GaslessTypes.MetaTransaction,\n                    ),\n                ).rejects.toThrow('Error fetching price');\n            });\n\n            it('throws validation error if AMM quote throws validation error', async () => {\n                getMetaTransactionV1QuoteAsyncMock.mockImplementation(() => {\n                    throw new ValidationError([\n                        {\n                            field: 'sellAmount',\n                            code: ValidationErrorCodes.FieldInvalid,\n                            reason: 'sellAmount too small',\n                        },\n                    ]);\n                });\n                mockRfqmService.fetchFirmQuoteAsync.mockResolvedValue({ quote: null, quoteReportId: null });\n\n                await expect(() =>\n                    gaslessSwapService.fetchPriceAsync(\n                        {\n                            buyAmount: new BigNumber(1800054805473),\n                            buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                            buyTokenDecimals: 6,\n                            integrator: {} as Integrator,\n                            sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                            sellTokenDecimals: 18,\n                            takerAddress: '0xtaker',\n                        },\n                        GaslessTypes.MetaTransaction,\n                    ),\n                ).rejects.toThrow(ValidationError);\n            });\n        });\n\n        describe('tx relay v1', () => {\n            it('gets a meta-transaction price', async () => {\n                getMetaTransactionV2QuoteAsyncMock.mockResolvedValueOnce({\n                    trade: {\n                        kind: GaslessTypes.MetaTransaction,\n                        hash: metaTransactionV1.getHash(),\n                        metaTransaction: metaTransactionV1,\n                    },\n                    price,\n                    sources,\n                    fees,\n                });\n                mockRfqmService.fetchIndicativeQuoteAsync.mockResolvedValueOnce(null);\n\n                const result = (await gaslessSwapService.fetchPriceAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        feeType: 'volume',\n                        feeRecipient: integratorAddress,\n                        feeSellTokenPercentage: new BigNumber(0.1),\n                    },\n                    GaslessTypes.MetaTransactionV2,\n                )) as FetchIndicativeQuoteResponse & { sources: LiquiditySource[]; fees?: Fees };\n\n                expect(result).toMatchInlineSnapshot(`\n                    Object {\n                      \"allowanceTarget\": \"0x12345\",\n                      \"buyAmount\": \"1800054805473\",\n                      \"buyTokenAddress\": \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n                      \"fees\": Object {\n                        \"gasFee\": Object {\n                          \"feeAmount\": \"10000000\",\n                          \"feeToken\": \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\",\n                          \"feeType\": \"gas\",\n                        },\n                        \"integratorFee\": Object {\n                          \"feeAmount\": \"1000000000000000000\",\n                          \"feeToken\": \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\",\n                          \"feeType\": \"volume\",\n                        },\n                        \"zeroExFee\": Object {\n                          \"feeAmount\": \"1000000000000000\",\n                          \"feeToken\": \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\",\n                          \"feeType\": \"integrator_share\",\n                        },\n                      },\n                      \"gas\": \"1043459\",\n                      \"price\": \"1800.054805\",\n                      \"sellAmount\": \"1000000000000000000000\",\n                      \"sellTokenAddress\": \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\",\n                      \"sources\": Array [\n                        Object {\n                          \"name\": \"QuickSwap\",\n                          \"proportion\": \"0.2308\",\n                        },\n                        Object {\n                          \"name\": \"DODO_V2\",\n                          \"proportion\": \"0.07692\",\n                        },\n                        Object {\n                          \"name\": \"Uniswap_V3\",\n                          \"proportion\": \"0.6923\",\n                        },\n                      ],\n                    }\n                `);\n            });\n\n            it('returns `null` if no liquidity is available', async () => {\n                getMetaTransactionV2QuoteAsyncMock.mockResolvedValueOnce(null);\n\n                const result = await gaslessSwapService.fetchPriceAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        feeType: 'volume',\n                        feeRecipient: integratorAddress,\n                        feeSellTokenPercentage: new BigNumber(0.1),\n                    },\n                    GaslessTypes.MetaTransactionV2,\n                );\n\n                expect(result).toBeNull();\n            });\n\n            it('throws if meta-transaction request throws', async () => {\n                getMetaTransactionV2QuoteAsyncMock.mockImplementationOnce(() => {\n                    throw new Error('meta-transaction price throws');\n                });\n\n                await expect(() =>\n                    gaslessSwapService.fetchPriceAsync(\n                        {\n                            buyAmount: new BigNumber(1800054805473),\n                            buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                            buyTokenDecimals: 6,\n                            integrator: {} as Integrator,\n                            sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                            sellTokenDecimals: 18,\n                            feeType: 'volume',\n                            feeRecipient: integratorAddress,\n                            feeSellTokenPercentage: new BigNumber(0.1),\n                        },\n                        GaslessTypes.MetaTransactionV2,\n                    ),\n                ).rejects.toThrow('Error fetching price');\n            });\n\n            it('throws validation error if meta-transaction v2 quote throws validation error', async () => {\n                getMetaTransactionV2QuoteAsyncMock.mockImplementation(() => {\n                    throw new ValidationError([\n                        {\n                            field: 'sellAmount',\n                            code: ValidationErrorCodes.FieldInvalid,\n                            reason: 'sellAmount too small',\n                        },\n                    ]);\n                });\n\n                await expect(() =>\n                    gaslessSwapService.fetchPriceAsync(\n                        {\n                            buyAmount: new BigNumber(1800054805473),\n                            buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                            buyTokenDecimals: 6,\n                            integrator: {} as Integrator,\n                            sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                            sellTokenDecimals: 18,\n                            takerAddress: '0xtaker',\n                            feeType: 'volume',\n                            feeRecipient: integratorAddress,\n                            feeSellTokenPercentage: new BigNumber(0.1),\n                        },\n                        GaslessTypes.MetaTransactionV2,\n                    ),\n                ).rejects.toThrow(ValidationError);\n            });\n        });\n    });\n\n    describe('fetchQuoteAsync', () => {\n        describe('zero-g', () => {\n            it('gets an RFQ quote if available', async () => {\n                mockRfqmService.fetchFirmQuoteAsync.mockResolvedValueOnce({ quote: otcQuote, quoteReportId: null });\n\n                const result = (await gaslessSwapService.fetchQuoteAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        takerAddress: '0xtaker',\n                        checkApproval: false,\n                    },\n                    GaslessTypes.MetaTransaction,\n                )) as OtcOrderRfqmQuoteResponse & { liquiditySource: 'rfq' | 'amm' };\n\n                expect(result).not.toBeNull();\n                expect(result?.type).toEqual(GaslessTypes.OtcOrder);\n                expect(result).toMatchInlineSnapshot(`\n                    Object {\n                      \"allowanceTarget\": \"0x12345\",\n                      \"buyAmount\": \"1800054805473\",\n                      \"buyTokenAddress\": \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n                      \"gas\": \"1043459\",\n                      \"liquiditySource\": \"rfq\",\n                      \"order\": OtcOrder {\n                        \"chainId\": 1337,\n                        \"expiry\": \"10000000000000000\",\n                        \"expiryAndNonce\": \"62771017353866807638357894232076664161023554444640345128970000000000000000\",\n                        \"maker\": \"0x2222222222222222222222222222222222222222\",\n                        \"makerAmount\": \"0\",\n                        \"makerToken\": \"0x3333333333333333333333333333333333333333\",\n                        \"nonce\": \"10000000000000000\",\n                        \"nonceBucket\": \"0\",\n                        \"taker\": \"0x1111111111111111111111111111111111111111\",\n                        \"takerAmount\": \"0\",\n                        \"takerToken\": \"0x4444444444444444444444444444444444444444\",\n                        \"txOrigin\": \"0x0000000000000000000000000000000000000000\",\n                        \"verifyingContract\": \"0x0000000000000000000000000000000000000000\",\n                      },\n                      \"orderHash\": \"0x69b784087387d37e2361a40146420a5a68b08375238a5ba0329f612d5673b2ea\",\n                      \"price\": \"1800.054805\",\n                      \"sellAmount\": \"1000000000000000000000\",\n                      \"sellTokenAddress\": \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\",\n                      \"type\": \"otc\",\n                    }\n                `);\n                expect(getMetaTransactionV1QuoteAsyncMock).not.toBeCalled();\n            });\n\n            it('gets an AMM quote if no RFQ liquidity is available', async () => {\n                getMetaTransactionV1QuoteAsyncMock.mockResolvedValueOnce({\n                    trade: {\n                        kind: GaslessTypes.MetaTransaction,\n                        hash: metaTransactionV1.getHash(),\n                        metaTransaction: metaTransactionV1,\n                    },\n                    price,\n                });\n                mockRfqmService.fetchFirmQuoteAsync.mockResolvedValueOnce({ quote: null, quoteReportId: null });\n\n                const result = (await gaslessSwapService.fetchQuoteAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        takerAddress: '0xtaker',\n                        checkApproval: false,\n                    },\n                    GaslessTypes.MetaTransaction,\n                )) as MetaTransactionV1QuoteResponse & { liquiditySource: 'rfq' | 'amm' };\n\n                expect(result).not.toBeNull();\n                expect(result?.type).toEqual(GaslessTypes.MetaTransaction);\n                if (result?.type !== GaslessTypes.MetaTransaction) {\n                    // Refine type for further assertions\n                    throw new Error('Result should be a meta transaction');\n                }\n                expect(result.metaTransaction.getHash()).toEqual(metaTransactionV1.getHash());\n                expect(result).toMatchInlineSnapshot(`\n                    Object {\n                      \"allowanceTarget\": \"0x12345\",\n                      \"approval\": undefined,\n                      \"buyAmount\": \"1800054805473\",\n                      \"buyTokenAddress\": \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n                      \"gas\": \"1043459\",\n                      \"liquiditySource\": \"amm\",\n                      \"metaTransaction\": MetaTransaction {\n                        \"callData\": \"0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000017b9e2a304f00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac18858000000000000000000000000000000000000000000000000000000039d0b9efd1000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001c94ebec37000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001db5156c13000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e69737761705633000000000000000000000000000000000000000000000000000000000000190522016f044a05b0000000000000000000000000000000000000000000000000000000b08217af9400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000000c829100b78224ef50000000000000000000000000000000000000000000000000000000570157389f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c6300000000000000000000000000000000000000000000005b89d96b4863067a6b\",\n                        \"chainId\": 137,\n                        \"expirationTimeSeconds\": \"9990868679\",\n                        \"feeAmount\": \"0\",\n                        \"feeToken\": \"0x0000000000000000000000000000000000000000\",\n                        \"maxGasPrice\": \"4294967296\",\n                        \"minGasPrice\": \"1\",\n                        \"salt\": \"32606650794224190000000000000000000000000000000000000000000000000000000000000\",\n                        \"sender\": \"0x0000000000000000000000000000000000000000\",\n                        \"signer\": \"0x4c42a706410f1190f97d26fe3c999c90070aa40f\",\n                        \"value\": \"0\",\n                        \"verifyingContract\": \"0xdef1c0ded9bec7f1a1670819833240f027b25eff\",\n                      },\n                      \"metaTransactionHash\": \"0xde5a11983edd012047dd3107532f007a73ae488bfb354f35b8a40580e2a775a1\",\n                      \"price\": \"1800.054805\",\n                      \"sellAmount\": \"1000000000000000000000\",\n                      \"sellTokenAddress\": \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\",\n                      \"type\": \"metatransaction\",\n                    }\n                `);\n            });\n\n            it('throws validation error if AMM quote throws validation error', async () => {\n                getMetaTransactionV1QuoteAsyncMock.mockImplementation(() => {\n                    throw new ValidationError([\n                        {\n                            field: 'sellAmount',\n                            code: ValidationErrorCodes.FieldInvalid,\n                            reason: 'sellAmount too small',\n                        },\n                    ]);\n                });\n                mockRfqmService.fetchFirmQuoteAsync.mockResolvedValue({ quote: null, quoteReportId: null });\n\n                await expect(() =>\n                    gaslessSwapService.fetchQuoteAsync(\n                        {\n                            buyAmount: new BigNumber(1800054805473),\n                            buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                            buyTokenDecimals: 6,\n                            integrator: {} as Integrator,\n                            sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                            sellTokenDecimals: 18,\n                            takerAddress: '0xtaker',\n                            checkApproval: false,\n                        },\n                        GaslessTypes.MetaTransaction,\n                    ),\n                ).rejects.toThrow(ValidationError);\n            });\n\n            it('adds an affiliate address if one is included in the integrator configuration but not in the quote request', async () => {\n                getMetaTransactionV1QuoteAsyncMock.mockResolvedValueOnce({\n                    trade: {\n                        kind: GaslessTypes.MetaTransaction,\n                        hash: metaTransactionV1.getHash(),\n                        metaTransaction: metaTransactionV1,\n                    },\n                    price,\n                });\n                mockRfqmService.fetchFirmQuoteAsync.mockResolvedValueOnce({ quote: null, quoteReportId: null });\n\n                await gaslessSwapService.fetchQuoteAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: { affiliateAddress: '0xaffiliateAddress' } as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        takerAddress: '0xtaker',\n                        checkApproval: false,\n                    },\n                    GaslessTypes.MetaTransaction,\n                );\n                expect(getMetaTransactionV1QuoteAsyncMock.mock.calls[0][/* params */ 2]['affiliateAddress']).toEqual(\n                    '0xaffiliateAddress',\n                );\n            });\n\n            it('uses the affiliate address in the quote request even if one is present in integrator configuration', async () => {\n                getMetaTransactionV1QuoteAsyncMock.mockResolvedValueOnce({\n                    trade: {\n                        kind: GaslessTypes.MetaTransaction,\n                        hash: metaTransactionV1.getHash(),\n                        metaTransaction: metaTransactionV1,\n                    },\n                    price,\n                });\n                mockRfqmService.fetchFirmQuoteAsync.mockResolvedValueOnce({ quote: null, quoteReportId: null });\n\n                await gaslessSwapService.fetchQuoteAsync(\n                    {\n                        affiliateAddress: '0xaffiliateAddressShouldUse',\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: { affiliateAddress: '0xaffiliateAddressShouldntUse' } as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        takerAddress: '0xtaker',\n                        checkApproval: false,\n                    },\n                    GaslessTypes.MetaTransaction,\n                );\n                expect(getMetaTransactionV1QuoteAsyncMock.mock.calls[0][/* params */ 2]['affiliateAddress']).toEqual(\n                    '0xaffiliateAddressShouldUse',\n                );\n            });\n\n            it('returns `null` if no liquidity is available', async () => {\n                mockRfqmService.fetchFirmQuoteAsync.mockResolvedValueOnce({ quote: null, quoteReportId: null });\n                getMetaTransactionV1QuoteAsyncMock.mockResolvedValueOnce(null);\n\n                const result = await gaslessSwapService.fetchQuoteAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        takerAddress: '0xtaker',\n                        checkApproval: false,\n                    },\n                    GaslessTypes.MetaTransaction,\n                );\n\n                expect(result).toBeNull();\n            });\n\n            it('throws if AMM request throws and RFQ has no liquidity / request throws', async () => {\n                mockRfqmService.fetchFirmQuoteAsync.mockImplementationOnce(() => {\n                    throw new Error('rfqm price threw up');\n                });\n                getMetaTransactionV1QuoteAsyncMock.mockImplementationOnce(() => {\n                    throw new Error('amm price threw up');\n                });\n\n                await expect(() =>\n                    gaslessSwapService.fetchQuoteAsync(\n                        {\n                            buyAmount: new BigNumber(1800054805473),\n                            buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                            buyTokenDecimals: 6,\n                            integrator: {} as Integrator,\n                            sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                            sellTokenDecimals: 18,\n                            takerAddress: '0xtaker',\n                            checkApproval: false,\n                        },\n                        GaslessTypes.MetaTransaction,\n                    ),\n                ).rejects.toThrow('Error fetching quote');\n            });\n\n            it('stores a metatransaction hash', async () => {\n                getMetaTransactionV1QuoteAsyncMock.mockResolvedValueOnce({\n                    trade: {\n                        kind: GaslessTypes.MetaTransaction,\n                        hash: metaTransactionV1.getHash(),\n                        metaTransaction: metaTransactionV1,\n                    },\n                    price,\n                });\n                mockRfqmService.fetchFirmQuoteAsync.mockResolvedValueOnce({ quote: null, quoteReportId: null });\n\n                await gaslessSwapService.fetchQuoteAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        takerAddress: '0xtaker',\n                        checkApproval: false,\n                    },\n                    GaslessTypes.MetaTransaction,\n                );\n\n                expect(mockRedis.set).toBeCalledWith(\n                    `metaTransactionHash.${metaTransactionV1.getHash()}`,\n                    0,\n                    'EX',\n                    900,\n                );\n            });\n\n            it('gets the approval object', async () => {\n                const approvalResponse: ApprovalResponse = {\n                    isRequired: true,\n                };\n                getMetaTransactionV1QuoteAsyncMock.mockResolvedValueOnce({\n                    trade: {\n                        kind: GaslessTypes.MetaTransaction,\n                        hash: metaTransactionV1.getHash(),\n                        metaTransaction: metaTransactionV1,\n                    },\n                    price,\n                });\n                mockRfqmService.fetchFirmQuoteAsync.mockResolvedValueOnce({ quote: null, quoteReportId: null });\n                mockRfqmService.getGaslessApprovalResponseAsync.mockResolvedValueOnce(approvalResponse);\n\n                const result = await gaslessSwapService.fetchQuoteAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        takerAddress: '0xtaker',\n                        checkApproval: true,\n                    },\n                    GaslessTypes.MetaTransaction,\n                );\n\n                expect(result?.approval).not.toBeUndefined();\n            });\n        });\n\n        describe('tx relay v1', () => {\n            it('gets a meta-transaction quote', async () => {\n                getMetaTransactionV2QuoteAsyncMock.mockResolvedValueOnce({\n                    trade: {\n                        kind: GaslessTypes.MetaTransaction,\n                        hash: metaTransactionV1.getHash(),\n                        metaTransaction: metaTransactionV1,\n                    },\n                    price,\n                    sources,\n                    fees,\n                });\n\n                const result = (await gaslessSwapService.fetchQuoteAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        takerAddress: '0xtaker',\n                        checkApproval: false,\n                        feeType: 'volume',\n                        feeRecipient: integratorAddress,\n                        feeSellTokenPercentage: new BigNumber(0.1),\n                    },\n                    GaslessTypes.MetaTransactionV2,\n                )) as MetaTransactionV2QuoteResponse;\n\n                expect(result).not.toBeNull();\n                expect(result?.trade.kind).toEqual(GaslessTypes.MetaTransaction);\n                expect(result?.trade.hash).toEqual(metaTransactionV1.getHash());\n                console.log(result);\n                expect(result).toMatchInlineSnapshot(`\n                    Object {\n                      \"allowanceTarget\": \"0x12345\",\n                      \"approval\": undefined,\n                      \"buyAmount\": \"1800054805473\",\n                      \"buyTokenAddress\": \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n                      \"fees\": Object {\n                        \"gasFee\": Object {\n                          \"feeAmount\": \"10000000\",\n                          \"feeToken\": \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\",\n                          \"feeType\": \"gas\",\n                        },\n                        \"integratorFee\": Object {\n                          \"feeAmount\": \"1000000000000000000\",\n                          \"feeToken\": \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\",\n                          \"feeType\": \"volume\",\n                        },\n                        \"zeroExFee\": Object {\n                          \"feeAmount\": \"1000000000000000\",\n                          \"feeToken\": \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\",\n                          \"feeType\": \"integrator_share\",\n                        },\n                      },\n                      \"gas\": \"1043459\",\n                      \"price\": \"1800.054805\",\n                      \"sellAmount\": \"1000000000000000000000\",\n                      \"sellTokenAddress\": \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\",\n                      \"sources\": Array [\n                        Object {\n                          \"name\": \"QuickSwap\",\n                          \"proportion\": \"0.2308\",\n                        },\n                        Object {\n                          \"name\": \"DODO_V2\",\n                          \"proportion\": \"0.07692\",\n                        },\n                        Object {\n                          \"name\": \"Uniswap_V3\",\n                          \"proportion\": \"0.6923\",\n                        },\n                      ],\n                      \"trade\": Object {\n                        \"hash\": \"0xde5a11983edd012047dd3107532f007a73ae488bfb354f35b8a40580e2a775a1\",\n                        \"kind\": \"metatransaction\",\n                        \"metaTransaction\": MetaTransaction {\n                          \"callData\": \"0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000017b9e2a304f00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac18858000000000000000000000000000000000000000000000000000000039d0b9efd1000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001c94ebec37000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001db5156c13000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e69737761705633000000000000000000000000000000000000000000000000000000000000190522016f044a05b0000000000000000000000000000000000000000000000000000000b08217af9400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000000c829100b78224ef50000000000000000000000000000000000000000000000000000000570157389f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c6300000000000000000000000000000000000000000000005b89d96b4863067a6b\",\n                          \"chainId\": 137,\n                          \"expirationTimeSeconds\": \"9990868679\",\n                          \"feeAmount\": \"0\",\n                          \"feeToken\": \"0x0000000000000000000000000000000000000000\",\n                          \"maxGasPrice\": \"4294967296\",\n                          \"minGasPrice\": \"1\",\n                          \"salt\": \"32606650794224190000000000000000000000000000000000000000000000000000000000000\",\n                          \"sender\": \"0x0000000000000000000000000000000000000000\",\n                          \"signer\": \"0x4c42a706410f1190f97d26fe3c999c90070aa40f\",\n                          \"value\": \"0\",\n                          \"verifyingContract\": \"0xdef1c0ded9bec7f1a1670819833240f027b25eff\",\n                        },\n                      },\n                    }\n                `);\n            });\n\n            it('throws validation error if meta-transaction throws validation error', async () => {\n                getMetaTransactionV2QuoteAsyncMock.mockImplementation(() => {\n                    throw new ValidationError([\n                        {\n                            field: 'sellAmount',\n                            code: ValidationErrorCodes.FieldInvalid,\n                            reason: 'sellAmount too small',\n                        },\n                    ]);\n                });\n\n                await expect(() =>\n                    gaslessSwapService.fetchQuoteAsync(\n                        {\n                            buyAmount: new BigNumber(1800054805473),\n                            buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                            buyTokenDecimals: 6,\n                            integrator: {} as Integrator,\n                            sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                            sellTokenDecimals: 18,\n                            takerAddress: '0xtaker',\n                            checkApproval: false,\n                            feeType: 'volume',\n                            feeRecipient: integratorAddress,\n                            feeSellTokenPercentage: new BigNumber(0.1),\n                        },\n                        GaslessTypes.MetaTransactionV2,\n                    ),\n                ).rejects.toThrow(ValidationError);\n            });\n\n            it('adds an affiliate address if one is included in the integrator configuration but not in the quote request', async () => {\n                getMetaTransactionV2QuoteAsyncMock.mockResolvedValueOnce({\n                    trade: {\n                        kind: GaslessTypes.MetaTransaction,\n                        hash: metaTransactionV1.getHash(),\n                        metaTransaction: metaTransactionV1,\n                    },\n                    price,\n                    sources,\n                    fees,\n                });\n\n                await gaslessSwapService.fetchQuoteAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: { affiliateAddress: '0xaffiliateAddress' } as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        takerAddress: '0xtaker',\n                        checkApproval: false,\n                        feeType: 'volume',\n                        feeRecipient: integratorAddress,\n                        feeSellTokenPercentage: new BigNumber(0.1),\n                    },\n                    GaslessTypes.MetaTransactionV2,\n                );\n                expect(getMetaTransactionV2QuoteAsyncMock.mock.calls[0][/* params */ 2]['affiliateAddress']).toEqual(\n                    '0xaffiliateAddress',\n                );\n            });\n\n            it('uses the affiliate address in the quote request even if one is present in integrator configuration', async () => {\n                getMetaTransactionV2QuoteAsyncMock.mockResolvedValueOnce({\n                    trade: {\n                        kind: GaslessTypes.MetaTransaction,\n                        hash: metaTransactionV1.getHash(),\n                        metaTransaction: metaTransactionV1,\n                    },\n                    price,\n                    sources,\n                    fees,\n                });\n\n                await gaslessSwapService.fetchQuoteAsync(\n                    {\n                        affiliateAddress: '0xaffiliateAddressShouldUse',\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: { affiliateAddress: '0xaffiliateAddressShouldntUse' } as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        takerAddress: '0xtaker',\n                        checkApproval: false,\n                        feeType: 'volume',\n                        feeRecipient: integratorAddress,\n                        feeSellTokenPercentage: new BigNumber(0.1),\n                    },\n                    GaslessTypes.MetaTransactionV2,\n                );\n                expect(getMetaTransactionV2QuoteAsyncMock.mock.calls[0][/* params */ 2]['affiliateAddress']).toEqual(\n                    '0xaffiliateAddressShouldUse',\n                );\n            });\n\n            it('returns `null` if no liquidity is available', async () => {\n                getMetaTransactionV2QuoteAsyncMock.mockResolvedValueOnce(null);\n\n                const result = await gaslessSwapService.fetchQuoteAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        takerAddress: '0xtaker',\n                        checkApproval: false,\n                        feeType: 'volume',\n                        feeRecipient: integratorAddress,\n                        feeSellTokenPercentage: new BigNumber(0.1),\n                    },\n                    GaslessTypes.MetaTransactionV2,\n                );\n\n                expect(result).toBeNull();\n            });\n\n            it('throws if meta-transaction request throws', async () => {\n                getMetaTransactionV2QuoteAsyncMock.mockImplementationOnce(() => {\n                    throw new Error('meta-transaction request throws');\n                });\n\n                await expect(() =>\n                    gaslessSwapService.fetchQuoteAsync(\n                        {\n                            buyAmount: new BigNumber(1800054805473),\n                            buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                            buyTokenDecimals: 6,\n                            integrator: {} as Integrator,\n                            sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                            sellTokenDecimals: 18,\n                            takerAddress: '0xtaker',\n                            checkApproval: false,\n                            feeType: 'volume',\n                            feeRecipient: integratorAddress,\n                            feeSellTokenPercentage: new BigNumber(0.1),\n                        },\n                        GaslessTypes.MetaTransactionV2,\n                    ),\n                ).rejects.toThrow('Error fetching quote');\n            });\n\n            it('stores a metatransaction hash', async () => {\n                getMetaTransactionV2QuoteAsyncMock.mockResolvedValueOnce({\n                    trade: {\n                        kind: GaslessTypes.MetaTransaction,\n                        hash: metaTransactionV1.getHash(),\n                        metaTransaction: metaTransactionV1,\n                    },\n                    price,\n                    sources,\n                    fees,\n                });\n\n                await gaslessSwapService.fetchQuoteAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        takerAddress: '0xtaker',\n                        checkApproval: false,\n                        feeType: 'volume',\n                        feeRecipient: integratorAddress,\n                        feeSellTokenPercentage: new BigNumber(0.1),\n                    },\n                    GaslessTypes.MetaTransactionV2,\n                );\n\n                expect(mockRedis.set).toBeCalledWith(\n                    `metaTransactionHash.${metaTransactionV2.getHash()}`,\n                    0,\n                    'EX',\n                    900,\n                );\n            });\n\n            it('gets the approval object', async () => {\n                const approvalResponse: ApprovalResponse = {\n                    isRequired: true,\n                };\n                getMetaTransactionV2QuoteAsyncMock.mockResolvedValueOnce({\n                    trade: {\n                        kind: GaslessTypes.MetaTransaction,\n                        hash: metaTransactionV1.getHash(),\n                        metaTransaction: metaTransactionV1,\n                    },\n                    price,\n                    sources,\n                    fees,\n                });\n                mockRfqmService.getGaslessApprovalResponseAsync.mockResolvedValueOnce(approvalResponse);\n\n                const result = await gaslessSwapService.fetchQuoteAsync(\n                    {\n                        buyAmount: new BigNumber(1800054805473),\n                        buyToken: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                        buyTokenDecimals: 6,\n                        integrator: {} as Integrator,\n                        sellToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        sellTokenDecimals: 18,\n                        takerAddress: '0xtaker',\n                        checkApproval: true,\n                        feeType: 'volume',\n                        feeRecipient: integratorAddress,\n                        feeSellTokenPercentage: new BigNumber(0.1),\n                    },\n                    GaslessTypes.MetaTransactionV2,\n                );\n\n                expect(result?.approval).not.toBeUndefined();\n            });\n        });\n    });\n\n    describe('processSubmitAsync', () => {\n        describe('zero-g', () => {\n            it('fails if the metatransaction is expired', async () => {\n                const expiredMetaTransaction = new MetaTransaction({\n                    callData:\n                        '0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000017b9e2a304f00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac18858000000000000000000000000000000000000000000000000000000039d0b9efd1000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001c94ebec37000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c42c00000000000000000000000000000000000000000000000000000001db5156c13000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e69737761705633000000000000000000000000000000000000000000000000000000000000190522016f044a05b0000000000000000000000000000000000000000000000000000000b08217af9400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000000c829100b78224ef50000000000000000000000000000000000000000000000000000000570157389f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c6300000000000000000000000000000000000000000000005b89d96b4863067a6b',\n                    chainId: 137,\n                    verifyingContract: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                    expirationTimeSeconds: new BigNumber('420'),\n                    feeAmount: new BigNumber(0),\n                    feeToken: '0x0000000000000000000000000000000000000000',\n                    maxGasPrice: new BigNumber(4294967296),\n                    minGasPrice: new BigNumber(1),\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line @typescript-eslint/no-loss-of-precision\n                    salt: new BigNumber(32606650794224189614795510724011106220035660490560169776986607186708081701146),\n                    sender: '0x0000000000000000000000000000000000000000',\n                    signer: '0x4C42a706410F1190f97D26Fe3c999c90070aa40F',\n                    value: new BigNumber(0),\n                });\n\n                await expect(() =>\n                    gaslessSwapService.processSubmitAsync(\n                        {\n                            kind: GaslessTypes.MetaTransaction,\n                            trade: {\n                                metaTransaction: expiredMetaTransaction,\n                                type: GaslessTypes.MetaTransaction,\n                                signature: {\n                                    r: '',\n                                    s: '',\n                                    signatureType: SignatureType.EthSign,\n                                    v: 1,\n                                },\n                            },\n                        },\n\n                        'integratorId',\n                    ),\n                ).rejects.toThrowError(ValidationError);\n            });\n\n            it(\"fails if the metatransaction hash doesn't exist in the redis store\", async () => {\n                mockRedis.get = jest.fn().mockResolvedValueOnce(null);\n                await expect(() =>\n                    gaslessSwapService.processSubmitAsync(\n                        {\n                            kind: GaslessTypes.MetaTransaction,\n                            trade: {\n                                metaTransaction: metaTransactionV1,\n                                type: GaslessTypes.MetaTransaction,\n                                signature: {\n                                    r: '',\n                                    s: '',\n                                    signatureType: SignatureType.EthSign,\n                                    v: 1,\n                                },\n                            },\n                        },\n                        'integratorId',\n                    ),\n                ).rejects.toThrowError('MetaTransaction hash not found');\n                expect(mockRedis.get).toBeCalledWith(`metaTransactionHash.${metaTransactionV1.getHash()}`);\n            });\n\n            it('fails if there is already a pending transaction for the taker/taker token', async () => {\n                mockRedis.get = jest.fn().mockResolvedValueOnce({});\n                mockDbUtils.findMetaTransactionJobsWithStatusesAsync.mockResolvedValueOnce([\n                    new MetaTransactionJobEntity({\n                        chainId: 1337,\n                        expiry: metaTransactionV1.expirationTimeSeconds,\n                        fee: {\n                            amount: metaTransactionV1.feeAmount,\n                            token: metaTransactionV1.feeToken,\n                            type: 'fixed',\n                        },\n                        inputToken: price.sellTokenAddress,\n                        inputTokenAmount: price.sellAmount,\n                        integratorId: 'integrator-id',\n                        metaTransaction: metaTransactionV1,\n                        metaTransactionHash: '0xotherhash',\n                        minOutputTokenAmount: new BigNumber(0),\n                        outputToken: price.buyTokenAddress,\n                        status: RfqmJobStatus.PendingProcessing,\n                        takerAddress: metaTransactionV1.signer,\n                        takerSignature: {\n                            r: '',\n                            s: '',\n                            signatureType: SignatureType.EthSign,\n                            v: 1,\n                        },\n                    }),\n                ]);\n                await expect(() =>\n                    gaslessSwapService.processSubmitAsync(\n                        {\n                            kind: GaslessTypes.MetaTransaction,\n                            trade: {\n                                metaTransaction: metaTransactionV1,\n                                type: GaslessTypes.MetaTransaction,\n                                signature: ethSignHashWithKey(metaTransactionV1.getHash(), takerPrivateKey),\n                            },\n                        },\n                        'integratorId',\n                    ),\n                ).rejects.toThrowError('pending trade');\n            });\n\n            it('fails if the signature is invalid', async () => {\n                const otherPrivateKey = '0xae4536e2cdee8f32adc77ebe86977a01c6526a32eee7c4c2ccfb1d5ddcddaaa2';\n                mockRedis.get = jest.fn().mockResolvedValueOnce({});\n                mockDbUtils.findMetaTransactionJobsWithStatusesAsync.mockResolvedValueOnce([]);\n                await expect(() =>\n                    gaslessSwapService.processSubmitAsync(\n                        {\n                            kind: GaslessTypes.MetaTransaction,\n                            trade: {\n                                metaTransaction: metaTransactionV1,\n                                type: GaslessTypes.MetaTransaction,\n                                signature: ethSignHashWithKey(metaTransactionV1.getHash(), otherPrivateKey),\n                            },\n                        },\n                        'integratorId',\n                    ),\n                ).rejects.toThrow(ValidationError);\n            });\n\n            it('fails if taker balance is too low', async () => {\n                mockRedis.get = jest.fn().mockResolvedValueOnce({});\n                mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync.mockResolvedValueOnce([new BigNumber(21)]);\n                await expect(() =>\n                    gaslessSwapService.processSubmitAsync(\n                        {\n                            kind: GaslessTypes.MetaTransaction,\n                            trade: {\n                                metaTransaction: metaTransactionV1,\n                                type: GaslessTypes.MetaTransaction,\n                                signature: ethSignHashWithKey(metaTransactionV1.getHash(), takerPrivateKey),\n                            },\n                        },\n                        'integratorId',\n                    ),\n                ).rejects.toThrow(ValidationError);\n            });\n\n            it('creates a metatransaction job', async () => {\n                mockRedis.get = jest.fn().mockResolvedValueOnce({});\n                mockBlockchainUtils.getMinOfBalancesAndAllowancesAsync = jest\n                    .fn()\n                    .mockResolvedValueOnce([price.sellAmount]);\n\n                mockDbUtils.writeMetaTransactionJobAsync.mockResolvedValueOnce({\n                    id: 'id',\n                } as MetaTransactionJobEntity);\n\n                const result = await gaslessSwapService.processSubmitAsync(\n                    {\n                        kind: GaslessTypes.MetaTransaction,\n                        trade: {\n                            metaTransaction: metaTransactionV1,\n                            type: GaslessTypes.MetaTransaction,\n                            signature: ethSignHashWithKey(metaTransactionV1.getHash(), takerPrivateKey),\n                        },\n                    },\n                    'integratorId',\n                );\n\n                expect(result.metaTransactionHash).toEqual(metaTransactionV1.getHash());\n                expect(result.type).toEqual(GaslessTypes.MetaTransaction);\n                // tslint:disable-next-line: no-unbound-method\n                expect(mockSqsProducer.send).toHaveBeenCalledWith({\n                    body: '{\"id\":\"id\",\"type\":\"metatransaction\"}',\n                    deduplicationId: 'id',\n                    groupId: 'id',\n                    id: 'id',\n                });\n            });\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/GaslessSwapService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/MetaTransactionClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_health_check.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/meta_transaction_fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/proto-ts/meta_transaction.pb.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ProtoUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_request_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/services/GaslessSwapService.ts",{"fileContent":"// tslint:disable:max-file-line-count\nimport { InternalServerError, TooManyRequestsError, ValidationError, ValidationErrorCodes } from '@0x/api-utils';\nimport { ITransformERC20Contract } from '@0x/contract-wrappers';\nimport { BigNumber, NULL_ADDRESS } from '@0x/utils';\nimport { AxiosInstance } from 'axios';\nimport { utils as ethersUtils } from 'ethers';\nimport Redis from 'ioredis';\nimport { Counter, Summary } from 'prom-client';\nimport { Producer } from 'sqs-producer';\n\nimport { ONE_MINUTE_S, ONE_SECOND_MS } from '../core/constants';\nimport { MetaTransactionJobConstructorOpts } from '../entities/MetaTransactionJobEntity';\nimport { RfqmJobStatus } from '../entities/types';\nimport { logger } from '../logger';\nimport { ExecuteMetaTransactionEip712Context, PermitEip712Context, GaslessTypes } from '../core/types';\nimport { FeeConfigs, TruncatedFees } from '../core/types/meta_transaction_fees';\nimport { getV1QuoteAsync, getV2QuoteAsync, MetaTransactionClientQuoteResponse } from '../utils/MetaTransactionClient';\nimport { RfqmDbUtils } from '../utils/rfqm_db_utils';\nimport { HealthCheckResult } from '../utils/rfqm_health_check';\nimport { RfqBlockchainUtils } from '../utils/rfq_blockchain_utils';\nimport { getSignerFromHash } from '../utils/signature_utils';\n\nimport { RfqmService } from './rfqm_service';\nimport {\n    FetchFirmQuoteParams,\n    FetchIndicativeQuoteParams,\n    FetchIndicativeQuoteResponse,\n    MetaTransactionV1QuoteResponse,\n    MetaTransactionV2QuoteResponse,\n    OtcOrderRfqmQuoteResponse,\n    SubmitMetaTransactionSignedQuoteParams,\n    SubmitMetaTransactionSignedQuoteResponse,\n    SubmitRfqmSignedQuoteWithApprovalParams,\n    SubmitRfqmSignedQuoteWithApprovalResponse,\n    LiquiditySource,\n    SubmitMetaTransactionV2SignedQuoteParams,\n    SubmitMetaTransactionV2SignedQuoteResponse,\n    StatusResponse,\n    FetchQuoteParamsBase,\n} from './types';\nimport { feesToTruncatedFees, getFeeConfigsFromParams } from '../core/meta_transaction_fee_utils';\n\n/**\n * When a metatransaction quote is issued, the hash\n * is stored in Redis. When a quote is submitted, it\n * is only accepted if the metatransaction hash is in\n * Redis. This prevents a malicious user submitting\n * a quote which was not issued by 0x.\n *\n * The length of time the quote metatransaction hash\n * is stored in Redis.\n */\nconst META_TRANSACTION_HASH_TTL_S = 15 * ONE_MINUTE_S; // tslint:disable-line binary-expression-operand-order custom-no-magic-numbers\n\nenum GaslessSwapServiceErrorReason {\n    MetaTransactionAboutToExpire = 'meta_transaction_about_to_expire', // meta-transaction is about to expire\n    MetaTransactionPendingJobAlreadyExist = 'meta_transaction_pending_job_already_exist', // a pendingmeta-transaction job already exists for a taker-takerToken\n    MetaTransactionTakerBalanceCheckFailed = 'meta_transaction_taker_balance_check_failed', // taker balance check failed when submitting a meta-transaction\n    MetaTransactionHashNotExist = 'meta_transaction_hash_does_not_exist', // meta-transaction hash does not exist\n    MetaTransactionInvalidSigner = 'meta_transaction_invalid_signer', // invalid signer for the mta-transaction\n    MetaTransactionFailedToQueue = 'meta_transaction_failed_to_queue', // failed to queue meta-transaction\n    RfqPriceError = 'rfq_price_error', // encountered error when fetching rfq price\n    AmmPriceError = 'amm_price_error', // encountered error when fetching amm price\n    RfqQuoteError = 'rfq_quote_error', // encountered error when fetching rfq quote\n    AmmQuoteError = 'amm_quote_error', // encountered error when fetching amm quote\n}\n\n/**\n * Produces a key for Redis using the MetaTransaction hash\n */\nfunction metaTransactionHashRedisKey(hash: string): string {\n    return `metaTransactionHash.${hash}`;\n}\n\n/**\n * Accepts calldata for a transformErc20 call and extracts\n * arguments from the calldata.\n */\nfunction decodeTransformErc20Calldata(calldata: string): {\n    inputToken: string;\n    outputToken: string;\n    inputTokenAmount: BigNumber;\n    minOutputTokenAmount: BigNumber;\n} {\n    const transformErc20Interface = new ethersUtils.Interface(ITransformERC20Contract.ABI());\n\n    const result = transformErc20Interface.parseTransaction({ data: calldata });\n\n    const {\n        args: [inputToken, outputToken, inputTokenAmount, minOutputTokenAmount],\n    } = result;\n\n    return {\n        inputToken: inputToken as string,\n        outputToken: outputToken as string,\n        // Use `toString` because these are actually Ethers BigNumbers\n        inputTokenAmount: new BigNumber(inputTokenAmount.toString()),\n        minOutputTokenAmount: new BigNumber(minOutputTokenAmount.toString()),\n    };\n}\n\nconst ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS = new Summary({\n    name: 'zerog_meta_transaction_quote_request_duration_seconds',\n    help: 'Histogram of request duration of gasless swap',\n    // tslint:disable-next-line: custom-no-magic-numbers\n    percentiles: [0.5, 0.9, 0.95, 0.99, 0.999],\n    labelNames: ['chainId', 'success'],\n    maxAgeSeconds: 60,\n    ageBuckets: 5,\n});\nconst ZEROG_GASLESSS_SWAP_SERVICE_ERRORS = new Counter({\n    name: 'zerog_gasless_swap_service_errors_total',\n    labelNames: ['chainId', 'reason'],\n    help: 'Number of errors (with specific reason) encountered in galess swap service',\n});\n\n/**\n * Contains logic to fetch RFQm quotes, but with a fallback to\n * a MetaTransaction-wrapped AMM trade in the case no RFQm\n * liquidity is available.\n */\nexport class GaslessSwapService {\n    constructor(\n        private readonly _chainId: number,\n        private readonly _rfqmService: RfqmService,\n        private readonly _metaTransactionServiceBaseUrl: URL,\n        private readonly _axiosInstance: AxiosInstance,\n        private readonly _redis: Redis,\n        private readonly _dbUtils: RfqmDbUtils,\n        private readonly _blockchainUtils: RfqBlockchainUtils,\n        private readonly _sqsProducer: Producer,\n    ) {}\n\n    /**\n     * Fetches a \"price\" (aka \"Indicative Quote\").\n     *\n     * The request is first sent to market maker servers and then to the metatransaction\n     * service if the market makers don't provide liquidity or errors out.\n     *\n     * If RFQ liquidity exists, then it is used to compute the price.\n     * If AMM liquidity exists but RFQ liquidity is unavailable then\n     * AMM liquidity is used to compute the price.\n     *\n     * Returns `null` if neither AMM or RFQ liquidity exists.\n     */\n    public async fetchPriceAsync(\n        params: FetchIndicativeQuoteParams,\n        kind: GaslessTypes,\n    ): Promise<\n        | (FetchIndicativeQuoteResponse &\n              ({ liquiditySource: 'rfq' | 'amm' } | { sources: LiquiditySource[]; fees?: TruncatedFees }))\n        | null\n    > {\n        if (kind === GaslessTypes.MetaTransaction) {\n            try {\n                const rfqPrice = await this._rfqmService.fetchIndicativeQuoteAsync(params, 'gaslessSwapRfq');\n\n                if (rfqPrice) {\n                    return { ...rfqPrice, liquiditySource: 'rfq' };\n                }\n            } catch (e) {\n                ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                    this._chainId.toString(),\n                    GaslessSwapServiceErrorReason.RfqPriceError,\n                ).inc();\n                logger.error(\n                    { params, errorMessage: e.message, stack: e.stack },\n                    'Encountered error when fetching RFQ price in `GaslessSwapService`',\n                );\n            }\n        }\n\n        try {\n            let feeConfigs: FeeConfigs | undefined;\n            if (kind === GaslessTypes.MetaTransactionV2) {\n                feeConfigs = this._getFeeConfigs(params, 'on-chain'); // integrator billing type would always be on-chain for now\n            }\n\n            const metaTransactionRequestParams = {\n                ...params,\n                chainId: this._chainId,\n                integratorId: params.integrator.integratorId,\n                // Can use the null address here since we won't be returning\n                // the actual metatransaction\n                takerAddress: params.takerAddress ?? NULL_ADDRESS,\n                feeConfigs,\n            };\n\n            let metaTransactionQuote: MetaTransactionClientQuoteResponse | null;\n\n            switch (kind) {\n                case GaslessTypes.MetaTransaction:\n                    metaTransactionQuote = await getV1QuoteAsync(\n                        this._axiosInstance,\n                        new URL(`${this._metaTransactionServiceBaseUrl.toString()}/quote`),\n                        metaTransactionRequestParams,\n                        {\n                            requestDurationSummary: ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS,\n                            chainId: this._chainId,\n                        },\n                        logger.warn.bind(logger),\n                    );\n                    break;\n                case GaslessTypes.MetaTransactionV2:\n                    metaTransactionQuote = await getV2QuoteAsync(\n                        this._axiosInstance,\n                        new URL(`${this._metaTransactionServiceBaseUrl.toString()}/quote`),\n                        metaTransactionRequestParams,\n                        {\n                            requestDurationSummary: ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS,\n                            chainId: this._chainId,\n                        },\n                        logger.warn.bind(logger),\n                    );\n                    break;\n                case GaslessTypes.OtcOrder:\n                    // This should never happen\n                    throw new Error('GaslessTypes.OtcOrder should not be reached');\n                default:\n                    ((_x: never) => {\n                        throw new Error('unreachable');\n                    })(kind);\n            }\n\n            if (metaTransactionQuote) {\n                if (kind === GaslessTypes.MetaTransaction) {\n                    return {\n                        ...metaTransactionQuote.price,\n                        allowanceTarget: this._blockchainUtils.getExchangeProxyAddress(),\n                        liquiditySource: 'amm',\n                    };\n                } else {\n                    return {\n                        ...metaTransactionQuote.price,\n                        sources: metaTransactionQuote.sources ?? [],\n                        fees: feesToTruncatedFees(metaTransactionQuote.fees),\n                        allowanceTarget: this._blockchainUtils.getExchangeProxyAddress(),\n                    };\n                }\n            }\n\n            return null;\n        } catch (e) {\n            if (e instanceof ValidationError) {\n                throw e;\n            }\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.AmmPriceError,\n            ).inc();\n            logger.error(\n                { params, errorMessage: e.message, stack: e.stack },\n                'Encountered error when fetching AMM price in `GaslessSwapService`',\n            );\n\n            // Throw here as it means RFQ throws / does not liquidity and AMM throws\n            throw new Error(`Error fetching price for ${params}`);\n        }\n    }\n\n    /**\n     * Fetches a \"quote\" (aka \"Firm Quote\").\n     *\n     * Liquidity selection logic is the same as with `fetchPriceAsync`.\n     *\n     * If an AMM metatransaction is selected as the liquidity source,\n     * its metatransaction hash is stored in Redis to be verified upon\n     * submit.\n     */\n    public async fetchQuoteAsync(\n        params: FetchFirmQuoteParams,\n        kind: GaslessTypes,\n    ): Promise<\n        | ((OtcOrderRfqmQuoteResponse | MetaTransactionV1QuoteResponse) & { liquiditySource: 'rfq' | 'amm' })\n        | MetaTransactionV2QuoteResponse\n        | null\n    > {\n        let rfqQuoteReportId: string | null = null;\n        if (kind === GaslessTypes.MetaTransaction) {\n            try {\n                const { quote: rfqQuote, quoteReportId } = await this._rfqmService.fetchFirmQuoteAsync(\n                    params,\n                    'gaslessSwapRfq',\n                );\n                rfqQuoteReportId = quoteReportId;\n                if (rfqQuote) {\n                    return { ...rfqQuote, liquiditySource: 'rfq' };\n                }\n            } catch (e) {\n                ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                    this._chainId.toString(),\n                    GaslessSwapServiceErrorReason.RfqQuoteError,\n                ).inc();\n                logger.error(\n                    { params, errorMessage: e.message, stack: e.stack },\n                    'Encountered error when fetching RFQ quote in `GaslessSwapService`',\n                );\n            }\n        }\n\n        try {\n            let feeConfigs: FeeConfigs | undefined;\n            if (kind === GaslessTypes.MetaTransactionV2) {\n                feeConfigs = this._getFeeConfigs(params, 'on-chain'); // integrator billing type would always be on-chain for now\n            }\n\n            const metaTransactionRequestParams = {\n                ...params,\n                chainId: this._chainId,\n                affiliateAddress: params.affiliateAddress ?? params.integrator.affiliateAddress,\n                integratorId: params.integrator.integratorId,\n                quoteUniqueId: kind === GaslessTypes.MetaTransaction ? rfqQuoteReportId ?? undefined : undefined,\n                feeConfigs,\n            };\n\n            let metaTransactionQuote: MetaTransactionClientQuoteResponse | null;\n\n            switch (kind) {\n                case GaslessTypes.MetaTransaction:\n                    metaTransactionQuote = await getV1QuoteAsync(\n                        this._axiosInstance,\n                        new URL(`${this._metaTransactionServiceBaseUrl.toString()}/quote`),\n                        metaTransactionRequestParams,\n                        {\n                            requestDurationSummary: ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS,\n                            chainId: this._chainId,\n                        },\n                        logger.warn.bind(logger),\n                    );\n                    break;\n                case GaslessTypes.MetaTransactionV2:\n                    metaTransactionQuote = await getV2QuoteAsync(\n                        this._axiosInstance,\n                        new URL(`${this._metaTransactionServiceBaseUrl.toString()}/quote`),\n                        metaTransactionRequestParams,\n                        {\n                            requestDurationSummary: ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS,\n                            chainId: this._chainId,\n                        },\n                        logger.warn.bind(logger),\n                    );\n                    break;\n                case GaslessTypes.OtcOrder:\n                    // This should never happen\n                    throw new Error('GaslessTypes.OtcOrder should not be reached');\n                default:\n                    ((_x: never) => {\n                        throw new Error('unreachable');\n                    })(kind);\n            }\n\n            if (metaTransactionQuote) {\n                const approval = params.checkApproval\n                    ? await this._rfqmService.getGaslessApprovalResponseAsync(\n                          params.takerAddress,\n                          params.sellToken,\n                          metaTransactionQuote.price.sellAmount,\n                      )\n                    : null;\n                const metaTransaction = metaTransactionQuote.trade.metaTransaction;\n                // TODO: Publish fee event for meta-transaction v2\n                await this._storeMetaTransactionHashAsync(metaTransaction.getHash());\n\n                if (kind === GaslessTypes.MetaTransaction) {\n                    // Response from /meta_transaction/v1 endpoint. The meta-transaction type\n                    // can ONLY be meta-transaction v1\n                    return {\n                        ...metaTransactionQuote.price,\n                        approval: approval ?? undefined,\n                        metaTransaction,\n                        metaTransactionHash: metaTransaction.getHash(),\n                        type: GaslessTypes.MetaTransaction,\n                        allowanceTarget: this._blockchainUtils.getExchangeProxyAddress(),\n                        liquiditySource: 'amm',\n                    };\n                } else {\n                    // Response from /meta_transaction/v2 endpoint. The meta-transaction type\n                    // can either be meta-transaction v1 / v2\n                    return {\n                        ...metaTransactionQuote.price,\n                        approval: approval ?? undefined,\n                        trade: metaTransactionQuote.trade,\n                        sources: metaTransactionQuote.sources ?? [],\n                        fees: feesToTruncatedFees(metaTransactionQuote.fees),\n                        allowanceTarget: this._blockchainUtils.getExchangeProxyAddress(),\n                    };\n                }\n            }\n\n            return null;\n        } catch (e) {\n            if (e instanceof ValidationError) {\n                throw e;\n            }\n\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.AmmQuoteError,\n            ).inc();\n            logger.error(\n                { params, errorMessage: e.message, stack: e.stack },\n                'Encountered error when fetching AMM quote in `GaslessSwapService`',\n            );\n\n            // Throw here as it means RFQ throws / does not liquidity and AMM throws\n            throw new Error(`Error fetching quote for ${params}`);\n        }\n    }\n\n    /**\n     * Accepts a taker-signed MetaTransaction or OtcOrder trade, and optionally,\n     * a signed permit transaction, and produces the appropriate Job and sends\n     * a message to SQS.\n     *\n     * For lots of discussion on why the type assertions are needed, see:\n     * https://github.com/microsoft/TypeScript/issues/33912\n     */\n    public async processSubmitAsync<\n        T extends\n            | SubmitRfqmSignedQuoteWithApprovalParams<ExecuteMetaTransactionEip712Context | PermitEip712Context>\n            | SubmitMetaTransactionSignedQuoteParams<ExecuteMetaTransactionEip712Context | PermitEip712Context>\n            | SubmitMetaTransactionV2SignedQuoteParams<ExecuteMetaTransactionEip712Context | PermitEip712Context>,\n    >(\n        params: T,\n        integratorId: string,\n    ): Promise<\n        T extends SubmitRfqmSignedQuoteWithApprovalParams<ExecuteMetaTransactionEip712Context | PermitEip712Context>\n            ? SubmitRfqmSignedQuoteWithApprovalResponse\n            : T extends SubmitMetaTransactionSignedQuoteParams<\n                  ExecuteMetaTransactionEip712Context | PermitEip712Context\n              >\n            ? SubmitMetaTransactionSignedQuoteResponse\n            : SubmitMetaTransactionV2SignedQuoteResponse\n    > {\n        // OtcOrder\n        if (params.kind === GaslessTypes.OtcOrder) {\n            const otcOrderResult = await this._rfqmService.submitTakerSignedOtcOrderWithApprovalAsync(params);\n            return otcOrderResult as T extends SubmitRfqmSignedQuoteWithApprovalParams<\n                ExecuteMetaTransactionEip712Context | PermitEip712Context\n            >\n                ? SubmitRfqmSignedQuoteWithApprovalResponse\n                : T extends SubmitMetaTransactionSignedQuoteParams<\n                      ExecuteMetaTransactionEip712Context | PermitEip712Context\n                  >\n                ? SubmitMetaTransactionSignedQuoteResponse\n                : SubmitMetaTransactionV2SignedQuoteResponse;\n        }\n\n        // TODO: Add the logic to handle meta-transaction v2 when the type is ready\n        // MetaTransaction\n        const {\n            trade: { metaTransaction },\n        } = params;\n        const { inputToken, inputTokenAmount, outputToken, minOutputTokenAmount } = decodeTransformErc20Calldata(\n            metaTransaction.callData,\n        );\n\n        // Verify that the metatransaction is not expired\n        const currentTimeMs = new Date().getTime();\n        const bufferS = 30;\n        if (\n            metaTransaction.expirationTimeSeconds.minus(bufferS).times(ONE_SECOND_MS).isLessThanOrEqualTo(currentTimeMs)\n        ) {\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.MetaTransactionAboutToExpire,\n            ).inc();\n            logger.warn(\n                { metaTransactionHash: metaTransaction.getHash() },\n                'Received metatransaction submission which is about to expire',\n            );\n\n            throw new ValidationError([\n                {\n                    field: 'expirationTimeSeconds',\n                    code: ValidationErrorCodes.FieldInvalid,\n                    reason: `trade will expire too soon`,\n                },\n            ]);\n        }\n\n        // Verify that the metatransaction was created by 0x API\n        const doesMetaTransactionHashExist = await this._doesMetaTransactionHashExistAsync(metaTransaction.getHash());\n        if (!doesMetaTransactionHashExist) {\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.MetaTransactionHashNotExist,\n            ).inc();\n            logger.warn(\n                { metaTransactionHash: metaTransaction.getHash() },\n                'Received metatransaction submission not created by 0x API',\n            );\n            throw new Error('MetaTransaction hash not found');\n        }\n\n        // Verify that there is not a pending transaction for this taker and taker token\n\n        // TODO (rhinodavid): optimize this query by adding the taker & takerToken instead\n        // of filtering it out in the next step\n        const pendingJobs = await this._dbUtils.findMetaTransactionJobsWithStatusesAsync([\n            RfqmJobStatus.PendingEnqueued,\n            RfqmJobStatus.PendingProcessing,\n            RfqmJobStatus.PendingLastLookAccepted,\n            RfqmJobStatus.PendingSubmitted,\n        ]);\n\n        if (\n            pendingJobs.some(\n                (job) =>\n                    job.takerAddress.toLowerCase() === metaTransaction.signer.toLowerCase() &&\n                    job.inputToken.toLowerCase() === inputToken.toLowerCase() &&\n                    // Other logic handles the case where the same order is submitted twice\n                    job.metaTransactionHash !== metaTransaction.getHash(),\n            )\n        ) {\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.MetaTransactionPendingJobAlreadyExist,\n            ).inc();\n            logger.warn(\n                {\n                    metaTransactionHash: metaTransaction.getHash(),\n                    takerToken: inputToken,\n                    takerAddress: metaTransaction.signer.toLowerCase(),\n                },\n                'Metatransaction submission rejected because a job is pending with the same taker and taker token',\n            );\n            throw new TooManyRequestsError('a pending trade for this taker and takertoken already exists');\n        }\n\n        // validate that the given taker signature is valid\n        const signerAddress = getSignerFromHash(metaTransaction.getHash(), params.trade.signature).toLowerCase();\n        if (signerAddress !== metaTransaction.signer) {\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.MetaTransactionInvalidSigner,\n            ).inc();\n            logger.warn(\n                {\n                    metaTransactionHash: metaTransaction.getHash(),\n                    metaTransactionSigner: metaTransaction.signer,\n                    transactionSigner: signerAddress,\n                },\n                'Received submission with signer mismatch',\n            );\n            throw new ValidationError([\n                {\n                    field: 'signature',\n                    code: ValidationErrorCodes.InvalidSignatureOrHash,\n                    reason: `signature is not valid`,\n                },\n            ]);\n        }\n\n        // Validate that order is fillable according to balance and/or allowance.\n        const [takerBalance] = params.approval\n            ? await this._blockchainUtils.getTokenBalancesAsync([{ owner: metaTransaction.signer, token: inputToken }])\n            : await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync([\n                  { owner: metaTransaction.signer, token: inputToken },\n              ]);\n\n        if (takerBalance.isLessThan(inputTokenAmount)) {\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.MetaTransactionTakerBalanceCheckFailed,\n            ).inc();\n            logger.warn(\n                {\n                    takerBalance,\n                    takerAddress: metaTransaction.signer,\n                    metaTransactionHash: metaTransaction.getHash(),\n                },\n                'Balance check failed while user was submitting',\n            );\n            throw new ValidationError([\n                {\n                    field: 'n/a',\n                    code: ValidationErrorCodes.InvalidOrder,\n                    reason: `order is not fillable`,\n                },\n            ]);\n        }\n\n        const rfqmApprovalOpts = params.approval\n            ? await this._rfqmService.createApprovalAsync(params.approval, metaTransaction.getHash(), inputToken)\n            : undefined;\n\n        const jobOptions: MetaTransactionJobConstructorOpts = {\n            chainId: this._chainId,\n            expiry: metaTransaction.expirationTimeSeconds,\n            fee: { token: metaTransaction.feeToken, amount: metaTransaction.feeAmount, type: 'fixed' },\n            inputToken,\n            inputTokenAmount,\n            integratorId,\n            metaTransaction,\n            metaTransactionHash: metaTransaction.getHash(),\n            minOutputTokenAmount,\n            outputToken,\n            takerAddress: metaTransaction.signer,\n            takerSignature: params.trade.signature,\n            ...rfqmApprovalOpts,\n        };\n\n        try {\n            const { id } = await this._dbUtils.writeMetaTransactionJobAsync(jobOptions);\n            await this._enqueueJobAsync(id, GaslessTypes.MetaTransaction);\n        } catch (error) {\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.MetaTransactionFailedToQueue,\n            ).inc();\n            logger.error({ errorMessage: error.message }, 'Failed to queue the quote for submission.');\n            throw new InternalServerError(\n                `failed to queue the quote for submission, it may have already been submitted`,\n            );\n        }\n\n        const result: SubmitMetaTransactionSignedQuoteResponse = {\n            metaTransactionHash: metaTransaction.getHash(),\n            type: GaslessTypes.MetaTransaction,\n        };\n\n        return result as T extends SubmitRfqmSignedQuoteWithApprovalParams<\n            ExecuteMetaTransactionEip712Context | PermitEip712Context\n        >\n            ? SubmitRfqmSignedQuoteWithApprovalResponse\n            : T extends SubmitMetaTransactionSignedQuoteParams<\n                  ExecuteMetaTransactionEip712Context | PermitEip712Context\n              >\n            ? SubmitMetaTransactionSignedQuoteResponse\n            : SubmitMetaTransactionV2SignedQuoteResponse;\n    }\n\n    public async getStatusAsync(hash: string): Promise<StatusResponse | null> {\n        return this._rfqmService.getStatusAsync(hash);\n    }\n\n    /**\n     * Passthrough to RFQm Service's `runHealthCheckAsync` method\n     */\n    public async runHealthCheckAsync(): Promise<HealthCheckResult> {\n        return this._rfqmService.runHealthCheckAsync();\n    }\n\n    /**\n     * Passthrough to RFQm Service's `getTokenDecimalsAsync` method\n     */\n    public async getTokenDecimalsAsync(tokenAddress: string): Promise<number> {\n        return this._rfqmService.getTokenDecimalsAsync(tokenAddress);\n    }\n\n    private async _enqueueJobAsync(id: string, type: GaslessTypes): Promise<void> {\n        await this._sqsProducer.send({\n            groupId: id,\n            id,\n            body: JSON.stringify({ id, type }),\n            deduplicationId: id,\n        });\n    }\n\n    private async _doesMetaTransactionHashExistAsync(hash: string): Promise<boolean> {\n        return this._redis.get(metaTransactionHashRedisKey(hash)).then((r) => !!r);\n    }\n\n    private async _storeMetaTransactionHashAsync(hash: string): Promise<void> {\n        await this._redis.set(metaTransactionHashRedisKey(hash), /* value */ 0, 'EX', META_TRANSACTION_HASH_TTL_S);\n    }\n\n    private _getFeeConfigs(params: FetchQuoteParamsBase, integratorBillingType: 'on-chain' | 'off-chain'): FeeConfigs {\n        let integratorFeeConfig;\n\n        if (params.feeType && params.feeRecipient && params.feeSellTokenPercentage) {\n            integratorFeeConfig = {\n                type: params.feeType,\n                recipient: params.feeRecipient,\n                billingType: integratorBillingType,\n                sellTokenPercentage: params.feeSellTokenPercentage,\n            };\n        }\n\n        return getFeeConfigsFromParams({\n            integratorId: params.integrator.integratorId,\n            chainId: this._chainId,\n            sellToken: params.sellToken,\n            buyToken: params.buyToken,\n            integratorFeeConfig,\n        });\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/MetaTransactionClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_health_check.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/meta_transaction_fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/proto-ts/meta_transaction.pb.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ProtoUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_request_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/__tests__/RfqtHandlers.test.ts",{"fileContent":"// tslint:disable: max-file-line-count\nimport { ContractAddresses } from '@0x/contract-addresses';\nimport { OtcOrder } from '@0x/protocol-utils';\nimport { SignatureType } from '@0x/protocol-utils/lib/src/signature_utils';\nimport { FillQuoteTransformerOrderType } from '@0x/protocol-utils/lib/src/transformer_utils';\nimport { BigNumber } from '@0x/utils';\nimport * as express from 'express';\nimport * as asyncHandler from 'express-async-handler';\nimport * as HttpStatus from 'http-status-codes';\nimport { mapValues } from 'lodash';\nimport * as supertest from 'supertest';\n\nimport { Integrator } from '../../config';\nimport { QuoteRequestor, V4RFQIndicativeQuoteMM } from '../../quoteRequestor/QuoteRequestor';\nimport { FeeService } from '../../services/fee_service';\nimport { RfqtService } from '../../services/RfqtService';\nimport { RfqMakerBalanceCacheService } from '../../services/rfq_maker_balance_cache_service';\nimport type { RfqtV2Price, RfqtV2Quote, SignedNativeOrder } from '../../core/types';\nimport { ConfigManager } from '../../utils/config_manager';\nimport { QuoteServerClient } from '../../utils/quote_server_client';\nimport { RfqMakerManager } from '../../utils/rfq_maker_manager';\nimport { TokenMetadataManager } from '../../utils/TokenMetadataManager';\nimport { RfqtHandlers } from '../RfqtHandlers';\nimport { RfqBlockchainUtils } from '../../utils/rfq_blockchain_utils';\nimport { DEFAULT_MIN_EXPIRY_DURATION_MS } from '../../core/constants';\nimport { CacheClient } from '../../utils/cache_client';\n\njest.mock('../../services/RfqtService', () => {\n    return {\n        RfqtService: jest.fn().mockImplementation(() => {\n            return {\n                getV1PricesAsync: jest.fn(),\n                getV1QuotesAsync: jest.fn(),\n                getV2PricesAsync: jest.fn(),\n                getV2QuotesAsync: jest.fn(),\n            };\n        }),\n    };\n});\n\njest.mock('../../utils/config_manager', () => {\n    return {\n        ConfigManager: jest.fn().mockImplementation(() => {\n            return {\n                getIntegratorByIdOrThrow: jest.fn(),\n            };\n        }),\n    };\n});\n\n// tslint:disable: no-object-literal-type-assertion\nconst mockRfqtService = jest.mocked(\n    new RfqtService(\n        0,\n        {} as RfqMakerManager,\n        {} as QuoteRequestor,\n        {} as QuoteServerClient,\n        DEFAULT_MIN_EXPIRY_DURATION_MS,\n        {} as RfqBlockchainUtils,\n        {} as TokenMetadataManager,\n        {} as ContractAddresses,\n        {} as FeeService,\n        1,\n        {} as RfqMakerBalanceCacheService,\n        {} as CacheClient,\n    ),\n);\n// Jest workaround for getter\nmockRfqtService.feeModelVersion = 1;\nmockRfqtService.getTokenDecimalsAsync = jest.fn().mockResolvedValue(18);\n\nconst mockConfigManager = jest.mocked(new ConfigManager());\n// tslint:enable: no-object-literal-type-assertion\n\n// tslint:disable-next-line: custom-no-magic-numbers\nconst rfqtHandlers = new RfqtHandlers(new Map([[1337, mockRfqtService]]), mockConfigManager);\n\n/**\n * Verifies the proper response to a request using a mocked `RfqtService`.\n *\n * Each case sets up its own little Express app to avoid coupiling this\n * test to the upstream router.\n */\ndescribe('RfqtHandlers', () => {\n    describe('parameter verification with _parseV1RequestParameters', () => {\n        it('throws if a required parameter is missing', async () => {\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV1PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set('Content-type', 'application/json')\n                .send({ makerToken: '0xmakertoken' });\n\n            expect(response.body.error).toContain('missing parameters');\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n\n        it('throws if the chain ID is invalid', async () => {\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV1PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 'liger' })\n                .send({\n                    altRfqAssetOfferings: {},\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 'liger',\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Trade', // Invalid\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-integrator-id',\n                });\n\n            expect(response.body.error).toContain('Chain ID is invalid');\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n\n        it('throws with an invalid market operation', async () => {\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV1PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    altRfqAssetOfferings: {},\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Trade', // Invalid\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-integrator-id',\n                });\n\n            expect(response.body.error).toContain('invalid market operation');\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n\n        it('throws when the integrator does not exist', async () => {\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                throw new Error(\"explodes because the integrator doesn't exist\");\n            });\n\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV1PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    altRfqAssetOfferings: {},\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-ghost-integrator-id',\n                });\n\n            expect(response.body.error).toContain('No integrator found for integrator ID');\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n\n        it('throws if there is no RFQt service for the chain id', async () => {\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                const integrator: Integrator = {\n                    apiKeys: [],\n                    integratorId: 'uuid-integrator-id',\n                    // tslint:disable-next-line: custom-no-magic-numbers\n                    allowedChainIds: [1337],\n                    label: 'Polygon Swap Machine',\n                    plp: false,\n                    rfqm: false,\n                    rfqt: true,\n                };\n                return integrator;\n            });\n\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV1PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 21 })\n                .send({\n                    altRfqAssetOfferings: {},\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 21, // No RFQt service exists for 21\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-polygon-swap-machine',\n                });\n\n            expect(response.body.error).toContain('No configuration exists for chain');\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n    });\n\n    describe('getV1PriceAsync', () => {\n        it('responds with an error if the underlying service call fails', async () => {\n            mockRfqtService.getV1PricesAsync.mockRejectedValueOnce(new Error('The service blew up'));\n\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                const integrator: Integrator = {\n                    apiKeys: [],\n                    integratorId: 'uuid-integrator-id',\n                    // tslint:disable-next-line: custom-no-magic-numbers\n                    allowedChainIds: [1337],\n                    label: 'Polygon Swap Machine',\n                    plp: false,\n                    rfqm: false,\n                    rfqt: true,\n                };\n                return integrator;\n            });\n\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV1PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    altRfqAssetOfferings: {},\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-polygon-swap-machine',\n                });\n            expect(response.body.error).toContain('blew up');\n            expect(response.statusCode).toEqual(HttpStatus.INTERNAL_SERVER_ERROR);\n        });\n\n        it('passes calls on to RfqtService', async () => {\n            mockRfqtService.getV1PricesAsync.mockResolvedValue([]);\n\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                const integrator: Integrator = {\n                    apiKeys: [],\n                    integratorId: 'uuid-integrator-id',\n                    // tslint:disable-next-line: custom-no-magic-numbers\n                    allowedChainIds: [1337],\n                    label: 'Polygon Swap Machine',\n                    plp: false,\n                    rfqm: false,\n                    rfqt: true,\n                };\n                return integrator;\n            });\n\n            await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV1PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    altRfqAssetOfferings: {},\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-polygon-swap-machine',\n                });\n\n            expect(mockRfqtService.getV1PricesAsync.mock.calls[0]).toMatchInlineSnapshot(`\n                Array [\n                  Object {\n                    \"altRfqAssetOfferings\": Object {},\n                    \"assetFillAmount\": \"100\",\n                    \"chainId\": 1337,\n                    \"comparisonPrice\": undefined,\n                    \"integrator\": Object {\n                      \"allowedChainIds\": Array [\n                        1337,\n                      ],\n                      \"apiKeys\": Array [],\n                      \"integratorId\": \"uuid-integrator-id\",\n                      \"label\": \"Polygon Swap Machine\",\n                      \"plp\": false,\n                      \"rfqm\": false,\n                      \"rfqt\": true,\n                    },\n                    \"integratorId\": \"uuid-polygon-swap-machine\",\n                    \"intentOnFilling\": false,\n                    \"makerToken\": \"0xmakertoken\",\n                    \"marketOperation\": \"Buy\",\n                    \"takerAddress\": \"0xtakeraddress\",\n                    \"takerToken\": \"0xtakertoken\",\n                    \"txOrigin\": \"0xtxorigin\",\n                  },\n                ]\n            `);\n        });\n\n        it('returns prices from RFQt Service', async () => {\n            const price: V4RFQIndicativeQuoteMM = {\n                makerUri: 'http://maker-uri',\n                makerToken: '0xmakertoken',\n                makerAmount: new BigNumber(1234),\n                takerToken: '0xtakertoken',\n                takerAmount: new BigNumber(9876),\n                expiry: new BigNumber(6969642069),\n            };\n\n            mockRfqtService.getV1PricesAsync.mockResolvedValue([price]);\n\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                const integrator: Integrator = {\n                    apiKeys: [],\n                    integratorId: 'uuid-integrator-id',\n                    // tslint:disable-next-line: custom-no-magic-numbers\n                    allowedChainIds: [1337],\n                    label: 'Polygon Swap Machine',\n                    plp: false,\n                    rfqm: false,\n                    rfqt: true,\n                };\n                return integrator;\n            });\n\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV1PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    altRfqAssetOfferings: {},\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-polygon-swap-machine',\n                });\n\n            expect(response.body.prices[0]).toStrictEqual(convertBigNumbersToJson(price));\n            expect(response.statusCode).toEqual(HttpStatus.OK);\n        });\n    });\n\n    describe('getV1QuotesAsync', () => {\n        it('responds with an error if the underlying service call fails', async () => {\n            mockRfqtService.getV1QuotesAsync.mockRejectedValueOnce(new Error('The service blew up'));\n\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                const integrator: Integrator = {\n                    apiKeys: [],\n                    integratorId: 'uuid-integrator-id',\n                    // tslint:disable-next-line: custom-no-magic-numbers\n                    allowedChainIds: [1337],\n                    label: 'Polygon Swap Machine',\n                    plp: false,\n                    rfqm: false,\n                    rfqt: true,\n                };\n                return integrator;\n            });\n\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV1QuotesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    altRfqAssetOfferings: {},\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: true,\n                    integratorId: 'uuid-polygon-swap-machine',\n                });\n            expect(response.body.error).toContain('blew up');\n            expect(response.statusCode).toEqual(HttpStatus.INTERNAL_SERVER_ERROR);\n        });\n\n        it('passes calls on to RfqtService', async () => {\n            mockRfqtService.getV1QuotesAsync.mockResolvedValue([]);\n\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                const integrator: Integrator = {\n                    apiKeys: [],\n                    integratorId: 'uuid-integrator-id',\n                    // tslint:disable-next-line: custom-no-magic-numbers\n                    allowedChainIds: [1337],\n                    label: 'Polygon Swap Machine',\n                    plp: false,\n                    rfqm: false,\n                    rfqt: true,\n                };\n                return integrator;\n            });\n\n            await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV1QuotesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    altRfqAssetOfferings: {},\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: true,\n                    integratorId: 'uuid-polygon-swap-machine',\n                });\n\n            expect(mockRfqtService.getV1QuotesAsync.mock.calls[0]).toMatchInlineSnapshot(`\n                Array [\n                  Object {\n                    \"altRfqAssetOfferings\": Object {},\n                    \"assetFillAmount\": \"100\",\n                    \"chainId\": 1337,\n                    \"comparisonPrice\": undefined,\n                    \"integrator\": Object {\n                      \"allowedChainIds\": Array [\n                        1337,\n                      ],\n                      \"apiKeys\": Array [],\n                      \"integratorId\": \"uuid-integrator-id\",\n                      \"label\": \"Polygon Swap Machine\",\n                      \"plp\": false,\n                      \"rfqm\": false,\n                      \"rfqt\": true,\n                    },\n                    \"integratorId\": \"uuid-polygon-swap-machine\",\n                    \"intentOnFilling\": true,\n                    \"makerToken\": \"0xmakertoken\",\n                    \"marketOperation\": \"Buy\",\n                    \"takerAddress\": \"0xtakeraddress\",\n                    \"takerToken\": \"0xtakertoken\",\n                    \"txOrigin\": \"0xtxorigin\",\n                  },\n                ]\n            `);\n        });\n\n        it('returns quotes from RFQt Service', async () => {\n            const quote: SignedNativeOrder = {\n                order: {\n                    txOrigin: '0xtxorigin',\n                    pool: '0xswimmingpool',\n                    salt: new BigNumber(21),\n                    makerToken: '0xmakertoken',\n                    makerAmount: new BigNumber(1234),\n                    takerToken: '0xtakertoken',\n                    takerAmount: new BigNumber(9876),\n                    expiry: new BigNumber(6969642069),\n                    maker: '0xmakeraddress',\n                    taker: '0xtakeraddress',\n                    chainId: 1337,\n                    verifyingContract: '0xdef1',\n                },\n                type: FillQuoteTransformerOrderType.Rfq,\n                signature: {\n                    v: 1,\n                    r: '',\n                    s: '',\n                    signatureType: SignatureType.EthSign,\n                },\n            };\n\n            mockRfqtService.getV1QuotesAsync.mockResolvedValue([quote]);\n\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                const integrator: Integrator = {\n                    apiKeys: [],\n                    integratorId: 'uuid-integrator-id',\n                    // tslint:disable-next-line: custom-no-magic-numbers\n                    allowedChainIds: [1337],\n                    label: 'Polygon Swap Machine',\n                    plp: false,\n                    rfqm: false,\n                    rfqt: true,\n                };\n                return integrator;\n            });\n\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV1QuotesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    altRfqAssetOfferings: {},\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-polygon-swap-machine',\n                });\n\n            expect(response.body.quotes[0]).toStrictEqual(convertBigNumbersToJson(quote));\n            expect(response.statusCode).toEqual(HttpStatus.OK);\n        });\n    });\n\n    describe('parameter verification with _retrieveQuoteContext', () => {\n        it('throws if a required parameter is missing', async () => {\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV2PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({ makerToken: '0xmakertoken' });\n\n            expect(response.body.error).toContain('missing parameter');\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n\n        it('throws if the chain ID is invalid', async () => {\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV2PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 'liger' })\n                .send({\n                    altRfqAssetOfferings: {},\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 'liger',\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Trade', // Invalid\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-integrator-id',\n                });\n\n            expect(response.body.error).toContain('Chain ID is invalid');\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n\n        it('throws with an invalid market operation', async () => {\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV2PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    altRfqAssetOfferings: {},\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Trade', // Invalid\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-integrator-id',\n                });\n\n            expect(response.body.error).toContain('invalid market operation');\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n\n        it('throws when the integrator does not exist', async () => {\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                throw new Error(\"explodes because the integrator doesn't exist\");\n            });\n\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV2PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    altRfqAssetOfferings: {},\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-ghost-integrator-id',\n                });\n\n            expect(response.body.error).toContain('No integrator found for integrator ID');\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n\n        it('throws if there is no RFQt service for the chain id', async () => {\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                const integrator: Integrator = {\n                    apiKeys: [],\n                    integratorId: 'uuid-integrator-id',\n                    // tslint:disable-next-line: custom-no-magic-numbers\n                    allowedChainIds: [1337],\n                    label: 'Polygon Swap Machine',\n                    plp: false,\n                    rfqm: false,\n                    rfqt: true,\n                };\n                return integrator;\n            });\n\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV2PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 21 })\n                .send({\n                    altRfqAssetOfferings: {},\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 21, // No RFQt service exists for 21\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-polygon-swap-machine',\n                });\n\n            expect(response.body.error).toContain('No configuration exists for chain');\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n    });\n\n    describe('getV2PriceAsync', () => {\n        it('responds with an error if the underlying service call fails', async () => {\n            mockRfqtService.getV2PricesAsync.mockRejectedValueOnce(new Error('The service blew up'));\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                const integrator: Integrator = {\n                    apiKeys: [],\n                    integratorId: 'uuid-integrator-id',\n                    // tslint:disable-next-line: custom-no-magic-numbers\n                    allowedChainIds: [1337],\n                    label: 'Polygon Swap Machine',\n                    plp: false,\n                    rfqm: false,\n                    rfqt: true,\n                };\n                return integrator;\n            });\n\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV2PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-polygon-swap-machine',\n                });\n            expect(response.body.error).toContain('blew up');\n            expect(response.statusCode).toEqual(HttpStatus.INTERNAL_SERVER_ERROR);\n        });\n\n        it('passes calls on to RfqtService', async () => {\n            mockRfqtService.getV2PricesAsync.mockResolvedValue([]);\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                const integrator: Integrator = {\n                    apiKeys: [],\n                    integratorId: 'uuid-integrator-id',\n                    // tslint:disable-next-line: custom-no-magic-numbers\n                    allowedChainIds: [1337],\n                    label: 'Polygon Swap Machine',\n                    plp: false,\n                    rfqm: false,\n                    rfqt: true,\n                };\n                return integrator;\n            });\n\n            await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV2PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-polygon-swap-machine',\n                });\n\n            expect(mockRfqtService.getV2PricesAsync.mock.calls[0]).toMatchInlineSnapshot(`\n                Array [\n                  Object {\n                    \"assetFillAmount\": \"100\",\n                    \"bucket\": undefined,\n                    \"chainId\": 1337,\n                    \"feeModelVersion\": 1,\n                    \"integrator\": Object {\n                      \"allowedChainIds\": Array [\n                        1337,\n                      ],\n                      \"apiKeys\": Array [],\n                      \"integratorId\": \"uuid-integrator-id\",\n                      \"label\": \"Polygon Swap Machine\",\n                      \"plp\": false,\n                      \"rfqm\": false,\n                      \"rfqt\": true,\n                    },\n                    \"isFirm\": false,\n                    \"isSelling\": false,\n                    \"isUnwrap\": false,\n                    \"makerAmount\": \"100\",\n                    \"makerToken\": \"0xmakertoken\",\n                    \"makerTokenDecimals\": 18,\n                    \"originalMakerToken\": \"0xmakertoken\",\n                    \"takerAddress\": \"0xtakeraddress\",\n                    \"takerAmount\": undefined,\n                    \"takerToken\": \"0xtakertoken\",\n                    \"takerTokenDecimals\": 18,\n                    \"trader\": \"0xtakeraddress\",\n                    \"txOrigin\": \"0xtxorigin\",\n                    \"workflow\": \"rfqt\",\n                  },\n                ]\n            `);\n        });\n\n        it('returns prices from RFQt Service', async () => {\n            const prices: RfqtV2Price[] = [\n                {\n                    makerId: 'maker1',\n                    makerUri: 'http://maker-uri',\n                    makerAddress: 'maker-address',\n                    makerToken: '0xmakertoken',\n                    makerAmount: new BigNumber(1234),\n                    takerToken: '0xtakertoken',\n                    takerAmount: new BigNumber(9876),\n                    expiry: new BigNumber(6969642069),\n                },\n            ];\n\n            mockRfqtService.getV2PricesAsync.mockResolvedValue(prices);\n\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                const integrator: Integrator = {\n                    apiKeys: [],\n                    integratorId: 'uuid-integrator-id',\n                    // tslint:disable-next-line: custom-no-magic-numbers\n                    allowedChainIds: [1337],\n                    label: 'Polygon Swap Machine',\n                    plp: false,\n                    rfqm: false,\n                    rfqt: true,\n                };\n                return integrator;\n            });\n\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV2PricesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-polygon-swap-machine',\n                });\n\n            expect(response.body.prices[0]).toStrictEqual(convertBigNumbersToJson(prices[0]));\n            expect(response.statusCode).toEqual(HttpStatus.OK);\n        });\n    });\n\n    describe('getV2QuotesAsync', () => {\n        it('responds with an error if the underlying service call fails', async () => {\n            mockRfqtService.getV2QuotesAsync.mockRejectedValueOnce(new Error('The service blew up'));\n\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                const integrator: Integrator = {\n                    apiKeys: [],\n                    integratorId: 'uuid-integrator-id',\n                    // tslint:disable-next-line: custom-no-magic-numbers\n                    allowedChainIds: [1337],\n                    label: 'Polygon Swap Machine',\n                    plp: false,\n                    rfqm: false,\n                    rfqt: true,\n                };\n                return integrator;\n            });\n\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV2QuotesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: true,\n                    integratorId: 'uuid-polygon-swap-machine',\n                });\n            expect(response.body.error).toContain('blew up');\n            expect(response.statusCode).toEqual(HttpStatus.INTERNAL_SERVER_ERROR);\n        });\n\n        it('passes calls on to RfqtService', async () => {\n            mockRfqtService.getV2QuotesAsync.mockResolvedValue([]);\n\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                const integrator: Integrator = {\n                    apiKeys: [],\n                    integratorId: 'uuid-integrator-id',\n                    // tslint:disable-next-line: custom-no-magic-numbers\n                    allowedChainIds: [1337],\n                    label: 'Polygon Swap Machine',\n                    plp: false,\n                    rfqm: false,\n                    rfqt: true,\n                };\n                return integrator;\n            });\n\n            await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV2QuotesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: true,\n                    integratorId: 'uuid-polygon-swap-machine',\n                });\n\n            expect(mockRfqtService.getV2QuotesAsync.mock.calls[0]).toMatchInlineSnapshot(`\n                Array [\n                  Object {\n                    \"assetFillAmount\": \"100\",\n                    \"bucket\": undefined,\n                    \"chainId\": 1337,\n                    \"feeModelVersion\": 1,\n                    \"integrator\": Object {\n                      \"allowedChainIds\": Array [\n                        1337,\n                      ],\n                      \"apiKeys\": Array [],\n                      \"integratorId\": \"uuid-integrator-id\",\n                      \"label\": \"Polygon Swap Machine\",\n                      \"plp\": false,\n                      \"rfqm\": false,\n                      \"rfqt\": true,\n                    },\n                    \"isFirm\": true,\n                    \"isSelling\": false,\n                    \"isUnwrap\": false,\n                    \"makerAmount\": \"100\",\n                    \"makerToken\": \"0xmakertoken\",\n                    \"makerTokenDecimals\": 18,\n                    \"originalMakerToken\": \"0xmakertoken\",\n                    \"takerAddress\": \"0xtakeraddress\",\n                    \"takerAmount\": undefined,\n                    \"takerToken\": \"0xtakertoken\",\n                    \"takerTokenDecimals\": 18,\n                    \"trader\": \"0xtakeraddress\",\n                    \"txOrigin\": \"0xtxorigin\",\n                    \"workflow\": \"rfqt\",\n                  },\n                ]\n            `);\n        });\n\n        it('returns quotes from RFQt Service', async () => {\n            const quotes: RfqtV2Quote[] = [\n                {\n                    fillableMakerAmount: new BigNumber(1234),\n                    fillableTakerAmount: new BigNumber(9876),\n                    fillableTakerFeeAmount: new BigNumber(0),\n                    makerId: 'maker1',\n                    makerUri: 'https://maker-uri',\n                    order: new OtcOrder({\n                        txOrigin: '0xtxorigin',\n                        makerToken: '0xmakertoken',\n                        makerAmount: new BigNumber(1234),\n                        takerToken: '0xtakertoken',\n                        takerAmount: new BigNumber(9876),\n                        expiryAndNonce: new BigNumber(6969642069),\n                        maker: '0xmakeraddress',\n                        taker: '0xtakeraddress',\n                        chainId: 1337,\n                        verifyingContract: '0xdef1',\n                    }),\n                    signature: {\n                        v: 1,\n                        r: '',\n                        s: '',\n                        signatureType: SignatureType.EthSign,\n                    },\n                },\n            ];\n\n            mockRfqtService.getV2QuotesAsync.mockResolvedValue(quotes);\n\n            mockConfigManager.getIntegratorByIdOrThrow.mockImplementationOnce(() => {\n                const integrator: Integrator = {\n                    apiKeys: [],\n                    integratorId: 'uuid-integrator-id',\n                    // tslint:disable-next-line: custom-no-magic-numbers\n                    allowedChainIds: [1337],\n                    label: 'Polygon Swap Machine',\n                    plp: false,\n                    rfqm: false,\n                    rfqt: true,\n                };\n                return integrator;\n            });\n\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/', asyncHandler(rfqtHandlers.getV2QuotesAsync.bind(rfqtHandlers))),\n            )\n                .post('/')\n                .set({ 'Content-type': 'application/json', '0x-chain-id': 1337 })\n                .send({\n                    assetFillAmount: new BigNumber(100),\n                    chainId: 1337,\n                    makerToken: '0xmakertoken',\n                    marketOperation: 'Buy',\n                    takerToken: '0xtakertoken',\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorigin',\n                    intentOnFilling: false,\n                    integratorId: 'uuid-polygon-swap-machine',\n                });\n\n            expect(response.body.quotes[0]).toStrictEqual(convertBigNumbersToJson(quotes[0]));\n            expect(response.statusCode).toEqual(HttpStatus.OK);\n        });\n    });\n});\n\n/**\n * Deeply transforms object keys from BigNumber to JSON\n */\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction convertBigNumbersToJson(x: Record<string, any>): Record<string, any> {\n    return mapValues(x, (v) => {\n        if (v instanceof BigNumber) {\n            return v.toJSON();\n        }\n        if (v instanceof Object) {\n            return convertBigNumbersToJson(v);\n        }\n        return v;\n    });\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/QuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/RfqtService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/RfqtHandlers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmImplementaionUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmTypes.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/rfqMakerBlacklist.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/number_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/RfqtQuoteValidator.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqtServiceBuilder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/MetaTransactionClient.test.ts",{"fileContent":"import { ValidationError, ValidationErrorCodes } from '@0x/api-utils';\nimport { MetaTransaction } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport Axios, { AxiosInstance } from 'axios';\nimport AxiosMockAdapter from 'axios-mock-adapter';\nimport { BAD_REQUEST, NOT_ACCEPTABLE, OK } from 'http-status-codes';\nimport { TwirpError } from 'twirpscript';\nimport { APIErrorCodes, apiErrorCodesToReasons } from '../../src/core/errors';\nimport { GetQuote, GetQuoteResponse } from '../../src/proto-ts/meta_transaction.pb';\nimport { getV1QuoteAsync, getQuoteRpc, getV2QuoteAsync } from '../../src/utils/MetaTransactionClient';\nimport { bigNumberToProto, protoToBigNumber } from '../../src/utils/ProtoUtils';\nimport { GaslessTypes } from '../../src/core/types';\n\njest.mock('../../src/proto-ts/meta_transaction.pb');\nconst mockGetQuote = jest.mocked(GetQuote);\n\nlet axiosClient: AxiosInstance;\nlet axiosMock: AxiosMockAdapter;\n\ndescribe('MetaTransactionClient', () => {\n    const integratorAddress = '0x4ea754349ace5303c82f0d1d491041e042f2ad22';\n    const zeroExAddress = '0x4ea754349ace5303c82f0d1d491041e042f2ad22';\n\n    beforeAll(() => {\n        axiosClient = Axios.create();\n        axiosMock = new AxiosMockAdapter(axiosClient);\n    });\n    describe('getV1QuoteAsync', () => {\n        it('should get a metatransaction quote', async () => {\n            const exampleSuccessfulResponse = {\n                allowanceTarget: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                buyAmount: '1800054805473',\n                buyTokenAddress: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                buyTokenToEthRate: '0.851202',\n                chainId: 137,\n                estimatedGas: '1043459',\n                estimatedPriceImpact: '1.6301',\n                gas: '1043459',\n                gasPrice: '115200000000',\n                minimumProtocolFee: '0',\n                metaTransaction: {\n                    callData:\n                        '0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000019eeab6030b00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac1897880000000000000000000000000000000000000000000000000000003f47a215c5000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c4bc40000000000000000000000000000000000000000000000000000001f2c6f738e000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c4bc40000000000000000000000000000000000000000000000000000001f811895a7000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000001d30a7ac56da56396a000000000000000000000000000000000000000000000000000000e10b7768e500000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e6973776170563300000000000000000000000000000000000000000000000000000000000008570b55cfac1897880000000000000000000000000000000000000000000000000000003fea147b29000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c630000000000000000000000000000000000000000000000f789bac21b62fed5ef',\n                    domain: {\n                        chainId: 137,\n                        verifyingContract: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                    },\n                    expirationTimeSeconds: '1660868679',\n                    feeAmount: '0',\n                    feeToken: '0x0000000000000000000000000000000000000000',\n                    maxGasPrice: '4294967296',\n                    minGasPrice: '1',\n                    salt: '32606650794224189614795510724011106220035660490560169776986607186708081701146',\n                    sender: '0x0000000000000000000000000000000000000000',\n                    signer: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                    value: '0',\n                },\n                metaTransactionHash: '0x16688406783c0e721a69e5c9f2727e2d30f24a0669522c1fb6937460348b4095',\n                price: '1800.054805',\n                protocolFee: '0',\n                sellAmount: '1000000000000000000000',\n                sellTokenAddress: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                sellTokenToEthRate: '0.000465167371348443',\n                sources: [\n                    {\n                        name: 'SushiSwap',\n                        proportion: '0',\n                    },\n                    {\n                        name: 'QuickSwap',\n                        proportion: '0.2308',\n                    },\n                    {\n                        name: 'DODO_V2',\n                        proportion: '0.07692',\n                    },\n                    {\n                        name: 'Uniswap_V3',\n                        proportion: '0.6923',\n                    },\n                ],\n                value: '0',\n            };\n\n            const url = new URL('https://quoteserver.pizza/quote');\n\n            axiosMock.onGet(url.toString()).replyOnce(OK, exampleSuccessfulResponse);\n\n            const response = await getV1QuoteAsync(axiosClient, url, {\n                buyToken: 'USDC',\n                chainId: 137,\n                integratorId: 'integrator-id',\n                sellToken: 'WETH',\n                sellAmount: new BigNumber(1000000000000000000000),\n                takerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n            });\n\n            expect(response?.trade.kind).toEqual(GaslessTypes.MetaTransaction);\n            expect(response?.trade.metaTransaction.getHash()).toEqual(exampleSuccessfulResponse.metaTransactionHash);\n            expect(response?.price).toEqual({\n                buyAmount: new BigNumber(exampleSuccessfulResponse.buyAmount),\n                buyTokenAddress: exampleSuccessfulResponse.buyTokenAddress,\n                gas: new BigNumber(exampleSuccessfulResponse.gas),\n                price: new BigNumber(exampleSuccessfulResponse.price),\n                sellAmount: new BigNumber(exampleSuccessfulResponse.sellAmount),\n                sellTokenAddress: exampleSuccessfulResponse.sellTokenAddress,\n            });\n        });\n\n        it('should return `null` when no liquidity is available', async () => {\n            const exampleNoLiquidityResponse = {\n                code: 100,\n                reason: 'Validation Failed',\n                validationErrors: [\n                    {\n                        field: 'sellAmount',\n                        code: 1004,\n                        reason: 'INSUFFICIENT_ASSET_LIQUIDITY',\n                    },\n                ],\n            };\n\n            const url = new URL('https://quoteserver.pizza/quote');\n\n            axiosMock.onGet(url.toString()).replyOnce(BAD_REQUEST, exampleNoLiquidityResponse);\n\n            const response = await getV1QuoteAsync(axiosClient, url, {\n                buyToken: 'USDC',\n                chainId: 137,\n                integratorId: 'integrator-id',\n                sellToken: '0x0000000000000000000000000000000000000000',\n                sellAmount: new BigNumber(1000000000000000000000),\n                takerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                slippagePercentage: new BigNumber(0.2),\n            });\n\n            expect(response).toBeNull();\n        });\n\n        it('should throw validation error when meta-transaction server returns the insufficient fund error', async () => {\n            const exampleInsufficientFundErrorResponse = {\n                code: APIErrorCodes.InsufficientFundsError,\n                reason: apiErrorCodesToReasons[APIErrorCodes.InsufficientFundsError],\n            };\n\n            const url = new URL('https://quoteserver.pizza/quote');\n\n            axiosMock.onGet(url.toString()).reply(BAD_REQUEST, exampleInsufficientFundErrorResponse);\n\n            await expect(() =>\n                getV1QuoteAsync(axiosClient, url, {\n                    buyToken: 'USDC',\n                    chainId: 137,\n                    integratorId: 'integrator-id',\n                    sellToken: '0x0000000000000000000000000000000000000000',\n                    sellAmount: new BigNumber(1000000000000000000000),\n                    takerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                    slippagePercentage: new BigNumber(0.2),\n                }),\n            ).rejects.toThrow(ValidationError);\n        });\n\n        it(\"should throw an error if the response doesn't match the no liquidity response + the insufficient fund error\", async () => {\n            const url = new URL('https://quoteserver.pizza/quote');\n\n            axiosMock.onGet(url.toString()).replyOnce(NOT_ACCEPTABLE);\n\n            await expect(() =>\n                getV1QuoteAsync(axiosClient, url, {\n                    buyToken: 'USDC',\n                    chainId: 137,\n                    integratorId: 'integrator-id',\n                    sellToken: '0x0000000000000000000000000000000000000000',\n                    sellAmount: new BigNumber(1000000000000000000000),\n                    takerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                }),\n            ).rejects.toThrow();\n        });\n\n        it('should throw if computed meta-transaction hash is different from the hash in response', async () => {\n            const exampleSuccessfulResponse = {\n                allowanceTarget: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                buyAmount: '1800054805473',\n                buyTokenAddress: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                buyTokenToEthRate: '0.851202',\n                chainId: 137,\n                estimatedGas: '1043459',\n                estimatedPriceImpact: '1.6301',\n                gas: '1043459',\n                gasPrice: '115200000000',\n                minimumProtocolFee: '0',\n                metaTransaction: {\n                    callData:\n                        '0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000019eeab6030b00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac1897880000000000000000000000000000000000000000000000000000003f47a215c5000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c4bc40000000000000000000000000000000000000000000000000000001f2c6f738e000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c4bc40000000000000000000000000000000000000000000000000000001f811895a7000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000001d30a7ac56da56396a000000000000000000000000000000000000000000000000000000e10b7768e500000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e6973776170563300000000000000000000000000000000000000000000000000000000000008570b55cfac1897880000000000000000000000000000000000000000000000000000003fea147b29000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c630000000000000000000000000000000000000000000000f789bac21b62fed5ef',\n                    domain: {\n                        chainId: 137,\n                        verifyingContract: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                    },\n                    expirationTimeSeconds: '1660868679',\n                    feeAmount: '0',\n                    feeToken: '0x0000000000000000000000000000000000000000',\n                    maxGasPrice: '4294967296',\n                    minGasPrice: '1',\n                    salt: '32606650794224189614795510724011106220035660490560169776986607186708081701146',\n                    sender: '0x0000000000000000000000000000000000000000',\n                    signer: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                    value: '0',\n                },\n                metaTransactionHash: '0x16688406783c0e721a69e5c9f2727e2d30f24a0669522c1fb6937460348b4094',\n                price: '1800.054805',\n                protocolFee: '0',\n                sellAmount: '1000000000000000000000',\n                sellTokenAddress: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                sellTokenToEthRate: '0.000465167371348443',\n                sources: [\n                    {\n                        name: 'SushiSwap',\n                        proportion: '0',\n                    },\n                    {\n                        name: 'QuickSwap',\n                        proportion: '0.2308',\n                    },\n                    {\n                        name: 'DODO_V2',\n                        proportion: '0.07692',\n                    },\n                    {\n                        name: 'Uniswap_V3',\n                        proportion: '0.6923',\n                    },\n                ],\n                value: '0',\n            };\n\n            const url = new URL('https://quoteserver.pizza/quote');\n\n            axiosMock.onGet(url.toString()).replyOnce(OK, exampleSuccessfulResponse);\n\n            await expect(() =>\n                getV1QuoteAsync(axiosClient, url, {\n                    buyToken: 'USDC',\n                    chainId: 137,\n                    integratorId: 'integrator-id',\n                    sellToken: 'WETH',\n                    sellAmount: new BigNumber(1000000000000000000000),\n                    takerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                }),\n            ).rejects.toThrow();\n        });\n    });\n\n    describe('getV2QuoteAsync', () => {\n        it('should get a metatransaction quote', async () => {\n            const exampleSuccessfulResponse = {\n                allowanceTarget: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                buyAmount: '1800054805473',\n                buyTokenAddress: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                buyTokenToEthRate: '0.851202',\n                chainId: 137,\n                estimatedGas: '1043459',\n                estimatedPriceImpact: '1.6301',\n                gas: '1043459',\n                gasPrice: '115200000000',\n                minimumProtocolFee: '0',\n                trade: {\n                    kind: 'metatransaction',\n                    hash: '0x16688406783c0e721a69e5c9f2727e2d30f24a0669522c1fb6937460348b4095',\n                    metaTransaction: {\n                        callData:\n                            '0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000019eeab6030b00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac1897880000000000000000000000000000000000000000000000000000003f47a215c5000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c4bc40000000000000000000000000000000000000000000000000000001f2c6f738e000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c4bc40000000000000000000000000000000000000000000000000000001f811895a7000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000001d30a7ac56da56396a000000000000000000000000000000000000000000000000000000e10b7768e500000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e6973776170563300000000000000000000000000000000000000000000000000000000000008570b55cfac1897880000000000000000000000000000000000000000000000000000003fea147b29000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c630000000000000000000000000000000000000000000000f789bac21b62fed5ef',\n                        chainId: 137,\n                        verifyingContract: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                        expirationTimeSeconds: '1660868679',\n                        feeAmount: '0',\n                        feeToken: '0x0000000000000000000000000000000000000000',\n                        maxGasPrice: '4294967296',\n                        minGasPrice: '1',\n                        salt: '32606650794224189614795510724011106220035660490560169776986607186708081701146',\n                        sender: '0x0000000000000000000000000000000000000000',\n                        signer: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                        value: '0',\n                    },\n                },\n                price: '1800.054805',\n                protocolFee: '0',\n                sellAmount: '1000000000000000000000',\n                sellTokenAddress: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                sellTokenToEthRate: '0.000465167371348443',\n                sources: [\n                    {\n                        name: 'SushiSwap',\n                        proportion: '0',\n                    },\n                    {\n                        name: 'QuickSwap',\n                        proportion: '0.2308',\n                    },\n                    {\n                        name: '\"Aave_V2',\n                        proportion: '0',\n                    },\n                    {\n                        name: 'DODO_V2',\n                        proportion: '0.07692',\n                    },\n                    {\n                        name: 'Uniswap_V3',\n                        proportion: '0.6923',\n                    },\n                ],\n                value: '0',\n                fees: {\n                    integratorFee: {\n                        type: 'volume',\n                        feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        feeAmount: '1000000000000000000',\n                        feeRecipient: integratorAddress,\n                        volumePercentage: '0.1',\n                    },\n                    zeroExFee: {\n                        type: 'integrator_share',\n                        feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        feeAmount: '1000000000000000',\n                        feeRecipient: zeroExAddress,\n                        integratorSharePercentage: '0.1',\n                    },\n                    gasFee: {\n                        type: 'gas',\n                        gasPrice: '115200000000',\n                        feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        feeAmount: '10000000',\n                        feeRecipient: null,\n                        estimatedGas: '1043459',\n                        feeTokenAmountPerBaseUnitNativeToken: '0.001',\n                    },\n                },\n            };\n\n            const url = new URL('https://quoteserver.pizza/quote');\n\n            axiosMock.onPost(url.toString()).replyOnce(OK, exampleSuccessfulResponse);\n\n            const response = await getV2QuoteAsync(axiosClient, url, {\n                buyToken: 'USDC',\n                chainId: 137,\n                integratorId: 'integrator-id',\n                sellToken: 'WETH',\n                sellAmount: new BigNumber(1000000000000000000000),\n                takerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n            });\n\n            expect(response?.trade.kind).toEqual(GaslessTypes.MetaTransaction);\n            expect(response?.trade.metaTransaction.getHash()).toEqual(exampleSuccessfulResponse.trade.hash);\n            expect(response?.price).toEqual({\n                buyAmount: new BigNumber(exampleSuccessfulResponse.buyAmount),\n                buyTokenAddress: exampleSuccessfulResponse.buyTokenAddress,\n                gas: new BigNumber(exampleSuccessfulResponse.gas),\n                price: new BigNumber(exampleSuccessfulResponse.price),\n                sellAmount: new BigNumber(exampleSuccessfulResponse.sellAmount),\n                sellTokenAddress: exampleSuccessfulResponse.sellTokenAddress,\n            });\n            expect(response?.sources).toEqual([\n                {\n                    name: 'QuickSwap',\n                    proportion: new BigNumber('0.2308'),\n                },\n                {\n                    name: 'DODO_V2',\n                    proportion: new BigNumber('0.07692'),\n                },\n                {\n                    name: 'Uniswap_V3',\n                    proportion: new BigNumber('0.6923'),\n                },\n            ]);\n            expect(response?.fees).toEqual({\n                integratorFee: {\n                    type: 'volume',\n                    feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                    feeAmount: new BigNumber(1000000000000000000),\n                    feeRecipient: integratorAddress,\n                    volumePercentage: new BigNumber(0.1),\n                },\n                zeroExFee: {\n                    type: 'integrator_share',\n                    feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                    feeAmount: new BigNumber(1000000000000000),\n                    feeRecipient: zeroExAddress,\n                    integratorSharePercentage: new BigNumber(0.1),\n                },\n                gasFee: {\n                    type: 'gas',\n                    gasPrice: new BigNumber(115200000000),\n                    feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                    feeAmount: new BigNumber(10000000),\n                    feeRecipient: null,\n                    estimatedGas: new BigNumber(1043459),\n                    feeTokenAmountPerBaseUnitNativeToken: new BigNumber(0.001),\n                },\n            });\n        });\n\n        it('should return `null` when no liquidity is available', async () => {\n            const exampleNoLiquidityResponse = {\n                code: 100,\n                reason: 'Validation Failed',\n                validationErrors: [\n                    {\n                        field: 'sellAmount',\n                        code: 1004,\n                        reason: 'INSUFFICIENT_ASSET_LIQUIDITY',\n                    },\n                ],\n            };\n\n            const url = new URL('https://quoteserver.pizza/quote');\n\n            axiosMock.onPost(url.toString()).replyOnce(BAD_REQUEST, exampleNoLiquidityResponse);\n\n            const response = await getV2QuoteAsync(axiosClient, url, {\n                buyToken: 'USDC',\n                chainId: 137,\n                integratorId: 'integrator-id',\n                sellToken: '0x0000000000000000000000000000000000000000',\n                sellAmount: new BigNumber(1000000000000000000000),\n                takerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                slippagePercentage: new BigNumber(0.2),\n            });\n\n            expect(response).toBeNull();\n        });\n\n        it('should throw validation error when meta-transaction server returns the insufficient fund error', async () => {\n            const exampleInsufficientFundErrorResponse = {\n                code: APIErrorCodes.InsufficientFundsError,\n                reason: apiErrorCodesToReasons[APIErrorCodes.InsufficientFundsError],\n            };\n\n            const url = new URL('https://quoteserver.pizza/quote');\n\n            axiosMock.onPost(url.toString()).reply(BAD_REQUEST, exampleInsufficientFundErrorResponse);\n\n            await expect(() =>\n                getV2QuoteAsync(axiosClient, url, {\n                    buyToken: 'USDC',\n                    chainId: 137,\n                    integratorId: 'integrator-id',\n                    sellToken: '0x0000000000000000000000000000000000000000',\n                    sellAmount: new BigNumber(1000000000000000000000),\n                    takerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                    slippagePercentage: new BigNumber(0.2),\n                }),\n            ).rejects.toThrow(ValidationError);\n        });\n\n        it(\"should throw an error if the response doesn't match the no liquidity response + the insufficient fund error\", async () => {\n            const url = new URL('https://quoteserver.pizza/quote');\n\n            axiosMock.onPost(url.toString()).replyOnce(NOT_ACCEPTABLE);\n\n            await expect(() =>\n                getV2QuoteAsync(axiosClient, url, {\n                    buyToken: 'USDC',\n                    chainId: 137,\n                    integratorId: 'integrator-id',\n                    sellToken: '0x0000000000000000000000000000000000000000',\n                    sellAmount: new BigNumber(1000000000000000000000),\n                    takerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                }),\n            ).rejects.toThrow();\n        });\n\n        it('should throw if computed meta-transaction hash is different from the hash in response', async () => {\n            const exampleSuccessfulResponse = {\n                allowanceTarget: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                buyAmount: '1800054805473',\n                buyTokenAddress: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                buyTokenToEthRate: '0.851202',\n                chainId: 137,\n                estimatedGas: '1043459',\n                estimatedPriceImpact: '1.6301',\n                gas: '1043459',\n                gasPrice: '115200000000',\n                minimumProtocolFee: '0',\n                trade: {\n                    kind: 'metatransaction',\n                    hash: '0x16688406783c0e721a69e5c9f2727e2d30f24a0669522c1fb6937460348b4094',\n                    metaTransaction: {\n                        callData:\n                            '0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000019eeab6030b00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac1897880000000000000000000000000000000000000000000000000000003f47a215c5000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c4bc40000000000000000000000000000000000000000000000000000001f2c6f738e000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c4bc40000000000000000000000000000000000000000000000000000001f811895a7000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000001d30a7ac56da56396a000000000000000000000000000000000000000000000000000000e10b7768e500000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e6973776170563300000000000000000000000000000000000000000000000000000000000008570b55cfac1897880000000000000000000000000000000000000000000000000000003fea147b29000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c630000000000000000000000000000000000000000000000f789bac21b62fed5ef',\n                        chainId: 137,\n                        verifyingContract: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                        expirationTimeSeconds: '1660868679',\n                        feeAmount: '0',\n                        feeToken: '0x0000000000000000000000000000000000000000',\n                        maxGasPrice: '4294967296',\n                        minGasPrice: '1',\n                        salt: '32606650794224189614795510724011106220035660490560169776986607186708081701146',\n                        sender: '0x0000000000000000000000000000000000000000',\n                        signer: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                        value: '0',\n                    },\n                },\n                price: '1800.054805',\n                protocolFee: '0',\n                sellAmount: '1000000000000000000000',\n                sellTokenAddress: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                sellTokenToEthRate: '0.000465167371348443',\n                sources: [\n                    {\n                        name: 'SushiSwap',\n                        proportion: '0',\n                    },\n                    {\n                        name: 'QuickSwap',\n                        proportion: '0.2308',\n                    },\n                    {\n                        name: '\"Aave_V2',\n                        proportion: '0',\n                    },\n                    {\n                        name: 'DODO_V2',\n                        proportion: '0.07692',\n                    },\n                    {\n                        name: 'Uniswap_V3',\n                        proportion: '0.6923',\n                    },\n                ],\n                value: '0',\n                fees: {\n                    integratorFee: {\n                        type: 'volume',\n                        feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        feeAmount: '1000000000000000000',\n                        feeRecipient: integratorAddress,\n                        volumePercentage: '0.1',\n                    },\n                    zeroExFee: {\n                        type: 'integrator_share',\n                        feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        feeAmount: '1000000000000000',\n                        feeRecipient: zeroExAddress,\n                        integratorSharePercentage: '0.1',\n                    },\n                    gasFee: {\n                        type: 'gas',\n                        gasPrice: '115200000000',\n                        feeToken: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                        feeAmount: '10000000',\n                        feeRecipient: null,\n                        estimatedGas: '1043459',\n                        feeTokenAmountPerBaseUnitNativeToken: '0.001',\n                    },\n                },\n            };\n\n            const url = new URL('https://quoteserver.pizza/quote');\n\n            axiosMock.onPost(url.toString()).replyOnce(OK, exampleSuccessfulResponse);\n\n            await expect(() =>\n                getV2QuoteAsync(axiosClient, url, {\n                    buyToken: 'USDC',\n                    chainId: 137,\n                    integratorId: 'integrator-id',\n                    sellToken: '0x0000000000000000000000000000000000000000',\n                    sellAmount: new BigNumber(1000000000000000000000),\n                    takerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                }),\n            ).rejects.toThrow();\n        });\n    });\n\n    describe('getQuoteRpc', () => {\n        it('gets a quote', async () => {\n            const mockResponse: GetQuoteResponse = {\n                metaTransaction: {\n                    callData:\n                        '0x415565b00000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000019eeab6030b00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000086000000000000000000000000000000000000000000000000000000000000007c000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000002517569636b5377617000000000000000000000000000000000000000000000000000000000000008570b55cfac1897880000000000000000000000000000000000000000000000000000003f47a215c5000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000002517569636b53776170000000000000000000000000000000000000000000000000000000000000042b85aae7d60c4bc40000000000000000000000000000000000000000000000000000001f2c6f738e000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000b446f646f5632000000000000000000000000000000000000000000000000000000000000000000042b85aae7d60c4bc40000000000000000000000000000000000000000000000000000001f811895a7000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000400000000000000000000000005333eb1e32522f1893b7c9fea3c263807a02d561000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000012556e697377617056330000000000000000000000000000000000000000000000000000000000001d30a7ac56da56396a000000000000000000000000000000000000000000000000000000e10b7768e500000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012556e6973776170563300000000000000000000000000000000000000000000000000000000000008570b55cfac1897880000000000000000000000000000000000000000000000000000003fea147b29000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000427ceb23fd6bc0add59e62ac25578270cff1b9f6190001f41bfd67037b42cf73acf2047067bd4f2c47d9bfd6000bb82791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000000000000000000000000000000000000000869584cd0000000000000000000000008c611defbd838a13de3a5923693c58a7c1807c630000000000000000000000000000000000000000000000f789bac21b62fed5ef',\n                    chainId: 137,\n                    expirationTimeSeconds: bigNumberToProto(new BigNumber('1660868679')),\n                    feeAmount: bigNumberToProto(new BigNumber('0')),\n                    feeTokenAddress: '0x0000000000000000000000000000000000000000',\n                    maxGasPrice: bigNumberToProto(new BigNumber('4294967296')),\n                    minGasPrice: bigNumberToProto(new BigNumber('1')),\n                    salt: bigNumberToProto(\n                        new BigNumber('32606650794224189614795510724011106220035660490560169776986607186708081701146'),\n                    ),\n                    senderAddress: '0x0000000000000000000000000000000000000000',\n                    signerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                    value: bigNumberToProto(new BigNumber('0')),\n                    verifyingContract: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                },\n                quote: {\n                    allowanceTarget: '0xdef1c0ded9bec7f1a1670819833240f027b25eff',\n                    buyAmount: bigNumberToProto(new BigNumber('1800054805473')),\n                    buyTokenAddress: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174',\n                    buyTokenToNativeTokenRate: bigNumberToProto(new BigNumber('0.851202')),\n                    chainId: 137,\n                    estimatedGas: bigNumberToProto(new BigNumber('1043459')),\n                    estimatedPriceImpact: bigNumberToProto(new BigNumber('1.6301')),\n                    gas: bigNumberToProto(new BigNumber('1043459')),\n                    gasPrice: bigNumberToProto(new BigNumber('115200000000')),\n                    liquiditySources: [\n                        {\n                            hops: [],\n                            name: 'SushiSwap',\n                            proportion: bigNumberToProto(new BigNumber('0')),\n                        },\n                        {\n                            hops: [],\n                            name: 'QuickSwap',\n                            proportion: bigNumberToProto(new BigNumber('0.2308')),\n                        },\n                        {\n                            hops: [],\n                            name: 'DODO_V2',\n                            proportion: bigNumberToProto(new BigNumber('0.07692')),\n                        },\n                        {\n                            hops: [],\n                            name: 'Uniswap_V3',\n                            proportion: bigNumberToProto(new BigNumber('0.6923')),\n                        },\n                    ],\n                    minimumProtocolFee: bigNumberToProto(new BigNumber('0')),\n                    price: bigNumberToProto(new BigNumber('1800.054805')),\n                    protocolFee: bigNumberToProto(new BigNumber('0')),\n                    sellAmount: bigNumberToProto(new BigNumber('1000000000000000000000')),\n                    sellTokenAddress: '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619',\n                    sellTokenToNativeTokenRate: bigNumberToProto(new BigNumber('0.000465167371348443')),\n                    value: bigNumberToProto(new BigNumber('0')),\n                },\n            };\n            mockGetQuote.mockResolvedValue(mockResponse);\n\n            const response = await getQuoteRpc({\n                buyToken: 'USDC',\n                chainId: 137,\n                integratorId: 'integrator-id',\n                sellToken: 'WETH',\n                sellAmount: new BigNumber(1000000000000000000000),\n                takerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n            });\n\n            expect(response?.metaTransaction).toBeInstanceOf(MetaTransaction);\n            expect(response?.metaTransaction.callData).toEqual(mockResponse.metaTransaction.callData);\n            expect(response?.metaTransaction.expirationTimeSeconds.toNumber()).toEqual(1660868679);\n            expect(response?.metaTransaction.maxGasPrice.toNumber()).toEqual(4294967296);\n\n            expect(response?.price.buyAmount.toNumber()).toEqual(\n                protoToBigNumber(mockResponse.quote.buyAmount).toNumber(),\n            );\n            expect(response?.price.sellAmount.toNumber()).toEqual(\n                protoToBigNumber(mockResponse.quote.sellAmount).toNumber(),\n            );\n            expect(response?.price.buyTokenAddress).toEqual(mockResponse.quote.buyTokenAddress);\n            expect(response?.price.sellTokenAddress).toEqual(mockResponse.quote.sellTokenAddress);\n        });\n\n        it('returns `null` when no liquidity is available', async () => {\n            const noLiquidityError: TwirpError = {\n                code: 'not_found',\n                msg: 'No liquidity exists',\n                meta: {\n                    validationErrors: JSON.stringify([\n                        {\n                            field: 'sellAmount',\n                            code: ValidationErrorCodes.ValueOutOfRange,\n                            reason: 'INSUFFICIENT_ASSET_LIQUIDITY',\n                        },\n                    ]),\n                },\n            };\n            mockGetQuote.mockRejectedValue(noLiquidityError);\n\n            const response = await getQuoteRpc({\n                buyToken: 'USDC',\n                chainId: 137,\n                integratorId: 'integrator-id',\n                sellToken: '0x0000000000000000000000000000000000000000',\n                sellAmount: new BigNumber(1000000000000000000000),\n                takerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                slippagePercentage: new BigNumber(0.2),\n            });\n\n            expect(response).toBeNull();\n        });\n\n        it('should throw validation error when meta-transaction server returns the insufficient fund error', async () => {\n            const exampleInsufficientFundError: TwirpError = {\n                code: 'failed_precondition',\n                msg: apiErrorCodesToReasons[APIErrorCodes.InsufficientFundsError],\n                meta: { zeroexErrorCode: APIErrorCodes.InsufficientFundsError.toString() },\n            };\n            mockGetQuote.mockRejectedValue(exampleInsufficientFundError);\n\n            await expect(() =>\n                getQuoteRpc({\n                    buyToken: 'USDC',\n                    chainId: 137,\n                    integratorId: 'integrator-id',\n                    sellToken: '0x0000000000000000000000000000000000000000',\n                    sellAmount: new BigNumber(1000000000000000000000),\n                    takerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                    slippagePercentage: new BigNumber(0.2),\n                }),\n            ).rejects.toThrow(ValidationError);\n\n            await expect(() =>\n                getQuoteRpc({\n                    buyToken: 'USDC',\n                    chainId: 137,\n                    integratorId: 'integrator-id',\n                    sellToken: '0x0000000000000000000000000000000000000000',\n                    buyAmount: new BigNumber(1000000000000000000000),\n                    takerAddress: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',\n                    slippagePercentage: new BigNumber(0.2),\n                }),\n            ).rejects.toThrow(ValidationError);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/proto-ts/meta_transaction.pb.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/MetaTransactionClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ProtoUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/proto-ts/big_number_js.pb.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/meta_transaction_fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_request_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/proto-ts/meta_transaction.pb.ts",{"fileContent":"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\r\n// Source: meta_transaction.proto\r\n/* eslint-disable */\r\n\r\nimport type { ByteSource } from \"protoscript\";\r\nimport { BinaryReader, BinaryWriter } from \"protoscript\";\r\nimport { JSONrequest, PBrequest } from \"twirpscript\";\r\n// This is the minimum version supported by the current runtime.\r\n// If this line fails typechecking, breaking changes have been introduced and this\r\n// file needs to be regenerated by running `npx twirpscript`.\r\nexport { MIN_SUPPORTED_VERSION_0_0_56 } from \"twirpscript\";\r\nimport type { ClientConfiguration } from \"twirpscript\";\r\nimport { BigNumberJs, BigNumberJsJSON } from \"./big_number_js.pb\";\r\n\r\n//========================================//\r\n//                 Types                  //\r\n//========================================//\r\n\r\nexport interface LiquiditySource {\r\n  name: string;\r\n  proportion: BigNumberJs;\r\n  intermediateToken?: string | null | undefined;\r\n  hops: string[];\r\n}\r\n\r\nexport interface Quote {\r\n  sellTokenAddress: string;\r\n  sellAmount: BigNumberJs;\r\n  buyTokenAddress: string;\r\n  buyAmount: BigNumberJs;\r\n  price: BigNumberJs;\r\n  estimatedPriceImpact?: BigNumberJs | null | undefined;\r\n  sellTokenToNativeTokenRate: BigNumberJs;\r\n  buyTokenToNativeTokenRate: BigNumberJs;\r\n  chainId: number;\r\n  gas: BigNumberJs;\r\n  estimatedGas: BigNumberJs;\r\n  gasPrice: BigNumberJs;\r\n  value: BigNumberJs;\r\n  protocolFee: BigNumberJs;\r\n  minimumProtocolFee: BigNumberJs;\r\n  allowanceTarget: string;\r\n  liquiditySources: LiquiditySource[];\r\n}\r\n\r\n/**\r\n **\r\n * MetaTransaction\r\n * https://github.com/0xProject/protocol/blob/development/packages/protocol-utils/src/meta_transactions.ts#L39\r\n */\r\nexport interface MetaTransaction {\r\n  signerAddress: string;\r\n  senderAddress: string;\r\n  minGasPrice: BigNumberJs;\r\n  maxGasPrice: BigNumberJs;\r\n  expirationTimeSeconds: BigNumberJs;\r\n  salt: BigNumberJs;\r\n  callData: string;\r\n  value: BigNumberJs;\r\n  feeTokenAddress: string;\r\n  feeAmount: BigNumberJs;\r\n  chainId: number;\r\n  verifyingContract: string;\r\n}\r\n\r\nexport interface GetQuoteRequest {\r\n  sellTokenAddress: string;\r\n  buyTokenAddress: string;\r\n  sellAmount?: BigNumberJs | null | undefined;\r\n  buyAmount?: BigNumberJs | null | undefined;\r\n  chainId: number;\r\n  takerAddress: string;\r\n  integratorId: string;\r\n  affiliateAddress?: string | null | undefined;\r\n  slippagePercentage?: BigNumberJs | null | undefined;\r\n  /**\r\n   * ID to use for the quote report `decodedUniqueId`\r\n   */\r\n  quoteUniqueId?: string | null | undefined;\r\n}\r\n\r\nexport interface GetQuoteResponse {\r\n  quote: Quote;\r\n  metaTransaction: MetaTransaction;\r\n}\r\n\r\n//========================================//\r\n// MetaTransactionService Protobuf Client //\r\n//========================================//\r\n\r\nexport async function GetQuote(\r\n  getQuoteRequest: GetQuoteRequest,\r\n  config?: ClientConfiguration\r\n): Promise<GetQuoteResponse> {\r\n  const response = await PBrequest(\r\n    \"/MetaTransactionService/GetQuote\",\r\n    GetQuoteRequest.encode(getQuoteRequest),\r\n    config\r\n  );\r\n  return GetQuoteResponse.decode(response);\r\n}\r\n\r\n//========================================//\r\n//   MetaTransactionService JSON Client   //\r\n//========================================//\r\n\r\nexport async function GetQuoteJSON(\r\n  getQuoteRequest: GetQuoteRequest,\r\n  config?: ClientConfiguration\r\n): Promise<GetQuoteResponse> {\r\n  const response = await JSONrequest(\r\n    \"/MetaTransactionService/GetQuote\",\r\n    GetQuoteRequestJSON.encode(getQuoteRequest),\r\n    config\r\n  );\r\n  return GetQuoteResponseJSON.decode(response);\r\n}\r\n\r\n//========================================//\r\n//         MetaTransactionService         //\r\n//========================================//\r\n\r\nexport interface MetaTransactionService<Context = unknown> {\r\n  GetQuote: (\r\n    getQuoteRequest: GetQuoteRequest,\r\n    context: Context\r\n  ) => Promise<GetQuoteResponse> | GetQuoteResponse;\r\n}\r\n\r\nexport function createMetaTransactionService<Context>(\r\n  service: MetaTransactionService<Context>\r\n) {\r\n  return {\r\n    name: \"MetaTransactionService\",\r\n    methods: {\r\n      GetQuote: {\r\n        name: \"GetQuote\",\r\n        handler: service.GetQuote,\r\n        input: { protobuf: GetQuoteRequest, json: GetQuoteRequestJSON },\r\n        output: { protobuf: GetQuoteResponse, json: GetQuoteResponseJSON },\r\n      },\r\n    },\r\n  } as const;\r\n}\r\n\r\n//========================================//\r\n//        Protobuf Encode / Decode        //\r\n//========================================//\r\n\r\nexport const LiquiditySource = {\r\n  /**\r\n   * Serializes LiquiditySource to protobuf.\r\n   */\r\n  encode: function (msg: Partial<LiquiditySource>): Uint8Array {\r\n    return LiquiditySource._writeMessage(\r\n      msg,\r\n      new BinaryWriter()\r\n    ).getResultBuffer();\r\n  },\r\n\r\n  /**\r\n   * Deserializes LiquiditySource from protobuf.\r\n   */\r\n  decode: function (bytes: ByteSource): LiquiditySource {\r\n    return LiquiditySource._readMessage(\r\n      LiquiditySource.initialize(),\r\n      new BinaryReader(bytes)\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Initializes LiquiditySource with all fields set to their default value.\r\n   */\r\n  initialize: function (): LiquiditySource {\r\n    return {\r\n      name: \"\",\r\n      proportion: BigNumberJs.initialize(),\r\n      intermediateToken: undefined,\r\n      hops: [],\r\n    };\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _writeMessage: function (\r\n    msg: Partial<LiquiditySource>,\r\n    writer: BinaryWriter\r\n  ): BinaryWriter {\r\n    if (msg.name) {\r\n      writer.writeString(1, msg.name);\r\n    }\r\n    if (msg.proportion) {\r\n      writer.writeMessage(2, msg.proportion, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.intermediateToken != undefined) {\r\n      writer.writeString(3, msg.intermediateToken);\r\n    }\r\n    if (msg.hops?.length) {\r\n      writer.writeRepeatedString(4, msg.hops);\r\n    }\r\n    return writer;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _readMessage: function (\r\n    msg: LiquiditySource,\r\n    reader: BinaryReader\r\n  ): LiquiditySource {\r\n    while (reader.nextField()) {\r\n      const field = reader.getFieldNumber();\r\n      switch (field) {\r\n        case 1: {\r\n          msg.name = reader.readString();\r\n          break;\r\n        }\r\n        case 2: {\r\n          reader.readMessage(msg.proportion, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 3: {\r\n          msg.intermediateToken = reader.readString();\r\n          break;\r\n        }\r\n        case 4: {\r\n          msg.hops.push(reader.readString());\r\n          break;\r\n        }\r\n        default: {\r\n          reader.skipField();\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return msg;\r\n  },\r\n};\r\n\r\nexport const Quote = {\r\n  /**\r\n   * Serializes Quote to protobuf.\r\n   */\r\n  encode: function (msg: Partial<Quote>): Uint8Array {\r\n    return Quote._writeMessage(msg, new BinaryWriter()).getResultBuffer();\r\n  },\r\n\r\n  /**\r\n   * Deserializes Quote from protobuf.\r\n   */\r\n  decode: function (bytes: ByteSource): Quote {\r\n    return Quote._readMessage(Quote.initialize(), new BinaryReader(bytes));\r\n  },\r\n\r\n  /**\r\n   * Initializes Quote with all fields set to their default value.\r\n   */\r\n  initialize: function (): Quote {\r\n    return {\r\n      sellTokenAddress: \"\",\r\n      sellAmount: BigNumberJs.initialize(),\r\n      buyTokenAddress: \"\",\r\n      buyAmount: BigNumberJs.initialize(),\r\n      price: BigNumberJs.initialize(),\r\n      estimatedPriceImpact: undefined,\r\n      sellTokenToNativeTokenRate: BigNumberJs.initialize(),\r\n      buyTokenToNativeTokenRate: BigNumberJs.initialize(),\r\n      chainId: 0,\r\n      gas: BigNumberJs.initialize(),\r\n      estimatedGas: BigNumberJs.initialize(),\r\n      gasPrice: BigNumberJs.initialize(),\r\n      value: BigNumberJs.initialize(),\r\n      protocolFee: BigNumberJs.initialize(),\r\n      minimumProtocolFee: BigNumberJs.initialize(),\r\n      allowanceTarget: \"\",\r\n      liquiditySources: [],\r\n    };\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _writeMessage: function (\r\n    msg: Partial<Quote>,\r\n    writer: BinaryWriter\r\n  ): BinaryWriter {\r\n    if (msg.sellTokenAddress) {\r\n      writer.writeString(1, msg.sellTokenAddress);\r\n    }\r\n    if (msg.sellAmount) {\r\n      writer.writeMessage(2, msg.sellAmount, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.buyTokenAddress) {\r\n      writer.writeString(3, msg.buyTokenAddress);\r\n    }\r\n    if (msg.buyAmount) {\r\n      writer.writeMessage(4, msg.buyAmount, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.price) {\r\n      writer.writeMessage(5, msg.price, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.estimatedPriceImpact != undefined) {\r\n      writer.writeMessage(\r\n        6,\r\n        msg.estimatedPriceImpact,\r\n        BigNumberJs._writeMessage\r\n      );\r\n    }\r\n    if (msg.sellTokenToNativeTokenRate) {\r\n      writer.writeMessage(\r\n        7,\r\n        msg.sellTokenToNativeTokenRate,\r\n        BigNumberJs._writeMessage\r\n      );\r\n    }\r\n    if (msg.buyTokenToNativeTokenRate) {\r\n      writer.writeMessage(\r\n        8,\r\n        msg.buyTokenToNativeTokenRate,\r\n        BigNumberJs._writeMessage\r\n      );\r\n    }\r\n    if (msg.chainId) {\r\n      writer.writeInt32(9, msg.chainId);\r\n    }\r\n    if (msg.gas) {\r\n      writer.writeMessage(10, msg.gas, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.estimatedGas) {\r\n      writer.writeMessage(11, msg.estimatedGas, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.gasPrice) {\r\n      writer.writeMessage(12, msg.gasPrice, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.value) {\r\n      writer.writeMessage(13, msg.value, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.protocolFee) {\r\n      writer.writeMessage(14, msg.protocolFee, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.minimumProtocolFee) {\r\n      writer.writeMessage(\r\n        15,\r\n        msg.minimumProtocolFee,\r\n        BigNumberJs._writeMessage\r\n      );\r\n    }\r\n    if (msg.allowanceTarget) {\r\n      writer.writeString(16, msg.allowanceTarget);\r\n    }\r\n    if (msg.liquiditySources?.length) {\r\n      writer.writeRepeatedMessage(\r\n        17,\r\n        msg.liquiditySources as any,\r\n        LiquiditySource._writeMessage\r\n      );\r\n    }\r\n    return writer;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _readMessage: function (msg: Quote, reader: BinaryReader): Quote {\r\n    while (reader.nextField()) {\r\n      const field = reader.getFieldNumber();\r\n      switch (field) {\r\n        case 1: {\r\n          msg.sellTokenAddress = reader.readString();\r\n          break;\r\n        }\r\n        case 2: {\r\n          reader.readMessage(msg.sellAmount, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 3: {\r\n          msg.buyTokenAddress = reader.readString();\r\n          break;\r\n        }\r\n        case 4: {\r\n          reader.readMessage(msg.buyAmount, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 5: {\r\n          reader.readMessage(msg.price, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 6: {\r\n          msg.estimatedPriceImpact = BigNumberJs.initialize();\r\n          reader.readMessage(\r\n            msg.estimatedPriceImpact,\r\n            BigNumberJs._readMessage\r\n          );\r\n          break;\r\n        }\r\n        case 7: {\r\n          reader.readMessage(\r\n            msg.sellTokenToNativeTokenRate,\r\n            BigNumberJs._readMessage\r\n          );\r\n          break;\r\n        }\r\n        case 8: {\r\n          reader.readMessage(\r\n            msg.buyTokenToNativeTokenRate,\r\n            BigNumberJs._readMessage\r\n          );\r\n          break;\r\n        }\r\n        case 9: {\r\n          msg.chainId = reader.readInt32();\r\n          break;\r\n        }\r\n        case 10: {\r\n          reader.readMessage(msg.gas, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 11: {\r\n          reader.readMessage(msg.estimatedGas, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 12: {\r\n          reader.readMessage(msg.gasPrice, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 13: {\r\n          reader.readMessage(msg.value, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 14: {\r\n          reader.readMessage(msg.protocolFee, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 15: {\r\n          reader.readMessage(msg.minimumProtocolFee, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 16: {\r\n          msg.allowanceTarget = reader.readString();\r\n          break;\r\n        }\r\n        case 17: {\r\n          const m = LiquiditySource.initialize();\r\n          reader.readMessage(m, LiquiditySource._readMessage);\r\n          msg.liquiditySources.push(m);\r\n          break;\r\n        }\r\n        default: {\r\n          reader.skipField();\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return msg;\r\n  },\r\n};\r\n\r\nexport const MetaTransaction = {\r\n  /**\r\n   * Serializes MetaTransaction to protobuf.\r\n   */\r\n  encode: function (msg: Partial<MetaTransaction>): Uint8Array {\r\n    return MetaTransaction._writeMessage(\r\n      msg,\r\n      new BinaryWriter()\r\n    ).getResultBuffer();\r\n  },\r\n\r\n  /**\r\n   * Deserializes MetaTransaction from protobuf.\r\n   */\r\n  decode: function (bytes: ByteSource): MetaTransaction {\r\n    return MetaTransaction._readMessage(\r\n      MetaTransaction.initialize(),\r\n      new BinaryReader(bytes)\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Initializes MetaTransaction with all fields set to their default value.\r\n   */\r\n  initialize: function (): MetaTransaction {\r\n    return {\r\n      signerAddress: \"\",\r\n      senderAddress: \"\",\r\n      minGasPrice: BigNumberJs.initialize(),\r\n      maxGasPrice: BigNumberJs.initialize(),\r\n      expirationTimeSeconds: BigNumberJs.initialize(),\r\n      salt: BigNumberJs.initialize(),\r\n      callData: \"\",\r\n      value: BigNumberJs.initialize(),\r\n      feeTokenAddress: \"\",\r\n      feeAmount: BigNumberJs.initialize(),\r\n      chainId: 0,\r\n      verifyingContract: \"\",\r\n    };\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _writeMessage: function (\r\n    msg: Partial<MetaTransaction>,\r\n    writer: BinaryWriter\r\n  ): BinaryWriter {\r\n    if (msg.signerAddress) {\r\n      writer.writeString(1, msg.signerAddress);\r\n    }\r\n    if (msg.senderAddress) {\r\n      writer.writeString(2, msg.senderAddress);\r\n    }\r\n    if (msg.minGasPrice) {\r\n      writer.writeMessage(3, msg.minGasPrice, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.maxGasPrice) {\r\n      writer.writeMessage(4, msg.maxGasPrice, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.expirationTimeSeconds) {\r\n      writer.writeMessage(\r\n        5,\r\n        msg.expirationTimeSeconds,\r\n        BigNumberJs._writeMessage\r\n      );\r\n    }\r\n    if (msg.salt) {\r\n      writer.writeMessage(6, msg.salt, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.callData) {\r\n      writer.writeString(7, msg.callData);\r\n    }\r\n    if (msg.value) {\r\n      writer.writeMessage(8, msg.value, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.feeTokenAddress) {\r\n      writer.writeString(9, msg.feeTokenAddress);\r\n    }\r\n    if (msg.feeAmount) {\r\n      writer.writeMessage(10, msg.feeAmount, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.chainId) {\r\n      writer.writeInt32(11, msg.chainId);\r\n    }\r\n    if (msg.verifyingContract) {\r\n      writer.writeString(12, msg.verifyingContract);\r\n    }\r\n    return writer;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _readMessage: function (\r\n    msg: MetaTransaction,\r\n    reader: BinaryReader\r\n  ): MetaTransaction {\r\n    while (reader.nextField()) {\r\n      const field = reader.getFieldNumber();\r\n      switch (field) {\r\n        case 1: {\r\n          msg.signerAddress = reader.readString();\r\n          break;\r\n        }\r\n        case 2: {\r\n          msg.senderAddress = reader.readString();\r\n          break;\r\n        }\r\n        case 3: {\r\n          reader.readMessage(msg.minGasPrice, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 4: {\r\n          reader.readMessage(msg.maxGasPrice, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 5: {\r\n          reader.readMessage(\r\n            msg.expirationTimeSeconds,\r\n            BigNumberJs._readMessage\r\n          );\r\n          break;\r\n        }\r\n        case 6: {\r\n          reader.readMessage(msg.salt, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 7: {\r\n          msg.callData = reader.readString();\r\n          break;\r\n        }\r\n        case 8: {\r\n          reader.readMessage(msg.value, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 9: {\r\n          msg.feeTokenAddress = reader.readString();\r\n          break;\r\n        }\r\n        case 10: {\r\n          reader.readMessage(msg.feeAmount, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 11: {\r\n          msg.chainId = reader.readInt32();\r\n          break;\r\n        }\r\n        case 12: {\r\n          msg.verifyingContract = reader.readString();\r\n          break;\r\n        }\r\n        default: {\r\n          reader.skipField();\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return msg;\r\n  },\r\n};\r\n\r\nexport const GetQuoteRequest = {\r\n  /**\r\n   * Serializes GetQuoteRequest to protobuf.\r\n   */\r\n  encode: function (msg: Partial<GetQuoteRequest>): Uint8Array {\r\n    return GetQuoteRequest._writeMessage(\r\n      msg,\r\n      new BinaryWriter()\r\n    ).getResultBuffer();\r\n  },\r\n\r\n  /**\r\n   * Deserializes GetQuoteRequest from protobuf.\r\n   */\r\n  decode: function (bytes: ByteSource): GetQuoteRequest {\r\n    return GetQuoteRequest._readMessage(\r\n      GetQuoteRequest.initialize(),\r\n      new BinaryReader(bytes)\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Initializes GetQuoteRequest with all fields set to their default value.\r\n   */\r\n  initialize: function (): GetQuoteRequest {\r\n    return {\r\n      sellTokenAddress: \"\",\r\n      buyTokenAddress: \"\",\r\n      sellAmount: undefined,\r\n      buyAmount: undefined,\r\n      chainId: 0,\r\n      takerAddress: \"\",\r\n      integratorId: \"\",\r\n      affiliateAddress: undefined,\r\n      slippagePercentage: undefined,\r\n      quoteUniqueId: undefined,\r\n    };\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _writeMessage: function (\r\n    msg: Partial<GetQuoteRequest>,\r\n    writer: BinaryWriter\r\n  ): BinaryWriter {\r\n    if (msg.sellTokenAddress) {\r\n      writer.writeString(1, msg.sellTokenAddress);\r\n    }\r\n    if (msg.buyTokenAddress) {\r\n      writer.writeString(2, msg.buyTokenAddress);\r\n    }\r\n    if (msg.sellAmount != undefined) {\r\n      writer.writeMessage(3, msg.sellAmount, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.buyAmount != undefined) {\r\n      writer.writeMessage(4, msg.buyAmount, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.chainId) {\r\n      writer.writeInt32(5, msg.chainId);\r\n    }\r\n    if (msg.takerAddress) {\r\n      writer.writeString(6, msg.takerAddress);\r\n    }\r\n    if (msg.integratorId) {\r\n      writer.writeString(7, msg.integratorId);\r\n    }\r\n    if (msg.affiliateAddress != undefined) {\r\n      writer.writeString(8, msg.affiliateAddress);\r\n    }\r\n    if (msg.slippagePercentage != undefined) {\r\n      writer.writeMessage(9, msg.slippagePercentage, BigNumberJs._writeMessage);\r\n    }\r\n    if (msg.quoteUniqueId != undefined) {\r\n      writer.writeString(10, msg.quoteUniqueId);\r\n    }\r\n    return writer;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _readMessage: function (\r\n    msg: GetQuoteRequest,\r\n    reader: BinaryReader\r\n  ): GetQuoteRequest {\r\n    while (reader.nextField()) {\r\n      const field = reader.getFieldNumber();\r\n      switch (field) {\r\n        case 1: {\r\n          msg.sellTokenAddress = reader.readString();\r\n          break;\r\n        }\r\n        case 2: {\r\n          msg.buyTokenAddress = reader.readString();\r\n          break;\r\n        }\r\n        case 3: {\r\n          msg.sellAmount = BigNumberJs.initialize();\r\n          reader.readMessage(msg.sellAmount, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 4: {\r\n          msg.buyAmount = BigNumberJs.initialize();\r\n          reader.readMessage(msg.buyAmount, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 5: {\r\n          msg.chainId = reader.readInt32();\r\n          break;\r\n        }\r\n        case 6: {\r\n          msg.takerAddress = reader.readString();\r\n          break;\r\n        }\r\n        case 7: {\r\n          msg.integratorId = reader.readString();\r\n          break;\r\n        }\r\n        case 8: {\r\n          msg.affiliateAddress = reader.readString();\r\n          break;\r\n        }\r\n        case 9: {\r\n          msg.slippagePercentage = BigNumberJs.initialize();\r\n          reader.readMessage(msg.slippagePercentage, BigNumberJs._readMessage);\r\n          break;\r\n        }\r\n        case 10: {\r\n          msg.quoteUniqueId = reader.readString();\r\n          break;\r\n        }\r\n        default: {\r\n          reader.skipField();\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return msg;\r\n  },\r\n};\r\n\r\nexport const GetQuoteResponse = {\r\n  /**\r\n   * Serializes GetQuoteResponse to protobuf.\r\n   */\r\n  encode: function (msg: Partial<GetQuoteResponse>): Uint8Array {\r\n    return GetQuoteResponse._writeMessage(\r\n      msg,\r\n      new BinaryWriter()\r\n    ).getResultBuffer();\r\n  },\r\n\r\n  /**\r\n   * Deserializes GetQuoteResponse from protobuf.\r\n   */\r\n  decode: function (bytes: ByteSource): GetQuoteResponse {\r\n    return GetQuoteResponse._readMessage(\r\n      GetQuoteResponse.initialize(),\r\n      new BinaryReader(bytes)\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Initializes GetQuoteResponse with all fields set to their default value.\r\n   */\r\n  initialize: function (): GetQuoteResponse {\r\n    return {\r\n      quote: Quote.initialize(),\r\n      metaTransaction: MetaTransaction.initialize(),\r\n    };\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _writeMessage: function (\r\n    msg: Partial<GetQuoteResponse>,\r\n    writer: BinaryWriter\r\n  ): BinaryWriter {\r\n    if (msg.quote) {\r\n      writer.writeMessage(1, msg.quote, Quote._writeMessage);\r\n    }\r\n    if (msg.metaTransaction) {\r\n      writer.writeMessage(\r\n        2,\r\n        msg.metaTransaction,\r\n        MetaTransaction._writeMessage\r\n      );\r\n    }\r\n    return writer;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _readMessage: function (\r\n    msg: GetQuoteResponse,\r\n    reader: BinaryReader\r\n  ): GetQuoteResponse {\r\n    while (reader.nextField()) {\r\n      const field = reader.getFieldNumber();\r\n      switch (field) {\r\n        case 1: {\r\n          reader.readMessage(msg.quote, Quote._readMessage);\r\n          break;\r\n        }\r\n        case 2: {\r\n          reader.readMessage(msg.metaTransaction, MetaTransaction._readMessage);\r\n          break;\r\n        }\r\n        default: {\r\n          reader.skipField();\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return msg;\r\n  },\r\n};\r\n\r\n//========================================//\r\n//          JSON Encode / Decode          //\r\n//========================================//\r\n\r\nexport const LiquiditySourceJSON = {\r\n  /**\r\n   * Serializes LiquiditySource to JSON.\r\n   */\r\n  encode: function (msg: Partial<LiquiditySource>): string {\r\n    return JSON.stringify(LiquiditySourceJSON._writeMessage(msg));\r\n  },\r\n\r\n  /**\r\n   * Deserializes LiquiditySource from JSON.\r\n   */\r\n  decode: function (json: string): LiquiditySource {\r\n    return LiquiditySourceJSON._readMessage(\r\n      LiquiditySourceJSON.initialize(),\r\n      JSON.parse(json)\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Initializes LiquiditySource with all fields set to their default value.\r\n   */\r\n  initialize: function (): LiquiditySource {\r\n    return {\r\n      name: \"\",\r\n      proportion: BigNumberJs.initialize(),\r\n      intermediateToken: undefined,\r\n      hops: [],\r\n    };\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _writeMessage: function (\r\n    msg: Partial<LiquiditySource>\r\n  ): Record<string, unknown> {\r\n    const json: Record<string, unknown> = {};\r\n    if (msg.name) {\r\n      json[\"name\"] = msg.name;\r\n    }\r\n    if (msg.proportion) {\r\n      const proportion = BigNumberJsJSON._writeMessage(msg.proportion);\r\n      if (Object.keys(proportion).length > 0) {\r\n        json[\"proportion\"] = proportion;\r\n      }\r\n    }\r\n    if (msg.intermediateToken != undefined) {\r\n      json[\"intermediateToken\"] = msg.intermediateToken;\r\n    }\r\n    if (msg.hops?.length) {\r\n      json[\"hops\"] = msg.hops;\r\n    }\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _readMessage: function (msg: LiquiditySource, json: any): LiquiditySource {\r\n    const _name = json[\"name\"];\r\n    if (_name) {\r\n      msg.name = _name;\r\n    }\r\n    const _proportion = json[\"proportion\"];\r\n    if (_proportion) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _proportion);\r\n      msg.proportion = m;\r\n    }\r\n    const _intermediateToken =\r\n      json[\"intermediateToken\"] ?? json[\"intermediate_token\"];\r\n    if (_intermediateToken) {\r\n      msg.intermediateToken = _intermediateToken;\r\n    }\r\n    const _hops = json[\"hops\"];\r\n    if (_hops) {\r\n      msg.hops = _hops;\r\n    }\r\n    return msg;\r\n  },\r\n};\r\n\r\nexport const QuoteJSON = {\r\n  /**\r\n   * Serializes Quote to JSON.\r\n   */\r\n  encode: function (msg: Partial<Quote>): string {\r\n    return JSON.stringify(QuoteJSON._writeMessage(msg));\r\n  },\r\n\r\n  /**\r\n   * Deserializes Quote from JSON.\r\n   */\r\n  decode: function (json: string): Quote {\r\n    return QuoteJSON._readMessage(QuoteJSON.initialize(), JSON.parse(json));\r\n  },\r\n\r\n  /**\r\n   * Initializes Quote with all fields set to their default value.\r\n   */\r\n  initialize: function (): Quote {\r\n    return {\r\n      sellTokenAddress: \"\",\r\n      sellAmount: BigNumberJs.initialize(),\r\n      buyTokenAddress: \"\",\r\n      buyAmount: BigNumberJs.initialize(),\r\n      price: BigNumberJs.initialize(),\r\n      estimatedPriceImpact: undefined,\r\n      sellTokenToNativeTokenRate: BigNumberJs.initialize(),\r\n      buyTokenToNativeTokenRate: BigNumberJs.initialize(),\r\n      chainId: 0,\r\n      gas: BigNumberJs.initialize(),\r\n      estimatedGas: BigNumberJs.initialize(),\r\n      gasPrice: BigNumberJs.initialize(),\r\n      value: BigNumberJs.initialize(),\r\n      protocolFee: BigNumberJs.initialize(),\r\n      minimumProtocolFee: BigNumberJs.initialize(),\r\n      allowanceTarget: \"\",\r\n      liquiditySources: [],\r\n    };\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _writeMessage: function (msg: Partial<Quote>): Record<string, unknown> {\r\n    const json: Record<string, unknown> = {};\r\n    if (msg.sellTokenAddress) {\r\n      json[\"sellTokenAddress\"] = msg.sellTokenAddress;\r\n    }\r\n    if (msg.sellAmount) {\r\n      const sellAmount = BigNumberJsJSON._writeMessage(msg.sellAmount);\r\n      if (Object.keys(sellAmount).length > 0) {\r\n        json[\"sellAmount\"] = sellAmount;\r\n      }\r\n    }\r\n    if (msg.buyTokenAddress) {\r\n      json[\"buyTokenAddress\"] = msg.buyTokenAddress;\r\n    }\r\n    if (msg.buyAmount) {\r\n      const buyAmount = BigNumberJsJSON._writeMessage(msg.buyAmount);\r\n      if (Object.keys(buyAmount).length > 0) {\r\n        json[\"buyAmount\"] = buyAmount;\r\n      }\r\n    }\r\n    if (msg.price) {\r\n      const price = BigNumberJsJSON._writeMessage(msg.price);\r\n      if (Object.keys(price).length > 0) {\r\n        json[\"price\"] = price;\r\n      }\r\n    }\r\n    if (msg.estimatedPriceImpact != undefined) {\r\n      const estimatedPriceImpact = BigNumberJsJSON._writeMessage(\r\n        msg.estimatedPriceImpact\r\n      );\r\n      json[\"estimatedPriceImpact\"] = estimatedPriceImpact;\r\n    }\r\n    if (msg.sellTokenToNativeTokenRate) {\r\n      const sellTokenToNativeTokenRate = BigNumberJsJSON._writeMessage(\r\n        msg.sellTokenToNativeTokenRate\r\n      );\r\n      if (Object.keys(sellTokenToNativeTokenRate).length > 0) {\r\n        json[\"sellTokenToNativeTokenRate\"] = sellTokenToNativeTokenRate;\r\n      }\r\n    }\r\n    if (msg.buyTokenToNativeTokenRate) {\r\n      const buyTokenToNativeTokenRate = BigNumberJsJSON._writeMessage(\r\n        msg.buyTokenToNativeTokenRate\r\n      );\r\n      if (Object.keys(buyTokenToNativeTokenRate).length > 0) {\r\n        json[\"buyTokenToNativeTokenRate\"] = buyTokenToNativeTokenRate;\r\n      }\r\n    }\r\n    if (msg.chainId) {\r\n      json[\"chainId\"] = msg.chainId;\r\n    }\r\n    if (msg.gas) {\r\n      const gas = BigNumberJsJSON._writeMessage(msg.gas);\r\n      if (Object.keys(gas).length > 0) {\r\n        json[\"gas\"] = gas;\r\n      }\r\n    }\r\n    if (msg.estimatedGas) {\r\n      const estimatedGas = BigNumberJsJSON._writeMessage(msg.estimatedGas);\r\n      if (Object.keys(estimatedGas).length > 0) {\r\n        json[\"estimatedGas\"] = estimatedGas;\r\n      }\r\n    }\r\n    if (msg.gasPrice) {\r\n      const gasPrice = BigNumberJsJSON._writeMessage(msg.gasPrice);\r\n      if (Object.keys(gasPrice).length > 0) {\r\n        json[\"gasPrice\"] = gasPrice;\r\n      }\r\n    }\r\n    if (msg.value) {\r\n      const value = BigNumberJsJSON._writeMessage(msg.value);\r\n      if (Object.keys(value).length > 0) {\r\n        json[\"value\"] = value;\r\n      }\r\n    }\r\n    if (msg.protocolFee) {\r\n      const protocolFee = BigNumberJsJSON._writeMessage(msg.protocolFee);\r\n      if (Object.keys(protocolFee).length > 0) {\r\n        json[\"protocolFee\"] = protocolFee;\r\n      }\r\n    }\r\n    if (msg.minimumProtocolFee) {\r\n      const minimumProtocolFee = BigNumberJsJSON._writeMessage(\r\n        msg.minimumProtocolFee\r\n      );\r\n      if (Object.keys(minimumProtocolFee).length > 0) {\r\n        json[\"minimumProtocolFee\"] = minimumProtocolFee;\r\n      }\r\n    }\r\n    if (msg.allowanceTarget) {\r\n      json[\"allowanceTarget\"] = msg.allowanceTarget;\r\n    }\r\n    if (msg.liquiditySources?.length) {\r\n      json[\"liquiditySources\"] = msg.liquiditySources.map(\r\n        LiquiditySourceJSON._writeMessage\r\n      );\r\n    }\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _readMessage: function (msg: Quote, json: any): Quote {\r\n    const _sellTokenAddress =\r\n      json[\"sellTokenAddress\"] ?? json[\"sell_token_address\"];\r\n    if (_sellTokenAddress) {\r\n      msg.sellTokenAddress = _sellTokenAddress;\r\n    }\r\n    const _sellAmount = json[\"sellAmount\"] ?? json[\"sell_amount\"];\r\n    if (_sellAmount) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _sellAmount);\r\n      msg.sellAmount = m;\r\n    }\r\n    const _buyTokenAddress =\r\n      json[\"buyTokenAddress\"] ?? json[\"buy_token_address\"];\r\n    if (_buyTokenAddress) {\r\n      msg.buyTokenAddress = _buyTokenAddress;\r\n    }\r\n    const _buyAmount = json[\"buyAmount\"] ?? json[\"buy_amount\"];\r\n    if (_buyAmount) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _buyAmount);\r\n      msg.buyAmount = m;\r\n    }\r\n    const _price = json[\"price\"];\r\n    if (_price) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _price);\r\n      msg.price = m;\r\n    }\r\n    const _estimatedPriceImpact =\r\n      json[\"estimatedPriceImpact\"] ?? json[\"estimated_price_impact\"];\r\n    if (_estimatedPriceImpact) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _estimatedPriceImpact);\r\n      msg.estimatedPriceImpact = m;\r\n    }\r\n    const _sellTokenToNativeTokenRate =\r\n      json[\"sellTokenToNativeTokenRate\"] ??\r\n      json[\"sell_token_to_native_token_rate\"];\r\n    if (_sellTokenToNativeTokenRate) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _sellTokenToNativeTokenRate);\r\n      msg.sellTokenToNativeTokenRate = m;\r\n    }\r\n    const _buyTokenToNativeTokenRate =\r\n      json[\"buyTokenToNativeTokenRate\"] ??\r\n      json[\"buy_token_to_native_token_rate\"];\r\n    if (_buyTokenToNativeTokenRate) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _buyTokenToNativeTokenRate);\r\n      msg.buyTokenToNativeTokenRate = m;\r\n    }\r\n    const _chainId = json[\"chainId\"] ?? json[\"chain_id\"];\r\n    if (_chainId) {\r\n      msg.chainId = _chainId;\r\n    }\r\n    const _gas = json[\"gas\"];\r\n    if (_gas) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _gas);\r\n      msg.gas = m;\r\n    }\r\n    const _estimatedGas = json[\"estimatedGas\"] ?? json[\"estimated_gas\"];\r\n    if (_estimatedGas) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _estimatedGas);\r\n      msg.estimatedGas = m;\r\n    }\r\n    const _gasPrice = json[\"gasPrice\"] ?? json[\"gas_price\"];\r\n    if (_gasPrice) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _gasPrice);\r\n      msg.gasPrice = m;\r\n    }\r\n    const _value = json[\"value\"];\r\n    if (_value) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _value);\r\n      msg.value = m;\r\n    }\r\n    const _protocolFee = json[\"protocolFee\"] ?? json[\"protocol_fee\"];\r\n    if (_protocolFee) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _protocolFee);\r\n      msg.protocolFee = m;\r\n    }\r\n    const _minimumProtocolFee =\r\n      json[\"minimumProtocolFee\"] ?? json[\"minimum_protocol_fee\"];\r\n    if (_minimumProtocolFee) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _minimumProtocolFee);\r\n      msg.minimumProtocolFee = m;\r\n    }\r\n    const _allowanceTarget =\r\n      json[\"allowanceTarget\"] ?? json[\"allowance_target\"];\r\n    if (_allowanceTarget) {\r\n      msg.allowanceTarget = _allowanceTarget;\r\n    }\r\n    const _liquiditySources =\r\n      json[\"liquiditySources\"] ?? json[\"liquidity_sources\"];\r\n    if (_liquiditySources) {\r\n      for (const item of _liquiditySources) {\r\n        const m = LiquiditySource.initialize();\r\n        LiquiditySourceJSON._readMessage(m, item);\r\n        msg.liquiditySources.push(m);\r\n      }\r\n    }\r\n    return msg;\r\n  },\r\n};\r\n\r\nexport const MetaTransactionJSON = {\r\n  /**\r\n   * Serializes MetaTransaction to JSON.\r\n   */\r\n  encode: function (msg: Partial<MetaTransaction>): string {\r\n    return JSON.stringify(MetaTransactionJSON._writeMessage(msg));\r\n  },\r\n\r\n  /**\r\n   * Deserializes MetaTransaction from JSON.\r\n   */\r\n  decode: function (json: string): MetaTransaction {\r\n    return MetaTransactionJSON._readMessage(\r\n      MetaTransactionJSON.initialize(),\r\n      JSON.parse(json)\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Initializes MetaTransaction with all fields set to their default value.\r\n   */\r\n  initialize: function (): MetaTransaction {\r\n    return {\r\n      signerAddress: \"\",\r\n      senderAddress: \"\",\r\n      minGasPrice: BigNumberJs.initialize(),\r\n      maxGasPrice: BigNumberJs.initialize(),\r\n      expirationTimeSeconds: BigNumberJs.initialize(),\r\n      salt: BigNumberJs.initialize(),\r\n      callData: \"\",\r\n      value: BigNumberJs.initialize(),\r\n      feeTokenAddress: \"\",\r\n      feeAmount: BigNumberJs.initialize(),\r\n      chainId: 0,\r\n      verifyingContract: \"\",\r\n    };\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _writeMessage: function (\r\n    msg: Partial<MetaTransaction>\r\n  ): Record<string, unknown> {\r\n    const json: Record<string, unknown> = {};\r\n    if (msg.signerAddress) {\r\n      json[\"signerAddress\"] = msg.signerAddress;\r\n    }\r\n    if (msg.senderAddress) {\r\n      json[\"senderAddress\"] = msg.senderAddress;\r\n    }\r\n    if (msg.minGasPrice) {\r\n      const minGasPrice = BigNumberJsJSON._writeMessage(msg.minGasPrice);\r\n      if (Object.keys(minGasPrice).length > 0) {\r\n        json[\"minGasPrice\"] = minGasPrice;\r\n      }\r\n    }\r\n    if (msg.maxGasPrice) {\r\n      const maxGasPrice = BigNumberJsJSON._writeMessage(msg.maxGasPrice);\r\n      if (Object.keys(maxGasPrice).length > 0) {\r\n        json[\"maxGasPrice\"] = maxGasPrice;\r\n      }\r\n    }\r\n    if (msg.expirationTimeSeconds) {\r\n      const expirationTimeSeconds = BigNumberJsJSON._writeMessage(\r\n        msg.expirationTimeSeconds\r\n      );\r\n      if (Object.keys(expirationTimeSeconds).length > 0) {\r\n        json[\"expirationTimeSeconds\"] = expirationTimeSeconds;\r\n      }\r\n    }\r\n    if (msg.salt) {\r\n      const salt = BigNumberJsJSON._writeMessage(msg.salt);\r\n      if (Object.keys(salt).length > 0) {\r\n        json[\"salt\"] = salt;\r\n      }\r\n    }\r\n    if (msg.callData) {\r\n      json[\"callData\"] = msg.callData;\r\n    }\r\n    if (msg.value) {\r\n      const value = BigNumberJsJSON._writeMessage(msg.value);\r\n      if (Object.keys(value).length > 0) {\r\n        json[\"value\"] = value;\r\n      }\r\n    }\r\n    if (msg.feeTokenAddress) {\r\n      json[\"feeTokenAddress\"] = msg.feeTokenAddress;\r\n    }\r\n    if (msg.feeAmount) {\r\n      const feeAmount = BigNumberJsJSON._writeMessage(msg.feeAmount);\r\n      if (Object.keys(feeAmount).length > 0) {\r\n        json[\"feeAmount\"] = feeAmount;\r\n      }\r\n    }\r\n    if (msg.chainId) {\r\n      json[\"chainId\"] = msg.chainId;\r\n    }\r\n    if (msg.verifyingContract) {\r\n      json[\"verifyingContract\"] = msg.verifyingContract;\r\n    }\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _readMessage: function (msg: MetaTransaction, json: any): MetaTransaction {\r\n    const _signerAddress = json[\"signerAddress\"] ?? json[\"signer_address\"];\r\n    if (_signerAddress) {\r\n      msg.signerAddress = _signerAddress;\r\n    }\r\n    const _senderAddress = json[\"senderAddress\"] ?? json[\"sender_address\"];\r\n    if (_senderAddress) {\r\n      msg.senderAddress = _senderAddress;\r\n    }\r\n    const _minGasPrice = json[\"minGasPrice\"] ?? json[\"min_gas_price\"];\r\n    if (_minGasPrice) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _minGasPrice);\r\n      msg.minGasPrice = m;\r\n    }\r\n    const _maxGasPrice = json[\"maxGasPrice\"] ?? json[\"max_gas_price\"];\r\n    if (_maxGasPrice) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _maxGasPrice);\r\n      msg.maxGasPrice = m;\r\n    }\r\n    const _expirationTimeSeconds =\r\n      json[\"expirationTimeSeconds\"] ?? json[\"expiration_time_seconds\"];\r\n    if (_expirationTimeSeconds) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _expirationTimeSeconds);\r\n      msg.expirationTimeSeconds = m;\r\n    }\r\n    const _salt = json[\"salt\"];\r\n    if (_salt) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _salt);\r\n      msg.salt = m;\r\n    }\r\n    const _callData = json[\"callData\"] ?? json[\"call_data\"];\r\n    if (_callData) {\r\n      msg.callData = _callData;\r\n    }\r\n    const _value = json[\"value\"];\r\n    if (_value) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _value);\r\n      msg.value = m;\r\n    }\r\n    const _feeTokenAddress =\r\n      json[\"feeTokenAddress\"] ?? json[\"fee_token_address\"];\r\n    if (_feeTokenAddress) {\r\n      msg.feeTokenAddress = _feeTokenAddress;\r\n    }\r\n    const _feeAmount = json[\"feeAmount\"] ?? json[\"fee_amount\"];\r\n    if (_feeAmount) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _feeAmount);\r\n      msg.feeAmount = m;\r\n    }\r\n    const _chainId = json[\"chainId\"] ?? json[\"chain_id\"];\r\n    if (_chainId) {\r\n      msg.chainId = _chainId;\r\n    }\r\n    const _verifyingContract =\r\n      json[\"verifyingContract\"] ?? json[\"verifying_contract\"];\r\n    if (_verifyingContract) {\r\n      msg.verifyingContract = _verifyingContract;\r\n    }\r\n    return msg;\r\n  },\r\n};\r\n\r\nexport const GetQuoteRequestJSON = {\r\n  /**\r\n   * Serializes GetQuoteRequest to JSON.\r\n   */\r\n  encode: function (msg: Partial<GetQuoteRequest>): string {\r\n    return JSON.stringify(GetQuoteRequestJSON._writeMessage(msg));\r\n  },\r\n\r\n  /**\r\n   * Deserializes GetQuoteRequest from JSON.\r\n   */\r\n  decode: function (json: string): GetQuoteRequest {\r\n    return GetQuoteRequestJSON._readMessage(\r\n      GetQuoteRequestJSON.initialize(),\r\n      JSON.parse(json)\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Initializes GetQuoteRequest with all fields set to their default value.\r\n   */\r\n  initialize: function (): GetQuoteRequest {\r\n    return {\r\n      sellTokenAddress: \"\",\r\n      buyTokenAddress: \"\",\r\n      sellAmount: undefined,\r\n      buyAmount: undefined,\r\n      chainId: 0,\r\n      takerAddress: \"\",\r\n      integratorId: \"\",\r\n      affiliateAddress: undefined,\r\n      slippagePercentage: undefined,\r\n      quoteUniqueId: undefined,\r\n    };\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _writeMessage: function (\r\n    msg: Partial<GetQuoteRequest>\r\n  ): Record<string, unknown> {\r\n    const json: Record<string, unknown> = {};\r\n    if (msg.sellTokenAddress) {\r\n      json[\"sellTokenAddress\"] = msg.sellTokenAddress;\r\n    }\r\n    if (msg.buyTokenAddress) {\r\n      json[\"buyTokenAddress\"] = msg.buyTokenAddress;\r\n    }\r\n    if (msg.sellAmount != undefined) {\r\n      const sellAmount = BigNumberJsJSON._writeMessage(msg.sellAmount);\r\n      json[\"sellAmount\"] = sellAmount;\r\n    }\r\n    if (msg.buyAmount != undefined) {\r\n      const buyAmount = BigNumberJsJSON._writeMessage(msg.buyAmount);\r\n      json[\"buyAmount\"] = buyAmount;\r\n    }\r\n    if (msg.chainId) {\r\n      json[\"chainId\"] = msg.chainId;\r\n    }\r\n    if (msg.takerAddress) {\r\n      json[\"takerAddress\"] = msg.takerAddress;\r\n    }\r\n    if (msg.integratorId) {\r\n      json[\"integratorId\"] = msg.integratorId;\r\n    }\r\n    if (msg.affiliateAddress != undefined) {\r\n      json[\"affiliateAddress\"] = msg.affiliateAddress;\r\n    }\r\n    if (msg.slippagePercentage != undefined) {\r\n      const slippagePercentage = BigNumberJsJSON._writeMessage(\r\n        msg.slippagePercentage\r\n      );\r\n      json[\"slippagePercentage\"] = slippagePercentage;\r\n    }\r\n    if (msg.quoteUniqueId != undefined) {\r\n      json[\"quoteUniqueId\"] = msg.quoteUniqueId;\r\n    }\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _readMessage: function (msg: GetQuoteRequest, json: any): GetQuoteRequest {\r\n    const _sellTokenAddress =\r\n      json[\"sellTokenAddress\"] ?? json[\"sell_token_address\"];\r\n    if (_sellTokenAddress) {\r\n      msg.sellTokenAddress = _sellTokenAddress;\r\n    }\r\n    const _buyTokenAddress =\r\n      json[\"buyTokenAddress\"] ?? json[\"buy_token_address\"];\r\n    if (_buyTokenAddress) {\r\n      msg.buyTokenAddress = _buyTokenAddress;\r\n    }\r\n    const _sellAmount = json[\"sellAmount\"] ?? json[\"sell_amount\"];\r\n    if (_sellAmount) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _sellAmount);\r\n      msg.sellAmount = m;\r\n    }\r\n    const _buyAmount = json[\"buyAmount\"] ?? json[\"buy_amount\"];\r\n    if (_buyAmount) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _buyAmount);\r\n      msg.buyAmount = m;\r\n    }\r\n    const _chainId = json[\"chainId\"] ?? json[\"chain_id\"];\r\n    if (_chainId) {\r\n      msg.chainId = _chainId;\r\n    }\r\n    const _takerAddress = json[\"takerAddress\"] ?? json[\"taker_address\"];\r\n    if (_takerAddress) {\r\n      msg.takerAddress = _takerAddress;\r\n    }\r\n    const _integratorId = json[\"integratorId\"] ?? json[\"integrator_id\"];\r\n    if (_integratorId) {\r\n      msg.integratorId = _integratorId;\r\n    }\r\n    const _affiliateAddress =\r\n      json[\"affiliateAddress\"] ?? json[\"affiliate_address\"];\r\n    if (_affiliateAddress) {\r\n      msg.affiliateAddress = _affiliateAddress;\r\n    }\r\n    const _slippagePercentage =\r\n      json[\"slippagePercentage\"] ?? json[\"slippage_percentage\"];\r\n    if (_slippagePercentage) {\r\n      const m = BigNumberJs.initialize();\r\n      BigNumberJsJSON._readMessage(m, _slippagePercentage);\r\n      msg.slippagePercentage = m;\r\n    }\r\n    const _quoteUniqueId = json[\"quoteUniqueId\"] ?? json[\"quote_unique_id\"];\r\n    if (_quoteUniqueId) {\r\n      msg.quoteUniqueId = _quoteUniqueId;\r\n    }\r\n    return msg;\r\n  },\r\n};\r\n\r\nexport const GetQuoteResponseJSON = {\r\n  /**\r\n   * Serializes GetQuoteResponse to JSON.\r\n   */\r\n  encode: function (msg: Partial<GetQuoteResponse>): string {\r\n    return JSON.stringify(GetQuoteResponseJSON._writeMessage(msg));\r\n  },\r\n\r\n  /**\r\n   * Deserializes GetQuoteResponse from JSON.\r\n   */\r\n  decode: function (json: string): GetQuoteResponse {\r\n    return GetQuoteResponseJSON._readMessage(\r\n      GetQuoteResponseJSON.initialize(),\r\n      JSON.parse(json)\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Initializes GetQuoteResponse with all fields set to their default value.\r\n   */\r\n  initialize: function (): GetQuoteResponse {\r\n    return {\r\n      quote: Quote.initialize(),\r\n      metaTransaction: MetaTransaction.initialize(),\r\n    };\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _writeMessage: function (\r\n    msg: Partial<GetQuoteResponse>\r\n  ): Record<string, unknown> {\r\n    const json: Record<string, unknown> = {};\r\n    if (msg.quote) {\r\n      const quote = QuoteJSON._writeMessage(msg.quote);\r\n      if (Object.keys(quote).length > 0) {\r\n        json[\"quote\"] = quote;\r\n      }\r\n    }\r\n    if (msg.metaTransaction) {\r\n      const metaTransaction = MetaTransactionJSON._writeMessage(\r\n        msg.metaTransaction\r\n      );\r\n      if (Object.keys(metaTransaction).length > 0) {\r\n        json[\"metaTransaction\"] = metaTransaction;\r\n      }\r\n    }\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _readMessage: function (msg: GetQuoteResponse, json: any): GetQuoteResponse {\r\n    const _quote = json[\"quote\"];\r\n    if (_quote) {\r\n      const m = Quote.initialize();\r\n      QuoteJSON._readMessage(m, _quote);\r\n      msg.quote = m;\r\n    }\r\n    const _metaTransaction =\r\n      json[\"metaTransaction\"] ?? json[\"meta_transaction\"];\r\n    if (_metaTransaction) {\r\n      const m = MetaTransaction.initialize();\r\n      MetaTransactionJSON._readMessage(m, _metaTransaction);\r\n      msg.metaTransaction = m;\r\n    }\r\n    return msg;\r\n  },\r\n};\r\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/proto-ts/big_number_js.pb.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/proto-ts/big_number_js.pb.ts",{"fileContent":"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\r\n// Source: big_number_js.proto\r\n/* eslint-disable */\r\n\r\nimport type { ByteSource } from \"protoscript\";\r\nimport { BinaryReader, BinaryWriter } from \"protoscript\";\r\n\r\n//========================================//\r\n//                 Types                  //\r\n//========================================//\r\n\r\n/**\r\n **\r\n *  Property representation of a bignumber.js instance. See:\r\n *  https://mikemcl.github.io/bignumber.js/#instance-properties\r\n */\r\nexport interface BigNumberJs {\r\n  c: bigint[];\r\n  e?: number | null | undefined;\r\n  /**\r\n   * `true` -> 1, `false` -> -1\r\n   */\r\n  s?: boolean | null | undefined;\r\n}\r\n\r\n//========================================//\r\n//        Protobuf Encode / Decode        //\r\n//========================================//\r\n\r\nexport const BigNumberJs = {\r\n  /**\r\n   * Serializes BigNumberJs to protobuf.\r\n   */\r\n  encode: function (msg: Partial<BigNumberJs>): Uint8Array {\r\n    return BigNumberJs._writeMessage(msg, new BinaryWriter()).getResultBuffer();\r\n  },\r\n\r\n  /**\r\n   * Deserializes BigNumberJs from protobuf.\r\n   */\r\n  decode: function (bytes: ByteSource): BigNumberJs {\r\n    return BigNumberJs._readMessage(\r\n      BigNumberJs.initialize(),\r\n      new BinaryReader(bytes)\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Initializes BigNumberJs with all fields set to their default value.\r\n   */\r\n  initialize: function (): BigNumberJs {\r\n    return {\r\n      c: [],\r\n      e: undefined,\r\n      s: undefined,\r\n    };\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _writeMessage: function (\r\n    msg: Partial<BigNumberJs>,\r\n    writer: BinaryWriter\r\n  ): BinaryWriter {\r\n    if (msg.c?.length) {\r\n      writer.writePackedInt64String(\r\n        1,\r\n        msg.c.map((x) => x.toString() as any)\r\n      );\r\n    }\r\n    if (msg.e != undefined) {\r\n      writer.writeSint32(2, msg.e);\r\n    }\r\n    if (msg.s != undefined) {\r\n      writer.writeBool(3, msg.s);\r\n    }\r\n    return writer;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _readMessage: function (msg: BigNumberJs, reader: BinaryReader): BigNumberJs {\r\n    while (reader.nextField()) {\r\n      const field = reader.getFieldNumber();\r\n      switch (field) {\r\n        case 1: {\r\n          if (reader.isDelimited()) {\r\n            msg.c.push(...reader.readPackedInt64String().map(BigInt));\r\n          } else {\r\n            msg.c.push(BigInt(reader.readInt64String()));\r\n          }\r\n          break;\r\n        }\r\n        case 2: {\r\n          msg.e = reader.readSint32();\r\n          break;\r\n        }\r\n        case 3: {\r\n          msg.s = reader.readBool();\r\n          break;\r\n        }\r\n        default: {\r\n          reader.skipField();\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return msg;\r\n  },\r\n};\r\n\r\n//========================================//\r\n//          JSON Encode / Decode          //\r\n//========================================//\r\n\r\nexport const BigNumberJsJSON = {\r\n  /**\r\n   * Serializes BigNumberJs to JSON.\r\n   */\r\n  encode: function (msg: Partial<BigNumberJs>): string {\r\n    return JSON.stringify(BigNumberJsJSON._writeMessage(msg));\r\n  },\r\n\r\n  /**\r\n   * Deserializes BigNumberJs from JSON.\r\n   */\r\n  decode: function (json: string): BigNumberJs {\r\n    return BigNumberJsJSON._readMessage(\r\n      BigNumberJsJSON.initialize(),\r\n      JSON.parse(json)\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Initializes BigNumberJs with all fields set to their default value.\r\n   */\r\n  initialize: function (): BigNumberJs {\r\n    return {\r\n      c: [],\r\n      e: undefined,\r\n      s: undefined,\r\n    };\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _writeMessage: function (msg: Partial<BigNumberJs>): Record<string, unknown> {\r\n    const json: Record<string, unknown> = {};\r\n    if (msg.c?.length) {\r\n      json[\"c\"] = msg.c.map((x) => x.toString());\r\n    }\r\n    if (msg.e != undefined) {\r\n      json[\"e\"] = msg.e;\r\n    }\r\n    if (msg.s != undefined) {\r\n      json[\"s\"] = msg.s;\r\n    }\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _readMessage: function (msg: BigNumberJs, json: any): BigNumberJs {\r\n    const _c = json[\"c\"];\r\n    if (_c) {\r\n      msg.c = _c.map(BigInt);\r\n    }\r\n    const _e = json[\"e\"];\r\n    if (_e) {\r\n      msg.e = _e;\r\n    }\r\n    const _s = json[\"s\"];\r\n    if (_s) {\r\n      msg.s = _s;\r\n    }\r\n    return msg;\r\n  },\r\n};\r\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/MetaTransactionClient.ts",{"fileContent":"import { pino, ValidationError, ValidationErrorCodes, ValidationErrorItem } from '@0x/api-utils';\nimport { MetaTransaction, MetaTransactionFields } from '@0x/protocol-utils';\nimport { EIP712DomainWithDefaultSchema } from '@0x/types';\nimport { BigNumber } from '@0x/utils';\nimport { AxiosError, AxiosInstance, AxiosResponse } from 'axios';\nimport { BAD_REQUEST } from 'http-status-codes';\nimport { Summary } from 'prom-client';\nimport { TwirpError } from 'twirpscript';\nimport { META_TRANSACTION_SERVICE_RPC_URL } from '../config';\nimport { ZERO } from '../core/constants';\nimport { APIErrorCodes } from '../core/errors';\nimport { rawFeesToFees } from '../core/meta_transaction_fee_utils';\nimport { GaslessTypes, SwapQuoterError } from '../core/types';\nimport { FeeConfigs, Fees, RawFees } from '../core/types/meta_transaction_fees';\nimport { GetQuote, GetQuoteResponse } from '../proto-ts/meta_transaction.pb';\n\nimport { FetchIndicativeQuoteResponse, LiquiditySource, MetaTransactionTradeResponse } from '../services/types';\nimport { bigNumberToProto, protoToBigNumber } from './ProtoUtils';\nimport { stringsToMetaTransactionFields } from './rfqm_request_utils';\n\ninterface QuoteParams {\n    affiliateAddress?: string;\n    chainId: number;\n    buyAmount?: BigNumber;\n    buyToken: string;\n    integratorId: string;\n    sellAmount?: BigNumber;\n    sellToken: string;\n    slippagePercentage?: BigNumber;\n    takerAddress: string;\n    quoteUniqueId?: string; // ID to use for the quote report `decodedUniqueId`\n    metaTransactionVersion?: 'v1' | 'v2';\n    feeConfigs?: FeeConfigs;\n}\n\n// Types\n//\n// NOTE: These types are copied here from 0x API. Once we have\n// a solution for a real service architecture, these types should\n// become part of the RPC interface published by a future\n// MetaTransactionService. Also we will make it MetatransactionService.\n\ninterface QuoteBase {\n    chainId: number;\n    price: BigNumber;\n    buyAmount: BigNumber;\n    sellAmount: BigNumber;\n    sources: LiquiditySource[];\n    gasPrice: BigNumber;\n    estimatedGas: BigNumber;\n    sellTokenToEthRate: BigNumber;\n    buyTokenToEthRate: BigNumber;\n    protocolFee: BigNumber;\n    minimumProtocolFee: BigNumber;\n    allowanceTarget?: string;\n    // Our calculated price impact or null if we were unable to\n    // to calculate any price impact\n    estimatedPriceImpact: BigNumber | null;\n}\n\n// Raw type of `QuoteBase` as the quote response sent by meta-transaction endpoints is serialized.\ninterface RawQuoteBase {\n    chainId: number;\n    price: string;\n    buyAmount: string;\n    sellAmount: string;\n    sources: {\n        name: string;\n        proportion: string;\n        intermediateToken?: string;\n        hops?: string[];\n    }[];\n    gasPrice: string;\n    estimatedGas: string;\n    sellTokenToEthRate: string;\n    buyTokenToEthRate: string;\n    protocolFee: string;\n    minimumProtocolFee: string;\n    allowanceTarget?: string;\n    // Our calculated price impact or null if we were unable to\n    // to calculate any price impact\n    estimatedPriceImpact: string | null;\n}\n\nexport interface BasePriceResponse extends QuoteBase {\n    sellTokenAddress: string;\n    buyTokenAddress: string;\n    value: BigNumber;\n    gas: BigNumber;\n}\n\n// Raw type of `BasePriceResponse` as the quote response sent by meta-transaction endpoints is serialized.\ninterface RawBasePriceResponse extends RawQuoteBase {\n    sellTokenAddress: string;\n    buyTokenAddress: string;\n    value: string;\n    gas: string;\n}\n\n/****** Types for 0x-api meta-transaction v1 endpoints ******/\n// Raw type of `ExchangeProxyMetaTransaction` as the quote response sent by meta-transaction endpoints is serialized.\ninterface RawExchangeProxyMetaTransaction {\n    signer: string;\n    sender: string;\n    minGasPrice: string;\n    maxGasPrice: string;\n    expirationTimeSeconds: string;\n    salt: string;\n    callData: string;\n    value: string;\n    feeToken: string;\n    feeAmount: string;\n    domain: EIP712DomainWithDefaultSchema;\n}\n\ninterface GetMetaTransactionV1QuoteResponse extends RawBasePriceResponse {\n    metaTransactionHash: string;\n    metaTransaction: RawExchangeProxyMetaTransaction;\n}\n\n/****** Types for 0x-api meta-transaction v2 endpoints ******/\ntype RawTradeResponse = RawMetaTransactionV1TradeResponse /** add RawMetaTransactionV2TradeResponse when it's ready */;\n\ninterface RawMetaTransactionV1TradeResponse {\n    kind: GaslessTypes.MetaTransaction;\n    hash: string;\n    metaTransaction: Record<keyof Omit<MetaTransactionFields, 'chainId'>, string> & { chainId: number };\n}\n\n// Quote response sent by meta-transaction v2 /quote endpoint\ninterface GetMetaTransactionV2QuoteResponse extends RawBasePriceResponse {\n    trade: RawTradeResponse;\n    fees?: RawFees;\n}\n\nexport interface MetaTransactionClientQuoteResponse {\n    trade: MetaTransactionTradeResponse;\n    price: FetchIndicativeQuoteResponse;\n    sources?: LiquiditySource[];\n    fees?: Fees;\n}\n\n/**\n * Queries the MetaTransaction v1 endpoints for an AMM quote wrapped in a\n * MetaTransaction.\n * If no AMM liquidity is available, returns `null`.\n *\n * If a prometheus 'Summary' is provided to the `requestDurationSummary`\n * parameter, the function will call its `observe` method with the request\n * duration in ms.\n *\n * @throws `AxiosError`\n */\nexport async function getV1QuoteAsync(\n    axiosInstance: AxiosInstance,\n    url: URL,\n    params: QuoteParams,\n    meter?: { requestDurationSummary: Summary<'chainId' | 'success'>; chainId: number },\n    noLiquidityLogger?: pino.LogFn,\n): Promise<MetaTransactionClientQuoteResponse | null> {\n    const stopTimer = meter?.requestDurationSummary.startTimer({ chainId: meter.chainId });\n\n    let response: AxiosResponse<GetMetaTransactionV1QuoteResponse>;\n    try {\n        response = await axiosInstance.get<GetMetaTransactionV1QuoteResponse>(url.toString(), {\n            params,\n            // TODO (rhinodavid): Formalize this value once we have a good idea of the\n            // actual numbers\n            timeout: 10000,\n            paramsSerializer: (data: typeof params) => {\n                const result = new URLSearchParams({\n                    buyToken: data.buyToken,\n                    sellToken: data.sellToken,\n                    takerAddress: data.takerAddress,\n                    integratorId: data.integratorId,\n                    chainId: data.chainId.toString(),\n                });\n                const {\n                    affiliateAddress,\n                    buyAmount: buyAmountData,\n                    sellAmount: sellAmountData,\n                    slippagePercentage,\n                    quoteUniqueId,\n                } = data;\n\n                affiliateAddress && result.append('affiliateAddress', affiliateAddress);\n                buyAmountData && result.append('buyAmount', buyAmountData.toString());\n                sellAmountData && result.append('sellAmount', sellAmountData.toString());\n                slippagePercentage && result.append('slippagePercentage', slippagePercentage.toString());\n                quoteUniqueId && result.append('quoteUniqueId', quoteUniqueId);\n\n                return result.toString();\n            },\n        });\n    } catch (e) {\n        stopTimer && stopTimer({ success: 'false' });\n        return handleQuoteError(e, params, noLiquidityLogger);\n    }\n\n    stopTimer && stopTimer({ success: 'true' });\n\n    const { buyAmount, buyTokenAddress, gas, price, sellAmount, sellTokenAddress, metaTransactionHash } = response.data;\n\n    // A fun thing here is that the return from the API, @0x/types:ExchangeProxyMetaTransaction\n    // does not match @0x/protocol-utils:MetaTransaction. So, we pull the domain information out\n    // and put it at the top level of the constructor parameters\n    const metaTransaction = new MetaTransaction(\n        stringsToMetaTransactionFields({\n            ...response.data.metaTransaction,\n            chainId: response.data.metaTransaction.domain.chainId,\n            verifyingContract: response.data.metaTransaction.domain.verifyingContract,\n        }),\n    );\n\n    const computedHash = metaTransaction.getHash();\n    if (computedHash !== metaTransactionHash) {\n        throw new Error(\n            `Computered meta-transaction hash ${computedHash} is different from hash returned from meta-transaction endpoints ${metaTransactionHash}`,\n        );\n    }\n\n    return {\n        trade: {\n            kind: GaslessTypes.MetaTransaction,\n            hash: metaTransaction.getHash(),\n            metaTransaction,\n        },\n        price: {\n            buyAmount: new BigNumber(buyAmount),\n            buyTokenAddress,\n            gas: new BigNumber(gas),\n            price: new BigNumber(price),\n            sellAmount: new BigNumber(sellAmount),\n            sellTokenAddress,\n        },\n    };\n}\n\n/**\n * Queries the meta-transaction v2 endpoints for a meta-transaction quote wrapped in a\n * meta-transaction. The meta-transaction type returned could be either v1 or v2.\n *\n * If no liquidity is available, returns `null`.\n *\n * If a prometheus 'Summary' is provided to the `requestDurationSummary`\n * parameter, the function will call its `observe` method with the request\n * duration in ms.\n *\n * @throws `AxiosError`\n */\nexport async function getV2QuoteAsync(\n    axiosInstance: AxiosInstance,\n    url: URL,\n    params: QuoteParams,\n    meter?: { requestDurationSummary: Summary<'chainId' | 'success'>; chainId: number },\n    noLiquidityLogger?: pino.LogFn,\n): Promise<MetaTransactionClientQuoteResponse | null> {\n    const stopTimer = meter?.requestDurationSummary.startTimer({ chainId: meter.chainId });\n\n    let response: AxiosResponse<GetMetaTransactionV2QuoteResponse>;\n    try {\n        response = await axiosInstance.post<GetMetaTransactionV2QuoteResponse>(url.toString(), params);\n    } catch (e) {\n        stopTimer && stopTimer({ success: 'false' });\n        return handleQuoteError(e, params, noLiquidityLogger);\n    }\n\n    stopTimer && stopTimer({ success: 'true' });\n\n    const { buyAmount, buyTokenAddress, gas, price, sellAmount, sellTokenAddress, trade: rawTrade } = response.data;\n\n    switch (rawTrade.kind) {\n        case GaslessTypes.MetaTransaction: {\n            const metaTransaction = new MetaTransaction(\n                stringsToMetaTransactionFields({\n                    ...rawTrade.metaTransaction,\n                }),\n            );\n\n            const computedHash = metaTransaction.getHash();\n            if (computedHash !== rawTrade.hash) {\n                throw new Error(\n                    `Computered meta-transaction hash ${computedHash} is different from hash returned from meta-transaction endpoints ${rawTrade.hash}`,\n                );\n            }\n\n            return {\n                trade: {\n                    kind: GaslessTypes.MetaTransaction,\n                    hash: rawTrade.hash,\n                    metaTransaction,\n                },\n                price: {\n                    buyAmount: new BigNumber(buyAmount),\n                    buyTokenAddress,\n                    gas: new BigNumber(gas),\n                    price: new BigNumber(price),\n                    sellAmount: new BigNumber(sellAmount),\n                    sellTokenAddress,\n                },\n                sources: response.data.sources\n                    .map((source) => {\n                        return {\n                            ...source,\n                            proportion: new BigNumber(source.proportion),\n                        };\n                    })\n                    .filter((source) => source.proportion.gt(ZERO)),\n                fees: rawFeesToFees(response.data.fees),\n            };\n        }\n        default:\n            ((_x: never) => {\n                throw new Error('unreachable');\n            })(rawTrade.kind);\n    }\n}\n\n/**\n * Internal function to handle meta-transaction quote responses.\n *\n * @returns Null if it's no liquidty error.\n */\nfunction handleQuoteError(\n    e: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n    params: QuoteParams,\n    noLiquidityLogger?: pino.LogFn,\n): null {\n    if (e.response?.data) {\n        const axiosError = e as AxiosError<{\n            code: number;\n            reason: string;\n            validationErrors?: ValidationErrorItem[];\n        }>;\n        //  The response for no liquidity is a 400 status with a body like:\n        //  {\n        //     \"code\": 100,\n        //     \"reason\": \"Validation Failed\",\n        //     \"validationErrors\": [\n        //       {\n        //         \"field\": \"sellAmount\",\n        //         \"code\": 1004,\n        //         \"reason\": \"INSUFFICIENT_ASSET_LIQUIDITY\"\n        //       }\n        //     ]\n        //   }\n        if (\n            axiosError.response?.status === BAD_REQUEST &&\n            axiosError.response?.data?.validationErrors?.length === 1 &&\n            axiosError.response?.data?.validationErrors\n                ?.map((v) => v.reason)\n                .includes(SwapQuoterError.InsufficientAssetLiquidity)\n        ) {\n            // Looks like there is no liquidity for the quote...\n            noLiquidityLogger &&\n                noLiquidityLogger(\n                    { ammQuoteRequestParams: params },\n                    `[MetaTransactionClient] No liquidity returned for pair`,\n                );\n            return null;\n        }\n\n        // The response for insufficient fund error (primarily caused by trading amount is less than the fee)\n        // is a 400 status and with a body like:\n        // {\n        //      \"code\": 109,\n        //      \"reason\": \"Insufficient funds for transaction\"\n        // }\n        if (\n            axiosError.response?.status === BAD_REQUEST &&\n            axiosError.response?.data?.code === APIErrorCodes.InsufficientFundsError\n        ) {\n            if (params.sellAmount) {\n                throw new ValidationError([\n                    {\n                        field: 'sellAmount',\n                        code: ValidationErrorCodes.FieldInvalid,\n                        reason: 'sellAmount too small',\n                    },\n                ]);\n            }\n\n            throw new ValidationError([\n                {\n                    field: 'buyAmount',\n                    code: ValidationErrorCodes.FieldInvalid,\n                    reason: 'buyAmount too small',\n                },\n            ]);\n        }\n    }\n    // This error is neither the standard no liquidity error nor the insufficient fund error\n    throw e;\n}\n\n/**\n * Queries the MetaTransaction RPC service for an AMM quote wrapped in a\n * MetaTransaction.\n * If no AMM liquidity is available, returns `null`.\n *\n * If a prometheus 'Summary' is provided to the `requestDurationSummary`\n * parameter, the function will call its `observe` method with the request\n * duration in ms.\n */\nexport async function getQuoteRpc(\n    params: {\n        affiliateAddress?: string;\n        chainId: number;\n        buyAmount?: BigNumber;\n        buyToken: string;\n        integratorId: string;\n        sellAmount?: BigNumber;\n        sellToken: string;\n        slippagePercentage?: BigNumber;\n        takerAddress: string;\n        quoteUniqueId?: string; // ID to use for the quote report `decodedUniqueId`\n    },\n    meter?: { requestDurationSummary: Summary<'chainId' | 'success'>; chainId: number },\n    noLiquidityLogger?: pino.LogFn,\n): Promise<{ metaTransaction: MetaTransaction; price: FetchIndicativeQuoteResponse } | null> {\n    const stopTimer = meter?.requestDurationSummary.startTimer({ chainId: meter.chainId });\n\n    let response: GetQuoteResponse;\n    try {\n        // TODO (rhinodavid): Figure out how to set a timeout\n        response = await GetQuote(\n            {\n                affiliateAddress: params.affiliateAddress,\n                buyAmount: params.buyAmount ? bigNumberToProto(params.buyAmount) : undefined,\n                buyTokenAddress: params.buyToken,\n                chainId: params.chainId,\n                integratorId: params.integratorId,\n                quoteUniqueId: params.quoteUniqueId,\n                sellAmount: params.sellAmount ? bigNumberToProto(params.sellAmount) : undefined,\n                sellTokenAddress: params.sellToken,\n                slippagePercentage: params.slippagePercentage ? bigNumberToProto(params.slippagePercentage) : undefined,\n                takerAddress: params.takerAddress,\n            },\n            { baseURL: META_TRANSACTION_SERVICE_RPC_URL },\n        );\n    } catch (_e) {\n        stopTimer && stopTimer({ success: 'false' });\n\n        /**\n         * Error handling:\n         *\n         * Twirp throws an error of the following type:\n         * export interface TwirpError {\n         *   code: ErrorCode;\n         *   msg: string;\n         *   meta?: Record<string, string>;\n         * }\n         *\n         * To support the current error codes, we type `meta` as:\n         *  meta: {\n         *     zeroexErrorCode?: APIErrorCodes,\n         *     validationErrors: JSON.stringify(ValidationErrorItem[])\n         *  }\n         */\n\n        const e = _e as TwirpError;\n        const zeroexErrorCode = Number.isNaN(parseInt(e.meta?.zeroexErrorCode ?? ''))\n            ? null\n            : parseInt(e.meta?.zeroexErrorCode ?? '');\n        const validationErrors: ValidationErrorItem[] = JSON.parse(e.meta?.validationErrors ?? '[]');\n\n        if (\n            validationErrors?.length === 1 &&\n            validationErrors?.map((v) => v.reason).includes(SwapQuoterError.InsufficientAssetLiquidity)\n        ) {\n            // Looks like there is no liquidity for the quote...\n            noLiquidityLogger &&\n                noLiquidityLogger(\n                    { ammQuoteRequestParams: params },\n                    `[MetaTransactionClient] No liquidity returned for pair`,\n                );\n            return null;\n        }\n\n        // The response for insufficient fund error (primarily caused by trading amount is less than the fee)\n        // is a zeroexGeneralErrorCode `InsufficientFundsError`\n\n        if (zeroexErrorCode === APIErrorCodes.InsufficientFundsError) {\n            if (params.sellAmount) {\n                throw new ValidationError([\n                    {\n                        field: 'sellAmount',\n                        code: ValidationErrorCodes.FieldInvalid,\n                        reason: 'sellAmount too small',\n                    },\n                ]);\n            }\n\n            throw new ValidationError([\n                {\n                    field: 'buyAmount',\n                    code: ValidationErrorCodes.FieldInvalid,\n                    reason: 'buyAmount too small',\n                },\n            ]);\n        }\n        // This error is neither the standard no liquidity error nor the insufficient fund error\n        throw e;\n    }\n\n    stopTimer && stopTimer({ success: 'true' });\n\n    return {\n        metaTransaction: new MetaTransaction({\n            signer: response.metaTransaction.signerAddress,\n            sender: response.metaTransaction.senderAddress,\n            minGasPrice: protoToBigNumber(response.metaTransaction.minGasPrice),\n            maxGasPrice: protoToBigNumber(response.metaTransaction.maxGasPrice),\n            expirationTimeSeconds: protoToBigNumber(response.metaTransaction.expirationTimeSeconds),\n            salt: protoToBigNumber(response.metaTransaction.salt),\n            callData: response.metaTransaction.callData,\n            value: protoToBigNumber(response.metaTransaction.value),\n            feeToken: response.metaTransaction.feeTokenAddress,\n            feeAmount: protoToBigNumber(response.metaTransaction.feeAmount),\n            chainId: response.metaTransaction.chainId,\n            verifyingContract: response.metaTransaction.verifyingContract,\n        }),\n        price: {\n            buyAmount: protoToBigNumber(response.quote.buyAmount),\n            buyTokenAddress: response.quote.buyTokenAddress,\n            gas: protoToBigNumber(response.quote.gas),\n            price: protoToBigNumber(response.quote.price),\n            sellAmount: protoToBigNumber(response.quote.sellAmount),\n            sellTokenAddress: response.quote.sellTokenAddress,\n        },\n    };\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/meta_transaction_fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/proto-ts/meta_transaction.pb.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ProtoUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_request_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/proto-ts/big_number_js.pb.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/core/meta_transaction_fee_utils.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { ZeroExFeeConfiguration, ZERO_EX_FEE_CONFIGURATION_MAP } from '../config';\nimport { toPairString } from './pair_utils';\nimport {\n    FeeConfigs,\n    Fees,\n    GasFee,\n    GasFeeConfig,\n    IntegratorShareFee,\n    IntegratorShareFeeConfig,\n    RawFees,\n    TruncatedFee,\n    TruncatedFees,\n    VolumeBasedFee,\n    VolumeBasedFeeConfig,\n} from './types/meta_transaction_fees';\n\nexport function rawFeesToFees(rawFees: RawFees | undefined): Fees | undefined {\n    if (!rawFees) {\n        return undefined;\n    }\n\n    let integratorFee: VolumeBasedFee | undefined;\n    if (rawFees.integratorFee) {\n        const rawIntegratorFee = rawFees.integratorFee;\n\n        integratorFee = {\n            type: 'volume',\n            feeToken: rawIntegratorFee.feeToken,\n            feeAmount: new BigNumber(rawIntegratorFee.feeAmount),\n            billingType: rawIntegratorFee.billingType,\n            feeRecipient: rawFees.integratorFee.feeRecipient,\n            volumePercentage: new BigNumber(rawFees.integratorFee.volumePercentage),\n        };\n    }\n\n    let zeroExFee: VolumeBasedFee | IntegratorShareFee | undefined;\n    if (rawFees.zeroExFee) {\n        const rawZeroExFee = rawFees.zeroExFee;\n\n        if (rawZeroExFee.type === 'volume') {\n            zeroExFee = {\n                type: 'volume',\n                feeToken: rawZeroExFee.feeToken,\n                feeAmount: new BigNumber(rawZeroExFee.feeAmount),\n                billingType: rawZeroExFee.billingType,\n                feeRecipient: rawZeroExFee.feeRecipient,\n                volumePercentage: new BigNumber(rawZeroExFee.volumePercentage),\n            };\n        } else if (rawZeroExFee.type === 'integrator_share') {\n            zeroExFee = {\n                type: 'integrator_share',\n                feeToken: rawZeroExFee.feeToken,\n                feeAmount: new BigNumber(rawZeroExFee.feeAmount),\n                billingType: rawZeroExFee.billingType,\n                feeRecipient: rawZeroExFee.feeRecipient,\n                integratorSharePercentage: new BigNumber(rawZeroExFee.integratorSharePercentage),\n            };\n        }\n    }\n\n    let gasFee: GasFee | undefined;\n    if (rawFees.gasFee) {\n        const rawGasFee = rawFees.gasFee;\n\n        gasFee = {\n            type: 'gas',\n            feeToken: rawGasFee.feeToken,\n            feeAmount: new BigNumber(rawGasFee.feeAmount),\n            feeRecipient: rawGasFee.feeRecipient,\n            billingType: rawGasFee.billingType,\n            gasPrice: new BigNumber(rawGasFee.gasPrice),\n            estimatedGas: new BigNumber(rawGasFee.estimatedGas),\n            feeTokenAmountPerBaseUnitNativeToken: new BigNumber(rawGasFee.feeTokenAmountPerBaseUnitNativeToken),\n        };\n    }\n\n    return {\n        integratorFee,\n        zeroExFee,\n        gasFee,\n    };\n}\n\n/**\n * Convert `Fees` to `TruncatedFees` which is returned in the payload to callers.\n */\nexport function feesToTruncatedFees(fees: Fees | undefined): TruncatedFees | undefined {\n    if (!fees) {\n        return undefined;\n    }\n\n    let integratorFee: TruncatedFee | undefined;\n    let zeroExFee: TruncatedFee | undefined;\n    let gasFee: TruncatedFee | undefined;\n\n    if (fees.integratorFee) {\n        const { type, feeToken, feeAmount } = fees.integratorFee;\n        integratorFee = {\n            feeType: type,\n            feeToken,\n            feeAmount,\n        };\n    }\n    if (fees.zeroExFee) {\n        const { type, feeToken, feeAmount } = fees.zeroExFee;\n        zeroExFee = {\n            feeType: type,\n            feeToken,\n            feeAmount,\n        };\n    }\n    if (fees.gasFee) {\n        const { type, feeToken, feeAmount } = fees.gasFee;\n        gasFee = {\n            feeType: type,\n            feeToken,\n            feeAmount,\n        };\n    }\n\n    return {\n        integratorFee,\n        zeroExFee,\n        gasFee,\n    };\n}\n\nexport function getFeeConfigsFromParams(params: {\n    integratorId: string;\n    chainId: number;\n    sellToken: string;\n    buyToken: string;\n    integratorFeeConfig?: {\n        type: 'volume'; // `feeType` field in `FetchQuoteParamsBase`\n        recipient: string; // `feeRecipient` field in `FetchQuoteParamsBase`\n        billingType: 'on-chain' | 'off-chain';\n        sellTokenPercentage: BigNumber; // `feeSellTokenPercentage` field in `FetchQuoteParamsBase`\n    };\n}): FeeConfigs {\n    let integratorFee: VolumeBasedFeeConfig | undefined;\n    let zeroExFee: VolumeBasedFeeConfig | IntegratorShareFeeConfig | undefined;\n    let gasFee: GasFeeConfig | undefined;\n\n    if (params.integratorFeeConfig) {\n        integratorFee = {\n            type: params.integratorFeeConfig.type,\n            feeRecipient: params.integratorFeeConfig.recipient,\n            billingType: params.integratorFeeConfig.billingType,\n            volumePercentage: params.integratorFeeConfig.sellTokenPercentage,\n        };\n    }\n\n    // If integrator id has an entry, use integrator id as key to get fee config. Otherwise, use wildcard.\n    const feeConfigurationByChainId = ZERO_EX_FEE_CONFIGURATION_MAP.get(params.integratorId)\n        ? ZERO_EX_FEE_CONFIGURATION_MAP.get(params.integratorId)\n        : ZERO_EX_FEE_CONFIGURATION_MAP.get('*');\n    if (feeConfigurationByChainId) {\n        const feeConfiguration = feeConfigurationByChainId.get(params.chainId);\n        if (feeConfiguration) {\n            zeroExFee = getZeroExFeeConfig(feeConfiguration, params.sellToken, params.buyToken);\n            gasFee = {\n                type: 'gas',\n                feeRecipient: feeConfiguration.gas.feeRecipient,\n                billingType: feeConfiguration.gas.billingType,\n            };\n        }\n    }\n\n    return {\n        integratorFee,\n        zeroExFee,\n        gasFee,\n    };\n}\n\n/**\n * Get 0x fee config from `ZeroExFeeConfiguration` object given sell and buy tokens. The function would match sell and buy tokens based on the following precedence:\n * 1. Specific pair\n * 2. Cartesian product\n * 3. Token\n *\n * For example, if `feeConfiguration` is the following:\n * {\n *      name: 'Coinbase',\n *      feeOn: 'volume',\n *      zeroExFeeRecipient: '0x123456...',\n *      gasFeeRecipient: '0x654321...',\n *      pairsFeeEntries:  { // Map\n *          // This means for USDC <-> WETH pair 0x charge 0.5% sell token as fee\n *          '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48-0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2': 0.5,\n *          // This means for USDT <-> WETH pair 0x charge 0.5% sell token as fee\n *          '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2-0xdac17f958d2ee523a2206206994597c13d831ec7': 0.5,\n *      },\n *      cartesianProductFeeEntries: [{\n *          // Set consists of USDC, USDT and DAI\n *          setA: { '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', '0xdac17f958d2ee523a2206206994597c13d831ec7', '0x6b175474e89094c44da98b954eedeac495271d0f' }\n *          // Set consists of WETH and WBTC\n *          setB: { '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599' }\n *          // This means for any combination between `setA` and `setB`, 0x charge 0.7% sell token as fee\n *          parameter: 0.7,\n *      }], [{\n *          // Set consists of USDC, USDT and DAI\n *          setA: { '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', '0xdac17f958d2ee523a2206206994597c13d831ec7', '0x6b175474e89094c44da98b954eedeac495271d0f' }\n *          // Set consists of USDC, USDT and DAI\n *          setB: { '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', '0xdac17f958d2ee523a2206206994597c13d831ec7', '0x6b175474e89094c44da98b954eedeac495271d0f' }\n *          // This means for any combination between `setA` and `setB`, 0x charge 0.1% sell token as fee\n *          parameter: 0.1,\n *      }],\n *      tokensEntries: { // Map\n *          // This means 0x charges 1.5% as fee if sell / buy token is WBTC\n *          '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599': 1.5, // WBTC\n *          // This means 0x charges all other sell tokens 0.05% as fee\n *          '*': 0.05,\n *      }\n * }\n *\n * With this example,\n * - if `sellToken` is 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48 (USDC) and `buyToken` is 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 (WETH), there is a pair matches,\n *   the fee percentage would be 0.5\n * - if `sellToken` is 0x6b175474e89094c44da98b954eedeac495271d0f (DAI) and `buyToken` is 0x2260fac5e5542a773aa44fbcfedf7c193bc2c599 (WBTC), there is no pair matches but\n *   a cartesian product match, the fee percentage would be 0.7\n * - if `sellToken` is 0x2260fac5e5542a773aa44fbcfedf7c193bc2c599 (WBTC) and `buyToken` is 0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce (SHIB), there is no pair matches,\n *   no cartesian product match but a token match, the fee percentage would be 1.5%\n * - if `sellToken` is 0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce (SHIB) and `buyToken` is 0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9 (AAVE), there is no pair matches,\n *   no cartesian product match, no exact token match but wildcard, the fee percentage would be 0.05%\n *\n * @param feeConfiguration Correponding fee configuration for an integrator and chain id.\n * @param sellToken Address of the sell token.\n * @param buyToken Address of the buy token.\n * @returns 0x fee config\n */\nfunction getZeroExFeeConfig(\n    feeConfiguration: ZeroExFeeConfiguration,\n    sellToken: string,\n    buyToken: string,\n): VolumeBasedFeeConfig | IntegratorShareFeeConfig | undefined {\n    const [sellTokenLowerCase, buyTokenLowerCase] = [sellToken, buyToken].map((token) => token.toLowerCase());\n    const pairString = toPairString(sellTokenLowerCase, buyTokenLowerCase);\n\n    // specific pair has the highest precedence\n    const pairFeeParameter = feeConfiguration.pairsFeeEntries.get(pairString);\n    if (pairFeeParameter) {\n        // pair fee config exists\n        if (feeConfiguration.feeOn === 'volume') {\n            return {\n                type: 'volume',\n                feeRecipient: feeConfiguration.zeroEx.feeRecipient,\n                billingType: feeConfiguration.zeroEx.billingType,\n                volumePercentage: pairFeeParameter,\n            };\n        } else if (feeConfiguration.feeOn === 'integrator_share') {\n            return {\n                type: 'integrator_share',\n                feeRecipient: feeConfiguration.zeroEx.feeRecipient,\n                billingType: feeConfiguration.zeroEx.billingType,\n                integratorSharePercentage: pairFeeParameter,\n            };\n        }\n    }\n\n    // cartesian product has the second precedence\n    for (const cartesianProductFeeEntry of feeConfiguration.cartesianProductFeeEntries) {\n        if (\n            (cartesianProductFeeEntry.setA.has(sellTokenLowerCase) &&\n                cartesianProductFeeEntry.setB.has(buyTokenLowerCase)) ||\n            (cartesianProductFeeEntry.setA.has(buyTokenLowerCase) &&\n                cartesianProductFeeEntry.setB.has(sellTokenLowerCase))\n        ) {\n            // cartesian product config exists\n            if (feeConfiguration.feeOn === 'volume') {\n                return {\n                    type: 'volume',\n                    feeRecipient: feeConfiguration.zeroEx.feeRecipient,\n                    billingType: feeConfiguration.zeroEx.billingType,\n                    volumePercentage: cartesianProductFeeEntry.parameter,\n                };\n            } else if (feeConfiguration.feeOn === 'integrator_share') {\n                return {\n                    type: 'integrator_share',\n                    feeRecipient: feeConfiguration.zeroEx.feeRecipient,\n                    billingType: feeConfiguration.zeroEx.billingType,\n                    integratorSharePercentage: cartesianProductFeeEntry.parameter,\n                };\n            }\n        }\n    }\n\n    // If sell/buy token has an entry, use sell/buy token as key to get fee config. Otherwise, use wildcard.\n    let tokenFeeParameter: BigNumber | undefined;\n    if (feeConfiguration.tokensEntries.get(sellTokenLowerCase)) {\n        tokenFeeParameter = feeConfiguration.tokensEntries.get(sellTokenLowerCase);\n    } else if (feeConfiguration.tokensEntries.get(buyTokenLowerCase)) {\n        tokenFeeParameter = feeConfiguration.tokensEntries.get(buyTokenLowerCase);\n    } else {\n        tokenFeeParameter = feeConfiguration.tokensEntries.get('*');\n    }\n\n    // Tokens has the lowest precedence\n    if (tokenFeeParameter) {\n        // find a match\n        if (feeConfiguration.feeOn === 'volume') {\n            return {\n                type: 'volume',\n                feeRecipient: feeConfiguration.zeroEx.feeRecipient,\n                billingType: feeConfiguration.zeroEx.billingType,\n                volumePercentage: tokenFeeParameter,\n            };\n        } else if (feeConfiguration.feeOn === 'integrator_share') {\n            return {\n                type: 'integrator_share',\n                feeRecipient: feeConfiguration.zeroEx.feeRecipient,\n                billingType: feeConfiguration.zeroEx.billingType,\n                integratorSharePercentage: tokenFeeParameter,\n            };\n        }\n    }\n\n    return undefined;\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts",{"fileContent":"import { MetaTransaction, OtcOrder, Signature } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\n\nimport { Integrator } from '../config';\nimport { JobFailureReason } from '../entities/types';\nimport {\n    ExecuteMetaTransactionEip712Context,\n    FeeModelVersion,\n    GaslessApprovalTypes,\n    GaslessTypes,\n    PermitEip712Context,\n} from '../core/types';\nimport { TruncatedFees } from '../core/types/meta_transaction_fees';\n\nexport interface FetchIndicativeQuoteParams extends FetchQuoteParamsBase {\n    takerAddress?: string;\n}\n\nexport interface FetchIndicativeQuoteResponse {\n    allowanceTarget?: string;\n    buyAmount: BigNumber;\n    buyTokenAddress: string;\n    gas: BigNumber;\n    price: BigNumber;\n    sellAmount: BigNumber;\n    sellTokenAddress: string;\n}\n\nexport interface FetchFirmQuoteParams extends FetchQuoteParamsBase {\n    takerAddress: string;\n    checkApproval: boolean;\n}\n\nexport interface FetchQuoteParamsBase {\n    affiliateAddress?: string;\n    buyAmount?: BigNumber;\n    buyToken: string;\n    buyTokenDecimals: number;\n    integrator: Integrator;\n    sellAmount?: BigNumber;\n    sellToken: string;\n    sellTokenDecimals: number;\n    // fields specific to gasless endpoints\n    slippagePercentage?: BigNumber;\n    feeType?: 'volume';\n    feeSellTokenPercentage?: BigNumber;\n    feeRecipient?: string;\n}\n\nexport interface BaseRfqmQuoteResponse {\n    allowanceTarget?: string;\n    buyAmount: BigNumber;\n    buyTokenAddress: string;\n    gas: BigNumber;\n    price: BigNumber;\n    sellAmount: BigNumber;\n    sellTokenAddress: string;\n}\n\nexport interface OtcOrderRfqmQuoteResponse extends BaseRfqmQuoteResponse {\n    type: GaslessTypes.OtcOrder;\n    order: OtcOrder;\n    orderHash: string;\n    approval?: ApprovalResponse;\n}\n\n/**\n * Response from the Gasless Swap Service `/quote` endpoint.\n *\n * `approval` will be populated if `checkApproval` is `true`\n * in the parameters, the token supports gasless approval,\n * and no allowance already exists.\n */\nexport interface MetaTransactionV1QuoteResponse extends BaseRfqmQuoteResponse {\n    type: GaslessTypes.MetaTransaction;\n    metaTransaction: MetaTransaction;\n    metaTransactionHash: string;\n    approval?: ApprovalResponse;\n}\n\n// TODO: This needs to be updated to the new meta-transaction type when smart contract changes are finished and corresponding types are published in packages\nexport class MetaTransactionV2 extends MetaTransaction {}\n\nexport interface LiquiditySource {\n    name: string;\n    proportion: BigNumber;\n    intermediateToken?: string;\n    hops?: string[];\n}\n\n// TODO: The type is only a placeholder and should be replaced by eip-712 context soon. Please move `MetaTransactionTradeResponse` and\n//       `MetaTransactionV1TradeResponse` to `MetaTransactionClient` file\nexport type MetaTransactionTradeResponse =\n    MetaTransactionV1TradeResponse /* add MetaTransactionV2TradeResponse when it's ready */;\n\ninterface MetaTransactionV1TradeResponse {\n    kind: GaslessTypes.MetaTransaction;\n    hash: string;\n    metaTransaction: MetaTransaction; // TODO: This field is a placeholder and should be updated to `eip712`\n}\n\nexport interface MetaTransactionV2QuoteResponse extends BaseRfqmQuoteResponse {\n    trade: MetaTransactionTradeResponse;\n    approval?: ApprovalResponse;\n    sources: LiquiditySource[];\n    fees?: TruncatedFees;\n}\n\nexport interface ApprovalResponse {\n    isRequired: boolean;\n    isGaslessAvailable?: boolean;\n    type?: GaslessApprovalTypes;\n    eip712?: ExecuteMetaTransactionEip712Context | PermitEip712Context;\n}\n\nexport interface OtcOrderSubmitRfqmSignedQuoteParams {\n    type: GaslessTypes.OtcOrder;\n    order: OtcOrder;\n    signature: Signature;\n}\n\n/**\n * Payload for the Gasless Swap `/submit` endpoint in the\n * metatransaction flow\n */\nexport interface SubmitMetaTransactionSignedQuoteParams<\n    T extends ExecuteMetaTransactionEip712Context | PermitEip712Context,\n> {\n    approval?: SubmitApprovalParams<T>;\n    // Used to distinguish between `SubmitRfqmSignedQuoteWithApprovalParams` during type check.\n    // Note that this information is in `trade`, but TypeScript does not narrow types based\n    // on nested values.\n    kind: GaslessTypes.MetaTransaction;\n    trade: { metaTransaction: MetaTransaction; signature: Signature; type: GaslessTypes.MetaTransaction };\n}\n\nexport interface SubmitMetaTransactionV2SignedQuoteParams<\n    T extends ExecuteMetaTransactionEip712Context | PermitEip712Context,\n> {\n    approval?: SubmitApprovalParams<T>;\n    // Used to distinguish between `SubmitRfqmSignedQuoteWithApprovalParams` and `SubmitMetaTransactionSignedQuoteParams` during type check.\n    // Note that this information is in `trade`, but TypeScript does not narrow types based\n    // on nested values.\n    kind: GaslessTypes.MetaTransactionV2;\n    // TODO: This needs to be updated to the new meta-transaction type when smart contract changes are finished and corresponding types are published in packages\n    trade: { metaTransaction: MetaTransactionV2; signature: Signature; type: GaslessTypes.MetaTransactionV2 };\n}\n\nexport interface OtcOrderSubmitRfqmSignedQuoteResponse {\n    type: GaslessTypes.OtcOrder;\n    orderHash: string;\n}\n\nexport interface SubmitApprovalParams<T extends ExecuteMetaTransactionEip712Context | PermitEip712Context> {\n    type: T extends ExecuteMetaTransactionEip712Context\n        ? GaslessApprovalTypes.ExecuteMetaTransaction\n        : GaslessApprovalTypes.Permit;\n    eip712: T;\n    signature: Signature;\n}\n\nexport interface SubmitRfqmSignedQuoteWithApprovalParams<\n    T extends ExecuteMetaTransactionEip712Context | PermitEip712Context,\n> {\n    approval?: SubmitApprovalParams<T>;\n    // Used to distinguish between `SubmitMetaTransactionSignedQuoteParams` during type check.\n    // Note that this information is in `trade`, but TypeScript does not narrow types based\n    // on nested values.\n    kind: GaslessTypes.OtcOrder;\n    trade: OtcOrderSubmitRfqmSignedQuoteParams;\n}\n\nexport interface SubmitRfqmSignedQuoteWithApprovalResponse {\n    type: GaslessTypes.OtcOrder;\n    orderHash: string;\n}\n\nexport interface SubmitMetaTransactionSignedQuoteResponse {\n    type: GaslessTypes.MetaTransaction;\n    metaTransactionHash: string;\n}\n\nexport interface SubmitMetaTransactionV2SignedQuoteResponse {\n    type: GaslessTypes.MetaTransactionV2;\n    metaTransactionHash: string;\n}\n\nexport interface TransactionDetails {\n    hash: string;\n    timestamp: number /* unix ms */;\n}\n\nexport type StatusResponse = {\n    transactions: TransactionDetails[];\n    approvalTransactions?: TransactionDetails[];\n} & ({ status: 'pending' | 'submitted' | 'succeeded' | 'confirmed' } | { status: 'failed'; reason?: JobFailureReason });\n\n/**\n * Result type used by the cleanup jobs functionality of the\n * rfq admin service\n */\nexport interface CleanupJobsResponse {\n    // Jobs successfuly cleaned up by `cleanupJobsAsync`\n    modifiedJobs: string[];\n    // Jobs that could not be cleaned up by `cleanupJobsAsync`. This includes\n    // jobs that could not be found, jobs too close to expiration, or jobs\n    // with non-pending statuses.\n    unmodifiedJobs: string[];\n}\n\n/**\n * Base interface for quote context, which includes input query parameters, derived\n * variables, and configuration information.\n */\ninterface QuoteContextBase {\n    workflow: 'rfqm' | 'rfqt' | 'gasless-rfqt';\n    chainId: number;\n    isFirm: boolean;\n    takerAmount?: BigNumber;\n    makerAmount?: BigNumber;\n    takerToken: string;\n    makerToken: string;\n    originalMakerToken: string;\n    takerTokenDecimals: number;\n    makerTokenDecimals: number;\n    integrator: Integrator;\n    affiliateAddress?: string;\n    isUnwrap: boolean;\n    isSelling: boolean;\n    assetFillAmount: BigNumber;\n    feeModelVersion: FeeModelVersion;\n}\n\n/**\n * Context for indicative quote\n */\ninterface IndicativeQuoteContext extends QuoteContextBase {\n    isFirm: false;\n    trader?: string;\n    takerAddress?: string;\n    txOrigin?: string;\n}\n\n/**\n * Context for firm quote\n */\nexport interface FirmQuoteContext extends QuoteContextBase {\n    isFirm: true;\n    trader: string;\n    takerAddress: string;\n    txOrigin: string;\n    bucket?: number;\n}\n\nexport type QuoteContext = IndicativeQuoteContext | FirmQuoteContext;\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ProtoUtils.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { BigNumberJs } from '../proto-ts/big_number_js.pb';\n\n/**\n * Converts a BigNumberJs proto to an instance of bignumber.js `BigNumber`.\n * See: https://mikemcl.github.io/bignumber.js/#instance-properties\n */\nexport function protoToBigNumber(proto: BigNumberJs): BigNumber {\n    // Proto uses an `int64` which is generated to a `bigint`, but bignumber.js uses\n    // `number`. This probably masks some big problems with bignumber.js, but we'll\n    // let that sleeping dog lie.\n    const c = proto.c.map((x) => Number(x));\n    const result = new BigNumber({\n        c,\n        e: proto.e ?? null,\n        s: proto.s ? 1 : proto.s === false ? -1 : null,\n        _isBigNumber: true,\n    });\n    if (!BigNumber.isBigNumber(result)) {\n        throw new Error(`Unable to create BigNumber from proto: ${JSON.stringify(proto)}`);\n    }\n    return result;\n}\n\n/**\n * Converts a bignumber.js to its proto representation.\n * See: https://mikemcl.github.io/bignumber.js/#instance-properties\n */\nexport function bigNumberToProto(n: BigNumber): BigNumberJs {\n    const c = n.c?.map((n) => BigInt(n)) ?? [];\n    const s = n.s === 1 ? true : n.s === -1 ? false : null;\n    const e = n.e;\n    return { c, e, s };\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/proto-ts/big_number_js.pb.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/services/RfqtServiceTest.ts",{"fileContent":"// tslint:disable custom-no-magic-numbers max-file-line-count\nimport { getContractAddressesForChainOrThrow } from '@0x/contract-addresses';\nimport { OtcOrder } from '@0x/protocol-utils';\nimport { Signature, SignatureType } from '@0x/protocol-utils/lib/src/signature_utils';\nimport { TokenMetadata } from '@0x/token-metadata';\nimport { MarketOperation } from '@0x/types';\nimport { BigNumber } from '@0x/utils';\nimport { AxiosInstance } from 'axios';\n\nimport { Integrator } from '../../src/config';\nimport { DEFAULT_MIN_EXPIRY_DURATION_MS, NULL_ADDRESS, ONE_SECOND_MS } from '../../src/core/constants';\nimport { RfqMaker } from '../../src/entities';\nimport { QuoteRequestor } from '../../src/quoteRequestor/QuoteRequestor';\nimport { FeeService } from '../../src/services/fee_service';\nimport { RfqtService } from '../../src/services/RfqtService';\nimport { RfqMakerBalanceCacheService } from '../../src/services/rfq_maker_balance_cache_service';\nimport { FirmQuoteContext, QuoteContext } from '../../src/services/types';\nimport { IndicativeQuote } from '../../src/core/types';\nimport { CacheClient } from '../../src/utils/cache_client';\nimport { ConfigManager } from '../../src/utils/config_manager';\nimport { GasStationAttendant } from '../../src/utils/GasStationAttendant';\nimport { QuoteServerClient } from '../../src/utils/quote_server_client';\nimport { RfqBalanceCheckUtils, RfqBlockchainUtils } from '../../src/utils/rfq_blockchain_utils';\nimport { RfqMakerDbUtils } from '../../src/utils/rfq_maker_db_utils';\nimport { RfqMakerAssetOfferings, RfqMakerManager } from '../../src/utils/rfq_maker_manager';\nimport { TokenMetadataManager } from '../../src/utils/TokenMetadataManager';\nimport { TokenPriceOracle } from '../../src/utils/TokenPriceOracle';\nimport { ZeroExApiClient } from '../../src/utils/ZeroExApiClient';\n\njest.mock('../../src/utils/rfq_maker_manager', () => ({\n    RfqMakerManager: jest.fn().mockImplementation(() => {\n        return {\n            getRfqtV2MakersForPair: jest.fn(),\n        };\n    }),\n}));\n\njest.mock('../../src/quoteRequestor/QuoteRequestor', () => ({\n    QuoteRequestor: jest.fn().mockImplementation(() => {\n        return {\n            requestRfqtIndicativeQuotesAsync: jest.fn().mockResolvedValue([]),\n            requestRfqtFirmQuotesAsync: jest.fn().mockResolvedValue([]),\n        };\n    }),\n}));\n\njest.mock('../../src/utils/quote_server_client', () => ({\n    QuoteServerClient: jest.fn().mockImplementation(() => {\n        return {\n            batchGetPriceV2Async: jest.fn().mockResolvedValue([]),\n        };\n    }),\n}));\n\njest.mock('../../src/services/rfq_maker_balance_cache_service', () => ({\n    RfqMakerBalanceCacheService: jest.fn().mockImplementation(() => {\n        return {\n            getERC20OwnerBalancesAsync: jest.fn().mockResolvedValue([]),\n        };\n    }),\n}));\n\n// TODO (rhinodavid): Find a better way to initialize mocked classes\nconst mockQuoteRequestor = jest.mocked(new QuoteRequestor({} as RfqMakerAssetOfferings, {} as AxiosInstance));\nconst mockRfqMakerManager = jest.mocked(new RfqMakerManager({} as ConfigManager, {} as RfqMakerDbUtils, 0));\nconst mockQuoteServerClient = jest.mocked(new QuoteServerClient({} as AxiosInstance));\nconst mockFeeService = jest.mocked(\n    new FeeService(\n        1337,\n        {} as TokenMetadata,\n        {} as ConfigManager,\n        {} as GasStationAttendant,\n        {} as TokenPriceOracle,\n        {} as ZeroExApiClient,\n        DEFAULT_MIN_EXPIRY_DURATION_MS,\n    ),\n);\nconst mockRfqBlockchainUtils = jest.mocked({} as RfqBlockchainUtils);\nconst mockTokenMetadataManager = jest.mocked(new TokenMetadataManager(1337, {} as RfqBlockchainUtils));\n// tslint:enable: no-object-literal-type-assertion\nconst mockContractAddresses = getContractAddressesForChainOrThrow(1337);\nconst mockRfqMakerBalanceCacheService = jest.mocked(\n    new RfqMakerBalanceCacheService({} as CacheClient, {} as RfqBalanceCheckUtils),\n);\nconst mockCacheClient = jest.mocked({} as CacheClient);\n\ndescribe('Rfqt Service', () => {\n    beforeEach(() => {\n        mockQuoteRequestor.requestRfqtFirmQuotesAsync.mockClear();\n        mockQuoteRequestor.requestRfqtIndicativeQuotesAsync.mockClear();\n        mockQuoteServerClient.batchGetPriceV2Async.mockClear();\n        mockRfqMakerManager.getRfqtV2MakersForPair.mockClear();\n        mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync.mockClear();\n    });\n    describe('v1', () => {\n        describe('getV1PricesAsync', () => {\n            it('passes through calls to QuoteRequestor::requestRfqtIndicativeQuotesAsync', async () => {\n                const rfqtService = new RfqtService(\n                    0,\n                    mockRfqMakerManager,\n                    mockQuoteRequestor,\n                    mockQuoteServerClient,\n                    DEFAULT_MIN_EXPIRY_DURATION_MS,\n                    mockRfqBlockchainUtils,\n                    mockTokenMetadataManager,\n                    mockContractAddresses,\n                    mockFeeService,\n                    1,\n                    mockRfqMakerBalanceCacheService,\n                    mockCacheClient,\n                );\n\n                await rfqtService.getV1PricesAsync({\n                    altRfqAssetOfferings: {\n                        'alt-mm': [\n                            {\n                                id: 'id',\n                                baseAsset: '0xbaseasset',\n                                quoteAsset: '0xquoteasset',\n                                baseAssetDecimals: 420,\n                                quoteAssetDecimals: 69,\n                            },\n                        ],\n                    },\n                    assetFillAmount: new BigNumber(111),\n                    comparisonPrice: new BigNumber(666),\n                    makerToken: '0xmakertoken',\n                    marketOperation: MarketOperation.Buy,\n                    takerAddress: '0xtakeraddress',\n                    takerToken: '0xtakertoken',\n                    intentOnFilling: false,\n                    integrator: {\n                        apiKeys: [],\n                        allowedChainIds: [],\n                        integratorId: 'uuid-integrator',\n                        plp: false,\n                        rfqm: false,\n                        rfqt: true,\n                        label: 'Scam Integrator 1',\n                    },\n                    txOrigin: '0xtxorigin',\n                });\n\n                const args = mockQuoteRequestor.requestRfqtIndicativeQuotesAsync.mock.calls[0];\n                expect(args).toMatchInlineSnapshot(`\n                    Array [\n                      \"0xmakertoken\",\n                      \"0xtakertoken\",\n                      \"111\",\n                      \"Buy\",\n                      \"666\",\n                      Object {\n                        \"altRfqAssetOfferings\": Object {\n                          \"alt-mm\": Array [\n                            Object {\n                              \"baseAsset\": \"0xbaseasset\",\n                              \"baseAssetDecimals\": 420,\n                              \"id\": \"id\",\n                              \"quoteAsset\": \"0xquoteasset\",\n                              \"quoteAssetDecimals\": 69,\n                            },\n                          ],\n                        },\n                        \"integrator\": Object {\n                          \"allowedChainIds\": Array [],\n                          \"apiKeys\": Array [],\n                          \"integratorId\": \"uuid-integrator\",\n                          \"label\": \"Scam Integrator 1\",\n                          \"plp\": false,\n                          \"rfqm\": false,\n                          \"rfqt\": true,\n                        },\n                        \"intentOnFilling\": false,\n                        \"isIndicative\": true,\n                        \"isLastLook\": false,\n                        \"makerEndpointMaxResponseTimeMs\": 600,\n                        \"takerAddress\": \"0xtakeraddress\",\n                        \"txOrigin\": \"0xtxorigin\",\n                      },\n                    ]\n                `);\n            });\n        });\n        describe('getV1QuotesAsync', () => {\n            it('passes through calls to QuoteRequestor::requestRfqtFirmQuotesAsync', async () => {\n                mockQuoteRequestor.requestRfqtFirmQuotesAsync.mockResolvedValue([]);\n                const rfqtService = new RfqtService(\n                    0,\n                    mockRfqMakerManager,\n                    mockQuoteRequestor,\n                    mockQuoteServerClient,\n                    DEFAULT_MIN_EXPIRY_DURATION_MS,\n                    mockRfqBlockchainUtils,\n                    mockTokenMetadataManager,\n                    mockContractAddresses,\n                    mockFeeService,\n                    1,\n                    mockRfqMakerBalanceCacheService,\n                    mockCacheClient,\n                );\n\n                await rfqtService.getV1QuotesAsync({\n                    altRfqAssetOfferings: {\n                        'alt-mm': [\n                            {\n                                id: 'id',\n                                baseAsset: '0xbaseasset',\n                                quoteAsset: '0xquoteasset',\n                                baseAssetDecimals: 420,\n                                quoteAssetDecimals: 69,\n                            },\n                        ],\n                    },\n                    assetFillAmount: new BigNumber(111),\n                    comparisonPrice: new BigNumber(666),\n                    makerToken: '0xmakertoken',\n                    marketOperation: MarketOperation.Buy,\n                    takerAddress: '0xtakeraddress',\n                    takerToken: '0xtakertoken',\n                    intentOnFilling: false,\n                    integrator: {\n                        allowedChainIds: [],\n                        apiKeys: [],\n                        integratorId: 'uuid-integrator',\n                        plp: false,\n                        rfqm: false,\n                        rfqt: true,\n                        label: 'Scam Integrator 1',\n                    },\n                    txOrigin: '0xtxorigin',\n                });\n\n                const args = mockQuoteRequestor.requestRfqtFirmQuotesAsync.mock.calls[0];\n                expect(args).toMatchInlineSnapshot(`\n                    Array [\n                      \"0xmakertoken\",\n                      \"0xtakertoken\",\n                      \"111\",\n                      \"Buy\",\n                      \"666\",\n                      Object {\n                        \"altRfqAssetOfferings\": Object {\n                          \"alt-mm\": Array [\n                            Object {\n                              \"baseAsset\": \"0xbaseasset\",\n                              \"baseAssetDecimals\": 420,\n                              \"id\": \"id\",\n                              \"quoteAsset\": \"0xquoteasset\",\n                              \"quoteAssetDecimals\": 69,\n                            },\n                          ],\n                        },\n                        \"integrator\": Object {\n                          \"allowedChainIds\": Array [],\n                          \"apiKeys\": Array [],\n                          \"integratorId\": \"uuid-integrator\",\n                          \"label\": \"Scam Integrator 1\",\n                          \"plp\": false,\n                          \"rfqm\": false,\n                          \"rfqt\": true,\n                        },\n                        \"intentOnFilling\": false,\n                        \"isIndicative\": false,\n                        \"isLastLook\": false,\n                        \"makerEndpointMaxResponseTimeMs\": 600,\n                        \"takerAddress\": \"0xtakeraddress\",\n                        \"txOrigin\": \"0xtxorigin\",\n                      },\n                    ]\n                `);\n            });\n        });\n    });\n    describe('v2', () => {\n        const maker = new RfqMaker({\n            makerId: 'maker-id',\n            chainId: 1337,\n            updatedAt: new Date(),\n            pairs: [['0x1', '0x2']],\n            rfqmUri: null,\n            rfqtUri: 'maker.uri',\n        });\n        const integrator: Integrator = {\n            allowedChainIds: [1337], // tslint:disable-line: custom-no-magic-numbers\n            apiKeys: [],\n            integratorId: 'integrator-id',\n            label: 'test integrator',\n            plp: false,\n            rfqm: false,\n            rfqt: true,\n        };\n        describe('getV2PricesAsync', () => {\n            it('transforms the API request into a quote server client request for buys', async () => {\n                const quoteContext: QuoteContext = {\n                    isFirm: false,\n                    workflow: 'rfqt',\n                    isUnwrap: false,\n                    originalMakerToken: '0x1',\n                    takerTokenDecimals: 18,\n                    makerTokenDecimals: 18,\n                    feeModelVersion: 1,\n                    assetFillAmount: new BigNumber(1000),\n                    chainId: 1337,\n                    integrator,\n                    makerToken: '0x1',\n                    isSelling: false,\n                    takerAddress: '0x0',\n                    takerToken: '0x2',\n                    txOrigin: '0xtakeraddress',\n                };\n\n                mockRfqMakerManager.getRfqtV2MakersForPair = jest.fn().mockReturnValue([maker]);\n                mockFeeService.calculateFeeAsync = jest.fn().mockResolvedValue({\n                    feeWithDetails: {\n                        token: '0x0b1ba0af832d7c05fd64161e0db78e85978e8082',\n                        amount: new BigNumber(100),\n                        type: 'fixed',\n                    },\n                });\n\n                const rfqtService = new RfqtService(\n                    1337, // tslint:disable-line: custom-no-magic-numbers\n                    mockRfqMakerManager,\n                    mockQuoteRequestor,\n                    mockQuoteServerClient,\n                    DEFAULT_MIN_EXPIRY_DURATION_MS,\n                    mockRfqBlockchainUtils,\n                    mockTokenMetadataManager,\n                    mockContractAddresses,\n                    mockFeeService,\n                    1,\n                    mockRfqMakerBalanceCacheService,\n                    mockCacheClient,\n                );\n\n                await rfqtService.getV2PricesAsync(quoteContext);\n\n                expect(mockQuoteServerClient.batchGetPriceV2Async.mock.calls[0]).toMatchInlineSnapshot(`\n                  Array [\n                    Array [\n                      \"maker.uri\",\n                    ],\n                    Object {\n                      \"allowedChainIds\": Array [\n                        1337,\n                      ],\n                      \"apiKeys\": Array [],\n                      \"integratorId\": \"integrator-id\",\n                      \"label\": \"test integrator\",\n                      \"plp\": false,\n                      \"rfqm\": false,\n                      \"rfqt\": true,\n                    },\n                    Object {\n                      \"buyAmountBaseUnits\": \"1000\",\n                      \"buyTokenAddress\": \"0x1\",\n                      \"chainId\": \"1337\",\n                      \"feeAmount\": \"100\",\n                      \"feeToken\": \"0x0b1ba0af832d7c05fd64161e0db78e85978e8082\",\n                      \"integratorId\": \"integrator-id\",\n                      \"protocolVersion\": \"4\",\n                      \"sellTokenAddress\": \"0x2\",\n                      \"takerAddress\": \"0x0\",\n                      \"txOrigin\": \"0xtakeraddress\",\n                    },\n                    [Function],\n                  ]\n                `);\n            });\n            it('[workflow: gasless-rfqt] transforms the API request into a quote server client request for buys', async () => {\n                const quoteContext: QuoteContext = {\n                    isFirm: false,\n                    workflow: 'gasless-rfqt',\n                    isUnwrap: false,\n                    originalMakerToken: '0x1',\n                    takerTokenDecimals: 18,\n                    makerTokenDecimals: 18,\n                    feeModelVersion: 1,\n                    assetFillAmount: new BigNumber(1000),\n                    chainId: 1337,\n                    integrator,\n                    makerToken: '0x1',\n                    isSelling: false,\n                    takerAddress: '0x0',\n                    takerToken: '0x2',\n                    txOrigin: '0xtakeraddress',\n                };\n\n                mockRfqMakerManager.getRfqtV2MakersForPair = jest.fn().mockReturnValue([maker]);\n                mockFeeService.calculateFeeAsync = jest.fn().mockResolvedValue({\n                    feeWithDetails: {\n                        token: '0x0b1ba0af832d7c05fd64161e0db78e85978e8082',\n                        amount: new BigNumber(100),\n                        type: 'fixed',\n                    },\n                });\n\n                const rfqtService = new RfqtService(\n                    1337, // tslint:disable-line: custom-no-magic-numbers\n                    mockRfqMakerManager,\n                    mockQuoteRequestor,\n                    mockQuoteServerClient,\n                    DEFAULT_MIN_EXPIRY_DURATION_MS,\n                    mockRfqBlockchainUtils,\n                    mockTokenMetadataManager,\n                    mockContractAddresses,\n                    mockFeeService,\n                    1,\n                    mockRfqMakerBalanceCacheService,\n                    mockCacheClient,\n                );\n\n                await rfqtService.getV2PricesAsync(quoteContext);\n\n                expect(mockQuoteServerClient.batchGetPriceV2Async.mock.calls[0]).toMatchInlineSnapshot(`\n                  Array [\n                    Array [\n                      \"maker.uri\",\n                    ],\n                    Object {\n                      \"allowedChainIds\": Array [\n                        1337,\n                      ],\n                      \"apiKeys\": Array [],\n                      \"integratorId\": \"integrator-id\",\n                      \"label\": \"test integrator\",\n                      \"plp\": false,\n                      \"rfqm\": false,\n                      \"rfqt\": true,\n                    },\n                    Object {\n                      \"buyAmountBaseUnits\": \"1000\",\n                      \"buyTokenAddress\": \"0x1\",\n                      \"chainId\": \"1337\",\n                      \"feeAmount\": \"100\",\n                      \"feeToken\": \"0x0b1ba0af832d7c05fd64161e0db78e85978e8082\",\n                      \"integratorId\": \"integrator-id\",\n                      \"protocolVersion\": \"4\",\n                      \"sellTokenAddress\": \"0x2\",\n                      \"takerAddress\": \"0x0\",\n                      \"txOrigin\": \"0xtakeraddress\",\n                    },\n                    [Function],\n                  ]\n                `);\n            });\n            it('transforms the API request into a quote server client request for sells', async () => {\n                const quoteContext: QuoteContext = {\n                    isFirm: false,\n                    workflow: 'rfqt',\n                    isUnwrap: false,\n                    originalMakerToken: '0x1',\n                    takerTokenDecimals: 18,\n                    makerTokenDecimals: 18,\n                    feeModelVersion: 1,\n                    assetFillAmount: new BigNumber(1000),\n                    chainId: 1337,\n                    integrator,\n                    makerToken: '0x1',\n                    isSelling: true,\n                    takerAddress: '0x0',\n                    takerToken: '0x2',\n                    txOrigin: '0xtakeraddress',\n                };\n                mockRfqMakerManager.getRfqtV2MakersForPair = jest.fn().mockReturnValue([maker]);\n                mockFeeService.calculateFeeAsync = jest.fn().mockResolvedValue({\n                    feeWithDetails: {\n                        token: '0x0b1ba0af832d7c05fd64161e0db78e85978e8082',\n                        amount: new BigNumber(100),\n                        type: 'fixed',\n                    },\n                });\n\n                const rfqtService = new RfqtService(\n                    1337, // tslint:disable-line: custom-no-magic-numbers\n                    mockRfqMakerManager,\n                    mockQuoteRequestor,\n                    mockQuoteServerClient,\n                    DEFAULT_MIN_EXPIRY_DURATION_MS,\n                    mockRfqBlockchainUtils,\n                    mockTokenMetadataManager,\n                    mockContractAddresses,\n                    mockFeeService,\n                    1,\n                    mockRfqMakerBalanceCacheService,\n                    mockCacheClient,\n                );\n\n                await rfqtService.getV2PricesAsync(quoteContext);\n\n                expect(mockQuoteServerClient.batchGetPriceV2Async.mock.calls[0]).toMatchInlineSnapshot(`\n                  Array [\n                    Array [\n                      \"maker.uri\",\n                    ],\n                    Object {\n                      \"allowedChainIds\": Array [\n                        1337,\n                      ],\n                      \"apiKeys\": Array [],\n                      \"integratorId\": \"integrator-id\",\n                      \"label\": \"test integrator\",\n                      \"plp\": false,\n                      \"rfqm\": false,\n                      \"rfqt\": true,\n                    },\n                    Object {\n                      \"buyTokenAddress\": \"0x1\",\n                      \"chainId\": \"1337\",\n                      \"feeAmount\": \"100\",\n                      \"feeToken\": \"0x0b1ba0af832d7c05fd64161e0db78e85978e8082\",\n                      \"integratorId\": \"integrator-id\",\n                      \"protocolVersion\": \"4\",\n                      \"sellAmountBaseUnits\": \"1000\",\n                      \"sellTokenAddress\": \"0x2\",\n                      \"takerAddress\": \"0x0\",\n                      \"txOrigin\": \"0xtakeraddress\",\n                    },\n                    [Function],\n                  ]\n              `);\n            });\n            it('gets prices', async () => {\n                const quoteContext: QuoteContext = {\n                    isFirm: false,\n                    workflow: 'rfqt',\n                    isUnwrap: false,\n                    originalMakerToken: '0x1',\n                    takerTokenDecimals: 18,\n                    makerTokenDecimals: 18,\n                    feeModelVersion: 1,\n                    assetFillAmount: new BigNumber(1000),\n                    chainId: 1337,\n                    integrator,\n                    makerToken: '0x1',\n                    isSelling: true,\n                    takerAddress: '0x0',\n                    takerToken: '0x2',\n                    txOrigin: '0xtakeraddress',\n                };\n\n                const price: IndicativeQuote = {\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line @typescript-eslint/no-loss-of-precision\n                    expiry: new BigNumber(9999999999999999),\n                    maker: '0xmakeraddress',\n                    makerAmount: new BigNumber(1000),\n                    makerToken: '0x1',\n                    makerUri: 'maker.uri',\n                    takerAmount: new BigNumber(1001),\n                    takerToken: '0x2',\n                };\n\n                mockRfqMakerManager.getRfqtV2MakersForPair = jest.fn().mockReturnValue([maker]);\n                mockQuoteServerClient.batchGetPriceV2Async = jest.fn().mockResolvedValue([price]);\n                mockFeeService.calculateFeeAsync = jest.fn().mockResolvedValue({\n                    feeWithDetails: {\n                        token: '0x0b1ba0af832d7c05fd64161e0db78e85978e8082',\n                        amount: new BigNumber(100),\n                        type: 'fixed',\n                    },\n                });\n\n                const rfqtService = new RfqtService(\n                    1337, // tslint:disable-line: custom-no-magic-numbers\n                    mockRfqMakerManager,\n                    mockQuoteRequestor,\n                    mockQuoteServerClient,\n                    DEFAULT_MIN_EXPIRY_DURATION_MS,\n                    mockRfqBlockchainUtils,\n                    mockTokenMetadataManager,\n                    mockContractAddresses,\n                    mockFeeService,\n                    1,\n                    mockRfqMakerBalanceCacheService,\n                    mockCacheClient,\n                );\n\n                const result = await rfqtService.getV2PricesAsync(quoteContext);\n                expect(result.length).toEqual(1);\n                expect(result[0].makerId).toEqual('maker-id');\n                expect(result[0]).toMatchInlineSnapshot(`\n                  Object {\n                    \"expiry\": \"10000000000000000\",\n                    \"makerAddress\": \"0xmakeraddress\",\n                    \"makerAmount\": \"1000\",\n                    \"makerId\": \"maker-id\",\n                    \"makerToken\": \"0x1\",\n                    \"makerUri\": \"maker.uri\",\n                    \"takerAmount\": \"1001\",\n                    \"takerToken\": \"0x2\",\n                  }\n                `);\n            });\n            it('gets prices from whitelisted makers only', async () => {\n                const quoteContext: QuoteContext = {\n                    isFirm: false,\n                    workflow: 'rfqt',\n                    isUnwrap: false,\n                    originalMakerToken: '0x1',\n                    takerTokenDecimals: 18,\n                    makerTokenDecimals: 18,\n                    feeModelVersion: 1,\n                    assetFillAmount: new BigNumber(1000),\n                    chainId: 1337,\n                    integrator: {\n                        ...integrator,\n                        whitelistMakerIds: ['maker1'],\n                    },\n                    makerToken: '0x1',\n                    isSelling: true,\n                    takerAddress: '0x0',\n                    takerToken: '0x2',\n                    txOrigin: '0xtakeraddress',\n                };\n\n                const price: IndicativeQuote = {\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line @typescript-eslint/no-loss-of-precision\n                    expiry: new BigNumber(9999999999999999),\n                    maker: '0xmakeraddress',\n                    makerAmount: new BigNumber(1000),\n                    makerToken: '0x1',\n                    makerUri: 'maker.uri',\n                    takerAmount: new BigNumber(1001),\n                    takerToken: '0x2',\n                };\n\n                mockRfqMakerManager.getRfqtV2MakersForPair = jest.fn().mockReturnValue([\n                    {\n                        ...maker,\n                        makerId: 'maker1',\n                    },\n                    {\n                        ...maker,\n                        makerId: 'maker2',\n                    },\n                ]);\n                mockQuoteServerClient.batchGetPriceV2Async = jest.fn().mockResolvedValue([price]);\n                mockFeeService.calculateFeeAsync = jest.fn().mockResolvedValue({\n                    feeWithDetails: {\n                        token: '0x0b1ba0af832d7c05fd64161e0db78e85978e8082',\n                        amount: new BigNumber(100),\n                        type: 'fixed',\n                    },\n                });\n\n                const rfqtService = new RfqtService(\n                    1337, // tslint:disable-line: custom-no-magic-numbers\n                    mockRfqMakerManager,\n                    mockQuoteRequestor,\n                    mockQuoteServerClient,\n                    DEFAULT_MIN_EXPIRY_DURATION_MS,\n                    mockRfqBlockchainUtils,\n                    mockTokenMetadataManager,\n                    mockContractAddresses,\n                    mockFeeService,\n                    1,\n                    mockRfqMakerBalanceCacheService,\n                    mockCacheClient,\n                );\n\n                const result = await rfqtService.getV2PricesAsync(quoteContext);\n                expect(result.length).toEqual(1);\n                expect(result[0].makerId).toEqual('maker1');\n                expect(result[0]).toMatchInlineSnapshot(`\n                  Object {\n                    \"expiry\": \"10000000000000000\",\n                    \"makerAddress\": \"0xmakeraddress\",\n                    \"makerAmount\": \"1000\",\n                    \"makerId\": \"maker1\",\n                    \"makerToken\": \"0x1\",\n                    \"makerUri\": \"maker.uri\",\n                    \"takerAmount\": \"1001\",\n                    \"takerToken\": \"0x2\",\n                  }\n                `);\n            });\n        });\n        describe('getV2QuotesAsync', () => {\n            const makerToken = '0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE';\n            const makerAddress = '0x79b7a69d90c82E014Bf0315e164208119B510FA0';\n            const takerToken = '0x42d6622deCe394b54999Fbd73D108123806f6a18';\n            const takerAddress = '0xE06fFA8146bBdECcBaaF72B6043b29091071AEB8';\n            const fakeNow = new Date(1657069278103);\n            const expiry = new BigNumber(fakeNow.getTime() + 1_000_000).dividedBy(ONE_SECOND_MS).decimalPlaces(0);\n\n            mockRfqBlockchainUtils.isValidOrderSignerAsync = jest.fn().mockResolvedValue(true);\n            it('filters out quotes with no signatures', async () => {\n                const quoteContext: FirmQuoteContext = {\n                    isFirm: true,\n                    workflow: 'rfqt',\n                    isUnwrap: false,\n                    originalMakerToken: '0x1',\n                    takerTokenDecimals: 18,\n                    makerTokenDecimals: 18,\n                    feeModelVersion: 1,\n                    assetFillAmount: new BigNumber(1000),\n                    chainId: 1337,\n                    integrator,\n                    makerToken,\n                    isSelling: false,\n                    takerAddress,\n                    trader: takerAddress,\n                    takerToken,\n                    txOrigin: takerAddress,\n                };\n\n                mockRfqMakerManager.getRfqtV2MakersForPair = jest.fn().mockReturnValue([maker]);\n                mockQuoteServerClient.batchGetPriceV2Async = jest.fn().mockResolvedValue([\n                    {\n                        maker: makerAddress,\n                        makerUri: maker.rfqtUri,\n                        makerToken,\n                        takerToken,\n                        makerAmount: new BigNumber(999),\n                        takerAmount: new BigNumber(1000),\n                        expiry,\n                    },\n                ]);\n                mockQuoteServerClient.signV2Async = jest.fn().mockResolvedValue(undefined);\n                mockFeeService.calculateFeeAsync = jest.fn().mockResolvedValue({\n                    feeWithDetails: {\n                        token: '0x0b1ba0af832d7c05fd64161e0db78e85978e8082',\n                        amount: new BigNumber(100),\n                        type: 'fixed',\n                    },\n                });\n\n                const rfqtService = new RfqtService(\n                    1337, // tslint:disable-line: custom-no-magic-numbers\n                    mockRfqMakerManager,\n                    mockQuoteRequestor,\n                    mockQuoteServerClient,\n                    DEFAULT_MIN_EXPIRY_DURATION_MS,\n                    mockRfqBlockchainUtils,\n                    mockTokenMetadataManager,\n                    mockContractAddresses,\n                    mockFeeService,\n                    1,\n                    mockRfqMakerBalanceCacheService,\n                    mockCacheClient,\n                );\n\n                const result = await rfqtService.getV2QuotesAsync(quoteContext);\n\n                expect(result.length).toEqual(0);\n            });\n\n            it(\"doesn't blow up if a sign request fails\", async () => {\n                const quoteContext: FirmQuoteContext = {\n                    isFirm: true,\n                    workflow: 'rfqt',\n                    isUnwrap: false,\n                    originalMakerToken: '0x1',\n                    takerTokenDecimals: 18,\n                    makerTokenDecimals: 18,\n                    feeModelVersion: 1,\n                    assetFillAmount: new BigNumber(1000),\n                    chainId: 1337,\n                    integrator,\n                    makerToken,\n                    isSelling: false,\n                    takerAddress,\n                    trader: takerAddress,\n                    takerToken,\n                    txOrigin: takerAddress,\n                };\n\n                mockRfqMakerManager.getRfqtV2MakersForPair = jest.fn().mockReturnValue([maker]);\n                mockQuoteServerClient.batchGetPriceV2Async = jest.fn().mockResolvedValue([\n                    {\n                        maker: makerAddress,\n                        makerUri: maker.rfqtUri,\n                        makerToken,\n                        takerToken,\n                        makerAmount: new BigNumber(999),\n                        takerAmount: new BigNumber(1000),\n                        expiry,\n                    },\n                ]);\n                mockQuoteServerClient.signV2Async = jest.fn().mockRejectedValue(new Error('EXPLODE'));\n                mockFeeService.calculateFeeAsync = jest.fn().mockResolvedValue({\n                    feeWithDetails: {\n                        token: '0x0b1ba0af832d7c05fd64161e0db78e85978e8082',\n                        amount: new BigNumber(100),\n                        type: 'fixed',\n                    },\n                });\n\n                const rfqtService = new RfqtService(\n                    1337, // tslint:disable-line: custom-no-magic-numbers\n                    mockRfqMakerManager,\n                    mockQuoteRequestor,\n                    mockQuoteServerClient,\n                    DEFAULT_MIN_EXPIRY_DURATION_MS,\n                    mockRfqBlockchainUtils,\n                    mockTokenMetadataManager,\n                    mockContractAddresses,\n                    mockFeeService,\n                    1,\n                    mockRfqMakerBalanceCacheService,\n                    mockCacheClient,\n                );\n\n                const result = await rfqtService.getV2QuotesAsync(quoteContext);\n\n                expect(result.length).toEqual(0);\n            });\n\n            it('[workflow: rfqt] creates orders with unique nonces', async () => {\n                const quoteContext: FirmQuoteContext = {\n                    isFirm: true,\n                    workflow: 'rfqt',\n                    isUnwrap: false,\n                    originalMakerToken: '0x1',\n                    takerTokenDecimals: 18,\n                    makerTokenDecimals: 18,\n                    feeModelVersion: 1,\n                    assetFillAmount: new BigNumber(1000),\n                    chainId: 1337,\n                    integrator,\n                    makerToken,\n                    isSelling: false,\n                    takerAddress,\n                    trader: takerAddress,\n                    takerToken,\n                    txOrigin: takerAddress,\n                };\n\n                mockRfqMakerManager.getRfqtV2MakersForPair = jest.fn().mockReturnValue([maker]);\n                mockQuoteServerClient.batchGetPriceV2Async = jest.fn().mockResolvedValue([\n                    {\n                        maker: makerAddress,\n                        makerUri: maker.rfqtUri,\n                        makerToken,\n                        takerToken,\n                        makerAmount: new BigNumber(999),\n                        takerAmount: new BigNumber(1000),\n                        expiry,\n                    },\n                    {\n                        maker: makerAddress,\n                        makerUri: maker.rfqtUri,\n                        makerToken,\n                        takerToken,\n                        makerAmount: new BigNumber(900),\n                        takerAmount: new BigNumber(1000),\n                        expiry,\n                    },\n                ]);\n                mockFeeService.calculateFeeAsync = jest.fn().mockResolvedValue({\n                    feeWithDetails: {\n                        token: '0x0b1ba0af832d7c05fd64161e0db78e85978e8082',\n                        amount: new BigNumber(100),\n                        type: 'fixed',\n                    },\n                });\n                mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync = jest\n                    .fn()\n                    .mockResolvedValue([new BigNumber(10000), new BigNumber(10000)]);\n\n                const signature: Signature = { r: 'r', v: 21, s: 's', signatureType: SignatureType.EIP712 };\n                mockQuoteServerClient.signV2Async = jest.fn().mockResolvedValue(signature);\n\n                const rfqtService = new RfqtService(\n                    1337, // tslint:disable-line: custom-no-magic-numbers\n                    mockRfqMakerManager,\n                    mockQuoteRequestor,\n                    mockQuoteServerClient,\n                    DEFAULT_MIN_EXPIRY_DURATION_MS,\n                    mockRfqBlockchainUtils,\n                    mockTokenMetadataManager,\n                    mockContractAddresses,\n                    mockFeeService,\n                    1,\n                    mockRfqMakerBalanceCacheService,\n                    mockCacheClient,\n                );\n\n                const result = await rfqtService.getV2QuotesAsync(quoteContext, fakeNow);\n\n                const [{ nonce: nonce1 }, { nonce: nonce2 }] = [\n                    OtcOrder.parseExpiryAndNonce(result[0].order.expiryAndNonce),\n                    OtcOrder.parseExpiryAndNonce(result[1].order.expiryAndNonce),\n                ];\n\n                expect(nonce1.toString()).not.toEqual(nonce2.toString());\n            });\n\n            it('[workflow: gasless-rfqt] creates orders with unique buckets', async () => {\n                const quoteContext: FirmQuoteContext = {\n                    isFirm: true,\n                    workflow: 'gasless-rfqt',\n                    isUnwrap: false,\n                    originalMakerToken: '0x1',\n                    takerTokenDecimals: 18,\n                    makerTokenDecimals: 18,\n                    feeModelVersion: 1,\n                    assetFillAmount: new BigNumber(1000),\n                    chainId: 1337,\n                    integrator,\n                    makerToken,\n                    isSelling: false,\n                    takerAddress,\n                    trader: takerAddress,\n                    takerToken,\n                    txOrigin: takerAddress,\n                };\n\n                mockRfqMakerManager.getRfqtV2MakersForPair = jest.fn().mockReturnValue([maker]);\n                mockQuoteServerClient.batchGetPriceV2Async = jest.fn().mockResolvedValue([\n                    {\n                        maker: makerAddress,\n                        makerUri: maker.rfqtUri,\n                        makerToken,\n                        takerToken,\n                        makerAmount: new BigNumber(999),\n                        takerAmount: new BigNumber(1000),\n                        expiry,\n                    },\n                    {\n                        maker: makerAddress,\n                        makerUri: maker.rfqtUri,\n                        makerToken,\n                        takerToken,\n                        makerAmount: new BigNumber(900),\n                        takerAmount: new BigNumber(1000),\n                        expiry,\n                    },\n                ]);\n                mockFeeService.calculateFeeAsync = jest.fn().mockResolvedValue({\n                    feeWithDetails: {\n                        token: '0x0b1ba0af832d7c05fd64161e0db78e85978e8082',\n                        amount: new BigNumber(100),\n                        type: 'fixed',\n                    },\n                });\n                mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync = jest\n                    .fn()\n                    .mockResolvedValue([new BigNumber(10000), new BigNumber(10000)]);\n\n                const signature: Signature = { r: 'r', v: 21, s: 's', signatureType: SignatureType.EIP712 };\n                mockQuoteServerClient.signV2Async = jest.fn().mockResolvedValue(signature);\n\n                // 0 is a special return value since this will trigger a wrap around\n                mockCacheClient.getNextNOtcOrderBucketsAsync = jest.fn().mockResolvedValue(0);\n\n                const rfqtService = new RfqtService(\n                    1337, // tslint:disable-line: custom-no-magic-numbers\n                    mockRfqMakerManager,\n                    mockQuoteRequestor,\n                    mockQuoteServerClient,\n                    DEFAULT_MIN_EXPIRY_DURATION_MS,\n                    mockRfqBlockchainUtils,\n                    mockTokenMetadataManager,\n                    mockContractAddresses,\n                    mockFeeService,\n                    1,\n                    mockRfqMakerBalanceCacheService,\n                    mockCacheClient,\n                );\n\n                const result = await rfqtService.getV2QuotesAsync(quoteContext, fakeNow);\n                console.log('result', result);\n\n                const [{ nonceBucket: bucket1 }, { nonceBucket: bucket2 }] = [\n                    OtcOrder.parseExpiryAndNonce(result[0].order.expiryAndNonce),\n                    OtcOrder.parseExpiryAndNonce(result[1].order.expiryAndNonce),\n                ];\n\n                expect(bucket1.toString()).not.toEqual(bucket2.toString());\n                // check that buckets are greater than zero (successfully wrapped around for negative numbers)\n                expect(bucket1.toNumber()).toBeGreaterThanOrEqual(0);\n                expect(bucket2.toNumber()).toBeGreaterThanOrEqual(0);\n            });\n\n            it('gets a signed quote', async () => {\n                const quoteContext: FirmQuoteContext = {\n                    isFirm: true,\n                    workflow: 'rfqt',\n                    isUnwrap: false,\n                    originalMakerToken: '0x1',\n                    takerTokenDecimals: 18,\n                    makerTokenDecimals: 18,\n                    feeModelVersion: 1,\n                    assetFillAmount: new BigNumber(1000),\n                    chainId: 1337,\n                    integrator,\n                    makerToken,\n                    isSelling: false,\n                    takerAddress: NULL_ADDRESS,\n                    trader: takerAddress,\n                    takerToken,\n                    txOrigin: takerAddress,\n                };\n\n                mockRfqMakerManager.getRfqtV2MakersForPair = jest.fn().mockReturnValue([maker]);\n                mockQuoteServerClient.batchGetPriceV2Async = jest.fn().mockResolvedValue([\n                    {\n                        maker: makerAddress,\n                        makerUri: maker.rfqtUri,\n                        makerToken,\n                        takerToken,\n                        makerAmount: new BigNumber(999),\n                        takerAmount: new BigNumber(1000),\n                        expiry,\n                    },\n                ]);\n                const signature: Signature = { r: 'r', v: 21, s: 's', signatureType: SignatureType.EIP712 };\n                mockQuoteServerClient.signV2Async = jest.fn().mockResolvedValue(signature);\n                mockFeeService.calculateFeeAsync = jest.fn().mockResolvedValue({\n                    feeWithDetails: {\n                        token: '0x0b1ba0af832d7c05fd64161e0db78e85978e8082',\n                        amount: new BigNumber(100),\n                        type: 'fixed',\n                    },\n                });\n                mockRfqMakerBalanceCacheService.getERC20OwnerBalancesAsync = jest\n                    .fn()\n                    .mockResolvedValue([new BigNumber(10000)]);\n\n                const rfqtService = new RfqtService(\n                    1337, // tslint:disable-line: custom-no-magic-numbers\n                    mockRfqMakerManager,\n                    mockQuoteRequestor,\n                    mockQuoteServerClient,\n                    DEFAULT_MIN_EXPIRY_DURATION_MS,\n                    mockRfqBlockchainUtils,\n                    mockTokenMetadataManager,\n                    mockContractAddresses,\n                    mockFeeService,\n                    1,\n                    mockRfqMakerBalanceCacheService,\n                    mockCacheClient,\n                );\n\n                const result = await rfqtService.getV2QuotesAsync(quoteContext, fakeNow);\n\n                expect(result.length).toEqual(1);\n                expect(result[0]).toMatchObject({\n                    fillableMakerAmount: new BigNumber(999),\n                    fillableTakerAmount: new BigNumber(1000),\n                    fillableTakerFeeAmount: new BigNumber(0),\n                    makerId: maker.makerId,\n                    makerUri: maker.rfqtUri,\n                    signature,\n                });\n                expect(result[0].order).toMatchInlineSnapshot(`\n                OtcOrder {\n                  \"chainId\": 1337,\n                  \"expiry\": \"1657070278\",\n                  \"expiryAndNonce\": \"10401598717691489530826623925864187439861993812812831231287826374366\",\n                  \"maker\": \"0x79b7a69d90c82E014Bf0315e164208119B510FA0\",\n                  \"makerAmount\": \"999\",\n                  \"makerToken\": \"0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE\",\n                  \"nonce\": \"1657069278\",\n                  \"nonceBucket\": \"0\",\n                  \"taker\": \"0x0000000000000000000000000000000000000000\",\n                  \"takerAmount\": \"1000\",\n                  \"takerToken\": \"0x42d6622deCe394b54999Fbd73D108123806f6a18\",\n                  \"txOrigin\": \"0xE06fFA8146bBdECcBaaF72B6043b29091071AEB8\",\n                  \"verifyingContract\": \"0x5315e44798395d4a952530d131249fe00f554565\",\n                }\n              `);\n            });\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/QuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/RfqtService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmImplementaionUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmTypes.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/rfqMakerBlacklist.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/number_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/RfqtQuoteValidator.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/__tests__/quoteRequestorTest.ts",{"fileContent":"// tslint:disable max-file-line-count\nimport { tokenUtils } from '@0x/dev-utils';\nimport { FillQuoteTransformerOrderType, SignatureType } from '@0x/protocol-utils';\nimport { MarketOperation, StatusCodes } from '@0x/types';\nimport { BigNumber, logUtils } from '@0x/utils';\nimport Axios from 'axios';\nimport { expect } from 'chai';\nimport { Agent as HttpAgent } from 'http';\nimport { Agent as HttpsAgent } from 'https';\nimport * as _ from 'lodash';\n\nimport { KEEP_ALIVE_TTL, NULL_ADDRESS, ONE_SECOND_MS } from '../../core/constants';\nimport { TakerRequestQueryParamsUnnested, V4RFQIndicativeQuote } from '../../quote-server/types';\nimport {\n    AltMockedRfqQuoteResponse,\n    AltQuoteModel,\n    AltQuoteRequestData,\n    AltQuoteSide,\n    AltRfqMakerAssetOfferings,\n    MockedRfqQuoteResponse,\n} from '../altMmTypes';\nimport { QuoteRequestor } from '../QuoteRequestor';\n\nimport { RfqQuoteEndpoint, testHelpers } from './testHelpers';\n\nconst quoteRequestorHttpClient = Axios.create({\n    httpAgent: new HttpAgent({ keepAlive: true, timeout: KEEP_ALIVE_TTL }),\n    httpsAgent: new HttpsAgent({ keepAlive: true, timeout: KEEP_ALIVE_TTL }),\n});\n\nconst ALT_MM_API_KEY = 'averysecurekey';\nconst ALT_PROFILE = 'acoolprofile';\nconst ALT_RFQ_CREDS = {\n    altRfqApiKey: ALT_MM_API_KEY,\n    altRfqProfile: ALT_PROFILE,\n};\n\nconst CREATED_STATUS_CODE = 201;\n\nfunction makeThreeMinuteExpiry(): BigNumber {\n    const expiry = new Date(Date.now());\n    // tslint:disable-next-line: custom-no-magic-numbers\n    expiry.setMinutes(expiry.getMinutes() + 3);\n    return new BigNumber(Math.round(expiry.valueOf() / ONE_SECOND_MS));\n}\n\ndescribe('QuoteRequestor', () => {\n    const [makerToken, takerToken, otherToken1] = tokenUtils.getDummyERC20TokenAddresses();\n    const validSignature = { v: 28, r: '0x', s: '0x', signatureType: SignatureType.EthSign };\n\n    const altRfqAssetOfferings: AltRfqMakerAssetOfferings = {\n        'https://132.0.0.1': [\n            {\n                id: 'XYZ-123',\n                baseAsset: makerToken,\n                quoteAsset: takerToken,\n                baseAssetDecimals: 2,\n                quoteAssetDecimals: 3,\n            },\n        ],\n    };\n\n    describe('requestRfqtFirmQuotesAsync for firm quotes', () => {\n        it('should return successful RFQT requests', async () => {\n            const takerAddress = '0xd209925defc99488e3afff1174e48b4fa628302a';\n            const txOrigin = takerAddress;\n            const apiKey = 'my-ko0l-api-key';\n\n            // Set up RFQT responses\n            // tslint:disable-next-line:array-type\n            const mockedRequests: MockedRfqQuoteResponse[] = [];\n            const altMockedRequests: AltMockedRfqQuoteResponse[] = [];\n\n            const expectedParams: TakerRequestQueryParamsUnnested = {\n                sellTokenAddress: takerToken,\n                buyTokenAddress: makerToken,\n                sellAmountBaseUnits: '10000',\n                comparisonPrice: undefined,\n                takerAddress,\n                txOrigin,\n                protocolVersion: '4',\n            };\n            const mockedDefaults = {\n                requestApiKey: apiKey,\n                requestParams: expectedParams,\n                responseCode: StatusCodes.Success,\n            };\n            const validSignedOrder = {\n                makerToken,\n                takerToken,\n                makerAmount: new BigNumber('1000'),\n                takerAmount: new BigNumber('1000'),\n                maker: takerAddress,\n                taker: takerAddress,\n                pool: '0x',\n                salt: '0',\n                chainId: 1,\n                verifyingContract: takerAddress,\n                txOrigin,\n                expiry: makeThreeMinuteExpiry(),\n                signature: validSignature,\n            };\n            // request is to sell 10000 units of the base token\n            // 10 units at 3 decimals\n            const altFirmRequestData = {\n                market: 'XYZ-123',\n                model: AltQuoteModel.Firm,\n                profile: ALT_PROFILE,\n                side: AltQuoteSide.Sell,\n                meta: {\n                    txOrigin,\n                    taker: takerAddress,\n                    client: apiKey,\n                },\n                value: '10',\n            };\n            const altFirmResponse = {\n                ...altFirmRequestData,\n                id: 'random_id',\n                // tslint:disable-next-line:custom-no-magic-numbers\n                price: new BigNumber(10 / 100).toString(),\n                status: 'active',\n                data: {\n                    '0xv4order': validSignedOrder,\n                },\n            };\n\n            // Successful response\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://1337.0.0.1',\n                responseData: {\n                    signedOrder: validSignedOrder,\n                },\n            });\n            // Another Successful response\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://37.0.0.1',\n                responseData: { signedOrder: validSignedOrder },\n            });\n            // Test out a bad response code, ensure it doesnt cause throw\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://420.0.0.1',\n                responseData: { error: 'bad request' },\n                responseCode: StatusCodes.InternalError,\n            });\n            // Test out a successful response code but a partial order\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://421.0.0.1',\n                responseData: { signedOrder: { makerToken: '123' } },\n            });\n            // A successful response code and invalid response data (encoding)\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://421.1.0.1',\n                responseData: 'this is not JSON!',\n            });\n            // A successful response code and valid order, but for wrong maker asset data\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://422.0.0.1',\n                responseData: { signedOrder: { ...validSignedOrder, makerToken: '0x1234' } },\n            });\n            // A successful response code and valid order, but for wrong taker asset data\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://423.0.0.1',\n                responseData: { signedOrder: { ...validSignedOrder, takerToken: '0x1234' } },\n            });\n            // A successful response code and good order but its unsigned\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://424.0.0.1',\n                responseData: { signedOrder: _.omit(validSignedOrder, ['signature']) },\n            });\n            // A successful response code and good order but for the wrong txOrigin\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://425.0.0.1',\n                responseData: { signedOrder: { ...validSignedOrder, txOrigin: NULL_ADDRESS } },\n            });\n            // A successful response code and order from an alt RFQ implementation\n            altMockedRequests.push({\n                endpoint: 'https://132.0.0.1',\n                mmApiKey: ALT_MM_API_KEY,\n                responseCode: CREATED_STATUS_CODE,\n                requestData: altFirmRequestData,\n                responseData: altFirmResponse,\n            });\n\n            const normalizedSuccessfulOrder = {\n                order: {\n                    ..._.omit(validSignedOrder, ['signature']),\n                    makerAmount: new BigNumber(validSignedOrder.makerAmount),\n                    takerAmount: new BigNumber(validSignedOrder.takerAmount),\n                    expiry: new BigNumber(validSignedOrder.expiry),\n                    salt: new BigNumber(validSignedOrder.salt),\n                },\n                signature: validSignedOrder.signature,\n                type: FillQuoteTransformerOrderType.Rfq,\n            };\n\n            return testHelpers.withMockedRfqQuotes(\n                mockedRequests,\n                altMockedRequests,\n                RfqQuoteEndpoint.Firm,\n                async () => {\n                    const qr = new QuoteRequestor(\n                        {\n                            'https://1337.0.0.1': [[makerToken, takerToken]],\n                            'https://420.0.0.1': [[makerToken, takerToken]],\n                            'https://421.0.0.1': [[makerToken, takerToken]],\n                            'https://421.1.0.1': [[makerToken, takerToken]],\n                            'https://422.0.0.1': [[makerToken, takerToken]],\n                            'https://423.0.0.1': [[makerToken, takerToken]],\n                            'https://424.0.0.1': [[makerToken, takerToken]],\n                            'https://425.0.0.1': [[makerToken, takerToken]],\n                            'https://426.0.0.1':\n                                [] /* Shouldn't ping an RFQ-T provider when they don't support the requested asset pair. */,\n                            'https://37.0.0.1': [[makerToken, takerToken]],\n                        },\n                        quoteRequestorHttpClient,\n                        ALT_RFQ_CREDS,\n                    );\n                    const resp = await qr.requestRfqtFirmQuotesAsync(\n                        makerToken,\n                        takerToken,\n                        new BigNumber(10000),\n                        MarketOperation.Sell,\n                        undefined,\n                        {\n                            integrator: {\n                                allowedChainIds: [],\n                                apiKeys: [],\n                                integratorId: apiKey,\n                                label: 'foo',\n                                plp: false,\n                                rfqm: false,\n                                rfqt: true,\n                            },\n                            takerAddress,\n                            txOrigin: takerAddress,\n                            intentOnFilling: true,\n                            altRfqAssetOfferings,\n                        },\n                    );\n                    expect(resp).to.deep.eq([\n                        normalizedSuccessfulOrder,\n                        normalizedSuccessfulOrder,\n                        normalizedSuccessfulOrder,\n                    ]);\n                },\n                quoteRequestorHttpClient,\n            );\n        });\n    });\n    describe('requestRfqtIndicativeQuotesAsync for Indicative quotes', () => {\n        it('should optionally accept a \"comparisonPrice\" parameter', async () => {\n            const response = QuoteRequestor.makeQueryParameters(\n                otherToken1, // tx origin\n                otherToken1, // taker\n                MarketOperation.Sell,\n                makerToken,\n                takerToken,\n                new BigNumber(1000),\n                new BigNumber(300.2),\n            );\n            expect(response.comparisonPrice).to.eql('300.2');\n        });\n        it('should return successful RFQT requests', async () => {\n            const takerAddress = '0xd209925defc99488e3afff1174e48b4fa628302a';\n            const apiKey = 'my-ko0l-api-key';\n\n            // Set up RFQT responses\n            // tslint:disable-next-line:array-type\n            const mockedRequests: MockedRfqQuoteResponse[] = [];\n            const expectedParams: TakerRequestQueryParamsUnnested = {\n                sellTokenAddress: takerToken,\n                buyTokenAddress: makerToken,\n                sellAmountBaseUnits: '10000',\n                comparisonPrice: undefined,\n                takerAddress,\n                txOrigin: takerAddress,\n                protocolVersion: '4',\n            };\n            const mockedDefaults = {\n                requestApiKey: apiKey,\n                requestParams: expectedParams,\n                responseCode: StatusCodes.Success,\n            };\n\n            // Successful response\n            const successfulQuote1 = {\n                makerToken,\n                takerToken,\n                makerAmount: new BigNumber(expectedParams.sellAmountBaseUnits),\n                takerAmount: new BigNumber(expectedParams.sellAmountBaseUnits),\n                expiry: makeThreeMinuteExpiry(),\n            };\n\n            const goodMMUri1 = 'https://1337.0.0.1';\n            const goodMMUri2 = 'https://37.0.0.1';\n\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: goodMMUri1,\n                responseData: successfulQuote1,\n            });\n            // Test out a bad response code, ensure it doesnt cause throw\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://420.0.0.1',\n                responseData: { error: 'bad request' },\n                responseCode: StatusCodes.InternalError,\n            });\n            // Test out a successful response code but an invalid order\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://421.0.0.1',\n                responseData: { makerToken: '123' },\n            });\n            // A successful response code and valid response data, but for wrong maker asset data\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://422.0.0.1',\n                responseData: { ...successfulQuote1, makerToken: otherToken1 },\n            });\n            // A successful response code and valid response data, but for wrong taker asset data\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://423.0.0.1',\n                responseData: { ...successfulQuote1, takerToken: otherToken1 },\n            });\n            // Another Successful response\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: goodMMUri2,\n                responseData: successfulQuote1,\n            });\n\n            const assetOfferings: { [k: string]: [[string, string]] } = {\n                'https://420.0.0.1': [[makerToken, takerToken]],\n                'https://421.0.0.1': [[makerToken, takerToken]],\n                'https://422.0.0.1': [[makerToken, takerToken]],\n                'https://423.0.0.1': [[makerToken, takerToken]],\n                'https://424.0.0.1': [[makerToken, takerToken]],\n            };\n            assetOfferings[goodMMUri1] = [[makerToken, takerToken]];\n            assetOfferings[goodMMUri2] = [[makerToken, takerToken]];\n\n            return testHelpers.withMockedRfqQuotes(\n                mockedRequests,\n                [],\n                RfqQuoteEndpoint.Indicative,\n                async () => {\n                    const qr = new QuoteRequestor(assetOfferings, quoteRequestorHttpClient);\n                    const resp = await qr.requestRfqtIndicativeQuotesAsync(\n                        makerToken,\n                        takerToken,\n                        new BigNumber(10000),\n                        MarketOperation.Sell,\n                        undefined,\n                        {\n                            integrator: {\n                                allowedChainIds: [],\n                                apiKeys: [],\n                                integratorId: apiKey,\n                                label: 'foo',\n                                plp: false,\n                                rfqm: false,\n                                rfqt: true,\n                            },\n                            takerAddress,\n                            txOrigin: takerAddress,\n                            intentOnFilling: true,\n                        },\n                    );\n                    expect(resp.sort()).to.eql(\n                        [\n                            { ...successfulQuote1, makerUri: goodMMUri1 },\n                            { ...successfulQuote1, makerUri: goodMMUri2 },\n                        ].sort(),\n                    );\n                },\n                quoteRequestorHttpClient,\n            );\n        });\n        it('should only return RFQT requests that meet the timeout', async () => {\n            const takerAddress = '0xd209925defc99488e3afff1174e48b4fa628302a';\n            const apiKey = 'my-ko0l-api-key';\n            const maxTimeoutMs = 10;\n            // tslint:disable-next-line:custom-no-magic-numbers\n            const exceedTimeoutMs = maxTimeoutMs + 50;\n\n            // Set up RFQT responses\n            // tslint:disable-next-line:array-type\n            const mockedRequests: MockedRfqQuoteResponse[] = [];\n            const expectedParams: TakerRequestQueryParamsUnnested = {\n                sellTokenAddress: takerToken,\n                buyTokenAddress: makerToken,\n                sellAmountBaseUnits: '10000',\n                comparisonPrice: undefined,\n                takerAddress,\n                txOrigin: takerAddress,\n                protocolVersion: '4',\n            };\n            const mockedDefaults = {\n                requestApiKey: apiKey,\n                requestParams: expectedParams,\n                responseCode: StatusCodes.Success,\n            };\n\n            // Successful response\n            const successfulQuote1 = {\n                makerToken,\n                takerToken,\n                makerAmount: new BigNumber(expectedParams.sellAmountBaseUnits),\n                takerAmount: new BigNumber(expectedParams.sellAmountBaseUnits),\n                expiry: makeThreeMinuteExpiry(),\n            };\n\n            // One good request\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://1337.0.0.1',\n                responseData: successfulQuote1,\n            });\n\n            // One request that will timeout\n            mockedRequests.push({\n                ...mockedDefaults,\n                endpoint: 'https://420.0.0.1',\n                responseData: successfulQuote1,\n                callback: async () => {\n                    // tslint:disable-next-line:no-inferred-empty-object-type\n                    return new Promise((resolve, _reject) => {\n                        setTimeout(() => {\n                            resolve([StatusCodes.Success, successfulQuote1]);\n                        }, exceedTimeoutMs);\n                    });\n                },\n            });\n\n            return testHelpers.withMockedRfqQuotes(\n                mockedRequests,\n                [],\n                RfqQuoteEndpoint.Indicative,\n                async () => {\n                    const qr = new QuoteRequestor(\n                        {\n                            'https://1337.0.0.1': [[makerToken, takerToken]],\n                            'https://420.0.0.1': [[makerToken, takerToken]],\n                        },\n                        quoteRequestorHttpClient,\n                    );\n                    const resp = await qr.requestRfqtIndicativeQuotesAsync(\n                        makerToken,\n                        takerToken,\n                        new BigNumber(10000),\n                        MarketOperation.Sell,\n                        undefined,\n                        {\n                            integrator: {\n                                allowedChainIds: [],\n                                apiKeys: [],\n                                integratorId: apiKey,\n                                label: 'foo',\n                                plp: false,\n                                rfqm: false,\n                                rfqt: true,\n                            },\n                            takerAddress,\n                            txOrigin: takerAddress,\n                            intentOnFilling: true,\n                            makerEndpointMaxResponseTimeMs: maxTimeoutMs,\n                        },\n                    );\n                    expect(resp.sort()).to.eql([{ ...successfulQuote1, makerUri: 'https://1337.0.0.1' }].sort()); // notice only one result, despite two requests made\n                },\n                quoteRequestorHttpClient,\n            );\n        });\n        it('should return successful RFQT indicative quote requests (Buy)', async () => {\n            const takerAddress = '0xd209925defc99488e3afff1174e48b4fa628302a';\n            const apiKey = 'my-ko0l-api-key';\n\n            // Set up RFQT responses\n            // tslint:disable-next-line:array-type\n            const mockedRequests: MockedRfqQuoteResponse[] = [];\n            const expectedParams: TakerRequestQueryParamsUnnested = {\n                sellTokenAddress: takerToken,\n                buyTokenAddress: makerToken,\n                buyAmountBaseUnits: '10000',\n                comparisonPrice: undefined,\n                takerAddress,\n                txOrigin: takerAddress,\n                protocolVersion: '4',\n            };\n            // Successful response\n            const successfulQuote1 = {\n                makerToken,\n                takerToken,\n                makerAmount: new BigNumber(expectedParams.buyAmountBaseUnits),\n                takerAmount: new BigNumber(expectedParams.buyAmountBaseUnits),\n                expiry: makeThreeMinuteExpiry(),\n            };\n            mockedRequests.push({\n                endpoint: 'https://1337.0.0.1',\n                requestApiKey: apiKey,\n                requestParams: expectedParams,\n                responseData: successfulQuote1,\n                responseCode: StatusCodes.Success,\n            });\n\n            return testHelpers.withMockedRfqQuotes(\n                mockedRequests,\n                [],\n                RfqQuoteEndpoint.Indicative,\n                async () => {\n                    const qr = new QuoteRequestor(\n                        { 'https://1337.0.0.1': [[makerToken, takerToken]] },\n                        quoteRequestorHttpClient,\n                    );\n                    const resp = await qr.requestRfqtIndicativeQuotesAsync(\n                        makerToken,\n                        takerToken,\n                        new BigNumber(10000),\n                        MarketOperation.Buy,\n                        undefined,\n                        {\n                            integrator: {\n                                integratorId: apiKey,\n                                label: 'foo',\n                                apiKeys: [],\n                                allowedChainIds: [],\n                                rfqm: false,\n                                rfqt: true,\n                                plp: false,\n                            },\n                            takerAddress,\n                            txOrigin: takerAddress,\n                            intentOnFilling: true,\n                        },\n                    );\n                    expect(resp.sort()).to.eql([{ ...successfulQuote1, makerUri: 'https://1337.0.0.1' }].sort());\n                },\n                quoteRequestorHttpClient,\n            );\n        });\n        it('should be able to handle and filter RFQ offerings', () => {\n            const tests: [string[] | undefined, string[]][] = [\n                [['https://top.maker'], []],\n                [undefined, ['https://foo.bar/', 'https://lorem.ipsum/']],\n                [['https://lorem.ipsum/'], ['https://lorem.ipsum/']],\n            ];\n            for (const test of tests) {\n                const [apiKeyWhitelist, results] = test;\n                const response = QuoteRequestor.getTypedMakerUrlsAndWhitelist(\n                    {\n                        integrator: {\n                            allowedChainIds: [],\n                            apiKeys: [],\n                            integratorId: 'foo',\n                            label: 'bar',\n                            plp: false,\n                            rfqm: false,\n                            rfqt: true,\n                            whitelistIntegratorUrls: apiKeyWhitelist,\n                        },\n                        altRfqAssetOfferings: {},\n                    },\n                    {\n                        'https://foo.bar/': [\n                            [\n                                '0xA6cD4cb8c62aCDe44739E3Ed0F1d13E0e31f2d94',\n                                '0xF45107c0200a04A8aB9C600cc52A3C89AE5D0489',\n                            ],\n                        ],\n                        'https://lorem.ipsum/': [\n                            [\n                                '0xA6cD4cb8c62aCDe44739E3Ed0F1d13E0e31f2d94',\n                                '0xF45107c0200a04A8aB9C600cc52A3C89AE5D0489',\n                            ],\n                        ],\n                    },\n                );\n                const typedUrls = response.map((typed) => typed.url);\n                expect(typedUrls).to.eql(results);\n            }\n        });\n\n        it('should return successful alt indicative quotes', async () => {\n            const takerAddress = '0xd209925defc99488e3afff1174e48b4fa628302a';\n            const txOrigin = '0xf209925defc99488e3afff1174e48b4fa628302a';\n            const apiKey = 'my-ko0l-api-key';\n\n            // base token has 2 decimals\n            // quote token has 3 decimals\n            const baseToken = makerToken;\n            const quoteToken = takerToken;\n\n            // Set up RFQT responses\n            const altMockedRequests: AltMockedRfqQuoteResponse[] = [];\n            const altScenarios: {\n                successfulQuote: V4RFQIndicativeQuote;\n                requestedMakerToken: string;\n                requestedTakerToken: string;\n                requestedAmount: BigNumber;\n                requestedOperation: MarketOperation;\n            }[] = [];\n\n            // SCENARIO 1\n            // buy, base asset specified\n            // requesting to buy 100 units (10000 base units) of the base token\n            // returning a price of 0.01, which should mean 10000 maker, 1000 taker amount\n            const buyAmountAltRequest: AltQuoteRequestData = {\n                market: 'XYZ-123',\n                model: AltQuoteModel.Indicative,\n                profile: ALT_PROFILE,\n                side: AltQuoteSide.Sell,\n                meta: {\n                    txOrigin,\n                    taker: takerAddress,\n                    client: apiKey,\n                },\n                amount: '100',\n            };\n            // Successful response\n            const buyAmountAltResponse = {\n                ...buyAmountAltRequest,\n                id: 'random_id',\n                // tslint:disable-next-line:custom-no-magic-numbers\n                price: new BigNumber(0.01).toString(),\n                status: 'live',\n            };\n            const successfulBuyAmountQuote: V4RFQIndicativeQuote = {\n                makerToken: baseToken,\n                takerToken: quoteToken,\n                makerAmount: new BigNumber(10000),\n                takerAmount: new BigNumber(1000),\n                expiry: new BigNumber(0),\n            };\n            altMockedRequests.push({\n                endpoint: 'https://132.0.0.1',\n                mmApiKey: ALT_MM_API_KEY,\n                responseCode: CREATED_STATUS_CODE,\n                requestData: buyAmountAltRequest,\n                responseData: buyAmountAltResponse,\n            });\n            altScenarios.push({\n                successfulQuote: successfulBuyAmountQuote,\n                requestedMakerToken: baseToken,\n                requestedTakerToken: quoteToken,\n                requestedAmount: new BigNumber(10000),\n                requestedOperation: MarketOperation.Buy,\n            });\n\n            // SCENARIO 2\n            // alt buy, quote asset specified\n            // user is requesting to sell 1 unit of the quote token, or 1000 base units\n            // returning a price of 0.01, which should mean 10000 maker amount, 1000 taker amount\n            const buyValueAltRequest: AltQuoteRequestData = {\n                market: 'XYZ-123',\n                model: AltQuoteModel.Indicative,\n                profile: ALT_PROFILE,\n                side: AltQuoteSide.Sell,\n                meta: {\n                    txOrigin,\n                    taker: takerAddress,\n                    client: apiKey,\n                },\n                value: '1',\n            };\n            // Successful response\n            const buyValueAltResponse = {\n                ...buyValueAltRequest,\n                id: 'random_id',\n                // tslint:disable-next-line:custom-no-magic-numbers\n                price: new BigNumber(0.01).toString(),\n                status: 'live',\n            };\n            const successfulBuyValueQuote: V4RFQIndicativeQuote = {\n                makerToken: baseToken,\n                takerToken: quoteToken,\n                makerAmount: new BigNumber(10000),\n                takerAmount: new BigNumber(1000),\n                expiry: new BigNumber(0),\n            };\n            altMockedRequests.push({\n                endpoint: 'https://132.0.0.1',\n                mmApiKey: ALT_MM_API_KEY,\n                responseCode: CREATED_STATUS_CODE,\n                requestData: buyValueAltRequest,\n                responseData: buyValueAltResponse,\n            });\n            altScenarios.push({\n                successfulQuote: successfulBuyValueQuote,\n                requestedMakerToken: baseToken,\n                requestedTakerToken: quoteToken,\n                requestedAmount: new BigNumber(1000),\n                requestedOperation: MarketOperation.Sell,\n            });\n\n            // SCENARIO 3\n            // alt sell, base asset specified\n            // user is requesting to sell 100 units (10000 base units) of the base token\n            // returning a price of 0.01, which should mean 10000 taker amount, 1000 maker amount\n            const sellAmountAltRequest: AltQuoteRequestData = {\n                market: 'XYZ-123',\n                model: AltQuoteModel.Indicative,\n                profile: ALT_PROFILE,\n                side: AltQuoteSide.Buy,\n                meta: {\n                    txOrigin,\n                    taker: takerAddress,\n                    client: apiKey,\n                },\n                amount: '100',\n            };\n            // Successful response\n            const sellAmountAltResponse = {\n                ...sellAmountAltRequest,\n                id: 'random_id',\n                // tslint:disable-next-line:custom-no-magic-numbers\n                price: new BigNumber(0.01).toString(),\n                status: 'live',\n            };\n            const successfulSellAmountQuote: V4RFQIndicativeQuote = {\n                makerToken: quoteToken,\n                takerToken: baseToken,\n                makerAmount: new BigNumber(1000),\n                takerAmount: new BigNumber(10000),\n                expiry: new BigNumber(0),\n            };\n            altMockedRequests.push({\n                endpoint: 'https://132.0.0.1',\n                mmApiKey: ALT_MM_API_KEY,\n                responseCode: CREATED_STATUS_CODE,\n                requestData: sellAmountAltRequest,\n                responseData: sellAmountAltResponse,\n            });\n            altScenarios.push({\n                successfulQuote: successfulSellAmountQuote,\n                requestedMakerToken: quoteToken,\n                requestedTakerToken: baseToken,\n                requestedAmount: new BigNumber(10000),\n                requestedOperation: MarketOperation.Sell,\n            });\n\n            // SCENARIO 4\n            // alt sell, quote asset specified\n            // user is requesting to buy 1 unit (1000 base units) of the quote token\n            // returning a price of 0.01, which should mean 10000 taker amount, 1000 maker amount\n            const sellValueAltRequest: AltQuoteRequestData = {\n                market: 'XYZ-123',\n                model: AltQuoteModel.Indicative,\n                profile: ALT_PROFILE,\n                side: AltQuoteSide.Buy,\n                meta: {\n                    txOrigin,\n                    taker: takerAddress,\n                    client: apiKey,\n                },\n                value: '1',\n            };\n            // Successful response\n            const sellValueAltResponse = {\n                ...sellValueAltRequest,\n                id: 'random_id',\n                // tslint:disable-next-line:custom-no-magic-numbers\n                price: new BigNumber(0.01).toString(),\n                status: 'live',\n            };\n            const successfulSellValueQuote: V4RFQIndicativeQuote = {\n                makerToken: quoteToken,\n                takerToken: baseToken,\n                makerAmount: new BigNumber(1000),\n                takerAmount: new BigNumber(10000),\n                expiry: new BigNumber(0),\n            };\n            altMockedRequests.push({\n                endpoint: 'https://132.0.0.1',\n                mmApiKey: ALT_MM_API_KEY,\n                responseCode: CREATED_STATUS_CODE,\n                requestData: sellValueAltRequest,\n                responseData: sellValueAltResponse,\n            });\n            altScenarios.push({\n                successfulQuote: successfulSellValueQuote,\n                requestedMakerToken: quoteToken,\n                requestedTakerToken: baseToken,\n                requestedAmount: new BigNumber(1000),\n                requestedOperation: MarketOperation.Buy,\n            });\n\n            let scenarioCounter = 1;\n            for (const altScenario of altScenarios) {\n                logUtils.log(`Alt MM indicative scenario ${scenarioCounter}`);\n                scenarioCounter += 1;\n                await testHelpers.withMockedRfqQuotes(\n                    [],\n                    altMockedRequests,\n                    RfqQuoteEndpoint.Indicative,\n                    async () => {\n                        const qr = new QuoteRequestor({}, quoteRequestorHttpClient, ALT_RFQ_CREDS);\n                        const resp = await qr.requestRfqtIndicativeQuotesAsync(\n                            altScenario.requestedMakerToken,\n                            altScenario.requestedTakerToken,\n                            altScenario.requestedAmount,\n                            altScenario.requestedOperation,\n                            undefined,\n                            {\n                                integrator: {\n                                    allowedChainIds: [],\n                                    apiKeys: [],\n                                    integratorId: apiKey,\n                                    label: 'foo',\n                                    plp: false,\n                                    rfqm: false,\n                                    rfqt: true,\n                                },\n                                takerAddress,\n                                txOrigin,\n                                intentOnFilling: true,\n                                altRfqAssetOfferings,\n                            },\n                        );\n                        // hack to get the expiry right, since it's dependent on the current timestamp\n                        const expected = { ...altScenario.successfulQuote, expiry: resp[0].expiry };\n                        expect(resp.sort()).to.eql([expected].sort());\n                    },\n                    quoteRequestorHttpClient,\n                );\n            }\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmTypes.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/QuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/__tests__/testHelpers.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmImplementaionUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/rfqMakerBlacklist.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/__tests__/testHelpers.ts",{"fileContent":"import axios, { AxiosInstance } from 'axios';\nimport AxiosMockAdapter from 'axios-mock-adapter';\nimport * as _ from 'lodash';\nimport { AltMockedRfqQuoteResponse, MockedRfqQuoteResponse } from '../altMmTypes';\n\nexport enum RfqQuoteEndpoint {\n    Indicative = 'price',\n    Firm = 'quote',\n}\n\nexport const testHelpers = {\n    /**\n     * A helper utility for testing which mocks out\n     * requests to RFQ-T/M providers\n     */\n    withMockedRfqQuotes: async (\n        standardMockedResponses: MockedRfqQuoteResponse[],\n        altMockedResponses: AltMockedRfqQuoteResponse[],\n        quoteType: RfqQuoteEndpoint,\n        afterResponseCallback: () => Promise<void>,\n        axiosClient: AxiosInstance = axios,\n    ): Promise<void> => {\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const mockedAxios = new AxiosMockAdapter(axiosClient, { onNoMatch: 'throwException' } as any);\n        try {\n            // Mock out Standard RFQ-T/M responses\n            for (const mockedResponse of standardMockedResponses) {\n                const { endpoint, requestApiKey, requestParams, responseData, responseCode } = mockedResponse;\n                const requestHeaders = {\n                    Accept: 'application/json, text/plain, */*',\n                    '0x-api-key': requestApiKey,\n                    '0x-integrator-id': requestApiKey,\n                };\n                if (mockedResponse.callback !== undefined) {\n                    mockedAxios\n                        .onGet(`${endpoint}/${quoteType}`, { params: requestParams }, requestHeaders)\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        .reply(mockedResponse.callback as any);\n                } else {\n                    mockedAxios\n                        .onGet(`${endpoint}/${quoteType}`, { params: requestParams }, requestHeaders)\n                        .replyOnce(responseCode, responseData);\n                }\n            }\n            // Mock out Alt RFQ-T/M responses\n            for (const mockedResponse of altMockedResponses) {\n                const { endpoint, /* mmApiKey, */ requestData, responseData, responseCode } = mockedResponse;\n                // Commented out during copy-paste\n                // const requestHeaders = {\n                //     Accept: 'application/json, text/plain, */*',\n                //     'Content-Type': 'application/json;charset=utf-8',\n                //     Authorization: `Bearer ${mmApiKey}`,\n                // };\n                mockedAxios\n                    .onPost(\n                        `${endpoint}/quotes`,\n                        // hack to get AxiosMockAdapter to recognize the match\n                        // b/t the mock data and the request data\n                        {\n                            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            asymmetricMatch: (x: any) => {\n                                return _.isEqual(requestData, x);\n                            },\n                        },\n                        // commented out to avoid over-specifying what the mock will match on.\n                        // requestHeaders,\n                    )\n                    .replyOnce(responseCode, responseData);\n            }\n            // Perform the callback function, e.g. a test validation\n            await afterResponseCallback();\n        } finally {\n            // Ensure we always restore axios afterwards\n            mockedAxios.restore();\n        }\n    },\n};\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmTypes.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/quote_comparison_utils_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\n// tslint:disable:no-empty\n// tslint:disable:max-file-line-count\nimport { OtcOrder, SignatureType } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { expect } from 'chai';\n\nimport { DEFAULT_MIN_EXPIRY_DURATION_MS, ONE_SECOND_MS, ZERO } from '../../src/core/constants';\nimport { FirmOtcQuote, IndicativeQuote } from '../../src/core/types';\nimport { getBestQuote } from '../../src/utils/quote_comparison_utils';\n\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n// eslint-disable-next-line @typescript-eslint/no-loss-of-precision\nconst NEVER_EXPIRES = new BigNumber(9999999999999999);\n\nfunction createBaseQuote(): FirmOtcQuote {\n    return {\n        order: new OtcOrder({\n            makerAmount: ZERO,\n            takerAmount: ZERO,\n        }),\n        kind: 'otc',\n        makerSignature: {\n            signatureType: SignatureType.Invalid,\n            v: 0,\n            r: '0x1',\n            s: '0x2',\n        },\n        makerUri: 'someuri.xyz',\n    };\n}\ndescribe('Quote Comparison Utils', () => {\n    describe('getBestQuote', () => {\n        const makerToken = 'DAI';\n        const takerToken = 'SUSD';\n        const assetFillAmount = new BigNumber(100);\n        const validityWindowMs = DEFAULT_MIN_EXPIRY_DURATION_MS;\n        const inThirtySeconds = new BigNumber(Math.round((Date.now() + ONE_SECOND_MS * 30) / ONE_SECOND_MS));\n\n        describe('IndicativeQuotes when selling', () => {\n            // Given\n            const BASE_INDICATIVE_QUOTE = {\n                makerUri: 'http://makeruri',\n                maker: '0xmaker',\n                makerToken,\n                takerToken,\n                expiry: NEVER_EXPIRES,\n            };\n\n            describe('sells', () => {\n                const isSelling = true;\n                const partialFillQuote: IndicativeQuote = {\n                    ...BASE_INDICATIVE_QUOTE,\n                    makerAmount: new BigNumber(55),\n                    takerAmount: new BigNumber(50),\n                };\n\n                const fullQuoteBadPricing: IndicativeQuote = {\n                    ...BASE_INDICATIVE_QUOTE,\n                    makerAmount: new BigNumber(99),\n                    takerAmount: new BigNumber(100),\n                };\n\n                const fullQuoteOkPricing: IndicativeQuote = {\n                    ...BASE_INDICATIVE_QUOTE,\n                    makerAmount: new BigNumber(105),\n                    takerAmount: new BigNumber(100),\n                };\n\n                const fullQuoteGreatPricing: IndicativeQuote = {\n                    ...BASE_INDICATIVE_QUOTE,\n                    makerAmount: new BigNumber(125),\n                    takerAmount: new BigNumber(100),\n                };\n\n                const wrongPair: IndicativeQuote = {\n                    ...BASE_INDICATIVE_QUOTE,\n                    expiry: NEVER_EXPIRES,\n                    makerAmount: new BigNumber(125),\n                    makerToken: takerToken,\n                    makerUri: 'http://makeruri',\n                    takerAmount: new BigNumber(100),\n                    takerToken: makerToken,\n                };\n\n                const expiresInOneMinute: IndicativeQuote = {\n                    ...BASE_INDICATIVE_QUOTE,\n                    makerAmount: new BigNumber(125),\n                    takerAmount: new BigNumber(100),\n                    expiry: inThirtySeconds,\n                };\n\n                const tests = [\n                    {\n                        name: 'should return null when no quotes valid',\n                        quotes: [partialFillQuote],\n                        expectations: {\n                            isNull: true,\n                            makerAmount: undefined,\n                            takerAmount: undefined,\n                        },\n                    },\n                    {\n                        name: 'should only select quotes that are 100% filled',\n                        quotes: [partialFillQuote, fullQuoteBadPricing],\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 99,\n                            takerAmount: 100,\n                        },\n                    },\n                    {\n                        name: 'should select quote with best pricing',\n                        quotes: [fullQuoteBadPricing, fullQuoteGreatPricing, fullQuoteOkPricing],\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 125,\n                            takerAmount: 100,\n                        },\n                    },\n                    {\n                        name: 'should ignore quotes with the wrong pair',\n                        quotes: [fullQuoteBadPricing, wrongPair],\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 99,\n                            takerAmount: 100,\n                        },\n                    },\n                    {\n                        name: 'should ignore quotes that expire too soon',\n                        quotes: [fullQuoteBadPricing, expiresInOneMinute],\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 99,\n                            takerAmount: 100,\n                        },\n                    },\n                ];\n\n                tests.forEach(({ name, quotes, expectations }) => {\n                    it(name, () => {\n                        const bestQuote = getBestQuote<IndicativeQuote>(\n                            quotes,\n                            isSelling,\n                            takerToken,\n                            makerToken,\n                            assetFillAmount,\n                            validityWindowMs,\n                        );\n\n                        if (bestQuote === null) {\n                            expect(expectations?.isNull).to.equal(true);\n                            return;\n                        }\n\n                        expect(expectations?.isNull).to.equal(false);\n                        expect(bestQuote.makerAmount.toNumber()).to.be.eq(expectations?.makerAmount);\n                        expect(bestQuote.takerAmount.toNumber()).to.be.eq(expectations?.takerAmount);\n                    });\n                });\n            });\n\n            describe('buys', () => {\n                const isSelling = false;\n                const partialFillQuote: IndicativeQuote = {\n                    ...BASE_INDICATIVE_QUOTE,\n                    makerAmount: new BigNumber(55),\n                    takerAmount: new BigNumber(50),\n                };\n\n                const fullQuoteBadPricing: IndicativeQuote = {\n                    ...BASE_INDICATIVE_QUOTE,\n                    makerAmount: new BigNumber(100),\n                    takerAmount: new BigNumber(125),\n                };\n\n                const fullQuoteOkPricing: IndicativeQuote = {\n                    ...BASE_INDICATIVE_QUOTE,\n                    makerAmount: new BigNumber(100),\n                    takerAmount: new BigNumber(120),\n                };\n\n                const fullQuoteGreatPricing: IndicativeQuote = {\n                    ...BASE_INDICATIVE_QUOTE,\n                    makerAmount: new BigNumber(100),\n                    takerAmount: new BigNumber(80),\n                };\n\n                const wrongPair: IndicativeQuote = {\n                    ...BASE_INDICATIVE_QUOTE,\n                    makerToken: takerToken,\n                    takerToken: makerToken,\n                    expiry: NEVER_EXPIRES,\n                    makerAmount: new BigNumber(100),\n                    takerAmount: new BigNumber(80),\n                };\n\n                const expiresInOneMinute = {\n                    ...BASE_INDICATIVE_QUOTE,\n                    makerAmount: new BigNumber(100),\n                    takerAmount: new BigNumber(80),\n                    expiry: inThirtySeconds,\n                };\n\n                const tests = [\n                    {\n                        name: 'should return null when no quotes valid',\n                        quotes: [partialFillQuote],\n                        expectations: {\n                            isNull: true,\n                            makerAmount: undefined,\n                            takerAmount: undefined,\n                        },\n                    },\n                    {\n                        name: 'should only select quotes that are 100% filled',\n                        quotes: [partialFillQuote, fullQuoteBadPricing],\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 100,\n                            takerAmount: 125,\n                        },\n                    },\n                    {\n                        name: 'should select quote with best pricing',\n                        quotes: [fullQuoteBadPricing, fullQuoteGreatPricing, fullQuoteOkPricing],\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 100,\n                            takerAmount: 80,\n                        },\n                    },\n                    {\n                        name: 'should ignore quotes with the wrong pair',\n                        quotes: [fullQuoteBadPricing, wrongPair],\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 100,\n                            takerAmount: 125,\n                        },\n                    },\n                    {\n                        name: 'should ignore quotes that expire too soon',\n                        quotes: [fullQuoteBadPricing, expiresInOneMinute],\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 100,\n                            takerAmount: 125,\n                        },\n                    },\n                ];\n\n                tests.forEach(({ name, quotes, expectations }) => {\n                    it(name, () => {\n                        const bestQuote = getBestQuote<IndicativeQuote>(\n                            quotes,\n                            isSelling,\n                            takerToken,\n                            makerToken,\n                            assetFillAmount,\n                            validityWindowMs,\n                        );\n\n                        if (bestQuote === null) {\n                            expect(expectations?.isNull).to.equal(true);\n                            return;\n                        }\n\n                        expect(expectations?.isNull).to.equal(false);\n                        expect(bestQuote.makerAmount.toNumber()).to.be.eq(expectations?.makerAmount);\n                        expect(bestQuote.takerAmount.toNumber()).to.be.eq(expectations?.takerAmount);\n                    });\n                });\n            });\n        });\n\n        describe('FirmQuotes', () => {\n            // Given\n            const BASE_QUOTE = createBaseQuote();\n\n            const BASE_ORDER = new OtcOrder({\n                makerToken,\n                takerToken,\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(NEVER_EXPIRES, ZERO, ZERO),\n            });\n\n            describe('sells', () => {\n                const isSelling = true;\n                const partialFillQuote: FirmOtcQuote = {\n                    ...BASE_QUOTE,\n                    order: new OtcOrder({\n                        ...BASE_ORDER,\n                        makerAmount: new BigNumber(55),\n                        takerAmount: new BigNumber(50),\n                    }),\n                };\n\n                const fullQuoteBadPricing: FirmOtcQuote = {\n                    ...BASE_QUOTE,\n                    order: new OtcOrder({\n                        ...BASE_ORDER,\n                        makerAmount: new BigNumber(99),\n                        takerAmount: new BigNumber(100),\n                    }),\n                };\n\n                const fullQuoteOkPricing: FirmOtcQuote = {\n                    ...BASE_QUOTE,\n                    order: new OtcOrder({\n                        ...BASE_ORDER,\n                        makerAmount: new BigNumber(105),\n                        takerAmount: new BigNumber(100),\n                    }),\n                };\n\n                const fullQuoteGreatPricing: FirmOtcQuote = {\n                    ...BASE_QUOTE,\n                    order: new OtcOrder({\n                        ...BASE_ORDER,\n                        makerAmount: new BigNumber(125),\n                        takerAmount: new BigNumber(100),\n                    }),\n                };\n\n                const wrongPair: FirmOtcQuote = {\n                    ...BASE_QUOTE,\n                    order: new OtcOrder({\n                        ...BASE_ORDER,\n                        makerToken: takerToken,\n                        takerToken: makerToken,\n                        makerAmount: new BigNumber(125),\n                        takerAmount: new BigNumber(100),\n                    }),\n                };\n\n                const expiresInOneMinute: FirmOtcQuote = {\n                    ...BASE_QUOTE,\n                    order: new OtcOrder({\n                        ...BASE_ORDER,\n                        makerAmount: new BigNumber(125),\n                        takerAmount: new BigNumber(100),\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(inThirtySeconds, ZERO, ZERO),\n                    }),\n                };\n\n                // TODO (MKR-671): uncomment once filter is enabled\n                const validMakerBalances: BigNumber[] = [new BigNumber(150), new BigNumber(150)];\n                const invalidMakerBalances: BigNumber[] = [new BigNumber(150), new BigNumber(50)];\n\n                const tests = [\n                    {\n                        name: 'should return null when no quotes valid',\n                        args: {\n                            quotes: [partialFillQuote],\n                        },\n                        expectations: {\n                            isNull: true,\n                            makerAmount: undefined,\n                            takerAmount: undefined,\n                        },\n                    },\n                    {\n                        name: 'should only select quotes that are 100% filled',\n                        args: {\n                            quotes: [partialFillQuote, fullQuoteBadPricing],\n                        },\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 99,\n                            takerAmount: 100,\n                        },\n                    },\n                    {\n                        name: 'should select quote with best pricing',\n                        args: {\n                            quotes: [fullQuoteBadPricing, fullQuoteGreatPricing, fullQuoteOkPricing],\n                        },\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 125,\n                            takerAmount: 100,\n                        },\n                    },\n                    {\n                        name: 'should ignore quotes with the wrong pair',\n                        args: {\n                            quotes: [fullQuoteBadPricing, wrongPair],\n                        },\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 99,\n                            takerAmount: 100,\n                        },\n                    },\n                    {\n                        name: 'should ignore quotes that expire too soon',\n                        args: {\n                            quotes: [fullQuoteBadPricing, expiresInOneMinute],\n                        },\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 99,\n                            takerAmount: 100,\n                        },\n                    },\n                    // TODO (MKR-671): uncomment once filter is enabled\n                    {\n                        name: 'should not ignore quotes if makers have enough balances',\n                        args: {\n                            quotes: [fullQuoteBadPricing, fullQuoteOkPricing],\n                            quotedMakerBalances: validMakerBalances,\n                        },\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 105,\n                            takerAmount: 100,\n                        },\n                    },\n                    {\n                        name: 'should ignore quotes if makers do not have enough balances',\n                        args: {\n                            quotes: [fullQuoteBadPricing, fullQuoteOkPricing],\n                            quotedMakerBalances: invalidMakerBalances,\n                        },\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 99,\n                            takerAmount: 100,\n                        },\n                    },\n                ];\n\n                tests.forEach(({ name, args, expectations }) => {\n                    it(name, () => {\n                        const bestQuote = getBestQuote(\n                            args?.quotes,\n                            isSelling,\n                            takerToken,\n                            makerToken,\n                            assetFillAmount,\n                            validityWindowMs,\n                            args?.quotedMakerBalances,\n                        );\n\n                        if (bestQuote === null) {\n                            expect(expectations?.isNull).to.equal(true);\n                            return;\n                        }\n\n                        expect(expectations?.isNull).to.equal(false);\n                        expect(bestQuote.order.makerAmount.toNumber()).to.be.eq(expectations?.makerAmount);\n                        expect(bestQuote.order.takerAmount.toNumber()).to.be.eq(expectations?.takerAmount);\n                    });\n                });\n            });\n\n            describe('buys', () => {\n                const isSelling = false;\n                const partialFillQuote: FirmOtcQuote = {\n                    ...BASE_QUOTE,\n                    order: new OtcOrder({\n                        ...BASE_ORDER,\n                        makerAmount: new BigNumber(55),\n                        takerAmount: new BigNumber(50),\n                    }),\n                };\n                const fullQuoteBadPricing: FirmOtcQuote = {\n                    ...BASE_QUOTE,\n                    order: new OtcOrder({\n                        ...BASE_ORDER,\n                        makerAmount: new BigNumber(100),\n                        takerAmount: new BigNumber(125),\n                    }),\n                };\n\n                const fullQuoteOkPricing: FirmOtcQuote = {\n                    ...BASE_QUOTE,\n                    order: new OtcOrder({\n                        ...BASE_ORDER,\n                        makerAmount: new BigNumber(100),\n                        takerAmount: new BigNumber(120),\n                    }),\n                };\n\n                const fullQuoteGreatPricing: FirmOtcQuote = {\n                    ...BASE_QUOTE,\n                    order: new OtcOrder({\n                        ...BASE_ORDER,\n                        makerAmount: new BigNumber(100),\n                        takerAmount: new BigNumber(80),\n                    }),\n                };\n\n                const wrongPair: FirmOtcQuote = {\n                    ...BASE_QUOTE,\n                    order: new OtcOrder({\n                        ...BASE_ORDER,\n                        makerToken: takerToken,\n                        takerToken: makerToken,\n                        makerAmount: new BigNumber(100),\n                        takerAmount: new BigNumber(80),\n                    }),\n                };\n\n                const expiresInOneMinute: FirmOtcQuote = {\n                    ...BASE_QUOTE,\n                    order: new OtcOrder({\n                        ...BASE_ORDER,\n                        makerAmount: new BigNumber(100),\n                        takerAmount: new BigNumber(80),\n                        expiryAndNonce: OtcOrder.encodeExpiryAndNonce(inThirtySeconds, ZERO, ZERO),\n                    }),\n                };\n\n                // TODO (MKR-671): uncomment once filter is enabled\n                const validMakerBalances: BigNumber[] = [new BigNumber(150), new BigNumber(150)];\n                const invalidMakerBalances: BigNumber[] = [new BigNumber(150), new BigNumber(50)];\n\n                const tests = [\n                    {\n                        name: 'should return null when no quotes valid',\n                        args: {\n                            quotes: [partialFillQuote],\n                        },\n                        expectations: {\n                            isNull: true,\n                            makerAmount: undefined,\n                            takerAmount: undefined,\n                        },\n                    },\n                    {\n                        name: 'should only select quotes that are 100% filled',\n                        args: {\n                            quotes: [partialFillQuote, fullQuoteBadPricing],\n                        },\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 100,\n                            takerAmount: 125,\n                        },\n                    },\n                    {\n                        name: 'should select quote with best pricing',\n                        args: {\n                            quotes: [fullQuoteBadPricing, fullQuoteGreatPricing, fullQuoteOkPricing],\n                        },\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 100,\n                            takerAmount: 80,\n                        },\n                    },\n                    {\n                        name: 'should ignore quotes with the wrong pair',\n                        args: {\n                            quotes: [fullQuoteBadPricing, wrongPair],\n                        },\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 100,\n                            takerAmount: 125,\n                        },\n                    },\n                    {\n                        name: 'should ignore quotes that expire too soon',\n                        args: {\n                            quotes: [fullQuoteBadPricing, expiresInOneMinute],\n                        },\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 100,\n                            takerAmount: 125,\n                        },\n                    },\n                    // TODO (MKR-671): uncomment once filter is enabled\n                    {\n                        name: 'should not ignore quotes if makers have enough balances',\n                        args: {\n                            quotes: [fullQuoteBadPricing, fullQuoteOkPricing],\n                            quotedMakerBalances: validMakerBalances,\n                        },\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 100,\n                            takerAmount: 120,\n                        },\n                    },\n                    {\n                        name: 'should ignore quotes if makers do not have enough balances',\n                        args: {\n                            quotes: [fullQuoteBadPricing, fullQuoteOkPricing],\n                            quotedMakerBalances: invalidMakerBalances,\n                        },\n                        expectations: {\n                            isNull: false,\n                            makerAmount: 100,\n                            takerAmount: 125,\n                        },\n                    },\n                ];\n\n                tests.forEach(({ name, args, expectations }) => {\n                    it(name, () => {\n                        const bestQuote = getBestQuote(\n                            args?.quotes,\n                            isSelling,\n                            takerToken,\n                            makerToken,\n                            assetFillAmount,\n                            validityWindowMs,\n                            args?.quotedMakerBalances,\n                        );\n\n                        if (bestQuote === null) {\n                            expect(expectations?.isNull).to.equal(true);\n                            return;\n                        }\n\n                        expect(expectations?.isNull).to.equal(false);\n                        expect(bestQuote.order.makerAmount.toNumber()).to.be.eq(expectations?.makerAmount);\n                        expect(bestQuote.order.takerAmount.toNumber()).to.be.eq(expectations?.takerAmount);\n                    });\n                });\n            });\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/quote_server_client_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\n// tslint:disable:no-empty\n// tslint:disable:max-file-line-count\n\nimport { ethSignHashWithKey, OtcOrder } from '@0x/protocol-utils';\nimport { BigNumber, NULL_ADDRESS } from '@0x/utils';\nimport Axios from 'axios';\nimport AxiosMockAdapter from 'axios-mock-adapter';\nimport * as HttpStatus from 'http-status-codes';\n\nimport { Integrator } from '../../src/config';\nimport { SignRequest } from '../../src/quote-server/types';\nimport { Fee, QuoteServerPriceParams } from '../../src/core/types';\nimport { QuoteServerClient } from '../../src/utils/quote_server_client';\nimport { CHAIN_ID, CONTRACT_ADDRESSES } from '../constants';\nimport { MarketOperation } from '@0x/types';\n\nconst makerUri = 'https://some-market-maker.xyz';\nconst integrator: Integrator = {\n    integratorId: 'some-integrator-id',\n    apiKeys: [],\n    allowedChainIds: [],\n    label: 'integrator',\n    plp: false,\n    rfqm: true,\n    rfqt: true,\n};\n\n// Maker\nconst makerAddress = '0xFDbEf5C1Ad7d173D191D565c14E28eBd5b50470e';\nconst makerPrivateKey = '0xf4559ca5152145f5e0b9762f12213c2e74020a4481953fb940413273051a89d3';\n\n// Taker\nconst takerAddress = '0xdA9AC423442169588DE6b4305f4E820D708d0cE5';\nconst takerPrivateKey = '0x653fa328df81be180b58e42737bc4cef037a19a3b9673b15d20ee2eebb2e509d';\n\n// Some tokens and amounts\nconst takerToken = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2';\nconst makerToken = '0x6b175474e89094c44da98b954eedeac495271d0f';\nconst takerAmount = new BigNumber(100);\nconst makerAmount = new BigNumber(100_000);\n\n// An OtcOrder\nconst order = new OtcOrder({\n    maker: makerAddress,\n    taker: takerAddress,\n    makerAmount,\n    takerAmount,\n    makerToken,\n    takerToken,\n    expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n        new BigNumber(2634330177),\n        new BigNumber(1),\n        new BigNumber(1634330177),\n    ),\n});\nconst orderHash = order.getHash();\n\n// Signatures\nconst takerSignature = ethSignHashWithKey(orderHash, takerPrivateKey);\nconst makerSignature = ethSignHashWithKey(orderHash, makerPrivateKey);\n\ndescribe('QuoteServerClient', () => {\n    const axiosInstance = Axios.create();\n    const axiosMock = new AxiosMockAdapter(axiosInstance);\n\n    afterEach(() => {\n        axiosMock.reset();\n    });\n\n    describe('makeQueryParameters', () => {\n        it('should make RFQt request parameters', () => {\n            // Given\n            const marketOperation = MarketOperation.Sell;\n            const input = {\n                txOrigin: takerAddress,\n                takerAddress: NULL_ADDRESS,\n                marketOperation,\n                buyTokenAddress: makerToken,\n                sellTokenAddress: takerToken,\n                comparisonPrice: new BigNumber('42'),\n                assetFillAmount: new BigNumber('100000'),\n            };\n\n            // When\n            const params = QuoteServerClient.makeQueryParameters(input);\n\n            // Then\n            expect(params).toEqual({\n                buyTokenAddress: '0x6b175474e89094c44da98b954eedeac495271d0f',\n                protocolVersion: '4',\n                sellAmountBaseUnits: '100000',\n                sellTokenAddress: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n                takerAddress: '0x0000000000000000000000000000000000000000',\n                txOrigin: '0xdA9AC423442169588DE6b4305f4E820D708d0cE5',\n                comparisonPrice: '42',\n            });\n        });\n\n        it('should make RFQm request parameters', () => {\n            // Given\n            const txOrigin = '0x335e51687677C4f1389f3dEcA259af983529e82D';\n            const feeAmount = '100';\n            const otcOrderFee: Fee = {\n                amount: new BigNumber(feeAmount),\n                token: CONTRACT_ADDRESSES.etherToken,\n                type: 'fixed',\n            };\n            const marketOperation = MarketOperation.Sell;\n\n            // When\n            const params = QuoteServerClient.makeQueryParameters({\n                txOrigin,\n                takerAddress,\n                marketOperation,\n                buyTokenAddress: makerToken,\n                sellTokenAddress: takerToken,\n                assetFillAmount: new BigNumber('100000'),\n                isLastLook: true,\n                fee: otcOrderFee,\n            });\n\n            // Then\n            expect(params).toEqual({\n                buyTokenAddress: '0x6b175474e89094c44da98b954eedeac495271d0f',\n                feeAmount: '100',\n                feeToken: '0x0b1ba0af832d7c05fd64161e0db78e85978e8082',\n                feeType: 'fixed',\n                isLastLook: 'true',\n                protocolVersion: '4',\n                sellAmountBaseUnits: '100000',\n                sellTokenAddress: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n                takerAddress: '0xdA9AC423442169588DE6b4305f4E820D708d0cE5',\n                txOrigin: '0x335e51687677C4f1389f3dEcA259af983529e82D',\n            });\n        });\n\n        it('should make RFQm request parameters with chain id', () => {\n            // Given\n            const txOrigin = '0x335e51687677C4f1389f3dEcA259af983529e82D';\n            const feeAmount = '100';\n            const otcOrderFee: Fee = {\n                amount: new BigNumber(feeAmount),\n                token: CONTRACT_ADDRESSES.etherToken,\n                type: 'fixed',\n            };\n            const marketOperation = MarketOperation.Sell;\n\n            // When\n            const params = QuoteServerClient.makeQueryParameters({\n                chainId: 10,\n                txOrigin,\n                takerAddress,\n                marketOperation,\n                buyTokenAddress: makerToken,\n                sellTokenAddress: takerToken,\n                assetFillAmount: new BigNumber('100000'),\n                isLastLook: true,\n                fee: otcOrderFee,\n            });\n\n            // Then\n            expect(params).toEqual({\n                chainId: '10',\n                buyTokenAddress: '0x6b175474e89094c44da98b954eedeac495271d0f',\n                feeAmount: '100',\n                feeToken: '0x0b1ba0af832d7c05fd64161e0db78e85978e8082',\n                feeType: 'fixed',\n                isLastLook: 'true',\n                protocolVersion: '4',\n                sellAmountBaseUnits: '100000',\n                sellTokenAddress: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n                takerAddress: '0xdA9AC423442169588DE6b4305f4E820D708d0cE5',\n                txOrigin: '0x335e51687677C4f1389f3dEcA259af983529e82D',\n            });\n        });\n    });\n\n    describe('OtcOrder', () => {\n        describe('getPriceV2Async', () => {\n            it('should return a valid indicative quote', async () => {\n                // Given\n                const client = new QuoteServerClient(axiosInstance);\n                const request: QuoteServerPriceParams = {\n                    chainId: CHAIN_ID.toString(),\n                    sellTokenAddress: takerToken,\n                    buyTokenAddress: makerToken,\n                    takerAddress,\n                    sellAmountBaseUnits: takerAmount.toString(),\n                    protocolVersion: '4',\n                    txOrigin: takerAddress,\n                    isLastLook: 'true',\n                    feeAmount: '100',\n                    feeType: 'fixed',\n                    feeToken: CONTRACT_ADDRESSES.etherToken,\n                    nonce: '1634322835',\n                    nonceBucket: '1',\n                };\n\n                const response = {\n                    maker: makerAddress,\n                    makerAmount,\n                    takerAmount,\n                    makerToken,\n                    takerToken,\n                    expiry: new BigNumber(9934322972),\n                };\n\n                axiosMock.onGet(`${makerUri}/rfqm/v2/price`).replyOnce(HttpStatus.OK, response);\n\n                // When\n                const indicativeQuote = await client.getPriceV2Async(\n                    makerUri,\n                    integrator,\n                    request,\n                    (uri) => `${uri}/rfqm/v2/price`,\n                );\n\n                // Then\n                const expectedResponse = {\n                    ...response,\n                    makerUri,\n                };\n                expect(indicativeQuote).toEqual(expectedResponse);\n            });\n\n            it('should return undefined for empty responses (not quoting)', async () => {\n                // Given\n                const client = new QuoteServerClient(axiosInstance);\n                const request: QuoteServerPriceParams = {\n                    chainId: CHAIN_ID.toString(),\n                    sellTokenAddress: takerToken,\n                    buyTokenAddress: makerToken,\n                    takerAddress,\n                    sellAmountBaseUnits: takerAmount.toString(),\n                    protocolVersion: '4',\n                    txOrigin: takerAddress,\n                    isLastLook: 'true',\n                    feeAmount: '100',\n                    feeType: 'fixed',\n                    feeToken: CONTRACT_ADDRESSES.etherToken,\n                    nonce: '1634322835',\n                    nonceBucket: '1',\n                };\n\n                const response = {}; // empty response\n\n                // When\n                axiosMock.onGet(`${makerUri}/rfqm/v2/price`).replyOnce(HttpStatus.OK, response);\n                const result = await client.getPriceV2Async(\n                    makerUri,\n                    integrator,\n                    request,\n                    (uri) => `${uri}/rfqm/v2/price`,\n                );\n\n                // Then\n                expect(result).toBe(undefined);\n            });\n\n            it('should return undefined when returning a 400 from axios', async () => {\n                // Given\n                const client = new QuoteServerClient(axiosInstance);\n                const request: QuoteServerPriceParams = {\n                    chainId: CHAIN_ID.toString(),\n                    sellTokenAddress: takerToken,\n                    buyTokenAddress: makerToken,\n                    takerAddress,\n                    sellAmountBaseUnits: takerAmount.toString(),\n                    protocolVersion: '4',\n                    txOrigin: takerAddress,\n                    isLastLook: 'true',\n                    feeAmount: '100',\n                    feeType: 'fixed',\n                    feeToken: CONTRACT_ADDRESSES.etherToken,\n                    nonce: '1634322835',\n                    nonceBucket: '1',\n                };\n\n                const response = {}; // empty response\n\n                axiosMock.onGet(`${makerUri}/rfqm/v2/price`).replyOnce(HttpStatus.BAD_REQUEST, response);\n\n                // When\n                const result = await client.getPriceV2Async(\n                    makerUri,\n                    integrator,\n                    request,\n                    (uri) => `${uri}/rfqm/v2/price`,\n                );\n\n                // Then\n                expect(result).toBe(undefined);\n            });\n\n            it('should throw an error for a malformed response', async () => {\n                // Given\n                const client = new QuoteServerClient(axiosInstance);\n                const request: QuoteServerPriceParams = {\n                    chainId: CHAIN_ID.toString(),\n                    sellTokenAddress: takerToken,\n                    buyTokenAddress: makerToken,\n                    takerAddress,\n                    sellAmountBaseUnits: takerAmount.toString(),\n                    protocolVersion: '4',\n                    txOrigin: takerAddress,\n                    isLastLook: 'true',\n                    feeAmount: '100',\n                    feeType: 'fixed',\n                    feeToken: CONTRACT_ADDRESSES.etherToken,\n                    nonce: '1634322835',\n                    nonceBucket: '1',\n                };\n\n                const response = {\n                    asdf: 'malformed response',\n                };\n\n                axiosMock.onGet(`${makerUri}/rfqm/v2/price`).replyOnce(HttpStatus.OK, response);\n\n                // When\n                await expect(async () => {\n                    await client.getPriceV2Async(makerUri, integrator, request, (uri) => `${uri}/rfqm/v2/price`);\n                }).rejects.toThrow();\n            });\n        });\n\n        describe('batchGetPriceV2Async', () => {\n            it('should return the valid indicative qutoes and filter out errors', async () => {\n                // Given\n                const makerUri1 = 'https://some-market-maker1.xyz';\n                const makerUri2 = 'https://some-market-maker2.xyz';\n                const makerUri3 = 'https://some-market-maker3.xyz';\n                const client = new QuoteServerClient(axiosInstance);\n                const request: QuoteServerPriceParams = {\n                    chainId: CHAIN_ID.toString(),\n                    sellTokenAddress: takerToken,\n                    buyTokenAddress: makerToken,\n                    takerAddress,\n                    sellAmountBaseUnits: takerAmount.toString(),\n                    protocolVersion: '4',\n                    txOrigin: takerAddress,\n                    isLastLook: 'true',\n                    feeAmount: '100',\n                    feeType: 'fixed',\n                    feeToken: CONTRACT_ADDRESSES.etherToken,\n                    nonce: '1634322835',\n                    nonceBucket: '1',\n                };\n\n                const response = {\n                    maker: makerAddress,\n                    makerAmount,\n                    takerAmount,\n                    makerToken,\n                    takerToken,\n                    expiry: new BigNumber(9934322972),\n                };\n\n                axiosMock.onGet(`${makerUri1}/rfqm/v2/price`).replyOnce(HttpStatus.OK, response);\n                axiosMock.onGet(`${makerUri2}/rfqm/v2/price`).replyOnce(HttpStatus.NO_CONTENT, {});\n                axiosMock.onGet(`${makerUri3}/rfqm/v2/price`).replyOnce(HttpStatus.BAD_GATEWAY, {});\n\n                // When\n                const indicativeQuotes = await client.batchGetPriceV2Async(\n                    [makerUri1, makerUri2, makerUri3],\n                    integrator,\n                    request,\n                );\n\n                // Then\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                expect(indicativeQuotes!.length).toEqual(1);\n                expect(indicativeQuotes[0].makerAmount.toNumber()).toEqual(response.makerAmount.toNumber());\n                expect(indicativeQuotes[0].maker).toEqual(makerAddress);\n            });\n        });\n\n        describe('signV2Async', () => {\n            it('should return a signature for valid response', async () => {\n                // Given\n                const client = new QuoteServerClient(axiosInstance);\n                const request: SignRequest = {\n                    order,\n                    orderHash,\n                    fee: {\n                        amount: new BigNumber('100'),\n                        type: 'fixed',\n                        token: CONTRACT_ADDRESSES.etherToken,\n                    },\n                    expiry: order.expiry,\n                    takerSignature,\n                    trader: takerAddress,\n                    workflow: 'rfqm',\n                };\n\n                const actualRequest = {\n                    order,\n                    orderHash,\n                    feeAmount: '100',\n                    feeToken: CONTRACT_ADDRESSES.etherToken,\n                    expiry: order.expiry,\n                    takerSignature,\n                    // trader: takerAddress,\n                    // workflow: 'rfqm',\n                };\n\n                const response = {\n                    feeAmount: '100',\n                    proceedWithFill: true,\n                    makerSignature,\n                };\n\n                axiosMock\n                    .onPost(`${makerUri}/rfqm/v2/sign`, JSON.parse(JSON.stringify(actualRequest)))\n                    .replyOnce(HttpStatus.OK, response);\n\n                // When\n                const signature = await client.signV2Async(makerUri, 'dummy-integrator-id', request);\n\n                // Then\n                expect(signature).toEqual(makerSignature);\n            });\n\n            it('should send takerSpecifiedSide when enabled and present in request', async () => {\n                // Given\n                const client = new QuoteServerClient(axiosInstance);\n                const request: SignRequest = {\n                    order,\n                    orderHash,\n                    fee: {\n                        amount: new BigNumber('100'),\n                        type: 'fixed',\n                        token: CONTRACT_ADDRESSES.etherToken,\n                    },\n                    expiry: order.expiry,\n                    takerSpecifiedSide: 'makerToken',\n                    takerSignature,\n                    trader: takerAddress,\n                    workflow: 'rfqm',\n                };\n\n                const actualRequest = {\n                    order,\n                    orderHash,\n                    feeAmount: '100',\n                    feeToken: CONTRACT_ADDRESSES.etherToken,\n                    expiry: order.expiry,\n                    takerSpecifiedSide: 'makerToken',\n                    takerSignature,\n                    // trader: takerAddress,\n                    // workflow: 'rfqm',\n                };\n\n                const response = {\n                    feeAmount: '100',\n                    proceedWithFill: true,\n                    makerSignature,\n                };\n\n                axiosMock\n                    .onPost(`${makerUri}/rfqm/v2/sign`, JSON.parse(JSON.stringify(actualRequest)))\n                    .replyOnce(HttpStatus.OK, response);\n\n                // When\n                const signature = await client.signV2Async(makerUri, 'dummy-integrator-id', request);\n\n                // Then\n                expect(signature).toEqual(makerSignature);\n            });\n\n            it('should return a signature for valid response even if the fee is higher than requested', async () => {\n                // Given\n                const client = new QuoteServerClient(axiosInstance);\n                const request: SignRequest = {\n                    order,\n                    orderHash,\n                    fee: {\n                        amount: new BigNumber('100'),\n                        type: 'fixed',\n                        token: CONTRACT_ADDRESSES.etherToken,\n                    },\n                    expiry: order.expiry,\n                    takerSignature,\n                    trader: takerAddress,\n                    workflow: 'rfqm',\n                };\n\n                const actualRequest = {\n                    order,\n                    orderHash,\n                    feeAmount: '100',\n                    feeToken: CONTRACT_ADDRESSES.etherToken,\n                    expiry: order.expiry,\n                    takerSignature,\n                    // trader: takerAddress,\n                    // workflow: 'rfqm',\n                };\n\n                const response = {\n                    feeAmount: '101', // higher than requested\n                    proceedWithFill: true,\n                    makerSignature,\n                };\n\n                axiosMock\n                    .onPost(`${makerUri}/rfqm/v2/sign`, JSON.parse(JSON.stringify(actualRequest)))\n                    .replyOnce(HttpStatus.OK, response);\n\n                // When\n                const signature = await client.signV2Async(makerUri, 'dummy-integrator-id', request);\n\n                // Then\n                expect(signature).toEqual(makerSignature);\n            });\n\n            it('should return a signature for valid response if the fee is 0 but no acknowledgement is returned', async () => {\n                // Given\n                const client = new QuoteServerClient(axiosInstance);\n                const request: SignRequest = {\n                    order,\n                    orderHash,\n                    fee: {\n                        amount: new BigNumber('0'),\n                        type: 'fixed',\n                        token: CONTRACT_ADDRESSES.etherToken,\n                    },\n                    expiry: order.expiry,\n                    takerSignature,\n                    trader: takerAddress,\n                    workflow: 'rfqm',\n                };\n\n                const actualRequest = {\n                    order,\n                    orderHash,\n                    feeAmount: '0',\n                    feeToken: CONTRACT_ADDRESSES.etherToken,\n                    expiry: order.expiry,\n                    takerSignature,\n                    // trader: takerAddress,\n                    // workflow: 'rfqm',\n                };\n\n                const response = {\n                    feeAmount: undefined, // no fee amount acknowledged\n                    proceedWithFill: true,\n                    makerSignature,\n                };\n\n                axiosMock\n                    .onPost(`${makerUri}/rfqm/v2/sign`, JSON.parse(JSON.stringify(actualRequest)))\n                    .replyOnce(HttpStatus.OK, response);\n\n                // When\n                const signature = await client.signV2Async(makerUri, 'dummy-integrator-id', request);\n\n                // Then\n                expect(signature).toEqual(makerSignature);\n            });\n\n            it('should throw an error for a malformed response', async () => {\n                // Given\n                const client = new QuoteServerClient(axiosInstance);\n                const request: SignRequest = {\n                    order,\n                    orderHash,\n                    fee: {\n                        amount: new BigNumber('100'),\n                        type: 'fixed',\n                        token: CONTRACT_ADDRESSES.etherToken,\n                    },\n                    expiry: order.expiry,\n                    takerSignature,\n                    trader: takerAddress,\n                    workflow: 'rfqm',\n                };\n\n                const response = {\n                    asdf: 'I am broken',\n                };\n\n                axiosMock\n                    .onPost(`${makerUri}/rfqm/v2/sign`, JSON.parse(JSON.stringify(request)))\n                    .replyOnce(HttpStatus.OK, response);\n\n                await expect(async () => {\n                    await client.signV2Async(makerUri, 'dummy-integrator-id', request);\n                }).rejects.toThrow();\n            });\n\n            it('should return undefined for an incorrect fee acknowledgement', async () => {\n                // Given\n                const client = new QuoteServerClient(axiosInstance);\n                const request: SignRequest = {\n                    order,\n                    orderHash,\n                    fee: {\n                        amount: new BigNumber('100'),\n                        type: 'fixed',\n                        token: CONTRACT_ADDRESSES.etherToken,\n                    },\n                    expiry: order.expiry,\n                    takerSignature,\n                    trader: takerAddress,\n                    workflow: 'rfqm',\n                };\n\n                const actualRequest = {\n                    order,\n                    orderHash,\n                    feeAmount: '100',\n                    feeToken: CONTRACT_ADDRESSES.etherToken,\n                    expiry: order.expiry,\n                    takerSignature,\n                    // trader: takerAddress,\n                    // workflow: 'rfqm',\n                };\n\n                const response = {\n                    feeAmount: '10', // Not the right fee\n                    proceedWithFill: true,\n                    makerSignature,\n                };\n\n                axiosMock\n                    .onPost(`${makerUri}/rfqm/v2/sign`, JSON.parse(JSON.stringify(actualRequest)))\n                    .replyOnce(HttpStatus.OK, response);\n\n                // When\n                const signature = await client.signV2Async(makerUri, 'dummy-integrator-id', request);\n\n                // Then\n                expect(signature).toBe(undefined);\n            });\n\n            it('should return undefined for explicitly rejected responses', async () => {\n                // Given\n                const client = new QuoteServerClient(axiosInstance);\n                const request: SignRequest = {\n                    order,\n                    orderHash,\n                    fee: {\n                        amount: new BigNumber('100'),\n                        type: 'fixed',\n                        token: CONTRACT_ADDRESSES.etherToken,\n                    },\n                    expiry: order.expiry,\n                    takerSignature,\n                    trader: takerAddress,\n                    workflow: 'rfqm',\n                };\n\n                const actualRequest = {\n                    order,\n                    orderHash,\n                    feeAmount: '100',\n                    feeToken: CONTRACT_ADDRESSES.etherToken,\n                    expiry: order.expiry,\n                    takerSignature,\n                    // trader: takerAddress,\n                    // workflow: 'rfqm',\n                };\n\n                const response = {\n                    proceedWithFill: false,\n                };\n\n                axiosMock\n                    .onPost(`${makerUri}/rfqm/v2/sign`, JSON.parse(JSON.stringify(actualRequest)))\n                    .replyOnce(HttpStatus.OK, response);\n\n                // When\n                const signature = await client.signV2Async(makerUri, 'dummy-integrator-id', request);\n\n                // Then\n                expect(signature).toBe(undefined);\n            });\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/schemas.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/rfq_blockchain_utils_test.ts",{"fileContent":"// tslint:disable custom-no-magic-numbers\n// tslint:disable await-promise\n// tslint:disable max-file-line-count\nimport { artifacts as assetSwapperArtifacts, BalanceCheckerContract } from '@0x/asset-swapper';\nimport { ChainId } from '@0x/contract-addresses';\nimport { artifacts as erc20Artifacts, DummyERC20TokenContract } from '@0x/contracts-erc20';\nimport { artifacts as zeroExArtifacts, fullMigrateAsync, IZeroExContract } from '@0x/contracts-zero-ex';\nimport { Web3ProviderEngine } from '@0x/dev-utils';\nimport { ethSignHashWithProviderAsync, OtcOrder, RfqOrder, Signature } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { TxData, Web3Wrapper } from '@0x/web3-wrapper';\nimport { expect } from 'chai';\nimport { Contract, providers, Wallet } from 'ethers';\n\nimport { ONE_MINUTE_MS, ZERO } from '../src/core/constants';\nimport { BalanceChecker } from '../src/utils/balance_checker';\nimport { RfqBlockchainUtils } from '../src/utils/rfq_blockchain_utils';\n\nimport {\n    getProvider,\n    MATCHA_AFFILIATE_ADDRESS,\n    MOCK_EXECUTE_META_TRANSACTION_APPROVAL,\n    MOCK_EXECUTE_META_TRANSACTION_CALLDATA,\n    MOCK_PERMIT_APPROVAL,\n    MOCK_PERMIT_CALLDATA,\n    TEST_RFQ_ORDER_FILLED_EVENT_LOG,\n    TEST_RFQ_ORDER_FILLED_EVENT_TAKER_AMOUNT,\n    WORKER_TEST_PRIVATE_KEY,\n} from './constants';\nimport { setupDependenciesAsync, TeardownDependenciesFunctionHandle } from './test_utils/deployment';\n\nconst GAS_PRICE = 1e9;\nconst VALID_EXPIRY = new BigNumber(9000000000);\nconst CHAIN_ID = ChainId.Ganache;\n\njest.setTimeout(ONE_MINUTE_MS * 2);\nlet teardownDependencies: TeardownDependenciesFunctionHandle;\n\ndescribe('RFQ Blockchain Utils', () => {\n    let provider: Web3ProviderEngine;\n    let makerToken: DummyERC20TokenContract;\n    let takerToken: DummyERC20TokenContract;\n    let makerAmount: BigNumber;\n    let takerAmount: BigNumber;\n    let invalidTakerAmount: BigNumber;\n    let makerBalance: BigNumber;\n    let takerBalance: BigNumber;\n    let web3Wrapper: Web3Wrapper;\n    let owner: string;\n    let maker: string;\n    let taker: string;\n    let signer: string;\n    let txOrigin: string;\n    let zeroEx: IZeroExContract;\n    let rfqOrder: RfqOrder;\n    let otcOrder: OtcOrder;\n    let unfillableRfqOrder: RfqOrder;\n    let rfqBlockchainUtils: RfqBlockchainUtils;\n    let orderSig: Signature;\n    let sigForUnfillableOrder: Signature;\n    let makerOtcOrderSig: Signature;\n    let takerOtcOrderSig: Signature;\n\n    beforeAll(async () => {\n        teardownDependencies = await setupDependenciesAsync(['ganache']);\n        provider = getProvider();\n        web3Wrapper = new Web3Wrapper(provider);\n\n        [owner, maker, taker, txOrigin, signer] = await web3Wrapper.getAvailableAddressesAsync();\n\n        // Deploy dummy tokens\n        makerToken = await DummyERC20TokenContract.deployFrom0xArtifactAsync(\n            erc20Artifacts.DummyERC20Token,\n            provider,\n            { from: maker, gas: 10000000 },\n            {},\n            'The token that originally belongs to the maker',\n            'makerToken',\n            new BigNumber(18),\n            new BigNumber(0),\n        );\n\n        takerToken = await DummyERC20TokenContract.deployFrom0xArtifactAsync(\n            erc20Artifacts.DummyERC20Token,\n            provider,\n            { from: taker, gas: 10000000 },\n            {},\n            'The token that originally belongs to the maker',\n            'takerToken',\n            new BigNumber(18),\n            new BigNumber(0),\n        );\n\n        // Deploy Balance Checker (only necessary for Ganache because ganache doesn't have overrides)\n        const balanceCheckerContract = await BalanceCheckerContract.deployFrom0xArtifactAsync(\n            assetSwapperArtifacts.BalanceChecker,\n            provider,\n            { from: owner, gas: 10000000 },\n            {},\n        );\n        const balanceChecker = new BalanceChecker(provider, balanceCheckerContract);\n\n        makerAmount = new BigNumber(100);\n        takerAmount = new BigNumber(50);\n        invalidTakerAmount = new BigNumber(10000000);\n\n        // Deploy ZeroEx to Ganache\n        zeroEx = await fullMigrateAsync(\n            owner,\n            provider,\n            { from: owner, gasPrice: GAS_PRICE },\n            {},\n            { protocolFeeMultiplier: Number(0) },\n            {\n                nativeOrders: zeroExArtifacts.NativeOrdersFeature,\n                metaTransactions: zeroExArtifacts.MetaTransactionsFeature,\n            },\n        );\n\n        // Prepare an RfqOrder\n        rfqOrder = new RfqOrder({\n            makerToken: makerToken.address,\n            takerToken: takerToken.address,\n            makerAmount,\n            takerAmount,\n            maker,\n            taker,\n            txOrigin,\n            expiry: VALID_EXPIRY,\n            salt: new BigNumber(1),\n            verifyingContract: zeroEx.address,\n            chainId: CHAIN_ID,\n        });\n        orderSig = await rfqOrder.getSignatureWithProviderAsync(provider);\n\n        // Prepare an Unfillable RfqOrder\n        unfillableRfqOrder = new RfqOrder({\n            makerToken: makerToken.address,\n            takerToken: takerToken.address,\n            makerAmount,\n            takerAmount: invalidTakerAmount,\n            maker,\n            taker,\n            txOrigin,\n            expiry: VALID_EXPIRY,\n            salt: new BigNumber(1),\n            verifyingContract: zeroEx.address,\n            chainId: CHAIN_ID,\n        });\n        sigForUnfillableOrder = await unfillableRfqOrder.getSignatureWithProviderAsync(provider);\n\n        // Prepare an OtcOrder and valid signatures\n        otcOrder = new OtcOrder({\n            maker,\n            taker,\n            makerAmount,\n            takerAmount,\n            makerToken: makerToken.address,\n            takerToken: takerToken.address,\n            txOrigin,\n            expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                new BigNumber(VALID_EXPIRY),\n                ZERO,\n                new BigNumber(VALID_EXPIRY),\n            ),\n            chainId: CHAIN_ID,\n            verifyingContract: zeroEx.address,\n        });\n        const orderHash = otcOrder.getHash();\n        makerOtcOrderSig = await ethSignHashWithProviderAsync(orderHash, maker, provider);\n        takerOtcOrderSig = await ethSignHashWithProviderAsync(orderHash, taker, provider);\n\n        // Mint enough tokens for a few trades\n        const numTrades = 2;\n        makerBalance = makerAmount.times(numTrades);\n        takerBalance = takerAmount.times(numTrades);\n\n        await makerToken.mint(makerBalance).awaitTransactionSuccessAsync({ from: maker });\n        await makerToken.approve(zeroEx.address, makerBalance.times(2)).awaitTransactionSuccessAsync({ from: maker });\n        await takerToken.mint(takerBalance).awaitTransactionSuccessAsync({ from: taker });\n        await takerToken.approve(zeroEx.address, takerBalance.times(2)).awaitTransactionSuccessAsync({ from: taker });\n\n        const ethersProvider = new providers.JsonRpcProvider();\n        const ethersWallet = new Wallet(WORKER_TEST_PRIVATE_KEY, ethersProvider);\n\n        rfqBlockchainUtils = new RfqBlockchainUtils(\n            provider,\n            zeroEx.address,\n            balanceChecker,\n            ethersProvider,\n            ethersWallet,\n        );\n    });\n\n    afterAll(async () => {\n        if (!teardownDependencies()) {\n            throw new Error('Failed to tear down dependencies');\n        }\n    });\n\n    describe('getMinOfBalancesAndAllowancesAsync', () => {\n        it('should fetch min of token balances and allowances', async () => {\n            const addresses = [\n                { owner: maker, token: makerToken.address },\n                { owner: maker, token: takerToken.address },\n                { owner: taker, token: makerToken.address },\n                { owner: taker, token: takerToken.address },\n            ];\n            const res = await rfqBlockchainUtils.getMinOfBalancesAndAllowancesAsync(addresses);\n            expect(res).to.deep.eq([makerBalance, ZERO, ZERO, takerBalance]);\n        });\n    });\n\n    describe('getTokenBalancesAsync', () => {\n        it('should fetch token balances', async () => {\n            const addresses = [\n                { owner: maker, token: makerToken.address },\n                { owner: maker, token: takerToken.address },\n                { owner: taker, token: makerToken.address },\n                { owner: taker, token: takerToken.address },\n            ];\n            const res = await rfqBlockchainUtils.getTokenBalancesAsync(addresses);\n            expect(res).to.deep.eq([makerBalance, ZERO, ZERO, takerBalance]);\n        });\n    });\n\n    describe('OtcOrder', () => {\n        describe('estimateGasForFillTakerSignedOtcOrderAsync', () => {\n            it('does not throw an error on valid order', async () => {\n                try {\n                    const gasEstimate = await rfqBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(\n                        otcOrder,\n                        makerOtcOrderSig,\n                        takerOtcOrderSig,\n                        txOrigin,\n                        false,\n                    );\n                    expect(gasEstimate).to.be.greaterThan(0);\n                } catch (err) {\n                    expect.fail('should not throw');\n                }\n            });\n\n            it('throws an error if order is invalid', async () => {\n                const invalidOtcOrder = new OtcOrder({\n                    maker,\n                    taker,\n                    makerAmount,\n                    takerAmount,\n                    makerToken: makerToken.address,\n                    takerToken: takerToken.address,\n                    txOrigin,\n                    expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                        ZERO, // expired\n                        ZERO,\n                        VALID_EXPIRY,\n                    ),\n                    chainId: CHAIN_ID,\n                    verifyingContract: zeroEx.address,\n                });\n                const orderHash = invalidOtcOrder.getHash();\n\n                const makerSig = await ethSignHashWithProviderAsync(orderHash, maker, provider);\n                const takerSig = await ethSignHashWithProviderAsync(orderHash, taker, provider);\n\n                expect(\n                    rfqBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(\n                        invalidOtcOrder, // invalid order, should be expired\n                        makerSig,\n                        takerSig,\n                        txOrigin,\n                        false,\n                    ),\n                ).to.eventually.be.rejectedWith(/revert/);\n            });\n\n            it('throws an error if signatures invalid', async () => {\n                expect(\n                    rfqBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(\n                        otcOrder,\n                        makerOtcOrderSig,\n                        makerOtcOrderSig, // wrong signature\n                        txOrigin,\n                        false,\n                    ),\n                ).to.eventually.be.rejectedWith('revert');\n            });\n        });\n    });\n\n    describe('validateMetaTransaction', () => {\n        it('returns successful filled amounts for a valid metatransaction', async () => {\n            const metaTx = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount, CHAIN_ID);\n            const metaTxSig = await metaTx.getSignatureWithProviderAsync(provider);\n            const res = await rfqBlockchainUtils.validateMetaTransactionOrThrowAsync(metaTx, metaTxSig, txOrigin);\n\n            expect(res[0]).to.deep.equal(takerAmount);\n            expect(res[1]).to.deep.equal(makerAmount);\n        });\n\n        it('throws for a metatransaction with an invalid signature', async () => {\n            const metaTx = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount, CHAIN_ID);\n            const invalidMetaTxSig = orderSig;\n\n            expect(\n                rfqBlockchainUtils.validateMetaTransactionOrThrowAsync(metaTx, invalidMetaTxSig, txOrigin),\n            ).to.eventually.be.rejectedWith('SignatureValidationError');\n        });\n\n        it('throws for a metatransaction with an unfillable order', async () => {\n            const metaTx = rfqBlockchainUtils.generateMetaTransaction(\n                unfillableRfqOrder,\n                sigForUnfillableOrder,\n                taker,\n                invalidTakerAmount,\n                CHAIN_ID,\n            );\n            const metaTxSig = await metaTx.getSignatureWithProviderAsync(provider);\n\n            expect(\n                rfqBlockchainUtils.validateMetaTransactionOrThrowAsync(metaTx, metaTxSig, txOrigin),\n            ).to.eventually.be.rejectedWith('MetaTransactionCallFailedError');\n        });\n\n        it('returns successful filled amounts for a valid metatransaction when validating calldata', async () => {\n            const metaTx = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount, CHAIN_ID);\n            const metaTxSig = await metaTx.getSignatureWithProviderAsync(provider);\n\n            const callData = rfqBlockchainUtils.generateMetaTransactionCallData(\n                metaTx,\n                metaTxSig,\n                MATCHA_AFFILIATE_ADDRESS,\n            );\n            const res = await rfqBlockchainUtils.decodeMetaTransactionCallDataAndValidateAsync(callData, txOrigin);\n\n            expect(res[0]).to.deep.equal(takerAmount);\n            expect(res[1]).to.deep.equal(makerAmount);\n        });\n        it('throws for a metatransaction with an invalid signature when validating calldata', async () => {\n            const metaTx = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount, CHAIN_ID);\n            const invalidMetaTxSig = orderSig;\n\n            const callData = rfqBlockchainUtils.generateMetaTransactionCallData(\n                metaTx,\n                invalidMetaTxSig,\n                MATCHA_AFFILIATE_ADDRESS,\n            );\n\n            expect(\n                rfqBlockchainUtils.decodeMetaTransactionCallDataAndValidateAsync(callData, txOrigin),\n            ).to.eventually.be.rejectedWith('SignatureValidationError');\n        });\n\n        it('throws for a metatransaction with an unfillable order when validating calldata', async () => {\n            const metaTx = rfqBlockchainUtils.generateMetaTransaction(\n                unfillableRfqOrder,\n                sigForUnfillableOrder,\n                taker,\n                invalidTakerAmount,\n                CHAIN_ID,\n            );\n            const metaTxSig = await metaTx.getSignatureWithProviderAsync(provider);\n\n            const callData = rfqBlockchainUtils.generateMetaTransactionCallData(\n                metaTx,\n                metaTxSig,\n                MATCHA_AFFILIATE_ADDRESS,\n            );\n\n            expect(\n                rfqBlockchainUtils.decodeMetaTransactionCallDataAndValidateAsync(callData, txOrigin),\n            ).to.eventually.be.rejectedWith('MetaTransactionCallFailedError');\n        });\n\n        it('should throw for a partially filled order', async () => {\n            const metaTx1 = rfqBlockchainUtils.generateMetaTransaction(\n                rfqOrder,\n                orderSig,\n                taker,\n                takerAmount.div(2),\n                CHAIN_ID,\n            );\n            const metaTxSig1 = await metaTx1.getSignatureWithProviderAsync(provider);\n\n            await zeroEx.executeMetaTransaction(metaTx1, metaTxSig1).awaitTransactionSuccessAsync({ from: txOrigin });\n\n            const metaTx2 = rfqBlockchainUtils.generateMetaTransaction(\n                rfqOrder,\n                orderSig,\n                taker,\n                takerAmount,\n                CHAIN_ID,\n            );\n            const metaTxSig2 = await metaTx2.getSignatureWithProviderAsync(provider);\n\n            expect(\n                rfqBlockchainUtils.validateMetaTransactionOrThrowAsync(metaTx2, metaTxSig2, txOrigin),\n            ).to.eventually.be.rejectedWith('filled amount is less than requested fill amount');\n        });\n    });\n\n    describe('transformTxDataToTransactionRequest', () => {\n        it('creates a TransactionRequest', () => {\n            const txOptions: TxData = {\n                from: '0xfromaddress',\n                gas: new BigNumber(210000000),\n                maxFeePerGas: new BigNumber(200000),\n                maxPriorityFeePerGas: new BigNumber(100000),\n                nonce: 21,\n                to: '0xtoaddress',\n                value: 0,\n            };\n\n            const result = rfqBlockchainUtils.transformTxDataToTransactionRequest(\n                txOptions,\n                /* chainId = */ 1337,\n                /* callData */ '0x01234',\n            );\n\n            expect(result.from).to.equal('0xfromaddress');\n            expect(result.gasLimit).to.equal(BigInt(210000000));\n            expect(result.maxFeePerGas).to.equal(BigInt(200000));\n            expect(result.maxPriorityFeePerGas).to.equal(BigInt(100000));\n            expect(result.nonce).to.equal(21);\n            expect(result.to).to.equal('0xtoaddress');\n            expect(result.value).to.equal(0);\n        });\n\n        it(\"uses the proxy address if no 'to' address is provided\", () => {\n            const txOptions: TxData = { from: '0xfromaddress' };\n\n            const result = rfqBlockchainUtils.transformTxDataToTransactionRequest(txOptions);\n\n            expect(result.to).to.equal(zeroEx.address);\n        });\n    });\n\n    describe('getDecodedRfqOrderFillEventLogFromLogs', () => {\n        it('correctly parses an RfqOrderFillEvent from logs', async () => {\n            const rfqOrderFilledEvent = rfqBlockchainUtils.getDecodedRfqOrderFillEventLogFromLogs([\n                TEST_RFQ_ORDER_FILLED_EVENT_LOG,\n            ]);\n\n            expect(rfqOrderFilledEvent.args.takerTokenFilledAmount).to.deep.eq(\n                TEST_RFQ_ORDER_FILLED_EVENT_TAKER_AMOUNT,\n            );\n            expect(rfqOrderFilledEvent.blockNumber).to.deep.eq(TEST_RFQ_ORDER_FILLED_EVENT_LOG.blockNumber);\n        });\n    });\n\n    describe('getTokenDecimalsAsync', () => {\n        it('gets the token decimals', async () => {\n            const decimals = await rfqBlockchainUtils.getTokenDecimalsAsync(makerToken.address);\n\n            expect(decimals).to.equal(18);\n        });\n\n        it('throws if the contract does not exist', () => {\n            // tslint:disable-next-line: no-unused-expression no-unbound-method\n            expect(rfqBlockchainUtils.getTokenDecimalsAsync('0x29D7d1dd5B6f9C864d9db560D72a247c178aE86B')).to.be\n                .rejected;\n        });\n    });\n\n    describe('isValidOrderSigner', () => {\n        it('returns false if signer is not valid', async () => {\n            const isValidOrderSigner = await rfqBlockchainUtils.isValidOrderSignerAsync(maker, signer);\n            expect(isValidOrderSigner).to.equal(false);\n        });\n\n        it('returns true when valid signer address is passed', async () => {\n            await rfqBlockchainUtils.registerAllowedOrderSignerAsync(maker, signer, true);\n\n            const isValidOrderSigner = await rfqBlockchainUtils.isValidOrderSignerAsync(maker, signer);\n            expect(isValidOrderSigner).to.equal(true);\n        });\n    });\n\n    describe('generateApprovalCalldataAsync', () => {\n        it('generates executeMetaTransaction calldata', async () => {\n            const token = makerToken.address;\n            const approval = MOCK_EXECUTE_META_TRANSACTION_APPROVAL;\n            const signature: Signature = {\n                r: '0x0000000000000000000000000000000000000000000000000000000000000000',\n                s: '0x0000000000000000000000000000000000000000000000000000000000000000',\n                v: 28,\n                signatureType: 2,\n            };\n            const calldata = await rfqBlockchainUtils.generateApprovalCalldataAsync(token, approval, signature);\n            expect(calldata).to.eq(MOCK_EXECUTE_META_TRANSACTION_CALLDATA);\n        });\n\n        it('generates permit calldata', async () => {\n            const token = makerToken.address;\n            const approval = MOCK_PERMIT_APPROVAL;\n            const signature: Signature = {\n                r: '0x0000000000000000000000000000000000000000000000000000000000000000',\n                s: '0x0000000000000000000000000000000000000000000000000000000000000000',\n                v: 28,\n                signatureType: 2,\n            };\n            const calldata = await rfqBlockchainUtils.generateApprovalCalldataAsync(token, approval, signature);\n            expect(calldata).to.eq(MOCK_PERMIT_CALLDATA);\n        });\n    });\n\n    describe('estimateGasForAsync', () => {\n        it('throws exception on invalid calldata', async () => {\n            const erc20AbiDecimals = `[{\n                \"constant\": true,\n                \"inputs\": [],\n                \"name\": \"decimals\",\n                \"outputs\": [\n                    {\n                        \"name\": \"\",\n                        \"type\": \"uint8\"\n                    }\n                ],\n                \"payable\": false,\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n            }]`;\n            const erc20 = new Contract(takerToken.address, erc20AbiDecimals);\n            const { data: calldata } = await erc20.populateTransaction.decimals();\n            if (!calldata) {\n                throw new Error('calldata for decimals should not be undefined or empty');\n            }\n            const invalidCalldata = `${calldata.substring(0, calldata.length - 1)}0`;\n\n            try {\n                await rfqBlockchainUtils.estimateGasForAsync({ to: takerToken.address, data: invalidCalldata });\n                expect.fail();\n            } catch (e) {\n                expect(e.message).to.contain('estimateGasForAsync');\n            }\n        });\n\n        it('successfully estimates gas', async () => {\n            const erc20AbiDecimals = `[{\n                \"constant\": true,\n                \"inputs\": [],\n                \"name\": \"decimals\",\n                \"outputs\": [\n                    {\n                        \"name\": \"\",\n                        \"type\": \"uint8\"\n                    }\n                ],\n                \"payable\": false,\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n            }]`;\n            const erc20 = new Contract(takerToken.address, erc20AbiDecimals);\n            const { data: calldata } = await erc20.populateTransaction.decimals();\n            if (!calldata) {\n                throw new Error('calldata for decimals should not be undefined or empty');\n            }\n\n            await rfqBlockchainUtils.estimateGasForAsync({ to: takerToken.address, data: calldata });\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/deployment.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/initDbDataSourceAsync.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/SubmissionContextTest.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { expect } from 'chai';\nimport { BigNumber as EthersBigNumber, providers } from 'ethers';\nimport { deepEqual, instance, mock, when } from 'ts-mockito';\n\nimport { ONE_SECOND_MS } from '../../src/core/constants';\nimport { RfqmV2TransactionSubmissionEntity } from '../../src/entities';\nimport {\n    RfqmTransactionSubmissionStatus,\n    RfqmTransactionSubmissionType,\n    SubmissionContextStatus,\n} from '../../src/entities/types';\nimport { RfqBlockchainUtils } from '../../src/utils/rfq_blockchain_utils';\nimport { SubmissionContext } from '../../src/utils/SubmissionContext';\n\ntype TransactionReceipt = providers.TransactionReceipt;\n\nlet mockBlockchainUtils: RfqBlockchainUtils;\n\ndescribe('SubmissionContext', () => {\n    beforeEach(() => {\n        mockBlockchainUtils = mock<RfqBlockchainUtils>();\n    });\n    describe('constructor', () => {\n        it('requires a transaction', () => {\n            expect(() => new SubmissionContext(instance(mockBlockchainUtils), [])).to.throw('nonzero');\n        });\n\n        it('requires all transactions to have unique hashes', () => {\n            const transaction1 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                gasPrice: new BigNumber(1),\n            });\n            const transaction2 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                gasPrice: new BigNumber(1),\n            });\n\n            expect(() => new SubmissionContext(instance(mockBlockchainUtils), [transaction1, transaction2])).to.throw(\n                'unique',\n            );\n        });\n\n        it('requires all transactions to have the same nonce', () => {\n            const transaction1 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                gasPrice: new BigNumber(1),\n            });\n            const transaction2 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x2',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 1,\n                gasPrice: new BigNumber(1),\n            });\n\n            expect(() => new SubmissionContext(instance(mockBlockchainUtils), [transaction1, transaction2])).to.throw(\n                'nonce',\n            );\n        });\n\n        it('requires all transactions to have the same gas format', () => {\n            const transaction1 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                gasPrice: new BigNumber(1),\n            });\n            const transaction2 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x2',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                maxFeePerGas: new BigNumber(1),\n                maxPriorityFeePerGas: new BigNumber(1),\n            });\n\n            expect(() => new SubmissionContext(instance(mockBlockchainUtils), [transaction1, transaction2])).to.throw(\n                'type',\n            );\n        });\n\n        it('fails for invalid EIP-1559 transactions', () => {\n            const transaction = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                maxPriorityFeePerGas: new BigNumber(1),\n            });\n\n            expect(() => new SubmissionContext(instance(mockBlockchainUtils), [transaction])).to.throw();\n        });\n    });\n    describe('get transactionType', () => {\n        it('handles type-0 transactions', () => {\n            const transaction = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                gasPrice: new BigNumber(1),\n            });\n\n            const submissionContext = new SubmissionContext(instance(mockBlockchainUtils), [transaction]);\n\n            expect(submissionContext.transactionType).to.equal(0);\n        });\n\n        it('handles type-2 transactions', () => {\n            const transaction = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                maxFeePerGas: new BigNumber(1),\n                maxPriorityFeePerGas: new BigNumber(1),\n            });\n\n            const submissionContext = new SubmissionContext(instance(mockBlockchainUtils), [transaction]);\n\n            expect(submissionContext.transactionType).to.equal(2);\n        });\n    });\n\n    describe('maxGasPrice', () => {\n        it('throws for EIP-1559 transactions', () => {\n            const transaction = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                maxFeePerGas: new BigNumber(1),\n                maxPriorityFeePerGas: new BigNumber(1),\n            });\n\n            const submissionContext = new SubmissionContext(instance(mockBlockchainUtils), [transaction]);\n\n            expect(() => submissionContext.maxGasPrice).to.throw('EIP-1559');\n        });\n\n        it('gets the max gas price', () => {\n            const transaction1 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                gasPrice: new BigNumber(1),\n            });\n            const transaction2 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x2',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                gasPrice: new BigNumber(2),\n            });\n\n            const submissionContext = new SubmissionContext(instance(mockBlockchainUtils), [\n                transaction1,\n                transaction2,\n            ]);\n\n            expect(submissionContext.maxGasPrice.toNumber()).to.equal(new BigNumber(2).toNumber());\n        });\n    });\n\n    describe('maxGasFees', () => {\n        it('throws for non-EIP-1559 transactions', () => {\n            const transaction = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                gasPrice: new BigNumber(1),\n            });\n\n            const submissionContext = new SubmissionContext(instance(mockBlockchainUtils), [transaction]);\n\n            expect(() => submissionContext.maxGasFees).to.throw('non-EIP-1559');\n        });\n\n        it('gets the max gas fees', () => {\n            const transaction1 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                maxFeePerGas: new BigNumber(0),\n                maxPriorityFeePerGas: new BigNumber(1),\n            });\n            const transaction2 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x2',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                maxFeePerGas: new BigNumber(1),\n                maxPriorityFeePerGas: new BigNumber(0),\n            });\n\n            const submissionContext = new SubmissionContext(instance(mockBlockchainUtils), [\n                transaction1,\n                transaction2,\n            ]);\n\n            expect(submissionContext.maxGasFees.maxFeePerGas.toNumber()).to.equal(new BigNumber(1).toNumber());\n            expect(submissionContext.maxGasFees.maxPriorityFeePerGas.toNumber()).to.equal(new BigNumber(1).toNumber());\n        });\n    });\n\n    describe('get firstSubmissionTimestampS', () => {\n        it('gets the earliest time a transaction in the context was submitted', () => {\n            const fakeEarlierMs = 1640307189361;\n            const fakeLaterMs = 1650307189361;\n            const transaction1 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                createdAt: new Date(fakeLaterMs),\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                maxFeePerGas: new BigNumber(0),\n                maxPriorityFeePerGas: new BigNumber(1),\n            });\n            const transaction2 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                createdAt: new Date(fakeEarlierMs), // Transaction 2 is older\n                transactionHash: '0x2',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                maxFeePerGas: new BigNumber(1),\n                maxPriorityFeePerGas: new BigNumber(0),\n            });\n\n            const submissionContext = new SubmissionContext(instance(mockBlockchainUtils), [\n                transaction1,\n                transaction2,\n            ]);\n\n            expect(submissionContext.firstSubmissionTimestampS).to.equal(Math.round(fakeEarlierMs / ONE_SECOND_MS));\n        });\n    });\n\n    describe('getReceiptsAsync', () => {\n        it('returns null if no transactions have been mined', async () => {\n            const transaction = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                maxFeePerGas: new BigNumber(1),\n                maxPriorityFeePerGas: new BigNumber(1),\n            });\n\n            when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0x1']))).thenResolve([undefined]);\n\n            const submissionContext = new SubmissionContext(instance(mockBlockchainUtils), [transaction]);\n\n            expect(await submissionContext.getReceiptAsync()).to.equal(null);\n        });\n\n        it('returns one transaction receipt have been mined', async () => {\n            const transaction1 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                maxFeePerGas: new BigNumber(1),\n                maxPriorityFeePerGas: new BigNumber(1),\n            });\n\n            const transaction2 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x2',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                maxFeePerGas: new BigNumber(1),\n                maxPriorityFeePerGas: new BigNumber(1),\n            });\n\n            const receipt: TransactionReceipt = {\n                to: '0xto',\n                from: '0xfrom',\n                contractAddress: '0xcontract',\n                transactionIndex: 1,\n                gasUsed: EthersBigNumber.from(1),\n                logsBloom: '',\n                blockHash: '0xblockhash',\n                transactionHash: '0x1',\n                logs: [],\n                blockNumber: 123,\n                confirmations: 1,\n                cumulativeGasUsed: EthersBigNumber.from(1),\n                effectiveGasPrice: EthersBigNumber.from(1),\n                byzantium: true,\n                type: 2,\n                status: 1,\n            };\n\n            when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0x1', '0x2']))).thenResolve([receipt, undefined]);\n\n            const submissionContext = new SubmissionContext(instance(mockBlockchainUtils), [\n                transaction1,\n                transaction2,\n            ]);\n\n            expect(await submissionContext.getReceiptAsync()).to.equal(receipt);\n        });\n\n        it('throws if multiple receipts are returned', () => {\n            const transaction1 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x1',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                maxFeePerGas: new BigNumber(1),\n                maxPriorityFeePerGas: new BigNumber(1),\n            });\n\n            const transaction2 = new RfqmV2TransactionSubmissionEntity({\n                type: RfqmTransactionSubmissionType.Trade,\n                transactionHash: '0x2',\n                from: '0xfrom',\n                to: '0xto',\n                orderHash: '0xOrderhash',\n                nonce: 0,\n                maxFeePerGas: new BigNumber(1),\n                maxPriorityFeePerGas: new BigNumber(1),\n            });\n\n            const receipt: TransactionReceipt = {\n                to: '0xto',\n                from: '0xfrom',\n                contractAddress: '0xcontract',\n                transactionIndex: 1,\n                gasUsed: EthersBigNumber.from(1),\n                logsBloom: '',\n                blockHash: '0xblockhash',\n                transactionHash: '0x1',\n                logs: [],\n                blockNumber: 123,\n                confirmations: 1,\n                cumulativeGasUsed: EthersBigNumber.from(1),\n                effectiveGasPrice: EthersBigNumber.from(1),\n                byzantium: true,\n                type: 2,\n                status: 1,\n            };\n\n            when(mockBlockchainUtils.getReceiptsAsync(deepEqual(['0x1', '0x2']))).thenResolve([receipt, receipt]);\n\n            const submissionContext = new SubmissionContext(instance(mockBlockchainUtils), [\n                transaction1,\n                transaction2,\n            ]);\n\n            expect(submissionContext.getReceiptAsync()).to.eventually.be.rejectedWith(\n                'more than one transaction receipt',\n            );\n        });\n\n        describe('isBlockConfirmed', () => {\n            it('should say no if receipt block is under 3 blocks deep', async () => {\n                const receiptBlock = 100;\n                const currentBlock = 102;\n\n                expect(SubmissionContext.isBlockConfirmed(currentBlock, receiptBlock)).to.equal(false);\n            });\n            it('should say yes if the receipt block is at least 3 blocks deep', async () => {\n                const receiptBlock = 100;\n                const currentBlock = 103;\n\n                expect(SubmissionContext.isBlockConfirmed(currentBlock, receiptBlock)).to.equal(true);\n            });\n        });\n\n        describe('submissionContextStatus', () => {\n            it('should return `PendingSubmitted` if none of the transactions is resolved', async () => {\n                const transaction1 = new RfqmV2TransactionSubmissionEntity({\n                    type: RfqmTransactionSubmissionType.Trade,\n                    transactionHash: '0x1',\n                    from: '0xfrom',\n                    to: '0xto',\n                    orderHash: '0xOrderhash',\n                    nonce: 0,\n                    maxFeePerGas: new BigNumber(1),\n                    maxPriorityFeePerGas: new BigNumber(1),\n                    status: RfqmTransactionSubmissionStatus.Submitted,\n                });\n\n                const transaction2 = new RfqmV2TransactionSubmissionEntity({\n                    type: RfqmTransactionSubmissionType.Trade,\n                    transactionHash: '0x2',\n                    from: '0xfrom',\n                    to: '0xto',\n                    orderHash: '0xOrderhash',\n                    nonce: 0,\n                    maxFeePerGas: new BigNumber(1),\n                    maxPriorityFeePerGas: new BigNumber(1),\n                    status: RfqmTransactionSubmissionStatus.Submitted,\n                });\n\n                const submissionContext = new SubmissionContext(instance(mockBlockchainUtils), [\n                    transaction1,\n                    transaction2,\n                ]);\n\n                expect(submissionContext.submissionContextStatus).to.deep.equal(\n                    SubmissionContextStatus.PendingSubmitted,\n                );\n            });\n\n            it('should return the correct status if one of the transactions is resolved', async () => {\n                const transaction1 = new RfqmV2TransactionSubmissionEntity({\n                    type: RfqmTransactionSubmissionType.Trade,\n                    transactionHash: '0x1',\n                    from: '0xfrom',\n                    to: '0xto',\n                    orderHash: '0xOrderhash',\n                    nonce: 0,\n                    maxFeePerGas: new BigNumber(1),\n                    maxPriorityFeePerGas: new BigNumber(1),\n                    status: RfqmTransactionSubmissionStatus.Submitted,\n                });\n\n                const transaction2 = new RfqmV2TransactionSubmissionEntity({\n                    type: RfqmTransactionSubmissionType.Trade,\n                    transactionHash: '0x2',\n                    from: '0xfrom',\n                    to: '0xto',\n                    orderHash: '0xOrderhash',\n                    nonce: 0,\n                    maxFeePerGas: new BigNumber(1),\n                    maxPriorityFeePerGas: new BigNumber(1),\n                    status: RfqmTransactionSubmissionStatus.SucceededConfirmed,\n                });\n\n                const submissionContext = new SubmissionContext(instance(mockBlockchainUtils), [\n                    transaction1,\n                    transaction2,\n                ]);\n\n                expect(submissionContext.submissionContextStatus).to.deep.equal(\n                    SubmissionContextStatus.SucceededConfirmed,\n                );\n            });\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/SubmissionContext.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/rfqm_db_utils_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\n\nimport { OtcOrder } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\n\nimport { ZERO } from '../../src/core/constants';\nimport { feeToStoredFee } from '../../src/core/fee_utils';\nimport {\n    DefaultFeeDetailsDeprecated,\n    Fee,\n    FeeWithDetails,\n    GasOnlyFeeDetailsDeprecated,\n    MarginBasedFeeDetailsDeprecated,\n} from '../../src/core/types';\nimport { otcOrderToStoredOtcOrder, storedOtcOrderToOtcOrder } from '../../src/utils/rfqm_db_utils';\n\ndescribe('RFQM DB utils', () => {\n    describe('storedOtcOrderToOtcOrder and otcOrderToStoredOtcOrder', () => {\n        it('should map there and back without data corruption', () => {\n            // it's expired if it's over 9000\n            const expiry = new BigNumber(9000);\n            const nonce = new BigNumber(1637085289);\n            const chainId = 1;\n            const order = new OtcOrder({\n                txOrigin: '0x0000000000000000000000000000000000000000',\n                taker: '0x1111111111111111111111111111111111111111',\n                maker: '0x2222222222222222222222222222222222222222',\n                makerToken: '0x3333333333333333333333333333333333333333',\n                takerToken: '0x4444444444444444444444444444444444444444',\n                expiryAndNonce: OtcOrder.encodeExpiryAndNonce(expiry, ZERO, nonce),\n                chainId,\n                verifyingContract: '0x0000000000000000000000000000000000000000',\n            });\n            const processedOrder = storedOtcOrderToOtcOrder(otcOrderToStoredOtcOrder(order));\n            expect(processedOrder).toEqual(order);\n        });\n    });\n    describe('feeToStoredFee', () => {\n        it('should convert Fee without details correctly', () => {\n            // Given\n            const fee: Fee = {\n                token: '0xatoken',\n                amount: new BigNumber(5),\n                type: 'fixed',\n            };\n\n            // When\n            const storedFee = feeToStoredFee(fee);\n\n            // Expect\n            expect(storedFee.type).toEqual(fee.type);\n            expect(storedFee.token).toEqual(fee.token);\n            expect(storedFee.amount).toEqual(fee.amount.toString());\n            expect(storedFee.details).toEqual(undefined);\n            expect(storedFee.breakdown).toEqual(undefined);\n            expect(storedFee.conversionRates).toEqual(undefined);\n        });\n\n        it('should convert Fee with gasOnly details correctly', () => {\n            // Given\n            const fee: FeeWithDetails & { details: GasOnlyFeeDetailsDeprecated } = {\n                token: '0xatoken',\n                amount: new BigNumber(5),\n                type: 'fixed',\n                details: {\n                    kind: 'gasOnly',\n                    feeModelVersion: 0,\n                    gasFeeAmount: new BigNumber(5),\n                    gasPrice: new BigNumber(50),\n                },\n                breakdown: {\n                    gas: {\n                        amount: new BigNumber(100),\n                        details: {\n                            gasPrice: new BigNumber(50),\n                            estimatedGas: new BigNumber(1),\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: null,\n                    feeTokenBaseUnitPriceUsd: null,\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n            };\n\n            // When\n            const storedFee = feeToStoredFee(fee);\n\n            // Expect\n            expect(storedFee.type).toEqual(fee.type);\n            expect(storedFee.token).toEqual(fee.token);\n            expect(storedFee.amount).toEqual(fee.amount.toString());\n            expect(storedFee.details.kind).toEqual(fee.details.kind);\n            expect(storedFee.details.feeModelVersion).toEqual(fee.details.feeModelVersion);\n            expect(storedFee.details.gasFeeAmount).toEqual(fee.details.gasFeeAmount.toString());\n            expect(storedFee.details.gasPrice).toEqual(fee.details.gasPrice.toString());\n\n            expect(storedFee.breakdown.gas.amount).toEqual(fee.breakdown.gas?.amount.toString());\n            expect(storedFee.breakdown.gas.details.gasPrice).toEqual(fee.breakdown.gas?.details.gasPrice.toString());\n            expect(storedFee.breakdown.gas.details.estimatedGas).toEqual(\n                fee.breakdown.gas?.details.estimatedGas.toString(),\n            );\n            expect(storedFee.breakdown.zeroEx).toEqual(undefined);\n\n            expect(storedFee.conversionRates.nativeTokenBaseUnitPriceUsd).toEqual(undefined);\n            expect(storedFee.conversionRates.feeTokenBaseUnitPriceUsd).toEqual(undefined);\n            expect(storedFee.conversionRates.takerTokenBaseUnitPriceUsd).toEqual(undefined);\n            expect(storedFee.conversionRates.makerTokenBaseUnitPriceUsd).toEqual(undefined);\n        });\n\n        it('should convert Fee with default details correctly', () => {\n            // Given\n            const fee: FeeWithDetails & { details: DefaultFeeDetailsDeprecated } = {\n                token: '0xatoken',\n                amount: new BigNumber(5),\n                type: 'fixed',\n                details: {\n                    kind: 'default',\n                    feeModelVersion: 1,\n                    gasFeeAmount: new BigNumber(5),\n                    gasPrice: new BigNumber(50),\n                    tradeSizeBps: 4,\n                    zeroExFeeAmount: new BigNumber(10),\n                    feeTokenBaseUnitPriceUsd: new BigNumber(3e-15),\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: new BigNumber(1e-18),\n                },\n                breakdown: {\n                    gas: {\n                        amount: new BigNumber(5),\n                        details: {\n                            gasPrice: new BigNumber(50),\n                            estimatedGas: new BigNumber(1),\n                        },\n                    },\n                    zeroEx: {\n                        amount: new BigNumber(10),\n                        details: {\n                            kind: 'volume',\n                            tradeSizeBps: 4,\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: new BigNumber(3e-15),\n                    feeTokenBaseUnitPriceUsd: new BigNumber(3e-15),\n                    takerTokenBaseUnitPriceUsd: null,\n                    makerTokenBaseUnitPriceUsd: new BigNumber(1e-18),\n                },\n            };\n\n            // When\n            const storedFee = feeToStoredFee(fee);\n\n            // Expect\n            expect(storedFee.type).toEqual(fee.type);\n            expect(storedFee.token).toEqual(fee.token);\n            expect(storedFee.amount).toEqual(fee.amount.toString());\n            expect(storedFee.details.kind).toEqual(fee.details.kind);\n            expect(storedFee.details.feeModelVersion).toEqual(fee.details.feeModelVersion);\n            expect(storedFee.details.gasFeeAmount).toEqual(fee.details.gasFeeAmount.toString());\n            expect(storedFee.details.gasPrice).toEqual(fee.details.gasPrice.toString());\n            expect(storedFee.details.tradeSizeBps).toEqual(fee.details.tradeSizeBps);\n            expect(storedFee.details.zeroExFeeAmount).toEqual(fee.details.zeroExFeeAmount.toString());\n            expect(storedFee.details.feeTokenBaseUnitPriceUsd).toEqual(\n                fee.details.feeTokenBaseUnitPriceUsd?.toString(),\n            );\n            expect(storedFee.details.takerTokenBaseUnitPriceUsd).toEqual(undefined);\n            expect(storedFee.details.makerTokenBaseUnitPriceUsd).toEqual(\n                fee.details.makerTokenBaseUnitPriceUsd?.toString(),\n            );\n\n            expect(storedFee.breakdown.gas.amount).toEqual(fee.breakdown.gas?.amount.toString());\n            expect(storedFee.breakdown.gas.details.gasPrice).toEqual(fee.breakdown.gas?.details.gasPrice.toString());\n            expect(storedFee.breakdown.gas.details.estimatedGas).toEqual(\n                fee.breakdown.gas?.details.estimatedGas.toString(),\n            );\n            expect(storedFee.breakdown.zeroEx.amount).toEqual(fee.breakdown.zeroEx?.amount.toString());\n            expect(storedFee.breakdown.zeroEx.details.kind).toEqual(fee.breakdown.zeroEx?.details.kind);\n            expect(storedFee.breakdown.zeroEx.details.tradeSizeBps).toEqual(4);\n\n            expect(storedFee.conversionRates.nativeTokenBaseUnitPriceUsd).toEqual(\n                fee.conversionRates.nativeTokenBaseUnitPriceUsd?.toString(),\n            );\n            expect(storedFee.conversionRates.feeTokenBaseUnitPriceUsd).toEqual(\n                fee.conversionRates.feeTokenBaseUnitPriceUsd?.toString(),\n            );\n            expect(storedFee.conversionRates.takerTokenBaseUnitPriceUsd).toEqual(undefined);\n            expect(storedFee.conversionRates.makerTokenBaseUnitPriceUsd).toEqual(\n                fee.conversionRates.makerTokenBaseUnitPriceUsd?.toString(),\n            );\n        });\n\n        it('should convert Fee with margin based details correctly', () => {\n            // Given\n            const fee: FeeWithDetails & { details: MarginBasedFeeDetailsDeprecated } = {\n                token: '0xatoken',\n                amount: new BigNumber(5),\n                type: 'fixed',\n                details: {\n                    kind: 'margin',\n                    feeModelVersion: 1,\n                    gasFeeAmount: new BigNumber(5),\n                    gasPrice: new BigNumber(50),\n                    margin: new BigNumber(4570),\n                    marginRakeRatio: 0.35,\n                    zeroExFeeAmount: new BigNumber(10),\n                    feeTokenBaseUnitPriceUsd: new BigNumber(3e-15),\n                    takerTokenBaseUnitPriceUsd: new BigNumber(1e-18),\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n                breakdown: {\n                    gas: {\n                        amount: new BigNumber(5),\n                        details: {\n                            gasPrice: new BigNumber(50),\n                            estimatedGas: new BigNumber(1),\n                        },\n                    },\n                    zeroEx: {\n                        amount: new BigNumber(10),\n                        details: {\n                            kind: 'price_improvement',\n                            priceImprovement: new BigNumber(4570),\n                            rakeRatio: 0.35,\n                        },\n                    },\n                },\n                conversionRates: {\n                    nativeTokenBaseUnitPriceUsd: new BigNumber(3e-15),\n                    feeTokenBaseUnitPriceUsd: new BigNumber(3e-15),\n                    takerTokenBaseUnitPriceUsd: new BigNumber(1e-18),\n                    makerTokenBaseUnitPriceUsd: null,\n                },\n            };\n\n            // When\n            const storedFee = feeToStoredFee(fee);\n\n            // Expect\n            expect(storedFee.type).toEqual(fee.type);\n            expect(storedFee.token).toEqual(fee.token);\n            expect(storedFee.amount).toEqual(fee.amount.toString());\n            expect(storedFee.details.kind).toEqual(fee.details.kind);\n            expect(storedFee.details.feeModelVersion).toEqual(fee.details.feeModelVersion);\n            expect(storedFee.details.gasFeeAmount).toEqual(fee.details.gasFeeAmount.toString());\n            expect(storedFee.details.gasPrice).toEqual(fee.details.gasPrice.toString());\n            expect(storedFee.details.margin).toEqual(fee.details.margin.toString());\n            expect(storedFee.details.marginRakeRatio).toEqual(fee.details.marginRakeRatio);\n            expect(storedFee.details.zeroExFeeAmount).toEqual(fee.details.zeroExFeeAmount.toString());\n            expect(storedFee.details.feeTokenBaseUnitPriceUsd).toEqual(\n                fee.details.feeTokenBaseUnitPriceUsd?.toString(),\n            );\n            expect(storedFee.details.takerTokenBaseUnitPriceUsd).toEqual(\n                fee.details.takerTokenBaseUnitPriceUsd?.toString(),\n            );\n            expect(storedFee.details.makerTokenBaseUnitPriceUsd).toEqual(undefined);\n\n            expect(storedFee.breakdown.gas.amount).toEqual(fee.breakdown.gas?.amount.toString());\n            expect(storedFee.breakdown.gas.details.gasPrice).toEqual(fee.breakdown.gas?.details.gasPrice.toString());\n            expect(storedFee.breakdown.gas.details.estimatedGas).toEqual(\n                fee.breakdown.gas?.details.estimatedGas.toString(),\n            );\n            expect(storedFee.breakdown.zeroEx.amount).toEqual(fee.breakdown.zeroEx?.amount.toString());\n            expect(storedFee.breakdown.zeroEx.details.kind).toEqual(fee.breakdown.zeroEx?.details.kind);\n            expect(storedFee.breakdown.zeroEx.details.priceImprovement).toEqual('4570');\n            expect(storedFee.breakdown.zeroEx.details.rakeRatio).toEqual(0.35);\n\n            expect(storedFee.conversionRates.nativeTokenBaseUnitPriceUsd).toEqual(\n                fee.conversionRates.nativeTokenBaseUnitPriceUsd?.toString(),\n            );\n            expect(storedFee.conversionRates.feeTokenBaseUnitPriceUsd).toEqual(\n                fee.conversionRates.feeTokenBaseUnitPriceUsd?.toString(),\n            );\n            expect(storedFee.conversionRates.takerTokenBaseUnitPriceUsd).toEqual(\n                fee.conversionRates.takerTokenBaseUnitPriceUsd?.toString(),\n            );\n            expect(storedFee.conversionRates.makerTokenBaseUnitPriceUsd).toEqual(undefined);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/rfq_maker_manager_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\n// tslint:disable:no-empty\n// tslint:disable:max-file-line-count\n\nimport { anything, instance, mock, when } from 'ts-mockito';\n\nimport { MakerIdSet } from '../../src/config';\nimport { RfqMaker } from '../../src/entities';\nimport { ConfigManager } from '../../src/utils/config_manager';\nimport { RfqMakerDbUtils } from '../../src/utils/rfq_maker_db_utils';\nimport { RfqMakerManager } from '../../src/utils/rfq_maker_manager';\nimport { CHAIN_ID } from '../constants';\n\nconst createMockConfigManager = (\n    rfqtRfqMakers: MakerIdSet,\n    rfqtOtcMakers: MakerIdSet,\n    rfqmOtcMakers: MakerIdSet,\n): ConfigManager => {\n    const configManagerMock = mock(ConfigManager);\n    when(configManagerMock.getRfqmMakerIdSetForOtcOrder()).thenReturn(rfqmOtcMakers);\n    when(configManagerMock.getRfqtMakerIdSetForRfqOrder()).thenReturn(rfqtRfqMakers);\n    when(configManagerMock.getRfqtMakerIdSetForOtcOrder()).thenReturn(rfqtOtcMakers);\n\n    return instance(configManagerMock);\n};\n\nconst createMockRfqMakerDbUtilsInstance = (rfqMaker: RfqMaker[]): RfqMakerDbUtils => {\n    const rfqMakerDbUtilsMock = mock(RfqMakerDbUtils);\n    when(rfqMakerDbUtilsMock.getRfqMakersAsync(anything())).thenResolve(rfqMaker);\n    when(rfqMakerDbUtilsMock.getRfqMakersUpdateTimeHashAsync(anything())).thenResolve('hash');\n\n    return instance(rfqMakerDbUtilsMock);\n};\n\ndescribe('RfqMakerManager', () => {\n    // Tokens in Checksum representation\n    const tokenA = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';\n    const tokenB = '0x6B175474E89094C44Da98b954EedeAC495271d0F';\n    const tokenC = '0xdAC17F958D2ee523a2206206994597C13D831ec7';\n\n    const makerIdSet: MakerIdSet = new Set();\n    makerIdSet.add('maker1');\n    makerIdSet.add('maker2');\n\n    const rfqMaker: RfqMaker[] = [\n        {\n            makerId: 'maker1',\n            chainId: CHAIN_ID,\n            pairs: [],\n            updatedAt: new Date(),\n            rfqtUri: 'https://maker1.asdf',\n            rfqmUri: 'https://maker1.asdf',\n        },\n        {\n            makerId: 'maker2',\n            chainId: CHAIN_ID,\n            pairs: [],\n            updatedAt: new Date(),\n            rfqtUri: 'https://maker2.asdf',\n            rfqmUri: 'https://maker2.asdf',\n        },\n    ];\n\n    describe('getRfqmV2MakerUrisForPair', () => {\n        it('should return a list of maker uris for a given config', async () => {\n            // Given\n            rfqMaker[0].pairs = [[tokenA, tokenB]];\n            rfqMaker[1].pairs = [[tokenA, tokenB]];\n            const rfqMakerDbUtils = createMockRfqMakerDbUtilsInstance(rfqMaker);\n            const configManager = createMockConfigManager(makerIdSet, makerIdSet, makerIdSet);\n\n            const rfqMakerManager = new RfqMakerManager(configManager, rfqMakerDbUtils, CHAIN_ID);\n            await rfqMakerManager.initializeAsync();\n\n            // When\n            const makerUris = rfqMakerManager.getRfqmV2MakerUrisForPair(tokenA, tokenB);\n\n            // Then\n            expect(makerUris).toEqual(['https://maker1.asdf', 'https://maker2.asdf']);\n        });\n\n        it('should ignore ordering when considering pairs', async () => {\n            // Given\n            rfqMaker[0].pairs = [[tokenA, tokenB]];\n            rfqMaker[1].pairs = [[tokenB, tokenA]];\n            const rfqMakerDbUtils = createMockRfqMakerDbUtilsInstance(rfqMaker);\n            const configManager = createMockConfigManager(makerIdSet, makerIdSet, makerIdSet);\n\n            const rfqMakerManager = new RfqMakerManager(configManager, rfqMakerDbUtils, CHAIN_ID);\n            await rfqMakerManager.initializeAsync();\n\n            // When\n            const makerUris1 = rfqMakerManager.getRfqmV2MakerUrisForPair(tokenB, tokenA); // order doesn't matter\n            const makerUris2 = rfqMakerManager.getRfqmV2MakerUrisForPair(tokenB, tokenA); // order doesn't matter\n\n            // Then\n            expect(makerUris1).toEqual(['https://maker1.asdf', 'https://maker2.asdf']);\n            expect(makerUris2).toEqual(['https://maker1.asdf', 'https://maker2.asdf']);\n        });\n\n        it('should return whitelisted makers only', async () => {\n            // Given\n            rfqMaker[0].pairs = [[tokenA, tokenB]];\n            rfqMaker[1].pairs = [[tokenA, tokenB]];\n            const rfqMakerDbUtils = createMockRfqMakerDbUtilsInstance(rfqMaker);\n            const configManager = createMockConfigManager(makerIdSet, makerIdSet, makerIdSet);\n\n            const rfqMakerManager = new RfqMakerManager(configManager, rfqMakerDbUtils, CHAIN_ID);\n            await rfqMakerManager.initializeAsync();\n\n            const whitelistedMakerIds = [rfqMaker[0].makerId];\n\n            // When\n            const makerUris1 = rfqMakerManager.getRfqmV2MakerUrisForPair(tokenA, tokenB);\n            const makerUris2 = rfqMakerManager.getRfqmV2MakerUrisForPair(tokenA, tokenB, whitelistedMakerIds);\n\n            // Then\n            expect(makerUris1).toEqual(['https://maker1.asdf', 'https://maker2.asdf']);\n            expect(makerUris2).toEqual(['https://maker1.asdf']);\n        });\n\n        it('should filter out blacklisted makers', async () => {\n            // Given\n            rfqMaker[0].pairs = [[tokenA, tokenB]];\n            rfqMaker[1].pairs = [[tokenA, tokenB]];\n            const rfqMakerDbUtils = createMockRfqMakerDbUtilsInstance(rfqMaker);\n            const configManager = createMockConfigManager(makerIdSet, makerIdSet, makerIdSet);\n\n            const rfqMakerManager = new RfqMakerManager(configManager, rfqMakerDbUtils, CHAIN_ID);\n            await rfqMakerManager.initializeAsync();\n\n            const blacklistedMakerIds = [rfqMaker[0].makerId];\n\n            // When\n            const makerUris1 = rfqMakerManager.getRfqmV2MakerUrisForPair(tokenA, tokenB);\n            const makerUris2 = rfqMakerManager.getRfqmV2MakerUrisForPair(tokenA, tokenB, null, blacklistedMakerIds);\n\n            // Then\n            expect(makerUris1).toEqual(['https://maker1.asdf', 'https://maker2.asdf']);\n            expect(makerUris2).toEqual(['https://maker2.asdf']);\n        });\n\n        it('should ignore casing when considering pairs', async () => {\n            // Given\n            // These pairs are selected such that when sorted as is: [0xF, 0xd]\n            // But their order fips when sorted after lower casing:  [0xd, 0xf]\n            const token_0xd = '0xdAC17F958D2ee523a2206206994597C13D831ec7';\n            const token_0xF = '0xFA2562da1Bba7B954f26C74725dF51fb62646313';\n            rfqMaker[0].pairs = [[token_0xd, token_0xF]];\n            rfqMaker[1].pairs = [[token_0xd.toLowerCase(), token_0xF.toLowerCase()]]; // case doesn't matter\n            const rfqMakerDbUtils = createMockRfqMakerDbUtilsInstance(rfqMaker);\n            const configManager = createMockConfigManager(makerIdSet, makerIdSet, makerIdSet);\n\n            const rfqMakerManager = new RfqMakerManager(configManager, rfqMakerDbUtils, CHAIN_ID);\n            await rfqMakerManager.initializeAsync();\n\n            // When\n            const makerUris1 = rfqMakerManager.getRfqmV2MakerUrisForPair(token_0xd, token_0xF);\n            const makerUris2 = rfqMakerManager.getRfqmV2MakerUrisForPair(\n                token_0xd.toUpperCase(),\n                token_0xF.toUpperCase(),\n            ); // case doesn't matter\n\n            // Then\n            expect(makerUris1).toEqual(makerUris2);\n        });\n\n        it('should return [] if no maker uris are providing liquidity', async () => {\n            // Given\n            rfqMaker[0].pairs = [[tokenA, tokenB]];\n            rfqMaker[1].pairs = [[tokenA, tokenB]];\n            const rfqMakerDbUtils = createMockRfqMakerDbUtilsInstance(rfqMaker);\n\n            const makerIdSetForMaker2Only: MakerIdSet = new Set();\n            makerIdSetForMaker2Only.add('maker2');\n            const configManager = createMockConfigManager(new Set(), makerIdSet, makerIdSetForMaker2Only);\n\n            const rfqMakerManager = new RfqMakerManager(configManager, rfqMakerDbUtils, CHAIN_ID);\n            await rfqMakerManager.initializeAsync();\n\n            // When\n            const makerUris = rfqMakerManager.getRfqmV2MakerUrisForPair(tokenA, tokenC);\n\n            // Then\n            expect(makerUris).toEqual([]);\n        });\n    });\n\n    describe('findMakerIdWithRfqmUri', () => {\n        it('should return correct maker Id if the rfqm URI exists', async () => {\n            // Given\n            const rfqMakerDbUtils = createMockRfqMakerDbUtilsInstance(rfqMaker);\n            const configManager = createMockConfigManager(makerIdSet, makerIdSet, makerIdSet);\n\n            const rfqMakerManager = new RfqMakerManager(configManager, rfqMakerDbUtils, CHAIN_ID);\n            await rfqMakerManager.initializeAsync();\n\n            // When\n            const maker1Id = rfqMakerManager.findMakerIdWithRfqmUri('https://maker1.asdf');\n            const maker2Id = rfqMakerManager.findMakerIdWithRfqmUri('https://maker2.asdf');\n\n            // Then\n            expect(maker1Id).toEqual('maker1');\n            expect(maker2Id).toEqual('maker2');\n        });\n\n        it('should return null if the maker URI does not exist', async () => {\n            // Given\n            const rfqMakerDbUtils = createMockRfqMakerDbUtilsInstance(rfqMaker);\n            const configManager = createMockConfigManager(makerIdSet, makerIdSet, makerIdSet);\n\n            const rfqMakerManager = new RfqMakerManager(configManager, rfqMakerDbUtils, CHAIN_ID);\n            await rfqMakerManager.initializeAsync();\n\n            // When\n            const nullMakerId = rfqMakerManager.findMakerIdWithRfqmUri('https://maker-null.asdf');\n\n            // Then\n            expect(nullMakerId).toEqual(null);\n        });\n    });\n\n    describe('getRfqtV2MakerOfferings', () => {\n        it('should return the RfqMakerAssetOfferings for OtcOrder', async () => {\n            // Given\n            const rfqMakerForMaker123 = [...rfqMaker];\n            rfqMakerForMaker123[0].pairs = [[tokenA, tokenB]];\n            rfqMakerForMaker123[1].pairs = [[tokenA, tokenB]];\n            rfqMakerForMaker123.push({\n                makerId: 'maker3',\n                chainId: CHAIN_ID,\n                pairs: [[tokenA, tokenC]],\n                updatedAt: new Date(),\n                rfqtUri: 'https://maker3.asdf',\n                rfqmUri: null,\n            });\n\n            const rfqMakerDbUtils = createMockRfqMakerDbUtilsInstance(rfqMakerForMaker123);\n\n            const makerIdSetWithMakers23: MakerIdSet = new Set();\n            makerIdSetWithMakers23.add('maker2');\n            makerIdSetWithMakers23.add('maker3');\n            const configManager = createMockConfigManager(makerIdSetWithMakers23, makerIdSetWithMakers23, new Set());\n\n            const rfqMakerManager = new RfqMakerManager(configManager, rfqMakerDbUtils, CHAIN_ID);\n            await rfqMakerManager.initializeAsync();\n\n            // When\n            const assetOfferings = rfqMakerManager.getRfqtV2MakerOfferings();\n\n            // Then\n            expect(assetOfferings).toEqual({\n                'https://maker2.asdf': [[tokenA, tokenB]],\n                'https://maker3.asdf': [[tokenA, tokenC]],\n            });\n        });\n    });\n\n    describe('getRfqtV1MakerOfferings', () => {\n        it('should return the RfqMakerAssetOfferings for RfqOrder', async () => {\n            // Given\n            const rfqMakerForMaker123 = [...rfqMaker];\n            rfqMakerForMaker123[0].pairs = [[tokenA, tokenB]];\n            rfqMakerForMaker123[1].pairs = [[tokenA, tokenB]];\n            rfqMakerForMaker123.push({\n                makerId: 'maker3',\n                chainId: CHAIN_ID,\n                pairs: [[tokenA, tokenC]],\n                updatedAt: new Date(),\n                rfqmUri: null,\n                rfqtUri: 'https://maker3.asdf',\n            });\n\n            const rfqMakerDbUtils = createMockRfqMakerDbUtilsInstance(rfqMakerForMaker123);\n\n            const makerIdSetWithMakers23: MakerIdSet = new Set();\n            makerIdSetWithMakers23.add('maker2');\n            makerIdSetWithMakers23.add('maker3');\n            const configManager = createMockConfigManager(makerIdSetWithMakers23, new Set(), new Set());\n\n            const rfqMakerManager = new RfqMakerManager(configManager, rfqMakerDbUtils, CHAIN_ID);\n            await rfqMakerManager.initializeAsync();\n\n            // When\n            const assetOfferings = rfqMakerManager.getRfqtV1MakerOfferings();\n\n            // Then\n            expect(assetOfferings).toEqual({\n                'https://maker2.asdf': [[tokenA, tokenB]],\n                'https://maker3.asdf': [[tokenA, tokenC]],\n            });\n        });\n    });\n    describe('getRfqtV2MakersForPair', () => {\n        it('should return the market makers trading rfqt-otc', async () => {\n            rfqMaker[0].pairs = [[tokenB, tokenA]];\n            rfqMaker[1].pairs = [[tokenB, tokenB]]; // This maker should not be included in the result\n\n            const rfqMakerDbUtils = createMockRfqMakerDbUtilsInstance(rfqMaker);\n            const configManager = createMockConfigManager(new Set(), new Set(['maker1', 'maker2']), new Set());\n            const rfqMakerManager = new RfqMakerManager(configManager, rfqMakerDbUtils, CHAIN_ID);\n            await rfqMakerManager.initializeAsync();\n\n            const makers = rfqMakerManager.getRfqtV2MakersForPair(tokenA, tokenB);\n\n            expect(makers.length).toEqual(1);\n            expect(makers[0].makerId).toEqual('maker1');\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/services/rfq_maker_service_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\n// tslint:disable:no-empty\n// tslint:disable:max-file-line-count\n\nimport { ChainId } from '@0x/contract-addresses';\nimport { expect } from 'chai';\nimport { anything, instance, mock, when } from 'ts-mockito';\nimport { Connection, Repository } from 'typeorm';\n\nimport { RfqMaker } from '../../src/entities';\nimport { RfqMakerService } from '../../src/services/rfq_maker_service';\nimport { ConfigManager } from '../../src/utils/config_manager';\nimport { RfqMakerDbUtils } from '../../src/utils/rfq_maker_db_utils';\n\ndescribe('RfqMakerService', () => {\n    const makerId = 'fakeMaker1';\n    const makerApiKey = 'fakeMakerApiKey1';\n    const chainId = ChainId.Ganache;\n    const updatedAt = new Date();\n    const pairs: [string, string][] = [\n        ['0x374a16f5e686c09b0cc9e8bc3466b3b645c74aa7', '0xf84830b73b2ed3c7267e7638f500110ea47fdf30'],\n    ];\n\n    describe('getRfqMakerAsync', () => {\n        it('should get RfqMaker entity from db connection', async () => {\n            // Given\n            const rfqMaker: RfqMaker = new RfqMaker({\n                makerId,\n                chainId,\n                updatedAt,\n                pairs,\n                rfqtUri: null,\n                rfqmUri: null,\n            });\n            const repositoryMock = mock(Repository);\n            when(repositoryMock.findOne(anything())).thenResolve(rfqMaker);\n            const connectionMock = mock(Connection);\n            when(connectionMock.getRepository(RfqMaker)).thenReturn(instance(repositoryMock));\n            const rfqDbUtils = new RfqMakerDbUtils(instance(connectionMock));\n\n            const configManagerMock = mock(ConfigManager);\n\n            const rfqMakerService = new RfqMakerService(rfqDbUtils, configManagerMock);\n\n            // When\n            const rfqMakerFromSevice = await rfqMakerService.getRfqMakerAsync(makerId, chainId);\n\n            // Then\n            expect(rfqMakerFromSevice.makerId).to.be.eq(makerId);\n            expect(rfqMakerFromSevice.chainId).to.be.eq(chainId);\n            expect(rfqMakerFromSevice.updatedAt).to.be.eq(updatedAt);\n            expect(rfqMakerFromSevice.pairs).to.be.eq(pairs);\n        });\n\n        it('should get default RfqMaker entity if there is no information in DB', async () => {\n            // Given\n            const repositoryMock = mock(Repository);\n            when(repositoryMock.findOne(anything())).thenResolve(undefined);\n            const connectionMock = mock(Connection);\n            when(connectionMock.getRepository(RfqMaker)).thenReturn(instance(repositoryMock));\n            const rfqDbUtils = new RfqMakerDbUtils(instance(connectionMock));\n\n            const configManagerMock = mock(ConfigManager);\n\n            const rfqMakerService = new RfqMakerService(rfqDbUtils, configManagerMock);\n\n            // When\n            const rfqMakerFromSevice = await rfqMakerService.getRfqMakerAsync(makerId, chainId);\n\n            // Then\n            expect(rfqMakerFromSevice.makerId).to.be.eq(makerId);\n            expect(rfqMakerFromSevice.chainId).to.be.eq(chainId);\n            expect(rfqMakerFromSevice.updatedAt).to.be.eq(null);\n            expect(rfqMakerFromSevice.pairs.length).to.be.eq(0);\n        });\n    });\n\n    describe('createOrUpdateRfqMakerAsync', () => {\n        it('should create or update the RfqMaker entity through db connection', async () => {\n            // Given\n            const repositoryMock = mock(Repository);\n            when(repositoryMock.save(anything())).thenCall((rfqMaker) => {\n                // Then\n                expect(rfqMaker.makerId).to.be.eq(makerId);\n                expect(rfqMaker.chainId).to.be.eq(chainId);\n                expect(rfqMaker.pairs).to.be.eq(pairs);\n            });\n            const connectionMock = mock(Connection);\n            when(connectionMock.getRepository(RfqMaker)).thenReturn(instance(repositoryMock));\n            const rfqDbUtils = new RfqMakerDbUtils(instance(connectionMock));\n            const configManagerMock = mock(ConfigManager);\n\n            const rfqMakerService = new RfqMakerService(rfqDbUtils, configManagerMock);\n\n            // When\n            await rfqMakerService.createOrUpdateRfqMakerAsync(makerId, chainId, pairs, null, null);\n        });\n    });\n\n    describe('patchRfqMakerAsync', () => {\n        it('should update pairs', async () => {\n            // Given\n            const originalRfqMaker: RfqMaker = new RfqMaker({\n                makerId,\n                chainId,\n                updatedAt,\n                pairs,\n                rfqtUri: null,\n                rfqmUri: null,\n            });\n            const newPairs: [string, string][] = [];\n            const rfqMakerServiceMock = mock(RfqMakerService);\n            when(rfqMakerServiceMock.getRfqMakerAsync(anything(), anything())).thenResolve(originalRfqMaker);\n\n            // Expect\n            when(\n                rfqMakerServiceMock.createOrUpdateRfqMakerAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenCall((makerIdToSave, chainIdToSave, pairsToSave, rfqtUriToSave, rfqmUriToSave) => {\n                expect(makerIdToSave).to.be.eq(originalRfqMaker.makerId);\n                expect(chainIdToSave).to.be.eq(originalRfqMaker.chainId);\n                expect(pairsToSave).to.be.eq(newPairs);\n                expect(rfqtUriToSave).to.be.eq(originalRfqMaker.rfqtUri);\n                expect(rfqmUriToSave).to.be.eq(originalRfqMaker.rfqmUri);\n            });\n            const rfqMakerService = instance(rfqMakerServiceMock);\n\n            // When\n            await rfqMakerService.patchRfqMakerAsync(makerId, chainId, newPairs, undefined, undefined);\n        });\n        it('should update URIs from null to a valid string', async () => {\n            // Given\n            const originalRfqMaker: RfqMaker = new RfqMaker({\n                makerId,\n                chainId,\n                updatedAt,\n                pairs,\n                rfqtUri: null,\n                rfqmUri: null,\n            });\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-inferrable-types\n            const newRfqtUri: string = 'http://localhost:3001';\n            const rfqMakerServiceMock = mock(RfqMakerService);\n            when(rfqMakerServiceMock.getRfqMakerAsync(anything(), anything())).thenResolve(originalRfqMaker);\n\n            // Expect\n            when(\n                rfqMakerServiceMock.createOrUpdateRfqMakerAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenCall((makerIdToSave, chainIdToSave, pairsToSave, rfqtUriToSave, rfqmUriToSave) => {\n                expect(makerIdToSave).to.be.eq(originalRfqMaker.makerId);\n                expect(chainIdToSave).to.be.eq(originalRfqMaker.chainId);\n                expect(pairsToSave).to.be.eq(originalRfqMaker.pairs);\n                expect(rfqtUriToSave).to.be.eq(newRfqtUri);\n                expect(rfqmUriToSave).to.be.eq(originalRfqMaker.rfqmUri);\n            });\n            const rfqMakerService = instance(rfqMakerServiceMock);\n\n            // When\n            await rfqMakerService.patchRfqMakerAsync(makerId, chainId, undefined, newRfqtUri, undefined);\n        });\n        it('should update URIs from string to null', async () => {\n            // Given\n            const originalRfqMaker: RfqMaker = new RfqMaker({\n                makerId,\n                chainId,\n                updatedAt,\n                pairs,\n                rfqtUri: 'http://localhost:3001',\n                rfqmUri: 'http://localhost:3002',\n            });\n            const rfqMakerServiceMock = mock(RfqMakerService);\n            when(rfqMakerServiceMock.getRfqMakerAsync(anything(), anything())).thenResolve(originalRfqMaker);\n\n            // Expect\n            when(\n                rfqMakerServiceMock.createOrUpdateRfqMakerAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).thenCall((makerIdToSave, chainIdToSave, pairsToSave, rfqtUriToSave, rfqmUriToSave) => {\n                expect(makerIdToSave).to.be.eq(originalRfqMaker.makerId);\n                expect(chainIdToSave).to.be.eq(originalRfqMaker.chainId);\n                expect(pairsToSave).to.be.eq(originalRfqMaker.pairs);\n                expect(rfqtUriToSave).to.be.eq(originalRfqMaker.rfqtUri);\n                expect(rfqmUriToSave).to.be.eq(null);\n            });\n            const rfqMakerService = instance(rfqMakerServiceMock);\n\n            // When\n            await rfqMakerService.patchRfqMakerAsync(makerId, chainId, undefined, undefined, null);\n        });\n    });\n\n    describe('mapMakerApiKeyToId', () => {\n        it('should map maker api key to maker id correctly', async () => {\n            // Given\n            const rfqDbUtils = mock(RfqMakerDbUtils);\n            const configManagerMock = mock(ConfigManager);\n            when(configManagerMock.getRfqMakerIdForApiKey(makerApiKey)).thenReturn(makerId);\n\n            const rfqMakerService = new RfqMakerService(rfqDbUtils, instance(configManagerMock));\n\n            // When\n            const makerIdFromService = rfqMakerService.mapMakerApiKeyToId(makerApiKey);\n\n            // Then\n            expect(makerIdFromService).to.be.eq(makerId);\n        });\n\n        it('should return null for undefined api key', async () => {\n            // Given\n            const rfqDbUtilsMock = mock(RfqMakerDbUtils);\n            const configManagerMock = mock(ConfigManager);\n            when(configManagerMock.getRfqMakerIdForApiKey(makerApiKey)).thenReturn(makerId);\n\n            const rfqMakerService = new RfqMakerService(rfqDbUtilsMock, instance(configManagerMock));\n\n            // When\n            const makerIdFromService = rfqMakerService.mapMakerApiKeyToId(undefined);\n\n            // Then\n            expect(makerIdFromService).to.be.eq(null);\n        });\n    });\n\n    describe('isValidChainId', () => {\n        it('should return false for invalid number chainId', async () => {\n            // Given\n            const invalidChainId = '123a';\n\n            // When\n            const isValidChainId = RfqMakerService.isValidChainId(invalidChainId);\n\n            // Then\n            expect(isValidChainId).to.be.eq(false);\n        });\n\n        it('should return false for unknown number chainId', async () => {\n            // Given\n            const invalidChainId = '12345';\n\n            // When\n            const isValidChainId = RfqMakerService.isValidChainId(invalidChainId);\n\n            // Then\n            expect(isValidChainId).to.be.eq(false);\n        });\n\n        it('should return number ChainId for well formated chainId', async () => {\n            // Given\n            const validChainId = '1337';\n\n            // When\n            const isValidChainId = RfqMakerService.isValidChainId(validChainId);\n\n            // Then\n            expect(isValidChainId).to.be.eq(true);\n        });\n    });\n\n    describe('validatePairsPayload', () => {\n        it('should pass with valid input pairs', async () => {\n            expect(() => {\n                RfqMakerService.validatePairsPayloadOrThrow(pairs);\n            }).to.not.throw();\n        });\n\n        it('should throw for non array input', async () => {\n            expect(() => {\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                RfqMakerService.validatePairsPayloadOrThrow('123' as any);\n            }).to.throw();\n        });\n\n        it('should throw for array of non arrays', async () => {\n            expect(() => {\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                RfqMakerService.validatePairsPayloadOrThrow(['123'] as any);\n            }).to.throw();\n        });\n\n        it('should throw for incorrect sub-array length', async () => {\n            expect(() => {\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                RfqMakerService.validatePairsPayloadOrThrow(['123'] as any);\n            }).to.throw();\n        });\n\n        it('should throw for pairs of invalid ethereum addresses', async () => {\n            expect(() => {\n                RfqMakerService.validatePairsPayloadOrThrow([['123', '234']]);\n            }).to.throw();\n        });\n\n        it('should throw for pairs of identical ethereum addresses', async () => {\n            expect(() => {\n                RfqMakerService.validatePairsPayloadOrThrow([\n                    ['0x374a16f5e686c09b0cc9e8bc3466b3b645c74aa7', '0x374a16f5e686c09b0cc9e8bc3466b3b645c74aa7'],\n                ]);\n            }).to.throw();\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/cache_service_test.ts",{"fileContent":"import { ChainId } from '@0x/contract-addresses';\nimport { BigNumber } from '@0x/utils';\nimport { expect } from 'chai';\nimport Redis from 'ioredis';\n\nimport { ONE_MINUTE_MS } from '../../src/core/constants';\nimport { ERC20Owner } from '../../src/core/types';\nimport { CacheClient } from '../../src/utils/cache_client';\nimport { setupDependenciesAsync, TeardownDependenciesFunctionHandle } from '../test_utils/deployment';\n\njest.setTimeout(ONE_MINUTE_MS * 2);\nlet teardownDependencies: TeardownDependenciesFunctionHandle;\n\ndescribe('CacheClient', () => {\n    let redis: Redis;\n    let cacheClient: CacheClient;\n\n    const chainId = ChainId.Ganache;\n\n    const makerA = '0x1111111111111111111111111111111111111111';\n    const makerB = '0x2222222222222222222222222222222222222222';\n    const makerC = '0x3333333333333333333333333333333333333333';\n\n    const tokenA = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';\n    const tokenB = '0x6B175474E89094C44Da98b954EedeAC495271d0F';\n    const tokenC = '0xdAC17F958D2ee523a2206206994597C13D831ec7';\n\n    // compareFn is used to determine the order of ERC20Owner elements\n    const compareFn = (a: ERC20Owner, b: ERC20Owner) => a.owner.localeCompare(b.owner);\n\n    beforeAll(async () => {\n        teardownDependencies = await setupDependenciesAsync(['redis']);\n        redis = new Redis();\n        cacheClient = new CacheClient(redis);\n    });\n\n    afterAll(async () => {\n        await cacheClient.closeAsync();\n        if (!teardownDependencies()) {\n            throw new Error('Failed to tear down dependencies');\n        }\n    });\n\n    afterEach(async () => {\n        await redis.flushdb();\n    });\n\n    describe('addERC20OwnerAsync', () => {\n        it('adds pending address to observed addresses without error', async () => {\n            expect(cacheClient.addERC20OwnerAsync(chainId, { owner: makerA, token: tokenA })).to.eventually.be.equal(\n                void 0,\n            );\n        });\n    });\n\n    describe('getERC20OwnersAsync', () => {\n        const addresses = [\n            { owner: makerA, token: tokenA },\n            { owner: makerB, token: tokenB },\n            { owner: makerC, token: tokenC },\n        ];\n\n        it('fetches maker token addresses in correct format', async () => {\n            addresses.forEach(async (address) => {\n                await cacheClient.addERC20OwnerAsync(chainId, address);\n            });\n            const cachedAddresses = await cacheClient.getERC20OwnersAsync(chainId);\n            expect(cachedAddresses.sort(compareFn)).to.deep.eq(addresses.sort(compareFn));\n        });\n\n        it('fetches empty arrays if no addresses are found in the set', async () => {\n            expect(await cacheClient.getERC20OwnersAsync(chainId)).to.deep.eq([]);\n        });\n    });\n\n    describe('setERC20OwnerBalancesAsync', () => {\n        const addresses = [\n            { owner: makerA, token: tokenA },\n            { owner: makerB, token: tokenB },\n            { owner: makerC, token: tokenC },\n        ];\n        const balances = [new BigNumber(1), new BigNumber(2), new BigNumber(3)];\n\n        it('sets balances in the cache without error', async () => {\n            expect(cacheClient.setERC20OwnerBalancesAsync(chainId, addresses, balances)).to.eventually.be.equal(void 0);\n        });\n\n        it('should fail when addresses do not match balances', async () => {\n            expect(\n                cacheClient.setERC20OwnerBalancesAsync(chainId, addresses, balances.slice(0, -1)),\n            ).to.be.rejectedWith('balances');\n        });\n\n        it('should not fail when addresses are empty', async () => {\n            expect(cacheClient.setERC20OwnerBalancesAsync(chainId, [], [])).to.eventually.be.equal(void 0);\n        });\n    });\n\n    describe('getERC20OwnerBalancesAsync', () => {\n        const addresses = [\n            { owner: makerA, token: tokenA },\n            { owner: makerB, token: tokenB },\n            { owner: makerC, token: tokenC },\n        ];\n        const balances = [new BigNumber(1), new BigNumber(2), new BigNumber(3)];\n\n        beforeEach(async () => {\n            await cacheClient.setERC20OwnerBalancesAsync(chainId, addresses, balances);\n        });\n\n        it('fetches correct balances from the cache', async () => {\n            expect(await cacheClient.getERC20OwnerBalancesAsync(chainId, addresses)).to.deep.eq([\n                new BigNumber(1),\n                new BigNumber(2),\n                new BigNumber(3),\n            ]);\n        });\n\n        it('returns null balances if addresses are not in the cache', async () => {\n            const badAddresses = [\n                { owner: makerA, token: tokenA },\n                { owner: makerB, token: tokenB },\n                { owner: '0x0000000000000000000000000000000000000000', token: tokenC },\n            ];\n            expect(await cacheClient.getERC20OwnerBalancesAsync(chainId, badAddresses)).to.deep.eq([\n                new BigNumber(1),\n                new BigNumber(2),\n                null,\n            ]);\n        });\n\n        it('returns null balances if addresses from a different chain are supplied', async () => {\n            expect(await cacheClient.getERC20OwnerBalancesAsync(ChainId.PolygonMumbai, addresses)).to.deep.eq([\n                null,\n                null,\n                null,\n            ]);\n        });\n\n        it('returns an empty array if addresses are empty', async () => {\n            expect(await cacheClient.getERC20OwnerBalancesAsync(chainId, [])).to.deep.eq([]);\n        });\n    });\n\n    describe('evictZeroBalancesAsync', () => {\n        const addresses = [\n            { owner: makerA, token: tokenA },\n            { owner: makerB, token: tokenB },\n            { owner: makerC, token: tokenC },\n        ];\n\n        it('evicts zeroed entries from the cache', async () => {\n            addresses.forEach(async (address) => {\n                await cacheClient.addERC20OwnerAsync(chainId, address);\n            });\n            let cachedAddresses = await cacheClient.getERC20OwnersAsync(chainId);\n            expect(cachedAddresses.sort(compareFn)).to.deep.eq(addresses.sort(compareFn));\n\n            const balances = [new BigNumber(1), new BigNumber(2), new BigNumber(0)];\n            await cacheClient.setERC20OwnerBalancesAsync(chainId, addresses, balances);\n\n            const numEvicted = await cacheClient.evictZeroBalancesAsync(chainId);\n            expect(numEvicted).to.eq(1);\n            cachedAddresses = await cacheClient.getERC20OwnersAsync(chainId);\n            expect(cachedAddresses.sort(compareFn)).to.deep.eq(addresses.slice(0, 2).sort(compareFn));\n        });\n\n        it('does not evict any entries if there are no stale balances', async () => {\n            addresses.forEach(async (address) => {\n                await cacheClient.addERC20OwnerAsync(chainId, address);\n            });\n            let cachedAddresses = await cacheClient.getERC20OwnersAsync(chainId);\n            expect(cachedAddresses.sort(compareFn)).to.deep.eq(addresses.sort(compareFn));\n\n            const balances = [new BigNumber(1), new BigNumber(2), new BigNumber(3)];\n            await cacheClient.setERC20OwnerBalancesAsync(chainId, addresses, balances);\n\n            const numEvicted = await cacheClient.evictZeroBalancesAsync(chainId);\n            expect(numEvicted).to.eq(0);\n            cachedAddresses = await cacheClient.getERC20OwnersAsync(chainId);\n            expect(cachedAddresses.sort(compareFn)).to.deep.eq(addresses.sort(compareFn));\n        });\n\n        it('does not error if the address set is empty', async () => {\n            expect(await cacheClient.getERC20OwnersAsync(chainId)).to.have.length(0);\n            const numEvicted = await cacheClient.evictZeroBalancesAsync(chainId);\n            expect(numEvicted).to.eq(0);\n        });\n    });\n\n    describe('coolDownMakerForPair', () => {\n        const makerId1 = 'makerId1';\n        const takerToken = 'takerToken';\n        const makerToken = 'makerToken';\n\n        it('should add new makers to the cooling down set for a pair', async () => {\n            const isUpdated = await cacheClient.addMakerToCooldownAsync(\n                makerId1,\n                Date.now(),\n                chainId,\n                takerToken,\n                makerToken,\n            );\n            expect(isUpdated).to.eq(true);\n        });\n\n        it('should update endTime to a time later than existing endTime', async () => {\n            const now = Date.now();\n            const oneMinuteLater = now + ONE_MINUTE_MS;\n            await cacheClient.addMakerToCooldownAsync(makerId1, now, chainId, takerToken, makerToken);\n            const isUpdated = await cacheClient.addMakerToCooldownAsync(\n                makerId1,\n                oneMinuteLater,\n                chainId,\n                makerToken,\n                takerToken,\n            );\n            expect(isUpdated).to.eq(true);\n        });\n\n        it('should not update endTime to a time earlier than existing endTime', async () => {\n            const now = Date.now();\n            const oneMinuteEarlier = now - ONE_MINUTE_MS;\n            await cacheClient.addMakerToCooldownAsync(makerId1, now, chainId, takerToken, makerToken);\n            const isUpdated = await cacheClient.addMakerToCooldownAsync(\n                makerId1,\n                oneMinuteEarlier,\n                chainId,\n                takerToken,\n                makerToken,\n            );\n            expect(isUpdated).to.eq(false);\n        });\n    });\n\n    describe('getCoolingDownMakersForPair', () => {\n        const makerId1 = 'makerId1';\n        const makerId2 = 'makerId2';\n        const takerToken = 'takerToken';\n        const otherTakerToken = 'otherTakerToken';\n        const makerToken = 'makerToken';\n\n        it('should get all makers that are cooling down', async () => {\n            const now = Date.now();\n            const oneMinuteLater = now + ONE_MINUTE_MS;\n            await cacheClient.addMakerToCooldownAsync(makerId1, oneMinuteLater, chainId, takerToken, makerToken);\n            await cacheClient.addMakerToCooldownAsync(makerId2, oneMinuteLater, chainId, takerToken, makerToken);\n            const result = await cacheClient.getMakersInCooldownForPairAsync(chainId, takerToken, makerToken, now);\n            expect(result).to.deep.eq([makerId1, makerId2]);\n        });\n\n        it('should not include makers whose cooling down periods already ended', async () => {\n            const now = Date.now();\n            const oneMinuteEarlier = now - ONE_MINUTE_MS;\n            const oneMinuteLater = now + ONE_MINUTE_MS;\n            await cacheClient.addMakerToCooldownAsync(makerId1, oneMinuteEarlier, chainId, takerToken, makerToken);\n            await cacheClient.addMakerToCooldownAsync(makerId2, oneMinuteLater, chainId, takerToken, makerToken);\n            const result = await cacheClient.getMakersInCooldownForPairAsync(chainId, takerToken, makerToken, now);\n            expect(result).to.deep.eq([makerId2]);\n        });\n\n        it('should only include makers that are cooling down for this pair', async () => {\n            const now = Date.now();\n            const oneMinuteLater = now + ONE_MINUTE_MS;\n            await cacheClient.addMakerToCooldownAsync(makerId1, oneMinuteLater, chainId, takerToken, makerToken);\n            await cacheClient.addMakerToCooldownAsync(makerId2, oneMinuteLater, chainId, otherTakerToken, makerToken);\n            const result = await cacheClient.getMakersInCooldownForPairAsync(chainId, takerToken, makerToken, now);\n            expect(result).to.deep.eq([makerId1]);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/deployment.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/initDbDataSourceAsync.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/rfq_maker_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\n// tslint:disable:no-empty\n// tslint:disable:max-file-line-count\n\nimport { expect } from 'chai';\nimport { Server } from 'http';\nimport * as HttpStatus from 'http-status-codes';\nimport * as request from 'supertest';\nimport { anything, instance, mock, resetCalls, verify, when } from 'ts-mockito';\nimport { Connection } from 'typeorm';\n\nimport * as config from '../src/config';\nimport { RFQ_MAKER_API_KEY_HEADER, RFQ_MAKER_PATH } from '../src/core/constants';\nimport { RfqMaker } from '../src/entities';\nimport { runHttpRfqmServiceAsync } from '../src/runners/http_rfqm_service_runner';\nimport { RfqmService } from '../src/services/rfqm_service';\nimport { RfqAdminService } from '../src/services/rfq_admin_service';\nimport { RfqMakerService } from '../src/services/rfq_maker_service';\nimport { ConfigManager } from '../src/utils/config_manager';\n\ndescribe('RFQ maker API tests', () => {\n    const makerApiKey = '111222333';\n    const unknownMakerApiKey = '111222334';\n    const makerId = '11';\n    const chainId = 56;\n    const invalidChainId = 57;\n    const pairs: [string, string][] = [\n        ['0x374a16f5e686c09b0cc9e8bc3466b3b645c74aa7', '0xf84830b73b2ed3c7267e7638f500110ea47fdf30'],\n    ];\n    const invalidPairs: [string, string][] = [['0x374a16f5e686c09b0cc9e8bc3466b3b645c74aa7', '123']];\n    const rfqMaker = new RfqMaker({ makerId, chainId, updatedAt: null, pairs, rfqtUri: null, rfqmUri: null });\n\n    let app: Express.Application;\n    let server: Server;\n    let mockRfqMakerService: RfqMakerService;\n\n    beforeAll(async () => {\n        const connection = mock(Connection);\n        const configManagerMock = mock(ConfigManager);\n        const mockRfqmService = mock(RfqmService);\n        const mockRfqAdminService = mock(RfqAdminService);\n\n        mockRfqMakerService = mock(RfqMakerService);\n        when(mockRfqMakerService.mapMakerApiKeyToId(makerApiKey)).thenReturn(makerId);\n        when(mockRfqMakerService.getRfqMakerAsync(makerId, chainId)).thenResolve(rfqMaker);\n        when(\n            mockRfqMakerService.createOrUpdateRfqMakerAsync(makerId, chainId, anything(), anything(), anything()),\n        ).thenResolve(rfqMaker);\n\n        const mockRfqmServices = new Map<number, RfqmService>([[chainId, mockRfqmService]]);\n\n        // Start the server\n        const res = await runHttpRfqmServiceAsync(\n            mockRfqmServices,\n            new Map(),\n            mockRfqAdminService,\n            instance(mockRfqMakerService),\n            configManagerMock,\n            config.defaultHttpServiceConfig,\n            connection,\n            false,\n        );\n        app = res.app;\n        server = res.server;\n    });\n\n    beforeEach(() => {\n        resetCalls(mockRfqMakerService);\n    });\n\n    afterAll(async () => {\n        await new Promise<void>((resolve, reject) => {\n            server.close((err?: Error) => {\n                if (err) {\n                    reject(err);\n                }\n                resolve();\n            });\n        });\n    });\n\n    describe('GET /maker/v1/chain-id/:chainId', () => {\n        it('should return a 401 UNAUTHORIZED without maker api key', async () => {\n            const response = await request(app)\n                .get(`${RFQ_MAKER_PATH}/chain-id/${chainId}`)\n                .expect(HttpStatus.UNAUTHORIZED)\n                .expect('Content-Type', /json/);\n\n            expect(response.body.error).to.be.eq('Invalid api key.');\n            verify(mockRfqMakerService.mapMakerApiKeyToId(undefined)).once();\n            verify(mockRfqMakerService.getRfqMakerAsync(anything(), anything())).never();\n            verify(\n                mockRfqMakerService.createOrUpdateRfqMakerAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).never();\n        });\n\n        it('should return a 401 UNAUTHORIZED with an unknown maker api key', async () => {\n            const response = await request(app)\n                .get(`${RFQ_MAKER_PATH}/chain-id/${chainId}`)\n                .set(RFQ_MAKER_API_KEY_HEADER, unknownMakerApiKey)\n                .expect(HttpStatus.UNAUTHORIZED)\n                .expect('Content-Type', /json/);\n\n            expect(response.body.error).to.be.eq('Invalid api key.');\n            verify(mockRfqMakerService.mapMakerApiKeyToId(unknownMakerApiKey)).once();\n            verify(mockRfqMakerService.getRfqMakerAsync(anything(), anything())).never();\n            verify(\n                mockRfqMakerService.createOrUpdateRfqMakerAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).never();\n        });\n\n        it('should return a 400 BAD_REQUEST with an invalid chainId', async () => {\n            const response = await request(app)\n                .get(`${RFQ_MAKER_PATH}/chain-id/${invalidChainId}`)\n                .set(RFQ_MAKER_API_KEY_HEADER, makerApiKey)\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(response.body.error).to.be.eq('Invalid chainId.');\n            verify(mockRfqMakerService.mapMakerApiKeyToId(makerApiKey)).once();\n            verify(mockRfqMakerService.getRfqMakerAsync(anything(), anything())).never();\n            verify(\n                mockRfqMakerService.createOrUpdateRfqMakerAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).never();\n        });\n\n        it('should return a 200 OK with active pairs', async () => {\n            const response = await request(app)\n                .get(`${RFQ_MAKER_PATH}/chain-id/${chainId}`)\n                .set(RFQ_MAKER_API_KEY_HEADER, makerApiKey)\n                .expect(HttpStatus.OK)\n                .expect('Content-Type', /json/);\n\n            expect(response.body.makerId).to.be.eq(makerId);\n            expect(response.body.chainId).to.be.eq(chainId);\n            expect(response.body.pairs).to.deep.equal(pairs);\n            verify(mockRfqMakerService.mapMakerApiKeyToId(makerApiKey)).once();\n            verify(mockRfqMakerService.getRfqMakerAsync(makerId, chainId)).once();\n            verify(\n                mockRfqMakerService.createOrUpdateRfqMakerAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).never();\n        });\n    });\n\n    describe('PUT /maker/v1/chain-id/:chainId', () => {\n        it('should return a 401 UNAUTHORIZED without maker api key', async () => {\n            const response = await request(app)\n                .put(`${RFQ_MAKER_PATH}/chain-id/${chainId}`)\n                .send({ pairs, rfqtUri: null, rfqmUri: null })\n                .expect(HttpStatus.UNAUTHORIZED)\n                .expect('Content-Type', /json/);\n\n            expect(response.body.error).to.be.eq('Invalid api key.');\n            verify(mockRfqMakerService.mapMakerApiKeyToId(undefined)).once();\n            verify(mockRfqMakerService.getRfqMakerAsync(anything(), anything())).never();\n            verify(\n                mockRfqMakerService.createOrUpdateRfqMakerAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).never();\n        });\n\n        it('should return a 401 UNAUTHORIZED with an unknown maker api key', async () => {\n            const response = await request(app)\n                .put(`${RFQ_MAKER_PATH}/chain-id/${chainId}`)\n                .send({ pairs, rfqtUri: null, rfqmUri: null })\n                .set(RFQ_MAKER_API_KEY_HEADER, unknownMakerApiKey)\n                .expect(HttpStatus.UNAUTHORIZED)\n                .expect('Content-Type', /json/);\n\n            expect(response.body.error).to.be.eq('Invalid api key.');\n            verify(mockRfqMakerService.mapMakerApiKeyToId(unknownMakerApiKey)).once();\n            verify(mockRfqMakerService.getRfqMakerAsync(anything(), anything())).never();\n            verify(\n                mockRfqMakerService.createOrUpdateRfqMakerAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).never();\n        });\n\n        it('should return a 400 BAD_REQUEST with an invalid chainId', async () => {\n            const response = await request(app)\n                .put(`${RFQ_MAKER_PATH}/chain-id/${invalidChainId}`)\n                .send({ pairs, rfqtUri: null, rfqmUri: null })\n                .set(RFQ_MAKER_API_KEY_HEADER, makerApiKey)\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(response.body.error).to.be.eq('Invalid chainId.');\n            verify(mockRfqMakerService.mapMakerApiKeyToId(makerApiKey)).once();\n            verify(mockRfqMakerService.getRfqMakerAsync(anything(), anything())).never();\n            verify(\n                mockRfqMakerService.createOrUpdateRfqMakerAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).never();\n        });\n\n        it('should return a 400 BAD_REQUEST with an invalid pairs payload', async () => {\n            const response = await request(app)\n                .put(`${RFQ_MAKER_PATH}/chain-id/${chainId}`)\n                .send({ pairs: invalidPairs, rfqtUri: null, rfqmUri: null })\n                .set(RFQ_MAKER_API_KEY_HEADER, makerApiKey)\n                .expect(HttpStatus.BAD_REQUEST)\n                .expect('Content-Type', /json/);\n\n            expect(response.body.error).to.be.eq('address of second token for pair 0 is invalid.');\n            verify(mockRfqMakerService.mapMakerApiKeyToId(makerApiKey)).once();\n            verify(mockRfqMakerService.getRfqMakerAsync(anything(), anything())).never();\n            verify(\n                mockRfqMakerService.createOrUpdateRfqMakerAsync(\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                    anything(),\n                ),\n            ).never();\n        });\n\n        it('should return a 201 CREATED on a valid PUT', async () => {\n            const response = await request(app)\n                .put(`${RFQ_MAKER_PATH}/chain-id/${chainId}`)\n                .send({ pairs, rfqtUri: null, rfqmUri: null })\n                .set(RFQ_MAKER_API_KEY_HEADER, makerApiKey)\n                .expect(HttpStatus.CREATED)\n                .expect('Content-Type', /json/);\n\n            expect(response.body.makerId).to.be.eq(makerId);\n            expect(response.body.chainId).to.be.eq(chainId);\n            expect(response.body.pairs).to.deep.equal(pairs);\n            verify(mockRfqMakerService.mapMakerApiKeyToId(makerApiKey)).once();\n            verify(mockRfqMakerService.getRfqMakerAsync(anything(), anything())).never();\n            verify(\n                mockRfqMakerService.createOrUpdateRfqMakerAsync(makerId, chainId, anything(), anything(), anything()),\n            ).once();\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/runners/http_rfqm_service_runner.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_admin_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/getDbDataSourceAsync.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/root_handler.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/middleware/address_normalizer.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/middleware/error_handling.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/routers/rfqm_router.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/routers/RfqtRouter.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/routers/rfq_admin_router.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/routers/rfq_maker_router.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_service_builder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqtServiceBuilder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/runner_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/errors.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_comparison_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_report_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_health_check.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/handlers/dummy_mm_handler_test.ts",{"fileContent":"import { OtcOrder } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport * as express from 'express';\nimport * as asyncHandler from 'express-async-handler';\nimport * as HttpStatus from 'http-status-codes';\nimport * as supertest from 'supertest';\n\nimport { DummyMMHandlers } from '../../src/handlers/dummy_mm_handler';\nimport { getSignerFromHash } from '../../src/utils/signature_utils';\n\nconst POLYGON_CHAIN_ID = 137;\nconst USDC_POLYGON = '0x2791bca1f2de4661ed88a30c99a7a9449aa84174';\nconst USDT_POLYGON = '0xc2132d05d31c914a87c6611c10748aeb04b58e8f';\nconst MM_ADDRESS = '0x06754422cf9f54ae0e67d42fd788b33d8eb4c5d5';\nconst INTEGRATOR_ID = '74188355-c85b-4f18-9de4-6dec3ec61b8d';\nconst dummyMMHandler = new DummyMMHandlers();\nconst emptyOtcOrder = new OtcOrder();\nconst emptyOtcOrderParam = {\n    maker: emptyOtcOrder.maker,\n    taker: emptyOtcOrder.taker,\n    makerAmount: emptyOtcOrder.makerAmount.toString(),\n    takerAmount: emptyOtcOrder.takerAmount.toString(),\n    makerToken: emptyOtcOrder.makerToken,\n    takerToken: emptyOtcOrder.takerToken,\n    txOrigin: emptyOtcOrder.txOrigin,\n    expiryAndNonce: emptyOtcOrder.expiryAndNonce.toString(),\n    chainId: emptyOtcOrder.chainId.toString(),\n    verifyingContract: emptyOtcOrder.verifyingContract,\n};\nconst acceptedOtcOrder = new OtcOrder({\n    makerToken: USDC_POLYGON,\n    takerToken: USDT_POLYGON,\n    takerAmount: new BigNumber('200'),\n    chainId: POLYGON_CHAIN_ID,\n});\nconst acceptedOtcOrderParam = {\n    maker: acceptedOtcOrder.maker,\n    taker: acceptedOtcOrder.taker,\n    makerAmount: acceptedOtcOrder.makerAmount.toString(),\n    takerAmount: acceptedOtcOrder.takerAmount.toString(),\n    makerToken: acceptedOtcOrder.makerToken,\n    takerToken: acceptedOtcOrder.takerToken,\n    txOrigin: acceptedOtcOrder.txOrigin,\n    expiryAndNonce: acceptedOtcOrder.expiryAndNonce.toString(),\n    chainId: acceptedOtcOrder.chainId.toString(),\n    verifyingContract: acceptedOtcOrder.verifyingContract,\n};\nconst refusedOtcOrder = new OtcOrder({\n    makerToken: USDC_POLYGON,\n    takerToken: USDT_POLYGON,\n    takerAmount: new BigNumber('1000000'),\n    chainId: POLYGON_CHAIN_ID,\n});\nconst refusedOtcOrderParam = {\n    maker: refusedOtcOrder.maker,\n    taker: refusedOtcOrder.taker,\n    makerAmount: refusedOtcOrder.makerAmount.toString(),\n    takerAmount: refusedOtcOrder.takerAmount.toString(),\n    makerToken: refusedOtcOrder.makerToken,\n    takerToken: refusedOtcOrder.takerToken,\n    txOrigin: refusedOtcOrder.txOrigin,\n    expiryAndNonce: refusedOtcOrder.expiryAndNonce.toString(),\n    chainId: refusedOtcOrder.chainId.toString(),\n    verifyingContract: refusedOtcOrder.verifyingContract,\n};\n\ndescribe('DummyMMHandlers', () => {\n    describe('signRfqtV2Async', () => {\n        it('returns BAD_REQUEST when order hash does not match with order hash query param', async () => {\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/rfqt/v2/sign', asyncHandler(dummyMMHandler.signRfqtV2Async.bind(dummyMMHandler))),\n            )\n                .post('/rfqt/v2/sign')\n                .set('Content-type', 'application/json')\n                .send({\n                    order: emptyOtcOrderParam,\n                    orderHash: '0xrandom',\n                    feeAmount: '10',\n                    feeToken: '0xfee',\n                    expiry: '20',\n                });\n\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n\n        it('returns NO_CONTENT when tokens in the order are not part of provided liquity', async () => {\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/rfqt/v2/sign', asyncHandler(dummyMMHandler.signRfqtV2Async.bind(dummyMMHandler))),\n            )\n                .post('/rfqt/v2/sign')\n                .set('Content-type', 'application/json')\n                .send({\n                    order: emptyOtcOrderParam,\n                    orderHash: emptyOtcOrder.getHash(),\n                    feeAmount: '10',\n                    feeToken: '0xfee',\n                    expiry: '20',\n                });\n\n            expect(response.statusCode).toEqual(HttpStatus.NO_CONTENT);\n        });\n\n        it('returns NO_CONTENT when the market marker refuses to sign the order', async () => {\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/rfqt/v2/sign', asyncHandler(dummyMMHandler.signRfqtV2Async.bind(dummyMMHandler))),\n            )\n                .post('/rfqt/v2/sign')\n                .set('Content-type', 'application/json')\n                .send({\n                    order: refusedOtcOrderParam,\n                    orderHash: refusedOtcOrder.getHash(),\n                    feeAmount: '10',\n                    feeToken: '0xfee',\n                    expiry: '20',\n                });\n\n            expect(response.statusCode).toEqual(HttpStatus.NO_CONTENT);\n        });\n\n        it('returns OK when the market marker signs', async () => {\n            const response = await supertest(\n                express()\n                    .use(express.json())\n                    .post('/rfqt/v2/sign', asyncHandler(dummyMMHandler.signRfqtV2Async.bind(dummyMMHandler))),\n            )\n                .post('/rfqt/v2/sign')\n                .set('Content-type', 'application/json')\n                .send({\n                    order: acceptedOtcOrderParam,\n                    orderHash: acceptedOtcOrder.getHash(),\n                    feeAmount: '10',\n                    feeToken: '0xfee',\n                    expiry: '20',\n                });\n\n            expect(response.statusCode).toEqual(HttpStatus.OK);\n            const signer = getSignerFromHash(acceptedOtcOrder.getHash(), response.body.makerSignature);\n            expect(signer).toEqual(MM_ADDRESS);\n        });\n    });\n\n    describe('getQuoteRfqtV2Async', () => {\n        it('returns BAD_REQUEST when missing integrator id', async () => {\n            const response = await supertest(\n                express().get('/rfqt/v2/quote', asyncHandler(dummyMMHandler.getQuoteRfqtV2Async.bind(dummyMMHandler))),\n            )\n                .get('/rfqt/v2/quote')\n                .query({\n                    sellTokenAddress: USDC_POLYGON,\n                    buyTokenAddress: USDT_POLYGON,\n                    sellAmountBaseUnits: '200',\n                    txOrigin: '0x123456789',\n                    takerAddress: '0x123456789',\n                    feeToken: USDC_POLYGON,\n                    feeAmount: '10',\n                    chainId: POLYGON_CHAIN_ID.toString(),\n                });\n\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n\n        it('returns BAD_REQUEST when integrator id is not whitelisted', async () => {\n            const response = await supertest(\n                express().get('/rfqt/v2/quote', asyncHandler(dummyMMHandler.getQuoteRfqtV2Async.bind(dummyMMHandler))),\n            )\n                .get('/rfqt/v2/quote')\n                .set('0x-integrator-id', '0123')\n                .query({\n                    sellTokenAddress: USDC_POLYGON,\n                    buyTokenAddress: USDT_POLYGON,\n                    sellAmountBaseUnits: '200',\n                    txOrigin: '0x123456789',\n                    takerAddress: '0x123456789',\n                    feeToken: USDC_POLYGON,\n                    feeAmount: '10',\n                    chainId: POLYGON_CHAIN_ID.toString(),\n                    integratorId: '0123',\n                });\n\n            expect(response.statusCode).toEqual(HttpStatus.BAD_REQUEST);\n        });\n\n        it('returns NO_CONTENT when tokens in the order are not part of provided liquity', async () => {\n            const response = await supertest(\n                express().get('/rfqt/v2/quote', asyncHandler(dummyMMHandler.getQuoteRfqtV2Async.bind(dummyMMHandler))),\n            )\n                .get('/rfqt/v2/quote')\n                .set('0x-integrator-id', INTEGRATOR_ID)\n                .query({\n                    sellTokenAddress: '0x1234',\n                    buyTokenAddress: USDT_POLYGON,\n                    sellAmountBaseUnits: '200',\n                    txOrigin: '0x123456789',\n                    takerAddress: '0x123456789',\n                    feeToken: USDC_POLYGON,\n                    feeAmount: '10',\n                    chainId: POLYGON_CHAIN_ID.toString(),\n                    integratorId: INTEGRATOR_ID,\n                });\n\n            expect(response.statusCode).toEqual(HttpStatus.NO_CONTENT);\n        });\n\n        it('returns NO_CONTENT when buy/sell amount > 2', async () => {\n            const response = await supertest(\n                express().get('/rfqt/v2/quote', asyncHandler(dummyMMHandler.getQuoteRfqtV2Async.bind(dummyMMHandler))),\n            )\n                .get('/rfqt/v2/quote')\n                .set('0x-integrator-id', INTEGRATOR_ID)\n                .query({\n                    sellTokenAddress: USDC_POLYGON,\n                    buyTokenAddress: USDT_POLYGON,\n                    sellAmountBaseUnits: '20000000000',\n                    txOrigin: '0x123456789',\n                    takerAddress: '0x123456789',\n                    feeToken: USDC_POLYGON,\n                    feeAmount: '10',\n                    chainId: POLYGON_CHAIN_ID.toString(),\n                    integratorId: INTEGRATOR_ID,\n                });\n\n            expect(response.statusCode).toEqual(HttpStatus.NO_CONTENT);\n        });\n\n        it('returns NO_CONTENT when trading amount is considered odd', async () => {\n            const response = await supertest(\n                express().get('/rfqt/v2/quote', asyncHandler(dummyMMHandler.getQuoteRfqtV2Async.bind(dummyMMHandler))),\n            )\n                .get('/rfqt/v2/quote')\n                .set('0x-integrator-id', INTEGRATOR_ID)\n                .query({\n                    sellTokenAddress: USDC_POLYGON,\n                    buyTokenAddress: USDT_POLYGON,\n                    sellAmountBaseUnits: '1000000',\n                    txOrigin: '0x123456789',\n                    takerAddress: '0x123456789',\n                    feeToken: USDC_POLYGON,\n                    feeAmount: '10',\n                    chainId: POLYGON_CHAIN_ID.toString(),\n                    integratorId: INTEGRATOR_ID,\n                });\n\n            expect(response.statusCode).toEqual(HttpStatus.NO_CONTENT);\n        });\n\n        it('returns OK the market maker signs the order', async () => {\n            const response = await supertest(\n                express().get('/rfqt/v2/quote', asyncHandler(dummyMMHandler.getQuoteRfqtV2Async.bind(dummyMMHandler))),\n            )\n                .get('/rfqt/v2/quote')\n                .set('0x-integrator-id', INTEGRATOR_ID)\n                .query({\n                    sellTokenAddress: USDC_POLYGON,\n                    buyTokenAddress: USDT_POLYGON,\n                    sellAmountBaseUnits: '200',\n                    txOrigin: '0x123456789',\n                    takerAddress: '0x123456789',\n                    feeToken: USDC_POLYGON,\n                    feeAmount: '10',\n                    chainId: POLYGON_CHAIN_ID.toString(),\n                    integratorId: INTEGRATOR_ID,\n                });\n\n            expect(response.statusCode).toEqual(HttpStatus.OK);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/dummy_mm_handler.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_request_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/handlers/dummy_mm_handler.ts",{"fileContent":"// tslint:disable:max-file-line-count\n// tslint:disable: custom-no-magic-numbers\n// tslint:disable: prefer-function-over-method\nimport { getContractAddressesForChainOrThrow } from '@0x/contract-addresses';\nimport { ethSignHashWithKey, OtcOrder, RfqOrder, Signature } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { Wallet } from 'ethers';\nimport * as express from 'express';\nimport * as HttpStatus from 'http-status-codes';\n\nimport { ONE_MINUTE_MS, ONE_SECOND_MS } from '../core/constants';\nimport { Fee, QuoteServerPriceParams } from '../core/types';\nimport { SubmitRequest } from '../quote-server/types';\nimport { stringsToOtcOrderFields, stringsToSignature } from '../utils/rfqm_request_utils';\n\nconst WETH_ROPSTEN = '0xc778417e063141139fce010982780140aa0cd5ab';\nconst TTA_ROPSTEN = '0x374a16f5e686c09b0cc9e8bc3466b3b645c74aa7';\nconst TTB_ROPSTEN = '0xf84830b73b2ed3c7267e7638f500110ea47fdf30';\n\nconst WMATIC_POLYGON = '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270';\nconst DAI_POLYGON = '0x8f3cf7ad23cd3cadbd9735aff958023239c6a063';\nconst USDC_POLYGON = '0x2791bca1f2de4661ed88a30c99a7a9449aa84174';\nconst USDT_POLYGON = '0xc2132d05d31c914a87c6611c10748aeb04b58e8f';\n\nconst RFQ1_MUMBAI = '0xbea1bca733a6f58c363d9eccfc62a806fa1afee7';\nconst RFQ2_MUMBAI = '0x72115b83bb0dc128785f3a66ad7d2dc484852d0c';\nconst RFQ3_MUMBAI = '0xb0a53dd97d672486f35787d23dc285a621537f21';\n\nconst MM_PRIVATE_KEY =\n    process.env.MM_PRIVATE_KEY || '0xf0d8f376ca991256ddb256fb7cd28d68d971b07f5c0cf62cf0294c1ff8078a90';\nconst MM_ADDRESS = new Wallet(MM_PRIVATE_KEY).address;\n\nconst ROPSTEN_CHAIN_ID = 3;\nconst POLYGON_CHAIN_ID = 137;\nconst MUMBAI_CHAIN_ID = 80001;\n\nconst RFQT_NONCE_BUCKET = 0;\n\nconst tokenToDecimals: Record<string, number> = {\n    [WETH_ROPSTEN]: 18,\n    [TTA_ROPSTEN]: 18,\n    [TTB_ROPSTEN]: 18,\n    [WMATIC_POLYGON]: 18,\n    [DAI_POLYGON]: 18,\n    [USDC_POLYGON]: 6,\n    [USDT_POLYGON]: 6,\n    [RFQ1_MUMBAI]: 18,\n    [RFQ2_MUMBAI]: 18,\n    [RFQ3_MUMBAI]: 18,\n};\n\nconst whitelistedIntegrators = new Set([\n    '74188355-c85b-4f18-9de4-6dec3ec61b8d', // RH\n    '301e83b5-61f4-409b-bc61-8886dd56189d', // RH Testnets\n    '1c016c87-3128-4f78-b0f5-e90038d165ef', // 0x RFQ\n    '83b02232-83ca-4e1e-af5d-46c563d6688e', // RFQ Load Tester\n    '37f254d7-8fcf-4e97-ab6b-060364c0eaf5', // Simbot\n]);\n\n/**\n * This class implements handlers that are used to satisfy the MM Quote Server spec\n */\nexport class DummyMMHandlers {\n    private readonly _tokenSetByChainId: Map<number | undefined, Set<string>>;\n\n    private static _parseQuoteRequest(req: express.Request): QuoteServerPriceParams & { integratorId?: string } {\n        const {\n            sellTokenAddress,\n            buyTokenAddress,\n            takerAddress,\n            sellAmountBaseUnits,\n            buyAmountBaseUnits,\n            txOrigin,\n            isLastLook,\n            feeToken,\n            feeAmount,\n            feeType,\n            chainId,\n        } = req.query;\n\n        const integratorId = req.headers['0x-integrator-id'];\n\n        const isSelling = sellAmountBaseUnits !== undefined;\n\n        const BASE_REQUEST = {\n            sellTokenAddress: sellTokenAddress as string,\n            buyTokenAddress: buyTokenAddress as string,\n            takerAddress: takerAddress as string,\n            txOrigin: txOrigin as string,\n            isLastLook: isLastLook as string,\n            feeToken: feeToken as string,\n            feeAmount: feeAmount as string,\n            feeType: feeType as string,\n            chainId: chainId as string,\n            integratorId: integratorId as string,\n        };\n\n        if (isSelling) {\n            return {\n                ...BASE_REQUEST,\n                sellAmountBaseUnits: sellAmountBaseUnits as string,\n            };\n        } else {\n            return {\n                ...BASE_REQUEST,\n                buyAmountBaseUnits: buyAmountBaseUnits as string,\n            };\n        }\n    }\n\n    private static _parseSubmitRequest(\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        req: express.Request<{}, {}, Record<keyof SubmitRequest, string>>,\n    ): SubmitRequest {\n        const { order, orderHash, fee, takerTokenFillAmount } = req.body;\n\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const rawOrder = order as any;\n        const rfqOrder = new RfqOrder({\n            txOrigin: rawOrder.txOrigin,\n            expiry: new BigNumber(rawOrder.expiry),\n            pool: rawOrder.pool,\n            salt: new BigNumber(rawOrder.salt),\n            makerToken: rawOrder.makerToken,\n            takerToken: rawOrder.takerToken,\n            makerAmount: new BigNumber(rawOrder.makerAmount),\n            takerAmount: new BigNumber(rawOrder.takerAmount),\n            maker: rawOrder.maker,\n            taker: rawOrder.taker,\n            chainId: rawOrder.chainId,\n        });\n\n        return {\n            order: rfqOrder,\n            orderHash,\n            fee: fee as unknown as Fee,\n            takerTokenFillAmount: new BigNumber(takerTokenFillAmount),\n        };\n    }\n\n    /**\n     * Parse RFQm sign request.\n     * @param req Incoming sign request.\n     * @returns Parsed RFQm sign request object.\n     */\n    private static _parseSignRfqmRequest(req: express.Request): {\n        feeAmount: string;\n        feeToken: string;\n        order: OtcOrder;\n        orderHash: string;\n        expiry: BigNumber;\n        takerSignature: Signature;\n    } {\n        const {\n            order: orderRaw,\n            orderHash,\n            feeAmount: feeAmountRaw,\n            feeToken: feeTokenRaw,\n            expiry: expiryRaw,\n            takerSignature: takerSignatureRaw,\n        } = req.body;\n\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const order = new OtcOrder(stringsToOtcOrderFields(orderRaw as any));\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const takerSignature = stringsToSignature(takerSignatureRaw as any);\n        const expiry = new BigNumber(expiryRaw as string);\n\n        return {\n            order,\n            orderHash: orderHash as string,\n            feeAmount: feeAmountRaw as string,\n            feeToken: feeTokenRaw as string,\n            takerSignature,\n            expiry,\n        };\n    }\n\n    /**\n     * Parse RFQt sign request.\n     * @param req Incoming sign request.\n     * @returns Parsed RFQt sign request object.\n     */\n    private static _parseSignRfqtRequest(req: express.Request): {\n        feeAmount: string;\n        feeToken: string;\n        order: OtcOrder;\n        orderHash: string;\n        expiry: BigNumber;\n    } {\n        const {\n            order: orderRaw,\n            orderHash,\n            feeAmount: feeAmountRaw,\n            feeToken: feeTokenRaw,\n            expiry: expiryRaw,\n        } = req.body;\n\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const order = new OtcOrder(stringsToOtcOrderFields(orderRaw as any));\n        const expiry = new BigNumber(expiryRaw as string);\n\n        return {\n            order,\n            orderHash: orderHash as string,\n            feeAmount: feeAmountRaw as string,\n            feeToken: feeTokenRaw as string,\n            expiry,\n        };\n    }\n\n    constructor() {\n        this._tokenSetByChainId = new Map<number | undefined, Set<string>>();\n        this._tokenSetByChainId.set(\n            ROPSTEN_CHAIN_ID,\n            new Set([WETH_ROPSTEN.toLocaleLowerCase(), TTA_ROPSTEN.toLowerCase(), TTB_ROPSTEN.toLowerCase()]),\n        );\n        this._tokenSetByChainId.set(\n            POLYGON_CHAIN_ID,\n            new Set([\n                USDC_POLYGON.toLowerCase(),\n                USDT_POLYGON.toLowerCase(),\n                WMATIC_POLYGON.toLowerCase(),\n                DAI_POLYGON.toLowerCase(),\n            ]),\n        );\n        this._tokenSetByChainId.set(\n            MUMBAI_CHAIN_ID,\n            new Set([RFQ1_MUMBAI.toLowerCase(), RFQ2_MUMBAI.toLowerCase(), RFQ3_MUMBAI.toLowerCase()]),\n        );\n    }\n\n    /**\n     * Simple pricing that always returns 1:1 v1 prices\n     */\n    public async getPriceV1Async(req: express.Request, res: express.Response): Promise<void> {\n        const params = DummyMMHandlers._parseQuoteRequest(req);\n        const tokenSet = this._tokenSetByChainId.get(Number(params.chainId));\n        const { sellTokenAddress, buyTokenAddress, sellAmountBaseUnits, buyAmountBaseUnits, integratorId } = params;\n\n        // Check integrator\n        if (!integratorId || !whitelistedIntegrators.has(integratorId)) {\n            res.status(HttpStatus.BAD_REQUEST).send('Invalid integrator id');\n            return;\n        }\n\n        // Check tokens\n        if (\n            !tokenSet ||\n            !tokenSet.has(sellTokenAddress.toLowerCase()) ||\n            !tokenSet.has(buyTokenAddress.toLowerCase())\n        ) {\n            res.status(HttpStatus.NO_CONTENT).send({});\n            return;\n        }\n\n        // Get amount (direction doesn't matter because price is always 1:1)\n        const isSelling = sellAmountBaseUnits !== undefined;\n        const rawAmount = (isSelling ? sellAmountBaseUnits : buyAmountBaseUnits) as string;\n        const amount = new BigNumber(rawAmount);\n\n        // Tokens\n        const takerToken = sellTokenAddress as string;\n        const makerToken = buyTokenAddress as string;\n\n        // Expiry\n        const now = new BigNumber(Date.now());\n        const fiveMinLater = now.plus(new BigNumber(5).times(ONE_MINUTE_MS)).div(ONE_SECOND_MS).integerValue();\n\n        const indicativeQuote = {\n            expiry: fiveMinLater.toString(),\n            makerToken,\n            takerToken,\n            makerAmount: amount.toString(),\n            takerAmount: amount.toString(),\n        };\n        res.status(HttpStatus.OK).send(indicativeQuote);\n        return;\n    }\n\n    /**\n     * Simple pricing that always returns 1:1 v2 prices\n     */\n    public async getPriceV2Async(req: express.Request, res: express.Response): Promise<void> {\n        const params = DummyMMHandlers._parseQuoteRequest(req);\n        const tokenSet = this._tokenSetByChainId.get(Number(params.chainId));\n        const { sellTokenAddress, buyTokenAddress, sellAmountBaseUnits, buyAmountBaseUnits, integratorId } = params;\n\n        // Check integrator\n        if (!integratorId || !whitelistedIntegrators.has(integratorId)) {\n            res.status(HttpStatus.BAD_REQUEST).send('Invalid integrator id');\n            return;\n        }\n\n        // Check tokens\n        if (\n            !tokenSet ||\n            !tokenSet.has(sellTokenAddress.toLowerCase()) ||\n            !tokenSet.has(buyTokenAddress.toLowerCase())\n        ) {\n            res.status(HttpStatus.NO_CONTENT).send({});\n            return;\n        }\n\n        // Get amount (direction doesn't matter because price is always 1:1)\n        const isSelling = sellAmountBaseUnits !== undefined;\n        const rawAmount = (isSelling ? sellAmountBaseUnits : buyAmountBaseUnits) as string;\n        const amount = new BigNumber(rawAmount);\n\n        // Tokens\n        const takerToken = sellTokenAddress as string;\n        const makerToken = buyTokenAddress as string;\n\n        // Expiry\n        const now = new BigNumber(Date.now());\n        const fiveMinLater = now.plus(new BigNumber(5).times(ONE_MINUTE_MS)).div(ONE_SECOND_MS).integerValue();\n\n        const indicativeQuote = {\n            expiry: fiveMinLater.toString(),\n            makerToken,\n            takerToken,\n            makerAmount: amount.toString(),\n            takerAmount: amount.toString(),\n            maker: MM_ADDRESS,\n        };\n        res.status(HttpStatus.OK).send(indicativeQuote);\n        return;\n    }\n\n    /**\n     * Simple quoting that always signs an order 1:1 for RFQM v1\n     */\n    public async getQuoteV1Async(req: express.Request, res: express.Response): Promise<void> {\n        const params = DummyMMHandlers._parseQuoteRequest(req);\n        const tokenSet = this._tokenSetByChainId.get(Number(params.chainId));\n        const {\n            sellTokenAddress,\n            buyTokenAddress,\n            sellAmountBaseUnits,\n            buyAmountBaseUnits,\n            txOrigin,\n            takerAddress,\n            integratorId,\n        } = params;\n\n        // Check integrator\n        if (!integratorId || !whitelistedIntegrators.has(integratorId)) {\n            res.status(HttpStatus.BAD_REQUEST).send('Invalid integrator id');\n            return;\n        }\n\n        // Check tokens\n        if (\n            !tokenSet ||\n            !tokenSet.has(sellTokenAddress.toLowerCase()) ||\n            !tokenSet.has(buyTokenAddress.toLowerCase())\n        ) {\n            res.status(HttpStatus.NO_CONTENT).send({});\n            return;\n        }\n\n        // Get amount (direction doesn't matter because price is always 1:1)\n        const isSelling = sellAmountBaseUnits !== undefined;\n        const rawAmount = (isSelling ? sellAmountBaseUnits : buyAmountBaseUnits) as string;\n        const amount = new BigNumber(rawAmount);\n\n        // Tokens\n        const takerToken = sellTokenAddress as string;\n        const makerToken = buyTokenAddress as string;\n\n        // Enforce a 5 unit maximum\n        const oneUnit = 10 ** tokenToDecimals[takerToken];\n        const fiveUnits = oneUnit * 5;\n        if (amount.gt(fiveUnits)) {\n            res.status(HttpStatus.NO_CONTENT).send({});\n            return;\n        }\n\n        // Expiry\n        const now = new BigNumber(Date.now());\n        const fiveMinLater = now.plus(new BigNumber(5).times(ONE_MINUTE_MS)).div(ONE_SECOND_MS).integerValue();\n\n        const rfqOrder = new RfqOrder({\n            txOrigin,\n            taker: takerAddress,\n            maker: MM_ADDRESS,\n            takerToken,\n            makerToken,\n            makerAmount: new BigNumber(amount.toString()),\n            takerAmount: new BigNumber(amount.toString()),\n            expiry: fiveMinLater,\n            chainId: Number(params.chainId),\n            salt: now,\n        });\n\n        const orderHash = rfqOrder.getHash();\n        const signature = ethSignHashWithKey(orderHash, MM_PRIVATE_KEY);\n\n        const firmQuote = {\n            signedOrder: {\n                ...rfqOrder,\n                signature,\n            },\n        };\n        res.status(HttpStatus.OK).send(firmQuote);\n        return;\n    }\n\n    /**\n     * Simple quoting for RFQt v2 that signs even taker amounts, but refuses to sign odd taker amounts, ignoring decimals.\n     * The max trading size is 2 tokens.\n     *\n     * Example for WETH:\n     * - 1.000_000_000_000_000_000 is considered odd!\n     * - 2.000_000_000_000_000_001 is considered even!\n     */\n    public async getQuoteRfqtV2Async(req: express.Request, res: express.Response): Promise<void> {\n        const params = DummyMMHandlers._parseQuoteRequest(req);\n        const chainId = Number(params.chainId);\n        const tokenSet = this._tokenSetByChainId.get(chainId);\n        const {\n            sellTokenAddress,\n            buyTokenAddress,\n            sellAmountBaseUnits,\n            buyAmountBaseUnits,\n            txOrigin,\n            takerAddress,\n            integratorId,\n            feeAmount,\n        } = params;\n\n        // Check integrator\n        if (!integratorId || !whitelistedIntegrators.has(integratorId)) {\n            res.status(HttpStatus.BAD_REQUEST).send('Invalid integrator id');\n            return;\n        }\n\n        // Check tokens\n        if (\n            !tokenSet ||\n            !tokenSet.has(sellTokenAddress.toLowerCase()) ||\n            !tokenSet.has(buyTokenAddress.toLowerCase())\n        ) {\n            res.status(HttpStatus.NO_CONTENT).send(`No liquidity for ${sellTokenAddress}:${buyTokenAddress}`);\n            return;\n        }\n\n        // Get amount (direction doesn't matter because price is always 1:1)\n        const isSelling = sellAmountBaseUnits !== undefined;\n        const rawAmount = (isSelling ? sellAmountBaseUnits : buyAmountBaseUnits) as string;\n        const amount = new BigNumber(rawAmount);\n\n        // Tokens\n        const takerToken = sellTokenAddress as string;\n        const makerToken = buyTokenAddress as string;\n\n        const decimals = tokenToDecimals[takerToken];\n        // Enforce a 2 units maximum for trading\n        const oneUnit = 10 ** decimals;\n        if (amount.gt(oneUnit * 2)) {\n            res.status(HttpStatus.NO_CONTENT).send('Trading limit for buy/sell tokens should not exceed 2');\n            return;\n        }\n\n        const isEven = amount\n            .div(10 ** decimals)\n            .integerValue()\n            .mod(2)\n            .eq(0);\n\n        // Reject\n        if (!isEven) {\n            res.status(HttpStatus.NO_CONTENT).send({});\n            return;\n        }\n\n        // Expiry and nonce\n        const now = new BigNumber(Date.now());\n        const expiry = now.plus(new BigNumber(5).times(ONE_MINUTE_MS)).div(ONE_SECOND_MS).integerValue();\n        const nowSeconds = Math.floor(Date.now() / ONE_SECOND_MS);\n\n        // Get Exchange Proxy contract address\n        const exchangeProxyContractAddress: string = getContractAddressesForChainOrThrow(chainId).exchangeProxy;\n\n        const otcOrder = new OtcOrder({\n            txOrigin,\n            expiryAndNonce: OtcOrder.encodeExpiryAndNonce(\n                expiry,\n                new BigNumber(RFQT_NONCE_BUCKET),\n                new BigNumber(nowSeconds),\n            ),\n            takerToken,\n            makerToken,\n            makerAmount: amount,\n            takerAmount: amount,\n            maker: MM_ADDRESS,\n            taker: takerAddress,\n            chainId,\n            verifyingContract: exchangeProxyContractAddress,\n        });\n\n        const orderHash = otcOrder.getHash();\n        const signature = ethSignHashWithKey(orderHash, MM_PRIVATE_KEY);\n        const response = {\n            feeAmount,\n            order: otcOrder,\n            orderHash,\n            makerSignature: signature,\n        };\n\n        res.status(HttpStatus.OK).send(response);\n    }\n\n    /**\n     * Approves even amounts and rejects odd amounts, ignoring decimals\n     *\n     * Example for WETH:\n     * - 1.000_000_000_000_000_000 is considered odd!\n     * - 2.000_000_000_000_000_001 is considered even!\n     */\n    public async submitAsync(req: express.Request, res: express.Response): Promise<void> {\n        const requestParams = DummyMMHandlers._parseSubmitRequest(req);\n        const { order, fee, orderHash, takerTokenFillAmount } = requestParams;\n        const decimals = tokenToDecimals[order.takerToken];\n\n        const isEven = order.takerAmount\n            .div(10 ** decimals)\n            .integerValue()\n            .mod(2)\n            .eq(0);\n        const response = {\n            fee,\n            proceedWithFill: isEven,\n            signedOrderHash: orderHash,\n            takerTokenFillAmount: takerTokenFillAmount.toString(),\n        };\n\n        res.status(HttpStatus.OK).send(response);\n    }\n\n    /**\n     * Approves even amounts and rejects odd amounts, ignoring decimals\n     *\n     * Example for WETH:\n     * - 1.000_000_000_000_000_000 is considered odd!\n     * - 2.000_000_000_000_000_001 is considered even!\n     */\n    public async signRfqmV2Async(req: express.Request, res: express.Response): Promise<void> {\n        const requestParams = DummyMMHandlers._parseSignRfqmRequest(req);\n        const { order, feeAmount, orderHash } = requestParams;\n        const decimals = tokenToDecimals[order.takerToken];\n\n        const isEven = order.takerAmount\n            .div(10 ** decimals)\n            .integerValue()\n            .mod(2)\n            .eq(0);\n\n        // Reject\n        if (!isEven) {\n            res.status(HttpStatus.OK).send({\n                proceedWithFill: false,\n            });\n            return;\n        }\n\n        // Accept and sign\n        const signature = ethSignHashWithKey(orderHash, MM_PRIVATE_KEY);\n        const response = {\n            feeAmount,\n            proceedWithFill: isEven,\n            makerSignature: signature,\n        };\n\n        res.status(HttpStatus.OK).send(response);\n    }\n\n    /**\n     * Signs for even taker amounts, but refuses odd taker amounts, ignoring decimals. The logic is very similar to\n     * `signRfqmV2Async` for consistency.\n     *\n     * Example for WETH:\n     * - 1.000_000_000_000_000_000 is considered odd!\n     * - 2.000_000_000_000_000_001 is considered even!\n     */\n    public async signRfqtV2Async(req: express.Request, res: express.Response): Promise<void> {\n        const requestParams = DummyMMHandlers._parseSignRfqtRequest(req);\n        const { order, feeAmount, orderHash: orderHashParam } = requestParams;\n        const orderHash = order.getHash();\n        const tokenSet = this._tokenSetByChainId.get(Number(requestParams.order.chainId));\n\n        // Check order hash computed from order is the same as order hash in query param\n        if (orderHash !== orderHashParam) {\n            res.status(HttpStatus.BAD_REQUEST).send(\n                `orderHash query param provided ${orderHashParam} is not equal to the actual order hash ${orderHash}`,\n            );\n            return;\n        }\n\n        // Check tokens\n        if (\n            !tokenSet ||\n            !tokenSet.has(order.makerToken.toLowerCase()) ||\n            !tokenSet.has(order.takerToken.toLowerCase())\n        ) {\n            res.status(HttpStatus.NO_CONTENT).send(`No liquidity for ${order.makerToken}:${order.takerToken}`);\n            return;\n        }\n\n        const decimals = tokenToDecimals[order.takerToken];\n        const isEven = order.takerAmount\n            .div(10 ** decimals)\n            .integerValue()\n            .mod(2)\n            .eq(0);\n\n        // Reject\n        if (!isEven) {\n            res.status(HttpStatus.NO_CONTENT).send({});\n            return;\n        }\n\n        // Refuse to sign\n        const signature = ethSignHashWithKey(orderHash, MM_PRIVATE_KEY);\n        const response = {\n            feeAmount,\n            makerSignature: signature,\n        };\n\n        res.status(HttpStatus.OK).send(response);\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_request_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/services/rfq_maker_balance_cache_service_test.ts",{"fileContent":"import { ChainId } from '@0x/contract-addresses';\nimport { BigNumber } from '@0x/utils';\nimport { expect } from 'chai';\nimport { anything, instance, mock, verify, when } from 'ts-mockito';\n\nimport { RfqMakerBalanceCacheService } from '../../src/services/rfq_maker_balance_cache_service';\nimport { ERC20Owner } from '../../src/core/types';\nimport { CacheClient } from '../../src/utils/cache_client';\nimport { RfqBalanceCheckUtils } from '../../src/utils/rfq_blockchain_utils';\n\ndescribe('RfqMakerBalanceCacheService', () => {\n    const chainId = ChainId.Ganache;\n\n    const makerA = '0x1111111111111111111111111111111111111111';\n    const makerB = '0x2222222222222222222222222222222222222222';\n    const makerC = '0x3333333333333333333333333333333333333333';\n\n    const tokenA = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';\n    const tokenB = '0x6B175474E89094C44Da98b954EedeAC495271d0F';\n    const tokenC = '0xdAC17F958D2ee523a2206206994597C13D831ec7';\n\n    describe('getERC20OwnerBalancesAsync', () => {\n        it('should get maker balances from the cache', async () => {\n            const addresses = [\n                { owner: makerA, token: tokenA },\n                { owner: makerB, token: tokenB },\n                { owner: makerC, token: tokenC },\n            ];\n\n            const cacheClientMock = mock(CacheClient);\n            when(cacheClientMock.getERC20OwnerBalancesAsync(chainId, addresses)).thenResolve([\n                new BigNumber(1),\n                new BigNumber(2),\n                new BigNumber(3),\n            ]);\n            const balanceCheckUtilsMock = mock(RfqBalanceCheckUtils);\n            const makerBalanceCacheService = new RfqMakerBalanceCacheService(\n                instance(cacheClientMock),\n                instance(balanceCheckUtilsMock),\n            );\n\n            expect(await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, addresses)).to.deep.eq([\n                new BigNumber(1),\n                new BigNumber(2),\n                new BigNumber(3),\n            ]);\n            verify(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(anything())).never();\n        });\n\n        it('should fetch balances through balance check for addresses not found in the cache', async () => {\n            const addresses = [\n                { owner: makerA, token: tokenA },\n                { owner: makerB, token: tokenB },\n                { owner: makerC, token: tokenC },\n            ];\n\n            const cacheClientMock = mock(CacheClient);\n            when(cacheClientMock.getERC20OwnerBalancesAsync(chainId, addresses)).thenResolve([\n                null,\n                new BigNumber(2),\n                null,\n            ]);\n            when(cacheClientMock.addERC20OwnerAsync(chainId, anything())).thenResolve();\n            const balanceCheckUtilsMock = mock(RfqBalanceCheckUtils);\n            when(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([\n                new BigNumber(1),\n                new BigNumber(3),\n            ]);\n            const makerBalanceCacheService = new RfqMakerBalanceCacheService(\n                instance(cacheClientMock),\n                instance(balanceCheckUtilsMock),\n            );\n\n            expect(await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, addresses)).to.deep.eq([\n                new BigNumber(1),\n                new BigNumber(2),\n                new BigNumber(3),\n            ]);\n            verify(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(anything())).once();\n        });\n\n        it('should get zero addresses if balance check returns malformed results', async () => {\n            const addresses = [\n                { owner: makerA, token: tokenA },\n                { owner: makerB, token: tokenB },\n                { owner: makerC, token: tokenC },\n            ];\n\n            const cacheClientMock = mock(CacheClient);\n            when(cacheClientMock.getERC20OwnerBalancesAsync(chainId, addresses)).thenResolve([\n                null,\n                new BigNumber(2),\n                null,\n            ]);\n            when(cacheClientMock.addERC20OwnerAsync(chainId, anything())).thenResolve();\n            const balanceCheckUtilsMock = mock(RfqBalanceCheckUtils);\n            when(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(anything())).thenResolve([]);\n            const makerBalanceCacheService = new RfqMakerBalanceCacheService(\n                instance(cacheClientMock),\n                instance(balanceCheckUtilsMock),\n            );\n\n            expect(await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, addresses)).to.deep.eq([\n                new BigNumber(0),\n                new BigNumber(2),\n                new BigNumber(0),\n            ]);\n            verify(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(anything())).once();\n        });\n\n        it('should throw an error if reading entries from the cache fails', async () => {\n            const addresses = [\n                { owner: makerA, token: tokenA },\n                { owner: makerB, token: tokenB },\n                { owner: makerC, token: '0xbadaddress' },\n            ];\n\n            const cacheClientMock = mock(CacheClient);\n            when(cacheClientMock.getERC20OwnerBalancesAsync(anything(), addresses)).thenReject(\n                new Error('Failed to read entries from maker balance cache'),\n            );\n            const balanceCheckUtilsMock = mock(RfqBalanceCheckUtils);\n            const makerBalanceCacheService = new RfqMakerBalanceCacheService(\n                instance(cacheClientMock),\n                instance(balanceCheckUtilsMock),\n            );\n\n            try {\n                await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, addresses);\n                expect.fail();\n            } catch (error) {\n                expect(error.message).to.contain('maker balance cache');\n                verify(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(anything())).never();\n            }\n        });\n\n        it('should get empty array when addresses are empty', async () => {\n            const emptyAddresses: ERC20Owner[] = [];\n\n            const cacheClientMock = mock(CacheClient);\n            when(cacheClientMock.getERC20OwnerBalancesAsync(chainId, emptyAddresses)).thenResolve([]);\n            const balanceCheckUtilsMock = mock(RfqBalanceCheckUtils);\n            const makerBalanceCacheService = new RfqMakerBalanceCacheService(\n                instance(cacheClientMock),\n                instance(balanceCheckUtilsMock),\n            );\n\n            expect(await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, emptyAddresses)).to.deep.eq([]);\n            verify(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(anything())).never();\n        });\n    });\n\n    describe('updateERC20OwnerBalancesAsync', () => {\n        it('should update the cache with given maker balances', async () => {\n            const addresses = [\n                { owner: makerA, token: tokenA },\n                { owner: makerB, token: tokenB },\n                { owner: makerC, token: tokenC },\n            ];\n            const cacheClientMock = mock(CacheClient);\n            when(cacheClientMock.getERC20OwnersAsync(chainId)).thenResolve(addresses);\n            when(cacheClientMock.setERC20OwnerBalancesAsync(chainId, addresses, anything())).thenResolve();\n            const balanceCheckUtilsMock = mock(RfqBalanceCheckUtils);\n            when(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(addresses)).thenResolve([\n                new BigNumber(1),\n                new BigNumber(2),\n                new BigNumber(3),\n            ]);\n            const makerBalanceCacheService = new RfqMakerBalanceCacheService(\n                instance(cacheClientMock),\n                instance(balanceCheckUtilsMock),\n            );\n\n            try {\n                await makerBalanceCacheService.updateERC20OwnerBalancesAsync(chainId);\n                verify(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(anything())).once();\n            } catch (error) {\n                expect.fail();\n            }\n        });\n    });\n\n    it('should throw an error if writing entries to the cache fails', async () => {\n        const addresses = [\n            { owner: makerA, token: tokenA },\n            { owner: makerB, token: tokenB },\n            { owner: makerC, token: tokenC },\n        ];\n        const cacheClientMock = mock(CacheClient);\n        when(cacheClientMock.getERC20OwnersAsync(chainId)).thenResolve(addresses);\n        when(cacheClientMock.setERC20OwnerBalancesAsync(chainId, addresses, anything())).thenReject(\n            new Error('Failed to update entries for maker balance cache'),\n        );\n        const balanceCheckUtilsMock = mock(RfqBalanceCheckUtils);\n        when(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(addresses)).thenResolve([\n            new BigNumber(1),\n            new BigNumber(2),\n            new BigNumber(3),\n        ]);\n        const makerBalanceCacheService = new RfqMakerBalanceCacheService(\n            instance(cacheClientMock),\n            instance(balanceCheckUtilsMock),\n        );\n\n        try {\n            await makerBalanceCacheService.updateERC20OwnerBalancesAsync(chainId);\n            expect.fail();\n        } catch (error) {\n            expect(error.message).to.contain('maker balance cache');\n            verify(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(anything())).once();\n        }\n    });\n\n    describe('evictZeroBalancesAsync', () => {\n        it('should evict entries from the cache', async () => {\n            const cacheClientMock = mock(CacheClient);\n            when(cacheClientMock.evictZeroBalancesAsync(chainId)).thenResolve(1);\n            const balanceCheckUtilsMock = mock(RfqBalanceCheckUtils);\n            const makerBalanceCacheService = new RfqMakerBalanceCacheService(\n                instance(cacheClientMock),\n                instance(balanceCheckUtilsMock),\n            );\n\n            try {\n                const numEvicted = await makerBalanceCacheService.evictZeroBalancesAsync(chainId);\n                expect(numEvicted).to.eq(1);\n                verify(cacheClientMock.evictZeroBalancesAsync(chainId)).once();\n            } catch (error) {\n                expect.fail();\n            }\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/sqs_consumer_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\n// tslint:disable:no-empty\n// tslint:disable:max-file-line-count\n\nimport { expect } from 'chai';\nimport { anyString, anything, instance, mock, verify, when } from 'ts-mockito';\n\nimport { SqsClient } from '../../src/utils/sqs_client';\nimport { SqsConsumer, SqsRetryableError } from '../../src/utils/sqs_consumer';\n\ndescribe('SqsConsumer', () => {\n    describe('consumeOnceAsync', () => {\n        describe('beforeHandle', () => {\n            it('should not call handleMessage if beforeHandle returns false', async () => {\n                // Given\n                const sqsClientMock = mock(SqsClient);\n                let isHandleCalled = false;\n                const beforeHandle = async () => false;\n                const handleMessage = async () => {\n                    isHandleCalled = true;\n                };\n\n                const consumer = new SqsConsumer({\n                    workerIndex: 0,\n                    workerAddress: 'id',\n                    sqsClient: sqsClientMock,\n                    handleMessage,\n                    beforeHandle,\n                });\n\n                // When\n                await consumer.consumeOnceAsync();\n\n                // Then\n                expect(isHandleCalled).to.equal(false);\n            });\n\n            it('should not call handleMessage if beforeHandle throws an error', async () => {\n                // Given\n                const sqsClientMock = mock(SqsClient);\n                let isHandleCalled = false;\n                const beforeHandle = async () => Promise.reject('error!');\n                const handleMessage = async () => {\n                    isHandleCalled = true;\n                };\n\n                const consumer = new SqsConsumer({\n                    workerIndex: 0,\n                    workerAddress: 'id',\n                    sqsClient: sqsClientMock,\n                    handleMessage,\n                    beforeHandle,\n                });\n\n                // When\n                await consumer.consumeOnceAsync();\n\n                // Then\n                expect(isHandleCalled).to.equal(false);\n            });\n\n            it('should call handleMessage if no beforeHandle', async () => {\n                // Given\n                const sqsClientMock = mock(SqsClient);\n                when(sqsClientMock.receiveMessageAsync()).thenResolve({\n                    Body: '0xdeadbeef',\n                });\n                const sqsClientInstance = instance(sqsClientMock);\n                let isHandleCalled = false;\n                const handleMessage = async () => {\n                    isHandleCalled = true;\n                };\n\n                const consumer = new SqsConsumer({\n                    workerIndex: 0,\n                    workerAddress: 'id',\n                    sqsClient: sqsClientInstance,\n                    handleMessage,\n                });\n\n                // When\n                await consumer.consumeOnceAsync();\n\n                // Then\n                expect(isHandleCalled).to.equal(true);\n            });\n\n            it('should call handleMessage if beforeHandle returns true', async () => {\n                // Given\n                const sqsClientMock = mock(SqsClient);\n                when(sqsClientMock.receiveMessageAsync()).thenResolve({\n                    Body: '0xdeadbeef',\n                });\n                const sqsClientInstance = instance(sqsClientMock);\n                const beforeHandle = async () => true;\n                let isHandleCalled = false;\n                const handleMessage = async () => {\n                    isHandleCalled = true;\n                };\n\n                const consumer = new SqsConsumer({\n                    workerIndex: 0,\n                    workerAddress: 'id',\n                    sqsClient: sqsClientInstance,\n                    beforeHandle,\n                    handleMessage,\n                });\n\n                // When\n                await consumer.consumeOnceAsync();\n\n                // Then\n                expect(isHandleCalled).to.equal(true);\n            });\n        });\n\n        describe('handleMessage', () => {\n            it('should not be called if no message is recieved', async () => {\n                // Given\n                const sqsClientMock = mock(SqsClient);\n                when(sqsClientMock.receiveMessageAsync()).thenResolve(null);\n                const sqsClientInstance = instance(sqsClientMock);\n\n                let isHandleCalled = false;\n                const handleMessage = async () => {\n                    isHandleCalled = true;\n                };\n\n                const consumer = new SqsConsumer({\n                    workerIndex: 0,\n                    workerAddress: 'id',\n                    sqsClient: sqsClientInstance,\n                    handleMessage,\n                });\n\n                // When\n                await consumer.consumeOnceAsync();\n\n                // Then\n                expect(isHandleCalled).to.equal(false);\n            });\n\n            it('should call changeMessageVisibility if a SqsRetryableError is encountered (triggers a retry)', async () => {\n                // Given\n                const sqsClientMock = mock(SqsClient);\n                when(sqsClientMock.receiveMessageAsync()).thenResolve({\n                    Body: '0xdeadbeef',\n                    ReceiptHandle: '1',\n                });\n                const sqsClientInstance = instance(sqsClientMock);\n\n                const handleMessage = async () => {\n                    throw new SqsRetryableError('error');\n                };\n\n                const consumer = new SqsConsumer({\n                    workerIndex: 0,\n                    workerAddress: 'id',\n                    sqsClient: sqsClientInstance,\n                    handleMessage,\n                });\n\n                // When\n                await consumer.consumeOnceAsync();\n\n                // Then\n                verify(sqsClientMock.changeMessageVisibilityAsync(anyString(), 0)).once();\n            });\n\n            it('should not call changeMessageVisibility if a non SqsRetryableError is encountered', async () => {\n                // Given\n                const sqsClientMock = mock(SqsClient);\n                when(sqsClientMock.receiveMessageAsync()).thenResolve({\n                    Body: '0xdeadbeef',\n                    ReceiptHandle: '1',\n                });\n                const sqsClientInstance = instance(sqsClientMock);\n\n                const handleMessage = async () => {\n                    throw new Error('error');\n                };\n\n                const consumer = new SqsConsumer({\n                    workerIndex: 0,\n                    workerAddress: 'id',\n                    sqsClient: sqsClientInstance,\n                    handleMessage,\n                });\n\n                // When\n                await consumer.consumeOnceAsync();\n\n                // Then\n                verify(sqsClientMock.changeMessageVisibilityAsync(anything(), anything())).never();\n            });\n\n            it('should call deleteMessageAsync if message is successfully handled', async () => {\n                // Given\n                const sqsClientMock = mock(SqsClient);\n                when(sqsClientMock.receiveMessageAsync()).thenResolve({\n                    Body: '0xdeadbeef',\n                    ReceiptHandle: '1',\n                });\n                const sqsClientInstance = instance(sqsClientMock);\n\n                let isHandleCalled = false;\n                const handleMessage = async () => {\n                    isHandleCalled = true;\n                };\n\n                const consumer = new SqsConsumer({\n                    workerIndex: 0,\n                    workerAddress: 'id',\n                    sqsClient: sqsClientInstance,\n                    handleMessage,\n                });\n\n                // When\n                await consumer.consumeOnceAsync();\n\n                // Then\n                expect(isHandleCalled).to.equal(true);\n                verify(sqsClientMock.deleteMessageAsync(anyString())).once();\n            });\n        });\n\n        describe('afterHandle', () => {\n            it('should be called once everything is successful', async () => {\n                // Given\n                const sqsClientMock = mock(SqsClient);\n                when(sqsClientMock.receiveMessageAsync()).thenResolve({\n                    Body: '0xdeadbeef',\n                    ReceiptHandle: '1',\n                });\n\n                const sqsClientInstance = instance(sqsClientMock);\n                let isAfterCalled = false;\n                const afterHandle = async () => {\n                    isAfterCalled = true;\n                };\n\n                const consumer = new SqsConsumer({\n                    workerIndex: 0,\n                    workerAddress: 'id',\n                    sqsClient: sqsClientInstance,\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line @typescript-eslint/no-empty-function\n                    handleMessage: async () => {},\n                    afterHandle,\n                });\n\n                // When\n                await consumer.consumeOnceAsync();\n\n                // Then\n                expect(isAfterCalled).to.equal(true);\n            });\n\n            it('should be passed an error if a non-retryable error was encountered', async () => {\n                // Given\n                const sqsClientMock = mock(SqsClient);\n                when(sqsClientMock.receiveMessageAsync()).thenResolve({\n                    Body: '0xdeadbeef',\n                    ReceiptHandle: '1',\n                });\n\n                const sqsClientInstance = instance(sqsClientMock);\n                let isAfterCalledWithError = false;\n\n                const consumer = new SqsConsumer({\n                    workerIndex: 0,\n                    workerAddress: 'id',\n                    sqsClient: sqsClientInstance,\n                    handleMessage: async () => {\n                        throw new Error();\n                    },\n                    afterHandle: async (_, error) => {\n                        if (error) {\n                            isAfterCalledWithError = true;\n                        }\n                    },\n                });\n\n                // When\n                await consumer.consumeOnceAsync();\n\n                // Then\n                expect(isAfterCalledWithError).to.equal(true);\n            });\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/sqs_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/sqs_consumer.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/sqs_client.ts",{"fileContent":"import { SQS } from 'aws-sdk';\n\nimport { LONG_POLLING_WAIT_TIME_SECONDS, SINGLE_MESSAGE } from '../core/constants';\n\n/**\n * SqsClient wraps SQS, making it far easier to unit test SQS and ignore SQS details\n */\nexport class SqsClient {\n    constructor(private readonly _sqs: SQS, private readonly _queueUrl: string) {}\n\n    public async receiveMessageAsync(): Promise<SQS.Message | null> {\n        const response = await this._sqs\n            .receiveMessage({\n                MaxNumberOfMessages: SINGLE_MESSAGE,\n                WaitTimeSeconds: LONG_POLLING_WAIT_TIME_SECONDS,\n                QueueUrl: this._queueUrl,\n            })\n            .promise();\n\n        if (response?.Messages?.length !== 1) {\n            return null;\n        }\n        return response.Messages[0];\n    }\n\n    public async changeMessageVisibilityAsync(receiptHandle: string, visibilityTimeout: number): Promise<void> {\n        await this._sqs\n            .changeMessageVisibility({\n                QueueUrl: this._queueUrl,\n                ReceiptHandle: receiptHandle,\n                VisibilityTimeout: visibilityTimeout,\n            })\n            .promise();\n    }\n\n    public async deleteMessageAsync(receiptHandle: string): Promise<void> {\n        await this._sqs\n            .deleteMessage({\n                QueueUrl: this._queueUrl,\n                ReceiptHandle: receiptHandle,\n            })\n            .promise();\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/sqs_consumer.ts",{"fileContent":"// tslint:disable: max-classes-per-file\nimport * as Sentry from '@sentry/node';\nimport { Transaction as SentryTransaction } from '@sentry/types';\nimport { SQS } from 'aws-sdk';\nimport delay from 'delay';\n\nimport { SENTRY_DSN } from '../config';\nimport { ONE_SECOND_MS } from '../core/constants';\nimport { logger } from '../logger';\n\nimport { SqsClient } from './sqs_client';\n\n// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type MessageHandler = (message: SQS.Types.Message) => Promise<any>;\n\nexport class SqsRetryableError extends Error {}\nexport class SqsConsumer {\n    private readonly _workerIndex: number;\n    private readonly _workerAddress: string;\n    private readonly _sqsClient: SqsClient;\n    private readonly _beforeHandle?: () => Promise<boolean>;\n    private readonly _handleMessage: MessageHandler;\n    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    private readonly _afterHandle?: (message: SQS.Types.Message, error?: Error) => Promise<any>;\n    private _isConsuming: boolean;\n\n    constructor(params: {\n        workerIndex: number;\n        workerAddress: string;\n        sqsClient: SqsClient;\n        beforeHandle?: () => Promise<boolean>;\n        handleMessage: MessageHandler;\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        afterHandle?: (message: SQS.Types.Message, error?: Error) => Promise<any>;\n    }) {\n        this._workerIndex = params.workerIndex;\n        this._workerAddress = params.workerAddress;\n        this._sqsClient = params.sqsClient;\n        this._beforeHandle = params.beforeHandle;\n        this._handleMessage = params.handleMessage;\n        this._afterHandle = params.afterHandle;\n        this._isConsuming = false;\n    }\n\n    public get workerIndex(): number {\n        return this._workerIndex;\n    }\n\n    public get workerAddress(): string {\n        return this._workerAddress;\n    }\n\n    public stop(): void {\n        this._isConsuming = false;\n    }\n\n    public async consumeAsync(): Promise<void> {\n        if (this._isConsuming) {\n            return;\n        }\n\n        this._isConsuming = true;\n        while (this._isConsuming) {\n            await this.consumeOnceAsync();\n        }\n    }\n\n    /**\n     * Decorates _consumeOnceInternalAsync with Sentry observability\n     */\n    public async consumeOnceAsync(): Promise<void> {\n        let transaction: SentryTransaction | undefined;\n        if (SENTRY_DSN) {\n            transaction = Sentry.startTransaction({\n                name: 'Worker Transaction',\n            });\n        }\n\n        try {\n            await this._consumeOnceInternalAsync();\n        } catch (e) {\n            if (SENTRY_DSN) {\n                Sentry.captureException(e);\n            }\n            logger.error(\n                { id: this._workerAddress, workerIndex: this._workerIndex, errorMessage: e.message },\n                `Encountered error when consuming from the queue`,\n            );\n        } finally {\n            if (SENTRY_DSN) {\n                transaction?.finish();\n            }\n        }\n    }\n\n    private async _consumeOnceInternalAsync(): Promise<void> {\n        // Run the before hook\n        if (this._beforeHandle) {\n            let beforeCheck;\n            try {\n                beforeCheck = await this._beforeHandle();\n            } catch (e) {\n                logger.error(\n                    { id: this._workerAddress, workerIndex: this._workerIndex, errorMessage: e.message },\n                    'Error encountered in the preHandle check',\n                );\n                throw e;\n            }\n\n            if (!beforeCheck) {\n                const errorMessage = 'Before validation failed';\n                logger.warn({ id: this._workerAddress, workerIndex: this._workerIndex }, errorMessage);\n                await delay(ONE_SECOND_MS);\n                return;\n            }\n        }\n\n        // Receive message\n        const message = await this._sqsClient.receiveMessageAsync();\n\n        // No message\n        if (message === null) {\n            return;\n        }\n\n        // Handle message\n        let error: Error | undefined;\n        try {\n            await this._handleMessage(message);\n        } catch (err) {\n            error = err;\n            logger.error(\n                { errorMessage: err.message, message, id: this._workerAddress, workerIndex: this._workerIndex },\n                'Encountered error while handling message',\n            );\n\n            if (err instanceof SqsRetryableError) {\n                logger.info({ message, id: this._workerAddress, workerIndex: this._workerIndex }, 'Retrying message');\n                // Retry message\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                await this._sqsClient.changeMessageVisibilityAsync(message.ReceiptHandle!, 0);\n                await delay(ONE_SECOND_MS);\n                throw err;\n            }\n        }\n\n        // Delete message\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        await this._sqsClient.deleteMessageAsync(message.ReceiptHandle!);\n\n        // Run the after hook\n        if (this._afterHandle) {\n            await this._afterHandle(message, error);\n        }\n\n        if (error) {\n            throw error;\n        }\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/sqs_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/TokenPriceOracleTest.ts",{"fileContent":"// tslint:disable: custom-no-magic-numbers\nimport Axios, { AxiosInstance } from 'axios';\nimport AxiosMockAdapter from 'axios-mock-adapter';\nimport * as HttpStatus from 'http-status-codes';\n\nimport { TokenPriceOracle } from '../../src/utils/TokenPriceOracle';\n\nlet axiosClient: AxiosInstance;\nlet axiosMock: AxiosMockAdapter;\n\ndescribe('TokenPriceOracle', () => {\n    beforeAll(() => {\n        axiosClient = Axios.create();\n        axiosMock = new AxiosMockAdapter(axiosClient);\n    });\n\n    afterEach(() => {\n        axiosMock.reset();\n        jest.useRealTimers();\n    });\n\n    describe('batchFetchTokenPriceAsync', () => {\n        it('returns the price in USD for all requested tokens', async () => {\n            const fakeDefinedFiResponseForUSDC = {\n                data: {\n                    getPrice: {\n                        priceUsd: 1.1,\n                    },\n                },\n            };\n            const fakeDefinedUSDCResponseForETH = {\n                data: {\n                    getPrice: {\n                        priceUsd: 3000.01,\n                    },\n                },\n            };\n            axiosMock\n                .onPost('https://api.defined.fi')\n                .replyOnce(HttpStatus.OK, fakeDefinedFiResponseForUSDC)\n                .onPost('https://api.defined.fi')\n                .replyOnce(HttpStatus.OK, fakeDefinedUSDCResponseForETH);\n\n            const tokenPriceOracle = new TokenPriceOracle(axiosClient, 'fakeApiKey', 'https://api.defined.fi');\n            const result = await tokenPriceOracle.batchFetchTokenPriceAsync([\n                { chainId: 1, tokenAddress: '0xUSDCContractAddress', tokenDecimals: 18 },\n                { chainId: 3, tokenAddress: '0xWETHContractAddress', tokenDecimals: 18 },\n            ]);\n            expect(axiosMock.history.post[0].headers['x-api-key']).toBe('fakeApiKey');\n\n            const expectedGraphqlQuery = `\n                query getPrice {\n                    getPrice(address: \"0xUSDCContractAddress\", networkId: 1) {\n                        priceUsd\n                    }\n                }\n            `;\n            const actualGraphQlQuery = JSON.parse(axiosMock.history.post[0].data).query;\n            // Strip out all indentations before comparing the body\n            expect(actualGraphQlQuery.replace(/^\\s+/gm, '')).toBe(expectedGraphqlQuery.replace(/^\\s+/gm, ''));\n\n            expect(result[0]?.toNumber()).toBe(1.1e-18);\n            expect(result[1]?.toNumber()).toBe(3000.01e-18);\n        });\n\n        it(\"returns null priceInUsd when it couldn't fetch the price\", async () => {\n            const tokenPriceOracle = new TokenPriceOracle(axiosClient, 'fakeApiKey', 'https://api.defined.fi');\n\n            // Test the case when server returns non-200 response\n            axiosMock.onPost('https://api.defined.fi').replyOnce(HttpStatus.INTERNAL_SERVER_ERROR);\n            let result = await tokenPriceOracle.batchFetchTokenPriceAsync([\n                { chainId: 1, tokenAddress: '0xUSDCContractAddress', tokenDecimals: 18 },\n            ]);\n            expect(result[0]).toBe(null);\n\n            // Test the case when server returns 200 but with unexpected response's body\n            //\n            // This is an actual response captured from defined.fi when we provide an invalid\n            // token address to their getPrice endpoint\n            const fakeDefinedResponseForInvalidToken = {\n                data: {\n                    getPrice: null,\n                },\n                errors: [\n                    {\n                        path: ['getPrice'],\n                        data: null,\n                        errorType: 'TypeError',\n                        errorInfo: null,\n                        locations: [\n                            {\n                                line: 2,\n                                column: 1,\n                                sourceName: null,\n                            },\n                        ],\n                        message: \"Cannot read property 'price' of undefined\",\n                    },\n                ],\n            };\n            axiosMock.onPost('https://api.defined.fi').replyOnce(HttpStatus.OK, fakeDefinedResponseForInvalidToken);\n            result = await tokenPriceOracle.batchFetchTokenPriceAsync([\n                { chainId: 1, tokenAddress: '0xInvalidContractAddress', tokenDecimals: 18 },\n            ]);\n            expect(result[0]).toBe(null);\n        });\n\n        it('caches the result', async () => {\n            const tokenPriceOracle = new TokenPriceOracle(axiosClient, 'fakeApiKey', 'https://api.defined.fi');\n\n            const fakeDefinedFiResponseForUSDC = {\n                data: {\n                    getPrice: {\n                        priceUsd: 1.1,\n                    },\n                },\n            };\n            const fakeDefinedFiResponseForUSDCChanged = {\n                data: {\n                    getPrice: {\n                        priceUsd: 2.1,\n                    },\n                },\n            };\n\n            axiosMock\n                .onPost('https://api.defined.fi')\n                .replyOnce(HttpStatus.OK, fakeDefinedFiResponseForUSDC)\n                .onPost('https://api.defined.fi')\n                .replyOnce(HttpStatus.OK, fakeDefinedFiResponseForUSDCChanged);\n\n            let result = await tokenPriceOracle.batchFetchTokenPriceAsync([\n                { chainId: 1, tokenAddress: '0xUSDCContractAddress', tokenDecimals: 18 },\n            ]);\n            expect(result[0]?.toNumber()).toBe(1.1e-18);\n\n            // Make another token price fetch request, the price should still be 1.1 because it didn't make another request to\n            // defined.fi API\n            result = await tokenPriceOracle.batchFetchTokenPriceAsync([\n                { chainId: 1, tokenAddress: '0xUSDCContractAddress', tokenDecimals: 18 },\n            ]);\n            // TokenPriceOracle shouldn't make another request to api.defined.fi\n            expect(axiosMock.history.post).toHaveLength(1);\n            expect(result[0]?.toNumber()).toBe(1.1e-18);\n        });\n\n        it('invalidates cache after configured TTL', async () => {\n            // Set Cache TTL to 5 seconds\n            const tokenPriceOracle = new TokenPriceOracle(axiosClient, 'fakeApiKey', 'https://api.defined.fi', 5000);\n\n            const fakeDefinedFiResponseForUSDC = {\n                data: {\n                    getPrice: {\n                        priceUsd: 1.1,\n                    },\n                },\n            };\n            const fakeDefinedFiResponseForUSDCChanged = {\n                data: {\n                    getPrice: {\n                        priceUsd: 2.1,\n                    },\n                },\n            };\n\n            axiosMock\n                .onPost('https://api.defined.fi')\n                .replyOnce(HttpStatus.OK, fakeDefinedFiResponseForUSDC)\n                .onPost('https://api.defined.fi')\n                .replyOnce(HttpStatus.OK, fakeDefinedFiResponseForUSDCChanged);\n\n            let result = await tokenPriceOracle.batchFetchTokenPriceAsync([\n                { chainId: 1, tokenAddress: '0xUSDCContractAddress', tokenDecimals: 18 },\n            ]);\n            expect(result[0]?.toNumber()).toBe(1.1e-18);\n\n            // Fast forward the system time 5.1 seconds\n            jest.useFakeTimers().setSystemTime(Date.now() + 5100);\n\n            // Make another token price fetch request, the price should be 2.1 now since the cache is invalidated\n            // so the TokenPriceOracle fetched the price from upstream again.\n            result = await tokenPriceOracle.batchFetchTokenPriceAsync([\n                { chainId: 1, tokenAddress: '0xUSDCContractAddress', tokenDecimals: 18 },\n            ]);\n            expect(axiosMock.history.post).toHaveLength(2);\n            expect(result[0]?.toNumber()).toBe(2.1e-18);\n        });\n\n        it('uses custom endpoint if provided', async () => {\n            axiosMock.onPost('https://custom-endpoint.local').replyOnce(HttpStatus.OK, {\n                data: {\n                    getPrice: {\n                        priceUsd: 1.1,\n                    },\n                },\n            });\n\n            const tokenPriceOracle = new TokenPriceOracle(\n                axiosClient,\n                'fakeApiKey',\n                'https://custom-endpoint.local',\n                5000,\n            );\n            await tokenPriceOracle.batchFetchTokenPriceAsync([\n                { chainId: 1, tokenAddress: '0xUSDCContractAddress', tokenDecimals: 18 },\n            ]);\n            expect(axiosMock.history.post[0].url).toBe('https://custom-endpoint.local');\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/meta_transaction_fee_test.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\r\nimport { rawFeesToFees } from '../../src/core/meta_transaction_fee_utils';\r\n\r\nconst FEE_TOKEN = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';\r\nconst FEE_RECIPIENT = '0x5fb652150AcE5303c82f0d1D491041e042f2ad22';\r\n\r\ndescribe('meta_transaction_fee_utils', () => {\r\n    describe('rawFeesToFees', () => {\r\n        it('returns undefined if `rawFees` is undefined', () => {\r\n            expect(rawFeesToFees(undefined)).toBeUndefined();\r\n        });\r\n\r\n        describe('integrator fee', () => {\r\n            it('returns integrator fee as undefined if integrator fee is not provided', () => {\r\n                const fees = rawFeesToFees({\r\n                    zeroExFee: {\r\n                        type: 'integrator_share',\r\n                        feeToken: FEE_TOKEN,\r\n                        feeAmount: '1000',\r\n                        feeRecipient: FEE_RECIPIENT,\r\n                        integratorSharePercentage: '10',\r\n                    },\r\n                });\r\n                expect(fees).toBeTruthy();\r\n                expect(fees?.integratorFee).toBeUndefined();\r\n            });\r\n\r\n            it('returns the correct integrator fee if integrator fee is provided', () => {\r\n                const fees = rawFeesToFees({\r\n                    integratorFee: {\r\n                        type: 'volume',\r\n                        feeToken: FEE_TOKEN,\r\n                        feeAmount: '1000',\r\n                        feeRecipient: FEE_RECIPIENT,\r\n                        volumePercentage: '10',\r\n                    },\r\n                    zeroExFee: {\r\n                        type: 'integrator_share',\r\n                        feeToken: FEE_TOKEN,\r\n                        feeAmount: '100000',\r\n                        feeRecipient: FEE_RECIPIENT,\r\n                        integratorSharePercentage: '1',\r\n                    },\r\n                });\r\n                expect(fees).toBeTruthy();\r\n                expect(fees?.integratorFee).toEqual({\r\n                    type: 'volume',\r\n                    feeToken: FEE_TOKEN,\r\n                    feeAmount: new BigNumber(1000),\r\n                    feeRecipient: FEE_RECIPIENT,\r\n                    volumePercentage: new BigNumber(10),\r\n                });\r\n            });\r\n        });\r\n\r\n        describe('0x fee', () => {\r\n            it('returns 0x fee as undefined if 0x fee is not provided', () => {\r\n                const fees = rawFeesToFees({\r\n                    integratorFee: {\r\n                        type: 'volume',\r\n                        feeToken: FEE_TOKEN,\r\n                        feeAmount: '1000',\r\n                        feeRecipient: FEE_RECIPIENT,\r\n                        volumePercentage: '10',\r\n                    },\r\n                });\r\n                expect(fees).toBeTruthy();\r\n                expect(fees?.zeroExFee).toBeUndefined();\r\n            });\r\n\r\n            it('returns the correct 0x fee volume fee if 0x fee is provided', () => {\r\n                const fees = rawFeesToFees({\r\n                    integratorFee: {\r\n                        type: 'volume',\r\n                        feeToken: FEE_TOKEN,\r\n                        feeAmount: '1000',\r\n                        feeRecipient: FEE_RECIPIENT,\r\n                        volumePercentage: '10',\r\n                    },\r\n                    zeroExFee: {\r\n                        type: 'volume',\r\n                        feeToken: FEE_TOKEN,\r\n                        feeAmount: '100000',\r\n                        feeRecipient: null,\r\n                        volumePercentage: '1',\r\n                    },\r\n                });\r\n                expect(fees).toBeTruthy();\r\n                expect(fees?.zeroExFee).toEqual({\r\n                    type: 'volume',\r\n                    feeToken: FEE_TOKEN,\r\n                    feeAmount: new BigNumber(100000),\r\n                    feeRecipient: null,\r\n                    volumePercentage: new BigNumber(1),\r\n                });\r\n            });\r\n\r\n            it('returns the correct 0x fee integrator share fee if 0x fee is provided', () => {\r\n                const fees = rawFeesToFees({\r\n                    integratorFee: {\r\n                        type: 'volume',\r\n                        feeToken: FEE_TOKEN,\r\n                        feeAmount: '1000',\r\n                        feeRecipient: FEE_RECIPIENT,\r\n                        volumePercentage: '10',\r\n                    },\r\n                    zeroExFee: {\r\n                        type: 'integrator_share',\r\n                        feeToken: FEE_TOKEN,\r\n                        feeAmount: '100000',\r\n                        feeRecipient: FEE_RECIPIENT,\r\n                        integratorSharePercentage: '1',\r\n                    },\r\n                });\r\n                expect(fees).toBeTruthy();\r\n                expect(fees?.zeroExFee).toEqual({\r\n                    type: 'integrator_share',\r\n                    feeToken: FEE_TOKEN,\r\n                    feeAmount: new BigNumber(100000),\r\n                    feeRecipient: FEE_RECIPIENT,\r\n                    integratorSharePercentage: new BigNumber(1),\r\n                });\r\n            });\r\n        });\r\n\r\n        describe('gas fee', () => {\r\n            it('returns gas fee as undefined if gas fee is not provided', () => {\r\n                const fees = rawFeesToFees({\r\n                    zeroExFee: {\r\n                        type: 'integrator_share',\r\n                        feeToken: FEE_TOKEN,\r\n                        feeAmount: '1000',\r\n                        feeRecipient: FEE_RECIPIENT,\r\n                        integratorSharePercentage: '10',\r\n                    },\r\n                });\r\n                expect(fees).toBeTruthy();\r\n                expect(fees?.gasFee).toBeUndefined();\r\n            });\r\n\r\n            it('returns the correct gas fee if gas is provided', () => {\r\n                const fees = rawFeesToFees({\r\n                    integratorFee: {\r\n                        type: 'volume',\r\n                        feeToken: FEE_TOKEN,\r\n                        feeAmount: '1000',\r\n                        feeRecipient: FEE_RECIPIENT,\r\n                        volumePercentage: '10',\r\n                    },\r\n                    zeroExFee: {\r\n                        type: 'integrator_share',\r\n                        feeToken: FEE_TOKEN,\r\n                        feeAmount: '100000',\r\n                        feeRecipient: FEE_RECIPIENT,\r\n                        integratorSharePercentage: '1',\r\n                    },\r\n                    gasFee: {\r\n                        type: 'gas',\r\n                        feeToken: FEE_TOKEN,\r\n                        feeAmount: '10',\r\n                        feeRecipient: FEE_RECIPIENT,\r\n                        gasPrice: '123',\r\n                        estimatedGas: '200000',\r\n                        feeTokenAmountPerBaseUnitNativeToken: '0.0001',\r\n                    },\r\n                });\r\n                expect(fees).toBeTruthy();\r\n                expect(fees?.gasFee).toEqual({\r\n                    type: 'gas',\r\n                    feeToken: FEE_TOKEN,\r\n                    feeAmount: new BigNumber(10),\r\n                    feeRecipient: FEE_RECIPIENT,\r\n                    gasPrice: new BigNumber(123),\r\n                    estimatedGas: new BigNumber(200000),\r\n                    feeTokenAmountPerBaseUnitNativeToken: new BigNumber(0.0001),\r\n                });\r\n            });\r\n        });\r\n    });\r\n});\r\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/meta_transaction_fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/GasStationAttendantPolygonTest.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { instance, mock, when } from 'ts-mockito';\n\nimport { GWEI_DECIMALS } from '../../src/core/constants';\nimport { GasOracleType0 } from '../../src/utils/GasOracleType0';\nimport { GasStationAttendantPolygon } from '../../src/utils/GasStationAttendantPolygon';\n\nlet gasOracleMock: GasOracleType0;\n\ndescribe('GasStationAttendantPolygon', () => {\n    beforeAll(() => {\n        gasOracleMock = mock(GasOracleType0);\n    });\n\n    describe('getWorkerBalanceForTradeAsync', () => {\n        it('gets the balance to trade', async () => {\n            when(gasOracleMock.getGasWeiAsync('fast')).thenResolve(new BigNumber(1000).shiftedBy(GWEI_DECIMALS));\n\n            const attendant = new GasStationAttendantPolygon(instance(gasOracleMock));\n\n            const workerGasToTrade = await attendant.getWorkerBalanceForTradeAsync();\n\n            // 1000 GWEI * (1.1^3) = 1331\n            // Gas estimate = 100,000 * 1.1 = 110,000\n            // Total = 1331 * 110,000 = 146,410,000 GWEI\n\n            expect(workerGasToTrade.toPrecision(2).toString()).toEqual(\n                // tslint:disable-next-line: custom-no-magic-numbers\n                new BigNumber(146_410_000).times(Math.pow(10, GWEI_DECIMALS)).toPrecision(2).toString(),\n            );\n        });\n    });\n\n    describe('getExpectedTransactionGasRateAsync', () => {\n        it('estimates the transaction gas rate', async () => {\n            when(gasOracleMock.getGasWeiAsync('fast')).thenResolve(new BigNumber(666).shiftedBy(GWEI_DECIMALS));\n\n            const attendant = new GasStationAttendantPolygon(instance(gasOracleMock));\n\n            const gasRate = await attendant.getExpectedTransactionGasRateAsync();\n\n            // 666 * 1.1^1.5 = 768.35736217 GWEI\n            expect(gasRate.toString()).toEqual(\n                // tslint:disable-next-line: custom-no-magic-numbers\n                new BigNumber(768.35736217)\n                    .times(Math.pow(10, GWEI_DECIMALS))\n                    .integerValue(BigNumber.ROUND_CEIL)\n                    .toString(),\n            );\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType0.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantPolygon.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/rfq_blockchain_utils_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers no-unused-expression\nimport { SupportedProvider } from '@0x/subproviders';\nimport { BigNumber } from '@0x/utils';\nimport { providers, Wallet } from 'ethers';\nimport { anything, instance, mock, spy, when } from 'ts-mockito';\n\nimport { EXECUTE_META_TRANSACTION_EIP_712_TYPES, PERMIT_EIP_712_TYPES } from '../../src/core/constants';\nimport { EIP_712_REGISTRY } from '../../src/eip712registry';\nimport { GaslessApprovalTypes } from '../../src/core/types';\nimport { BalanceChecker } from '../../src/utils/balance_checker';\nimport { extractEIP712DomainType } from '../../src/utils/Eip712Utils';\nimport { RfqBlockchainUtils } from '../../src/utils/rfq_blockchain_utils';\n\nlet supportedProvider: SupportedProvider;\nlet balancerChecker: BalanceChecker;\nlet ethersProvider: providers.JsonRpcProvider;\nlet ethersWallet: Wallet;\nlet rfqBlockchainUtils: RfqBlockchainUtils;\n\nconst ACCESS_LIST_ADDR_1 = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';\nconst STORAGE_KEY_1 = '0x0000000000000000000000000000000000000000000000000000000000000000';\nconst ACCESS_LIST_ADDR_2 = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48';\nconst STORAGE_KEY_2 = '0x3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff';\nconst CALLDATA = '0xd0e30db0';\nconst PROXY_ADDR = '0xdef1c0ded9bec7f1a1670819833240f027b25eff';\nconst FROM = '0xdef1c0ded9bec7f1a1670819833240f027b25ef1';\n\ndescribe('RfqBlockchainUtils', () => {\n    beforeEach(() => {\n        supportedProvider = mock<SupportedProvider>();\n        balancerChecker = mock(BalanceChecker);\n        ethersProvider = mock(providers.JsonRpcProvider);\n        ethersWallet = mock(Wallet);\n        rfqBlockchainUtils = new RfqBlockchainUtils(\n            instance(supportedProvider),\n            PROXY_ADDR,\n            instance(balancerChecker),\n            instance(ethersProvider),\n            instance(ethersWallet),\n        );\n    });\n\n    describe('createAccessListForAsync', () => {\n        it('returns correct TxAccessListWithGas object', async () => {\n            when(ethersProvider.send(anything(), anything())).thenResolve({\n                accessList: [\n                    {\n                        address: ACCESS_LIST_ADDR_1,\n                        storageKeys: [STORAGE_KEY_1],\n                    },\n                    {\n                        address: ACCESS_LIST_ADDR_2,\n                        storageKeys: [STORAGE_KEY_2],\n                    },\n                ],\n                gasUsed: '0x651a',\n            });\n\n            expect(await rfqBlockchainUtils.createAccessListForAsync({ data: CALLDATA, from: FROM })).toEqual({\n                accessList: {\n                    [ACCESS_LIST_ADDR_1]: [STORAGE_KEY_1],\n                    [ACCESS_LIST_ADDR_2]: [STORAGE_KEY_2],\n                },\n                gasEstimate: 25882,\n            });\n        });\n\n        it('throws exception on failed eth_createAccessList RPC call', async () => {\n            when(ethersProvider.send(anything(), anything())).thenReject(new Error('RPC error'));\n\n            await expect(async () => {\n                await rfqBlockchainUtils.createAccessListForAsync({ data: CALLDATA, from: FROM });\n            }).rejects.toThrow('createAccessListForAsync');\n        });\n\n        it('throws exception on malformed RPC response', async () => {\n            when(ethersProvider.send(anything(), anything())).thenResolve(1);\n\n            await expect(async () => {\n                await rfqBlockchainUtils.createAccessListForAsync({ data: CALLDATA, from: FROM });\n            }).rejects.toThrow('createAccessListForAsync');\n        });\n    });\n\n    describe('getGaslessApprovalAsync', () => {\n        it('returns null if a token does not exist in EIP-712 registry', async () => {\n            expect(await rfqBlockchainUtils.getGaslessApprovalAsync(12345, 'random', '0x1234')).toBeNull();\n            expect(await rfqBlockchainUtils.getGaslessApprovalAsync(137, 'random', '0x1234')).toBeNull();\n        });\n\n        it('returns the correct approval object for executeMetaTransaction::approve', async () => {\n            // Given\n            const executeMetaTxToken = '0x9a71012b13ca4d3d0cdc72a177df3ef03b0e76a3'; // BAL\n            const { domain } = EIP_712_REGISTRY[137][executeMetaTxToken];\n            when(ethersProvider._isProvider).thenReturn(true);\n            const spiedBlockchainUtils = spy(rfqBlockchainUtils);\n            when(spiedBlockchainUtils.getMetaTransactionNonceAsync(anything(), anything())).thenResolve(\n                new BigNumber('0x1'),\n            );\n\n            // When\n            const approval = await rfqBlockchainUtils.getGaslessApprovalAsync(137, executeMetaTxToken, FROM);\n\n            // Then\n            expect(approval).toEqual({\n                kind: GaslessApprovalTypes.ExecuteMetaTransaction,\n                eip712: {\n                    types: {\n                        ...extractEIP712DomainType(domain),\n                        ...EXECUTE_META_TRANSACTION_EIP_712_TYPES,\n                    },\n                    primaryType: 'MetaTransaction',\n                    domain,\n                    message: {\n                        nonce: 1,\n                        from: FROM,\n                        functionSignature:\n                            '0x095ea7b3000000000000000000000000def1c0ded9bec7f1a1670819833240f027b25effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',\n                    },\n                },\n            });\n        });\n\n        it('returns the correct approval object for permit', async () => {\n            // Given\n            const permitToken = '0x2791bca1f2de4661ed88a30c99a7a9449aa84174'; // USDC\n            const { domain } = EIP_712_REGISTRY[137][permitToken];\n            when(ethersProvider._isProvider).thenReturn(true);\n            const spiedBlockchainUtils = spy(rfqBlockchainUtils);\n            when(spiedBlockchainUtils.getPermitNonceAsync(anything(), anything())).thenResolve(new BigNumber('0x1'));\n\n            // When\n            const approval = await rfqBlockchainUtils.getGaslessApprovalAsync(137, permitToken, FROM, 0);\n\n            // Then\n            expect(approval).toEqual({\n                kind: GaslessApprovalTypes.Permit,\n                eip712: {\n                    types: {\n                        ...extractEIP712DomainType(domain),\n                        ...PERMIT_EIP_712_TYPES,\n                    },\n                    primaryType: 'Permit',\n                    domain,\n                    message: {\n                        owner: FROM,\n                        spender: PROXY_ADDR,\n                        value: '115792089237316195423570985008687907853269984665640564039457584007913129639935', // infinite approval\n                        nonce: 1,\n                        deadline: '600', // 10 minutes from 0\n                    },\n                },\n            });\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/ethereum.json","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/polygon.json","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/abis/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/service_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/subprovider_adapter.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/RfqtQuoteValidatorTest.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { Integrator } from '../../src/config';\nimport { ONE_MINUTE_MS, ONE_SECOND_MS } from '../../src/core/constants';\nimport { QuoteContext } from '../../src/services/types';\n\nimport { RfqtV2Price } from '../../src/core/types';\nimport { getRfqtV2FillableAmounts, validateV2Prices } from '../../src/utils/RfqtQuoteValidator';\n\ndescribe('Rfqt Quote Validator', () => {\n    const chainId = 1337;\n    const integrator: Integrator = {\n        allowedChainIds: [chainId],\n        apiKeys: [],\n        integratorId: 'integrator-id',\n        label: 'test integrator',\n        plp: false,\n        rfqm: false,\n        rfqt: true,\n    };\n    const quoteContext: QuoteContext = {\n        isFirm: false,\n        workflow: 'rfqt',\n        isUnwrap: false,\n        originalMakerToken: '0x1',\n        takerTokenDecimals: 18,\n        makerTokenDecimals: 18,\n        feeModelVersion: 1,\n        assetFillAmount: new BigNumber(111),\n        chainId,\n        integrator,\n        makerToken: '0x1',\n        isSelling: false,\n        takerAddress: '0x0',\n        takerToken: '0x2',\n        txOrigin: '0xtakeraddress',\n    };\n    const nowTimeS = new BigNumber(Date.now()).div(ONE_SECOND_MS);\n    const validPrices: RfqtV2Price[] = [\n        {\n            expiry: nowTimeS.plus(75),\n            makerAddress: '0xmaker1',\n            makerAmount: new BigNumber(111),\n            makerId: 'uuid-maker1',\n            makerToken: '0x1',\n            makerUri: 'maker1.xyz',\n            takerAmount: new BigNumber(111),\n            takerToken: '0x2',\n        },\n        {\n            expiry: nowTimeS.plus(75),\n            makerAddress: '0xmaker2',\n            makerAmount: new BigNumber(111),\n            makerId: 'uuid-maker2',\n            makerToken: '0x1',\n            makerUri: 'maker2.xyz',\n            takerAmount: new BigNumber(111),\n            takerToken: '0x2',\n        },\n    ];\n    const validityWindowMs = ONE_MINUTE_MS;\n\n    describe('validateV2Prices', () => {\n        it('filters fetched prices for the wrong pair', () => {\n            const prices: RfqtV2Price[] = [\n                ...validPrices,\n                {\n                    expiry: nowTimeS.plus(75),\n                    makerAddress: '0xmaker3',\n                    makerAmount: new BigNumber(111),\n                    makerId: 'uuid-maker3',\n                    makerToken: '0x1',\n                    makerUri: 'maker3.xyz',\n                    takerAmount: new BigNumber(111),\n                    takerToken: '0x3',\n                },\n            ];\n            const validatedPrices = validateV2Prices(prices, quoteContext, validityWindowMs);\n            expect(validatedPrices).toEqual(validPrices);\n        });\n\n        it('filters fetched prices with tight expiration windows', () => {\n            const prices: RfqtV2Price[] = [\n                ...validPrices,\n                {\n                    expiry: nowTimeS.plus(59),\n                    makerAddress: '0xmaker3',\n                    makerAmount: new BigNumber(111),\n                    makerId: 'uuid-maker3',\n                    makerToken: '0x1',\n                    makerUri: 'maker3.xyz',\n                    takerAmount: new BigNumber(111),\n                    takerToken: '0x2',\n                },\n            ];\n            const validatedPrices = validateV2Prices(prices, quoteContext, validityWindowMs);\n            expect(validatedPrices).toEqual(validPrices);\n        });\n\n        it('returns an empty array from empty prices', () => {\n            const emptyPrices = validateV2Prices([], quoteContext, validityWindowMs);\n            expect(emptyPrices).toEqual([]);\n        });\n    });\n\n    describe('getRfqtV2FillableAmounts', () => {\n        it('returns full amounts for fully fillable orders', () => {\n            const quotedMakerBalances = [new BigNumber(1000), new BigNumber(1000)];\n            const fillableAmounts = getRfqtV2FillableAmounts(validPrices, chainId, quotedMakerBalances);\n            expect(fillableAmounts).toEqual([\n                { fillableMakerAmount: new BigNumber(111), fillableTakerAmount: new BigNumber(111) },\n                { fillableMakerAmount: new BigNumber(111), fillableTakerAmount: new BigNumber(111) },\n            ]);\n        });\n\n        it('returns full amounts if maker balances are not present', () => {\n            const fillableAmounts = getRfqtV2FillableAmounts(validPrices, chainId);\n            expect(fillableAmounts).toEqual([\n                { fillableMakerAmount: new BigNumber(111), fillableTakerAmount: new BigNumber(111) },\n                { fillableMakerAmount: new BigNumber(111), fillableTakerAmount: new BigNumber(111) },\n            ]);\n        });\n\n        it('returns partial amounts if a maker does not have enough balance', () => {\n            const quotedMakerBalances = [new BigNumber(1000), new BigNumber(10)];\n            const fillableAmounts = getRfqtV2FillableAmounts(validPrices, chainId, quotedMakerBalances);\n            expect(fillableAmounts).toEqual([\n                { fillableMakerAmount: new BigNumber(111), fillableTakerAmount: new BigNumber(111) },\n                { fillableMakerAmount: new BigNumber(10), fillableTakerAmount: new BigNumber(10) },\n            ]);\n        });\n\n        it('returns zero amounts if a maker has zero balance', () => {\n            const quotedMakerBalances = [new BigNumber(1000), new BigNumber(0)];\n            const fillableAmounts = getRfqtV2FillableAmounts(validPrices, chainId, quotedMakerBalances);\n            expect(fillableAmounts).toEqual([\n                { fillableMakerAmount: new BigNumber(111), fillableTakerAmount: new BigNumber(111) },\n                { fillableMakerAmount: new BigNumber(0), fillableTakerAmount: new BigNumber(0) },\n            ]);\n        });\n\n        it('returns zero amounts if supplied maker amount is zero', () => {\n            const prices = [\n                {\n                    expiry: nowTimeS.plus(75),\n                    makerAddress: '0xmaker3',\n                    makerAmount: new BigNumber(0),\n                    makerId: 'uuid-maker3',\n                    makerToken: '0x1',\n                    makerUri: 'maker3.xyz',\n                    takerAmount: new BigNumber(111),\n                    takerToken: '0x2',\n                },\n            ];\n            const quotedMakerBalances = [new BigNumber(1000)];\n            const fillableAmounts = getRfqtV2FillableAmounts(prices, chainId, quotedMakerBalances);\n            expect(fillableAmounts).toEqual([\n                { fillableMakerAmount: new BigNumber(0), fillableTakerAmount: new BigNumber(0) },\n            ]);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/RfqtQuoteValidator.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/rfqm_health_check_test.ts",{"fileContent":"// tslint:disable custom-no-magic-numbers\nimport { BigNumber } from '@0x/utils';\nimport { expect } from 'chai';\nimport { Producer } from 'sqs-producer';\nimport { instance, mock, when } from 'ts-mockito';\n\nimport { ETH_DECIMALS } from '../../src/core/constants';\nimport { RfqmWorkerHeartbeatEntity } from '../../src/entities';\nimport {\n    checkSqsQueueAsync,\n    checkWorkerHeartbeatsAsync,\n    getHttpIssues,\n    HealthCheckStatus,\n} from '../../src/utils/rfqm_health_check';\n\nlet producerMock: Producer;\n\nconst MS_IN_MINUTE = 60000;\nconst fullBalance = new BigNumber(1).shiftedBy(ETH_DECIMALS);\n\ndescribe('RFQm Health Check', () => {\n    describe('checkSqsQueueAsync', () => {\n        beforeEach(() => {\n            producerMock = mock(Producer);\n        });\n\n        describe('queue size check', () => {\n            it('creates no issues if there are 10 or less jobs in the queue', async () => {\n                when(producerMock.queueSize()).thenResolve(1);\n\n                const issues = await checkSqsQueueAsync(instance(producerMock));\n\n                expect(issues).to.have.length(0);\n            });\n\n            it('creates a DEGRADED issue if there are more than 5 messages in the queue', async () => {\n                when(producerMock.queueSize()).thenResolve(11);\n\n                const issues = await checkSqsQueueAsync(instance(producerMock));\n\n                expect(issues).to.have.length(1);\n                expect(issues[0].status).to.equal(HealthCheckStatus.Degraded);\n            });\n\n            it('creates a FAILED issue if there are more than 20 messages in the queue', async () => {\n                when(producerMock.queueSize()).thenResolve(21);\n\n                const issues = await checkSqsQueueAsync(instance(producerMock));\n\n                expect(issues).to.have.length(1);\n                expect(issues[0].status).to.equal(HealthCheckStatus.Failed);\n            });\n        });\n    });\n\n    describe('checkWorkerHeartbeatsAsync', () => {\n        it('creates a failed issue when no heartbeats are found', async () => {\n            const issues = await checkWorkerHeartbeatsAsync([]);\n\n            expect(issues).to.have.length(1);\n            expect(issues[0].status).to.equal(HealthCheckStatus.Failed);\n        });\n\n        describe('Heartbeat age', () => {\n            it('creates a failed issue with no recent heartbeats', async () => {\n                const now = new Date();\n                const nowTime = now.getTime();\n                const heartbeat = new RfqmWorkerHeartbeatEntity({\n                    address: '0x00',\n                    balance: fullBalance,\n                    index: 0,\n                    timestamp: new Date(nowTime - MS_IN_MINUTE * 6),\n                    chainId: 1337,\n                });\n\n                const issues = await checkWorkerHeartbeatsAsync([heartbeat], now);\n                const failedIssues = issues.filter(({ status }) => status === HealthCheckStatus.Failed);\n\n                expect(failedIssues).to.have.length(1);\n            });\n\n            it('creates degraded issues for stale heartbeats', async () => {\n                const now = new Date();\n                const nowTime = now.getTime();\n                const heartbeat1 = new RfqmWorkerHeartbeatEntity({\n                    address: '0x00',\n                    balance: fullBalance,\n                    index: 0,\n                    timestamp: now,\n                    chainId: 1337,\n                });\n                const heartbeat2 = new RfqmWorkerHeartbeatEntity({\n                    address: '0x01',\n                    balance: fullBalance,\n                    index: 1,\n                    timestamp: new Date(nowTime - MS_IN_MINUTE * 8),\n                    chainId: 1337,\n                });\n\n                const issues = await checkWorkerHeartbeatsAsync([heartbeat1, heartbeat2], now);\n                const failedIssues = issues.filter(({ status }) => status === HealthCheckStatus.Failed);\n                expect(failedIssues).to.have.length(0);\n                const degradedIssues = issues.filter(({ status }) => status === HealthCheckStatus.Degraded);\n                expect(degradedIssues).to.have.length(1);\n                expect(degradedIssues[0].description).to.contain('0x01');\n            });\n        });\n\n        describe('Worker balance', () => {\n            it('creates a failed issue when no worker has a balance above the failed threshold', async () => {\n                const now = new Date();\n                const heartbeat = new RfqmWorkerHeartbeatEntity({\n                    address: '0x00',\n                    balance: new BigNumber(0.01),\n                    index: 0,\n                    timestamp: now,\n                    chainId: 1337,\n                });\n\n                const issues = await checkWorkerHeartbeatsAsync([heartbeat], now);\n                const failedIssues = issues.filter(({ status }) => status === HealthCheckStatus.Failed);\n\n                expect(failedIssues).to.have.length(1);\n            });\n\n            it('creates degraded issues for low worker balances', async () => {\n                const now = new Date();\n                const heartbeat1 = new RfqmWorkerHeartbeatEntity({\n                    address: '0x00',\n                    balance: new BigNumber(0.01),\n                    index: 0,\n                    timestamp: now,\n                    chainId: 1337,\n                });\n                const heartbeat2 = new RfqmWorkerHeartbeatEntity({\n                    address: '0x01',\n                    balance: fullBalance,\n                    index: 1,\n                    timestamp: now,\n                    chainId: 1337,\n                });\n\n                const issues = await checkWorkerHeartbeatsAsync([heartbeat1, heartbeat2], now);\n                const failedIssues = issues.filter(({ status }) => status === HealthCheckStatus.Failed);\n                expect(failedIssues).to.have.length(0);\n\n                const degradedIssues = issues.filter(({ status }) => status === HealthCheckStatus.Degraded);\n\n                expect(degradedIssues).to.have.length(1);\n                expect(degradedIssues[0].description).to.contain(\n                    'Less than two workers have a balance above the degraded threshold',\n                );\n            });\n        });\n    });\n\n    describe('getHttpIssues', () => {\n        it('goes into maintainence mode', async () => {\n            const issues = getHttpIssues(/* isMaintainenceMode */ true);\n\n            expect(issues[0].status).to.equal(HealthCheckStatus.Maintenance);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_health_check.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/GasStationAttendantEthereumTest.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { expect } from 'chai';\nimport { instance, mock, when } from 'ts-mockito';\n\nimport { GasOracleType2 } from '../../src/utils/GasOracleType2';\nimport { GasStationAttendantEthereum } from '../../src/utils/GasStationAttendantEthereum';\nimport { calculateGasEstimate } from '../../src/utils/rfqm_gas_estimate_utils';\n\nlet gasOracleMock: GasOracleType2;\n\ndescribe('GasStationAttendantEthereum', () => {\n    beforeAll(() => {\n        gasOracleMock = mock(GasOracleType2);\n    });\n\n    describe('getWorkerBalanceForTradeAsync', () => {\n        it('gets the balance to trade', async () => {\n            when(gasOracleMock.getBaseFeePerGasWeiAsync()).thenResolve(new BigNumber(1000));\n            when(gasOracleMock.getMaxPriorityFeePerGasWeiAsync('instant')).thenResolve(new BigNumber(666));\n\n            const attendant = new GasStationAttendantEthereum(instance(gasOracleMock));\n\n            const workerGasToTrade = await attendant.getWorkerBalanceForTradeAsync();\n\n            // Base fee is 1000. With 6 10% increases = 1000 * (1.1)^ 6 = 1771.561\n            // Instant tip is 666\n            // Gas estimate matches the one used in the algorithm\n            const gasEstimate = calculateGasEstimate(\n                '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9',\n                '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n                'otc',\n                true,\n            );\n\n            expect(workerGasToTrade.toPrecision(2).toString()).to.equal(\n                // tslint:disable-next-line: custom-no-magic-numbers\n                new BigNumber(1771.561).plus(666).times(gasEstimate).toPrecision(2).toString(),\n            );\n        });\n    });\n\n    describe('getExpectedTransactionGasRateAsync', () => {\n        it('estimates the transaction gas rate', async () => {\n            when(gasOracleMock.getBaseFeePerGasWeiAsync()).thenResolve(new BigNumber(1000));\n\n            const attendant = new GasStationAttendantEthereum(instance(gasOracleMock));\n\n            const gasRate = await attendant.getExpectedTransactionGasRateAsync();\n\n            // Base fee is 1000\n            // Tip estimate is\n            const tipEstimate = new BigNumber(2750000000);\n\n            expect(gasRate.toString()).to.equal(\n                // tslint:disable-next-line: custom-no-magic-numbers\n                new BigNumber(1000).plus(tipEstimate).toString(),\n            );\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType2.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantEthereum.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendant.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/__tests__/RefreshingQuoteRequestor.test.ts",{"fileContent":"import { MarketOperation } from '@0x/types';\nimport { BigNumber } from '@0x/utils';\nimport axios, { AxiosInstance } from 'axios';\nimport { EventEmitter } from 'stream';\n\nimport { ConfigManager } from '../../utils/config_manager';\nimport { RfqMakerDbUtils } from '../../utils/rfq_maker_db_utils';\nimport { RfqMakerManager } from '../../utils/rfq_maker_manager';\nimport { QuoteRequestor } from '../QuoteRequestor';\nimport { RefreshingQuoteRequestor } from '../RefreshingQuoteRequestor';\n\njest.mock('axios');\n\nconst mockRequestRfqtIndicativeQuotesAsync = jest.fn().mockResolvedValue([]);\nconst mockRequestRfqtFirmQuotesAsync = jest.fn().mockResolvedValue([]);\njest.mock('../QuoteRequestor', () => {\n    return {\n        QuoteRequestor: jest.fn().mockImplementation((..._args) => {\n            return {\n                requestRfqtIndicativeQuotesAsync: mockRequestRfqtIndicativeQuotesAsync,\n                requestRfqtFirmQuotesAsync: mockRequestRfqtFirmQuotesAsync,\n            };\n        }),\n    };\n});\n\njest.mock('../../utils/rfq_maker_manager', () => {\n    return {\n        RfqMakerManager: jest.fn().mockImplementation((..._args) => {\n            const rmm = new EventEmitter() as unknown as jest.MockedObject<RfqMakerManager>;\n            rmm.getRfqtV1MakerOfferings = jest.fn().mockReturnValue([]);\n            return rmm;\n        }),\n    };\n});\n\n// TODO (rhinodavid): Find a better way to initialize mocked classes\nconst mockRfqMakerManager = jest.mocked(\n    // tslint:disable-next-line: no-object-literal-type-assertion custom-no-magic-numbers\n    new RfqMakerManager({} as ConfigManager, {} as RfqMakerDbUtils, /* chainId */ 1337),\n);\nconst mockAxiosInstance = jest.mocked(axios.create()) as unknown as jest.MockedObject<AxiosInstance>;\n\ndescribe('RefreshingQuoteRequestor', () => {\n    it('refreshes the quote requestor instance on new pairs', () => {\n        new RefreshingQuoteRequestor(mockRfqMakerManager, mockAxiosInstance); // tslint:disable-line: no-unused-expression\n\n        expect(QuoteRequestor).toBeCalledTimes(1);\n\n        mockRfqMakerManager.emit(RfqMakerManager.REFRESHED_EVENT);\n\n        expect(QuoteRequestor).toBeCalledTimes(2);\n    });\n\n    describe('requestRfqtIndicativeQuotesAsync', () => {\n        it('passes through arguments to quote requestor', async () => {\n            const refreshingQuoteRequestor = new RefreshingQuoteRequestor(mockRfqMakerManager, mockAxiosInstance);\n\n            await refreshingQuoteRequestor.requestRfqtIndicativeQuotesAsync(\n                '0xmakertoken',\n                '0xtakertoken',\n                /* assetFillAmount */ new BigNumber(100),\n                MarketOperation.Buy,\n                /* comparisonPrice */ undefined,\n                {\n                    integrator: {\n                        allowedChainIds: [],\n                        apiKeys: [],\n                        integratorId: 'uuid-integrator-id',\n                        label: 'integrator',\n                        plp: false,\n                        rfqm: false,\n                        rfqt: true,\n                    },\n                    intentOnFilling: false,\n                    isIndicative: true,\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorign',\n                },\n            );\n\n            const args = mockRequestRfqtIndicativeQuotesAsync.mock.calls[0];\n            expect(args).toMatchInlineSnapshot(`\n                Array [\n                  \"0xmakertoken\",\n                  \"0xtakertoken\",\n                  \"100\",\n                  \"Buy\",\n                  undefined,\n                  Object {\n                    \"integrator\": Object {\n                      \"allowedChainIds\": Array [],\n                      \"apiKeys\": Array [],\n                      \"integratorId\": \"uuid-integrator-id\",\n                      \"label\": \"integrator\",\n                      \"plp\": false,\n                      \"rfqm\": false,\n                      \"rfqt\": true,\n                    },\n                    \"intentOnFilling\": false,\n                    \"isIndicative\": true,\n                    \"takerAddress\": \"0xtakeraddress\",\n                    \"txOrigin\": \"0xtxorign\",\n                  },\n                ]\n            `);\n        });\n    });\n\n    describe('requestRfqtFirmQuotesAsync', () => {\n        it('passes through arguments to quote requestor', async () => {\n            const refreshingQuoteRequestor = new RefreshingQuoteRequestor(mockRfqMakerManager, mockAxiosInstance);\n\n            await refreshingQuoteRequestor.requestRfqtFirmQuotesAsync(\n                '0xmakertoken',\n                '0xtakertoken',\n                /* assetFillAmount */ new BigNumber(100),\n                MarketOperation.Buy,\n                /* comparisonPrice */ undefined,\n                {\n                    integrator: {\n                        allowedChainIds: [],\n                        apiKeys: [],\n                        integratorId: 'uuid-integrator-id',\n                        label: 'integrator',\n                        plp: false,\n                        rfqm: false,\n                        rfqt: true,\n                    },\n                    intentOnFilling: true,\n                    takerAddress: '0xtakeraddress',\n                    txOrigin: '0xtxorign',\n                },\n            );\n\n            const args = mockRequestRfqtFirmQuotesAsync.mock.calls[0];\n            expect(args).toMatchInlineSnapshot(`\n                Array [\n                  \"0xmakertoken\",\n                  \"0xtakertoken\",\n                  \"100\",\n                  \"Buy\",\n                  undefined,\n                  Object {\n                    \"integrator\": Object {\n                      \"allowedChainIds\": Array [],\n                      \"apiKeys\": Array [],\n                      \"integratorId\": \"uuid-integrator-id\",\n                      \"label\": \"integrator\",\n                      \"plp\": false,\n                      \"rfqm\": false,\n                      \"rfqt\": true,\n                    },\n                    \"intentOnFilling\": true,\n                    \"takerAddress\": \"0xtakeraddress\",\n                    \"txOrigin\": \"0xtxorign\",\n                  },\n                ]\n            `);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/QuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/RefreshingQuoteRequestor.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmImplementaionUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmTypes.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/rfqMakerBlacklist.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/MetricsProxyImpl.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/rfq_blocked_address_utils_test.ts",{"fileContent":"import { expect } from 'chai';\nimport { DataSource } from 'typeorm';\n\nimport { ONE_MINUTE_MS } from '../../src/core/constants';\nimport { BlockedAddressEntity } from '../../src/entities/BlockedAddressEntity';\nimport { RfqBlockedAddressUtils } from '../../src/utils/rfq_blocked_address_utils';\nimport { setupDependenciesAsync, TeardownDependenciesFunctionHandle } from '../test_utils/deployment';\nimport { initDbDataSourceAsync } from '../test_utils/initDbDataSourceAsync';\n\nconst ttlMs = 50;\n\n// tslint:disable-next-line: custom-no-magic-numbers\njest.setTimeout(ONE_MINUTE_MS * 2);\nlet teardownDependencies: TeardownDependenciesFunctionHandle;\n\ndescribe('rfqBlockedAddressUtils', () => {\n    let dataSource: DataSource;\n    let rfqBlacklistUtils: RfqBlockedAddressUtils;\n\n    beforeAll(async () => {\n        teardownDependencies = await setupDependenciesAsync(['postgres']);\n        // tslint:disable-next-line: custom-no-magic-numbers\n        dataSource = await initDbDataSourceAsync();\n        rfqBlacklistUtils = new RfqBlockedAddressUtils(dataSource, new Set(), ttlMs);\n    });\n\n    afterAll(async () => {\n        const wasKilled = teardownDependencies();\n        if (!wasKilled) {\n            throw new Error('Dependencies failed to shut down');\n        }\n    });\n\n    beforeEach(async () => {\n        rfqBlacklistUtils = new RfqBlockedAddressUtils(dataSource, new Set(), ttlMs);\n    });\n\n    afterEach(async () => {\n        await dataSource.query('TRUNCATE TABLE blocked_addresses CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_jobs CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_quotes CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_transaction_submissions CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_v2_jobs CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_v2_quotes CASCADE;');\n        await dataSource.query('TRUNCATE TABLE rfqm_v2_transaction_submissions CASCADE;');\n    });\n\n    describe('blocked_addresses table', () => {\n        it('should only allow lower case insertions', async () => {\n            const sampleBadAddress = '0xA10612Ee5432B6395d1F0d6fB2601299a1c64274';\n\n            try {\n                await dataSource.getRepository(BlockedAddressEntity).save({\n                    address: sampleBadAddress,\n                });\n                expect.fail('should throw');\n            } catch (err) {\n                expect(err.message).to.match(/violates check constraint/);\n            }\n\n            try {\n                await dataSource.getRepository(BlockedAddressEntity).save({\n                    address: sampleBadAddress.toLowerCase(),\n                });\n            } catch (err) {\n                expect.fail('lower case should not throw');\n            }\n        });\n    });\n\n    it('should use stale values via isBlocked', async () => {\n        const sampleBadAddress = '0xA10612Ee5432B6395d1F0d6fB2601299a1c64274';\n        expect(rfqBlacklistUtils.isBlocked(sampleBadAddress)).to.equal(false);\n\n        // Add it to the blocked list\n        await dataSource.getRepository(BlockedAddressEntity).save({\n            address: sampleBadAddress.toLowerCase(),\n        });\n\n        expect(rfqBlacklistUtils.isBlocked(sampleBadAddress)).to.equal(false);\n    });\n\n    it('should use fresh values after the update is complete', async () => {\n        const sampleBadAddress = '0xB10612Ee5432B6395d1F0d6fB2601299a1c64274';\n\n        // Add it to the blocked list\n        await dataSource.getRepository(BlockedAddressEntity).save({\n            address: sampleBadAddress.toLowerCase(),\n        });\n\n        // Initally not blocked\n        const isBlocked_t0 = rfqBlacklistUtils.isBlocked(sampleBadAddress);\n        expect(isBlocked_t0).to.equal(false);\n\n        // Await for the update to complete\n        await rfqBlacklistUtils.completeUpdateAsync();\n\n        // Now should be blocked\n        const isBlocked_t1 = rfqBlacklistUtils.isBlocked(sampleBadAddress);\n        expect(isBlocked_t1).to.equal(true);\n    });\n\n    it('should be case insensitive', async () => {\n        const sampleBadAddress = '0xC10612Ee5432B6395d1F0d6fB2601299a1c64274';\n        await dataSource.getRepository(BlockedAddressEntity).save({\n            address: sampleBadAddress.toLowerCase(),\n        });\n\n        // Trigger the update and wait for completion\n        rfqBlacklistUtils.isBlocked(sampleBadAddress);\n        await rfqBlacklistUtils.completeUpdateAsync();\n\n        const isChecksumBlocked = rfqBlacklistUtils.isBlocked(sampleBadAddress);\n        const isLowerCaseBlocked = rfqBlacklistUtils.isBlocked(sampleBadAddress.toLowerCase());\n        const isUpperCaseBlocked = rfqBlacklistUtils.isBlocked(sampleBadAddress.toUpperCase());\n\n        expect(isChecksumBlocked).to.equal(true);\n        expect(isLowerCaseBlocked).to.equal(true);\n        expect(isUpperCaseBlocked).to.equal(true);\n    });\n});\n// tslint:disable-line:max-file-line-count\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blocked_address_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/deployment.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/initDbDataSourceAsync.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/getDbDataSourceAsync.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blocked_address_utils.ts",{"fileContent":"import { Gauge } from 'prom-client';\nimport { Connection } from 'typeorm/connection/Connection';\n\nimport { BlockedAddressEntity } from '../entities/BlockedAddressEntity';\nimport { logger } from '../logger';\n\nconst MAX_SET_SIZE = 5000;\n\nconst RFQ_BLOCKED_ADDRESS_SET_SIZE = new Gauge({\n    name: 'rfq_blocked_address_set_size',\n    help: 'The number of blocked addresses',\n});\n\n/**\n * RfqBlockedAddressUtils helps manage the RFQ blocked addresses\n */\nexport class RfqBlockedAddressUtils {\n    public _blocked: Set<string>;\n    private _expiresAt: number;\n    private _updatePromise: Promise<void> | undefined;\n    private _updating: boolean;\n    private readonly _ttlMs: number;\n\n    constructor(private readonly _connection: Connection, initialBlockedSet: Set<string>, ttlMs: number) {\n        this._blocked = initialBlockedSet;\n        this._ttlMs = ttlMs;\n        this._updating = false;\n        this._expiresAt = Date.now().valueOf(); // cache expires immediately\n    }\n\n    /**\n     * isBlocked returns whether an address is blocked from the cache\n     * NOTE: In the background, it also updates the blocked set if the cache is expired\n     */\n    public isBlocked(address: string): boolean {\n        if (Date.now().valueOf() > this._expiresAt && !this._updating) {\n            // If expired, update in the background\n            this._updatePromise = this._updateBlockedSetAsync();\n        }\n\n        // Return cached value, even if stale\n        return this._blocked.has(address.toLowerCase());\n    }\n\n    /**\n     * completeUpdateAsync returns a Promise that resolves when the blocked address cache is updated\n     */\n    public async completeUpdateAsync(): Promise<void> {\n        if (this._updatePromise) {\n            return this._updatePromise;\n        }\n    }\n\n    /**\n     * Updates the blocked set of addresses\n     */\n    private async _updateBlockedSetAsync(): Promise<void> {\n        this._updating = true;\n        const blockedAddresses = await this._connection\n            .getRepository(BlockedAddressEntity)\n            .find({ take: MAX_SET_SIZE });\n\n        RFQ_BLOCKED_ADDRESS_SET_SIZE.set(blockedAddresses.length);\n        if (blockedAddresses.length >= MAX_SET_SIZE) {\n            logger.warn('Blocked address table has hit or exceeded the limit');\n        }\n        this._blocked = new Set(blockedAddresses.map((entity) => entity.address.toLowerCase()));\n        this._expiresAt = Date.now().valueOf() + this._ttlMs;\n        this._updating = false;\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/config_manager_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\n// tslint:disable:no-empty\n// tslint:disable:max-file-line-count\n\nimport { expect } from 'chai';\n\nimport { DEFAULT_FEE_MODEL_CONFIGURATION } from '../../src/config';\nimport { ConfigManager } from '../../src/utils/config_manager';\n\ndescribe('ConfigManager', () => {\n    describe('getRfqMakerIdForApiKey', () => {\n        it('should return correct maker Ids', () => {\n            // Given\n            const configManager = new ConfigManager();\n            // Facts defined in test_env file\n            const apiKeyToMakerIds = [\n                {\n                    apiKey: 'd2ed029a-a8a6-48af-9934-bcf3ce07cddf',\n                    makerId: 'degen-trading',\n                },\n                {\n                    apiKey: '03da31bd-cbd9-4167-932d-11b054d02832',\n                    makerId: 'tradfi-finance',\n                },\n                {\n                    apiKey: '16a35054-d41f-46b0-83bb-166015aaf86e',\n                    makerId: 'i-love-rfqorder',\n                },\n            ];\n\n            apiKeyToMakerIds.forEach((apiKeyIdPair) => {\n                // When\n                const makerId = configManager.getRfqMakerIdForApiKey(apiKeyIdPair.apiKey);\n\n                // Then\n                expect(makerId).to.be.eq(apiKeyIdPair.makerId);\n            });\n        });\n\n        it('should ignore conflict api key', () => {\n            // Given\n            const configManager = new ConfigManager();\n            // Facts defined in test_env file\n            const conflictApiKey = 'bc5dfd4c-580f-475f-aa7e-611cbb6d70cd';\n\n            // When\n            const makerIdForConflictKey = configManager.getRfqMakerIdForApiKey(conflictApiKey);\n\n            // Then\n            expect(makerIdForConflictKey).to.be.eq(undefined);\n        });\n\n        it('should ignore unknown api key', () => {\n            // Given\n            const configManager = new ConfigManager();\n            const unknownApiKey = '7825fbc1-9b7d-4ba7-9237-2f1ec971cf20';\n\n            // When\n            const makerIdForUnknownKey = configManager.getRfqMakerIdForApiKey(unknownApiKey);\n\n            // Then\n            expect(makerIdForUnknownKey).to.be.eq(undefined);\n        });\n    });\n    describe('getFeeModelConfiguration', () => {\n        const chainId = 1;\n        const tokenA = '0x374a16f5e686c09b0cc9e8bc3466b3b645c74aa7';\n        const tokenB = '0xf84830b73b2ed3c7267e7638f500110ea47fdf30';\n        const unknownToken = '0xf84830b73b2ed3c7267e7638f500110ea47fdf31';\n        const marginRakeRatio = 0.4;\n        const tradeSizeBps = 5;\n\n        it('should find fee model config for given pairs', () => {\n            // Given\n            const configManager = new ConfigManager();\n\n            // When\n            const feeModelConfig = configManager.getFeeModelConfiguration(chainId, tokenA, tokenB);\n\n            // Then\n            expect(feeModelConfig.marginRakeRatio).to.be.eq(marginRakeRatio);\n            expect(feeModelConfig.tradeSizeBps).to.be.eq(tradeSizeBps);\n        });\n\n        it('should ignore tokens order when looking for fee model config', () => {\n            // Given\n            const configManager = new ConfigManager();\n\n            // When\n            const feeModelConfig = configManager.getFeeModelConfiguration(chainId, tokenB, tokenA);\n\n            // Then\n            expect(feeModelConfig.marginRakeRatio).to.be.eq(marginRakeRatio);\n            expect(feeModelConfig.tradeSizeBps).to.be.eq(tradeSizeBps);\n        });\n\n        it('should return default fee model config when chainId is not found', () => {\n            // Given\n            const configManager = new ConfigManager();\n\n            // When\n            const feeModelConfig = configManager.getFeeModelConfiguration(137, tokenA, tokenB);\n\n            // Then\n            expect(feeModelConfig.marginRakeRatio).to.be.eq(DEFAULT_FEE_MODEL_CONFIGURATION.marginRakeRatio);\n            expect(feeModelConfig.tradeSizeBps).to.be.eq(DEFAULT_FEE_MODEL_CONFIGURATION.tradeSizeBps);\n        });\n\n        it('should return default fee model config when chainId is not found', () => {\n            // Given\n            const configManager = new ConfigManager();\n\n            // When\n            const feeModelConfig = configManager.getFeeModelConfiguration(chainId, tokenA, unknownToken);\n\n            // Then\n            expect(feeModelConfig.marginRakeRatio).to.be.eq(DEFAULT_FEE_MODEL_CONFIGURATION.marginRakeRatio);\n            expect(feeModelConfig.tradeSizeBps).to.be.eq(DEFAULT_FEE_MODEL_CONFIGURATION.tradeSizeBps);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/services/rfq_admin_service_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\n\nimport { OtcOrder } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport { expect } from 'chai';\nimport { anything, deepEqual, instance, mock, verify, when } from 'ts-mockito';\n\nimport { ONE_SECOND_MS, ZERO } from '../../src/core/constants';\nimport { RfqmV2JobEntity } from '../../src/entities';\nimport { RfqmJobStatus } from '../../src/entities/types';\nimport { RfqAdminService } from '../../src/services/rfq_admin_service';\nimport { otcOrderToStoredOtcOrder, RfqmDbUtils } from '../../src/utils/rfqm_db_utils';\n\ndescribe('RFQ Admin Service Logic', () => {\n    describe('cleanupJobsAsync', () => {\n        const expiry = new BigNumber(Date.now() - 1_000_000).dividedBy(ONE_SECOND_MS).decimalPlaces(0);\n        const otcOrder = new OtcOrder({\n            txOrigin: '0x0000000000000000000000000000000000000000',\n            taker: '0x1111111111111111111111111111111111111111',\n            maker: '0x2222222222222222222222222222222222222222',\n            makerToken: '0x3333333333333333333333333333333333333333',\n            takerToken: '0x4444444444444444444444444444444444444444',\n            expiryAndNonce: OtcOrder.encodeExpiryAndNonce(expiry, ZERO, expiry),\n            chainId: 1337,\n            verifyingContract: '0x0000000000000000000000000000000000000000',\n        });\n        const BASE_JOB = new RfqmV2JobEntity({\n            chainId: 1337,\n            expiry,\n            makerUri: '',\n            orderHash: '0x00',\n            fee: {\n                token: '0xToken',\n                amount: '100',\n                type: 'fixed',\n            },\n            order: otcOrderToStoredOtcOrder(otcOrder),\n        });\n        it('should clean up stuck jobs', async () => {\n            const job = new RfqmV2JobEntity({ ...BASE_JOB, status: RfqmJobStatus.PendingProcessing });\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n            when(dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(anything())).thenResolve([]);\n            const adminService = new RfqAdminService(instance(dbUtilsMock));\n\n            const res = await adminService.cleanupJobsAsync(['0x00']);\n\n            expect(res.modifiedJobs[0]).to.equal(BASE_JOB.orderHash);\n            verify(\n                dbUtilsMock.updateRfqmJobAsync(\n                    deepEqual(new RfqmV2JobEntity({ ...BASE_JOB, status: RfqmJobStatus.FailedExpired })),\n                ),\n            ).called();\n        });\n        it('should not modify unexpired jobs', async () => {\n            const job = new RfqmV2JobEntity({\n                ...BASE_JOB,\n                status: RfqmJobStatus.PendingProcessing,\n                expiry: new BigNumber(Date.now() + 60_000).dividedBy(ONE_SECOND_MS).decimalPlaces(0),\n            });\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n            when(dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(anything())).thenResolve([]);\n            const adminService = new RfqAdminService(instance(dbUtilsMock));\n\n            const res = await adminService.cleanupJobsAsync(['0x00']);\n\n            expect(res.unmodifiedJobs[0]).to.equal(BASE_JOB.orderHash);\n            verify(dbUtilsMock.updateRfqmJobAsync(anything())).never();\n        });\n        it('should not modify resolved jobs', async () => {\n            const job = new RfqmV2JobEntity({ ...BASE_JOB, status: RfqmJobStatus.FailedExpired });\n            const dbUtilsMock = mock(RfqmDbUtils);\n            when(dbUtilsMock.findV2JobByOrderHashAsync(anything())).thenResolve(job);\n            when(dbUtilsMock.findV2TransactionSubmissionsByOrderHashAsync(anything())).thenResolve([]);\n            const adminService = new RfqAdminService(instance(dbUtilsMock));\n\n            const res = await adminService.cleanupJobsAsync(['0x00']);\n\n            expect(res.unmodifiedJobs[0]).to.equal(BASE_JOB.orderHash);\n            verify(dbUtilsMock.updateRfqmJobAsync(anything())).never();\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_admin_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/BlockedAddressEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/KeyValueEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/LastLookRejectionCooldownsEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MakerBalanceChainCacheEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/MetaTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/OrderWatcherSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/PersistentSignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmJobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmQuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmTransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2JobEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2QuoteEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmV2TransactionSubmissionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqmWorkerHeartbeatEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMaker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/RfqMakerUpdateTimeHash.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/SignedOrderV4Entity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/entities/TransactionEntity.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/ZeroExApiClientTest.ts",{"fileContent":"// tslint:disable: custom-no-magic-numbers\nimport { BigNumber } from '@0x/utils';\nimport Axios, { AxiosInstance } from 'axios';\nimport AxiosMockAdapter from 'axios-mock-adapter';\nimport * as HttpStatus from 'http-status-codes';\n\nimport { ZeroExApiClient } from '../../src/utils/ZeroExApiClient';\n\nlet axiosClient: AxiosInstance;\nlet axiosMock: AxiosMockAdapter;\n\ndescribe('ZeroExApiClient', () => {\n    beforeAll(() => {\n        axiosClient = Axios.create();\n        axiosMock = new AxiosMockAdapter(axiosClient);\n    });\n\n    afterEach(() => {\n        axiosMock.reset();\n    });\n\n    describe('fetchAmmQuoteAsync', () => {\n        it('returns the AMM quote from 0x API', async () => {\n            const zeroExApiClient = new ZeroExApiClient(axiosClient, 'api-key-for-rfq', {\n                chainId: 1,\n                zeroExClientBaseUrl: 'http://0x-chain-id-1',\n            });\n\n            axiosMock.onGet('http://0x-chain-id-1/swap/v1/quote').replyOnce(HttpStatus.OK, {\n                buyAmount: '2040568023',\n                sellAmount: '1000000000000000000',\n                estimatedGas: '126183',\n                gasPrice: '73000000000',\n                expectedSlippage: '-0.0004065694347781162427479482993648',\n                decodedUniqueId: 'a-quoteid-with-timestamp',\n            });\n\n            const ammQuote = await zeroExApiClient.fetchAmmQuoteAsync({\n                makerToken: 'tokenB',\n                takerToken: 'tokenA',\n                takerAmount: new BigNumber('1000000000000000000'),\n                affiliateAddress: 'rfq-affiliate-address',\n            });\n\n            expect(axiosMock.history.get[0].headers['0x-api-key']).toBe('api-key-for-rfq');\n            expect(axiosMock.history.get[0].params).toEqual({\n                buyToken: 'tokenB',\n                sellToken: 'tokenA',\n                sellAmount: '1000000000000000000',\n                affiliateAddress: 'rfq-affiliate-address',\n                excludedSources: '0x',\n            });\n            expect(ammQuote?.makerAmount.toString()).toEqual('2040568023');\n            expect(ammQuote?.takerAmount.toString()).toEqual('1000000000000000000');\n            expect(ammQuote?.estimatedGasFeeWei.toString()).toEqual('9211359000000000');\n            expect(ammQuote?.expectedSlippage.toString()).toEqual('-0.0004065694347781162427479482993648');\n            expect(ammQuote?.decodedUniqueId).toEqual('a-quoteid-with-timestamp');\n        });\n\n        it('returns null when 0x API returns an error', async () => {\n            const zeroExApiClient = new ZeroExApiClient(axiosClient, 'api-key-for-rfq', {\n                chainId: 1,\n                zeroExClientBaseUrl: 'http://0x-chain-id-1',\n            });\n\n            axiosMock.onGet('http://0x-chain-id-1/swap/v1/quote').replyOnce(HttpStatus.INTERNAL_SERVER_ERROR);\n\n            const ammQuote = await zeroExApiClient.fetchAmmQuoteAsync({\n                makerToken: 'tokenB',\n                takerToken: 'tokenA',\n                takerAmount: new BigNumber('1000000000000000000'),\n            });\n            expect(ammQuote).toEqual(null);\n        });\n\n        it('returns null when 0x API returns unexpected response body', async () => {\n            const zeroExApiClient = new ZeroExApiClient(axiosClient, 'api-key-for-rfq', {\n                chainId: 1,\n                zeroExClientBaseUrl: 'http://0x-chain-id-1',\n            });\n\n            axiosMock.onGet('http://0x-chain-id-1/swap/v1/quote').replyOnce(HttpStatus.OK, {\n                // Missing buyAmount\n                sellAmount: '1000000000000000000',\n                estimatedGas: '126183',\n                gasPrice: '73000000000',\n                expectedSlippage: '-0.0004065694347781162427479482993648',\n                decodedUniqueId: 'a-quoteid-with-timestamp',\n            });\n\n            const ammQuote = await zeroExApiClient.fetchAmmQuoteAsync({\n                makerToken: 'tokenB',\n                takerToken: 'tokenA',\n                takerAmount: new BigNumber('1000000000000000000'),\n            });\n            expect(ammQuote).toEqual(null);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/types.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/GasOracleTest.ts",{"fileContent":"import Axios, { AxiosInstance } from 'axios';\nimport AxiosMockAdapter from 'axios-mock-adapter';\nimport { expect } from 'chai';\nimport * as HttpStatus from 'http-status-codes';\n\nimport { GasOracle } from '../../src/utils/GasOracle';\n\nconst fakeEip1559Response = {\n    result: {\n        source: 'MEDIAN',\n        timestamp: 1649113582,\n        instant: {\n            price: 80000000000,\n            maxPriorityFeePerGas: 2000000000,\n            maxFeePerGas: 158770000000,\n            baseFeePerGas: 78383362949,\n        },\n        fast: {\n            price: 79000000000,\n            maxPriorityFeePerGas: 1500000000,\n            maxFeePerGas: 158270000000,\n            baseFeePerGas: 78383362949,\n        },\n        standard: {\n            price: 79000000000,\n            maxPriorityFeePerGas: 1500000000,\n            maxFeePerGas: 158270000000,\n            baseFeePerGas: 78383362949,\n        },\n        low: {\n            price: 79000000000,\n            maxPriorityFeePerGas: 1240000000,\n            maxFeePerGas: 158000000000,\n            baseFeePerGas: 78383362949,\n        },\n    },\n};\n\nlet axiosClient: AxiosInstance;\nlet axiosMock: AxiosMockAdapter;\n\ndescribe('GasOracle', () => {\n    beforeAll(() => {\n        axiosClient = Axios.create();\n        axiosMock = new AxiosMockAdapter(axiosClient);\n    });\n\n    describe('create', () => {\n        it('parses the legacy URL', async () => {\n            axiosMock.onGet(`http://gas-price-oracle-svc.gas-price-oracle/v2/source/median`).replyOnce(HttpStatus.OK);\n\n            const gasOracle = GasOracle.create(\n                'http://gas-price-oracle-svc.gas-price-oracle/source/median?output=eth_gas_station',\n                axiosClient,\n            );\n            try {\n                await gasOracle.getBaseFeePerGasWeiAsync();\n            } catch {\n                // This will fail since we're not faking a valid response.\n                // Just want to make sure the right URL is being called.\n            }\n            expect(axiosMock.history.get[0].url).to.equal(\n                'http://gas-price-oracle-svc.gas-price-oracle/v2/source/median',\n            );\n        });\n    });\n\n    describe('getBaseFeePerGasWeiAsync', () => {\n        it('gets the base fee', async () => {\n            axiosMock\n                .onGet(`http://gas-price-oracle-svc.gas-price-oracle/v2/source/median`)\n                .replyOnce(HttpStatus.OK, fakeEip1559Response);\n\n            const gasOracle = GasOracle.create(\n                'http://gas-price-oracle-svc.gas-price-oracle/v2/source/median',\n                axiosClient,\n            );\n\n            const baseFee = await gasOracle.getBaseFeePerGasWeiAsync();\n            expect(baseFee.toString()).equals('78383362949');\n        });\n    });\n\n    describe('getMaxPriorityFeePerGasWeiAsync', () => {\n        it('gets the max priority fee', async () => {\n            axiosMock\n                .onGet(`http://gas-price-oracle-svc.gas-price-oracle/v2/source/median`)\n                .replyOnce(HttpStatus.OK, fakeEip1559Response);\n\n            const gasOracle = GasOracle.create(\n                'http://gas-price-oracle-svc.gas-price-oracle/v2/source/median',\n                axiosClient,\n            );\n\n            const baseFee = await gasOracle.getMaxPriorityFeePerGasWeiAsync('low');\n            expect(baseFee.toString()).equals('1240000000');\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracle.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/background_jobs_integration_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\nimport { Queue, Worker } from 'bullmq';\nimport Redis from 'ioredis';\n\nimport backgroundJobNoOp from '../src/background-jobs/no_op';\nimport { REDIS_BACKGROUND_JOB_URI } from '../src/config';\nimport { ONE_SECOND_MS } from '../src/core/constants';\nimport { ScheduledBackgroundJob, Scheduler } from '../src/scheduler';\nimport { closeRedisConnectionsAsync, closeWorkersAsync } from '../src/utils/runner_utils';\n\nimport { setupDependenciesAsync, TeardownDependenciesFunctionHandle } from './test_utils/deployment';\n\njest.setTimeout(ONE_SECOND_MS * 60);\nlet teardownDependencies: TeardownDependenciesFunctionHandle;\nlet redisConnections: Redis[] = [];\nlet workers: Worker[] = [];\nlet scheduler: Scheduler;\n\ndescribe('Background jobs integration tests', () => {\n    beforeEach(async () => {\n        teardownDependencies = await setupDependenciesAsync(['redis']);\n    });\n\n    afterEach(async () => {\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const connection = new Redis(REDIS_BACKGROUND_JOB_URI!);\n        const keys = await connection.keys('bull:*');\n        if (keys.length) {\n            await connection.del(keys);\n        }\n        await closeWorkersAsync(workers);\n        await closeRedisConnectionsAsync(redisConnections);\n        redisConnections = [];\n        workers = [];\n        await Scheduler.shutdownAsync();\n        if (!teardownDependencies()) {\n            throw new Error('Failed to tear down dependencies');\n        }\n    });\n\n    describe('no-op job', () => {\n        it('no-op job should be scheduled and processed', async () => {\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const connection = new Redis(REDIS_BACKGROUND_JOB_URI!, {\n                maxRetriesPerRequest: null,\n                enableReadyCheck: false,\n            });\n            // clean up keys related to bullmq\n            const keys = await connection.keys('bull:*');\n            if (keys.length) {\n                await connection.del(keys);\n            }\n\n            const noOpBackgroundJobQueue = new Queue(backgroundJobNoOp.queueName, { connection });\n\n            const schedule: ScheduledBackgroundJob[] = [\n                {\n                    schedule: backgroundJobNoOp.schedule,\n                    func: async () => {\n                        await backgroundJobNoOp.createAsync(noOpBackgroundJobQueue, { timestamp: Date.now() });\n                    },\n                },\n            ];\n\n            scheduler = new Scheduler(schedule);\n            scheduler.start();\n            const { queueName, processAsync } = backgroundJobNoOp;\n            const worker = new Worker(queueName, processAsync, { connection });\n\n            redisConnections = [connection];\n            workers = [worker];\n\n            await new Promise((resolve) => setTimeout(resolve, ONE_SECOND_MS * 15));\n            expect(await noOpBackgroundJobQueue.getCompletedCount()).toEqual(1);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/background-jobs/no_op.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/scheduler.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/runner_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/deployment.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/background-jobs/blueprint.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/test_utils/initDbDataSourceAsync.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/background-jobs/no_op.ts",{"fileContent":"import { Job, Queue } from 'bullmq';\nimport { Counter } from 'prom-client';\n\nimport { ONE_SECOND_MS } from '../core/constants';\nimport { logger } from '../logger';\n\nimport { BackgroundJobBlueprint } from './blueprint';\n\nconst QUEUE_NAME = 'no-op';\nconst REMOVE_ON_COMPLETE_OPS = {\n    count: 100,\n};\nconst REMOVE_ON_FAILURE_OPS = {\n    count: 100,\n};\nconst NO_OP_SCHEDULE = '*/5 * * * *'; // job will be scheduled at every 5 minutes\nconst DESCRIPTION = 'A no-op background job that would sleep and increase the counter. This job is used for testing';\n\nexport interface BackgroundJobNoOpData {\n    timestamp: number;\n}\n\nexport interface BackgroundJobNoOpResult {\n    jobName: string;\n    timestamp: number;\n}\n\nconst backgroundJobNoOp: BackgroundJobBlueprint<BackgroundJobNoOpData, BackgroundJobNoOpResult> = {\n    queueName: QUEUE_NAME,\n    schedule: NO_OP_SCHEDULE,\n    description: DESCRIPTION,\n    createAsync,\n    processAsync,\n};\n// tslint:disable-next-line: no-default-export\nexport default backgroundJobNoOp;\n\nconst NO_OP_PROCESS_COUNT = new Counter({\n    name: 'rfq_background_job_no_op_process_total',\n    help: 'Number of times the processor method of the no-op background job is triggered',\n});\n\n/**\n * Create a no-op background job by pushing a message to the correponding queue with associated data.\n *\n * @param queue Queue to push the message.\n * @param data Necessary data for processor to execute the no-op background job.\n * @returns Promise of the no-op background job.\n */\nasync function createAsync(\n    queue: Queue,\n    data: BackgroundJobNoOpData,\n): Promise<Job<BackgroundJobNoOpData, BackgroundJobNoOpResult>> {\n    logger.info({ queue: QUEUE_NAME, data }, 'Creating the no-op background job on queue');\n    return queue.add(`${QUEUE_NAME}.${data.timestamp}`, data, {\n        removeOnComplete: REMOVE_ON_COMPLETE_OPS,\n        removeOnFail: REMOVE_ON_FAILURE_OPS,\n    });\n}\n\n/**\n * Processor method for the no-op background job. Print log, sleep and increase the counter.\n *\n * @param job The no-op background job to process.\n * @returns Result of the no-op background job.\n */\nasync function processAsync(\n    job: Job<BackgroundJobNoOpData, BackgroundJobNoOpResult>,\n): Promise<BackgroundJobNoOpResult> {\n    await job.updateProgress(0);\n    logger.info(\n        { jobName: job.name, queue: job.queueName, data: job.data, timestamp: Date.now() },\n        'Processing the no-op background job on queue',\n    );\n    // tslint:disable:custom-no-magic-numbers\n    // sleep for 5 seconds\n    await new Promise((resolve) => setTimeout(resolve, ONE_SECOND_MS * 5));\n    await job.updateProgress(50);\n    // sleep for 5 seconds\n    await new Promise((resolve) => setTimeout(resolve, ONE_SECOND_MS * 5));\n    NO_OP_PROCESS_COUNT.inc();\n    await job.updateProgress(100);\n    return {\n        jobName: job.name,\n        timestamp: Date.now(),\n    };\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/background-jobs/blueprint.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/scheduler.ts",{"fileContent":"import { gracefulShutdown, scheduleJob } from 'node-schedule';\n\nimport { logger } from './logger';\n\nexport interface ScheduledBackgroundJob {\n    schedule: string; // cron style string to indicate scheduling frequency\n    func: () => Promise<void>; // function to be scheduled\n}\n\nexport class Scheduler {\n    /**\n     * Shutdown the scheduler.\n     */\n    public static async shutdownAsync(): Promise<void> {\n        try {\n            await gracefulShutdown();\n        } catch (error) {\n            logger.error({ errorMessage: error.message, stack: error.stack }, 'Error shuting down job scheduler');\n            throw error;\n        }\n    }\n    constructor(private readonly jobs: ScheduledBackgroundJob[]) {}\n\n    /**\n     * Schedule all background jobs.\n     */\n    public start(): void {\n        for (const job of this.jobs) {\n            try {\n                logger.info({ schedule: job.schedule }, 'Scheduling background job');\n                // Schedule the job the invoke immediately\n                scheduleJob(job.schedule, job.func).invoke();\n            } catch (error) {\n                logger.error(\n                    { schedule: job.schedule, errorMessage: error.message, stack: error.stack },\n                    'Error scheduling background job',\n                );\n                throw error;\n            }\n        }\n    }\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/signature_utils_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\n// tslint:disable:max-file-line-count\n\nimport { eip712SignTypedDataWithKey, ethSignHashWithKey, LimitOrder, OtcOrder } from '@0x/protocol-utils';\nimport { expect } from 'chai';\n\nimport { getSignerFromHash, padSignature } from '../../src/utils/signature_utils';\n\nconst address = '0xdA9AC423442169588DE6b4305f4E820D708d0cE5';\nconst privateKey = '0x653fa328df81be180b58e42737bc4cef037a19a3b9673b15d20ee2eebb2e509d';\n\ndescribe('Signature utils', () => {\n    describe('getSignerFromHash', () => {\n        it('should recover an address for an EthSign Signature', () => {\n            // Given\n            const otcOrder = new OtcOrder();\n            const orderHash = otcOrder.getHash();\n            const signature = ethSignHashWithKey(orderHash, privateKey);\n\n            // When\n            const signer = getSignerFromHash(orderHash, signature);\n\n            // Then\n            expect(signer).to.equal(address.toLowerCase());\n        });\n\n        it('should recover an address for an EIP712 Signature', () => {\n            // Given\n            const otcOrder = new OtcOrder();\n            const orderHash = otcOrder.getHash();\n            const signature = eip712SignTypedDataWithKey(otcOrder.getEIP712TypedData(), privateKey);\n\n            // When\n            const signer = getSignerFromHash(orderHash, signature);\n\n            // Then\n            expect(signer).to.equal(address.toLowerCase());\n        });\n\n        it('should not recover an address when signature is for something else', () => {\n            // Given\n            const limitOrder = new LimitOrder();\n            const limitOrderHash = limitOrder.getHash();\n            const signatureForLimitOrder = ethSignHashWithKey(limitOrderHash, privateKey);\n\n            const otcOrder = new OtcOrder();\n            const otcOrderHash = otcOrder.getHash();\n\n            // When\n            const signer = getSignerFromHash(otcOrderHash, signatureForLimitOrder);\n\n            // Then\n            expect(signer.toLowerCase()).to.not.eq(address.toLowerCase());\n        });\n    });\n    describe('padSignature', () => {\n        it(\"doesn't modify valid signatures\", () => {\n            const validSignature = {\n                r: '0x9168c21566a9846ad80ef8c27a199d4855a5245dfee5e9453300e6dd5d659ca6',\n                s: '0x0c74487fba706194d030cce9c8b5d712e698326731f4e6d603251b7a1eeca084',\n                v: 28,\n                signatureType: 3,\n            };\n\n            const result = padSignature(validSignature);\n\n            expect(validSignature).to.deep.equal(result);\n        });\n\n        it('pads a signature missing bytes', () => {\n            const signature = {\n                r: '0x59ca6',\n                s: '0Xeca084',\n                v: 28,\n                signatureType: 3,\n            };\n\n            const result = padSignature(signature);\n\n            expect(result).to.deep.equal({\n                r: '0x0000000000000000000000000000000000000000000000000000000000059ca6',\n                s: '0x0000000000000000000000000000000000000000000000000000000000eca084',\n                v: 28,\n                signatureType: 3,\n            });\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/signature_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/config_test.ts",{"fileContent":"// tslint:disable custom-no-magic-numbers\nimport { expect } from 'chai';\n\nimport {\n    getApiKeyWhitelistFromIntegratorsAcl,\n    getIntegratorByIdOrThrow,\n    getIntegratorIdForApiKey,\n    ZERO_EX_FEE_CONFIGURATION_MAP,\n} from '../src/config';\nimport { ZERO_EX_FEE_CONFIGURATIONS } from './constants';\n\n/**\n * Configuration tests which run against the config in `test_env` file.\n */\ndescribe('Config', () => {\n    describe('getIntegratorIdForApiKey', () => {\n        it('gets the integrator ID for an api key', () => {\n            const id = getIntegratorIdForApiKey('test-api-key-1');\n\n            expect(id).to.equal('test-integrator-id-1');\n        });\n\n        it('correctly parses whitelist', () => {\n            try {\n                getIntegratorByIdOrThrow('test-integrator-id-2');\n                expect.fail(`\"test-integrator-id-2\" should not exist`);\n            } catch (e) {\n                expect(e.toString()).to.equal('AssertionError: \"test-integrator-id-2\" should not exist');\n            }\n        });\n\n        it('allows us to fetch Integrator by Integrator key', () => {\n            const { whitelistIntegratorUrls } = getIntegratorByIdOrThrow('test-integrator-id-1');\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            expect(whitelistIntegratorUrls!.length).to.eql(1);\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            expect(whitelistIntegratorUrls![0]).to.eql('http://foo.bar');\n        });\n\n        it('returns `undefined` for non-existent api keys', () => {\n            const id = getIntegratorIdForApiKey('test-api-key-does-not-exist');\n            expect(id).to.equal(undefined);\n        });\n    });\n\n    describe('getApiKeyWhitelistFromIntegratorsAcl', () => {\n        it('gets keys for allowed liquidity sources', () => {\n            const rfqtKeys = getApiKeyWhitelistFromIntegratorsAcl('rfqt');\n            expect(rfqtKeys.length).to.eql(2);\n            expect(rfqtKeys[0]).to.eql('test-api-key-1');\n            expect(rfqtKeys[1]).to.eql('test-api-key-2');\n\n            const rfqmKeys = getApiKeyWhitelistFromIntegratorsAcl('rfqm');\n            expect(rfqmKeys.length).to.eql(3); // tslint:disable-line: custom-no-magic-numbers\n            expect(rfqmKeys[0]).to.eql('test-api-key-1');\n            expect(rfqmKeys[1]).to.eql('test-api-key-2');\n            expect(rfqmKeys[2]).to.eql('test-api-key-3');\n        });\n        it(\"doesn't add disallowed liquidity sources to allowed API keys\", () => {\n            const plpKeys = getApiKeyWhitelistFromIntegratorsAcl('plp');\n            expect(plpKeys.length).to.equal(0);\n        });\n    });\n\n    describe('ZERO_EX_FEE_CONFIGURATION_MAP', () => {\n        it('correctly processes raw 0x fee config', () => {\n            expect(ZERO_EX_FEE_CONFIGURATION_MAP).to.be.eql(ZERO_EX_FEE_CONFIGURATIONS);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schemas/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/schema_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/rfqm_gas_estimate_utils_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\n// tslint:disable:max-file-line-count\n\nimport { expect } from 'chai';\n\nimport { RFQM_TX_GAS_ESTIMATE } from '../../src/core/constants';\nimport { calculateGasEstimate } from '../../src/utils/rfqm_gas_estimate_utils';\n\ndescribe('RFQM Gas Estimate utils', () => {\n    describe('calculateGasEstimate', () => {\n        it('should return base gas estimate if neither tokens have premiums', () => {\n            const makerToken = '';\n            const takerToken = '';\n\n            const result = calculateGasEstimate(makerToken, takerToken, 'rfq', false);\n\n            expect(result).to.equal(RFQM_TX_GAS_ESTIMATE);\n        });\n\n        it('should add a token premium for maker token', () => {\n            const makerToken = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48';\n            const takerToken = '';\n\n            const result = calculateGasEstimate(makerToken, takerToken, 'rfq', false);\n\n            expect(result).to.be.greaterThan(RFQM_TX_GAS_ESTIMATE);\n        });\n\n        it('should add a token premium for taker token', () => {\n            const makerToken = '';\n            const takerToken = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48';\n\n            const result = calculateGasEstimate(makerToken, takerToken, 'rfq', false);\n\n            expect(result).to.be.greaterThan(RFQM_TX_GAS_ESTIMATE);\n        });\n\n        it('token premiums for maker and taker token should be additive', () => {\n            const unknown = '';\n            const USDC = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48';\n            const USDT = '0xdac17f958d2ee523a2206206994597c13d831ec7';\n\n            const result1 = calculateGasEstimate(USDC, unknown, 'rfq', false);\n            const result2 = calculateGasEstimate(USDC, USDT, 'rfq', false);\n\n            expect(result2).to.be.greaterThan(result1);\n        });\n\n        it('should be case insensitive to the input tokens', () => {\n            const unknown = '';\n            const USDC_uppercase = '0xA0B86991C6218B36C1D19D4A2E9EB0CE3606EB48';\n            const USDT_uppercase = '0xDAC17F958D2EE523A2206206994597C13D831EC7';\n\n            const result0 = calculateGasEstimate(unknown, unknown, 'rfq', false);\n            const result1 = calculateGasEstimate(USDC_uppercase, unknown, 'rfq', false);\n            const result2 = calculateGasEstimate(USDC_uppercase, USDT_uppercase, 'rfq', false);\n\n            expect(result1).to.be.greaterThan(result0);\n            expect(result2).to.be.greaterThan(result1);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_gas_estimate_utils.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/rfqm_worker_test.ts",{"fileContent":"// tslint:disable:custom-no-magic-numbers\n// tslint:disable:no-empty\n// tslint:disable:max-file-line-count\n\nimport { BigNumber } from '@0x/utils';\nimport { Web3Wrapper } from '@0x/web3-wrapper';\nimport { expect } from 'chai';\nimport { BlockParamLiteral } from 'ethereum-types';\nimport { providers } from 'ethers';\nimport { anything, instance, mock, when } from 'ts-mockito';\n\nimport { NULL_ADDRESS, RFQM_TX_GAS_ESTIMATE } from '../../src/core/constants';\nimport { isWorkerReadyAndAbleAsync } from '../../src/utils/rfqm_worker_balance_utils';\n\nlet providerMock: providers.Provider;\n\ndescribe('RFQM Worker balance utils', () => {\n    describe('isWorkerReadyAndAbleAsync', () => {\n        beforeEach(() => {\n            providerMock = mock(providers.Web3Provider);\n        });\n        it('should assess the balance to trade', async () => {\n            when(providerMock.getTransactionCount(NULL_ADDRESS)).thenResolve(0);\n            when(providerMock.getTransactionCount(NULL_ADDRESS, anything())).thenResolve(0);\n            const tests: [BigNumber, BigNumber, boolean][] = [\n                [Web3Wrapper.toBaseUnitAmount(0.5, 18), Web3Wrapper.toBaseUnitAmount(120, 9), true],\n                [Web3Wrapper.toBaseUnitAmount(0.05, 18), Web3Wrapper.toBaseUnitAmount(120, 9), false],\n                [Web3Wrapper.toBaseUnitAmount(0.05, 18), Web3Wrapper.toBaseUnitAmount(100, 9), true],\n            ];\n            for (const test of tests) {\n                const [balance, gasPrice, isSuccessful] = test;\n                expect(\n                    await isWorkerReadyAndAbleAsync(\n                        instance(providerMock),\n                        NULL_ADDRESS,\n                        balance,\n                        gasPrice,\n                        RFQM_TX_GAS_ESTIMATE,\n                    ),\n                ).to.eql(isSuccessful);\n            }\n        });\n        it('should fail with an outstanding transaction', async () => {\n            when(providerMock.getTransactionCount(NULL_ADDRESS)).thenResolve(0);\n            when(providerMock.getTransactionCount(NULL_ADDRESS, BlockParamLiteral.Pending)).thenResolve(1);\n\n            expect(\n                await isWorkerReadyAndAbleAsync(\n                    instance(providerMock),\n                    NULL_ADDRESS,\n                    Web3Wrapper.toBaseUnitAmount(10, 18),\n                    Web3Wrapper.toBaseUnitAmount(120, 9),\n                    RFQM_TX_GAS_ESTIMATE,\n                ),\n            ).to.eql(false);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/rfqm_service_builder_test.ts",{"fileContent":"import { getContractAddressesForChainOrThrow } from '@0x/contract-addresses';\nimport { providers } from 'ethers';\n\nimport { getContractAddressesForNetworkOrThrowAsync } from '../../src/utils/rfqm_service_builder';\n\ndescribe('rfqm_service_builder', () => {\n    describe('getContractAddressesForNetworkOrThrowAsync', () => {\n        describe('when an override for exchange proxy contract address is defined', () => {\n            it('returns an object with the value of `exchangeProxy` set to the override address', async () => {\n                const ethersProvider = new providers.JsonRpcProvider();\n\n                // tslint:disable-next-line:custom-no-magic-numbers\n                const contractAddresses = await getContractAddressesForNetworkOrThrowAsync(ethersProvider, {\n                    chainId: 80001,\n                    exchangeProxyContractAddressOverride: '0x_override_address',\n                });\n                expect(contractAddresses.exchangeProxy).toBe('0x_override_address');\n            });\n        });\n\n        describe('when an override for exchange proxy contract address is NOT defined', () => {\n            it('returns an object with the value of `exchangeProxy` set value got from upstream module', async () => {\n                const ethersProvider = new providers.JsonRpcProvider();\n\n                // tslint:disable-next-line:custom-no-magic-numbers\n                const contractAddresses = await getContractAddressesForNetworkOrThrowAsync(ethersProvider, {\n                    chainId: 80001,\n                });\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const contractAddressesFromUpstreamModule = getContractAddressesForChainOrThrow('80001' as any);\n                expect(contractAddresses.exchangeProxy).toBe(contractAddressesFromUpstreamModule.exchangeProxy);\n            });\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_service_builder.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/fee_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfqm_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_maker_balance_cache_service.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/services/WorkerService.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/config_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasStationAttendantUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/provider_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/quote_server_client.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_blockchain_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_db_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfq_maker_manager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenMetadataManager.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ZeroExApiClient.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/Eip712UtilsTest.ts",{"fileContent":"// tslint:disable: custom-no-magic-numbers\nimport { EIP_712_REGISTRY } from '../../src/eip712registry';\nimport { extractEIP712DomainType } from '../../src/utils/Eip712Utils';\n\ndescribe('extractEIP712DomainType', () => {\n    it('extracts the EIP712Domain type from the domain for the USDC token on polygon', () => {\n        const token = '0x2791bca1f2de4661ed88a30c99a7a9449aa84174'; // USDC\n        const { domain } = EIP_712_REGISTRY[137][token];\n        const result = extractEIP712DomainType(domain);\n        expect(result).toEqual({\n            EIP712Domain: [\n                { name: 'name', type: 'string' },\n                { name: 'version', type: 'string' },\n                { name: 'verifyingContract', type: 'address' },\n                { name: 'salt', type: 'bytes32' },\n            ],\n        });\n    });\n\n    it('extracts the EIP712Domain type from the domain for the BANANA token on polygon', () => {\n        const token = '0x5d47baba0d66083c52009271faf3f50dcc01023c'; // BANANA\n        const { domain } = EIP_712_REGISTRY[137][token];\n        const result = extractEIP712DomainType(domain);\n        expect(result).toEqual({\n            EIP712Domain: [\n                { name: 'name', type: 'string' },\n                { name: 'version', type: 'string' },\n                { name: 'chainId', type: 'uint256' },\n                { name: 'verifyingContract', type: 'address' },\n            ],\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/utils/Eip712Utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/ethereum.json","/Users/davidwalsh/code-local/0x-rfq-api/src/eip712registry/polygon.json"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/logger.test.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\n\nimport { createSwapId } from '../src/logger';\n\ndescribe('logger', () => {\n    describe('createSwapId', () => {\n        it('creates a swap id', () => {\n            const swapParms = {\n                buyAmount: new BigNumber(10000),\n                buyToken: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270',\n                sellToken: '0x9a71012B13CA4d3D0Cdc72A177DF3ef03b0E76A3',\n                takerAddress: '0x4Ea754349AcE5303c82f0d1D491041e042f2ad22',\n            };\n\n            const swapId = createSwapId(swapParms);\n\n            expect(swapId).not.toBeNull();\n            if (!swapId) {\n                throw new Error();\n            }\n            // tslint:disable-next-line: custom-no-magic-numbers\n            expect(swapId).toHaveLength(16);\n            expect(/[0-9A-Fa-f]{16}/.test(swapId)).toBeTruthy();\n        });\n\n        it('returns null if no taker address is present', () => {\n            const swapParms = {\n                buyAmount: new BigNumber(10000),\n                buyToken: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270',\n                sellToken: '0x9a71012B13CA4d3D0Cdc72A177DF3ef03b0E76A3',\n            };\n\n            const swapId = createSwapId(swapParms);\n\n            expect(swapId).toBeNull();\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/logger.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/entities/transformers_test.ts",{"fileContent":"import { FeeTransformer, MetaTransactionTransformer } from '../../src/entities/transformers';\nimport { MOCK_FEE, MOCK_META_TRANSACTION, MOCK_STORED_FEE, MOCK_STORED_META_TRANSACTION } from '../constants';\n\ndescribe('transformers', () => {\n    describe('MetaTransactionTransformer', () => {\n        it('should correctly marshal `MetaTransaction`', async () => {\n            expect(MetaTransactionTransformer.to(MOCK_META_TRANSACTION)).toEqual(MOCK_STORED_META_TRANSACTION);\n        });\n\n        it('should correctly unmarshal `MetaTransaction` stored in db to `MetaTransaction` object', async () => {\n            expect(MetaTransactionTransformer.from(MOCK_STORED_META_TRANSACTION)).toEqual(MOCK_META_TRANSACTION);\n        });\n    });\n\n    describe('FeeTransformer', () => {\n        it('should correctly marshal `Fee`', async () => {\n            expect(FeeTransformer.to(MOCK_FEE)).toEqual(MOCK_STORED_FEE);\n        });\n\n        it('should correctly unmarshal `Fee` stored in db to `Fee` object', async () => {\n            expect(FeeTransformer.from(MOCK_STORED_FEE)).toEqual(MOCK_FEE);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/transformers.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/entities/typesTest.ts",{"fileContent":"import { expect } from 'chai';\n\nimport { RfqmJobStatus, UnresolvedRfqmJobStatuses } from '../../src/entities/types';\n\ndescribe('entity types', () => {\n    describe('UnresolvedJobStatuses', () => {\n        it('should not contain resolved statuses', () => {\n            expect(UnresolvedRfqmJobStatuses).to.not.contain(RfqmJobStatus.SucceededConfirmed);\n            expect(UnresolvedRfqmJobStatuses).to.not.contain(RfqmJobStatus.FailedLastLookDeclined);\n        });\n        it('should contain unresolved statuses', () => {\n            expect(UnresolvedRfqmJobStatuses).to.contain(RfqmJobStatus.FailedRevertedUnconfirmed);\n            expect(UnresolvedRfqmJobStatuses).to.contain(RfqmJobStatus.SucceededUnconfirmed);\n            expect(UnresolvedRfqmJobStatuses).to.contain(RfqmJobStatus.PendingEnqueued);\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/entities/types.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/ProtoUtils.test.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { bigNumberToProto, protoToBigNumber } from '../../src/utils/ProtoUtils';\n\ndescribe('ProtoUtils', () => {\n    describe('bignumber utilities', () => {\n        it('converts bignumber to proto and back', () => {\n            const numbers = [10, -24, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, 2.425335, -3.1412, 42069, NaN];\n            numbers.forEach((n) => {\n                const bn = new BigNumber(n);\n                const proto = bigNumberToProto(bn);\n                const bn2 = protoToBigNumber(proto);\n                expect(bn2.toNumber()).toEqual(n);\n            });\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/ProtoUtils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/proto-ts/big_number_js.pb.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/GasOracleType0Test.ts",{"fileContent":"import Axios, { AxiosInstance } from 'axios';\nimport AxiosMockAdapter from 'axios-mock-adapter';\nimport * as HttpStatus from 'http-status-codes';\n\nimport { GasOracleType0 } from '../../src/utils/GasOracleType0';\n\nconst fakeResponse = {\n    result: {\n        source: 'MEDIAN',\n        timestamp: 1676403824,\n        instant: 353363290000,\n        fast: 353363290000,\n        standard: 353113290000,\n        low: 266513290000,\n    },\n};\n\nlet axiosClient: AxiosInstance;\nlet axiosMock: AxiosMockAdapter;\n\ndescribe('GasOracleType0', () => {\n    beforeAll(() => {\n        axiosClient = Axios.create();\n        axiosMock = new AxiosMockAdapter(axiosClient);\n    });\n\n    describe('create', () => {\n        it('fails for non-default output formats', async () => {\n            expect(() =>\n                GasOracleType0.create(\n                    'http://gas-price-oracle-svc.gas-price-oracle/source/median?output=eth_gas_station',\n                    axiosClient,\n                ),\n            ).toThrow();\n        });\n        it('fails for a v2 URL', async () => {\n            expect(() =>\n                GasOracleType0.create('http://gas-price-oracle-svc.gas-price-oracle/v2/source/median', axiosClient),\n            ).toThrow();\n        });\n    });\n\n    describe('getGasWeiAsync', () => {\n        it('gets the fast gas price', async () => {\n            axiosMock\n                .onGet(`http://gas-price-oracle-svc.gas-price-oracle/source/median`)\n                .replyOnce(HttpStatus.OK, fakeResponse);\n\n            const gasOracle = GasOracleType0.create(\n                'http://gas-price-oracle-svc.gas-price-oracle/source/median',\n                axiosClient,\n            );\n\n            const result = await gasOracle.getGasWeiAsync('fast');\n            expect(result.toString()).toEqual('353363290000');\n        });\n        it('gets the standard gas price', async () => {\n            axiosMock\n                .onGet(`http://gas-price-oracle-svc.gas-price-oracle/source/median`)\n                .replyOnce(HttpStatus.OK, fakeResponse);\n\n            const gasOracle = GasOracleType0.create(\n                'http://gas-price-oracle-svc.gas-price-oracle/source/median',\n                axiosClient,\n            );\n\n            const result = await gasOracle.getGasWeiAsync('standard');\n            expect(result.toString()).toEqual('353113290000');\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType0.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType0.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { AxiosInstance } from 'axios';\nimport { OK } from 'http-status-codes';\n\n/**\n * Response format from e.g. https://gas.polygon.api.0x.org/source/median\n */\nexport interface TMedianResponse {\n    result: {\n        source: 'MEDIAN';\n        timestamp: number; // Unix SECONDS\n        instant: number; // wei\n        fast: number; // wei\n        standard: number; // wei\n        low: number; // wei\n    };\n}\n\nconst TIMEOUT_MS = 250;\n\n/**\n * A client to wrap the functionality of the 0x Gas Price Oracle\n * (https://github.com/0xProject/gas-price-oracle) non-\"v2\" endpoints\n * which return type 0 gas data\n */\nexport class GasOracleType0 {\n    private readonly _url: string;\n    private readonly _axiosInstance: AxiosInstance;\n\n    /**\n     * Creates an instance of `GasOracleType0`.\n     *\n     * Verifies that the URL is of the format\n     * \"http://gas-price-oracle-svc.gas-price-oracle/source/median\", that way\n     * we don't accidentally put in a v2 (EIP1559) URL.\n     */\n    public static create(url: string, axiosInstance: AxiosInstance): GasOracleType0 {\n        const domainRegex = /^https?:\\/\\/[^/]*\\/source\\/median$/;\n        if (!domainRegex.test(url)) {\n            throw new Error(\n                `Error creating GasOracleType0: URL ${url} is not of the expected format.\n                Make sure you aren't trying to use a \"v2\" URL with GasOracleType0`,\n            );\n        }\n        return new GasOracleType0(url, axiosInstance);\n    }\n\n    /**\n     * Fetch the current \"fast\" gas price being reported by the oracle, in WEI\n     */\n    public async getGasWeiAsync(speed: 'instant' | 'fast' | 'standard' | 'low'): Promise<BigNumber> {\n        const response = await this._axiosInstance.get<TMedianResponse>(this._url, {\n            timeout: TIMEOUT_MS,\n        });\n        if (response.status !== OK) {\n            throw new Error('Failed to request base fee from gas price oracle');\n        }\n        try {\n            const gasFee = response.data.result[speed];\n            return new BigNumber(gasFee);\n        } catch (e) {\n            throw new Error(\n                `Response from gas price oracle did not include the expected values:\n                ${e.message} ${JSON.stringify(response.data)}`,\n            );\n        }\n    }\n\n    /**\n     * Constructor is marked `private` to force users to use the static\n     * creator functions, which validate the URL.\n     */\n    private constructor(url: string, axiosInstance: AxiosInstance) {\n        this._axiosInstance = axiosInstance;\n        this._url = url;\n    }\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/utils/GasOracleType2Test.ts",{"fileContent":"import Axios, { AxiosInstance } from 'axios';\nimport AxiosMockAdapter from 'axios-mock-adapter';\nimport * as HttpStatus from 'http-status-codes';\n\nimport { GasOracleType2 } from '../../src/utils/GasOracleType2';\n\nconst fakeEip1559Response = {\n    result: {\n        source: 'MEDIAN',\n        timestamp: 1649113582,\n        instant: {\n            price: 80000000000,\n            maxPriorityFeePerGas: 2000000000,\n            maxFeePerGas: 158770000000,\n            baseFeePerGas: 78383362949,\n        },\n        fast: {\n            price: 79000000000,\n            maxPriorityFeePerGas: 1500000000,\n            maxFeePerGas: 158270000000,\n            baseFeePerGas: 78383362949,\n        },\n        standard: {\n            price: 79000000000,\n            maxPriorityFeePerGas: 1500000000,\n            maxFeePerGas: 158270000000,\n            baseFeePerGas: 78383362949,\n        },\n        low: {\n            price: 79000000000,\n            maxPriorityFeePerGas: 1240000000,\n            maxFeePerGas: 158000000000,\n            baseFeePerGas: 78383362949,\n        },\n    },\n};\n\nlet axiosClient: AxiosInstance;\nlet axiosMock: AxiosMockAdapter;\n\ndescribe('GasOracleType2', () => {\n    beforeAll(() => {\n        axiosClient = Axios.create();\n        axiosMock = new AxiosMockAdapter(axiosClient);\n    });\n\n    describe('create', () => {\n        it('fails for non-default output formats', async () => {\n            expect(() =>\n                GasOracleType2.create(\n                    'http://gas-price-oracle-svc.gas-price-oracle/v2/source/median?output=eth_gas_station',\n                    axiosClient,\n                ),\n            ).toThrow();\n        });\n        it('fails for a v0 URL', async () => {\n            expect(() =>\n                GasOracleType2.create('http://gas-price-oracle-svc.gas-price-oracle/source/median', axiosClient),\n            ).toThrow();\n        });\n    });\n\n    describe('getBaseFeePerGasWeiAsync', () => {\n        it('gets the base fee', async () => {\n            axiosMock\n                .onGet(`http://gas-price-oracle-svc.gas-price-oracle/v2/source/median`)\n                .replyOnce(HttpStatus.OK, fakeEip1559Response);\n\n            const gasOracle = GasOracleType2.create(\n                'http://gas-price-oracle-svc.gas-price-oracle/v2/source/median',\n                axiosClient,\n            );\n\n            const baseFee = await gasOracle.getBaseFeePerGasWeiAsync();\n            expect(baseFee.toString()).toEqual('78383362949');\n        });\n    });\n\n    describe('getMaxPriorityFeePerGasWeiAsync', () => {\n        it('gets the max priority fee', async () => {\n            axiosMock\n                .onGet(`http://gas-price-oracle-svc.gas-price-oracle/v2/source/median`)\n                .replyOnce(HttpStatus.OK, fakeEip1559Response);\n\n            const gasOracle = GasOracleType2.create(\n                'http://gas-price-oracle-svc.gas-price-oracle/v2/source/median',\n                axiosClient,\n            );\n\n            const baseFee = await gasOracle.getMaxPriorityFeePerGasWeiAsync('low');\n            expect(baseFee.toString()).toEqual('1240000000');\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType2.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/GasOracleType2.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { AxiosInstance } from 'axios';\nimport { OK } from 'http-status-codes';\n\n/**\n * Response format from https://github.com/0xProject/gas-price-oracle\n * for \"v2\" endpoints\n */\nexport interface T0xGasPriceOracleResponse {\n    result: TResult;\n}\n\nexport interface TResult {\n    source: string;\n    timestamp: number;\n    instant: TRates;\n    fast: TRates;\n    standard: TRates;\n    low: TRates;\n}\n\nexport interface TRates {\n    price: number;\n    maxPriorityFeePerGas: number;\n    maxFeePerGas: number;\n    baseFeePerGas: number;\n}\n\nconst TIMEOUT_MS = 250;\n\n/**\n * A client to wrap the functionality of the 0x Gas Price Oracle\n * (https://github.com/0xProject/gas-price-oracle) \"v2\" endpoints\n * which provide support for EIP1559\n */\nexport class GasOracleType2 {\n    private readonly _url: string;\n    private readonly _axiosInstance: AxiosInstance;\n\n    /**\n     * Creates an instance of `GasOracleType2`.\n     *\n     * Verifies that the URL is of the format\n     * \"http://gas-price-oracle-svc.gas-price-oracle/v2/source/median\", that way\n     * we don't accidentally put in a v0 URL.\n     */\n    public static create(url: string, axiosInstance: AxiosInstance): GasOracleType2 {\n        const domainRegex = /^https?:\\/\\/[^/]*\\/v2\\/source\\/median$/;\n        if (!domainRegex.test(url)) {\n            throw new Error(\n                `Error creating GasOracleType2: URL ${url} is not of the expected format.\n                Make sure you aren't trying to use a v0 URL with GasOracleType2`,\n            );\n        }\n        return new GasOracleType2(url, axiosInstance);\n    }\n\n    /**\n     * Fetch the current baseFeePerGas being reported by the oracle\n     */\n    public async getBaseFeePerGasWeiAsync(): Promise<BigNumber> {\n        const response = await this._axiosInstance.get<T0xGasPriceOracleResponse>(this._url, {\n            timeout: TIMEOUT_MS,\n        });\n        if (response.status !== OK) {\n            throw new Error('Failed to request base fee from gas price oracle');\n        }\n        try {\n            // All the speed levels have the same base fee, so just use 'instant'\n            const baseFee = response.data.result.instant.baseFeePerGas;\n            return new BigNumber(baseFee);\n        } catch (e) {\n            throw new Error(`Response from gas price oracle did not include the base fee: ${e.message}`);\n        }\n    }\n\n    /**\n     * Fetch the current maxPriorityFeePerGas, aka \"tip\", being reported by the oracle\n     */\n    public async getMaxPriorityFeePerGasWeiAsync(speed: 'instant' | 'fast' | 'standard' | 'low'): Promise<BigNumber> {\n        const response = await this._axiosInstance.get<T0xGasPriceOracleResponse>(this._url, {\n            timeout: TIMEOUT_MS,\n        });\n        if (response.status !== OK) {\n            throw new Error('Failed to request base fee from gas price oracle');\n        }\n        try {\n            const maxPriorityFee = response.data.result[speed].maxPriorityFeePerGas;\n            return new BigNumber(maxPriorityFee);\n        } catch (e) {\n            throw new Error(\n                `Response from gas price oracle did not include the expected maxPriorityFeePerGas: ${e.message}`,\n            );\n        }\n    }\n\n    /**\n     * Constructor is marked `private` to force users to use the static\n     * creator functions, which validate the URL.\n     */\n    private constructor(url: string, axiosInstance: AxiosInstance) {\n        this._axiosInstance = axiosInstance;\n        this._url = url;\n    }\n}\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/assetSwapper.ts",{"fileContent":"/**\n * Types migrated from Asset Swapper\n */\n\nimport { FillQuoteTransformerOrderType, LimitOrderFields, RfqOrderFields, Signature } from '@0x/protocol-utils';\n\nexport enum SwapQuoterError {\n    NoEtherTokenContractFound = 'NO_ETHER_TOKEN_CONTRACT_FOUND',\n    StandardRelayerApiError = 'STANDARD_RELAYER_API_ERROR',\n    InsufficientAssetLiquidity = 'INSUFFICIENT_ASSET_LIQUIDITY',\n    AssetUnavailable = 'ASSET_UNAVAILABLE',\n    NoGasPriceProvidedOrEstimated = 'NO_GAS_PRICE_PROVIDED_OR_ESTIMATED',\n    AssetDataUnsupported = 'ASSET_DATA_UNSUPPORTED',\n}\n\nexport interface SignedOrder<T> {\n    order: T;\n    type: FillQuoteTransformerOrderType.Limit | FillQuoteTransformerOrderType.Rfq;\n    signature: Signature;\n}\nexport type SignedNativeOrder = SignedOrder<LimitOrderFields> | SignedOrder<RfqOrderFields>;\n","resolvedModuleNames":[]}],["/Users/davidwalsh/code-local/0x-rfq-api/src/quoteRequestor/altMmTypes.ts",{"fileContent":"/**\n * Alternate Market Maker types.\n * See: https://github.com/0xProject/protocol/blob/2fdca24d4e09bcf6a2aefb027099e9c0703a8052/packages/asset-swapper/src/types.ts\n */\n\nimport { TakerRequestQueryParamsUnnested, V4SignedRfqOrder } from '../quote-server/types';\n\n/**\n * Represents a mocked RFQ-T/M alternative maker responses.\n */\nexport interface AltMockedRfqQuoteResponse {\n    endpoint: string;\n    mmApiKey: string;\n    requestData: AltQuoteRequestData;\n    responseData: unknown;\n    responseCode: number;\n}\n\nexport enum AltQuoteModel {\n    Firm = 'firm',\n    Indicative = 'indicative',\n}\n\nexport enum AltQuoteSide {\n    Buy = 'buy',\n    Sell = 'sell',\n}\nexport interface AltQuoteRequestData {\n    market: string;\n    model: AltQuoteModel;\n    profile: string;\n    side: AltQuoteSide;\n    value?: string;\n    amount?: string;\n    meta: {\n        txOrigin: string;\n        taker: string;\n        client: string;\n        existingOrder?: {\n            price: string;\n            value?: string;\n            amount?: string;\n        };\n    };\n}\n\nexport interface AltOffering {\n    id: string;\n    baseAsset: string;\n    quoteAsset: string;\n    baseAssetDecimals: number;\n    quoteAssetDecimals: number;\n}\nexport interface AltRfqMakerAssetOfferings {\n    [endpoint: string]: AltOffering[];\n}\n\n/**\n * Represents a mocked RFQ-T/M maker responses.\n */\nexport interface MockedRfqQuoteResponse {\n    endpoint: string;\n    requestApiKey: string;\n    requestParams: TakerRequestQueryParamsUnnested;\n    responseData: unknown;\n    responseCode: number;\n    callback?: (config: unknown) => Promise<unknown>;\n}\n\nexport enum RfqQuoteEndpoint {\n    Indicative = 'price',\n    Firm = 'quote',\n}\n\nexport interface AltQuoteRequestData {\n    market: string;\n    model: AltQuoteModel;\n    profile: string;\n    side: AltQuoteSide;\n    value?: string;\n    amount?: string;\n    meta: {\n        txOrigin: string;\n        taker: string;\n        client: string;\n        existingOrder?: {\n            price: string;\n            value?: string;\n            amount?: string;\n        };\n    };\n}\nexport interface AltBaseRfqResponse extends AltQuoteRequestData {\n    id: string;\n    price?: string;\n}\nexport interface AltIndicativeQuoteResponse extends AltBaseRfqResponse {\n    model: AltQuoteModel.Indicative;\n    status: 'live' | 'rejected';\n}\nexport interface AltFirmQuoteResponse extends AltBaseRfqResponse {\n    model: AltQuoteModel.Firm;\n    data: {\n        '0xv4order': V4SignedRfqOrder;\n    };\n    status: 'active' | 'rejected';\n}\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/quote-server/types.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts"]}],["/Users/davidwalsh/code-local/0x-rfq-api/test/core/meta_transaction_fee_utils_test.ts",{"fileContent":"import { BigNumber } from '@0x/utils';\nimport { feesToTruncatedFees, getFeeConfigsFromParams, rawFeesToFees } from '../../src/core/meta_transaction_fee_utils';\nimport { MAINET_TOKEN_ADDRESSES } from '../constants';\n\nconst FEE_TOKEN = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';\nconst FEE_RECIPIENT = '0x4ea754349ace5303c82f0d1d491041e042f2ad22';\nconst INTEGRATOR_ID = '5062340f-87bb-4e1b-8029-eb8c03a9989c';\n\ndescribe('meta_transaction_fee_utils', () => {\n    describe('rawFeesToFees', () => {\n        it('returns undefined if `rawFees` is undefined', () => {\n            expect(rawFeesToFees(undefined)).toBeUndefined();\n        });\n\n        describe('integrator fee', () => {\n            it('returns integrator fee as undefined if integrator fee is not provided', () => {\n                const fees = rawFeesToFees({\n                    zeroExFee: {\n                        type: 'integrator_share',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: '1000',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        integratorSharePercentage: '10',\n                    },\n                });\n                expect(fees).toBeTruthy();\n                expect(fees?.integratorFee).toBeUndefined();\n            });\n\n            it('returns the correct integrator fee if integrator fee is provided', () => {\n                const fees = rawFeesToFees({\n                    integratorFee: {\n                        type: 'volume',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: '1000',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        volumePercentage: '10',\n                    },\n                    zeroExFee: {\n                        type: 'integrator_share',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: '100000',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        integratorSharePercentage: '1',\n                    },\n                });\n                expect(fees).toBeTruthy();\n                expect(fees?.integratorFee).toEqual({\n                    type: 'volume',\n                    feeToken: FEE_TOKEN,\n                    feeAmount: new BigNumber(1000),\n                    feeRecipient: FEE_RECIPIENT,\n                    billingType: 'on-chain',\n                    volumePercentage: new BigNumber(10),\n                });\n            });\n        });\n\n        describe('0x fee', () => {\n            it('returns 0x fee as undefined if 0x fee is not provided', () => {\n                const fees = rawFeesToFees({\n                    integratorFee: {\n                        type: 'volume',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: '1000',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        volumePercentage: '10',\n                    },\n                });\n                expect(fees).toBeTruthy();\n                expect(fees?.zeroExFee).toBeUndefined();\n            });\n\n            it('returns the correct 0x fee volume fee if 0x fee is provided', () => {\n                const fees = rawFeesToFees({\n                    integratorFee: {\n                        type: 'volume',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: '1000',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        volumePercentage: '10',\n                    },\n                    zeroExFee: {\n                        type: 'volume',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: '100000',\n                        feeRecipient: null,\n                        billingType: 'off-chain',\n                        volumePercentage: '1',\n                    },\n                });\n                expect(fees).toBeTruthy();\n                expect(fees?.zeroExFee).toEqual({\n                    type: 'volume',\n                    feeToken: FEE_TOKEN,\n                    feeAmount: new BigNumber(100000),\n                    feeRecipient: null,\n                    billingType: 'off-chain',\n                    volumePercentage: new BigNumber(1),\n                });\n            });\n\n            it('returns the correct 0x fee integrator share fee if 0x fee is provided', () => {\n                const fees = rawFeesToFees({\n                    integratorFee: {\n                        type: 'volume',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: '1000',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        volumePercentage: '10',\n                    },\n                    zeroExFee: {\n                        type: 'integrator_share',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: '100000',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        integratorSharePercentage: '1',\n                    },\n                });\n                expect(fees).toBeTruthy();\n                expect(fees?.zeroExFee).toEqual({\n                    type: 'integrator_share',\n                    feeToken: FEE_TOKEN,\n                    feeAmount: new BigNumber(100000),\n                    feeRecipient: FEE_RECIPIENT,\n                    billingType: 'on-chain',\n                    integratorSharePercentage: new BigNumber(1),\n                });\n            });\n        });\n\n        describe('gas fee', () => {\n            it('returns gas fee as undefined if gas fee is not provided', () => {\n                const fees = rawFeesToFees({\n                    zeroExFee: {\n                        type: 'integrator_share',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: '1000',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        integratorSharePercentage: '10',\n                    },\n                });\n                expect(fees).toBeTruthy();\n                expect(fees?.gasFee).toBeUndefined();\n            });\n\n            it('returns the correct gas fee if gas is provided', () => {\n                const fees = rawFeesToFees({\n                    integratorFee: {\n                        type: 'volume',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: '1000',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        volumePercentage: '10',\n                    },\n                    zeroExFee: {\n                        type: 'integrator_share',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: '100000',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        integratorSharePercentage: '1',\n                    },\n                    gasFee: {\n                        type: 'gas',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: '10',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        gasPrice: '123',\n                        estimatedGas: '200000',\n                        feeTokenAmountPerBaseUnitNativeToken: '0.0001',\n                    },\n                });\n                expect(fees).toBeTruthy();\n                expect(fees?.gasFee).toEqual({\n                    type: 'gas',\n                    feeToken: FEE_TOKEN,\n                    feeAmount: new BigNumber(10),\n                    feeRecipient: FEE_RECIPIENT,\n                    billingType: 'on-chain',\n                    gasPrice: new BigNumber(123),\n                    estimatedGas: new BigNumber(200000),\n                    feeTokenAmountPerBaseUnitNativeToken: new BigNumber(0.0001),\n                });\n            });\n        });\n    });\n\n    describe('getFeeConfigsFromParams', () => {\n        describe('integrator fee', () => {\n            it('returns undefined integrator fee if `integratorFeeConfig` is not provided', () => {\n                const integratorFeeConfig = getFeeConfigsFromParams({\n                    integratorId: INTEGRATOR_ID,\n                    chainId: 1,\n                    sellToken: MAINET_TOKEN_ADDRESSES.WETH,\n                    buyToken: MAINET_TOKEN_ADDRESSES.USDC,\n                }).integratorFee;\n                expect(integratorFeeConfig).toBeUndefined();\n            });\n\n            it('returns the correct integrator fee', () => {\n                const integratorFeeConfig = getFeeConfigsFromParams({\n                    integratorId: INTEGRATOR_ID,\n                    chainId: 1,\n                    sellToken: MAINET_TOKEN_ADDRESSES.WETH,\n                    buyToken: MAINET_TOKEN_ADDRESSES.USDC,\n                    integratorFeeConfig: {\n                        type: 'volume',\n                        recipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        sellTokenPercentage: new BigNumber(0.1),\n                    },\n                }).integratorFee;\n                expect(integratorFeeConfig).toEqual({\n                    type: 'volume',\n                    feeRecipient: FEE_RECIPIENT,\n                    billingType: 'on-chain',\n                    volumePercentage: new BigNumber(0.1),\n                });\n            });\n        });\n\n        describe('0x fee', () => {\n            describe('coinbase mainnet', () => {\n                it('matches a specific pair', () => {\n                    const zeroExFeeConfig = getFeeConfigsFromParams({\n                        integratorId: INTEGRATOR_ID,\n                        chainId: 1,\n                        sellToken: MAINET_TOKEN_ADDRESSES.WETH,\n                        buyToken: MAINET_TOKEN_ADDRESSES.USDC,\n                    }).zeroExFee;\n\n                    expect(zeroExFeeConfig).toBeTruthy();\n                    expect(zeroExFeeConfig).toEqual({\n                        type: 'volume',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        volumePercentage: new BigNumber(0.5),\n                    });\n                });\n\n                it('matches a cartesian product if no matches for specific pair', () => {\n                    const zeroExFeeConfig = getFeeConfigsFromParams({\n                        integratorId: INTEGRATOR_ID,\n                        chainId: 1,\n                        sellToken: MAINET_TOKEN_ADDRESSES.DAI,\n                        buyToken: MAINET_TOKEN_ADDRESSES.WBTC,\n                    }).zeroExFee;\n\n                    expect(zeroExFeeConfig).toBeTruthy();\n                    expect(zeroExFeeConfig).toEqual({\n                        type: 'volume',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        volumePercentage: new BigNumber(0.7),\n                    });\n                });\n\n                it('matches a token if no matches for specific pair and cartesian product', () => {\n                    const zeroExFeeConfig = getFeeConfigsFromParams({\n                        integratorId: INTEGRATOR_ID,\n                        chainId: 1,\n                        sellToken: MAINET_TOKEN_ADDRESSES.SHIB,\n                        buyToken: MAINET_TOKEN_ADDRESSES.WBTC,\n                    }).zeroExFee;\n\n                    expect(zeroExFeeConfig).toBeTruthy();\n                    expect(zeroExFeeConfig).toEqual({\n                        type: 'volume',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        volumePercentage: new BigNumber(1.5),\n                    });\n                });\n\n                it('matches a wildcard token if no matches for specific pair, cartesian product and exact token', () => {\n                    const zeroExFeeConfig = getFeeConfigsFromParams({\n                        integratorId: INTEGRATOR_ID,\n                        chainId: 1,\n                        sellToken: MAINET_TOKEN_ADDRESSES.SHIB,\n                        buyToken: MAINET_TOKEN_ADDRESSES.AAVE,\n                    }).zeroExFee;\n\n                    expect(zeroExFeeConfig).toBeTruthy();\n                    expect(zeroExFeeConfig).toEqual({\n                        type: 'volume',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        volumePercentage: new BigNumber(0.05),\n                    });\n                });\n            });\n\n            describe('default mainnet', () => {\n                it('returns the correct 0x fee config', () => {\n                    const zeroExFeeConfig = getFeeConfigsFromParams({\n                        integratorId: '*',\n                        chainId: 1,\n                        sellToken: MAINET_TOKEN_ADDRESSES.WETH,\n                        buyToken: MAINET_TOKEN_ADDRESSES.USDC,\n                    }).zeroExFee;\n\n                    expect(zeroExFeeConfig).toBeTruthy();\n                    expect(zeroExFeeConfig).toEqual({\n                        type: 'integrator_share',\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        integratorSharePercentage: new BigNumber(0.03),\n                    });\n                });\n            });\n        });\n\n        describe('gas fee', () => {\n            it('returns the correct gas fee config', () => {\n                const gasFeeConfig = getFeeConfigsFromParams({\n                    integratorId: INTEGRATOR_ID,\n                    chainId: 1,\n                    sellToken: MAINET_TOKEN_ADDRESSES.WETH,\n                    buyToken: MAINET_TOKEN_ADDRESSES.USDC,\n                }).gasFee;\n                expect(gasFeeConfig).toEqual({\n                    type: 'gas',\n                    feeRecipient: null,\n                    billingType: 'off-chain',\n                });\n            });\n        });\n    });\n\n    describe('feesToTruncatedFees', () => {\n        it('returns undefined when `fees` is undefined', () => {\n            expect(feesToTruncatedFees(undefined)).toBeUndefined();\n        });\n\n        it('returns correct truncated fee', () => {\n            expect(\n                feesToTruncatedFees({\n                    integratorFee: {\n                        type: 'volume',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: new BigNumber(1000),\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        volumePercentage: new BigNumber(10),\n                    },\n                    zeroExFee: {\n                        type: 'integrator_share',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: new BigNumber(100),\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        integratorSharePercentage: new BigNumber(1),\n                    },\n                    gasFee: {\n                        type: 'gas',\n                        feeToken: FEE_TOKEN,\n                        feeAmount: new BigNumber(1),\n                        feeRecipient: FEE_RECIPIENT,\n                        billingType: 'on-chain',\n                        gasPrice: new BigNumber(123),\n                        estimatedGas: new BigNumber(200000),\n                        feeTokenAmountPerBaseUnitNativeToken: new BigNumber(0.0001),\n                    },\n                }),\n            );\n        });\n    });\n});\n","resolvedModuleNames":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/meta_transaction_fee_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/test/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/config.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/pair_utils.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/meta_transaction_fees.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/constants.ts","/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts"]}]]