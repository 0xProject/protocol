d051f7a545afae44b03b6336681a29b7
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable custom-no-magic-numbers
// tslint:disable await-promise
// tslint:disable max-file-line-count
const asset_swapper_1 = require("@0x/asset-swapper");
const contract_addresses_1 = require("@0x/contract-addresses");
const contracts_erc20_1 = require("@0x/contracts-erc20");
const contracts_zero_ex_1 = require("@0x/contracts-zero-ex");
const protocol_utils_1 = require("@0x/protocol-utils");
const utils_1 = require("@0x/utils");
const web3_wrapper_1 = require("@0x/web3-wrapper");
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const constants_1 = require("../src/core/constants");
const balance_checker_1 = require("../src/utils/balance_checker");
const rfq_blockchain_utils_1 = require("../src/utils/rfq_blockchain_utils");
const constants_2 = require("./constants");
const deployment_1 = require("./test_utils/deployment");
const GAS_PRICE = 1e9;
const VALID_EXPIRY = new utils_1.BigNumber(9000000000);
const CHAIN_ID = contract_addresses_1.ChainId.Ganache;
jest.setTimeout(constants_1.ONE_MINUTE_MS * 2);
let teardownDependencies;
describe('RFQ Blockchain Utils', () => {
    let provider;
    let makerToken;
    let takerToken;
    let makerAmount;
    let takerAmount;
    let invalidTakerAmount;
    let makerBalance;
    let takerBalance;
    let web3Wrapper;
    let owner;
    let maker;
    let taker;
    let signer;
    let txOrigin;
    let zeroEx;
    let rfqOrder;
    let otcOrder;
    let unfillableRfqOrder;
    let rfqBlockchainUtils;
    let orderSig;
    let sigForUnfillableOrder;
    let makerOtcOrderSig;
    let takerOtcOrderSig;
    beforeAll(async () => {
        teardownDependencies = await (0, deployment_1.setupDependenciesAsync)(['ganache']);
        provider = (0, constants_2.getProvider)();
        web3Wrapper = new web3_wrapper_1.Web3Wrapper(provider);
        [owner, maker, taker, txOrigin, signer] = await web3Wrapper.getAvailableAddressesAsync();
        // Deploy dummy tokens
        makerToken = await contracts_erc20_1.DummyERC20TokenContract.deployFrom0xArtifactAsync(contracts_erc20_1.artifacts.DummyERC20Token, provider, { from: maker, gas: 10000000 }, {}, 'The token that originally belongs to the maker', 'makerToken', new utils_1.BigNumber(18), new utils_1.BigNumber(0));
        takerToken = await contracts_erc20_1.DummyERC20TokenContract.deployFrom0xArtifactAsync(contracts_erc20_1.artifacts.DummyERC20Token, provider, { from: taker, gas: 10000000 }, {}, 'The token that originally belongs to the maker', 'takerToken', new utils_1.BigNumber(18), new utils_1.BigNumber(0));
        // Deploy Balance Checker (only necessary for Ganache because ganache doesn't have overrides)
        const balanceCheckerContract = await asset_swapper_1.BalanceCheckerContract.deployFrom0xArtifactAsync(asset_swapper_1.artifacts.BalanceChecker, provider, { from: owner, gas: 10000000 }, {});
        const balanceChecker = new balance_checker_1.BalanceChecker(provider, balanceCheckerContract);
        makerAmount = new utils_1.BigNumber(100);
        takerAmount = new utils_1.BigNumber(50);
        invalidTakerAmount = new utils_1.BigNumber(10000000);
        // Deploy ZeroEx to Ganache
        zeroEx = await (0, contracts_zero_ex_1.fullMigrateAsync)(owner, provider, { from: owner, gasPrice: GAS_PRICE }, {}, { protocolFeeMultiplier: Number(0) }, {
            nativeOrders: contracts_zero_ex_1.artifacts.NativeOrdersFeature,
            metaTransactions: contracts_zero_ex_1.artifacts.MetaTransactionsFeature,
        });
        // Prepare an RfqOrder
        rfqOrder = new protocol_utils_1.RfqOrder({
            makerToken: makerToken.address,
            takerToken: takerToken.address,
            makerAmount,
            takerAmount,
            maker,
            taker,
            txOrigin,
            expiry: VALID_EXPIRY,
            salt: new utils_1.BigNumber(1),
            verifyingContract: zeroEx.address,
            chainId: CHAIN_ID,
        });
        orderSig = await rfqOrder.getSignatureWithProviderAsync(provider);
        // Prepare an Unfillable RfqOrder
        unfillableRfqOrder = new protocol_utils_1.RfqOrder({
            makerToken: makerToken.address,
            takerToken: takerToken.address,
            makerAmount,
            takerAmount: invalidTakerAmount,
            maker,
            taker,
            txOrigin,
            expiry: VALID_EXPIRY,
            salt: new utils_1.BigNumber(1),
            verifyingContract: zeroEx.address,
            chainId: CHAIN_ID,
        });
        sigForUnfillableOrder = await unfillableRfqOrder.getSignatureWithProviderAsync(provider);
        // Prepare an OtcOrder and valid signatures
        otcOrder = new protocol_utils_1.OtcOrder({
            maker,
            taker,
            makerAmount,
            takerAmount,
            makerToken: makerToken.address,
            takerToken: takerToken.address,
            txOrigin,
            expiryAndNonce: protocol_utils_1.OtcOrder.encodeExpiryAndNonce(new utils_1.BigNumber(VALID_EXPIRY), constants_1.ZERO, new utils_1.BigNumber(VALID_EXPIRY)),
            chainId: CHAIN_ID,
            verifyingContract: zeroEx.address,
        });
        const orderHash = otcOrder.getHash();
        makerOtcOrderSig = await (0, protocol_utils_1.ethSignHashWithProviderAsync)(orderHash, maker, provider);
        takerOtcOrderSig = await (0, protocol_utils_1.ethSignHashWithProviderAsync)(orderHash, taker, provider);
        // Mint enough tokens for a few trades
        const numTrades = 2;
        makerBalance = makerAmount.times(numTrades);
        takerBalance = takerAmount.times(numTrades);
        await makerToken.mint(makerBalance).awaitTransactionSuccessAsync({ from: maker });
        await makerToken.approve(zeroEx.address, makerBalance.times(2)).awaitTransactionSuccessAsync({ from: maker });
        await takerToken.mint(takerBalance).awaitTransactionSuccessAsync({ from: taker });
        await takerToken.approve(zeroEx.address, takerBalance.times(2)).awaitTransactionSuccessAsync({ from: taker });
        const ethersProvider = new ethers_1.providers.JsonRpcProvider();
        const ethersWallet = new ethers_1.Wallet(constants_2.WORKER_TEST_PRIVATE_KEY, ethersProvider);
        rfqBlockchainUtils = new rfq_blockchain_utils_1.RfqBlockchainUtils(provider, zeroEx.address, balanceChecker, ethersProvider, ethersWallet);
    });
    afterAll(async () => {
        if (!teardownDependencies()) {
            throw new Error('Failed to tear down dependencies');
        }
    });
    describe('getMinOfBalancesAndAllowancesAsync', () => {
        it('should fetch min of token balances and allowances', async () => {
            const addresses = [
                { owner: maker, token: makerToken.address },
                { owner: maker, token: takerToken.address },
                { owner: taker, token: makerToken.address },
                { owner: taker, token: takerToken.address },
            ];
            const res = await rfqBlockchainUtils.getMinOfBalancesAndAllowancesAsync(addresses);
            (0, chai_1.expect)(res).to.deep.eq([makerBalance, constants_1.ZERO, constants_1.ZERO, takerBalance]);
        });
    });
    describe('getTokenBalancesAsync', () => {
        it('should fetch token balances', async () => {
            const addresses = [
                { owner: maker, token: makerToken.address },
                { owner: maker, token: takerToken.address },
                { owner: taker, token: makerToken.address },
                { owner: taker, token: takerToken.address },
            ];
            const res = await rfqBlockchainUtils.getTokenBalancesAsync(addresses);
            (0, chai_1.expect)(res).to.deep.eq([makerBalance, constants_1.ZERO, constants_1.ZERO, takerBalance]);
        });
    });
    describe('OtcOrder', () => {
        describe('estimateGasForFillTakerSignedOtcOrderAsync', () => {
            it('does not throw an error on valid order', async () => {
                try {
                    const gasEstimate = await rfqBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(otcOrder, makerOtcOrderSig, takerOtcOrderSig, txOrigin, false);
                    (0, chai_1.expect)(gasEstimate).to.be.greaterThan(0);
                }
                catch (err) {
                    chai_1.expect.fail('should not throw');
                }
            });
            it('throws an error if order is invalid', async () => {
                const invalidOtcOrder = new protocol_utils_1.OtcOrder({
                    maker,
                    taker,
                    makerAmount,
                    takerAmount,
                    makerToken: makerToken.address,
                    takerToken: takerToken.address,
                    txOrigin,
                    expiryAndNonce: protocol_utils_1.OtcOrder.encodeExpiryAndNonce(constants_1.ZERO, // expired
                    constants_1.ZERO, VALID_EXPIRY),
                    chainId: CHAIN_ID,
                    verifyingContract: zeroEx.address,
                });
                const orderHash = invalidOtcOrder.getHash();
                const makerSig = await (0, protocol_utils_1.ethSignHashWithProviderAsync)(orderHash, maker, provider);
                const takerSig = await (0, protocol_utils_1.ethSignHashWithProviderAsync)(orderHash, taker, provider);
                (0, chai_1.expect)(rfqBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(invalidOtcOrder, // invalid order, should be expired
                makerSig, takerSig, txOrigin, false)).to.eventually.be.rejectedWith(/revert/);
            });
            it('throws an error if signatures invalid', async () => {
                (0, chai_1.expect)(rfqBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(otcOrder, makerOtcOrderSig, makerOtcOrderSig, // wrong signature
                txOrigin, false)).to.eventually.be.rejectedWith('revert');
            });
        });
    });
    describe('validateMetaTransaction', () => {
        it('returns successful filled amounts for a valid metatransaction', async () => {
            const metaTx = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount, CHAIN_ID);
            const metaTxSig = await metaTx.getSignatureWithProviderAsync(provider);
            const res = await rfqBlockchainUtils.validateMetaTransactionOrThrowAsync(metaTx, metaTxSig, txOrigin);
            (0, chai_1.expect)(res[0]).to.deep.equal(takerAmount);
            (0, chai_1.expect)(res[1]).to.deep.equal(makerAmount);
        });
        it('throws for a metatransaction with an invalid signature', async () => {
            const metaTx = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount, CHAIN_ID);
            const invalidMetaTxSig = orderSig;
            (0, chai_1.expect)(rfqBlockchainUtils.validateMetaTransactionOrThrowAsync(metaTx, invalidMetaTxSig, txOrigin)).to.eventually.be.rejectedWith('SignatureValidationError');
        });
        it('throws for a metatransaction with an unfillable order', async () => {
            const metaTx = rfqBlockchainUtils.generateMetaTransaction(unfillableRfqOrder, sigForUnfillableOrder, taker, invalidTakerAmount, CHAIN_ID);
            const metaTxSig = await metaTx.getSignatureWithProviderAsync(provider);
            (0, chai_1.expect)(rfqBlockchainUtils.validateMetaTransactionOrThrowAsync(metaTx, metaTxSig, txOrigin)).to.eventually.be.rejectedWith('MetaTransactionCallFailedError');
        });
        it('returns successful filled amounts for a valid metatransaction when validating calldata', async () => {
            const metaTx = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount, CHAIN_ID);
            const metaTxSig = await metaTx.getSignatureWithProviderAsync(provider);
            const callData = rfqBlockchainUtils.generateMetaTransactionCallData(metaTx, metaTxSig, constants_2.MATCHA_AFFILIATE_ADDRESS);
            const res = await rfqBlockchainUtils.decodeMetaTransactionCallDataAndValidateAsync(callData, txOrigin);
            (0, chai_1.expect)(res[0]).to.deep.equal(takerAmount);
            (0, chai_1.expect)(res[1]).to.deep.equal(makerAmount);
        });
        it('throws for a metatransaction with an invalid signature when validating calldata', async () => {
            const metaTx = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount, CHAIN_ID);
            const invalidMetaTxSig = orderSig;
            const callData = rfqBlockchainUtils.generateMetaTransactionCallData(metaTx, invalidMetaTxSig, constants_2.MATCHA_AFFILIATE_ADDRESS);
            (0, chai_1.expect)(rfqBlockchainUtils.decodeMetaTransactionCallDataAndValidateAsync(callData, txOrigin)).to.eventually.be.rejectedWith('SignatureValidationError');
        });
        it('throws for a metatransaction with an unfillable order when validating calldata', async () => {
            const metaTx = rfqBlockchainUtils.generateMetaTransaction(unfillableRfqOrder, sigForUnfillableOrder, taker, invalidTakerAmount, CHAIN_ID);
            const metaTxSig = await metaTx.getSignatureWithProviderAsync(provider);
            const callData = rfqBlockchainUtils.generateMetaTransactionCallData(metaTx, metaTxSig, constants_2.MATCHA_AFFILIATE_ADDRESS);
            (0, chai_1.expect)(rfqBlockchainUtils.decodeMetaTransactionCallDataAndValidateAsync(callData, txOrigin)).to.eventually.be.rejectedWith('MetaTransactionCallFailedError');
        });
        it('should throw for a partially filled order', async () => {
            const metaTx1 = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount.div(2), CHAIN_ID);
            const metaTxSig1 = await metaTx1.getSignatureWithProviderAsync(provider);
            await zeroEx.executeMetaTransaction(metaTx1, metaTxSig1).awaitTransactionSuccessAsync({ from: txOrigin });
            const metaTx2 = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount, CHAIN_ID);
            const metaTxSig2 = await metaTx2.getSignatureWithProviderAsync(provider);
            (0, chai_1.expect)(rfqBlockchainUtils.validateMetaTransactionOrThrowAsync(metaTx2, metaTxSig2, txOrigin)).to.eventually.be.rejectedWith('filled amount is less than requested fill amount');
        });
    });
    describe('transformTxDataToTransactionRequest', () => {
        it('creates a TransactionRequest', () => {
            const txOptions = {
                from: '0xfromaddress',
                gas: new utils_1.BigNumber(210000000),
                maxFeePerGas: new utils_1.BigNumber(200000),
                maxPriorityFeePerGas: new utils_1.BigNumber(100000),
                nonce: 21,
                to: '0xtoaddress',
                value: 0,
            };
            const result = rfqBlockchainUtils.transformTxDataToTransactionRequest(txOptions, 
            /* chainId = */ 1337, 
            /* callData */ '0x01234');
            (0, chai_1.expect)(result.from).to.equal('0xfromaddress');
            (0, chai_1.expect)(result.gasLimit).to.equal(BigInt(210000000));
            (0, chai_1.expect)(result.maxFeePerGas).to.equal(BigInt(200000));
            (0, chai_1.expect)(result.maxPriorityFeePerGas).to.equal(BigInt(100000));
            (0, chai_1.expect)(result.nonce).to.equal(21);
            (0, chai_1.expect)(result.to).to.equal('0xtoaddress');
            (0, chai_1.expect)(result.value).to.equal(0);
        });
        it("uses the proxy address if no 'to' address is provided", () => {
            const txOptions = { from: '0xfromaddress' };
            const result = rfqBlockchainUtils.transformTxDataToTransactionRequest(txOptions);
            (0, chai_1.expect)(result.to).to.equal(zeroEx.address);
        });
    });
    describe('getDecodedRfqOrderFillEventLogFromLogs', () => {
        it('correctly parses an RfqOrderFillEvent from logs', async () => {
            const rfqOrderFilledEvent = rfqBlockchainUtils.getDecodedRfqOrderFillEventLogFromLogs([
                constants_2.TEST_RFQ_ORDER_FILLED_EVENT_LOG,
            ]);
            (0, chai_1.expect)(rfqOrderFilledEvent.args.takerTokenFilledAmount).to.deep.eq(constants_2.TEST_RFQ_ORDER_FILLED_EVENT_TAKER_AMOUNT);
            (0, chai_1.expect)(rfqOrderFilledEvent.blockNumber).to.deep.eq(constants_2.TEST_RFQ_ORDER_FILLED_EVENT_LOG.blockNumber);
        });
    });
    describe('getTokenDecimalsAsync', () => {
        it('gets the token decimals', async () => {
            const decimals = await rfqBlockchainUtils.getTokenDecimalsAsync(makerToken.address);
            (0, chai_1.expect)(decimals).to.equal(18);
        });
        it('throws if the contract does not exist', () => {
            // tslint:disable-next-line: no-unused-expression no-unbound-method
            (0, chai_1.expect)(rfqBlockchainUtils.getTokenDecimalsAsync('0x29D7d1dd5B6f9C864d9db560D72a247c178aE86B')).to.be
                .rejected;
        });
    });
    describe('isValidOrderSigner', () => {
        it('returns false if signer is not valid', async () => {
            const isValidOrderSigner = await rfqBlockchainUtils.isValidOrderSignerAsync(maker, signer);
            (0, chai_1.expect)(isValidOrderSigner).to.equal(false);
        });
        it('returns true when valid signer address is passed', async () => {
            await rfqBlockchainUtils.registerAllowedOrderSignerAsync(maker, signer, true);
            const isValidOrderSigner = await rfqBlockchainUtils.isValidOrderSignerAsync(maker, signer);
            (0, chai_1.expect)(isValidOrderSigner).to.equal(true);
        });
    });
    describe('generateApprovalCalldataAsync', () => {
        it('generates executeMetaTransaction calldata', async () => {
            const token = makerToken.address;
            const approval = constants_2.MOCK_EXECUTE_META_TRANSACTION_APPROVAL;
            const signature = {
                r: '0x0000000000000000000000000000000000000000000000000000000000000000',
                s: '0x0000000000000000000000000000000000000000000000000000000000000000',
                v: 28,
                signatureType: 2,
            };
            const calldata = await rfqBlockchainUtils.generateApprovalCalldataAsync(token, approval, signature);
            (0, chai_1.expect)(calldata).to.eq(constants_2.MOCK_EXECUTE_META_TRANSACTION_CALLDATA);
        });
        it('generates permit calldata', async () => {
            const token = makerToken.address;
            const approval = constants_2.MOCK_PERMIT_APPROVAL;
            const signature = {
                r: '0x0000000000000000000000000000000000000000000000000000000000000000',
                s: '0x0000000000000000000000000000000000000000000000000000000000000000',
                v: 28,
                signatureType: 2,
            };
            const calldata = await rfqBlockchainUtils.generateApprovalCalldataAsync(token, approval, signature);
            (0, chai_1.expect)(calldata).to.eq(constants_2.MOCK_PERMIT_CALLDATA);
        });
    });
    describe('estimateGasForAsync', () => {
        it('throws exception on invalid calldata', async () => {
            const erc20AbiDecimals = `[{
                "constant": true,
                "inputs": [],
                "name": "decimals",
                "outputs": [
                    {
                        "name": "",
                        "type": "uint8"
                    }
                ],
                "payable": false,
                "stateMutability": "view",
                "type": "function"
            }]`;
            const erc20 = new ethers_1.Contract(takerToken.address, erc20AbiDecimals);
            const { data: calldata } = await erc20.populateTransaction.decimals();
            if (!calldata) {
                throw new Error('calldata for decimals should not be undefined or empty');
            }
            const invalidCalldata = `${calldata.substring(0, calldata.length - 1)}0`;
            try {
                await rfqBlockchainUtils.estimateGasForAsync({ to: takerToken.address, data: invalidCalldata });
                chai_1.expect.fail();
            }
            catch (e) {
                (0, chai_1.expect)(e.message).to.contain('estimateGasForAsync');
            }
        });
        it('successfully estimates gas', async () => {
            const erc20AbiDecimals = `[{
                "constant": true,
                "inputs": [],
                "name": "decimals",
                "outputs": [
                    {
                        "name": "",
                        "type": "uint8"
                    }
                ],
                "payable": false,
                "stateMutability": "view",
                "type": "function"
            }]`;
            const erc20 = new ethers_1.Contract(takerToken.address, erc20AbiDecimals);
            const { data: calldata } = await erc20.populateTransaction.decimals();
            if (!calldata) {
                throw new Error('calldata for decimals should not be undefined or empty');
            }
            await rfqBlockchainUtils.estimateGasForAsync({ to: takerToken.address, data: calldata });
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3Rlc3QvcmZxX2Jsb2NrY2hhaW5fdXRpbHNfdGVzdC50cyIsIm1hcHBpbmdzIjoiOztBQUFBLHlDQUF5QztBQUN6QywrQkFBK0I7QUFDL0IscUNBQXFDO0FBQ3JDLHFEQUErRjtBQUMvRiwrREFBaUQ7QUFDakQseURBQTJGO0FBQzNGLDZEQUF3RztBQUV4Ryx1REFBaUc7QUFDakcscUNBQXNDO0FBQ3RDLG1EQUF1RDtBQUN2RCwrQkFBOEI7QUFDOUIsbUNBQXFEO0FBRXJELHFEQUE0RDtBQUM1RCxrRUFBOEQ7QUFDOUQsNEVBQXVFO0FBRXZFLDJDQVVxQjtBQUNyQix3REFBcUc7QUFFckcsTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDO0FBQ3RCLE1BQU0sWUFBWSxHQUFHLElBQUksaUJBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUMvQyxNQUFNLFFBQVEsR0FBRyw0QkFBTyxDQUFDLE9BQU8sQ0FBQztBQUVqQyxJQUFJLENBQUMsVUFBVSxDQUFDLHlCQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDbkMsSUFBSSxvQkFBd0QsQ0FBQztBQUU3RCxRQUFRLENBQUMsc0JBQXNCLEVBQUUsR0FBRyxFQUFFO0lBQ2xDLElBQUksUUFBNEIsQ0FBQztJQUNqQyxJQUFJLFVBQW1DLENBQUM7SUFDeEMsSUFBSSxVQUFtQyxDQUFDO0lBQ3hDLElBQUksV0FBc0IsQ0FBQztJQUMzQixJQUFJLFdBQXNCLENBQUM7SUFDM0IsSUFBSSxrQkFBNkIsQ0FBQztJQUNsQyxJQUFJLFlBQXVCLENBQUM7SUFDNUIsSUFBSSxZQUF1QixDQUFDO0lBQzVCLElBQUksV0FBd0IsQ0FBQztJQUM3QixJQUFJLEtBQWEsQ0FBQztJQUNsQixJQUFJLEtBQWEsQ0FBQztJQUNsQixJQUFJLEtBQWEsQ0FBQztJQUNsQixJQUFJLE1BQWMsQ0FBQztJQUNuQixJQUFJLFFBQWdCLENBQUM7SUFDckIsSUFBSSxNQUF1QixDQUFDO0lBQzVCLElBQUksUUFBa0Is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QztZQUN0RSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNYLE1BQU0sSUFBSSxLQUFLLENBQUMsd0RBQXdELENBQUMsQ0FBQzthQUM3RTtZQUVELE1BQU0sa0JBQWtCLENBQUMsbUJBQW1CLENBQUMsRUFBRSxFQUFFLEVBQUUsVUFBVSxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUM3RixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3Rlc3QvcmZxX2Jsb2NrY2hhaW5fdXRpbHNfdGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZSBjdXN0b20tbm8tbWFnaWMtbnVtYmVyc1xyXG4vLyB0c2xpbnQ6ZGlzYWJsZSBhd2FpdC1wcm9taXNlXHJcbi8vIHRzbGludDpkaXNhYmxlIG1heC1maWxlLWxpbmUtY291bnRcclxuaW1wb3J0IHsgYXJ0aWZhY3RzIGFzIGFzc2V0U3dhcHBlckFydGlmYWN0cywgQmFsYW5jZUNoZWNrZXJDb250cmFjdCB9IGZyb20gJ0AweC9hc3NldC1zd2FwcGVyJztcclxuaW1wb3J0IHsgQ2hhaW5JZCB9IGZyb20gJ0AweC9jb250cmFjdC1hZGRyZXNzZXMnO1xyXG5pbXBvcnQgeyBhcnRpZmFjdHMgYXMgZXJjMjBBcnRpZmFjdHMsIER1bW15RVJDMjBUb2tlbkNvbnRyYWN0IH0gZnJvbSAnQDB4L2NvbnRyYWN0cy1lcmMyMCc7XHJcbmltcG9ydCB7IGFydGlmYWN0cyBhcyB6ZXJvRXhBcnRpZmFjdHMsIGZ1bGxNaWdyYXRlQXN5bmMsIElaZXJvRXhDb250cmFjdCB9IGZyb20gJ0AweC9jb250cmFjdHMtemVyby1leCc7XHJcbmltcG9ydCB7IFdlYjNQcm92aWRlckVuZ2luZSB9IGZyb20gJ0AweC9kZXYtdXRpbHMnO1xyXG5pbXBvcnQgeyBldGhTaWduSGFzaFdpdGhQcm92aWRlckFzeW5jLCBPdGNPcmRlciwgUmZxT3JkZXIsIFNpZ25hdHVyZSB9IGZyb20gJ0AweC9wcm90b2NvbC11dGlscyc7XHJcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ0AweC91dGlscyc7XHJcbmltcG9ydCB7IFR4RGF0YSwgV2ViM1dyYXBwZXIgfSBmcm9tICdAMHgvd2ViMy13cmFwcGVyJztcclxuaW1wb3J0IHsgZXhwZWN0IH0gZnJvbSAnY2hhaSc7XHJcbmltcG9ydCB7IENvbnRyYWN0LCBwcm92aWRlcnMsIFdhbGxldCB9IGZyb20gJ2V0aGVycyc7XHJcblxyXG5pbXBvcnQgeyBPTkVfTUlOVVRFX01TLCBaRVJPIH0gZnJvbSAnLi4vc3JjL2NvcmUvY29uc3RhbnRzJztcclxuaW1wb3J0IHsgQmFsYW5jZUNoZWNrZXIgfSBmcm9tICcuLi9zcmMvdXRpbHMvYmFsYW5jZV9jaGVja2VyJztcclxuaW1wb3J0IHsgUmZxQmxvY2tjaGFpblV0aWxzIH0gZnJvbSAnLi4vc3JjL3V0aWxzL3JmcV9ibG9ja2NoYWluX3V0aWxzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgICBnZXRQcm92aWRlcixcclxuICAgIE1BVENIQV9BRkZJTElBVEVfQUREUkVTUyxcclxuICAgIE1PQ0tfRVhFQ1VURV9NRVRBX1RSQU5TQUNUSU9OX0FQUFJPVkFMLFxyXG4gICAgTU9DS19FWEVDVVRFX01FVEFfVFJBTlNBQ1RJT05fQ0FMTERBVEEsXHJcbiAgICBNT0NLX1BFUk1JVF9BUFBST1ZBTCxcclxuICAgIE1PQ0tfUEVSTUlUX0NBTExEQVRBLFxyXG4gICAgVEVTVF9SRlFfT1JERVJfRklMTEVEX0VWRU5UX0xPRyxcclxuICAgIFRFU1RfUkZRX09SREVSX0ZJTExFRF9FVkVOVF9UQUtFUl9BTU9VTlQsXHJcbiAgICBXT1JLRVJfVEVTVF9QUklWQVRFX0tFWSxcclxufSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IHNldHVwRGVwZW5kZW5jaWVzQXN5bmMsIFRlYXJkb3duRGVwZW5kZW5jaWVzRnVuY3Rpb25IYW5kbGUgfSBmcm9tICcuL3Rlc3RfdXRpbHMvZGVwbG95bWVudCc7XHJcblxyXG5jb25zdCBHQVNfUFJJQ0UgPSAxZTk7XHJcbmNvbnN0IFZBTElEX0VYUElSWSA9IG5ldyBCaWdOdW1iZXIoOTAwMDAwMDAwMCk7XHJcbmNvbnN0IENIQUlOX0lEID0gQ2hhaW5JZC5HYW5hY2hlO1xyXG5cclxuamVzdC5zZXRUaW1lb3V0KE9ORV9NSU5VVEVfTVMgKiAyKTtcclxubGV0IHRlYXJkb3duRGVwZW5kZW5jaWVzOiBUZWFyZG93bkRlcGVuZGVuY2llc0Z1bmN0aW9uSGFuZGxlO1xyXG5cclxuZGVzY3JpYmUoJ1JGUSBCbG9ja2NoYWluIFV0aWxzJywgKCkgPT4ge1xyXG4gICAgbGV0IHByb3ZpZGVyOiBXZWIzUHJvdmlkZXJFbmdpbmU7XHJcbiAgICBsZXQgbWFrZXJUb2tlbjogRHVtbXlFUkMyMFRva2VuQ29udHJhY3Q7XHJcbiAgICBsZXQgdGFrZXJUb2tlbjogRHVtbXlFUkMyMFRva2VuQ29udHJhY3Q7XHJcbiAgICBsZXQgbWFrZXJBbW91bnQ6IEJpZ051bWJlcjtcclxuICAgIGxldCB0YWtlckFtb3VudDogQmlnTnVtYmVyO1xyXG4gICAgbGV0IGludmFsaWRUYWtlckFtb3VudDogQmlnTnVtYmVyO1xyXG4gICAgbGV0IG1ha2VyQmFsYW5jZTogQmlnTnVtYmVyO1xyXG4gICAgbGV0IHRha2VyQmFsYW5jZTogQmlnTnVtYmVyO1xyXG4gICAgbGV0IHdlYjNXcmFwcGVyOiBXZWIzV3JhcHBlcjtcclxuICAgIGxldCBvd25lcjogc3RyaW5nO1xyXG4gICAgbGV0IG1ha2VyOiBzdHJpbmc7XHJcbiAgICBsZXQgdGFrZXI6IHN0cmluZztcclxuICAgIGxldCBzaWduZXI6IHN0cmluZztcclxuICAgIGxldCB0eE9yaWdpbjogc3RyaW5nO1xyXG4gICAgbGV0IHplcm9FeDogSVplcm9FeENvbnRyYWN0O1xyXG4gICAgbGV0IHJmcU9yZGVyOiBSZnFPcmRlcjtcclxuICAgIGxldCBvdGNPcmRlcjogT3RjT3JkZXI7XHJcbiAgICBsZXQgdW5maWxsYWJsZVJmcU9yZGVyOiBSZnFPcmRlcjtcclxuICAgIGxldCByZnFCbG9ja2NoYWluVXRpbHM6IFJmcUJsb2NrY2hhaW5VdGlscztcclxuICAgIGxldCBvcmRlclNpZzogU2lnbmF0dXJlO1xyXG4gICAgbGV0IHNpZ0ZvclVuZmlsbGFibGVPcmRlcjogU2lnbmF0dXJlO1xyXG4gICAgbGV0IG1ha2VyT3RjT3JkZXJTaWc6IFNpZ25hdHVyZTtcclxuICAgIGxldCB0YWtlck90Y09yZGVyU2lnOiBTaWduYXR1cmU7XHJcblxyXG4gICAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcclxuICAgICAgICB0ZWFyZG93bkRlcGVuZGVuY2llcyA9IGF3YWl0IHNldHVwRGVwZW5kZW5jaWVzQXN5bmMoWydnYW5hY2hlJ10pO1xyXG4gICAgICAgIHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICB3ZWIzV3JhcHBlciA9IG5ldyBXZWIzV3JhcHBlcihwcm92aWRlcik7XHJcblxyXG4gICAgICAgIFtvd25lciwgbWFrZXIsIHRha2VyLCB0eE9yaWdpbiwgc2lnbmVyXSA9IGF3YWl0IHdlYjNXcmFwcGVyLmdldEF2YWlsYWJsZUFkZHJlc3Nlc0FzeW5jKCk7XHJcblxyXG4gICAgICAgIC8vIERlcGxveSBkdW1teSB0b2tlbnNcclxuICAgICAgICBtYWtlclRva2VuID0gYXdhaXQgRHVtbXlFUkMyMFRva2VuQ29udHJhY3QuZGVwbG95RnJvbTB4QXJ0aWZhY3RBc3luYyhcclxuICAgICAgICAgICAgZXJjMjBBcnRpZmFjdHMuRHVtbXlFUkMyMFRva2VuLFxyXG4gICAgICAgICAgICBwcm92aWRlcixcclxuICAgICAgICAgICAgeyBmcm9tOiBtYWtlciwgZ2FzOiAxMDAwMDAwMCB9LFxyXG4gICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgJ1RoZSB0b2tlbiB0aGF0IG9yaWdpbmFsbHkgYmVsb25ncyB0byB0aGUgbWFrZXInLFxyXG4gICAgICAgICAgICAnbWFrZXJUb2tlbicsXHJcbiAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMTgpLFxyXG4gICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDApLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRha2VyVG9rZW4gPSBhd2FpdCBEdW1teUVSQzIwVG9rZW5Db250cmFjdC5kZXBsb3lGcm9tMHhBcnRpZmFjdEFzeW5jKFxyXG4gICAgICAgICAgICBlcmMyMEFydGlmYWN0cy5EdW1teUVSQzIwVG9rZW4sXHJcbiAgICAgICAgICAgIHByb3ZpZGVyLFxyXG4gICAgICAgICAgICB7IGZyb206IHRha2VyLCBnYXM6IDEwMDAwMDAwIH0sXHJcbiAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAnVGhlIHRva2VuIHRoYXQgb3JpZ2luYWxseSBiZWxvbmdzIHRvIHRoZSBtYWtlcicsXHJcbiAgICAgICAgICAgICd0YWtlclRva2VuJyxcclxuICAgICAgICAgICAgbmV3IEJpZ051bWJlcigxOCksXHJcbiAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMCksXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gRGVwbG95IEJhbGFuY2UgQ2hlY2tlciAob25seSBuZWNlc3NhcnkgZm9yIEdhbmFjaGUgYmVjYXVzZSBnYW5hY2hlIGRvZXNuJ3QgaGF2ZSBvdmVycmlkZXMpXHJcbiAgICAgICAgY29uc3QgYmFsYW5jZUNoZWNrZXJDb250cmFjdCA9IGF3YWl0IEJhbGFuY2VDaGVja2VyQ29udHJhY3QuZGVwbG95RnJvbTB4QXJ0aWZhY3RBc3luYyhcclxuICAgICAgICAgICAgYXNzZXRTd2FwcGVyQXJ0aWZhY3RzLkJhbGFuY2VDaGVja2VyLFxyXG4gICAgICAgICAgICBwcm92aWRlcixcclxuICAgICAgICAgICAgeyBmcm9tOiBvd25lciwgZ2FzOiAxMDAwMDAwMCB9LFxyXG4gICAgICAgICAgICB7fSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IGJhbGFuY2VDaGVja2VyID0gbmV3IEJhbGFuY2VDaGVja2VyKHByb3ZpZGVyLCBiYWxhbmNlQ2hlY2tlckNvbnRyYWN0KTtcclxuXHJcbiAgICAgICAgbWFrZXJBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDEwMCk7XHJcbiAgICAgICAgdGFrZXJBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDUwKTtcclxuICAgICAgICBpbnZhbGlkVGFrZXJBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDEwMDAwMDAwKTtcclxuXHJcbiAgICAgICAgLy8gRGVwbG95IFplcm9FeCB0byBHYW5hY2hlXHJcbiAgICAgICAgemVyb0V4ID0gYXdhaXQgZnVsbE1pZ3JhdGVBc3luYyhcclxuICAgICAgICAgICAgb3duZXIsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyLFxyXG4gICAgICAgICAgICB7IGZyb206IG93bmVyLCBnYXNQcmljZTogR0FTX1BSSUNFIH0sXHJcbiAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICB7IHByb3RvY29sRmVlTXVsdGlwbGllcjogTnVtYmVyKDApIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5hdGl2ZU9yZGVyczogemVyb0V4QXJ0aWZhY3RzLk5hdGl2ZU9yZGVyc0ZlYXR1cmUsXHJcbiAgICAgICAgICAgICAgICBtZXRhVHJhbnNhY3Rpb25zOiB6ZXJvRXhBcnRpZmFjdHMuTWV0YVRyYW5zYWN0aW9uc0ZlYXR1cmUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGFyZSBhbiBSZnFPcmRlclxyXG4gICAgICAgIHJmcU9yZGVyID0gbmV3IFJmcU9yZGVyKHtcclxuICAgICAgICAgICAgbWFrZXJUb2tlbjogbWFrZXJUb2tlbi5hZGRyZXNzLFxyXG4gICAgICAgICAgICB0YWtlclRva2VuOiB0YWtlclRva2VuLmFkZHJlc3MsXHJcbiAgICAgICAgICAgIG1ha2VyQW1vdW50LFxyXG4gICAgICAgICAgICB0YWtlckFtb3VudCxcclxuICAgICAgICAgICAgbWFrZXIsXHJcbiAgICAgICAgICAgIHRha2VyLFxyXG4gICAgICAgICAgICB0eE9yaWdpbixcclxuICAgICAgICAgICAgZXhwaXJ5OiBWQUxJRF9FWFBJUlksXHJcbiAgICAgICAgICAgIHNhbHQ6IG5ldyBCaWdOdW1iZXIoMSksXHJcbiAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiB6ZXJvRXguYWRkcmVzcyxcclxuICAgICAgICAgICAgY2hhaW5JZDogQ0hBSU5fSUQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb3JkZXJTaWcgPSBhd2FpdCByZnFPcmRlci5nZXRTaWduYXR1cmVXaXRoUHJvdmlkZXJBc3luYyhwcm92aWRlcik7XHJcblxyXG4gICAgICAgIC8vIFByZXBhcmUgYW4gVW5maWxsYWJsZSBSZnFPcmRlclxyXG4gICAgICAgIHVuZmlsbGFibGVSZnFPcmRlciA9IG5ldyBSZnFPcmRlcih7XHJcbiAgICAgICAgICAgIG1ha2VyVG9rZW46IG1ha2VyVG9rZW4uYWRkcmVzcyxcclxuICAgICAgICAgICAgdGFrZXJUb2tlbjogdGFrZXJUb2tlbi5hZGRyZXNzLFxyXG4gICAgICAgICAgICBtYWtlckFtb3VudCxcclxuICAgICAgICAgICAgdGFrZXJBbW91bnQ6IGludmFsaWRUYWtlckFtb3VudCxcclxuICAgICAgICAgICAgbWFrZXIsXHJcbiAgICAgICAgICAgIHRha2VyLFxyXG4gICAgICAgICAgICB0eE9yaWdpbixcclxuICAgICAgICAgICAgZXhwaXJ5OiBWQUxJRF9FWFBJUlksXHJcbiAgICAgICAgICAgIHNhbHQ6IG5ldyBCaWdOdW1iZXIoMSksXHJcbiAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiB6ZXJvRXguYWRkcmVzcyxcclxuICAgICAgICAgICAgY2hhaW5JZDogQ0hBSU5fSUQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2lnRm9yVW5maWxsYWJsZU9yZGVyID0gYXdhaXQgdW5maWxsYWJsZVJmcU9yZGVyLmdldFNpZ25hdHVyZVdpdGhQcm92aWRlckFzeW5jKHByb3ZpZGVyKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGFyZSBhbiBPdGNPcmRlciBhbmQgdmFsaWQgc2lnbmF0dXJlc1xyXG4gICAgICAgIG90Y09yZGVyID0gbmV3IE90Y09yZGVyKHtcclxuICAgICAgICAgICAgbWFrZXIsXHJcbiAgICAgICAgICAgIHRha2VyLFxyXG4gICAgICAgICAgICBtYWtlckFtb3VudCxcclxuICAgICAgICAgICAgdGFrZXJBbW91bnQsXHJcbiAgICAgICAgICAgIG1ha2VyVG9rZW46IG1ha2VyVG9rZW4uYWRkcmVzcyxcclxuICAgICAgICAgICAgdGFrZXJUb2tlbjogdGFrZXJUb2tlbi5hZGRyZXNzLFxyXG4gICAgICAgICAgICB0eE9yaWdpbixcclxuICAgICAgICAgICAgZXhwaXJ5QW5kTm9uY2U6IE90Y09yZGVyLmVuY29kZUV4cGlyeUFuZE5vbmNlKFxyXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcihWQUxJRF9FWFBJUlkpLFxyXG4gICAgICAgICAgICAgICAgWkVSTyxcclxuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoVkFMSURfRVhQSVJZKSxcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgY2hhaW5JZDogQ0hBSU5fSUQsXHJcbiAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiB6ZXJvRXguYWRkcmVzcyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBvcmRlckhhc2ggPSBvdGNPcmRlci5nZXRIYXNoKCk7XHJcbiAgICAgICAgbWFrZXJPdGNPcmRlclNpZyA9IGF3YWl0IGV0aFNpZ25IYXNoV2l0aFByb3ZpZGVyQXN5bmMob3JkZXJIYXNoLCBtYWtlciwgcHJvdmlkZXIpO1xyXG4gICAgICAgIHRha2VyT3RjT3JkZXJTaWcgPSBhd2FpdCBldGhTaWduSGFzaFdpdGhQcm92aWRlckFzeW5jKG9yZGVySGFzaCwgdGFrZXIsIHByb3ZpZGVyKTtcclxuXHJcbiAgICAgICAgLy8gTWludCBlbm91Z2ggdG9rZW5zIGZvciBhIGZldyB0cmFkZXNcclxuICAgICAgICBjb25zdCBudW1UcmFkZXMgPSAyO1xyXG4gICAgICAgIG1ha2VyQmFsYW5jZSA9IG1ha2VyQW1vdW50LnRpbWVzKG51bVRyYWRlcyk7XHJcbiAgICAgICAgdGFrZXJCYWxhbmNlID0gdGFrZXJBbW91bnQudGltZXMobnVtVHJhZGVzKTtcclxuXHJcbiAgICAgICAgYXdhaXQgbWFrZXJUb2tlbi5taW50KG1ha2VyQmFsYW5jZSkuYXdhaXRUcmFuc2FjdGlvblN1Y2Nlc3NBc3luYyh7IGZyb206IG1ha2VyIH0pO1xyXG4gICAgICAgIGF3YWl0IG1ha2VyVG9rZW4uYXBwcm92ZSh6ZXJvRXguYWRkcmVzcywgbWFrZXJCYWxhbmNlLnRpbWVzKDIpKS5hd2FpdFRyYW5zYWN0aW9uU3VjY2Vzc0FzeW5jKHsgZnJvbTogbWFrZXIgfSk7XHJcbiAgICAgICAgYXdhaXQgdGFrZXJUb2tlbi5taW50KHRha2VyQmFsYW5jZSkuYXdhaXRUcmFuc2FjdGlvblN1Y2Nlc3NBc3luYyh7IGZyb206IHRha2VyIH0pO1xyXG4gICAgICAgIGF3YWl0IHRha2VyVG9rZW4uYXBwcm92ZSh6ZXJvRXguYWRkcmVzcywgdGFrZXJCYWxhbmNlLnRpbWVzKDIpKS5hd2FpdFRyYW5zYWN0aW9uU3VjY2Vzc0FzeW5jKHsgZnJvbTogdGFrZXIgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGV0aGVyc1Byb3ZpZGVyID0gbmV3IHByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIoKTtcclxuICAgICAgICBjb25zdCBldGhlcnNXYWxsZXQgPSBuZXcgV2FsbGV0KFdPUktFUl9URVNUX1BSSVZBVEVfS0VZLCBldGhlcnNQcm92aWRlcik7XHJcblxyXG4gICAgICAgIHJmcUJsb2NrY2hhaW5VdGlscyA9IG5ldyBSZnFCbG9ja2NoYWluVXRpbHMoXHJcbiAgICAgICAgICAgIHByb3ZpZGVyLFxyXG4gICAgICAgICAgICB6ZXJvRXguYWRkcmVzcyxcclxuICAgICAgICAgICAgYmFsYW5jZUNoZWNrZXIsXHJcbiAgICAgICAgICAgIGV0aGVyc1Byb3ZpZGVyLFxyXG4gICAgICAgICAgICBldGhlcnNXYWxsZXQsXHJcbiAgICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFmdGVyQWxsKGFzeW5jICgpID0+IHtcclxuICAgICAgICBpZiAoIXRlYXJkb3duRGVwZW5kZW5jaWVzKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdGVhciBkb3duIGRlcGVuZGVuY2llcycpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdnZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCdzaG91bGQgZmV0Y2ggbWluIG9mIHRva2VuIGJhbGFuY2VzIGFuZCBhbGxvd2FuY2VzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXHJcbiAgICAgICAgICAgICAgICB7IG93bmVyOiBtYWtlciwgdG9rZW46IG1ha2VyVG9rZW4uYWRkcmVzcyB9LFxyXG4gICAgICAgICAgICAgICAgeyBvd25lcjogbWFrZXIsIHRva2VuOiB0YWtlclRva2VuLmFkZHJlc3MgfSxcclxuICAgICAgICAgICAgICAgIHsgb3duZXI6IHRha2VyLCB0b2tlbjogbWFrZXJUb2tlbi5hZGRyZXNzIH0sXHJcbiAgICAgICAgICAgICAgICB7IG93bmVyOiB0YWtlciwgdG9rZW46IHRha2VyVG9rZW4uYWRkcmVzcyB9LFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCByZnFCbG9ja2NoYWluVXRpbHMuZ2V0TWluT2ZCYWxhbmNlc0FuZEFsbG93YW5jZXNBc3luYyhhZGRyZXNzZXMpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzKS50by5kZWVwLmVxKFttYWtlckJhbGFuY2UsIFpFUk8sIFpFUk8sIHRha2VyQmFsYW5jZV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ2dldFRva2VuQmFsYW5jZXNBc3luYycsICgpID0+IHtcclxuICAgICAgICBpdCgnc2hvdWxkIGZldGNoIHRva2VuIGJhbGFuY2VzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXHJcbiAgICAgICAgICAgICAgICB7IG93bmVyOiBtYWtlciwgdG9rZW46IG1ha2VyVG9rZW4uYWRkcmVzcyB9LFxyXG4gICAgICAgICAgICAgICAgeyBvd25lcjogbWFrZXIsIHRva2VuOiB0YWtlclRva2VuLmFkZHJlc3MgfSxcclxuICAgICAgICAgICAgICAgIHsgb3duZXI6IHRha2VyLCB0b2tlbjogbWFrZXJUb2tlbi5hZGRyZXNzIH0sXHJcbiAgICAgICAgICAgICAgICB7IG93bmVyOiB0YWtlciwgdG9rZW46IHRha2VyVG9rZW4uYWRkcmVzcyB9LFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCByZnFCbG9ja2NoYWluVXRpbHMuZ2V0VG9rZW5CYWxhbmNlc0FzeW5jKGFkZHJlc3Nlcyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXMpLnRvLmRlZXAuZXEoW21ha2VyQmFsYW5jZSwgWkVSTywgWkVSTywgdGFrZXJCYWxhbmNlXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnT3RjT3JkZXInLCAoKSA9PiB7XHJcbiAgICAgICAgZGVzY3JpYmUoJ2VzdGltYXRlR2FzRm9yRmlsbFRha2VyU2lnbmVkT3RjT3JkZXJBc3luYycsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ2RvZXMgbm90IHRocm93IGFuIGVycm9yIG9uIHZhbGlkIG9yZGVyJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNFc3RpbWF0ZSA9IGF3YWl0IHJmcUJsb2NrY2hhaW5VdGlscy5lc3RpbWF0ZUdhc0ZvckZpbGxUYWtlclNpZ25lZE90Y09yZGVyQXN5bmMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG90Y09yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlck90Y09yZGVyU2lnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWtlck90Y09yZGVyU2lnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eE9yaWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoZ2FzRXN0aW1hdGUpLnRvLmJlLmdyZWF0ZXJUaGFuKDApO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0LmZhaWwoJ3Nob3VsZCBub3QgdGhyb3cnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgndGhyb3dzIGFuIGVycm9yIGlmIG9yZGVyIGlzIGludmFsaWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkT3RjT3JkZXIgPSBuZXcgT3RjT3JkZXIoe1xyXG4gICAgICAgICAgICAgICAgICAgIG1ha2VyLFxyXG4gICAgICAgICAgICAgICAgICAgIHRha2VyLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ha2VyQW1vdW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHRha2VyQW1vdW50LFxyXG4gICAgICAgICAgICAgICAgICAgIG1ha2VyVG9rZW46IG1ha2VyVG9rZW4uYWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICB0YWtlclRva2VuOiB0YWtlclRva2VuLmFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgdHhPcmlnaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJ5QW5kTm9uY2U6IE90Y09yZGVyLmVuY29kZUV4cGlyeUFuZE5vbmNlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBaRVJPLCAvLyBleHBpcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFpFUk8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZBTElEX0VYUElSWSxcclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IENIQUlOX0lELFxyXG4gICAgICAgICAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiB6ZXJvRXguYWRkcmVzcyxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJIYXNoID0gaW52YWxpZE90Y09yZGVyLmdldEhhc2goKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYWtlclNpZyA9IGF3YWl0IGV0aFNpZ25IYXNoV2l0aFByb3ZpZGVyQXN5bmMob3JkZXJIYXNoLCBtYWtlciwgcHJvdmlkZXIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFrZXJTaWcgPSBhd2FpdCBldGhTaWduSGFzaFdpdGhQcm92aWRlckFzeW5jKG9yZGVySGFzaCwgdGFrZXIsIHByb3ZpZGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBleHBlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgcmZxQmxvY2tjaGFpblV0aWxzLmVzdGltYXRlR2FzRm9yRmlsbFRha2VyU2lnbmVkT3RjT3JkZXJBc3luYyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZE90Y09yZGVyLCAvLyBpbnZhbGlkIG9yZGVyLCBzaG91bGQgYmUgZXhwaXJlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlclNpZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFrZXJTaWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4T3JpZ2luLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgKS50by5ldmVudHVhbGx5LmJlLnJlamVjdGVkV2l0aCgvcmV2ZXJ0Lyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ3Rocm93cyBhbiBlcnJvciBpZiBzaWduYXR1cmVzIGludmFsaWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgcmZxQmxvY2tjaGFpblV0aWxzLmVzdGltYXRlR2FzRm9yRmlsbFRha2VyU2lnbmVkT3RjT3JkZXJBc3luYyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3RjT3JkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VyT3RjT3JkZXJTaWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VyT3RjT3JkZXJTaWcsIC8vIHdyb25nIHNpZ25hdHVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eE9yaWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICkudG8uZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGgoJ3JldmVydCcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCd2YWxpZGF0ZU1ldGFUcmFuc2FjdGlvbicsICgpID0+IHtcclxuICAgICAgICBpdCgncmV0dXJucyBzdWNjZXNzZnVsIGZpbGxlZCBhbW91bnRzIGZvciBhIHZhbGlkIG1ldGF0cmFuc2FjdGlvbicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWV0YVR4ID0gcmZxQmxvY2tjaGFpblV0aWxzLmdlbmVyYXRlTWV0YVRyYW5zYWN0aW9uKHJmcU9yZGVyLCBvcmRlclNpZywgdGFrZXIsIHRha2VyQW1vdW50LCBDSEFJTl9JRCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGFUeFNpZyA9IGF3YWl0IG1ldGFUeC5nZXRTaWduYXR1cmVXaXRoUHJvdmlkZXJBc3luYyhwcm92aWRlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJmcUJsb2NrY2hhaW5VdGlscy52YWxpZGF0ZU1ldGFUcmFuc2FjdGlvbk9yVGhyb3dBc3luYyhtZXRhVHgsIG1ldGFUeFNpZywgdHhPcmlnaW4pO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KHJlc1swXSkudG8uZGVlcC5lcXVhbCh0YWtlckFtb3VudCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXNbMV0pLnRvLmRlZXAuZXF1YWwobWFrZXJBbW91bnQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgndGhyb3dzIGZvciBhIG1ldGF0cmFuc2FjdGlvbiB3aXRoIGFuIGludmFsaWQgc2lnbmF0dXJlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhVHggPSByZnFCbG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb24ocmZxT3JkZXIsIG9yZGVyU2lnLCB0YWtlciwgdGFrZXJBbW91bnQsIENIQUlOX0lEKTtcclxuICAgICAgICAgICAgY29uc3QgaW52YWxpZE1ldGFUeFNpZyA9IG9yZGVyU2lnO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KFxyXG4gICAgICAgICAgICAgICAgcmZxQmxvY2tjaGFpblV0aWxzLnZhbGlkYXRlTWV0YVRyYW5zYWN0aW9uT3JUaHJvd0FzeW5jKG1ldGFUeCwgaW52YWxpZE1ldGFUeFNpZywgdHhPcmlnaW4pLFxyXG4gICAgICAgICAgICApLnRvLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWRXaXRoKCdTaWduYXR1cmVWYWxpZGF0aW9uRXJyb3InKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Rocm93cyBmb3IgYSBtZXRhdHJhbnNhY3Rpb24gd2l0aCBhbiB1bmZpbGxhYmxlIG9yZGVyJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhVHggPSByZnFCbG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb24oXHJcbiAgICAgICAgICAgICAgICB1bmZpbGxhYmxlUmZxT3JkZXIsXHJcbiAgICAgICAgICAgICAgICBzaWdGb3JVbmZpbGxhYmxlT3JkZXIsXHJcbiAgICAgICAgICAgICAgICB0YWtlcixcclxuICAgICAgICAgICAgICAgIGludmFsaWRUYWtlckFtb3VudCxcclxuICAgICAgICAgICAgICAgIENIQUlOX0lELFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhVHhTaWcgPSBhd2FpdCBtZXRhVHguZ2V0U2lnbmF0dXJlV2l0aFByb3ZpZGVyQXN5bmMocHJvdmlkZXIpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KFxyXG4gICAgICAgICAgICAgICAgcmZxQmxvY2tjaGFpblV0aWxzLnZhbGlkYXRlTWV0YVRyYW5zYWN0aW9uT3JUaHJvd0FzeW5jKG1ldGFUeCwgbWV0YVR4U2lnLCB0eE9yaWdpbiksXHJcbiAgICAgICAgICAgICkudG8uZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGgoJ01ldGFUcmFuc2FjdGlvbkNhbGxGYWlsZWRFcnJvcicpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgncmV0dXJucyBzdWNjZXNzZnVsIGZpbGxlZCBhbW91bnRzIGZvciBhIHZhbGlkIG1ldGF0cmFuc2FjdGlvbiB3aGVuIHZhbGlkYXRpbmcgY2FsbGRhdGEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGFUeCA9IHJmcUJsb2NrY2hhaW5VdGlscy5nZW5lcmF0ZU1ldGFUcmFuc2FjdGlvbihyZnFPcmRlciwgb3JkZXJTaWcsIHRha2VyLCB0YWtlckFtb3VudCwgQ0hBSU5fSUQpO1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhVHhTaWcgPSBhd2FpdCBtZXRhVHguZ2V0U2lnbmF0dXJlV2l0aFByb3ZpZGVyQXN5bmMocHJvdmlkZXIpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY2FsbERhdGEgPSByZnFCbG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb25DYWxsRGF0YShcclxuICAgICAgICAgICAgICAgIG1ldGFUeCxcclxuICAgICAgICAgICAgICAgIG1ldGFUeFNpZyxcclxuICAgICAgICAgICAgICAgIE1BVENIQV9BRkZJTElBVEVfQUREUkVTUyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgcmZxQmxvY2tjaGFpblV0aWxzLmRlY29kZU1ldGFUcmFuc2FjdGlvbkNhbGxEYXRhQW5kVmFsaWRhdGVBc3luYyhjYWxsRGF0YSwgdHhPcmlnaW4pO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KHJlc1swXSkudG8uZGVlcC5lcXVhbCh0YWtlckFtb3VudCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXNbMV0pLnRvLmRlZXAuZXF1YWwobWFrZXJBbW91bnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGl0KCd0aHJvd3MgZm9yIGEgbWV0YXRyYW5zYWN0aW9uIHdpdGggYW4gaW52YWxpZCBzaWduYXR1cmUgd2hlbiB2YWxpZGF0aW5nIGNhbGxkYXRhJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhVHggPSByZnFCbG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb24ocmZxT3JkZXIsIG9yZGVyU2lnLCB0YWtlciwgdGFrZXJBbW91bnQsIENIQUlOX0lEKTtcclxuICAgICAgICAgICAgY29uc3QgaW52YWxpZE1ldGFUeFNpZyA9IG9yZGVyU2lnO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY2FsbERhdGEgPSByZnFCbG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb25DYWxsRGF0YShcclxuICAgICAgICAgICAgICAgIG1ldGFUeCxcclxuICAgICAgICAgICAgICAgIGludmFsaWRNZXRhVHhTaWcsXHJcbiAgICAgICAgICAgICAgICBNQVRDSEFfQUZGSUxJQVRFX0FERFJFU1MsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QoXHJcbiAgICAgICAgICAgICAgICByZnFCbG9ja2NoYWluVXRpbHMuZGVjb2RlTWV0YVRyYW5zYWN0aW9uQ2FsbERhdGFBbmRWYWxpZGF0ZUFzeW5jKGNhbGxEYXRhLCB0eE9yaWdpbiksXHJcbiAgICAgICAgICAgICkudG8uZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGgoJ1NpZ25hdHVyZVZhbGlkYXRpb25FcnJvcicpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgndGhyb3dzIGZvciBhIG1ldGF0cmFuc2FjdGlvbiB3aXRoIGFuIHVuZmlsbGFibGUgb3JkZXIgd2hlbiB2YWxpZGF0aW5nIGNhbGxkYXRhJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhVHggPSByZnFCbG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb24oXHJcbiAgICAgICAgICAgICAgICB1bmZpbGxhYmxlUmZxT3JkZXIsXHJcbiAgICAgICAgICAgICAgICBzaWdGb3JVbmZpbGxhYmxlT3JkZXIsXHJcbiAgICAgICAgICAgICAgICB0YWtlcixcclxuICAgICAgICAgICAgICAgIGludmFsaWRUYWtlckFtb3VudCxcclxuICAgICAgICAgICAgICAgIENIQUlOX0lELFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhVHhTaWcgPSBhd2FpdCBtZXRhVHguZ2V0U2lnbmF0dXJlV2l0aFByb3ZpZGVyQXN5bmMocHJvdmlkZXIpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY2FsbERhdGEgPSByZnFCbG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb25DYWxsRGF0YShcclxuICAgICAgICAgICAgICAgIG1ldGFUeCxcclxuICAgICAgICAgICAgICAgIG1ldGFUeFNpZyxcclxuICAgICAgICAgICAgICAgIE1BVENIQV9BRkZJTElBVEVfQUREUkVTUyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChcclxuICAgICAgICAgICAgICAgIHJmcUJsb2NrY2hhaW5VdGlscy5kZWNvZGVNZXRhVHJhbnNhY3Rpb25DYWxsRGF0YUFuZFZhbGlkYXRlQXN5bmMoY2FsbERhdGEsIHR4T3JpZ2luKSxcclxuICAgICAgICAgICAgKS50by5ldmVudHVhbGx5LmJlLnJlamVjdGVkV2l0aCgnTWV0YVRyYW5zYWN0aW9uQ2FsbEZhaWxlZEVycm9yJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgdGhyb3cgZm9yIGEgcGFydGlhbGx5IGZpbGxlZCBvcmRlcicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWV0YVR4MSA9IHJmcUJsb2NrY2hhaW5VdGlscy5nZW5lcmF0ZU1ldGFUcmFuc2FjdGlvbihcclxuICAgICAgICAgICAgICAgIHJmcU9yZGVyLFxyXG4gICAgICAgICAgICAgICAgb3JkZXJTaWcsXHJcbiAgICAgICAgICAgICAgICB0YWtlcixcclxuICAgICAgICAgICAgICAgIHRha2VyQW1vdW50LmRpdigyKSxcclxuICAgICAgICAgICAgICAgIENIQUlOX0lELFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhVHhTaWcxID0gYXdhaXQgbWV0YVR4MS5nZXRTaWduYXR1cmVXaXRoUHJvdmlkZXJBc3luYyhwcm92aWRlcik7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCB6ZXJvRXguZXhlY3V0ZU1ldGFUcmFuc2FjdGlvbihtZXRhVHgxLCBtZXRhVHhTaWcxKS5hd2FpdFRyYW5zYWN0aW9uU3VjY2Vzc0FzeW5jKHsgZnJvbTogdHhPcmlnaW4gfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtZXRhVHgyID0gcmZxQmxvY2tjaGFpblV0aWxzLmdlbmVyYXRlTWV0YVRyYW5zYWN0aW9uKFxyXG4gICAgICAgICAgICAgICAgcmZxT3JkZXIsXHJcbiAgICAgICAgICAgICAgICBvcmRlclNpZyxcclxuICAgICAgICAgICAgICAgIHRha2VyLFxyXG4gICAgICAgICAgICAgICAgdGFrZXJBbW91bnQsXHJcbiAgICAgICAgICAgICAgICBDSEFJTl9JRCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgY29uc3QgbWV0YVR4U2lnMiA9IGF3YWl0IG1ldGFUeDIuZ2V0U2lnbmF0dXJlV2l0aFByb3ZpZGVyQXN5bmMocHJvdmlkZXIpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KFxyXG4gICAgICAgICAgICAgICAgcmZxQmxvY2tjaGFpblV0aWxzLnZhbGlkYXRlTWV0YVRyYW5zYWN0aW9uT3JUaHJvd0FzeW5jKG1ldGFUeDIsIG1ldGFUeFNpZzIsIHR4T3JpZ2luKSxcclxuICAgICAgICAgICAgKS50by5ldmVudHVhbGx5LmJlLnJlamVjdGVkV2l0aCgnZmlsbGVkIGFtb3VudCBpcyBsZXNzIHRoYW4gcmVxdWVzdGVkIGZpbGwgYW1vdW50Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgndHJhbnNmb3JtVHhEYXRhVG9UcmFuc2FjdGlvblJlcXVlc3QnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ2NyZWF0ZXMgYSBUcmFuc2FjdGlvblJlcXVlc3QnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR4T3B0aW9uczogVHhEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgZnJvbTogJzB4ZnJvbWFkZHJlc3MnLFxyXG4gICAgICAgICAgICAgICAgZ2FzOiBuZXcgQmlnTnVtYmVyKDIxMDAwMDAwMCksXHJcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXM6IG5ldyBCaWdOdW1iZXIoMjAwMDAwKSxcclxuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBuZXcgQmlnTnVtYmVyKDEwMDAwMCksXHJcbiAgICAgICAgICAgICAgICBub25jZTogMjEsXHJcbiAgICAgICAgICAgICAgICB0bzogJzB4dG9hZGRyZXNzJyxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmZxQmxvY2tjaGFpblV0aWxzLnRyYW5zZm9ybVR4RGF0YVRvVHJhbnNhY3Rpb25SZXF1ZXN0KFxyXG4gICAgICAgICAgICAgICAgdHhPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgLyogY2hhaW5JZCA9ICovIDEzMzcsXHJcbiAgICAgICAgICAgICAgICAvKiBjYWxsRGF0YSAqLyAnMHgwMTIzNCcsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmZyb20pLnRvLmVxdWFsKCcweGZyb21hZGRyZXNzJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2FzTGltaXQpLnRvLmVxdWFsKEJpZ0ludCgyMTAwMDAwMDApKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5tYXhGZWVQZXJHYXMpLnRvLmVxdWFsKEJpZ0ludCgyMDAwMDApKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5tYXhQcmlvcml0eUZlZVBlckdhcykudG8uZXF1YWwoQmlnSW50KDEwMDAwMCkpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm5vbmNlKS50by5lcXVhbCgyMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQudG8pLnRvLmVxdWFsKCcweHRvYWRkcmVzcycpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlKS50by5lcXVhbCgwKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoXCJ1c2VzIHRoZSBwcm94eSBhZGRyZXNzIGlmIG5vICd0bycgYWRkcmVzcyBpcyBwcm92aWRlZFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR4T3B0aW9uczogVHhEYXRhID0geyBmcm9tOiAnMHhmcm9tYWRkcmVzcycgfTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJmcUJsb2NrY2hhaW5VdGlscy50cmFuc2Zvcm1UeERhdGFUb1RyYW5zYWN0aW9uUmVxdWVzdCh0eE9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC50bykudG8uZXF1YWwoemVyb0V4LmFkZHJlc3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ2dldERlY29kZWRSZnFPcmRlckZpbGxFdmVudExvZ0Zyb21Mb2dzJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCdjb3JyZWN0bHkgcGFyc2VzIGFuIFJmcU9yZGVyRmlsbEV2ZW50IGZyb20gbG9ncycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmZxT3JkZXJGaWxsZWRFdmVudCA9IHJmcUJsb2NrY2hhaW5VdGlscy5nZXREZWNvZGVkUmZxT3JkZXJGaWxsRXZlbnRMb2dGcm9tTG9ncyhbXHJcbiAgICAgICAgICAgICAgICBURVNUX1JGUV9PUkRFUl9GSUxMRURfRVZFTlRfTE9HLFxyXG4gICAgICAgICAgICBdKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZnFPcmRlckZpbGxlZEV2ZW50LmFyZ3MudGFrZXJUb2tlbkZpbGxlZEFtb3VudCkudG8uZGVlcC5lcShcclxuICAgICAgICAgICAgICAgIFRFU1RfUkZRX09SREVSX0ZJTExFRF9FVkVOVF9UQUtFUl9BTU9VTlQsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZnFPcmRlckZpbGxlZEV2ZW50LmJsb2NrTnVtYmVyKS50by5kZWVwLmVxKFRFU1RfUkZRX09SREVSX0ZJTExFRF9FVkVOVF9MT0cuYmxvY2tOdW1iZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ2dldFRva2VuRGVjaW1hbHNBc3luYycsICgpID0+IHtcclxuICAgICAgICBpdCgnZ2V0cyB0aGUgdG9rZW4gZGVjaW1hbHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxzID0gYXdhaXQgcmZxQmxvY2tjaGFpblV0aWxzLmdldFRva2VuRGVjaW1hbHNBc3luYyhtYWtlclRva2VuLmFkZHJlc3MpO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KGRlY2ltYWxzKS50by5lcXVhbCgxOCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCd0aHJvd3MgaWYgdGhlIGNvbnRyYWN0IGRvZXMgbm90IGV4aXN0JywgKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLXVudXNlZC1leHByZXNzaW9uIG5vLXVuYm91bmQtbWV0aG9kXHJcbiAgICAgICAgICAgIGV4cGVjdChyZnFCbG9ja2NoYWluVXRpbHMuZ2V0VG9rZW5EZWNpbWFsc0FzeW5jKCcweDI5RDdkMWRkNUI2ZjlDODY0ZDlkYjU2MEQ3MmEyNDdjMTc4YUU4NkInKSkudG8uYmVcclxuICAgICAgICAgICAgICAgIC5yZWplY3RlZDtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdpc1ZhbGlkT3JkZXJTaWduZXInLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ3JldHVybnMgZmFsc2UgaWYgc2lnbmVyIGlzIG5vdCB2YWxpZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZE9yZGVyU2lnbmVyID0gYXdhaXQgcmZxQmxvY2tjaGFpblV0aWxzLmlzVmFsaWRPcmRlclNpZ25lckFzeW5jKG1ha2VyLCBzaWduZXIpO1xyXG4gICAgICAgICAgICBleHBlY3QoaXNWYWxpZE9yZGVyU2lnbmVyKS50by5lcXVhbChmYWxzZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdyZXR1cm5zIHRydWUgd2hlbiB2YWxpZCBzaWduZXIgYWRkcmVzcyBpcyBwYXNzZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHJmcUJsb2NrY2hhaW5VdGlscy5yZWdpc3RlckFsbG93ZWRPcmRlclNpZ25lckFzeW5jKG1ha2VyLCBzaWduZXIsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZE9yZGVyU2lnbmVyID0gYXdhaXQgcmZxQmxvY2tjaGFpblV0aWxzLmlzVmFsaWRPcmRlclNpZ25lckFzeW5jKG1ha2VyLCBzaWduZXIpO1xyXG4gICAgICAgICAgICBleHBlY3QoaXNWYWxpZE9yZGVyU2lnbmVyKS50by5lcXVhbCh0cnVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdnZW5lcmF0ZUFwcHJvdmFsQ2FsbGRhdGFBc3luYycsICgpID0+IHtcclxuICAgICAgICBpdCgnZ2VuZXJhdGVzIGV4ZWN1dGVNZXRhVHJhbnNhY3Rpb24gY2FsbGRhdGEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gbWFrZXJUb2tlbi5hZGRyZXNzO1xyXG4gICAgICAgICAgICBjb25zdCBhcHByb3ZhbCA9IE1PQ0tfRVhFQ1VURV9NRVRBX1RSQU5TQUNUSU9OX0FQUFJPVkFMO1xyXG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmU6IFNpZ25hdHVyZSA9IHtcclxuICAgICAgICAgICAgICAgIHI6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxyXG4gICAgICAgICAgICAgICAgczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXHJcbiAgICAgICAgICAgICAgICB2OiAyOCxcclxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZVR5cGU6IDIsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbGxkYXRhID0gYXdhaXQgcmZxQmxvY2tjaGFpblV0aWxzLmdlbmVyYXRlQXBwcm92YWxDYWxsZGF0YUFzeW5jKHRva2VuLCBhcHByb3ZhbCwgc2lnbmF0dXJlKTtcclxuICAgICAgICAgICAgZXhwZWN0KGNhbGxkYXRhKS50by5lcShNT0NLX0VYRUNVVEVfTUVUQV9UUkFOU0FDVElPTl9DQUxMREFUQSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdnZW5lcmF0ZXMgcGVybWl0IGNhbGxkYXRhJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IG1ha2VyVG9rZW4uYWRkcmVzcztcclxuICAgICAgICAgICAgY29uc3QgYXBwcm92YWwgPSBNT0NLX1BFUk1JVF9BUFBST1ZBTDtcclxuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlOiBTaWduYXR1cmUgPSB7XHJcbiAgICAgICAgICAgICAgICByOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcclxuICAgICAgICAgICAgICAgIHM6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxyXG4gICAgICAgICAgICAgICAgdjogMjgsXHJcbiAgICAgICAgICAgICAgICBzaWduYXR1cmVUeXBlOiAyLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBjYWxsZGF0YSA9IGF3YWl0IHJmcUJsb2NrY2hhaW5VdGlscy5nZW5lcmF0ZUFwcHJvdmFsQ2FsbGRhdGFBc3luYyh0b2tlbiwgYXBwcm92YWwsIHNpZ25hdHVyZSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChjYWxsZGF0YSkudG8uZXEoTU9DS19QRVJNSVRfQ0FMTERBVEEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ2VzdGltYXRlR2FzRm9yQXN5bmMnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ3Rocm93cyBleGNlcHRpb24gb24gaW52YWxpZCBjYWxsZGF0YScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXJjMjBBYmlEZWNpbWFscyA9IGBbe1xyXG4gICAgICAgICAgICAgICAgXCJjb25zdGFudFwiOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgXCJpbnB1dHNcIjogW10sXHJcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJkZWNpbWFsc1wiLFxyXG4gICAgICAgICAgICAgICAgXCJvdXRwdXRzXCI6IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1aW50OFwiXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIFwicGF5YWJsZVwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgICAgICB9XWA7XHJcbiAgICAgICAgICAgIGNvbnN0IGVyYzIwID0gbmV3IENvbnRyYWN0KHRha2VyVG9rZW4uYWRkcmVzcywgZXJjMjBBYmlEZWNpbWFscyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogY2FsbGRhdGEgfSA9IGF3YWl0IGVyYzIwLnBvcHVsYXRlVHJhbnNhY3Rpb24uZGVjaW1hbHMoKTtcclxuICAgICAgICAgICAgaWYgKCFjYWxsZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsZGF0YSBmb3IgZGVjaW1hbHMgc2hvdWxkIG5vdCBiZSB1bmRlZmluZWQgb3IgZW1wdHknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpbnZhbGlkQ2FsbGRhdGEgPSBgJHtjYWxsZGF0YS5zdWJzdHJpbmcoMCwgY2FsbGRhdGEubGVuZ3RoIC0gMSl9MGA7XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgcmZxQmxvY2tjaGFpblV0aWxzLmVzdGltYXRlR2FzRm9yQXN5bmMoeyB0bzogdGFrZXJUb2tlbi5hZGRyZXNzLCBkYXRhOiBpbnZhbGlkQ2FsbGRhdGEgfSk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QuZmFpbCgpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoZS5tZXNzYWdlKS50by5jb250YWluKCdlc3RpbWF0ZUdhc0ZvckFzeW5jJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3N1Y2Nlc3NmdWxseSBlc3RpbWF0ZXMgZ2FzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlcmMyMEFiaURlY2ltYWxzID0gYFt7XHJcbiAgICAgICAgICAgICAgICBcImNvbnN0YW50XCI6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBcImlucHV0c1wiOiBbXSxcclxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImRlY2ltYWxzXCIsXHJcbiAgICAgICAgICAgICAgICBcIm91dHB1dHNcIjogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVpbnQ4XCJcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJwYXlhYmxlXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJ2aWV3XCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgIH1dYDtcclxuICAgICAgICAgICAgY29uc3QgZXJjMjAgPSBuZXcgQ29udHJhY3QodGFrZXJUb2tlbi5hZGRyZXNzLCBlcmMyMEFiaURlY2ltYWxzKTtcclxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBjYWxsZGF0YSB9ID0gYXdhaXQgZXJjMjAucG9wdWxhdGVUcmFuc2FjdGlvbi5kZWNpbWFscygpO1xyXG4gICAgICAgICAgICBpZiAoIWNhbGxkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxkYXRhIGZvciBkZWNpbWFscyBzaG91bGQgbm90IGJlIHVuZGVmaW5lZCBvciBlbXB0eScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhd2FpdCByZnFCbG9ja2NoYWluVXRpbHMuZXN0aW1hdGVHYXNGb3JBc3luYyh7IHRvOiB0YWtlclRva2VuLmFkZHJlc3MsIGRhdGE6IGNhbGxkYXRhIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn0pO1xyXG4iXSwidmVyc2lvbiI6M30=