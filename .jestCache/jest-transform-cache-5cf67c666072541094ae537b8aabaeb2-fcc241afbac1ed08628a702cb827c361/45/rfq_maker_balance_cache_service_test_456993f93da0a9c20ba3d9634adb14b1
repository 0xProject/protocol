d576179f78f475f386d11dd785122e6d
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const contract_addresses_1 = require("@0x/contract-addresses");
const utils_1 = require("@0x/utils");
const chai_1 = require("chai");
const ts_mockito_1 = require("ts-mockito");
const rfq_maker_balance_cache_service_1 = require("../../src/services/rfq_maker_balance_cache_service");
const cache_client_1 = require("../../src/utils/cache_client");
const rfq_blockchain_utils_1 = require("../../src/utils/rfq_blockchain_utils");
describe('RfqMakerBalanceCacheService', () => {
    const chainId = contract_addresses_1.ChainId.Ganache;
    const makerA = '0x1111111111111111111111111111111111111111';
    const makerB = '0x2222222222222222222222222222222222222222';
    const makerC = '0x3333333333333333333333333333333333333333';
    const tokenA = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';
    const tokenB = '0x6B175474E89094C44Da98b954EedeAC495271d0F';
    const tokenC = '0xdAC17F958D2ee523a2206206994597C13D831ec7';
    describe('getERC20OwnerBalancesAsync', () => {
        it('should get maker balances from the cache', async () => {
            const addresses = [
                { owner: makerA, token: tokenA },
                { owner: makerB, token: tokenB },
                { owner: makerC, token: tokenC },
            ];
            const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
            (0, ts_mockito_1.when)(cacheClientMock.getERC20OwnerBalancesAsync(chainId, addresses)).thenResolve([
                new utils_1.BigNumber(1),
                new utils_1.BigNumber(2),
                new utils_1.BigNumber(3),
            ]);
            const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
            const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
            (0, chai_1.expect)(await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, addresses)).to.deep.eq([
                new utils_1.BigNumber(1),
                new utils_1.BigNumber(2),
                new utils_1.BigNumber(3),
            ]);
            (0, ts_mockito_1.verify)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).never();
        });
        it('should fetch balances through balance check for addresses not found in the cache', async () => {
            const addresses = [
                { owner: makerA, token: tokenA },
                { owner: makerB, token: tokenB },
                { owner: makerC, token: tokenC },
            ];
            const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
            (0, ts_mockito_1.when)(cacheClientMock.getERC20OwnerBalancesAsync(chainId, addresses)).thenResolve([
                null,
                new utils_1.BigNumber(2),
                null,
            ]);
            (0, ts_mockito_1.when)(cacheClientMock.addERC20OwnerAsync(chainId, (0, ts_mockito_1.anything)())).thenResolve();
            const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
            (0, ts_mockito_1.when)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).thenResolve([
                new utils_1.BigNumber(1),
                new utils_1.BigNumber(3),
            ]);
            const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
            (0, chai_1.expect)(await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, addresses)).to.deep.eq([
                new utils_1.BigNumber(1),
                new utils_1.BigNumber(2),
                new utils_1.BigNumber(3),
            ]);
            (0, ts_mockito_1.verify)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).once();
        });
        it('should get zero addresses if balance check returns malformed results', async () => {
            const addresses = [
                { owner: makerA, token: tokenA },
                { owner: makerB, token: tokenB },
                { owner: makerC, token: tokenC },
            ];
            const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
            (0, ts_mockito_1.when)(cacheClientMock.getERC20OwnerBalancesAsync(chainId, addresses)).thenResolve([
                null,
                new utils_1.BigNumber(2),
                null,
            ]);
            (0, ts_mockito_1.when)(cacheClientMock.addERC20OwnerAsync(chainId, (0, ts_mockito_1.anything)())).thenResolve();
            const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
            (0, ts_mockito_1.when)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).thenResolve([]);
            const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
            (0, chai_1.expect)(await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, addresses)).to.deep.eq([
                new utils_1.BigNumber(0),
                new utils_1.BigNumber(2),
                new utils_1.BigNumber(0),
            ]);
            (0, ts_mockito_1.verify)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).once();
        });
        it('should throw an error if reading entries from the cache fails', async () => {
            const addresses = [
                { owner: makerA, token: tokenA },
                { owner: makerB, token: tokenB },
                { owner: makerC, token: '0xbadaddress' },
            ];
            const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
            (0, ts_mockito_1.when)(cacheClientMock.getERC20OwnerBalancesAsync((0, ts_mockito_1.anything)(), addresses)).thenReject(new Error('Failed to read entries from maker balance cache'));
            const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
            const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
            try {
                await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, addresses);
                chai_1.expect.fail();
            }
            catch (error) {
                (0, chai_1.expect)(error.message).to.contain('maker balance cache');
                (0, ts_mockito_1.verify)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).never();
            }
        });
        it('should get empty array when addresses are empty', async () => {
            const emptyAddresses = [];
            const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
            (0, ts_mockito_1.when)(cacheClientMock.getERC20OwnerBalancesAsync(chainId, emptyAddresses)).thenResolve([]);
            const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
            const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
            (0, chai_1.expect)(await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, emptyAddresses)).to.deep.eq([]);
            (0, ts_mockito_1.verify)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).never();
        });
    });
    describe('updateERC20OwnerBalancesAsync', () => {
        it('should update the cache with given maker balances', async () => {
            const addresses = [
                { owner: makerA, token: tokenA },
                { owner: makerB, token: tokenB },
                { owner: makerC, token: tokenC },
            ];
            const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
            (0, ts_mockito_1.when)(cacheClientMock.getERC20OwnersAsync(chainId)).thenResolve(addresses);
            (0, ts_mockito_1.when)(cacheClientMock.setERC20OwnerBalancesAsync(chainId, addresses, (0, ts_mockito_1.anything)())).thenResolve();
            const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
            (0, ts_mockito_1.when)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(addresses)).thenResolve([
                new utils_1.BigNumber(1),
                new utils_1.BigNumber(2),
                new utils_1.BigNumber(3),
            ]);
            const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
            try {
                await makerBalanceCacheService.updateERC20OwnerBalancesAsync(chainId);
                (0, ts_mockito_1.verify)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).once();
            }
            catch (error) {
                chai_1.expect.fail();
            }
        });
    });
    it('should throw an error if writing entries to the cache fails', async () => {
        const addresses = [
            { owner: makerA, token: tokenA },
            { owner: makerB, token: tokenB },
            { owner: makerC, token: tokenC },
        ];
        const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
        (0, ts_mockito_1.when)(cacheClientMock.getERC20OwnersAsync(chainId)).thenResolve(addresses);
        (0, ts_mockito_1.when)(cacheClientMock.setERC20OwnerBalancesAsync(chainId, addresses, (0, ts_mockito_1.anything)())).thenReject(new Error('Failed to update entries for maker balance cache'));
        const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
        (0, ts_mockito_1.when)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(addresses)).thenResolve([
            new utils_1.BigNumber(1),
            new utils_1.BigNumber(2),
            new utils_1.BigNumber(3),
        ]);
        const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
        try {
            await makerBalanceCacheService.updateERC20OwnerBalancesAsync(chainId);
            chai_1.expect.fail();
        }
        catch (error) {
            (0, chai_1.expect)(error.message).to.contain('maker balance cache');
            (0, ts_mockito_1.verify)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).once();
        }
    });
    describe('evictZeroBalancesAsync', () => {
        it('should evict entries from the cache', async () => {
            const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
            (0, ts_mockito_1.when)(cacheClientMock.evictZeroBalancesAsync(chainId)).thenResolve(1);
            const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
            const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
            try {
                const numEvicted = await makerBalanceCacheService.evictZeroBalancesAsync(chainId);
                (0, chai_1.expect)(numEvicted).to.eq(1);
                (0, ts_mockito_1.verify)(cacheClientMock.evictZeroBalancesAsync(chainId)).once();
            }
            catch (error) {
                chai_1.expect.fail();
            }
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3Rlc3Qvc2VydmljZXMvcmZxX21ha2VyX2JhbGFuY2VfY2FjaGVfc2VydmljZV90ZXN0LnRzIiwibWFwcGluZ3MiOiI7O0FBQUEsK0RBQWlEO0FBQ2pELHFDQUFzQztBQUN0QywrQkFBOEI7QUFDOUIsMkNBQW9FO0FBRXBFLHdHQUFpRztBQUVqRywrREFBMkQ7QUFDM0QsK0VBQTRFO0FBRTVFLFFBQVEsQ0FBQyw2QkFBNkIsRUFBRSxHQUFHLEVBQUU7SUFDekMsTUFBTSxPQUFPLEdBQUcsNEJBQU8sQ0FBQyxPQUFPLENBQUM7SUFFaEMsTUFBTSxNQUFNLEdBQUcsNENBQTRDLENBQUM7SUFDNUQsTUFBTSxNQUFNLEdBQUcsNENBQTRDLENBQUM7SUFDNUQsTUFBTSxNQUFNLEdBQUcsNENBQTRDLENBQUM7SUFFNUQsTUFBTSxNQUFNLEdBQUcsNENBQTRDLENBQUM7SUFDNUQsTUFBTSxNQUFNLEdBQUcsNENBQTRDLENBQUM7SUFDNUQsTUFBTSxNQUFNLEdBQUcsNENBQTRDLENBQUM7SUFFNUQsUUFBUSxDQUFDLDRCQUE0QixFQUFFLEdBQUcsRUFBRTtRQUN4QyxFQUFFLENBQUMsMENBQTBDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDdEQsTUFBTSxTQUFTLEdBQUc7Z0JBQ2QsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUU7Z0JBQ2hDLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFO2dCQUNoQyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRTthQUNuQyxDQUFDO1lBRUYsTUFBTSxlQUFlLEdBQUcsSUFBQSxpQkFBSSxFQUFDLDBCQUFXLENBQUMsQ0FBQztZQUMxQyxJQUFBLGlCQUFJLEVBQUMsZUFBZSxDQUFDLDBCQUEwQixDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQztnQkFDN0UsSUFB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QkFBcUIsQ0FBQyxDQUNsQyxDQUFDO1lBRUYsSUFBSTtnQkFDQSxNQUFNLFVBQVUsR0FBRyxNQUFNLHdCQUF3QixDQUFDLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUNsRixJQUFBLGFBQU0sRUFBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM1QixJQUFBLG1CQUFNLEVBQUMsZUFBZSxDQUFDLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDbEU7WUFBQyxPQUFPLEtBQUssRUFBRTtnQkFDWixhQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDakI7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3Rlc3Qvc2VydmljZXMvcmZxX21ha2VyX2JhbGFuY2VfY2FjaGVfc2VydmljZV90ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYWluSWQgfSBmcm9tICdAMHgvY29udHJhY3QtYWRkcmVzc2VzJztcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ0AweC91dGlscyc7XG5pbXBvcnQgeyBleHBlY3QgfSBmcm9tICdjaGFpJztcbmltcG9ydCB7IGFueXRoaW5nLCBpbnN0YW5jZSwgbW9jaywgdmVyaWZ5LCB3aGVuIH0gZnJvbSAndHMtbW9ja2l0byc7XG5cbmltcG9ydCB7IFJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSB9IGZyb20gJy4uLy4uL3NyYy9zZXJ2aWNlcy9yZnFfbWFrZXJfYmFsYW5jZV9jYWNoZV9zZXJ2aWNlJztcbmltcG9ydCB7IEVSQzIwT3duZXIgfSBmcm9tICcuLi8uLi9zcmMvY29yZS90eXBlcyc7XG5pbXBvcnQgeyBDYWNoZUNsaWVudCB9IGZyb20gJy4uLy4uL3NyYy91dGlscy9jYWNoZV9jbGllbnQnO1xuaW1wb3J0IHsgUmZxQmFsYW5jZUNoZWNrVXRpbHMgfSBmcm9tICcuLi8uLi9zcmMvdXRpbHMvcmZxX2Jsb2NrY2hhaW5fdXRpbHMnO1xuXG5kZXNjcmliZSgnUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlJywgKCkgPT4ge1xuICAgIGNvbnN0IGNoYWluSWQgPSBDaGFpbklkLkdhbmFjaGU7XG5cbiAgICBjb25zdCBtYWtlckEgPSAnMHgxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJztcbiAgICBjb25zdCBtYWtlckIgPSAnMHgyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyJztcbiAgICBjb25zdCBtYWtlckMgPSAnMHgzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzJztcblxuICAgIGNvbnN0IHRva2VuQSA9ICcweEMwMmFhQTM5YjIyM0ZFOEQwQTBlNUM0RjI3ZUFEOTA4M0M3NTZDYzInO1xuICAgIGNvbnN0IHRva2VuQiA9ICcweDZCMTc1NDc0RTg5MDk0QzQ0RGE5OGI5NTRFZWRlQUM0OTUyNzFkMEYnO1xuICAgIGNvbnN0IHRva2VuQyA9ICcweGRBQzE3Rjk1OEQyZWU1MjNhMjIwNjIwNjk5NDU5N0MxM0Q4MzFlYzcnO1xuXG4gICAgZGVzY3JpYmUoJ2dldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIGdldCBtYWtlciBiYWxhbmNlcyBmcm9tIHRoZSBjYWNoZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IFtcbiAgICAgICAgICAgICAgICB7IG93bmVyOiBtYWtlckEsIHRva2VuOiB0b2tlbkEgfSxcbiAgICAgICAgICAgICAgICB7IG93bmVyOiBtYWtlckIsIHRva2VuOiB0b2tlbkIgfSxcbiAgICAgICAgICAgICAgICB7IG93bmVyOiBtYWtlckMsIHRva2VuOiB0b2tlbkMgfSxcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlQ2xpZW50TW9jayA9IG1vY2soQ2FjaGVDbGllbnQpO1xuICAgICAgICAgICAgd2hlbihjYWNoZUNsaWVudE1vY2suZ2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmMoY2hhaW5JZCwgYWRkcmVzc2VzKSkudGhlblJlc29sdmUoW1xuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMSksXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcigyKSxcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDMpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlQ2hlY2tVdGlsc01vY2sgPSBtb2NrKFJmcUJhbGFuY2VDaGVja1V0aWxzKTtcbiAgICAgICAgICAgIGNvbnN0IG1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSA9IG5ldyBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UoXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UoY2FjaGVDbGllbnRNb2NrKSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZShiYWxhbmNlQ2hlY2tVdGlsc01vY2spLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZXhwZWN0KGF3YWl0IG1ha2VyQmFsYW5jZUNhY2hlU2VydmljZS5nZXRFUkMyME93bmVyQmFsYW5jZXNBc3luYyhjaGFpbklkLCBhZGRyZXNzZXMpKS50by5kZWVwLmVxKFtcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDEpLFxuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMiksXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcigzKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdmVyaWZ5KGJhbGFuY2VDaGVja1V0aWxzTW9jay5nZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKGFueXRoaW5nKCkpKS5uZXZlcigpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGZldGNoIGJhbGFuY2VzIHRocm91Z2ggYmFsYW5jZSBjaGVjayBmb3IgYWRkcmVzc2VzIG5vdCBmb3VuZCBpbiB0aGUgY2FjaGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXG4gICAgICAgICAgICAgICAgeyBvd25lcjogbWFrZXJBLCB0b2tlbjogdG9rZW5BIH0sXG4gICAgICAgICAgICAgICAgeyBvd25lcjogbWFrZXJCLCB0b2tlbjogdG9rZW5CIH0sXG4gICAgICAgICAgICAgICAgeyBvd25lcjogbWFrZXJDLCB0b2tlbjogdG9rZW5DIH0sXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBjb25zdCBjYWNoZUNsaWVudE1vY2sgPSBtb2NrKENhY2hlQ2xpZW50KTtcbiAgICAgICAgICAgIHdoZW4oY2FjaGVDbGllbnRNb2NrLmdldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKGNoYWluSWQsIGFkZHJlc3NlcykpLnRoZW5SZXNvbHZlKFtcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMiksXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgd2hlbihjYWNoZUNsaWVudE1vY2suYWRkRVJDMjBPd25lckFzeW5jKGNoYWluSWQsIGFueXRoaW5nKCkpKS50aGVuUmVzb2x2ZSgpO1xuICAgICAgICAgICAgY29uc3QgYmFsYW5jZUNoZWNrVXRpbHNNb2NrID0gbW9jayhSZnFCYWxhbmNlQ2hlY2tVdGlscyk7XG4gICAgICAgICAgICB3aGVuKGJhbGFuY2VDaGVja1V0aWxzTW9jay5nZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKGFueXRoaW5nKCkpKS50aGVuUmVzb2x2ZShbXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcigxKSxcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDMpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBjb25zdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UgPSBuZXcgUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlKFxuICAgICAgICAgICAgICAgIGluc3RhbmNlKGNhY2hlQ2xpZW50TW9jayksXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UoYmFsYW5jZUNoZWNrVXRpbHNNb2NrKSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChhd2FpdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UuZ2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmMoY2hhaW5JZCwgYWRkcmVzc2VzKSkudG8uZGVlcC5lcShbXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcigxKSxcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDIpLFxuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMyksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHZlcmlmeShiYWxhbmNlQ2hlY2tVdGlsc01vY2suZ2V0TWluT2ZCYWxhbmNlc0FuZEFsbG93YW5jZXNBc3luYyhhbnl0aGluZygpKSkub25jZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGdldCB6ZXJvIGFkZHJlc3NlcyBpZiBiYWxhbmNlIGNoZWNrIHJldHVybnMgbWFsZm9ybWVkIHJlc3VsdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXG4gICAgICAgICAgICAgICAgeyBvd25lcjogbWFrZXJBLCB0b2tlbjogdG9rZW5BIH0sXG4gICAgICAgICAgICAgICAgeyBvd25lcjogbWFrZXJCLCB0b2tlbjogdG9rZW5CIH0sXG4gICAgICAgICAgICAgICAgeyBvd25lcjogbWFrZXJDLCB0b2tlbjogdG9rZW5DIH0sXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBjb25zdCBjYWNoZUNsaWVudE1vY2sgPSBtb2NrKENhY2hlQ2xpZW50KTtcbiAgICAgICAgICAgIHdoZW4oY2FjaGVDbGllbnRNb2NrLmdldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKGNoYWluSWQsIGFkZHJlc3NlcykpLnRoZW5SZXNvbHZlKFtcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMiksXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgd2hlbihjYWNoZUNsaWVudE1vY2suYWRkRVJDMjBPd25lckFzeW5jKGNoYWluSWQsIGFueXRoaW5nKCkpKS50aGVuUmVzb2x2ZSgpO1xuICAgICAgICAgICAgY29uc3QgYmFsYW5jZUNoZWNrVXRpbHNNb2NrID0gbW9jayhSZnFCYWxhbmNlQ2hlY2tVdGlscyk7XG4gICAgICAgICAgICB3aGVuKGJhbGFuY2VDaGVja1V0aWxzTW9jay5nZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKGFueXRoaW5nKCkpKS50aGVuUmVzb2x2ZShbXSk7XG4gICAgICAgICAgICBjb25zdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UgPSBuZXcgUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlKFxuICAgICAgICAgICAgICAgIGluc3RhbmNlKGNhY2hlQ2xpZW50TW9jayksXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UoYmFsYW5jZUNoZWNrVXRpbHNNb2NrKSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChhd2FpdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UuZ2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmMoY2hhaW5JZCwgYWRkcmVzc2VzKSkudG8uZGVlcC5lcShbXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcigwKSxcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDIpLFxuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMCksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHZlcmlmeShiYWxhbmNlQ2hlY2tVdGlsc01vY2suZ2V0TWluT2ZCYWxhbmNlc0FuZEFsbG93YW5jZXNBc3luYyhhbnl0aGluZygpKSkub25jZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIHJlYWRpbmcgZW50cmllcyBmcm9tIHRoZSBjYWNoZSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IFtcbiAgICAgICAgICAgICAgICB7IG93bmVyOiBtYWtlckEsIHRva2VuOiB0b2tlbkEgfSxcbiAgICAgICAgICAgICAgICB7IG93bmVyOiBtYWtlckIsIHRva2VuOiB0b2tlbkIgfSxcbiAgICAgICAgICAgICAgICB7IG93bmVyOiBtYWtlckMsIHRva2VuOiAnMHhiYWRhZGRyZXNzJyB9LFxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgY29uc3QgY2FjaGVDbGllbnRNb2NrID0gbW9jayhDYWNoZUNsaWVudCk7XG4gICAgICAgICAgICB3aGVuKGNhY2hlQ2xpZW50TW9jay5nZXRFUkMyME93bmVyQmFsYW5jZXNBc3luYyhhbnl0aGluZygpLCBhZGRyZXNzZXMpKS50aGVuUmVqZWN0KFxuICAgICAgICAgICAgICAgIG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgZW50cmllcyBmcm9tIG1ha2VyIGJhbGFuY2UgY2FjaGUnKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlQ2hlY2tVdGlsc01vY2sgPSBtb2NrKFJmcUJhbGFuY2VDaGVja1V0aWxzKTtcbiAgICAgICAgICAgIGNvbnN0IG1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSA9IG5ldyBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UoXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UoY2FjaGVDbGllbnRNb2NrKSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZShiYWxhbmNlQ2hlY2tVdGlsc01vY2spLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UuZ2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmMoY2hhaW5JZCwgYWRkcmVzc2VzKTtcbiAgICAgICAgICAgICAgICBleHBlY3QuZmFpbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkudG8uY29udGFpbignbWFrZXIgYmFsYW5jZSBjYWNoZScpO1xuICAgICAgICAgICAgICAgIHZlcmlmeShiYWxhbmNlQ2hlY2tVdGlsc01vY2suZ2V0TWluT2ZCYWxhbmNlc0FuZEFsbG93YW5jZXNBc3luYyhhbnl0aGluZygpKSkubmV2ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBnZXQgZW1wdHkgYXJyYXkgd2hlbiBhZGRyZXNzZXMgYXJlIGVtcHR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW1wdHlBZGRyZXNzZXM6IEVSQzIwT3duZXJbXSA9IFtdO1xuXG4gICAgICAgICAgICBjb25zdCBjYWNoZUNsaWVudE1vY2sgPSBtb2NrKENhY2hlQ2xpZW50KTtcbiAgICAgICAgICAgIHdoZW4oY2FjaGVDbGllbnRNb2NrLmdldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKGNoYWluSWQsIGVtcHR5QWRkcmVzc2VzKSkudGhlblJlc29sdmUoW10pO1xuICAgICAgICAgICAgY29uc3QgYmFsYW5jZUNoZWNrVXRpbHNNb2NrID0gbW9jayhSZnFCYWxhbmNlQ2hlY2tVdGlscyk7XG4gICAgICAgICAgICBjb25zdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UgPSBuZXcgUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlKFxuICAgICAgICAgICAgICAgIGluc3RhbmNlKGNhY2hlQ2xpZW50TW9jayksXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UoYmFsYW5jZUNoZWNrVXRpbHNNb2NrKSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChhd2FpdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UuZ2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmMoY2hhaW5JZCwgZW1wdHlBZGRyZXNzZXMpKS50by5kZWVwLmVxKFtdKTtcbiAgICAgICAgICAgIHZlcmlmeShiYWxhbmNlQ2hlY2tVdGlsc01vY2suZ2V0TWluT2ZCYWxhbmNlc0FuZEFsbG93YW5jZXNBc3luYyhhbnl0aGluZygpKSkubmV2ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgndXBkYXRlRVJDMjBPd25lckJhbGFuY2VzQXN5bmMnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgdXBkYXRlIHRoZSBjYWNoZSB3aXRoIGdpdmVuIG1ha2VyIGJhbGFuY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW1xuICAgICAgICAgICAgICAgIHsgb3duZXI6IG1ha2VyQSwgdG9rZW46IHRva2VuQSB9LFxuICAgICAgICAgICAgICAgIHsgb3duZXI6IG1ha2VyQiwgdG9rZW46IHRva2VuQiB9LFxuICAgICAgICAgICAgICAgIHsgb3duZXI6IG1ha2VyQywgdG9rZW46IHRva2VuQyB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlQ2xpZW50TW9jayA9IG1vY2soQ2FjaGVDbGllbnQpO1xuICAgICAgICAgICAgd2hlbihjYWNoZUNsaWVudE1vY2suZ2V0RVJDMjBPd25lcnNBc3luYyhjaGFpbklkKSkudGhlblJlc29sdmUoYWRkcmVzc2VzKTtcbiAgICAgICAgICAgIHdoZW4oY2FjaGVDbGllbnRNb2NrLnNldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKGNoYWluSWQsIGFkZHJlc3NlcywgYW55dGhpbmcoKSkpLnRoZW5SZXNvbHZlKCk7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlQ2hlY2tVdGlsc01vY2sgPSBtb2NrKFJmcUJhbGFuY2VDaGVja1V0aWxzKTtcbiAgICAgICAgICAgIHdoZW4oYmFsYW5jZUNoZWNrVXRpbHNNb2NrLmdldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMoYWRkcmVzc2VzKSkudGhlblJlc29sdmUoW1xuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMSksXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcigyKSxcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDMpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBjb25zdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UgPSBuZXcgUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlKFxuICAgICAgICAgICAgICAgIGluc3RhbmNlKGNhY2hlQ2xpZW50TW9jayksXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UoYmFsYW5jZUNoZWNrVXRpbHNNb2NrKSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlLnVwZGF0ZUVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKGNoYWluSWQpO1xuICAgICAgICAgICAgICAgIHZlcmlmeShiYWxhbmNlQ2hlY2tVdGlsc01vY2suZ2V0TWluT2ZCYWxhbmNlc0FuZEFsbG93YW5jZXNBc3luYyhhbnl0aGluZygpKSkub25jZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QuZmFpbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgYW4gZXJyb3IgaWYgd3JpdGluZyBlbnRyaWVzIHRvIHRoZSBjYWNoZSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW1xuICAgICAgICAgICAgeyBvd25lcjogbWFrZXJBLCB0b2tlbjogdG9rZW5BIH0sXG4gICAgICAgICAgICB7IG93bmVyOiBtYWtlckIsIHRva2VuOiB0b2tlbkIgfSxcbiAgICAgICAgICAgIHsgb3duZXI6IG1ha2VyQywgdG9rZW46IHRva2VuQyB9LFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBjYWNoZUNsaWVudE1vY2sgPSBtb2NrKENhY2hlQ2xpZW50KTtcbiAgICAgICAgd2hlbihjYWNoZUNsaWVudE1vY2suZ2V0RVJDMjBPd25lcnNBc3luYyhjaGFpbklkKSkudGhlblJlc29sdmUoYWRkcmVzc2VzKTtcbiAgICAgICAgd2hlbihjYWNoZUNsaWVudE1vY2suc2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmMoY2hhaW5JZCwgYWRkcmVzc2VzLCBhbnl0aGluZygpKSkudGhlblJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBlbnRyaWVzIGZvciBtYWtlciBiYWxhbmNlIGNhY2hlJyksXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGJhbGFuY2VDaGVja1V0aWxzTW9jayA9IG1vY2soUmZxQmFsYW5jZUNoZWNrVXRpbHMpO1xuICAgICAgICB3aGVuKGJhbGFuY2VDaGVja1V0aWxzTW9jay5nZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKGFkZHJlc3NlcykpLnRoZW5SZXNvbHZlKFtcbiAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMSksXG4gICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDIpLFxuICAgICAgICAgICAgbmV3IEJpZ051bWJlcigzKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IG1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSA9IG5ldyBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UoXG4gICAgICAgICAgICBpbnN0YW5jZShjYWNoZUNsaWVudE1vY2spLFxuICAgICAgICAgICAgaW5zdGFuY2UoYmFsYW5jZUNoZWNrVXRpbHNNb2NrKSxcbiAgICAgICAgKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgbWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlLnVwZGF0ZUVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKGNoYWluSWQpO1xuICAgICAgICAgICAgZXhwZWN0LmZhaWwoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGV4cGVjdChlcnJvci5tZXNzYWdlKS50by5jb250YWluKCdtYWtlciBiYWxhbmNlIGNhY2hlJyk7XG4gICAgICAgICAgICB2ZXJpZnkoYmFsYW5jZUNoZWNrVXRpbHNNb2NrLmdldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMoYW55dGhpbmcoKSkpLm9uY2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2V2aWN0WmVyb0JhbGFuY2VzQXN5bmMnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgZXZpY3QgZW50cmllcyBmcm9tIHRoZSBjYWNoZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlQ2xpZW50TW9jayA9IG1vY2soQ2FjaGVDbGllbnQpO1xuICAgICAgICAgICAgd2hlbihjYWNoZUNsaWVudE1vY2suZXZpY3RaZXJvQmFsYW5jZXNBc3luYyhjaGFpbklkKSkudGhlblJlc29sdmUoMSk7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlQ2hlY2tVdGlsc01vY2sgPSBtb2NrKFJmcUJhbGFuY2VDaGVja1V0aWxzKTtcbiAgICAgICAgICAgIGNvbnN0IG1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSA9IG5ldyBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UoXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UoY2FjaGVDbGllbnRNb2NrKSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZShiYWxhbmNlQ2hlY2tVdGlsc01vY2spLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1FdmljdGVkID0gYXdhaXQgbWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlLmV2aWN0WmVyb0JhbGFuY2VzQXN5bmMoY2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KG51bUV2aWN0ZWQpLnRvLmVxKDEpO1xuICAgICAgICAgICAgICAgIHZlcmlmeShjYWNoZUNsaWVudE1vY2suZXZpY3RaZXJvQmFsYW5jZXNBc3luYyhjaGFpbklkKSkub25jZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QuZmFpbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9