dc5748d8293809cf16d7ea0c261f42cf
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DummyMMHandlers = void 0;
// tslint:disable:max-file-line-count
// tslint:disable: custom-no-magic-numbers
// tslint:disable: prefer-function-over-method
const contract_addresses_1 = require("@0x/contract-addresses");
const protocol_utils_1 = require("@0x/protocol-utils");
const utils_1 = require("@0x/utils");
const ethers_1 = require("ethers");
const HttpStatus = require("http-status-codes");
const constants_1 = require("../core/constants");
const rfqm_request_utils_1 = require("../utils/rfqm_request_utils");
const WETH_ROPSTEN = '0xc778417e063141139fce010982780140aa0cd5ab';
const TTA_ROPSTEN = '0x374a16f5e686c09b0cc9e8bc3466b3b645c74aa7';
const TTB_ROPSTEN = '0xf84830b73b2ed3c7267e7638f500110ea47fdf30';
const WMATIC_POLYGON = '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270';
const DAI_POLYGON = '0x8f3cf7ad23cd3cadbd9735aff958023239c6a063';
const USDC_POLYGON = '0x2791bca1f2de4661ed88a30c99a7a9449aa84174';
const USDT_POLYGON = '0xc2132d05d31c914a87c6611c10748aeb04b58e8f';
const RFQ1_MUMBAI = '0xbea1bca733a6f58c363d9eccfc62a806fa1afee7';
const RFQ2_MUMBAI = '0x72115b83bb0dc128785f3a66ad7d2dc484852d0c';
const RFQ3_MUMBAI = '0xb0a53dd97d672486f35787d23dc285a621537f21';
const MM_PRIVATE_KEY = process.env.MM_PRIVATE_KEY || '0xf0d8f376ca991256ddb256fb7cd28d68d971b07f5c0cf62cf0294c1ff8078a90';
const MM_ADDRESS = new ethers_1.Wallet(MM_PRIVATE_KEY).address;
const ROPSTEN_CHAIN_ID = 3;
const POLYGON_CHAIN_ID = 137;
const MUMBAI_CHAIN_ID = 80001;
const RFQT_NONCE_BUCKET = 0;
const tokenToDecimals = {
    [WETH_ROPSTEN]: 18,
    [TTA_ROPSTEN]: 18,
    [TTB_ROPSTEN]: 18,
    [WMATIC_POLYGON]: 18,
    [DAI_POLYGON]: 18,
    [USDC_POLYGON]: 6,
    [USDT_POLYGON]: 6,
    [RFQ1_MUMBAI]: 18,
    [RFQ2_MUMBAI]: 18,
    [RFQ3_MUMBAI]: 18,
};
const whitelistedIntegrators = new Set([
    '74188355-c85b-4f18-9de4-6dec3ec61b8d',
    '301e83b5-61f4-409b-bc61-8886dd56189d',
    '1c016c87-3128-4f78-b0f5-e90038d165ef',
    '83b02232-83ca-4e1e-af5d-46c563d6688e',
    '37f254d7-8fcf-4e97-ab6b-060364c0eaf5', // Simbot
]);
/**
 * This class implements handlers that are used to satisfy the MM Quote Server spec
 */
class DummyMMHandlers {
    constructor() {
        this._tokenSetByChainId = new Map();
        this._tokenSetByChainId.set(ROPSTEN_CHAIN_ID, new Set([WETH_ROPSTEN.toLocaleLowerCase(), TTA_ROPSTEN.toLowerCase(), TTB_ROPSTEN.toLowerCase()]));
        this._tokenSetByChainId.set(POLYGON_CHAIN_ID, new Set([
            USDC_POLYGON.toLowerCase(),
            USDT_POLYGON.toLowerCase(),
            WMATIC_POLYGON.toLowerCase(),
            DAI_POLYGON.toLowerCase(),
        ]));
        this._tokenSetByChainId.set(MUMBAI_CHAIN_ID, new Set([RFQ1_MUMBAI.toLowerCase(), RFQ2_MUMBAI.toLowerCase(), RFQ3_MUMBAI.toLowerCase()]));
    }
    static _parseQuoteRequest(req) {
        const { sellTokenAddress, buyTokenAddress, takerAddress, sellAmountBaseUnits, buyAmountBaseUnits, txOrigin, isLastLook, feeToken, feeAmount, feeType, chainId, } = req.query;
        const integratorId = req.headers['0x-integrator-id'];
        const isSelling = sellAmountBaseUnits !== undefined;
        const BASE_REQUEST = {
            sellTokenAddress: sellTokenAddress,
            buyTokenAddress: buyTokenAddress,
            takerAddress: takerAddress,
            txOrigin: txOrigin,
            isLastLook: isLastLook,
            feeToken: feeToken,
            feeAmount: feeAmount,
            feeType: feeType,
            chainId: chainId,
            integratorId: integratorId,
        };
        if (isSelling) {
            return {
                ...BASE_REQUEST,
                sellAmountBaseUnits: sellAmountBaseUnits,
            };
        }
        else {
            return {
                ...BASE_REQUEST,
                buyAmountBaseUnits: buyAmountBaseUnits,
            };
        }
    }
    static _parseSubmitRequest(
    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
    // eslint-disable-next-line @typescript-eslint/ban-types
    req) {
        const { order, orderHash, fee, takerTokenFillAmount } = req.body;
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const rawOrder = order;
        const rfqOrder = new protocol_utils_1.RfqOrder({
            txOrigin: rawOrder.txOrigin,
            expiry: new utils_1.BigNumber(rawOrder.expiry),
            pool: rawOrder.pool,
            salt: new utils_1.BigNumber(rawOrder.salt),
            makerToken: rawOrder.makerToken,
            takerToken: rawOrder.takerToken,
            makerAmount: new utils_1.BigNumber(rawOrder.makerAmount),
            takerAmount: new utils_1.BigNumber(rawOrder.takerAmount),
            maker: rawOrder.maker,
            taker: rawOrder.taker,
            chainId: rawOrder.chainId,
        });
        return {
            order: rfqOrder,
            orderHash,
            fee: fee,
            takerTokenFillAmount: new utils_1.BigNumber(takerTokenFillAmount),
        };
    }
    /**
     * Parse RFQm sign request.
     * @param req Incoming sign request.
     * @returns Parsed RFQm sign request object.
     */
    static _parseSignRfqmRequest(req) {
        const { order: orderRaw, orderHash, feeAmount: feeAmountRaw, feeToken: feeTokenRaw, expiry: expiryRaw, takerSignature: takerSignatureRaw, } = req.body;
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const order = new protocol_utils_1.OtcOrder((0, rfqm_request_utils_1.stringsToOtcOrderFields)(orderRaw));
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const takerSignature = (0, rfqm_request_utils_1.stringsToSignature)(takerSignatureRaw);
        const expiry = new utils_1.BigNumber(expiryRaw);
        return {
            order,
            orderHash: orderHash,
            feeAmount: feeAmountRaw,
            feeToken: feeTokenRaw,
            takerSignature,
            expiry,
        };
    }
    /**
     * Parse RFQt sign request.
     * @param req Incoming sign request.
     * @returns Parsed RFQt sign request object.
     */
    static _parseSignRfqtRequest(req) {
        const { order: orderRaw, orderHash, feeAmount: feeAmountRaw, feeToken: feeTokenRaw, expiry: expiryRaw, } = req.body;
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const order = new protocol_utils_1.OtcOrder((0, rfqm_request_utils_1.stringsToOtcOrderFields)(orderRaw));
        const expiry = new utils_1.BigNumber(expiryRaw);
        return {
            order,
            orderHash: orderHash,
            feeAmount: feeAmountRaw,
            feeToken: feeTokenRaw,
            expiry,
        };
    }
    /**
     * Simple pricing that always returns 1:1 v1 prices
     */
    async getPriceV1Async(req, res) {
        const params = DummyMMHandlers._parseQuoteRequest(req);
        const tokenSet = this._tokenSetByChainId.get(Number(params.chainId));
        const { sellTokenAddress, buyTokenAddress, sellAmountBaseUnits, buyAmountBaseUnits, integratorId } = params;
        // Check integrator
        if (!integratorId || !whitelistedIntegrators.has(integratorId)) {
            res.status(HttpStatus.BAD_REQUEST).send('Invalid integrator id');
            return;
        }
        // Check tokens
        if (!tokenSet ||
            !tokenSet.has(sellTokenAddress.toLowerCase()) ||
            !tokenSet.has(buyTokenAddress.toLowerCase())) {
            res.status(HttpStatus.NO_CONTENT).send({});
            return;
        }
        // Get amount (direction doesn't matter because price is always 1:1)
        const isSelling = sellAmountBaseUnits !== undefined;
        const rawAmount = (isSelling ? sellAmountBaseUnits : buyAmountBaseUnits);
        const amount = new utils_1.BigNumber(rawAmount);
        // Tokens
        const takerToken = sellTokenAddress;
        const makerToken = buyTokenAddress;
        // Expiry
        const now = new utils_1.BigNumber(Date.now());
        const fiveMinLater = now.plus(new utils_1.BigNumber(5).times(constants_1.ONE_MINUTE_MS)).div(constants_1.ONE_SECOND_MS).integerValue();
        const indicativeQuote = {
            expiry: fiveMinLater.toString(),
            makerToken,
            takerToken,
            makerAmount: amount.toString(),
            takerAmount: amount.toString(),
        };
        res.status(HttpStatus.OK).send(indicativeQuote);
        return;
    }
    /**
     * Simple pricing that always returns 1:1 v2 prices
     */
    async getPriceV2Async(req, res) {
        const params = DummyMMHandlers._parseQuoteRequest(req);
        const tokenSet = this._tokenSetByChainId.get(Number(params.chainId));
        const { sellTokenAddress, buyTokenAddress, sellAmountBaseUnits, buyAmountBaseUnits, integratorId } = params;
        // Check integrator
        if (!integratorId || !whitelistedIntegrators.has(integratorId)) {
            res.status(HttpStatus.BAD_REQUEST).send('Invalid integrator id');
            return;
        }
        // Check tokens
        if (!tokenSet ||
            !tokenSet.has(sellTokenAddress.toLowerCase()) ||
            !tokenSet.has(buyTokenAddress.toLowerCase())) {
            res.status(HttpStatus.NO_CONTENT).send({});
            return;
        }
        // Get amount (direction doesn't matter because price is always 1:1)
        const isSelling = sellAmountBaseUnits !== undefined;
        const rawAmount = (isSelling ? sellAmountBaseUnits : buyAmountBaseUnits);
        const amount = new utils_1.BigNumber(rawAmount);
        // Tokens
        const takerToken = sellTokenAddress;
        const makerToken = buyTokenAddress;
        // Expiry
        const now = new utils_1.BigNumber(Date.now());
        const fiveMinLater = now.plus(new utils_1.BigNumber(5).times(constants_1.ONE_MINUTE_MS)).div(constants_1.ONE_SECOND_MS).integerValue();
        const indicativeQuote = {
            expiry: fiveMinLater.toString(),
            makerToken,
            takerToken,
            makerAmount: amount.toString(),
            takerAmount: amount.toString(),
            maker: MM_ADDRESS,
        };
        res.status(HttpStatus.OK).send(indicativeQuote);
        return;
    }
    /**
     * Simple quoting that always signs an order 1:1 for RFQM v1
     */
    async getQuoteV1Async(req, res) {
        const params = DummyMMHandlers._parseQuoteRequest(req);
        const tokenSet = this._tokenSetByChainId.get(Number(params.chainId));
        const { sellTokenAddress, buyTokenAddress, sellAmountBaseUnits, buyAmountBaseUnits, txOrigin, takerAddress, integratorId, } = params;
        // Check integrator
        if (!integratorId || !whitelistedIntegrators.has(integratorId)) {
            res.status(HttpStatus.BAD_REQUEST).send('Invalid integrator id');
            return;
        }
        // Check tokens
        if (!tokenSet ||
            !tokenSet.has(sellTokenAddress.toLowerCase()) ||
            !tokenSet.has(buyTokenAddress.toLowerCase())) {
            res.status(HttpStatus.NO_CONTENT).send({});
            return;
        }
        // Get amount (direction doesn't matter because price is always 1:1)
        const isSelling = sellAmountBaseUnits !== undefined;
        const rawAmount = (isSelling ? sellAmountBaseUnits : buyAmountBaseUnits);
        const amount = new utils_1.BigNumber(rawAmount);
        // Tokens
        const takerToken = sellTokenAddress;
        const makerToken = buyTokenAddress;
        // Enforce a 5 unit maximum
        const oneUnit = 10 ** tokenToDecimals[takerToken];
        const fiveUnits = oneUnit * 5;
        if (amount.gt(fiveUnits)) {
            res.status(HttpStatus.NO_CONTENT).send({});
            return;
        }
        // Expiry
        const now = new utils_1.BigNumber(Date.now());
        const fiveMinLater = now.plus(new utils_1.BigNumber(5).times(constants_1.ONE_MINUTE_MS)).div(constants_1.ONE_SECOND_MS).integerValue();
        const rfqOrder = new protocol_utils_1.RfqOrder({
            txOrigin,
            taker: takerAddress,
            maker: MM_ADDRESS,
            takerToken,
            makerToken,
            makerAmount: new utils_1.BigNumber(amount.toString()),
            takerAmount: new utils_1.BigNumber(amount.toString()),
            expiry: fiveMinLater,
            chainId: Number(params.chainId),
            salt: now,
        });
        const orderHash = rfqOrder.getHash();
        const signature = (0, protocol_utils_1.ethSignHashWithKey)(orderHash, MM_PRIVATE_KEY);
        const firmQuote = {
            signedOrder: {
                ...rfqOrder,
                signature,
            },
        };
        res.status(HttpStatus.OK).send(firmQuote);
        return;
    }
    /**
     * Simple quoting for RFQt v2 that signs even taker amounts, but refuses to sign odd taker amounts, ignoring decimals.
     * The max trading size is 2 tokens.
     *
     * Example for WETH:
     * - 1.000_000_000_000_000_000 is considered odd!
     * - 2.000_000_000_000_000_001 is considered even!
     */
    async getQuoteRfqtV2Async(req, res) {
        const params = DummyMMHandlers._parseQuoteRequest(req);
        const chainId = Number(params.chainId);
        const tokenSet = this._tokenSetByChainId.get(chainId);
        const { sellTokenAddress, buyTokenAddress, sellAmountBaseUnits, buyAmountBaseUnits, txOrigin, takerAddress, integratorId, feeAmount, } = params;
        // Check integrator
        if (!integratorId || !whitelistedIntegrators.has(integratorId)) {
            res.status(HttpStatus.BAD_REQUEST).send('Invalid integrator id');
            return;
        }
        // Check tokens
        if (!tokenSet ||
            !tokenSet.has(sellTokenAddress.toLowerCase()) ||
            !tokenSet.has(buyTokenAddress.toLowerCase())) {
            res.status(HttpStatus.NO_CONTENT).send(`No liquidity for ${sellTokenAddress}:${buyTokenAddress}`);
            return;
        }
        // Get amount (direction doesn't matter because price is always 1:1)
        const isSelling = sellAmountBaseUnits !== undefined;
        const rawAmount = (isSelling ? sellAmountBaseUnits : buyAmountBaseUnits);
        const amount = new utils_1.BigNumber(rawAmount);
        // Tokens
        const takerToken = sellTokenAddress;
        const makerToken = buyTokenAddress;
        const decimals = tokenToDecimals[takerToken];
        // Enforce a 2 units maximum for trading
        const oneUnit = 10 ** decimals;
        if (amount.gt(oneUnit * 2)) {
            res.status(HttpStatus.NO_CONTENT).send('Trading limit for buy/sell tokens should not exceed 2');
            return;
        }
        const isEven = amount
            .div(10 ** decimals)
            .integerValue()
            .mod(2)
            .eq(0);
        // Reject
        if (!isEven) {
            res.status(HttpStatus.NO_CONTENT).send({});
            return;
        }
        // Expiry and nonce
        const now = new utils_1.BigNumber(Date.now());
        const expiry = now.plus(new utils_1.BigNumber(5).times(constants_1.ONE_MINUTE_MS)).div(constants_1.ONE_SECOND_MS).integerValue();
        const nowSeconds = Math.floor(Date.now() / constants_1.ONE_SECOND_MS);
        // Get Exchange Proxy contract address
        const exchangeProxyContractAddress = (0, contract_addresses_1.getContractAddressesForChainOrThrow)(chainId).exchangeProxy;
        const otcOrder = new protocol_utils_1.OtcOrder({
            txOrigin,
            expiryAndNonce: protocol_utils_1.OtcOrder.encodeExpiryAndNonce(expiry, new utils_1.BigNumber(RFQT_NONCE_BUCKET), new utils_1.BigNumber(nowSeconds)),
            takerToken,
            makerToken,
            makerAmount: amount,
            takerAmount: amount,
            maker: MM_ADDRESS,
            taker: takerAddress,
            chainId,
            verifyingContract: exchangeProxyContractAddress,
        });
        const orderHash = otcOrder.getHash();
        const signature = (0, protocol_utils_1.ethSignHashWithKey)(orderHash, MM_PRIVATE_KEY);
        const response = {
            feeAmount,
            order: otcOrder,
            orderHash,
            makerSignature: signature,
        };
        res.status(HttpStatus.OK).send(response);
    }
    /**
     * Approves even amounts and rejects odd amounts, ignoring decimals
     *
     * Example for WETH:
     * - 1.000_000_000_000_000_000 is considered odd!
     * - 2.000_000_000_000_000_001 is considered even!
     */
    async submitAsync(req, res) {
        const requestParams = DummyMMHandlers._parseSubmitRequest(req);
        const { order, fee, orderHash, takerTokenFillAmount } = requestParams;
        const decimals = tokenToDecimals[order.takerToken];
        const isEven = order.takerAmount
            .div(10 ** decimals)
            .integerValue()
            .mod(2)
            .eq(0);
        const response = {
            fee,
            proceedWithFill: isEven,
            signedOrderHash: orderHash,
            takerTokenFillAmount: takerTokenFillAmount.toString(),
        };
        res.status(HttpStatus.OK).send(response);
    }
    /**
     * Approves even amounts and rejects odd amounts, ignoring decimals
     *
     * Example for WETH:
     * - 1.000_000_000_000_000_000 is considered odd!
     * - 2.000_000_000_000_000_001 is considered even!
     */
    async signRfqmV2Async(req, res) {
        const requestParams = DummyMMHandlers._parseSignRfqmRequest(req);
        const { order, feeAmount, orderHash } = requestParams;
        const decimals = tokenToDecimals[order.takerToken];
        const isEven = order.takerAmount
            .div(10 ** decimals)
            .integerValue()
            .mod(2)
            .eq(0);
        // Reject
        if (!isEven) {
            res.status(HttpStatus.OK).send({
                proceedWithFill: false,
            });
            return;
        }
        // Accept and sign
        const signature = (0, protocol_utils_1.ethSignHashWithKey)(orderHash, MM_PRIVATE_KEY);
        const response = {
            feeAmount,
            proceedWithFill: isEven,
            makerSignature: signature,
        };
        res.status(HttpStatus.OK).send(response);
    }
    /**
     * Signs for even taker amounts, but refuses odd taker amounts, ignoring decimals. The logic is very similar to
     * `signRfqmV2Async` for consistency.
     *
     * Example for WETH:
     * - 1.000_000_000_000_000_000 is considered odd!
     * - 2.000_000_000_000_000_001 is considered even!
     */
    async signRfqtV2Async(req, res) {
        const requestParams = DummyMMHandlers._parseSignRfqtRequest(req);
        const { order, feeAmount, orderHash: orderHashParam } = requestParams;
        const orderHash = order.getHash();
        const tokenSet = this._tokenSetByChainId.get(Number(requestParams.order.chainId));
        // Check order hash computed from order is the same as order hash in query param
        if (orderHash !== orderHashParam) {
            res.status(HttpStatus.BAD_REQUEST).send(`orderHash query param provided ${orderHashParam} is not equal to the actual order hash ${orderHash}`);
            return;
        }
        // Check tokens
        if (!tokenSet ||
            !tokenSet.has(order.makerToken.toLowerCase()) ||
            !tokenSet.has(order.takerToken.toLowerCase())) {
            res.status(HttpStatus.NO_CONTENT).send(`No liquidity for ${order.makerToken}:${order.takerToken}`);
            return;
        }
        const decimals = tokenToDecimals[order.takerToken];
        const isEven = order.takerAmount
            .div(10 ** decimals)
            .integerValue()
            .mod(2)
            .eq(0);
        // Reject
        if (!isEven) {
            res.status(HttpStatus.NO_CONTENT).send({});
            return;
        }
        // Refuse to sign
        const signature = (0, protocol_utils_1.ethSignHashWithKey)(orderHash, MM_PRIVATE_KEY);
        const response = {
            feeAmount,
            makerSignature: signature,
        };
        res.status(HttpStatus.OK).send(response);
    }
}
exports.DummyMMHandlers = DummyMMHandlers;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9oYW5kbGVycy9kdW1teV9tbV9oYW5kbGVyLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUFxQztBQUNyQywwQ0FBMEM7QUFDMUMsOENBQThDO0FBQzlDLCtEQUE2RTtBQUM3RSx1REFBdUY7QUFDdkYscUNBQXNDO0FBQ3RDLG1DQUFnQztBQUVoQyxnREFBZ0Q7QUFFaEQsaURBQWlFO0FBR2pFLG9FQUEwRjtBQUUxRixNQUFNLFlBQVksR0FBRyw0Q0FBNEMsQ0FBQztBQUNsRSxNQUFNLFdBQVcsR0FBRyw0Q0FBNEMsQ0FBQztBQUNqRSxNQUFNLFdBQVcsR0FBRyw0Q0FBNEMsQ0FBQztBQUVqRSxNQUFNLGNBQWMsR0FBRyw0Q0FBNEMsQ0FBQztBQUNwRSxNQUFNLFdBQVcsR0FBRyw0Q0FBNEMsQ0FBQztBQUNqRSxNQUFNLFlBQVksR0FBRyw0Q0FBNEMsQ0FBQztBQUNsRSxNQUFNLFlBQVksR0FBRyw0Q0FBNEMsQ0FBQztBQUVsRSxNQUFNLFdBQVcsR0FBRyw0Q0FBNEMsQ0FBQztBQUNqRSxNQUFNLFdBQVcsR0FBRyw0Q0FBNEMsQ0FBQztBQUNqRSxNQUFNLFdBQVcsR0FBRyw0Q0FBNEMsQ0FBQztBQUVqRSxNQUFNLGNBQWMsR0FDaEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLElBQUksb0VBQW9FLENBQUM7QUFDdkcsTUFBTSxVQUFVLEdBQUcsSUFBSSxlQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsT0FBTyxDQUFDO0FBRXRELE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO0FBQzNCLE1BQU0sZ0JBQWdCLEdBQUcsR0FBRyxDQUFDO0FBQzdCLE1BQU0sZUFBZSxHQUFHLEtBQUssQ0FBQztBQUU5QixNQUFNLGlCQUFpQixHQUFHLENBQUMsQ0FBQztBQUU1QixNQUFNLGVBQWUsR0FBMkI7SUFDNUMsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFO0lBQ2xCLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFBRTtJQUNq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Q0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDM0MsT0FBTztTQUNWO1FBRUQsaUJBQWlCO1FBQ2pCLE1BQU0sU0FBUyxHQUFHLElBQUEsbUNBQWtCLEVBQUMsU0FBUyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ2hFLE1BQU0sUUFBUSxHQUFHO1lBQ2IsU0FBUztZQUNULGNBQWMsRUFBRSxTQUFTO1NBQzVCLENBQUM7UUFFRixHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0MsQ0FBQztDQUNKO0FBOWpCRCwwQ0E4akJDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXZpZHdhbHNoL2NvZGUtbG9jYWwvMHgtcmZxLWFwaS9zcmMvaGFuZGxlcnMvZHVtbXlfbW1faGFuZGxlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZTptYXgtZmlsZS1saW5lLWNvdW50XHJcbi8vIHRzbGludDpkaXNhYmxlOiBjdXN0b20tbm8tbWFnaWMtbnVtYmVyc1xyXG4vLyB0c2xpbnQ6ZGlzYWJsZTogcHJlZmVyLWZ1bmN0aW9uLW92ZXItbWV0aG9kXHJcbmltcG9ydCB7IGdldENvbnRyYWN0QWRkcmVzc2VzRm9yQ2hhaW5PclRocm93IH0gZnJvbSAnQDB4L2NvbnRyYWN0LWFkZHJlc3Nlcyc7XHJcbmltcG9ydCB7IGV0aFNpZ25IYXNoV2l0aEtleSwgT3RjT3JkZXIsIFJmcU9yZGVyLCBTaWduYXR1cmUgfSBmcm9tICdAMHgvcHJvdG9jb2wtdXRpbHMnO1xyXG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdAMHgvdXRpbHMnO1xyXG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tICdldGhlcnMnO1xyXG5pbXBvcnQgKiBhcyBleHByZXNzIGZyb20gJ2V4cHJlc3MnO1xyXG5pbXBvcnQgKiBhcyBIdHRwU3RhdHVzIGZyb20gJ2h0dHAtc3RhdHVzLWNvZGVzJztcclxuXHJcbmltcG9ydCB7IE9ORV9NSU5VVEVfTVMsIE9ORV9TRUNPTkRfTVMgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IEZlZSwgUXVvdGVTZXJ2ZXJQcmljZVBhcmFtcyB9IGZyb20gJy4uL2NvcmUvdHlwZXMnO1xyXG5pbXBvcnQgeyBTdWJtaXRSZXF1ZXN0IH0gZnJvbSAnLi4vcXVvdGUtc2VydmVyL3R5cGVzJztcclxuaW1wb3J0IHsgc3RyaW5nc1RvT3RjT3JkZXJGaWVsZHMsIHN0cmluZ3NUb1NpZ25hdHVyZSB9IGZyb20gJy4uL3V0aWxzL3JmcW1fcmVxdWVzdF91dGlscyc7XHJcblxyXG5jb25zdCBXRVRIX1JPUFNURU4gPSAnMHhjNzc4NDE3ZTA2MzE0MTEzOWZjZTAxMDk4Mjc4MDE0MGFhMGNkNWFiJztcclxuY29uc3QgVFRBX1JPUFNURU4gPSAnMHgzNzRhMTZmNWU2ODZjMDliMGNjOWU4YmMzNDY2YjNiNjQ1Yzc0YWE3JztcclxuY29uc3QgVFRCX1JPUFNURU4gPSAnMHhmODQ4MzBiNzNiMmVkM2M3MjY3ZTc2MzhmNTAwMTEwZWE0N2ZkZjMwJztcclxuXHJcbmNvbnN0IFdNQVRJQ19QT0xZR09OID0gJzB4MGQ1MDBiMWQ4ZThlZjMxZTIxYzk5ZDFkYjlhNjQ0NGQzYWRmMTI3MCc7XHJcbmNvbnN0IERBSV9QT0xZR09OID0gJzB4OGYzY2Y3YWQyM2NkM2NhZGJkOTczNWFmZjk1ODAyMzIzOWM2YTA2Myc7XHJcbmNvbnN0IFVTRENfUE9MWUdPTiA9ICcweDI3OTFiY2ExZjJkZTQ2NjFlZDg4YTMwYzk5YTdhOTQ0OWFhODQxNzQnO1xyXG5jb25zdCBVU0RUX1BPTFlHT04gPSAnMHhjMjEzMmQwNWQzMWM5MTRhODdjNjYxMWMxMDc0OGFlYjA0YjU4ZThmJztcclxuXHJcbmNvbnN0IFJGUTFfTVVNQkFJID0gJzB4YmVhMWJjYTczM2E2ZjU4YzM2M2Q5ZWNjZmM2MmE4MDZmYTFhZmVlNyc7XHJcbmNvbnN0IFJGUTJfTVVNQkFJID0gJzB4NzIxMTViODNiYjBkYzEyODc4NWYzYTY2YWQ3ZDJkYzQ4NDg1MmQwYyc7XHJcbmNvbnN0IFJGUTNfTVVNQkFJID0gJzB4YjBhNTNkZDk3ZDY3MjQ4NmYzNTc4N2QyM2RjMjg1YTYyMTUzN2YyMSc7XHJcblxyXG5jb25zdCBNTV9QUklWQVRFX0tFWSA9XHJcbiAgICBwcm9jZXNzLmVudi5NTV9QUklWQVRFX0tFWSB8fCAnMHhmMGQ4ZjM3NmNhOTkxMjU2ZGRiMjU2ZmI3Y2QyOGQ2OGQ5NzFiMDdmNWMwY2Y2MmNmMDI5NGMxZmY4MDc4YTkwJztcclxuY29uc3QgTU1fQUREUkVTUyA9IG5ldyBXYWxsZXQoTU1fUFJJVkFURV9LRVkpLmFkZHJlc3M7XHJcblxyXG5jb25zdCBST1BTVEVOX0NIQUlOX0lEID0gMztcclxuY29uc3QgUE9MWUdPTl9DSEFJTl9JRCA9IDEzNztcclxuY29uc3QgTVVNQkFJX0NIQUlOX0lEID0gODAwMDE7XHJcblxyXG5jb25zdCBSRlFUX05PTkNFX0JVQ0tFVCA9IDA7XHJcblxyXG5jb25zdCB0b2tlblRvRGVjaW1hbHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XHJcbiAgICBbV0VUSF9ST1BTVEVOXTogMTgsXHJcbiAgICBbVFRBX1JPUFNURU5dOiAxOCxcclxuICAgIFtUVEJfUk9QU1RFTl06IDE4LFxyXG4gICAgW1dNQVRJQ19QT0xZR09OXTogMTgsXHJcbiAgICBbREFJX1BPTFlHT05dOiAxOCxcclxuICAgIFtVU0RDX1BPTFlHT05dOiA2LFxyXG4gICAgW1VTRFRfUE9MWUdPTl06IDYsXHJcbiAgICBbUkZRMV9NVU1CQUldOiAxOCxcclxuICAgIFtSRlEyX01VTUJBSV06IDE4LFxyXG4gICAgW1JGUTNfTVVNQkFJXTogMTgsXHJcbn07XHJcblxyXG5jb25zdCB3aGl0ZWxpc3RlZEludGVncmF0b3JzID0gbmV3IFNldChbXHJcbiAgICAnNzQxODgzNTUtYzg1Yi00ZjE4LTlkZTQtNmRlYzNlYzYxYjhkJywgLy8gUkhcclxuICAgICczMDFlODNiNS02MWY0LTQwOWItYmM2MS04ODg2ZGQ1NjE4OWQnLCAvLyBSSCBUZXN0bmV0c1xyXG4gICAgJzFjMDE2Yzg3LTMxMjgtNGY3OC1iMGY1LWU5MDAzOGQxNjVlZicsIC8vIDB4IFJGUVxyXG4gICAgJzgzYjAyMjMyLTgzY2EtNGUxZS1hZjVkLTQ2YzU2M2Q2Njg4ZScsIC8vIFJGUSBMb2FkIFRlc3RlclxyXG4gICAgJzM3ZjI1NGQ3LThmY2YtNGU5Ny1hYjZiLTA2MDM2NGMwZWFmNScsIC8vIFNpbWJvdFxyXG5dKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGltcGxlbWVudHMgaGFuZGxlcnMgdGhhdCBhcmUgdXNlZCB0byBzYXRpc2Z5IHRoZSBNTSBRdW90ZSBTZXJ2ZXIgc3BlY1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIER1bW15TU1IYW5kbGVycyB7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF90b2tlblNldEJ5Q2hhaW5JZDogTWFwPG51bWJlciB8IHVuZGVmaW5lZCwgU2V0PHN0cmluZz4+O1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF9wYXJzZVF1b3RlUmVxdWVzdChyZXE6IGV4cHJlc3MuUmVxdWVzdCk6IFF1b3RlU2VydmVyUHJpY2VQYXJhbXMgJiB7IGludGVncmF0b3JJZD86IHN0cmluZyB9IHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHNlbGxUb2tlbkFkZHJlc3MsXHJcbiAgICAgICAgICAgIGJ1eVRva2VuQWRkcmVzcyxcclxuICAgICAgICAgICAgdGFrZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICBzZWxsQW1vdW50QmFzZVVuaXRzLFxyXG4gICAgICAgICAgICBidXlBbW91bnRCYXNlVW5pdHMsXHJcbiAgICAgICAgICAgIHR4T3JpZ2luLFxyXG4gICAgICAgICAgICBpc0xhc3RMb29rLFxyXG4gICAgICAgICAgICBmZWVUb2tlbixcclxuICAgICAgICAgICAgZmVlQW1vdW50LFxyXG4gICAgICAgICAgICBmZWVUeXBlLFxyXG4gICAgICAgICAgICBjaGFpbklkLFxyXG4gICAgICAgIH0gPSByZXEucXVlcnk7XHJcblxyXG4gICAgICAgIGNvbnN0IGludGVncmF0b3JJZCA9IHJlcS5oZWFkZXJzWycweC1pbnRlZ3JhdG9yLWlkJ107XHJcblxyXG4gICAgICAgIGNvbnN0IGlzU2VsbGluZyA9IHNlbGxBbW91bnRCYXNlVW5pdHMgIT09IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgY29uc3QgQkFTRV9SRVFVRVNUID0ge1xyXG4gICAgICAgICAgICBzZWxsVG9rZW5BZGRyZXNzOiBzZWxsVG9rZW5BZGRyZXNzIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgYnV5VG9rZW5BZGRyZXNzOiBidXlUb2tlbkFkZHJlc3MgYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICB0YWtlckFkZHJlc3M6IHRha2VyQWRkcmVzcyBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgIHR4T3JpZ2luOiB0eE9yaWdpbiBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgIGlzTGFzdExvb2s6IGlzTGFzdExvb2sgYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICBmZWVUb2tlbjogZmVlVG9rZW4gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICBmZWVBbW91bnQ6IGZlZUFtb3VudCBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgIGZlZVR5cGU6IGZlZVR5cGUgYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgaW50ZWdyYXRvcklkOiBpbnRlZ3JhdG9ySWQgYXMgc3RyaW5nLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChpc1NlbGxpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC4uLkJBU0VfUkVRVUVTVCxcclxuICAgICAgICAgICAgICAgIHNlbGxBbW91bnRCYXNlVW5pdHM6IHNlbGxBbW91bnRCYXNlVW5pdHMgYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5CQVNFX1JFUVVFU1QsXHJcbiAgICAgICAgICAgICAgICBidXlBbW91bnRCYXNlVW5pdHM6IGJ1eUFtb3VudEJhc2VVbml0cyBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF9wYXJzZVN1Ym1pdFJlcXVlc3QoXHJcbiAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcbiAgICAgICAgcmVxOiBleHByZXNzLlJlcXVlc3Q8e30sIHt9LCBSZWNvcmQ8a2V5b2YgU3VibWl0UmVxdWVzdCwgc3RyaW5nPj4sXHJcbiAgICApOiBTdWJtaXRSZXF1ZXN0IHtcclxuICAgICAgICBjb25zdCB7IG9yZGVyLCBvcmRlckhhc2gsIGZlZSwgdGFrZXJUb2tlbkZpbGxBbW91bnQgfSA9IHJlcS5ib2R5O1xyXG5cclxuICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICBjb25zdCByYXdPcmRlciA9IG9yZGVyIGFzIGFueTtcclxuICAgICAgICBjb25zdCByZnFPcmRlciA9IG5ldyBSZnFPcmRlcih7XHJcbiAgICAgICAgICAgIHR4T3JpZ2luOiByYXdPcmRlci50eE9yaWdpbixcclxuICAgICAgICAgICAgZXhwaXJ5OiBuZXcgQmlnTnVtYmVyKHJhd09yZGVyLmV4cGlyeSksXHJcbiAgICAgICAgICAgIHBvb2w6IHJhd09yZGVyLnBvb2wsXHJcbiAgICAgICAgICAgIHNhbHQ6IG5ldyBCaWdOdW1iZXIocmF3T3JkZXIuc2FsdCksXHJcbiAgICAgICAgICAgIG1ha2VyVG9rZW46IHJhd09yZGVyLm1ha2VyVG9rZW4sXHJcbiAgICAgICAgICAgIHRha2VyVG9rZW46IHJhd09yZGVyLnRha2VyVG9rZW4sXHJcbiAgICAgICAgICAgIG1ha2VyQW1vdW50OiBuZXcgQmlnTnVtYmVyKHJhd09yZGVyLm1ha2VyQW1vdW50KSxcclxuICAgICAgICAgICAgdGFrZXJBbW91bnQ6IG5ldyBCaWdOdW1iZXIocmF3T3JkZXIudGFrZXJBbW91bnQpLFxyXG4gICAgICAgICAgICBtYWtlcjogcmF3T3JkZXIubWFrZXIsXHJcbiAgICAgICAgICAgIHRha2VyOiByYXdPcmRlci50YWtlcixcclxuICAgICAgICAgICAgY2hhaW5JZDogcmF3T3JkZXIuY2hhaW5JZCxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3JkZXI6IHJmcU9yZGVyLFxyXG4gICAgICAgICAgICBvcmRlckhhc2gsXHJcbiAgICAgICAgICAgIGZlZTogZmVlIGFzIHVua25vd24gYXMgRmVlLFxyXG4gICAgICAgICAgICB0YWtlclRva2VuRmlsbEFtb3VudDogbmV3IEJpZ051bWJlcih0YWtlclRva2VuRmlsbEFtb3VudCksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIFJGUW0gc2lnbiByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIHJlcSBJbmNvbWluZyBzaWduIHJlcXVlc3QuXHJcbiAgICAgKiBAcmV0dXJucyBQYXJzZWQgUkZRbSBzaWduIHJlcXVlc3Qgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfcGFyc2VTaWduUmZxbVJlcXVlc3QocmVxOiBleHByZXNzLlJlcXVlc3QpOiB7XHJcbiAgICAgICAgZmVlQW1vdW50OiBzdHJpbmc7XHJcbiAgICAgICAgZmVlVG9rZW46IHN0cmluZztcclxuICAgICAgICBvcmRlcjogT3RjT3JkZXI7XHJcbiAgICAgICAgb3JkZXJIYXNoOiBzdHJpbmc7XHJcbiAgICAgICAgZXhwaXJ5OiBCaWdOdW1iZXI7XHJcbiAgICAgICAgdGFrZXJTaWduYXR1cmU6IFNpZ25hdHVyZTtcclxuICAgIH0ge1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgb3JkZXI6IG9yZGVyUmF3LFxyXG4gICAgICAgICAgICBvcmRlckhhc2gsXHJcbiAgICAgICAgICAgIGZlZUFtb3VudDogZmVlQW1vdW50UmF3LFxyXG4gICAgICAgICAgICBmZWVUb2tlbjogZmVlVG9rZW5SYXcsXHJcbiAgICAgICAgICAgIGV4cGlyeTogZXhwaXJ5UmF3LFxyXG4gICAgICAgICAgICB0YWtlclNpZ25hdHVyZTogdGFrZXJTaWduYXR1cmVSYXcsXHJcbiAgICAgICAgfSA9IHJlcS5ib2R5O1xyXG5cclxuICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICBjb25zdCBvcmRlciA9IG5ldyBPdGNPcmRlcihzdHJpbmdzVG9PdGNPcmRlckZpZWxkcyhvcmRlclJhdyBhcyBhbnkpKTtcclxuICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICBjb25zdCB0YWtlclNpZ25hdHVyZSA9IHN0cmluZ3NUb1NpZ25hdHVyZSh0YWtlclNpZ25hdHVyZVJhdyBhcyBhbnkpO1xyXG4gICAgICAgIGNvbnN0IGV4cGlyeSA9IG5ldyBCaWdOdW1iZXIoZXhwaXJ5UmF3IGFzIHN0cmluZyk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9yZGVyLFxyXG4gICAgICAgICAgICBvcmRlckhhc2g6IG9yZGVySGFzaCBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgIGZlZUFtb3VudDogZmVlQW1vdW50UmF3IGFzIHN0cmluZyxcclxuICAgICAgICAgICAgZmVlVG9rZW46IGZlZVRva2VuUmF3IGFzIHN0cmluZyxcclxuICAgICAgICAgICAgdGFrZXJTaWduYXR1cmUsXHJcbiAgICAgICAgICAgIGV4cGlyeSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgUkZRdCBzaWduIHJlcXVlc3QuXHJcbiAgICAgKiBAcGFyYW0gcmVxIEluY29taW5nIHNpZ24gcmVxdWVzdC5cclxuICAgICAqIEByZXR1cm5zIFBhcnNlZCBSRlF0IHNpZ24gcmVxdWVzdCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF9wYXJzZVNpZ25SZnF0UmVxdWVzdChyZXE6IGV4cHJlc3MuUmVxdWVzdCk6IHtcclxuICAgICAgICBmZWVBbW91bnQ6IHN0cmluZztcclxuICAgICAgICBmZWVUb2tlbjogc3RyaW5nO1xyXG4gICAgICAgIG9yZGVyOiBPdGNPcmRlcjtcclxuICAgICAgICBvcmRlckhhc2g6IHN0cmluZztcclxuICAgICAgICBleHBpcnk6IEJpZ051bWJlcjtcclxuICAgIH0ge1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgb3JkZXI6IG9yZGVyUmF3LFxyXG4gICAgICAgICAgICBvcmRlckhhc2gsXHJcbiAgICAgICAgICAgIGZlZUFtb3VudDogZmVlQW1vdW50UmF3LFxyXG4gICAgICAgICAgICBmZWVUb2tlbjogZmVlVG9rZW5SYXcsXHJcbiAgICAgICAgICAgIGV4cGlyeTogZXhwaXJ5UmF3LFxyXG4gICAgICAgIH0gPSByZXEuYm9keTtcclxuXHJcbiAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgY29uc3Qgb3JkZXIgPSBuZXcgT3RjT3JkZXIoc3RyaW5nc1RvT3RjT3JkZXJGaWVsZHMob3JkZXJSYXcgYXMgYW55KSk7XHJcbiAgICAgICAgY29uc3QgZXhwaXJ5ID0gbmV3IEJpZ051bWJlcihleHBpcnlSYXcgYXMgc3RyaW5nKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3JkZXIsXHJcbiAgICAgICAgICAgIG9yZGVySGFzaDogb3JkZXJIYXNoIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgZmVlQW1vdW50OiBmZWVBbW91bnRSYXcgYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICBmZWVUb2tlbjogZmVlVG9rZW5SYXcgYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICBleHBpcnksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl90b2tlblNldEJ5Q2hhaW5JZCA9IG5ldyBNYXA8bnVtYmVyIHwgdW5kZWZpbmVkLCBTZXQ8c3RyaW5nPj4oKTtcclxuICAgICAgICB0aGlzLl90b2tlblNldEJ5Q2hhaW5JZC5zZXQoXHJcbiAgICAgICAgICAgIFJPUFNURU5fQ0hBSU5fSUQsXHJcbiAgICAgICAgICAgIG5ldyBTZXQoW1dFVEhfUk9QU1RFTi50b0xvY2FsZUxvd2VyQ2FzZSgpLCBUVEFfUk9QU1RFTi50b0xvd2VyQ2FzZSgpLCBUVEJfUk9QU1RFTi50b0xvd2VyQ2FzZSgpXSksXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLl90b2tlblNldEJ5Q2hhaW5JZC5zZXQoXHJcbiAgICAgICAgICAgIFBPTFlHT05fQ0hBSU5fSUQsXHJcbiAgICAgICAgICAgIG5ldyBTZXQoW1xyXG4gICAgICAgICAgICAgICAgVVNEQ19QT0xZR09OLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICAgICBVU0RUX1BPTFlHT04udG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgIFdNQVRJQ19QT0xZR09OLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICAgICBEQUlfUE9MWUdPTi50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgICAgICBdKSxcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuX3Rva2VuU2V0QnlDaGFpbklkLnNldChcclxuICAgICAgICAgICAgTVVNQkFJX0NIQUlOX0lELFxyXG4gICAgICAgICAgICBuZXcgU2V0KFtSRlExX01VTUJBSS50b0xvd2VyQ2FzZSgpLCBSRlEyX01VTUJBSS50b0xvd2VyQ2FzZSgpLCBSRlEzX01VTUJBSS50b0xvd2VyQ2FzZSgpXSksXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbXBsZSBwcmljaW5nIHRoYXQgYWx3YXlzIHJldHVybnMgMToxIHYxIHByaWNlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0UHJpY2VWMUFzeW5jKHJlcTogZXhwcmVzcy5SZXF1ZXN0LCByZXM6IGV4cHJlc3MuUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSBEdW1teU1NSGFuZGxlcnMuX3BhcnNlUXVvdGVSZXF1ZXN0KHJlcSk7XHJcbiAgICAgICAgY29uc3QgdG9rZW5TZXQgPSB0aGlzLl90b2tlblNldEJ5Q2hhaW5JZC5nZXQoTnVtYmVyKHBhcmFtcy5jaGFpbklkKSk7XHJcbiAgICAgICAgY29uc3QgeyBzZWxsVG9rZW5BZGRyZXNzLCBidXlUb2tlbkFkZHJlc3MsIHNlbGxBbW91bnRCYXNlVW5pdHMsIGJ1eUFtb3VudEJhc2VVbml0cywgaW50ZWdyYXRvcklkIH0gPSBwYXJhbXM7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGludGVncmF0b3JcclxuICAgICAgICBpZiAoIWludGVncmF0b3JJZCB8fCAhd2hpdGVsaXN0ZWRJbnRlZ3JhdG9ycy5oYXMoaW50ZWdyYXRvcklkKSkge1xyXG4gICAgICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuQkFEX1JFUVVFU1QpLnNlbmQoJ0ludmFsaWQgaW50ZWdyYXRvciBpZCcpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayB0b2tlbnNcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICF0b2tlblNldCB8fFxyXG4gICAgICAgICAgICAhdG9rZW5TZXQuaGFzKHNlbGxUb2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgIXRva2VuU2V0LmhhcyhidXlUb2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLk5PX0NPTlRFTlQpLnNlbmQoe30pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBHZXQgYW1vdW50IChkaXJlY3Rpb24gZG9lc24ndCBtYXR0ZXIgYmVjYXVzZSBwcmljZSBpcyBhbHdheXMgMToxKVxyXG4gICAgICAgIGNvbnN0IGlzU2VsbGluZyA9IHNlbGxBbW91bnRCYXNlVW5pdHMgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCByYXdBbW91bnQgPSAoaXNTZWxsaW5nID8gc2VsbEFtb3VudEJhc2VVbml0cyA6IGJ1eUFtb3VudEJhc2VVbml0cykgYXMgc3RyaW5nO1xyXG4gICAgICAgIGNvbnN0IGFtb3VudCA9IG5ldyBCaWdOdW1iZXIocmF3QW1vdW50KTtcclxuXHJcbiAgICAgICAgLy8gVG9rZW5zXHJcbiAgICAgICAgY29uc3QgdGFrZXJUb2tlbiA9IHNlbGxUb2tlbkFkZHJlc3MgYXMgc3RyaW5nO1xyXG4gICAgICAgIGNvbnN0IG1ha2VyVG9rZW4gPSBidXlUb2tlbkFkZHJlc3MgYXMgc3RyaW5nO1xyXG5cclxuICAgICAgICAvLyBFeHBpcnlcclxuICAgICAgICBjb25zdCBub3cgPSBuZXcgQmlnTnVtYmVyKERhdGUubm93KCkpO1xyXG4gICAgICAgIGNvbnN0IGZpdmVNaW5MYXRlciA9IG5vdy5wbHVzKG5ldyBCaWdOdW1iZXIoNSkudGltZXMoT05FX01JTlVURV9NUykpLmRpdihPTkVfU0VDT05EX01TKS5pbnRlZ2VyVmFsdWUoKTtcclxuXHJcbiAgICAgICAgY29uc3QgaW5kaWNhdGl2ZVF1b3RlID0ge1xyXG4gICAgICAgICAgICBleHBpcnk6IGZpdmVNaW5MYXRlci50b1N0cmluZygpLFxyXG4gICAgICAgICAgICBtYWtlclRva2VuLFxyXG4gICAgICAgICAgICB0YWtlclRva2VuLFxyXG4gICAgICAgICAgICBtYWtlckFtb3VudDogYW1vdW50LnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHRha2VyQW1vdW50OiBhbW91bnQudG9TdHJpbmcoKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5PSykuc2VuZChpbmRpY2F0aXZlUXVvdGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbXBsZSBwcmljaW5nIHRoYXQgYWx3YXlzIHJldHVybnMgMToxIHYyIHByaWNlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0UHJpY2VWMkFzeW5jKHJlcTogZXhwcmVzcy5SZXF1ZXN0LCByZXM6IGV4cHJlc3MuUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSBEdW1teU1NSGFuZGxlcnMuX3BhcnNlUXVvdGVSZXF1ZXN0KHJlcSk7XHJcbiAgICAgICAgY29uc3QgdG9rZW5TZXQgPSB0aGlzLl90b2tlblNldEJ5Q2hhaW5JZC5nZXQoTnVtYmVyKHBhcmFtcy5jaGFpbklkKSk7XHJcbiAgICAgICAgY29uc3QgeyBzZWxsVG9rZW5BZGRyZXNzLCBidXlUb2tlbkFkZHJlc3MsIHNlbGxBbW91bnRCYXNlVW5pdHMsIGJ1eUFtb3VudEJhc2VVbml0cywgaW50ZWdyYXRvcklkIH0gPSBwYXJhbXM7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGludGVncmF0b3JcclxuICAgICAgICBpZiAoIWludGVncmF0b3JJZCB8fCAhd2hpdGVsaXN0ZWRJbnRlZ3JhdG9ycy5oYXMoaW50ZWdyYXRvcklkKSkge1xyXG4gICAgICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuQkFEX1JFUVVFU1QpLnNlbmQoJ0ludmFsaWQgaW50ZWdyYXRvciBpZCcpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayB0b2tlbnNcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICF0b2tlblNldCB8fFxyXG4gICAgICAgICAgICAhdG9rZW5TZXQuaGFzKHNlbGxUb2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgIXRva2VuU2V0LmhhcyhidXlUb2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLk5PX0NPTlRFTlQpLnNlbmQoe30pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBHZXQgYW1vdW50IChkaXJlY3Rpb24gZG9lc24ndCBtYXR0ZXIgYmVjYXVzZSBwcmljZSBpcyBhbHdheXMgMToxKVxyXG4gICAgICAgIGNvbnN0IGlzU2VsbGluZyA9IHNlbGxBbW91bnRCYXNlVW5pdHMgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCByYXdBbW91bnQgPSAoaXNTZWxsaW5nID8gc2VsbEFtb3VudEJhc2VVbml0cyA6IGJ1eUFtb3VudEJhc2VVbml0cykgYXMgc3RyaW5nO1xyXG4gICAgICAgIGNvbnN0IGFtb3VudCA9IG5ldyBCaWdOdW1iZXIocmF3QW1vdW50KTtcclxuXHJcbiAgICAgICAgLy8gVG9rZW5zXHJcbiAgICAgICAgY29uc3QgdGFrZXJUb2tlbiA9IHNlbGxUb2tlbkFkZHJlc3MgYXMgc3RyaW5nO1xyXG4gICAgICAgIGNvbnN0IG1ha2VyVG9rZW4gPSBidXlUb2tlbkFkZHJlc3MgYXMgc3RyaW5nO1xyXG5cclxuICAgICAgICAvLyBFeHBpcnlcclxuICAgICAgICBjb25zdCBub3cgPSBuZXcgQmlnTnVtYmVyKERhdGUubm93KCkpO1xyXG4gICAgICAgIGNvbnN0IGZpdmVNaW5MYXRlciA9IG5vdy5wbHVzKG5ldyBCaWdOdW1iZXIoNSkudGltZXMoT05FX01JTlVURV9NUykpLmRpdihPTkVfU0VDT05EX01TKS5pbnRlZ2VyVmFsdWUoKTtcclxuXHJcbiAgICAgICAgY29uc3QgaW5kaWNhdGl2ZVF1b3RlID0ge1xyXG4gICAgICAgICAgICBleHBpcnk6IGZpdmVNaW5MYXRlci50b1N0cmluZygpLFxyXG4gICAgICAgICAgICBtYWtlclRva2VuLFxyXG4gICAgICAgICAgICB0YWtlclRva2VuLFxyXG4gICAgICAgICAgICBtYWtlckFtb3VudDogYW1vdW50LnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHRha2VyQW1vdW50OiBhbW91bnQudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgbWFrZXI6IE1NX0FERFJFU1MsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuT0spLnNlbmQoaW5kaWNhdGl2ZVF1b3RlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW1wbGUgcXVvdGluZyB0aGF0IGFsd2F5cyBzaWducyBhbiBvcmRlciAxOjEgZm9yIFJGUU0gdjFcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldFF1b3RlVjFBc3luYyhyZXE6IGV4cHJlc3MuUmVxdWVzdCwgcmVzOiBleHByZXNzLlJlc3BvbnNlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gRHVtbXlNTUhhbmRsZXJzLl9wYXJzZVF1b3RlUmVxdWVzdChyZXEpO1xyXG4gICAgICAgIGNvbnN0IHRva2VuU2V0ID0gdGhpcy5fdG9rZW5TZXRCeUNoYWluSWQuZ2V0KE51bWJlcihwYXJhbXMuY2hhaW5JZCkpO1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgc2VsbFRva2VuQWRkcmVzcyxcclxuICAgICAgICAgICAgYnV5VG9rZW5BZGRyZXNzLFxyXG4gICAgICAgICAgICBzZWxsQW1vdW50QmFzZVVuaXRzLFxyXG4gICAgICAgICAgICBidXlBbW91bnRCYXNlVW5pdHMsXHJcbiAgICAgICAgICAgIHR4T3JpZ2luLFxyXG4gICAgICAgICAgICB0YWtlckFkZHJlc3MsXHJcbiAgICAgICAgICAgIGludGVncmF0b3JJZCxcclxuICAgICAgICB9ID0gcGFyYW1zO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpbnRlZ3JhdG9yXHJcbiAgICAgICAgaWYgKCFpbnRlZ3JhdG9ySWQgfHwgIXdoaXRlbGlzdGVkSW50ZWdyYXRvcnMuaGFzKGludGVncmF0b3JJZCkpIHtcclxuICAgICAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLkJBRF9SRVFVRVNUKS5zZW5kKCdJbnZhbGlkIGludGVncmF0b3IgaWQnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdG9rZW5zXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAhdG9rZW5TZXQgfHxcclxuICAgICAgICAgICAgIXRva2VuU2V0LmhhcyhzZWxsVG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICF0b2tlblNldC5oYXMoYnV5VG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5OT19DT05URU5UKS5zZW5kKHt9KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IGFtb3VudCAoZGlyZWN0aW9uIGRvZXNuJ3QgbWF0dGVyIGJlY2F1c2UgcHJpY2UgaXMgYWx3YXlzIDE6MSlcclxuICAgICAgICBjb25zdCBpc1NlbGxpbmcgPSBzZWxsQW1vdW50QmFzZVVuaXRzICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgcmF3QW1vdW50ID0gKGlzU2VsbGluZyA/IHNlbGxBbW91bnRCYXNlVW5pdHMgOiBidXlBbW91bnRCYXNlVW5pdHMpIGFzIHN0cmluZztcclxuICAgICAgICBjb25zdCBhbW91bnQgPSBuZXcgQmlnTnVtYmVyKHJhd0Ftb3VudCk7XHJcblxyXG4gICAgICAgIC8vIFRva2Vuc1xyXG4gICAgICAgIGNvbnN0IHRha2VyVG9rZW4gPSBzZWxsVG9rZW5BZGRyZXNzIGFzIHN0cmluZztcclxuICAgICAgICBjb25zdCBtYWtlclRva2VuID0gYnV5VG9rZW5BZGRyZXNzIGFzIHN0cmluZztcclxuXHJcbiAgICAgICAgLy8gRW5mb3JjZSBhIDUgdW5pdCBtYXhpbXVtXHJcbiAgICAgICAgY29uc3Qgb25lVW5pdCA9IDEwICoqIHRva2VuVG9EZWNpbWFsc1t0YWtlclRva2VuXTtcclxuICAgICAgICBjb25zdCBmaXZlVW5pdHMgPSBvbmVVbml0ICogNTtcclxuICAgICAgICBpZiAoYW1vdW50Lmd0KGZpdmVVbml0cykpIHtcclxuICAgICAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLk5PX0NPTlRFTlQpLnNlbmQoe30pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFeHBpcnlcclxuICAgICAgICBjb25zdCBub3cgPSBuZXcgQmlnTnVtYmVyKERhdGUubm93KCkpO1xyXG4gICAgICAgIGNvbnN0IGZpdmVNaW5MYXRlciA9IG5vdy5wbHVzKG5ldyBCaWdOdW1iZXIoNSkudGltZXMoT05FX01JTlVURV9NUykpLmRpdihPTkVfU0VDT05EX01TKS5pbnRlZ2VyVmFsdWUoKTtcclxuXHJcbiAgICAgICAgY29uc3QgcmZxT3JkZXIgPSBuZXcgUmZxT3JkZXIoe1xyXG4gICAgICAgICAgICB0eE9yaWdpbixcclxuICAgICAgICAgICAgdGFrZXI6IHRha2VyQWRkcmVzcyxcclxuICAgICAgICAgICAgbWFrZXI6IE1NX0FERFJFU1MsXHJcbiAgICAgICAgICAgIHRha2VyVG9rZW4sXHJcbiAgICAgICAgICAgIG1ha2VyVG9rZW4sXHJcbiAgICAgICAgICAgIG1ha2VyQW1vdW50OiBuZXcgQmlnTnVtYmVyKGFtb3VudC50b1N0cmluZygpKSxcclxuICAgICAgICAgICAgdGFrZXJBbW91bnQ6IG5ldyBCaWdOdW1iZXIoYW1vdW50LnRvU3RyaW5nKCkpLFxyXG4gICAgICAgICAgICBleHBpcnk6IGZpdmVNaW5MYXRlcixcclxuICAgICAgICAgICAgY2hhaW5JZDogTnVtYmVyKHBhcmFtcy5jaGFpbklkKSxcclxuICAgICAgICAgICAgc2FsdDogbm93LFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBvcmRlckhhc2ggPSByZnFPcmRlci5nZXRIYXNoKCk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZXRoU2lnbkhhc2hXaXRoS2V5KG9yZGVySGFzaCwgTU1fUFJJVkFURV9LRVkpO1xyXG5cclxuICAgICAgICBjb25zdCBmaXJtUXVvdGUgPSB7XHJcbiAgICAgICAgICAgIHNpZ25lZE9yZGVyOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5yZnFPcmRlcixcclxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5PSykuc2VuZChmaXJtUXVvdGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbXBsZSBxdW90aW5nIGZvciBSRlF0IHYyIHRoYXQgc2lnbnMgZXZlbiB0YWtlciBhbW91bnRzLCBidXQgcmVmdXNlcyB0byBzaWduIG9kZCB0YWtlciBhbW91bnRzLCBpZ25vcmluZyBkZWNpbWFscy5cclxuICAgICAqIFRoZSBtYXggdHJhZGluZyBzaXplIGlzIDIgdG9rZW5zLlxyXG4gICAgICpcclxuICAgICAqIEV4YW1wbGUgZm9yIFdFVEg6XHJcbiAgICAgKiAtIDEuMDAwXzAwMF8wMDBfMDAwXzAwMF8wMDAgaXMgY29uc2lkZXJlZCBvZGQhXHJcbiAgICAgKiAtIDIuMDAwXzAwMF8wMDBfMDAwXzAwMF8wMDEgaXMgY29uc2lkZXJlZCBldmVuIVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0UXVvdGVSZnF0VjJBc3luYyhyZXE6IGV4cHJlc3MuUmVxdWVzdCwgcmVzOiBleHByZXNzLlJlc3BvbnNlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gRHVtbXlNTUhhbmRsZXJzLl9wYXJzZVF1b3RlUmVxdWVzdChyZXEpO1xyXG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSBOdW1iZXIocGFyYW1zLmNoYWluSWQpO1xyXG4gICAgICAgIGNvbnN0IHRva2VuU2V0ID0gdGhpcy5fdG9rZW5TZXRCeUNoYWluSWQuZ2V0KGNoYWluSWQpO1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgc2VsbFRva2VuQWRkcmVzcyxcclxuICAgICAgICAgICAgYnV5VG9rZW5BZGRyZXNzLFxyXG4gICAgICAgICAgICBzZWxsQW1vdW50QmFzZVVuaXRzLFxyXG4gICAgICAgICAgICBidXlBbW91bnRCYXNlVW5pdHMsXHJcbiAgICAgICAgICAgIHR4T3JpZ2luLFxyXG4gICAgICAgICAgICB0YWtlckFkZHJlc3MsXHJcbiAgICAgICAgICAgIGludGVncmF0b3JJZCxcclxuICAgICAgICAgICAgZmVlQW1vdW50LFxyXG4gICAgICAgIH0gPSBwYXJhbXM7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGludGVncmF0b3JcclxuICAgICAgICBpZiAoIWludGVncmF0b3JJZCB8fCAhd2hpdGVsaXN0ZWRJbnRlZ3JhdG9ycy5oYXMoaW50ZWdyYXRvcklkKSkge1xyXG4gICAgICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuQkFEX1JFUVVFU1QpLnNlbmQoJ0ludmFsaWQgaW50ZWdyYXRvciBpZCcpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayB0b2tlbnNcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICF0b2tlblNldCB8fFxyXG4gICAgICAgICAgICAhdG9rZW5TZXQuaGFzKHNlbGxUb2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgIXRva2VuU2V0LmhhcyhidXlUb2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLk5PX0NPTlRFTlQpLnNlbmQoYE5vIGxpcXVpZGl0eSBmb3IgJHtzZWxsVG9rZW5BZGRyZXNzfToke2J1eVRva2VuQWRkcmVzc31gKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IGFtb3VudCAoZGlyZWN0aW9uIGRvZXNuJ3QgbWF0dGVyIGJlY2F1c2UgcHJpY2UgaXMgYWx3YXlzIDE6MSlcclxuICAgICAgICBjb25zdCBpc1NlbGxpbmcgPSBzZWxsQW1vdW50QmFzZVVuaXRzICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgcmF3QW1vdW50ID0gKGlzU2VsbGluZyA/IHNlbGxBbW91bnRCYXNlVW5pdHMgOiBidXlBbW91bnRCYXNlVW5pdHMpIGFzIHN0cmluZztcclxuICAgICAgICBjb25zdCBhbW91bnQgPSBuZXcgQmlnTnVtYmVyKHJhd0Ftb3VudCk7XHJcblxyXG4gICAgICAgIC8vIFRva2Vuc1xyXG4gICAgICAgIGNvbnN0IHRha2VyVG9rZW4gPSBzZWxsVG9rZW5BZGRyZXNzIGFzIHN0cmluZztcclxuICAgICAgICBjb25zdCBtYWtlclRva2VuID0gYnV5VG9rZW5BZGRyZXNzIGFzIHN0cmluZztcclxuXHJcbiAgICAgICAgY29uc3QgZGVjaW1hbHMgPSB0b2tlblRvRGVjaW1hbHNbdGFrZXJUb2tlbl07XHJcbiAgICAgICAgLy8gRW5mb3JjZSBhIDIgdW5pdHMgbWF4aW11bSBmb3IgdHJhZGluZ1xyXG4gICAgICAgIGNvbnN0IG9uZVVuaXQgPSAxMCAqKiBkZWNpbWFscztcclxuICAgICAgICBpZiAoYW1vdW50Lmd0KG9uZVVuaXQgKiAyKSkge1xyXG4gICAgICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuTk9fQ09OVEVOVCkuc2VuZCgnVHJhZGluZyBsaW1pdCBmb3IgYnV5L3NlbGwgdG9rZW5zIHNob3VsZCBub3QgZXhjZWVkIDInKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgaXNFdmVuID0gYW1vdW50XHJcbiAgICAgICAgICAgIC5kaXYoMTAgKiogZGVjaW1hbHMpXHJcbiAgICAgICAgICAgIC5pbnRlZ2VyVmFsdWUoKVxyXG4gICAgICAgICAgICAubW9kKDIpXHJcbiAgICAgICAgICAgIC5lcSgwKTtcclxuXHJcbiAgICAgICAgLy8gUmVqZWN0XHJcbiAgICAgICAgaWYgKCFpc0V2ZW4pIHtcclxuICAgICAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLk5PX0NPTlRFTlQpLnNlbmQoe30pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFeHBpcnkgYW5kIG5vbmNlXHJcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IEJpZ051bWJlcihEYXRlLm5vdygpKTtcclxuICAgICAgICBjb25zdCBleHBpcnkgPSBub3cucGx1cyhuZXcgQmlnTnVtYmVyKDUpLnRpbWVzKE9ORV9NSU5VVEVfTVMpKS5kaXYoT05FX1NFQ09ORF9NUykuaW50ZWdlclZhbHVlKCk7XHJcbiAgICAgICAgY29uc3Qgbm93U2Vjb25kcyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIE9ORV9TRUNPTkRfTVMpO1xyXG5cclxuICAgICAgICAvLyBHZXQgRXhjaGFuZ2UgUHJveHkgY29udHJhY3QgYWRkcmVzc1xyXG4gICAgICAgIGNvbnN0IGV4Y2hhbmdlUHJveHlDb250cmFjdEFkZHJlc3M6IHN0cmluZyA9IGdldENvbnRyYWN0QWRkcmVzc2VzRm9yQ2hhaW5PclRocm93KGNoYWluSWQpLmV4Y2hhbmdlUHJveHk7XHJcblxyXG4gICAgICAgIGNvbnN0IG90Y09yZGVyID0gbmV3IE90Y09yZGVyKHtcclxuICAgICAgICAgICAgdHhPcmlnaW4sXHJcbiAgICAgICAgICAgIGV4cGlyeUFuZE5vbmNlOiBPdGNPcmRlci5lbmNvZGVFeHBpcnlBbmROb25jZShcclxuICAgICAgICAgICAgICAgIGV4cGlyeSxcclxuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoUkZRVF9OT05DRV9CVUNLRVQpLFxyXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcihub3dTZWNvbmRzKSxcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgdGFrZXJUb2tlbixcclxuICAgICAgICAgICAgbWFrZXJUb2tlbixcclxuICAgICAgICAgICAgbWFrZXJBbW91bnQ6IGFtb3VudCxcclxuICAgICAgICAgICAgdGFrZXJBbW91bnQ6IGFtb3VudCxcclxuICAgICAgICAgICAgbWFrZXI6IE1NX0FERFJFU1MsXHJcbiAgICAgICAgICAgIHRha2VyOiB0YWtlckFkZHJlc3MsXHJcbiAgICAgICAgICAgIGNoYWluSWQsXHJcbiAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBleGNoYW5nZVByb3h5Q29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBvcmRlckhhc2ggPSBvdGNPcmRlci5nZXRIYXNoKCk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZXRoU2lnbkhhc2hXaXRoS2V5KG9yZGVySGFzaCwgTU1fUFJJVkFURV9LRVkpO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xyXG4gICAgICAgICAgICBmZWVBbW91bnQsXHJcbiAgICAgICAgICAgIG9yZGVyOiBvdGNPcmRlcixcclxuICAgICAgICAgICAgb3JkZXJIYXNoLFxyXG4gICAgICAgICAgICBtYWtlclNpZ25hdHVyZTogc2lnbmF0dXJlLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5PSykuc2VuZChyZXNwb25zZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHByb3ZlcyBldmVuIGFtb3VudHMgYW5kIHJlamVjdHMgb2RkIGFtb3VudHMsIGlnbm9yaW5nIGRlY2ltYWxzXHJcbiAgICAgKlxyXG4gICAgICogRXhhbXBsZSBmb3IgV0VUSDpcclxuICAgICAqIC0gMS4wMDBfMDAwXzAwMF8wMDBfMDAwXzAwMCBpcyBjb25zaWRlcmVkIG9kZCFcclxuICAgICAqIC0gMi4wMDBfMDAwXzAwMF8wMDBfMDAwXzAwMSBpcyBjb25zaWRlcmVkIGV2ZW4hXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBzdWJtaXRBc3luYyhyZXE6IGV4cHJlc3MuUmVxdWVzdCwgcmVzOiBleHByZXNzLlJlc3BvbnNlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IER1bW15TU1IYW5kbGVycy5fcGFyc2VTdWJtaXRSZXF1ZXN0KHJlcSk7XHJcbiAgICAgICAgY29uc3QgeyBvcmRlciwgZmVlLCBvcmRlckhhc2gsIHRha2VyVG9rZW5GaWxsQW1vdW50IH0gPSByZXF1ZXN0UGFyYW1zO1xyXG4gICAgICAgIGNvbnN0IGRlY2ltYWxzID0gdG9rZW5Ub0RlY2ltYWxzW29yZGVyLnRha2VyVG9rZW5dO1xyXG5cclxuICAgICAgICBjb25zdCBpc0V2ZW4gPSBvcmRlci50YWtlckFtb3VudFxyXG4gICAgICAgICAgICAuZGl2KDEwICoqIGRlY2ltYWxzKVxyXG4gICAgICAgICAgICAuaW50ZWdlclZhbHVlKClcclxuICAgICAgICAgICAgLm1vZCgyKVxyXG4gICAgICAgICAgICAuZXEoMCk7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XHJcbiAgICAgICAgICAgIGZlZSxcclxuICAgICAgICAgICAgcHJvY2VlZFdpdGhGaWxsOiBpc0V2ZW4sXHJcbiAgICAgICAgICAgIHNpZ25lZE9yZGVySGFzaDogb3JkZXJIYXNoLFxyXG4gICAgICAgICAgICB0YWtlclRva2VuRmlsbEFtb3VudDogdGFrZXJUb2tlbkZpbGxBbW91bnQudG9TdHJpbmcoKSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuT0spLnNlbmQocmVzcG9uc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwcm92ZXMgZXZlbiBhbW91bnRzIGFuZCByZWplY3RzIG9kZCBhbW91bnRzLCBpZ25vcmluZyBkZWNpbWFsc1xyXG4gICAgICpcclxuICAgICAqIEV4YW1wbGUgZm9yIFdFVEg6XHJcbiAgICAgKiAtIDEuMDAwXzAwMF8wMDBfMDAwXzAwMF8wMDAgaXMgY29uc2lkZXJlZCBvZGQhXHJcbiAgICAgKiAtIDIuMDAwXzAwMF8wMDBfMDAwXzAwMF8wMDEgaXMgY29uc2lkZXJlZCBldmVuIVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgc2lnblJmcW1WMkFzeW5jKHJlcTogZXhwcmVzcy5SZXF1ZXN0LCByZXM6IGV4cHJlc3MuUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gRHVtbXlNTUhhbmRsZXJzLl9wYXJzZVNpZ25SZnFtUmVxdWVzdChyZXEpO1xyXG4gICAgICAgIGNvbnN0IHsgb3JkZXIsIGZlZUFtb3VudCwgb3JkZXJIYXNoIH0gPSByZXF1ZXN0UGFyYW1zO1xyXG4gICAgICAgIGNvbnN0IGRlY2ltYWxzID0gdG9rZW5Ub0RlY2ltYWxzW29yZGVyLnRha2VyVG9rZW5dO1xyXG5cclxuICAgICAgICBjb25zdCBpc0V2ZW4gPSBvcmRlci50YWtlckFtb3VudFxyXG4gICAgICAgICAgICAuZGl2KDEwICoqIGRlY2ltYWxzKVxyXG4gICAgICAgICAgICAuaW50ZWdlclZhbHVlKClcclxuICAgICAgICAgICAgLm1vZCgyKVxyXG4gICAgICAgICAgICAuZXEoMCk7XHJcblxyXG4gICAgICAgIC8vIFJlamVjdFxyXG4gICAgICAgIGlmICghaXNFdmVuKSB7XHJcbiAgICAgICAgICAgIHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5PSykuc2VuZCh7XHJcbiAgICAgICAgICAgICAgICBwcm9jZWVkV2l0aEZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWNjZXB0IGFuZCBzaWduXHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZXRoU2lnbkhhc2hXaXRoS2V5KG9yZGVySGFzaCwgTU1fUFJJVkFURV9LRVkpO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xyXG4gICAgICAgICAgICBmZWVBbW91bnQsXHJcbiAgICAgICAgICAgIHByb2NlZWRXaXRoRmlsbDogaXNFdmVuLFxyXG4gICAgICAgICAgICBtYWtlclNpZ25hdHVyZTogc2lnbmF0dXJlLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5PSykuc2VuZChyZXNwb25zZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWducyBmb3IgZXZlbiB0YWtlciBhbW91bnRzLCBidXQgcmVmdXNlcyBvZGQgdGFrZXIgYW1vdW50cywgaWdub3JpbmcgZGVjaW1hbHMuIFRoZSBsb2dpYyBpcyB2ZXJ5IHNpbWlsYXIgdG9cclxuICAgICAqIGBzaWduUmZxbVYyQXN5bmNgIGZvciBjb25zaXN0ZW5jeS5cclxuICAgICAqXHJcbiAgICAgKiBFeGFtcGxlIGZvciBXRVRIOlxyXG4gICAgICogLSAxLjAwMF8wMDBfMDAwXzAwMF8wMDBfMDAwIGlzIGNvbnNpZGVyZWQgb2RkIVxyXG4gICAgICogLSAyLjAwMF8wMDBfMDAwXzAwMF8wMDBfMDAxIGlzIGNvbnNpZGVyZWQgZXZlbiFcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIHNpZ25SZnF0VjJBc3luYyhyZXE6IGV4cHJlc3MuUmVxdWVzdCwgcmVzOiBleHByZXNzLlJlc3BvbnNlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IER1bW15TU1IYW5kbGVycy5fcGFyc2VTaWduUmZxdFJlcXVlc3QocmVxKTtcclxuICAgICAgICBjb25zdCB7IG9yZGVyLCBmZWVBbW91bnQsIG9yZGVySGFzaDogb3JkZXJIYXNoUGFyYW0gfSA9IHJlcXVlc3RQYXJhbXM7XHJcbiAgICAgICAgY29uc3Qgb3JkZXJIYXNoID0gb3JkZXIuZ2V0SGFzaCgpO1xyXG4gICAgICAgIGNvbnN0IHRva2VuU2V0ID0gdGhpcy5fdG9rZW5TZXRCeUNoYWluSWQuZ2V0KE51bWJlcihyZXF1ZXN0UGFyYW1zLm9yZGVyLmNoYWluSWQpKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgb3JkZXIgaGFzaCBjb21wdXRlZCBmcm9tIG9yZGVyIGlzIHRoZSBzYW1lIGFzIG9yZGVyIGhhc2ggaW4gcXVlcnkgcGFyYW1cclxuICAgICAgICBpZiAob3JkZXJIYXNoICE9PSBvcmRlckhhc2hQYXJhbSkge1xyXG4gICAgICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuQkFEX1JFUVVFU1QpLnNlbmQoXHJcbiAgICAgICAgICAgICAgICBgb3JkZXJIYXNoIHF1ZXJ5IHBhcmFtIHByb3ZpZGVkICR7b3JkZXJIYXNoUGFyYW19IGlzIG5vdCBlcXVhbCB0byB0aGUgYWN0dWFsIG9yZGVyIGhhc2ggJHtvcmRlckhhc2h9YCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdG9rZW5zXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAhdG9rZW5TZXQgfHxcclxuICAgICAgICAgICAgIXRva2VuU2V0LmhhcyhvcmRlci5tYWtlclRva2VuLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICF0b2tlblNldC5oYXMob3JkZXIudGFrZXJUb2tlbi50b0xvd2VyQ2FzZSgpKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuTk9fQ09OVEVOVCkuc2VuZChgTm8gbGlxdWlkaXR5IGZvciAke29yZGVyLm1ha2VyVG9rZW59OiR7b3JkZXIudGFrZXJUb2tlbn1gKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZGVjaW1hbHMgPSB0b2tlblRvRGVjaW1hbHNbb3JkZXIudGFrZXJUb2tlbl07XHJcbiAgICAgICAgY29uc3QgaXNFdmVuID0gb3JkZXIudGFrZXJBbW91bnRcclxuICAgICAgICAgICAgLmRpdigxMCAqKiBkZWNpbWFscylcclxuICAgICAgICAgICAgLmludGVnZXJWYWx1ZSgpXHJcbiAgICAgICAgICAgIC5tb2QoMilcclxuICAgICAgICAgICAgLmVxKDApO1xyXG5cclxuICAgICAgICAvLyBSZWplY3RcclxuICAgICAgICBpZiAoIWlzRXZlbikge1xyXG4gICAgICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuTk9fQ09OVEVOVCkuc2VuZCh7fSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlZnVzZSB0byBzaWduXHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZXRoU2lnbkhhc2hXaXRoS2V5KG9yZGVySGFzaCwgTU1fUFJJVkFURV9LRVkpO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xyXG4gICAgICAgICAgICBmZWVBbW91bnQsXHJcbiAgICAgICAgICAgIG1ha2VyU2lnbmF0dXJlOiBzaWduYXR1cmUsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLk9LKS5zZW5kKHJlc3BvbnNlKTtcclxuICAgIH1cclxufVxyXG4iXSwidmVyc2lvbiI6M30=