2e789c317e19df43060baef4a66a511d
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildRfqmServicesAsync = exports.buildRfqMakerBalanceCacheServiceAsync = exports.buildWorkerServiceAsync = exports.buildRfqmServiceAsync = exports.getContractAddressesForNetworkOrThrowAsync = exports.getAxiosRequestConfigWithProxy = exports.getAxiosRequestConfig = void 0;
const asset_swapper_1 = require("@0x/asset-swapper");
const contract_addresses_1 = require("@0x/contract-addresses");
const subproviders_1 = require("@0x/subproviders");
const token_metadata_1 = require("@0x/token-metadata");
const web3_wrapper_1 = require("@0x/web3-wrapper");
const axios_1 = require("axios");
const ethers_1 = require("ethers");
const http_1 = require("http");
const https_1 = require("https");
const ioredis_1 = require("ioredis");
const kafkajs_1 = require("kafkajs");
const sqs_producer_1 = require("sqs-producer");
const config_1 = require("../config");
const constants_1 = require("../core/constants");
const logger_1 = require("../logger");
const fee_service_1 = require("../services/fee_service");
const rfqm_service_1 = require("../services/rfqm_service");
const rfq_maker_balance_cache_service_1 = require("../services/rfq_maker_balance_cache_service");
const WorkerService_1 = require("../services/WorkerService");
const balance_checker_1 = require("./balance_checker");
const cache_client_1 = require("./cache_client");
const config_manager_1 = require("./config_manager");
const GasStationAttendantUtils_1 = require("./GasStationAttendantUtils");
const provider_utils_1 = require("./provider_utils");
const quote_server_client_1 = require("./quote_server_client");
const rfq_blockchain_utils_1 = require("./rfq_blockchain_utils");
const rfq_maker_manager_1 = require("./rfq_maker_manager");
const TokenMetadataManager_1 = require("./TokenMetadataManager");
const ZeroExApiClient_1 = require("./ZeroExApiClient");
const DEFAULT_AXIOS_TIMEOUT = 600; // ms
/**
 * Initialize a kafka producer if KAFKA_BROKERS is set
 */
function getKafkaProducer() {
    let kafkaProducer;
    if (config_1.KAFKA_BROKERS !== undefined) {
        const kafka = new kafkajs_1.Kafka({
            clientId: '0x-api',
            brokers: config_1.KAFKA_BROKERS,
        });
        kafkaProducer = kafka.producer();
        // tslint:disable-next-line: no-floating-promises
        kafkaProducer.connect();
    }
    return kafkaProducer;
}
/**
 * Creates the default Axios Request Config
 */
function getAxiosRequestConfig(timeout = DEFAULT_AXIOS_TIMEOUT) {
    return {
        httpAgent: new http_1.Agent({ keepAlive: true, timeout: constants_1.KEEP_ALIVE_TTL }),
        httpsAgent: new https_1.Agent({ keepAlive: true, timeout: constants_1.KEEP_ALIVE_TTL }),
        timeout,
    };
}
exports.getAxiosRequestConfig = getAxiosRequestConfig;
/**
 * Creates the Axios Request Config with egress proxy
 */
function getAxiosRequestConfigWithProxy() {
    const axiosRequestConfig = getAxiosRequestConfig();
    if (config_1.RFQ_PROXY_ADDRESS !== undefined && config_1.RFQ_PROXY_PORT !== undefined) {
        axiosRequestConfig.proxy = {
            host: config_1.RFQ_PROXY_ADDRESS,
            port: config_1.RFQ_PROXY_PORT,
        };
    }
    return axiosRequestConfig;
}
exports.getAxiosRequestConfigWithProxy = getAxiosRequestConfigWithProxy;
async function deploySamplerContractAsync(provider, chainId) {
    const web3Wrapper = new web3_wrapper_1.Web3Wrapper(provider);
    const _chainId = await web3Wrapper.getChainIdAsync();
    if (_chainId !== chainId) {
        throw new Error(`Incorrect Chain Id: ${_chainId}`);
    }
    const [account] = await web3Wrapper.getAvailableAddressesAsync();
    try {
        const sampler = await asset_swapper_1.ERC20BridgeSamplerContract.deployFrom0xArtifactAsync(asset_swapper_1.artifacts.ERC20BridgeSampler, provider, { from: account }, {});
        logger_1.logger.info(`Deployed ERC20BridgeSamplerContract on network ${chainId}: ${sampler.address}`);
        return sampler;
    }
    catch (err) {
        logger_1.logger.error(`Failed to deploy ERC20BridgeSamplerContract on network ${chainId}: ${err}`);
        throw err;
    }
}
/**
 * Determines the contract addresses needed for the network. For testing (ganache)
 * required contracts are deployed
 * @param provider provider to the network, used for ganache deployment
 * @param chainConfiguration used for getting chainId and exchangeProxyContractAddressOverride
 */
async function getContractAddressesForNetworkOrThrowAsync(provider, chainConfiguration) {
    const { chainId, exchangeProxyContractAddressOverride } = chainConfiguration;
    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let contractAddresses = (0, contract_addresses_1.getContractAddressesForChainOrThrow)(chainId.toString());
    // In a testnet where the environment does not support overrides
    // so we deploy the latest sampler
    if (chainId === contract_addresses_1.ChainId.Ganache) {
        const sampler = await deploySamplerContractAsync(provider, chainId);
        contractAddresses = { ...contractAddresses, erc20BridgeSampler: sampler.address };
    }
    // If 0x Exchange Proxy contract address override is defined in the chain config
    // we use address instead of the one provided from `@0x/contract-addresses`
    if (exchangeProxyContractAddressOverride) {
        contractAddresses = { ...contractAddresses, exchangeProxy: exchangeProxyContractAddressOverride };
    }
    return contractAddresses;
}
exports.getContractAddressesForNetworkOrThrowAsync = getContractAddressesForNetworkOrThrowAsync;
/**
 * Builds a single instance of RfqmService
 */
async function buildRfqmServiceAsync(rfqmDbUtils, rfqMakerManager, tokenPriceOracle, configManager, chain, redis) {
    const { rfqm: rfqmConfiguration, chainId } = chain;
    if (!rfqmConfiguration) {
        throw new Error(`RFQm Service for chain ${chainId} does not exist`);
    }
    // ether.js Provider coexists with web3 provider during migration away from 0x/web3-wrapper.
    const ethersProvider = new ethers_1.providers.JsonRpcProvider(chain.rpcUrl, chainId);
    const rpcProvider = provider_utils_1.providerUtils.createWeb3Provider(chain.rpcUrl);
    const provider = rpcProvider;
    const contractAddresses = await getContractAddressesForNetworkOrThrowAsync(provider, chain);
    const axiosInstance = axios_1.default.create(getAxiosRequestConfigWithProxy());
    const protocolFeeUtils = asset_swapper_1.ProtocolFeeUtils.getInstance(constants_1.PROTOCOL_FEE_UTILS_POLLING_INTERVAL_IN_MS, chain.gasStationUrl);
    const balanceChecker = new balance_checker_1.BalanceChecker(provider);
    const rfqBlockchainUtils = new rfq_blockchain_utils_1.RfqBlockchainUtils(provider, contractAddresses.exchangeProxy, balanceChecker, ethersProvider);
    const tokenMetadataManager = new TokenMetadataManager_1.TokenMetadataManager(chainId, rfqBlockchainUtils);
    const sqsProducer = sqs_producer_1.Producer.create({
        queueUrl: chain.sqsUrl,
    });
    const quoteServerClient = new quote_server_client_1.QuoteServerClient(axiosInstance);
    const cacheClient = new cache_client_1.CacheClient(redis);
    const kafkaProducer = getKafkaProducer();
    const gasStationAttendant = (0, GasStationAttendantUtils_1.getGasStationAttendant)(chain, axiosInstance, protocolFeeUtils);
    const feeTokenMetadata = (0, token_metadata_1.getTokenMetadataIfExists)(contractAddresses.etherToken, chainId);
    if (feeTokenMetadata === undefined) {
        throw new Error(`Fee token ${contractAddresses.etherToken} on chain ${chainId} could not be found!`);
    }
    const zeroExApiClient = new ZeroExApiClient_1.ZeroExApiClient(axios_1.default.create(), config_1.ZERO_EX_API_KEY, chain);
    const feeService = new fee_service_1.FeeService(chainId, feeTokenMetadata, configManager, gasStationAttendant, tokenPriceOracle, zeroExApiClient, rfqmConfiguration.minExpiryDurationMs || constants_1.DEFAULT_MIN_EXPIRY_DURATION_MS);
    const rfqMakerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService(cacheClient, rfqBlockchainUtils.balanceCheckUtils);
    return new rfqm_service_1.RfqmService(chainId, feeService, rfqmConfiguration.feeModelVersion || 0, contractAddresses, chain.registryAddress, rfqBlockchainUtils, rfqmDbUtils, sqsProducer, quoteServerClient, rfqmConfiguration.minExpiryDurationMs || constants_1.DEFAULT_MIN_EXPIRY_DURATION_MS, cacheClient, rfqMakerBalanceCacheService, rfqMakerManager, tokenMetadataManager, kafkaProducer, rfqmConfiguration.quoteReportTopic);
}
exports.buildRfqmServiceAsync = buildRfqmServiceAsync;
/**
 * Builds a single instance of the WorkerService
 */
async function buildWorkerServiceAsync(rfqmDbUtils, rfqMakerManager, chain, redis, workerIndex) {
    const { worker: workerConfiguration, chainId } = chain;
    if (!workerConfiguration) {
        throw new Error(`Worker Service for chain ${chainId} does not exist`);
    }
    let provider;
    // ether.js Provider coexists with web3 provider during migration away from 0x/web3-wrapper.
    const ethersProvider = new ethers_1.providers.JsonRpcProvider(chain.rpcUrl, chainId);
    let ethersWallet;
    const rpcProvider = provider_utils_1.providerUtils.createWeb3Provider(chain.rpcUrl);
    if (config_1.META_TX_WORKER_MNEMONIC === undefined) {
        throw new Error(`META_TX_WORKER_MNEMONIC must be defined to run RFQM service as a worker`);
    }
    const workerPrivateKey = rfq_blockchain_utils_1.RfqBlockchainUtils.getPrivateKeyFromIndexAndPhrase(config_1.META_TX_WORKER_MNEMONIC, workerIndex);
    // TODO (rhinodavid): Remove once migration to ethers.js is complete
    const privateWalletSubprovider = new subproviders_1.PrivateKeyWalletSubprovider(workerPrivateKey);
    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
    // eslint-disable-next-line prefer-const
    provider = rfq_blockchain_utils_1.RfqBlockchainUtils.createPrivateKeyProvider(rpcProvider, privateWalletSubprovider);
    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ethersWallet = ethers_1.Wallet.fromMnemonic(config_1.META_TX_WORKER_MNEMONIC, `m/44'/60'/0'/0/${workerIndex}`);
    ethersWallet = ethersWallet.connect(ethersProvider);
    const contractAddresses = await getContractAddressesForNetworkOrThrowAsync(provider, chain);
    const axiosInstance = axios_1.default.create(getAxiosRequestConfigWithProxy());
    const protocolFeeUtils = asset_swapper_1.ProtocolFeeUtils.getInstance(constants_1.PROTOCOL_FEE_UTILS_POLLING_INTERVAL_IN_MS, chain.gasStationUrl);
    const balanceChecker = new balance_checker_1.BalanceChecker(provider);
    const rfqBlockchainUtils = new rfq_blockchain_utils_1.RfqBlockchainUtils(provider, contractAddresses.exchangeProxy, balanceChecker, ethersProvider, ethersWallet);
    const quoteServerClient = new quote_server_client_1.QuoteServerClient(axiosInstance);
    const cacheClient = new cache_client_1.CacheClient(redis);
    const gasStationAttendant = (0, GasStationAttendantUtils_1.getGasStationAttendant)(chain, axiosInstance, protocolFeeUtils);
    const feeTokenMetadata = (0, token_metadata_1.getTokenMetadataIfExists)(contractAddresses.etherToken, chainId);
    if (feeTokenMetadata === undefined) {
        throw new Error(`Fee token ${contractAddresses.etherToken} on chain ${chainId} could not be found!`);
    }
    const rfqMakerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService(cacheClient, rfqBlockchainUtils.balanceCheckUtils);
    return new WorkerService_1.WorkerService(chainId, gasStationAttendant, chain.registryAddress, rfqBlockchainUtils, rfqmDbUtils, quoteServerClient, workerConfiguration.transactionWatcherSleepTimeMs || constants_1.DEFAULT_WORKER_TRANSACTION_WATCHER_SLEEP_TIME_MS, cacheClient, rfqMakerBalanceCacheService, rfqMakerManager, workerConfiguration.initialMaxPriorityFeePerGasGwei, workerConfiguration.maxFeePerGasCapGwei, workerConfiguration.enableAccessList);
}
exports.buildWorkerServiceAsync = buildWorkerServiceAsync;
/**
 * Builds an instance of maker balance cache service.
 * Intended to be used by maker balance cache background jobs.
 */
async function buildRfqMakerBalanceCacheServiceAsync(chain) {
    const provider = provider_utils_1.providerUtils.createWeb3Provider(chain.rpcUrl);
    const contractAddresses = await getContractAddressesForNetworkOrThrowAsync(provider, chain);
    const balanceChecker = new balance_checker_1.BalanceChecker(provider);
    const balanceCheckUtils = new rfq_blockchain_utils_1.RfqBalanceCheckUtils(balanceChecker, contractAddresses.exchangeProxy);
    if (!config_1.REDIS_URI) {
        throw new Error('No redis URI provided to maker balance cache service');
    }
    const redis = new ioredis_1.default(config_1.REDIS_URI);
    const cacheClient = new cache_client_1.CacheClient(redis);
    return new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService(cacheClient, balanceCheckUtils);
}
exports.buildRfqMakerBalanceCacheServiceAsync = buildRfqMakerBalanceCacheServiceAsync;
/**
 * Creates an RFQM Service for each chain present in `ChainConfigurations`.
 *
 * Intended for use by the top-level runners.
 */
async function buildRfqmServicesAsync(asWorker, rfqmDbUtils, rfqMakerDbUtils, chainConfigurations, tokenPriceOracle, configManager = new config_manager_1.ConfigManager(), redis, 
// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
// eslint-disable-next-line @typescript-eslint/no-inferrable-types
_workerIndex = 0) {
    const services = await Promise.all(chainConfigurations.map(async (chain) => {
        const rfqMakerManager = new rfq_maker_manager_1.RfqMakerManager(configManager, rfqMakerDbUtils, chain.chainId);
        await rfqMakerManager.initializeAsync();
        return buildRfqmServiceAsync(rfqmDbUtils, rfqMakerManager, tokenPriceOracle, configManager, chain, redis);
    }));
    return new Map(services.map((s, i) => [chainConfigurations[i].chainId, s]));
}
exports.buildRfqmServicesAsync = buildRfqmServicesAsync;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy91dGlscy9yZnFtX3NlcnZpY2VfYnVpbGRlci50cyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxxREFNMkI7QUFDM0IsK0RBQXNGO0FBQ3RGLG1EQUErRDtBQUMvRCx1REFBOEQ7QUFDOUQsbURBQStDO0FBQy9DLGlDQUFrRDtBQUNsRCxtQ0FBMkM7QUFDM0MsK0JBQTBDO0FBQzFDLGlDQUE0QztBQUM1QyxxQ0FBNEI7QUFDNUIscUNBQTJEO0FBQzNELCtDQUF3QztBQUV4QyxzQ0FTbUI7QUFDbkIsaURBSzJCO0FBQzNCLHNDQUFtQztBQUNuQyx5REFBcUQ7QUFDckQsMkRBQXVEO0FBQ3ZELGlHQUEwRjtBQUMxRiw2REFBMEQ7QUFFMUQsdURBQW1EO0FBQ25ELGlEQUE2QztBQUM3QyxxREFBaUQ7QUFDakQseUVBQW9FO0FBQ3BFLHFEQUFpRDtBQUNqRCwrREFBMEQ7QUFFMUQsaUVBQWtGO0FBRWxGLDJEQUFzRDtBQUN0RCxpRUFBOEQ7QUFFOUQsdURBQW9EO0FBSXBELE1BQU0scUJBQXFCLEdBQUcsR0FBRyxDQUFDLENBQUMsS0FBSztBQUV4Qzs7R0FFRztBQUNILFNBQVMsZ0JBQWdCO0lBQ3JCLElBQUksYUFBd0MsQ0FBQztJQUM3QyxJQUFJLHNCQUFhLEtBQUssU0FBUyxFQUFFO1FBQzdCLE1BQU0sS0FBSyxHQUFHLElBQUksZUFBSyxDQUFDO1lBQ3BCLFFBQVEsRUFBRSxRQUFRO1lBQ2xCLE9BQU8sRUFBRSxzQkFBYTtTQUN6QixDQUFDLENBQUM7UUFFSCxhQUFhLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2pDLGlEQUFpRDtRQUNqRCxhQUFhLENBQUMsT0FBTyxFQUFFLENBQUM7S0FDM0I7SUFDRCxPQUFPLGFBQWEsQ0FBQztBQUN6QixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixxQkFBcUIsQ0FBQyxVQUFrQixxQkFBcUI7SUFDekUsT0FBTztRQUNILFNBQVMsRUFBRSxJQUFJLFlBQVMs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Q0ksS0FBSyxVQUFVLHNCQUFzQixDQUN4QyxRQUFpQixFQUNqQixXQUF3QixFQUN4QixlQUFnQyxFQUNoQyxtQkFBd0MsRUFDeEMsZ0JBQWtDLEVBQ2xDLGdCQUErQixJQUFJLDhCQUFhLEVBQUUsRUFDbEQsS0FBWTtBQUNaLDZEQUE2RDtBQUM3RCxrRUFBa0U7QUFDbEUsZUFBdUIsQ0FBQztJQUV4QixNQUFNLFFBQVEsR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQzlCLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUU7UUFDcEMsTUFBTSxlQUFlLEdBQUcsSUFBSSxtQ0FBZSxDQUFDLGFBQWEsRUFBRSxlQUFlLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzNGLE1BQU0sZUFBZSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3hDLE9BQU8scUJBQXFCLENBQUMsV0FBVyxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxhQUFhLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzlHLENBQUMsQ0FBQyxDQUNMLENBQUM7SUFDRixPQUFPLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDaEYsQ0FBQztBQXBCRCx3REFvQkMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy91dGlscy9yZnFtX3NlcnZpY2VfYnVpbGRlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gICAgYXJ0aWZhY3RzLFxyXG4gICAgQXNzZXRTd2FwcGVyQ29udHJhY3RBZGRyZXNzZXMsXHJcbiAgICBFUkMyMEJyaWRnZVNhbXBsZXJDb250cmFjdCxcclxuICAgIFByb3RvY29sRmVlVXRpbHMsXHJcbiAgICBTdXBwb3J0ZWRQcm92aWRlcixcclxufSBmcm9tICdAMHgvYXNzZXQtc3dhcHBlcic7XHJcbmltcG9ydCB7IENoYWluSWQsIGdldENvbnRyYWN0QWRkcmVzc2VzRm9yQ2hhaW5PclRocm93IH0gZnJvbSAnQDB4L2NvbnRyYWN0LWFkZHJlc3Nlcyc7XHJcbmltcG9ydCB7IFByaXZhdGVLZXlXYWxsZXRTdWJwcm92aWRlciB9IGZyb20gJ0AweC9zdWJwcm92aWRlcnMnO1xyXG5pbXBvcnQgeyBnZXRUb2tlbk1ldGFkYXRhSWZFeGlzdHMgfSBmcm9tICdAMHgvdG9rZW4tbWV0YWRhdGEnO1xyXG5pbXBvcnQgeyBXZWIzV3JhcHBlciB9IGZyb20gJ0AweC93ZWIzLXdyYXBwZXInO1xyXG5pbXBvcnQgQXhpb3MsIHsgQXhpb3NSZXF1ZXN0Q29uZmlnIH0gZnJvbSAnYXhpb3MnO1xyXG5pbXBvcnQgeyBwcm92aWRlcnMsIFdhbGxldCB9IGZyb20gJ2V0aGVycyc7XHJcbmltcG9ydCB7IEFnZW50IGFzIEh0dHBBZ2VudCB9IGZyb20gJ2h0dHAnO1xyXG5pbXBvcnQgeyBBZ2VudCBhcyBIdHRwc0FnZW50IH0gZnJvbSAnaHR0cHMnO1xyXG5pbXBvcnQgUmVkaXMgZnJvbSAnaW9yZWRpcyc7XHJcbmltcG9ydCB7IEthZmthLCBQcm9kdWNlciBhcyBLYWZrYVByb2R1Y2VyIH0gZnJvbSAna2Fma2Fqcyc7XHJcbmltcG9ydCB7IFByb2R1Y2VyIH0gZnJvbSAnc3FzLXByb2R1Y2VyJztcclxuXHJcbmltcG9ydCB7XHJcbiAgICBDaGFpbkNvbmZpZ3VyYXRpb24sXHJcbiAgICBDaGFpbkNvbmZpZ3VyYXRpb25zLFxyXG4gICAgS0FGS0FfQlJPS0VSUyxcclxuICAgIE1FVEFfVFhfV09SS0VSX01ORU1PTklDLFxyXG4gICAgUkVESVNfVVJJLFxyXG4gICAgUkZRX1BST1hZX0FERFJFU1MsXHJcbiAgICBSRlFfUFJPWFlfUE9SVCxcclxuICAgIFpFUk9fRVhfQVBJX0tFWSxcclxufSBmcm9tICcuLi9jb25maWcnO1xyXG5pbXBvcnQge1xyXG4gICAgREVGQVVMVF9NSU5fRVhQSVJZX0RVUkFUSU9OX01TLFxyXG4gICAgREVGQVVMVF9XT1JLRVJfVFJBTlNBQ1RJT05fV0FUQ0hFUl9TTEVFUF9USU1FX01TLFxyXG4gICAgS0VFUF9BTElWRV9UVEwsXHJcbiAgICBQUk9UT0NPTF9GRUVfVVRJTFNfUE9MTElOR19JTlRFUlZBTF9JTl9NUyxcclxufSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL2xvZ2dlcic7XHJcbmltcG9ydCB7IEZlZVNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9mZWVfc2VydmljZSc7XHJcbmltcG9ydCB7IFJmcW1TZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvcmZxbV9zZXJ2aWNlJztcclxuaW1wb3J0IHsgUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvcmZxX21ha2VyX2JhbGFuY2VfY2FjaGVfc2VydmljZSc7XHJcbmltcG9ydCB7IFdvcmtlclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9Xb3JrZXJTZXJ2aWNlJztcclxuXHJcbmltcG9ydCB7IEJhbGFuY2VDaGVja2VyIH0gZnJvbSAnLi9iYWxhbmNlX2NoZWNrZXInO1xyXG5pbXBvcnQgeyBDYWNoZUNsaWVudCB9IGZyb20gJy4vY2FjaGVfY2xpZW50JztcclxuaW1wb3J0IHsgQ29uZmlnTWFuYWdlciB9IGZyb20gJy4vY29uZmlnX21hbmFnZXInO1xyXG5pbXBvcnQgeyBnZXRHYXNTdGF0aW9uQXR0ZW5kYW50IH0gZnJvbSAnLi9HYXNTdGF0aW9uQXR0ZW5kYW50VXRpbHMnO1xyXG5pbXBvcnQgeyBwcm92aWRlclV0aWxzIH0gZnJvbSAnLi9wcm92aWRlcl91dGlscyc7XHJcbmltcG9ydCB7IFF1b3RlU2VydmVyQ2xpZW50IH0gZnJvbSAnLi9xdW90ZV9zZXJ2ZXJfY2xpZW50JztcclxuaW1wb3J0IHsgUmZxbURiVXRpbHMgfSBmcm9tICcuL3JmcW1fZGJfdXRpbHMnO1xyXG5pbXBvcnQgeyBSZnFCYWxhbmNlQ2hlY2tVdGlscywgUmZxQmxvY2tjaGFpblV0aWxzIH0gZnJvbSAnLi9yZnFfYmxvY2tjaGFpbl91dGlscyc7XHJcbmltcG9ydCB7IFJmcU1ha2VyRGJVdGlscyB9IGZyb20gJy4vcmZxX21ha2VyX2RiX3V0aWxzJztcclxuaW1wb3J0IHsgUmZxTWFrZXJNYW5hZ2VyIH0gZnJvbSAnLi9yZnFfbWFrZXJfbWFuYWdlcic7XHJcbmltcG9ydCB7IFRva2VuTWV0YWRhdGFNYW5hZ2VyIH0gZnJvbSAnLi9Ub2tlbk1ldGFkYXRhTWFuYWdlcic7XHJcbmltcG9ydCB7IFRva2VuUHJpY2VPcmFjbGUgfSBmcm9tICcuL1Rva2VuUHJpY2VPcmFjbGUnO1xyXG5pbXBvcnQgeyBaZXJvRXhBcGlDbGllbnQgfSBmcm9tICcuL1plcm9FeEFwaUNsaWVudCc7XHJcblxyXG5leHBvcnQgdHlwZSBSZnFtU2VydmljZXMgPSBNYXA8bnVtYmVyLCBSZnFtU2VydmljZT47XHJcblxyXG5jb25zdCBERUZBVUxUX0FYSU9TX1RJTUVPVVQgPSA2MDA7IC8vIG1zXHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIGthZmthIHByb2R1Y2VyIGlmIEtBRktBX0JST0tFUlMgaXMgc2V0XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRLYWZrYVByb2R1Y2VyKCk6IEthZmthUHJvZHVjZXIgfCB1bmRlZmluZWQge1xyXG4gICAgbGV0IGthZmthUHJvZHVjZXI6IEthZmthUHJvZHVjZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBpZiAoS0FGS0FfQlJPS0VSUyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY29uc3Qga2Fma2EgPSBuZXcgS2Fma2Eoe1xyXG4gICAgICAgICAgICBjbGllbnRJZDogJzB4LWFwaScsXHJcbiAgICAgICAgICAgIGJyb2tlcnM6IEtBRktBX0JST0tFUlMsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGthZmthUHJvZHVjZXIgPSBrYWZrYS5wcm9kdWNlcigpO1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICBrYWZrYVByb2R1Y2VyLmNvbm5lY3QoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBrYWZrYVByb2R1Y2VyO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyB0aGUgZGVmYXVsdCBBeGlvcyBSZXF1ZXN0IENvbmZpZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEF4aW9zUmVxdWVzdENvbmZpZyh0aW1lb3V0OiBudW1iZXIgPSBERUZBVUxUX0FYSU9TX1RJTUVPVVQpOiBBeGlvc1JlcXVlc3RDb25maWcge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBodHRwQWdlbnQ6IG5ldyBIdHRwQWdlbnQoeyBrZWVwQWxpdmU6IHRydWUsIHRpbWVvdXQ6IEtFRVBfQUxJVkVfVFRMIH0pLFxyXG4gICAgICAgIGh0dHBzQWdlbnQ6IG5ldyBIdHRwc0FnZW50KHsga2VlcEFsaXZlOiB0cnVlLCB0aW1lb3V0OiBLRUVQX0FMSVZFX1RUTCB9KSxcclxuICAgICAgICB0aW1lb3V0LFxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgdGhlIEF4aW9zIFJlcXVlc3QgQ29uZmlnIHdpdGggZWdyZXNzIHByb3h5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXhpb3NSZXF1ZXN0Q29uZmlnV2l0aFByb3h5KCk6IEF4aW9zUmVxdWVzdENvbmZpZyB7XHJcbiAgICBjb25zdCBheGlvc1JlcXVlc3RDb25maWc6IEF4aW9zUmVxdWVzdENvbmZpZyA9IGdldEF4aW9zUmVxdWVzdENvbmZpZygpO1xyXG4gICAgaWYgKFJGUV9QUk9YWV9BRERSRVNTICE9PSB1bmRlZmluZWQgJiYgUkZRX1BST1hZX1BPUlQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGF4aW9zUmVxdWVzdENvbmZpZy5wcm94eSA9IHtcclxuICAgICAgICAgICAgaG9zdDogUkZRX1BST1hZX0FERFJFU1MsXHJcbiAgICAgICAgICAgIHBvcnQ6IFJGUV9QUk9YWV9QT1JULFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGF4aW9zUmVxdWVzdENvbmZpZztcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZGVwbG95U2FtcGxlckNvbnRyYWN0QXN5bmMoXHJcbiAgICBwcm92aWRlcjogU3VwcG9ydGVkUHJvdmlkZXIsXHJcbiAgICBjaGFpbklkOiBDaGFpbklkLFxyXG4pOiBQcm9taXNlPEVSQzIwQnJpZGdlU2FtcGxlckNvbnRyYWN0PiB7XHJcbiAgICBjb25zdCB3ZWIzV3JhcHBlciA9IG5ldyBXZWIzV3JhcHBlcihwcm92aWRlcik7XHJcbiAgICBjb25zdCBfY2hhaW5JZCA9IGF3YWl0IHdlYjNXcmFwcGVyLmdldENoYWluSWRBc3luYygpO1xyXG4gICAgaWYgKF9jaGFpbklkICE9PSBjaGFpbklkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvcnJlY3QgQ2hhaW4gSWQ6ICR7X2NoYWluSWR9YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBbYWNjb3VudF0gPSBhd2FpdCB3ZWIzV3JhcHBlci5nZXRBdmFpbGFibGVBZGRyZXNzZXNBc3luYygpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBzYW1wbGVyID0gYXdhaXQgRVJDMjBCcmlkZ2VTYW1wbGVyQ29udHJhY3QuZGVwbG95RnJvbTB4QXJ0aWZhY3RBc3luYyhcclxuICAgICAgICAgICAgYXJ0aWZhY3RzLkVSQzIwQnJpZGdlU2FtcGxlcixcclxuICAgICAgICAgICAgcHJvdmlkZXIsXHJcbiAgICAgICAgICAgIHsgZnJvbTogYWNjb3VudCB9LFxyXG4gICAgICAgICAgICB7fSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGxvZ2dlci5pbmZvKGBEZXBsb3llZCBFUkMyMEJyaWRnZVNhbXBsZXJDb250cmFjdCBvbiBuZXR3b3JrICR7Y2hhaW5JZH06ICR7c2FtcGxlci5hZGRyZXNzfWApO1xyXG4gICAgICAgIHJldHVybiBzYW1wbGVyO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZGVwbG95IEVSQzIwQnJpZGdlU2FtcGxlckNvbnRyYWN0IG9uIG5ldHdvcmsgJHtjaGFpbklkfTogJHtlcnJ9YCk7XHJcbiAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB0aGUgY29udHJhY3QgYWRkcmVzc2VzIG5lZWRlZCBmb3IgdGhlIG5ldHdvcmsuIEZvciB0ZXN0aW5nIChnYW5hY2hlKVxyXG4gKiByZXF1aXJlZCBjb250cmFjdHMgYXJlIGRlcGxveWVkXHJcbiAqIEBwYXJhbSBwcm92aWRlciBwcm92aWRlciB0byB0aGUgbmV0d29yaywgdXNlZCBmb3IgZ2FuYWNoZSBkZXBsb3ltZW50XHJcbiAqIEBwYXJhbSBjaGFpbkNvbmZpZ3VyYXRpb24gdXNlZCBmb3IgZ2V0dGluZyBjaGFpbklkIGFuZCBleGNoYW5nZVByb3h5Q29udHJhY3RBZGRyZXNzT3ZlcnJpZGVcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb250cmFjdEFkZHJlc3Nlc0Zvck5ldHdvcmtPclRocm93QXN5bmMoXHJcbiAgICBwcm92aWRlcjogU3VwcG9ydGVkUHJvdmlkZXIsXHJcbiAgICBjaGFpbkNvbmZpZ3VyYXRpb246IFBpY2s8Q2hhaW5Db25maWd1cmF0aW9uLCAnY2hhaW5JZCcgfCAnZXhjaGFuZ2VQcm94eUNvbnRyYWN0QWRkcmVzc092ZXJyaWRlJz4sXHJcbik6IFByb21pc2U8QXNzZXRTd2FwcGVyQ29udHJhY3RBZGRyZXNzZXM+IHtcclxuICAgIGNvbnN0IHsgY2hhaW5JZCwgZXhjaGFuZ2VQcm94eUNvbnRyYWN0QWRkcmVzc092ZXJyaWRlIH0gPSBjaGFpbkNvbmZpZ3VyYXRpb247XHJcbiAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgbGV0IGNvbnRyYWN0QWRkcmVzc2VzID0gZ2V0Q29udHJhY3RBZGRyZXNzZXNGb3JDaGFpbk9yVGhyb3coY2hhaW5JZC50b1N0cmluZygpIGFzIGFueSk7XHJcbiAgICAvLyBJbiBhIHRlc3RuZXQgd2hlcmUgdGhlIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgb3ZlcnJpZGVzXHJcbiAgICAvLyBzbyB3ZSBkZXBsb3kgdGhlIGxhdGVzdCBzYW1wbGVyXHJcbiAgICBpZiAoY2hhaW5JZCA9PT0gQ2hhaW5JZC5HYW5hY2hlKSB7XHJcbiAgICAgICAgY29uc3Qgc2FtcGxlciA9IGF3YWl0IGRlcGxveVNhbXBsZXJDb250cmFjdEFzeW5jKHByb3ZpZGVyLCBjaGFpbklkKTtcclxuICAgICAgICBjb250cmFjdEFkZHJlc3NlcyA9IHsgLi4uY29udHJhY3RBZGRyZXNzZXMsIGVyYzIwQnJpZGdlU2FtcGxlcjogc2FtcGxlci5hZGRyZXNzIH07XHJcbiAgICB9XHJcbiAgICAvLyBJZiAweCBFeGNoYW5nZSBQcm94eSBjb250cmFjdCBhZGRyZXNzIG92ZXJyaWRlIGlzIGRlZmluZWQgaW4gdGhlIGNoYWluIGNvbmZpZ1xyXG4gICAgLy8gd2UgdXNlIGFkZHJlc3MgaW5zdGVhZCBvZiB0aGUgb25lIHByb3ZpZGVkIGZyb20gYEAweC9jb250cmFjdC1hZGRyZXNzZXNgXHJcbiAgICBpZiAoZXhjaGFuZ2VQcm94eUNvbnRyYWN0QWRkcmVzc092ZXJyaWRlKSB7XHJcbiAgICAgICAgY29udHJhY3RBZGRyZXNzZXMgPSB7IC4uLmNvbnRyYWN0QWRkcmVzc2VzLCBleGNoYW5nZVByb3h5OiBleGNoYW5nZVByb3h5Q29udHJhY3RBZGRyZXNzT3ZlcnJpZGUgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb250cmFjdEFkZHJlc3NlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyBhIHNpbmdsZSBpbnN0YW5jZSBvZiBSZnFtU2VydmljZVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJ1aWxkUmZxbVNlcnZpY2VBc3luYyhcclxuICAgIHJmcW1EYlV0aWxzOiBSZnFtRGJVdGlscyxcclxuICAgIHJmcU1ha2VyTWFuYWdlcjogUmZxTWFrZXJNYW5hZ2VyLFxyXG4gICAgdG9rZW5QcmljZU9yYWNsZTogVG9rZW5QcmljZU9yYWNsZSxcclxuICAgIGNvbmZpZ01hbmFnZXI6IENvbmZpZ01hbmFnZXIsXHJcbiAgICBjaGFpbjogQ2hhaW5Db25maWd1cmF0aW9uLFxyXG4gICAgcmVkaXM6IFJlZGlzLFxyXG4pOiBQcm9taXNlPFJmcW1TZXJ2aWNlPiB7XHJcbiAgICBjb25zdCB7IHJmcW06IHJmcW1Db25maWd1cmF0aW9uLCBjaGFpbklkIH0gPSBjaGFpbjtcclxuICAgIGlmICghcmZxbUNvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJGUW0gU2VydmljZSBmb3IgY2hhaW4gJHtjaGFpbklkfSBkb2VzIG5vdCBleGlzdGApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGV0aGVyLmpzIFByb3ZpZGVyIGNvZXhpc3RzIHdpdGggd2ViMyBwcm92aWRlciBkdXJpbmcgbWlncmF0aW9uIGF3YXkgZnJvbSAweC93ZWIzLXdyYXBwZXIuXHJcbiAgICBjb25zdCBldGhlcnNQcm92aWRlciA9IG5ldyBwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKGNoYWluLnJwY1VybCwgY2hhaW5JZCk7XHJcblxyXG4gICAgY29uc3QgcnBjUHJvdmlkZXIgPSBwcm92aWRlclV0aWxzLmNyZWF0ZVdlYjNQcm92aWRlcihjaGFpbi5ycGNVcmwpO1xyXG4gICAgY29uc3QgcHJvdmlkZXI6IFN1cHBvcnRlZFByb3ZpZGVyID0gcnBjUHJvdmlkZXI7XHJcblxyXG4gICAgY29uc3QgY29udHJhY3RBZGRyZXNzZXMgPSBhd2FpdCBnZXRDb250cmFjdEFkZHJlc3Nlc0Zvck5ldHdvcmtPclRocm93QXN5bmMocHJvdmlkZXIsIGNoYWluKTtcclxuICAgIGNvbnN0IGF4aW9zSW5zdGFuY2UgPSBBeGlvcy5jcmVhdGUoZ2V0QXhpb3NSZXF1ZXN0Q29uZmlnV2l0aFByb3h5KCkpO1xyXG5cclxuICAgIGNvbnN0IHByb3RvY29sRmVlVXRpbHMgPSBQcm90b2NvbEZlZVV0aWxzLmdldEluc3RhbmNlKFxyXG4gICAgICAgIFBST1RPQ09MX0ZFRV9VVElMU19QT0xMSU5HX0lOVEVSVkFMX0lOX01TLFxyXG4gICAgICAgIGNoYWluLmdhc1N0YXRpb25VcmwsXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGJhbGFuY2VDaGVja2VyID0gbmV3IEJhbGFuY2VDaGVja2VyKHByb3ZpZGVyKTtcclxuICAgIGNvbnN0IHJmcUJsb2NrY2hhaW5VdGlscyA9IG5ldyBSZnFCbG9ja2NoYWluVXRpbHMoXHJcbiAgICAgICAgcHJvdmlkZXIsXHJcbiAgICAgICAgY29udHJhY3RBZGRyZXNzZXMuZXhjaGFuZ2VQcm94eSxcclxuICAgICAgICBiYWxhbmNlQ2hlY2tlcixcclxuICAgICAgICBldGhlcnNQcm92aWRlcixcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgdG9rZW5NZXRhZGF0YU1hbmFnZXIgPSBuZXcgVG9rZW5NZXRhZGF0YU1hbmFnZXIoY2hhaW5JZCwgcmZxQmxvY2tjaGFpblV0aWxzKTtcclxuXHJcbiAgICBjb25zdCBzcXNQcm9kdWNlciA9IFByb2R1Y2VyLmNyZWF0ZSh7XHJcbiAgICAgICAgcXVldWVVcmw6IGNoYWluLnNxc1VybCxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHF1b3RlU2VydmVyQ2xpZW50ID0gbmV3IFF1b3RlU2VydmVyQ2xpZW50KGF4aW9zSW5zdGFuY2UpO1xyXG5cclxuICAgIGNvbnN0IGNhY2hlQ2xpZW50ID0gbmV3IENhY2hlQ2xpZW50KHJlZGlzKTtcclxuXHJcbiAgICBjb25zdCBrYWZrYVByb2R1Y2VyID0gZ2V0S2Fma2FQcm9kdWNlcigpO1xyXG5cclxuICAgIGNvbnN0IGdhc1N0YXRpb25BdHRlbmRhbnQgPSBnZXRHYXNTdGF0aW9uQXR0ZW5kYW50KGNoYWluLCBheGlvc0luc3RhbmNlLCBwcm90b2NvbEZlZVV0aWxzKTtcclxuXHJcbiAgICBjb25zdCBmZWVUb2tlbk1ldGFkYXRhID0gZ2V0VG9rZW5NZXRhZGF0YUlmRXhpc3RzKGNvbnRyYWN0QWRkcmVzc2VzLmV0aGVyVG9rZW4sIGNoYWluSWQpO1xyXG4gICAgaWYgKGZlZVRva2VuTWV0YWRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmVlIHRva2VuICR7Y29udHJhY3RBZGRyZXNzZXMuZXRoZXJUb2tlbn0gb24gY2hhaW4gJHtjaGFpbklkfSBjb3VsZCBub3QgYmUgZm91bmQhYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgemVyb0V4QXBpQ2xpZW50ID0gbmV3IFplcm9FeEFwaUNsaWVudChBeGlvcy5jcmVhdGUoKSwgWkVST19FWF9BUElfS0VZLCBjaGFpbik7XHJcblxyXG4gICAgY29uc3QgZmVlU2VydmljZSA9IG5ldyBGZWVTZXJ2aWNlKFxyXG4gICAgICAgIGNoYWluSWQsXHJcbiAgICAgICAgZmVlVG9rZW5NZXRhZGF0YSxcclxuICAgICAgICBjb25maWdNYW5hZ2VyLFxyXG4gICAgICAgIGdhc1N0YXRpb25BdHRlbmRhbnQsXHJcbiAgICAgICAgdG9rZW5QcmljZU9yYWNsZSxcclxuICAgICAgICB6ZXJvRXhBcGlDbGllbnQsXHJcbiAgICAgICAgcmZxbUNvbmZpZ3VyYXRpb24ubWluRXhwaXJ5RHVyYXRpb25NcyB8fCBERUZBVUxUX01JTl9FWFBJUllfRFVSQVRJT05fTVMsXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSA9IG5ldyBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UoXHJcbiAgICAgICAgY2FjaGVDbGllbnQsXHJcbiAgICAgICAgcmZxQmxvY2tjaGFpblV0aWxzLmJhbGFuY2VDaGVja1V0aWxzLFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFJmcW1TZXJ2aWNlKFxyXG4gICAgICAgIGNoYWluSWQsXHJcbiAgICAgICAgZmVlU2VydmljZSxcclxuICAgICAgICByZnFtQ29uZmlndXJhdGlvbi5mZWVNb2RlbFZlcnNpb24gfHwgMCxcclxuICAgICAgICBjb250cmFjdEFkZHJlc3NlcyxcclxuICAgICAgICBjaGFpbi5yZWdpc3RyeUFkZHJlc3MsXHJcbiAgICAgICAgcmZxQmxvY2tjaGFpblV0aWxzLFxyXG4gICAgICAgIHJmcW1EYlV0aWxzLFxyXG4gICAgICAgIHNxc1Byb2R1Y2VyLFxyXG4gICAgICAgIHF1b3RlU2VydmVyQ2xpZW50LFxyXG4gICAgICAgIHJmcW1Db25maWd1cmF0aW9uLm1pbkV4cGlyeUR1cmF0aW9uTXMgfHwgREVGQVVMVF9NSU5fRVhQSVJZX0RVUkFUSU9OX01TLFxyXG4gICAgICAgIGNhY2hlQ2xpZW50LFxyXG4gICAgICAgIHJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSxcclxuICAgICAgICByZnFNYWtlck1hbmFnZXIsXHJcbiAgICAgICAgdG9rZW5NZXRhZGF0YU1hbmFnZXIsXHJcbiAgICAgICAga2Fma2FQcm9kdWNlcixcclxuICAgICAgICByZnFtQ29uZmlndXJhdGlvbi5xdW90ZVJlcG9ydFRvcGljLFxyXG4gICAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyBhIHNpbmdsZSBpbnN0YW5jZSBvZiB0aGUgV29ya2VyU2VydmljZVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJ1aWxkV29ya2VyU2VydmljZUFzeW5jKFxyXG4gICAgcmZxbURiVXRpbHM6IFJmcW1EYlV0aWxzLFxyXG4gICAgcmZxTWFrZXJNYW5hZ2VyOiBSZnFNYWtlck1hbmFnZXIsXHJcbiAgICBjaGFpbjogQ2hhaW5Db25maWd1cmF0aW9uLFxyXG4gICAgcmVkaXM6IFJlZGlzLFxyXG4gICAgd29ya2VySW5kZXg6IG51bWJlcixcclxuKTogUHJvbWlzZTxXb3JrZXJTZXJ2aWNlPiB7XHJcbiAgICBjb25zdCB7IHdvcmtlcjogd29ya2VyQ29uZmlndXJhdGlvbiwgY2hhaW5JZCB9ID0gY2hhaW47XHJcbiAgICBpZiAoIXdvcmtlckNvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdvcmtlciBTZXJ2aWNlIGZvciBjaGFpbiAke2NoYWluSWR9IGRvZXMgbm90IGV4aXN0YCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHByb3ZpZGVyOiBTdXBwb3J0ZWRQcm92aWRlcjtcclxuXHJcbiAgICAvLyBldGhlci5qcyBQcm92aWRlciBjb2V4aXN0cyB3aXRoIHdlYjMgcHJvdmlkZXIgZHVyaW5nIG1pZ3JhdGlvbiBhd2F5IGZyb20gMHgvd2ViMy13cmFwcGVyLlxyXG4gICAgY29uc3QgZXRoZXJzUHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcihjaGFpbi5ycGNVcmwsIGNoYWluSWQpO1xyXG4gICAgbGV0IGV0aGVyc1dhbGxldDogV2FsbGV0IHwgdW5kZWZpbmVkO1xyXG5cclxuICAgIGNvbnN0IHJwY1Byb3ZpZGVyID0gcHJvdmlkZXJVdGlscy5jcmVhdGVXZWIzUHJvdmlkZXIoY2hhaW4ucnBjVXJsKTtcclxuICAgIGlmIChNRVRBX1RYX1dPUktFUl9NTkVNT05JQyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNRVRBX1RYX1dPUktFUl9NTkVNT05JQyBtdXN0IGJlIGRlZmluZWQgdG8gcnVuIFJGUU0gc2VydmljZSBhcyBhIHdvcmtlcmApO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgd29ya2VyUHJpdmF0ZUtleSA9IFJmcUJsb2NrY2hhaW5VdGlscy5nZXRQcml2YXRlS2V5RnJvbUluZGV4QW5kUGhyYXNlKE1FVEFfVFhfV09SS0VSX01ORU1PTklDLCB3b3JrZXJJbmRleCk7XHJcblxyXG4gICAgLy8gVE9ETyAocmhpbm9kYXZpZCk6IFJlbW92ZSBvbmNlIG1pZ3JhdGlvbiB0byBldGhlcnMuanMgaXMgY29tcGxldGVcclxuICAgIGNvbnN0IHByaXZhdGVXYWxsZXRTdWJwcm92aWRlciA9IG5ldyBQcml2YXRlS2V5V2FsbGV0U3VicHJvdmlkZXIod29ya2VyUHJpdmF0ZUtleSk7XHJcbiAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XHJcbiAgICBwcm92aWRlciA9IFJmcUJsb2NrY2hhaW5VdGlscy5jcmVhdGVQcml2YXRlS2V5UHJvdmlkZXIocnBjUHJvdmlkZXIsIHByaXZhdGVXYWxsZXRTdWJwcm92aWRlcik7XHJcblxyXG4gICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cclxuICAgIGV0aGVyc1dhbGxldCA9IFdhbGxldC5mcm9tTW5lbW9uaWMoTUVUQV9UWF9XT1JLRVJfTU5FTU9OSUMsIGBtLzQ0Jy82MCcvMCcvMC8ke3dvcmtlckluZGV4IX1gKTtcclxuICAgIGV0aGVyc1dhbGxldCA9IGV0aGVyc1dhbGxldC5jb25uZWN0KGV0aGVyc1Byb3ZpZGVyKTtcclxuXHJcbiAgICBjb25zdCBjb250cmFjdEFkZHJlc3NlcyA9IGF3YWl0IGdldENvbnRyYWN0QWRkcmVzc2VzRm9yTmV0d29ya09yVGhyb3dBc3luYyhwcm92aWRlciwgY2hhaW4pO1xyXG4gICAgY29uc3QgYXhpb3NJbnN0YW5jZSA9IEF4aW9zLmNyZWF0ZShnZXRBeGlvc1JlcXVlc3RDb25maWdXaXRoUHJveHkoKSk7XHJcblxyXG4gICAgY29uc3QgcHJvdG9jb2xGZWVVdGlscyA9IFByb3RvY29sRmVlVXRpbHMuZ2V0SW5zdGFuY2UoXHJcbiAgICAgICAgUFJPVE9DT0xfRkVFX1VUSUxTX1BPTExJTkdfSU5URVJWQUxfSU5fTVMsXHJcbiAgICAgICAgY2hhaW4uZ2FzU3RhdGlvblVybCxcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgYmFsYW5jZUNoZWNrZXIgPSBuZXcgQmFsYW5jZUNoZWNrZXIocHJvdmlkZXIpO1xyXG4gICAgY29uc3QgcmZxQmxvY2tjaGFpblV0aWxzID0gbmV3IFJmcUJsb2NrY2hhaW5VdGlscyhcclxuICAgICAgICBwcm92aWRlcixcclxuICAgICAgICBjb250cmFjdEFkZHJlc3Nlcy5leGNoYW5nZVByb3h5LFxyXG4gICAgICAgIGJhbGFuY2VDaGVja2VyLFxyXG4gICAgICAgIGV0aGVyc1Byb3ZpZGVyLFxyXG4gICAgICAgIGV0aGVyc1dhbGxldCxcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgcXVvdGVTZXJ2ZXJDbGllbnQgPSBuZXcgUXVvdGVTZXJ2ZXJDbGllbnQoYXhpb3NJbnN0YW5jZSk7XHJcblxyXG4gICAgY29uc3QgY2FjaGVDbGllbnQgPSBuZXcgQ2FjaGVDbGllbnQocmVkaXMpO1xyXG5cclxuICAgIGNvbnN0IGdhc1N0YXRpb25BdHRlbmRhbnQgPSBnZXRHYXNTdGF0aW9uQXR0ZW5kYW50KGNoYWluLCBheGlvc0luc3RhbmNlLCBwcm90b2NvbEZlZVV0aWxzKTtcclxuXHJcbiAgICBjb25zdCBmZWVUb2tlbk1ldGFkYXRhID0gZ2V0VG9rZW5NZXRhZGF0YUlmRXhpc3RzKGNvbnRyYWN0QWRkcmVzc2VzLmV0aGVyVG9rZW4sIGNoYWluSWQpO1xyXG4gICAgaWYgKGZlZVRva2VuTWV0YWRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmVlIHRva2VuICR7Y29udHJhY3RBZGRyZXNzZXMuZXRoZXJUb2tlbn0gb24gY2hhaW4gJHtjaGFpbklkfSBjb3VsZCBub3QgYmUgZm91bmQhYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlID0gbmV3IFJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZShcclxuICAgICAgICBjYWNoZUNsaWVudCxcclxuICAgICAgICByZnFCbG9ja2NoYWluVXRpbHMuYmFsYW5jZUNoZWNrVXRpbHMsXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBuZXcgV29ya2VyU2VydmljZShcclxuICAgICAgICBjaGFpbklkLFxyXG4gICAgICAgIGdhc1N0YXRpb25BdHRlbmRhbnQsXHJcbiAgICAgICAgY2hhaW4ucmVnaXN0cnlBZGRyZXNzLFxyXG4gICAgICAgIHJmcUJsb2NrY2hhaW5VdGlscyxcclxuICAgICAgICByZnFtRGJVdGlscyxcclxuICAgICAgICBxdW90ZVNlcnZlckNsaWVudCxcclxuICAgICAgICB3b3JrZXJDb25maWd1cmF0aW9uLnRyYW5zYWN0aW9uV2F0Y2hlclNsZWVwVGltZU1zIHx8IERFRkFVTFRfV09SS0VSX1RSQU5TQUNUSU9OX1dBVENIRVJfU0xFRVBfVElNRV9NUyxcclxuICAgICAgICBjYWNoZUNsaWVudCxcclxuICAgICAgICByZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UsXHJcbiAgICAgICAgcmZxTWFrZXJNYW5hZ2VyLFxyXG4gICAgICAgIHdvcmtlckNvbmZpZ3VyYXRpb24uaW5pdGlhbE1heFByaW9yaXR5RmVlUGVyR2FzR3dlaSxcclxuICAgICAgICB3b3JrZXJDb25maWd1cmF0aW9uLm1heEZlZVBlckdhc0NhcEd3ZWksXHJcbiAgICAgICAgd29ya2VyQ29uZmlndXJhdGlvbi5lbmFibGVBY2Nlc3NMaXN0LFxyXG4gICAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyBhbiBpbnN0YW5jZSBvZiBtYWtlciBiYWxhbmNlIGNhY2hlIHNlcnZpY2UuXHJcbiAqIEludGVuZGVkIHRvIGJlIHVzZWQgYnkgbWFrZXIgYmFsYW5jZSBjYWNoZSBiYWNrZ3JvdW5kIGpvYnMuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGRSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2VBc3luYyhcclxuICAgIGNoYWluOiBDaGFpbkNvbmZpZ3VyYXRpb24sXHJcbik6IFByb21pc2U8UmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlPiB7XHJcbiAgICBjb25zdCBwcm92aWRlciA9IHByb3ZpZGVyVXRpbHMuY3JlYXRlV2ViM1Byb3ZpZGVyKGNoYWluLnJwY1VybCk7XHJcbiAgICBjb25zdCBjb250cmFjdEFkZHJlc3NlcyA9IGF3YWl0IGdldENvbnRyYWN0QWRkcmVzc2VzRm9yTmV0d29ya09yVGhyb3dBc3luYyhwcm92aWRlciwgY2hhaW4pO1xyXG4gICAgY29uc3QgYmFsYW5jZUNoZWNrZXIgPSBuZXcgQmFsYW5jZUNoZWNrZXIocHJvdmlkZXIpO1xyXG4gICAgY29uc3QgYmFsYW5jZUNoZWNrVXRpbHMgPSBuZXcgUmZxQmFsYW5jZUNoZWNrVXRpbHMoYmFsYW5jZUNoZWNrZXIsIGNvbnRyYWN0QWRkcmVzc2VzLmV4Y2hhbmdlUHJveHkpO1xyXG5cclxuICAgIGlmICghUkVESVNfVVJJKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZWRpcyBVUkkgcHJvdmlkZWQgdG8gbWFrZXIgYmFsYW5jZSBjYWNoZSBzZXJ2aWNlJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZWRpcyA9IG5ldyBSZWRpcyhSRURJU19VUkkpO1xyXG4gICAgY29uc3QgY2FjaGVDbGllbnQgPSBuZXcgQ2FjaGVDbGllbnQocmVkaXMpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlKGNhY2hlQ2xpZW50LCBiYWxhbmNlQ2hlY2tVdGlscyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIFJGUU0gU2VydmljZSBmb3IgZWFjaCBjaGFpbiBwcmVzZW50IGluIGBDaGFpbkNvbmZpZ3VyYXRpb25zYC5cclxuICpcclxuICogSW50ZW5kZWQgZm9yIHVzZSBieSB0aGUgdG9wLWxldmVsIHJ1bm5lcnMuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGRSZnFtU2VydmljZXNBc3luYyhcclxuICAgIGFzV29ya2VyOiBib29sZWFuLFxyXG4gICAgcmZxbURiVXRpbHM6IFJmcW1EYlV0aWxzLFxyXG4gICAgcmZxTWFrZXJEYlV0aWxzOiBSZnFNYWtlckRiVXRpbHMsXHJcbiAgICBjaGFpbkNvbmZpZ3VyYXRpb25zOiBDaGFpbkNvbmZpZ3VyYXRpb25zLFxyXG4gICAgdG9rZW5QcmljZU9yYWNsZTogVG9rZW5QcmljZU9yYWNsZSxcclxuICAgIGNvbmZpZ01hbmFnZXI6IENvbmZpZ01hbmFnZXIgPSBuZXcgQ29uZmlnTWFuYWdlcigpLFxyXG4gICAgcmVkaXM6IFJlZGlzLFxyXG4gICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1pbmZlcnJhYmxlLXR5cGVzXHJcbiAgICBfd29ya2VySW5kZXg6IG51bWJlciA9IDAsXHJcbik6IFByb21pc2U8UmZxbVNlcnZpY2VzPiB7XHJcbiAgICBjb25zdCBzZXJ2aWNlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICAgIGNoYWluQ29uZmlndXJhdGlvbnMubWFwKGFzeW5jIChjaGFpbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZnFNYWtlck1hbmFnZXIgPSBuZXcgUmZxTWFrZXJNYW5hZ2VyKGNvbmZpZ01hbmFnZXIsIHJmcU1ha2VyRGJVdGlscywgY2hhaW4uY2hhaW5JZCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHJmcU1ha2VyTWFuYWdlci5pbml0aWFsaXplQXN5bmMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUmZxbVNlcnZpY2VBc3luYyhyZnFtRGJVdGlscywgcmZxTWFrZXJNYW5hZ2VyLCB0b2tlblByaWNlT3JhY2xlLCBjb25maWdNYW5hZ2VyLCBjaGFpbiwgcmVkaXMpO1xyXG4gICAgICAgIH0pLFxyXG4gICAgKTtcclxuICAgIHJldHVybiBuZXcgTWFwKHNlcnZpY2VzLm1hcCgocywgaSkgPT4gW2NoYWluQ29uZmlndXJhdGlvbnNbaV0uY2hhaW5JZCwgc10pKTtcclxufVxyXG4iXSwidmVyc2lvbiI6M30=