add9d720779bb104bad360a7e82be5db
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RfqBalanceCheckUtils = exports.RfqBlockchainUtils = void 0;
// tslint:disable:max-file-line-count
const contract_addresses_1 = require("@0x/contract-addresses");
const contracts_zero_ex_1 = require("@0x/contracts-zero-ex");
const protocol_utils_1 = require("@0x/protocol-utils");
const subproviders_1 = require("@0x/subproviders");
const utils_1 = require("@0x/utils");
const hdnode_1 = require("@ethersproject/hdnode");
const ethers_1 = require("ethers");
const utils_2 = require("ethers/lib/utils");
const abis_1 = require("../abis");
const constants_1 = require("../core/constants");
const eip712registry_1 = require("../eip712registry");
const logger_1 = require("../logger");
const types_1 = require("../core/types");
const address_utils_1 = require("./address_utils");
const Eip712Utils_1 = require("./Eip712Utils");
const rfqm_worker_balance_utils_1 = require("./rfqm_worker_balance_utils");
const service_utils_1 = require("./service_utils");
const subprovider_adapter_1 = require("./subprovider_adapter");
// allow a wide range for gas price for flexibility
const MIN_GAS_PRICE = new utils_1.BigNumber(0);
// 10K Gwei
const MAX_GAS_PRICE = new utils_1.BigNumber(1e13);
const RFQ_ORDER_FILLED_EVENT_TOPIC0 = '0x829fa99d94dc4636925b38632e625736a614c154d55006b7ab6bea979c210c32';
const OTC_ORDER_FILLED_EVENT_TOPIC0 = '0xac75f773e3a92f1a02b12134d65e1f47f8a14eabe4eaf1e24624918e6a8b269f';
const ZERO_EX_FILL_EVENT_ABI = [
    {
        anonymous: false,
        inputs: [
            { indexed: false, internalType: 'bytes32', name: 'orderHash', type: 'bytes32' },
            { indexed: false, internalType: 'address', name: 'maker', type: 'address' },
            { indexed: false, internalType: 'address', name: 'taker', type: 'address' },
            { indexed: false, internalType: 'address', name: 'makerToken', type: 'address' },
            { indexed: false, internalType: 'address', name: 'takerToken', type: 'address' },
            { indexed: false, internalType: 'uint128', name: 'takerTokenFilledAmount', type: 'uint128' },
            { indexed: false, internalType: 'uint128', name: 'makerTokenFilledAmount', type: 'uint128' },
            { indexed: false, internalType: 'bytes32', name: 'pool', type: 'bytes32' },
        ],
        name: 'RfqOrderFilled',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            { indexed: false, internalType: 'bytes32', name: 'orderHash', type: 'bytes32' },
            { indexed: false, internalType: 'address', name: 'maker', type: 'address' },
            { indexed: false, internalType: 'address', name: 'taker', type: 'address' },
            { indexed: false, internalType: 'address', name: 'makerToken', type: 'address' },
            { indexed: false, internalType: 'address', name: 'takerToken', type: 'address' },
            { indexed: false, internalType: 'uint128', name: 'makerTokenFilledAmount', type: 'uint128' },
            { indexed: false, internalType: 'uint128', name: 'takerTokenFilledAmount', type: 'uint128' },
        ],
        name: 'OtcOrderFilled',
        type: 'event',
    },
];
function toBigNumber(ethersBigNumber) {
    return new utils_1.BigNumber(ethersBigNumber.toString());
}
class RfqBlockchainUtils {
    constructor(provider, _exchangeProxyAddress, balanceChecker, ethersProvider, ethersWallet) {
        this._exchangeProxyAddress = _exchangeProxyAddress;
        this._abiDecoder = new utils_1.AbiDecoder([ZERO_EX_FILL_EVENT_ABI]);
        this.balanceCheckUtils = new RfqBalanceCheckUtils(balanceChecker, _exchangeProxyAddress);
        this._ethersProvider = ethersProvider;
        this._ethersWallet = ethersWallet;
        this._exchangeProxy = new contracts_zero_ex_1.IZeroExContract(this._exchangeProxyAddress, provider);
    }
    static getPrivateKeyFromIndexAndPhrase(mnemonic, index) {
        const hdNode = hdnode_1.HDNode.fromMnemonic(mnemonic).derivePath(this._getPathByIndex(index));
        // take '0x' off
        return hdNode.privateKey.substring(2);
    }
    static getAddressFromIndexAndPhrase(mnemonic, index) {
        const hdNode = hdnode_1.HDNode.fromMnemonic(mnemonic).derivePath(this._getPathByIndex(index));
        return hdNode.address;
    }
    static createPrivateKeyProvider(rpcProvider, privateWalletSubprovider) {
        const providerEngine = new subproviders_1.Web3ProviderEngine();
        providerEngine.addProvider(privateWalletSubprovider);
        providerEngine.addProvider(new subprovider_adapter_1.SubproviderAdapter(rpcProvider));
        utils_1.providerUtils.startProviderEngine(providerEngine);
        return providerEngine;
    }
    // tslint:disable-next-line:prefer-function-over-method
    static _getPathByIndex(index) {
        // ensure index is a 0+ integer
        if (index < 0 || index !== Math.floor(index)) {
            throw new Error(`invalid index`);
        }
        return `m/44'/60'/0'/0/`.concat(String(index));
    }
    /**
     * Fetches min value between balance for a list of addresses against the specified tokens. The index of
     * an address in `addresses` must correspond with the index of a token in `tokens`.
     */
    async getMinOfBalancesAndAllowancesAsync(erc20Owners) {
        return this.balanceCheckUtils.getMinOfBalancesAndAllowancesAsync(erc20Owners);
    }
    /**
     * Fetches the balances for a list of addresses against the specified tokens. The index of
     * an address in `addresses` must correspond with the index of a token in `tokens`.
     */
    async getTokenBalancesAsync(erc20Owners) {
        return this.balanceCheckUtils.getTokenBalancesAsync(erc20Owners);
    }
    // for use when 0x API operator submits an order on-chain on behalf of taker
    generateMetaTransaction(rfqOrder, signature, taker, takerAmount, chainId) {
        // generate call data for fillRfqOrder
        const callData = this._exchangeProxy
            .fillRfqOrder(rfqOrder, signature, takerAmount)
            .getABIEncodedTransactionData();
        return new protocol_utils_1.MetaTransaction({
            signer: taker,
            sender: constants_1.NULL_ADDRESS,
            minGasPrice: MIN_GAS_PRICE,
            maxGasPrice: MAX_GAS_PRICE,
            expirationTimeSeconds: rfqOrder.expiry,
            salt: new utils_1.BigNumber(Date.now()),
            callData,
            value: constants_1.ZERO,
            feeToken: constants_1.NULL_ADDRESS,
            feeAmount: constants_1.ZERO,
            chainId,
            verifyingContract: this._exchangeProxy.address,
        });
    }
    async decodeMetaTransactionCallDataAndValidateAsync(calldata, sender, txOptions) {
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const metaTxInput = this._exchangeProxy.getABIDecodedTransactionData('executeMetaTransaction', calldata);
        return this.validateMetaTransactionOrThrowAsync(metaTxInput[0], metaTxInput[1], sender, txOptions);
    }
    /**
     * Validates a metatransaction and its signature for a given sender
     *
     * @returns a Promise of [takerTokenFilledAmount, makerTokenFilledAmount]
     * @throws an error if the metatransaction is not valid
     */
    async validateMetaTransactionOrThrowAsync(metaTx, metaTxSig, sender, txOptions) {
        try {
            const results = await this._exchangeProxy
                .executeMetaTransaction(metaTx, metaTxSig)
                .callAsync({ from: sender, ...txOptions });
            const takerTokenFillAmount = // $eslint-fix-me github.com/rhinodavid/eslint-fix-me
             
            /* eslint-disable @typescript-eslint/no-explicit-any */
            this._exchangeProxy.getABIDecodedTransactionData('fillRfqOrder', metaTx.callData) /* eslint-enable @typescript-eslint/no-explicit-any */[2];
            const decodedResults = this._exchangeProxy.getABIDecodedReturnData('fillRfqOrder', results);
            if (decodedResults[0].isLessThan(takerTokenFillAmount)) {
                logger_1.logger.error('validation failed because filled amount is less than requested fill amount');
                throw new Error(`filled amount is less than requested fill amount`);
            }
            return decodedResults;
        }
        catch (err) {
            logger_1.logger.error({ errorMessage: err === null || err === void 0 ? void 0 : err.message }, 'eth_call validation failed for executeMetaTransaction');
            throw new Error(err);
        }
    }
    /**
     * Simulate the transaction with calldata.
     *
     * NOTE: In ethers.js, provider.call and provider.send('eth_call', ...) might not throw exception.
     *       The behavior might be dependent on providers. Revisit this later.
     */
    async simulateTransactionAsync(to, calldata) {
        try {
            await this._ethersProvider.call({
                to,
                data: calldata,
            });
        }
        catch (e) {
            if (e instanceof Error) {
                e.message = `simulateTransactionAsync: ${e.message}`;
            }
            throw e;
        }
    }
    /**
     * Estimate the gas for fillTakerSignedOtcOrder and fillTakerSignedOtcOrderForEth
     * NOTE: can also be used for validation
     *
     * @returns a Promise of the gas estimate
     * @throws an error if transaction will revert
     */
    async estimateGasForFillTakerSignedOtcOrderAsync(order, makerSignature, takerSignature, sender, isUnwrap) {
        try {
            if (isUnwrap) {
                return await this._exchangeProxy
                    .fillTakerSignedOtcOrderForEth(order, makerSignature, takerSignature)
                    .estimateGasAsync({ from: sender });
            }
            else {
                return await this._exchangeProxy
                    .fillTakerSignedOtcOrder(order, makerSignature, takerSignature)
                    .estimateGasAsync({ from: sender });
            }
        }
        catch (err) {
            logger_1.logger.error({
                orderHash: order.getHash(),
                maker: order.maker,
                taker: order.taker,
                isUnwrap,
                errorMessage: err === null || err === void 0 ? void 0 : err.message,
            }, 'validation failed for taker signed OtcOrder');
            throw err;
        }
    }
    /**
     * Generates calldata for Taker Signed OtcOrder settlement
     */
    generateTakerSignedOtcOrderCallData(order, makerSignature, takerSignature, isUnwrap, affiliateAddress) {
        const callData = isUnwrap
            ? this._exchangeProxy
                .fillTakerSignedOtcOrderForEth(order, makerSignature, takerSignature)
                .getABIEncodedTransactionData()
            : this._exchangeProxy
                .fillTakerSignedOtcOrder(order, makerSignature, takerSignature)
                .getABIEncodedTransactionData();
        return service_utils_1.serviceUtils.attributeCallData(callData, affiliateAddress).affiliatedData;
    }
    generateMetaTransactionCallData(metaTx, metaTxSig, affiliateAddress) {
        const callData = this._exchangeProxy.executeMetaTransaction(metaTx, metaTxSig).getABIEncodedTransactionData();
        return service_utils_1.serviceUtils.attributeCallData(callData, affiliateAddress).affiliatedData;
    }
    async getNonceAsync(workerAddress) {
        return this._ethersProvider.getTransactionCount(workerAddress);
    }
    getExchangeProxyAddress() {
        return this._exchangeProxyAddress;
    }
    /**
     * Returns the transaction receipts for the given transaction hashes.
     * If a receipt does not exist, returns `undefined`.
     */
    async getReceiptsAsync(transactionHashes) {
        return Promise.all(transactionHashes.map(async (transactionHash) => this._ethersProvider.getTransactionReceipt(transactionHash)));
    }
    async getCurrentBlockAsync() {
        return this._ethersProvider.getBlockNumber();
    }
    // Fetches a block from the block number or block hash
    async getBlockAsync(blockHash) {
        return this._ethersProvider.getBlock(blockHash);
    }
    /**
     * Passthrough to the ethers `getTransaction` function
     * https://docs.ethers.io/v5/api/providers/provider/#Provider-getTransaction:
     *
     * Returns the transaction with hash or null if the transaction is unknown.
     * If a transaction has not been mined, this method will search the transaction pool.
     * Various backends may have more restrictive transaction pool access
     * (e.g. if the gas price is too low or the transaction was only recently sent and not yet indexed)
     * in which case this method may also return null.
     */
    async getTransactionAsync(transactionHash) {
        return this._ethersProvider.getTransaction(transactionHash);
    }
    /**
     * Estimate gas (in wei) given a transaction request using `eth_estimateGas` JSON RPC method.
     * The transaction request contains information related to the transaction (from, to, data, etc.).
     *
     * @param transactionRequest Transaction request object which contains information about the transaction.
     * @returns The gas estimate for the transaction in wei.
     */
    async estimateGasForAsync(transactionRequest) {
        try {
            const gasEstimate = await this._ethersProvider.estimateGas(transactionRequest);
            return gasEstimate.toNumber();
        }
        catch (e) {
            if (e instanceof Error) {
                e.message = `estimateGasForAsync: ${e.message}`;
            }
            throw e;
        }
    }
    /**
     * Get the access list and the gas estimation given a transaction request. Uses the provider
     * to call the `eth_createAccessList` JSON RPC method.
     *
     * The transaction request contains information related to the transaction (from, to, data, etc.).
     * Note that the implementation is similar to the one in @0x/web3-wrapper. This repo is
     * migrating away from web3-wrapper in favor of ethers. The original implementation in
     * web3-wrapper:
     * https://github.com/0xProject/tools/blob/development/web3-wrapper/src/web3_wrapper.ts#L591
     *
     * @param transactionRequest Transaction request object which contains information about the transaction.
     * @returns A TxAccessListWithGas object which contains access list and gas estimation for the transaction.
     */
    async createAccessListForAsync(transactionRequest) {
        try {
            const rawResult = await this._ethersProvider.send('eth_createAccessList', [transactionRequest]);
            const accessList = rawResult.accessList;
            const gasUsed = rawResult.gasUsed;
            return {
                // The type for `accessList` is `AccessList` (Array<{ address: string, storageKeys: Array<string> }>).
                // The reduce operation is used to transform the array into type `TxAccessList` ([address: string]: string[]) whose keys
                // are addresses and values are corresponding storage keys. This is useful if we need to remove an address from the object.
                accessList: accessList.reduce((o, v) => {
                    o[v.address] = o[v.address] || [];
                    o[v.address].push(...(v.storageKeys || []));
                    return o;
                }, {}),
                gasEstimate: new utils_1.BigNumber(gasUsed).toNumber(),
            };
        }
        catch (e) {
            if (e instanceof Error) {
                e.message = `createAccessListForAsync: ${e.message}`;
            }
            throw e;
        }
    }
    getDecodedRfqOrderFillEventLogFromLogs(logs) {
        for (const log of logs) {
            if (log.topics[0] === RFQ_ORDER_FILLED_EVENT_TOPIC0) {
                return this._abiDecoder.tryToDecodeLogOrNoop(log);
            }
        }
        throw new Error(`no RfqOrderFilledEvent logs among the logs passed into getDecodedRfqOrderFillEventLogFromLogs`);
    }
    /**
     * Decode the OtcOrder Filled Event
     */
    getDecodedOtcOrderFillEventLogFromLogs(logs) {
        for (const log of logs) {
            if (log.topics[0] === OTC_ORDER_FILLED_EVENT_TOPIC0) {
                return this._abiDecoder.tryToDecodeLogOrNoop(log);
            }
        }
        throw new Error(`no OtcOrderFilledEvent logs among the logs passed into getDecodedOtcOrderFillEventLogFromLogs`);
    }
    /**
     * Broadcasts a raw transaction via the `eth_sendRawTransaction` JSON RPC method.
     * The transaction must be signed by this point, otherwise submission will fail.
     *
     * @returns The transaction hash returned by the RPC provider.
     */
    async submitSignedTransactionAsync(signedTransaction) {
        const response = await this._ethersProvider.sendTransaction(signedTransaction);
        return response.hash;
    }
    async getAccountBalanceAsync(accountAddress) {
        return this._ethersProvider.getBalance(accountAddress).then((r) => toBigNumber(r));
    }
    /**
     * Check if a worker is ready to pick up a new job:
     * - the worker has enough balance
     * - the worker has no pending transactions
     *
     * @param chainId Id of the chain.
     * @param workerAddress Address of the worker to check.
     * @param balance Balance of the worker to check.
     * @param gasPrice Current gas price.
     * @returns True if a worker is ready to pick up a new job and false otherwise.
     */
    async isWorkerReadyAsync(chainId, workerAddress, balance, gasPrice) {
        let gasEstimate;
        switch (chainId) {
            case contract_addresses_1.ChainId.Polygon:
                gasEstimate = constants_1.ZEROG_METATX_GAS_ESTIMATE;
                break;
            default:
                gasEstimate = constants_1.RFQM_TX_GAS_ESTIMATE;
                break;
        }
        return (0, rfqm_worker_balance_utils_1.isWorkerReadyAndAbleAsync)(this._ethersProvider, workerAddress, balance, gasPrice, gasEstimate);
    }
    /**
     * Converts a @0x/web3-wrapper `TxData` object into an Ethers `TransactionRequest`.
     *
     * If the `from` address is not present in the `TxData`, the function uses the address
     * of the Ethers Wallet passed to `rfqBlockchainUtils`
     *
     * If the `to` address is not present, the function uses the exchange proxy address.
     */
    transformTxDataToTransactionRequest(txOptions, chainId, callData) {
        const baseRequest = {
            chainId,
            data: callData,
            from: txOptions.from,
            // web3wrappers "gas" field -> ethers "gasLimit" field
            gasLimit: txOptions.gas instanceof utils_1.BigNumber ? BigInt(txOptions.gas.toString()) : txOptions.gas,
            nonce: txOptions.nonce,
            to: txOptions.to || this._exchangeProxy.address,
            value: txOptions.value instanceof utils_1.BigNumber ? txOptions.value.toString() : txOptions.value,
        };
        // Handle Type 0 (Legacy) Tx
        if (txOptions.gasPrice) {
            return {
                ...baseRequest,
                type: 0,
                gasPrice: txOptions.gasPrice instanceof utils_1.BigNumber ? txOptions.gasPrice.toString() : txOptions.gasPrice,
            };
        }
        // Handle Type 2 (EIP-1559) Tx
        return {
            ...baseRequest,
            type: 2,
            maxFeePerGas: txOptions.maxFeePerGas instanceof utils_1.BigNumber
                ? BigInt(txOptions.maxFeePerGas.toString())
                : txOptions.maxFeePerGas,
            maxPriorityFeePerGas: txOptions.maxPriorityFeePerGas instanceof utils_1.BigNumber
                ? BigInt(txOptions.maxPriorityFeePerGas.toString())
                : txOptions.maxPriorityFeePerGas,
        };
    }
    /**
     * Uses the Ethers Wallet to sign a transaction. Returns both the signed transaction and its hash.
     *
     * If the containing class has been initialized without a wallet, the function throws.
     */
    async signTransactionAsync(transaction) {
        if (!this._ethersWallet) {
            throw new Error('RFQ Blockchain Utils must be initialized with an Ethers Wallet in order to get transaction hashes before submitting');
        }
        const checkedRequest = await (0, utils_2.resolveProperties)(this._ethersWallet.checkTransaction(transaction));
        const signedTransaction = await this._ethersWallet.signTransaction(checkedRequest);
        const hash = ethers_1.utils.keccak256(signedTransaction);
        return { signedTransaction, transactionHash: hash };
    }
    async getTokenDecimalsAsync(tokenAddress) {
        const erc20AbiDecimals = `[{
            "constant": true,
            "inputs": [],
            "name": "decimals",
            "outputs": [
                {
                    "name": "",
                    "type": "uint8"
                }
            ],
            "payable": false,
            "stateMutability": "view",
            "type": "function"
        }]`;
        const tokenContract = new ethers_1.Contract(tokenAddress, erc20AbiDecimals, this._ethersProvider);
        const decimals = await tokenContract.decimals();
        if (typeof decimals !== 'number') {
            throw new Error('Decimals was not a number');
        }
        return decimals;
    }
    /**
     * Calls the 0x Exchange Proxy to add an address to the list of allowed order signers for the msg's sender.
     */
    async registerAllowedOrderSignerAsync(from, signerAddress, isAllowed) {
        // tslint:disable-next-line: await-promise
        await this._exchangeProxy
            .registerAllowedOrderSigner(signerAddress, isAllowed)
            .awaitTransactionSuccessAsync({ from });
    }
    /**
     * Returns whether the signer address is an allowed order signer of the maker.
     */
    async isValidOrderSignerAsync(makerAddress, signerAddress) {
        return this._exchangeProxy.isValidOrderSigner(makerAddress, signerAddress).callAsync();
    }
    /**
     * Get the gasless approval object which encapsulates the EIP-712 context that would be signed by the `takerAddress`
     * for gasless approval. The two main schemes for gasless approvals are `executeMetaTransaction` and `permit`.
     *
     * @param chainId Id of the chain.
     * @param token The address of the token.
     * @param takerAddress The address of the taker.
     * @param nowMs optional - the current timestamp in milliseconds
     * @returns The corresponding gasless approval oject or null if the token does not support gasless approval (does not exist in our EIP-712 token registry).
     */
    async getGaslessApprovalAsync(chainId, token, takerAddress, nowMs = Date.now()) {
        // If the token does not exist in the token registry, return null
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line no-prototype-builtins
        if (!eip712registry_1.EIP_712_REGISTRY.hasOwnProperty(chainId) || !eip712registry_1.EIP_712_REGISTRY[chainId].hasOwnProperty(token)) {
            return null;
        }
        const tokenEIP712 = eip712registry_1.EIP_712_REGISTRY[chainId][token];
        const eip712DomainType = (0, Eip712Utils_1.extractEIP712DomainType)(tokenEIP712.domain);
        switch (tokenEIP712.kind) {
            case types_1.GaslessApprovalTypes.ExecuteMetaTransaction: {
                const nonce = await this.getMetaTransactionNonceAsync(token, takerAddress);
                // generate calldata for approve with max number of uint256 as amount
                const erc20 = new ethers_1.Contract(token, abis_1.abis.polygonBridgedERC20, this._ethersProvider);
                const { data: approveCalldata } = await erc20.populateTransaction.approve(this._exchangeProxyAddress, ethers_1.constants.MaxUint256);
                const executeMetaTransactionApproval = {
                    kind: types_1.GaslessApprovalTypes.ExecuteMetaTransaction,
                    eip712: {
                        types: {
                            ...eip712DomainType,
                            ...constants_1.EXECUTE_META_TRANSACTION_EIP_712_TYPES,
                        },
                        primaryType: 'MetaTransaction',
                        domain: tokenEIP712.domain,
                        message: {
                            nonce: nonce.toNumber(),
                            from: takerAddress,
                            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            functionSignature: approveCalldata,
                        },
                    },
                };
                return executeMetaTransactionApproval;
            }
            case types_1.GaslessApprovalTypes.Permit: {
                const nonce = await this.getPermitNonceAsync(token, takerAddress);
                const tenMinutesAfterNowS = new utils_1.BigNumber(nowMs + constants_1.ONE_MINUTE_MS * 10).div(constants_1.ONE_SECOND_MS).integerValue();
                const permitApproval = {
                    kind: types_1.GaslessApprovalTypes.Permit,
                    eip712: {
                        types: {
                            ...eip712DomainType,
                            ...constants_1.PERMIT_EIP_712_TYPES,
                        },
                        primaryType: 'Permit',
                        domain: tokenEIP712.domain,
                        message: {
                            owner: takerAddress,
                            spender: this._exchangeProxyAddress,
                            value: ethers_1.constants.MaxUint256.toString(),
                            nonce: nonce.toNumber(),
                            deadline: tenMinutesAfterNowS.toString(),
                        },
                    },
                };
                return permitApproval;
            }
            default:
                throw new Error(`Gasless approval kind ${tokenEIP712.kind} is not implemented yet`);
        }
    }
    /**
     * Get the amount (in base unit) of `token` `spender` will be allowed to spend on behalf on `owner` (the allowance). Note that
     * base unit means 10 ** decimals (decimals of the token).
     *
     * @param token The address of the token.
     * @param owner The address that owns certain amount of `token`.
     * @param spender The address that would like to spend token on behalf of `owner`.
     * @returns The amount (in base unit) of tokens spender is allowed to spend.
     */
    async getAllowanceAsync(token, owner, spender) {
        const erc20 = new ethers_1.Contract(token, abis_1.abis.polygonBridgedERC20, this._ethersProvider);
        const allowance = await erc20.allowance(owner, spender);
        return new utils_1.BigNumber(allowance.toString());
    }
    /**
     * Get nonce for meta transaction. This is used by contracts that support Biconomy's `executeMetaTransaction` which includes bridged tokens on Polygon.
     *
     * @param token The address of the token.
     * @param takerAddress The address of the taker.
     * @returns Nonce.
     */
    async getMetaTransactionNonceAsync(token, takerAddress) {
        const erc20 = new ethers_1.Contract(token, abis_1.abis.polygonBridgedERC20, this._ethersProvider);
        const nonce = await erc20.getNonce(takerAddress);
        return new utils_1.BigNumber(nonce.toString());
    }
    /**
     * Get permit nonce, which is used by contracts that support EIP-2612 standards.
     *
     * @param token The address of the token.
     * @param takerAddress The address of the taker.
     * @returns Nonce.
     */
    async getPermitNonceAsync(token, takerAddress) {
        const erc20 = new ethers_1.Contract(token, abis_1.abis.permitERC20, this._ethersProvider);
        const nonce = await erc20.nonces(takerAddress);
        return new utils_1.BigNumber(nonce.toString());
    }
    /**
     * Generates calldata for gasless approval submission.
     *
     * @param token The address of the token.
     * @param approval The Approval object, which consists of 'kind' and eip712 object.
     * @param signature The gasless approval transaction signed by taker.
     * @returns Generated calldata.
     */
    async generateApprovalCalldataAsync(token, approval, signature) {
        const { kind, eip712 } = approval;
        switch (kind) {
            case types_1.GaslessApprovalTypes.ExecuteMetaTransaction: {
                const erc20 = new ethers_1.Contract(token, abis_1.abis.polygonBridgedERC20, this._ethersProvider);
                const { data } = await erc20.populateTransaction.executeMetaTransaction(eip712.message.from, eip712.message.functionSignature, signature.r, signature.s, signature.v);
                if (!data) {
                    throw new Error(`Cannot generate approval submission calldata for ${kind}`);
                }
                return data;
            }
            case types_1.GaslessApprovalTypes.Permit: {
                const erc20 = new ethers_1.Contract(token, abis_1.abis.permitERC20, this._ethersProvider);
                const { data } = await erc20.populateTransaction.permit(eip712.message.owner, eip712.message.spender, eip712.message.value, eip712.message.deadline, signature.v, signature.r, signature.s);
                if (!data) {
                    throw new Error(`Cannot generate approval submission calldata for ${kind}`);
                }
                return data;
            }
            default:
                throw new Error(`Gasless approval kind ${kind} is not implemented yet`);
        }
    }
}
exports.RfqBlockchainUtils = RfqBlockchainUtils;
class RfqBalanceCheckUtils {
    constructor(_balanceChecker, _exchangeProxyAddress) {
        this._balanceChecker = _balanceChecker;
        this._exchangeProxyAddress = _exchangeProxyAddress;
    }
    /**
     * Fetches min value between balance for a list of addresses against the specified tokens. The index of
     * an address in `addresses` must correspond with the index of a token in `tokens`.
     */
    async getMinOfBalancesAndAllowancesAsync(erc20Owners) {
        const { owners, tokens } = (0, address_utils_1.splitAddresses)(erc20Owners);
        return this._balanceChecker.getMinOfBalancesAndAllowancesAsync(owners, tokens, this._exchangeProxyAddress);
    }
    /**
     * Fetches the balances for a list of addresses against the specified tokens. The index of
     * an address in `addresses` must correspond with the index of a token in `tokens`.
     */
    async getTokenBalancesAsync(erc20Owners) {
        const { owners, tokens } = (0, address_utils_1.splitAddresses)(erc20Owners);
        return this._balanceChecker.getTokenBalancesAsync(owners, tokens);
    }
}
exports.RfqBalanceCheckUtils = RfqBalanceCheckUtils;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy91dGlscy9yZnFfYmxvY2tjaGFpbl91dGlscy50cyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxxQ0FBcUM7QUFFckMsK0RBQWlEO0FBRWpELDZEQUF3RDtBQUN4RCx1REFBb0Y7QUFDcEYsbURBQXNHO0FBQ3RHLHFDQUFpRTtBQUNqRSxrREFBK0M7QUFHL0MsbUNBQXFHO0FBQ3JHLDRDQUFxRDtBQUVyRCxrQ0FBK0I7QUFDL0IsaURBUzJCO0FBQzNCLHNEQUFxRDtBQUNyRCxzQ0FBbUM7QUFDbkMseUNBTXVCO0FBRXZCLG1EQUFpRDtBQUVqRCwrQ0FBd0Q7QUFDeEQsMkVBQXdFO0FBQ3hFLG1EQUErQztBQUMvQywrREFBMkQ7QUFFM0QsbURBQW1EO0FBQ25ELE1BQU0sYUFBYSxHQUFHLElBQUksaUJBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2QyxXQUFXO0FBQ1gsTUFBTSxhQUFhLEdBQUcsSUFBSSxpQkFBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzFDLE1BQU0sNkJBQTZCLEdBQUcsb0VBQW9FLENBQUM7QUFDM0csTUFBTSw2QkFBNkIsR0FBRyxvRUFBb0UsQ0FBQztBQUMzRyxNQUFNLHNCQUFzQixHQUFHO0lBQzNCO1FBQ0ksU0FBUyxFQUFFLEtBQUs7UUFDaEIsTUFBTSxFQUFFO1lBQ0osRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFO1lBQy9FLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTtZQUMzRSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUU7WUFDM0UsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFO1lBQ2hGLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTtZQUNoRixFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsd0JBQXdCLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTtZQUM1RixFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsd0JBQXdCLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTtZQUM1RixFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUU7U0FDN0U7UUFDRCxJQUFJLEVBQUUsZ0JBQWdCO1FBQ3RCLElBQUksRUFBRSxPQUFPO0tBQ2hCO0lBQ0Q7UUFDSSxTQUFTLEVBQUUsS0FBSztRQUNoQixNQUFNLEVBQUU7WUFDSixFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUU7WUFDL0UsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFO1lBQzNFLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTtZQUMzRSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUU7WUFD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Q0FBQztTQUMvRTtJQUNMLENBQUM7Q0FDSjtBQTdyQkQsZ0RBNnJCQztBQUVELE1BQWEsb0JBQW9CO0lBQzdCLFlBQTZCLGVBQStCLEVBQW1CLHFCQUE2QjtRQUEvRSxvQkFBZSxHQUFmLGVBQWUsQ0FBZ0I7UUFBbUIsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUFRO0lBQUcsQ0FBQztJQUVoSDs7O09BR0c7SUFDSSxLQUFLLENBQUMsa0NBQWtDLENBQUMsV0FBc0M7UUFDbEYsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxJQUFBLDhCQUFjLEVBQUMsV0FBVyxDQUFDLENBQUM7UUFDdkQsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLGtDQUFrQyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDL0csQ0FBQztJQUVEOzs7T0FHRztJQUNJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxXQUFzQztRQUNyRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLElBQUEsOEJBQWMsRUFBQyxXQUFXLENBQUMsQ0FBQztRQUN2RCxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMscUJBQXFCLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3RFLENBQUM7Q0FDSjtBQXBCRCxvREFvQkMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy91dGlscy9yZnFfYmxvY2tjaGFpbl91dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZTptYXgtZmlsZS1saW5lLWNvdW50XG5cbmltcG9ydCB7IENoYWluSWQgfSBmcm9tICdAMHgvY29udHJhY3QtYWRkcmVzc2VzJztcbmltcG9ydCB7IElaZXJvRXhPdGNPcmRlckZpbGxlZEV2ZW50QXJncywgSVplcm9FeFJmcU9yZGVyRmlsbGVkRXZlbnRBcmdzIH0gZnJvbSAnQDB4L2NvbnRyYWN0LXdyYXBwZXJzJztcbmltcG9ydCB7IElaZXJvRXhDb250cmFjdCB9IGZyb20gJ0AweC9jb250cmFjdHMtemVyby1leCc7XG5pbXBvcnQgeyBNZXRhVHJhbnNhY3Rpb24sIE90Y09yZGVyLCBSZnFPcmRlciwgU2lnbmF0dXJlIH0gZnJvbSAnQDB4L3Byb3RvY29sLXV0aWxzJztcbmltcG9ydCB7IFByaXZhdGVLZXlXYWxsZXRTdWJwcm92aWRlciwgU3VwcG9ydGVkUHJvdmlkZXIsIFdlYjNQcm92aWRlckVuZ2luZSB9IGZyb20gJ0AweC9zdWJwcm92aWRlcnMnO1xuaW1wb3J0IHsgQWJpRGVjb2RlciwgQmlnTnVtYmVyLCBwcm92aWRlclV0aWxzIH0gZnJvbSAnQDB4L3V0aWxzJztcbmltcG9ydCB7IEhETm9kZSB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L2hkbm9kZSc7XG5pbXBvcnQgeyBBY2Nlc3NMaXN0IH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zJztcbmltcG9ydCB7IENhbGxEYXRhLCBMb2dFbnRyeSwgTG9nV2l0aERlY29kZWRBcmdzLCBUeEFjY2Vzc0xpc3QsIFR4RGF0YSB9IGZyb20gJ2V0aGVyZXVtLXR5cGVzJztcbmltcG9ydCB7IEJpZ051bWJlciBhcyBFdGhlcnNCaWdOdW1iZXIsIGNvbnN0YW50cywgQ29udHJhY3QsIHByb3ZpZGVycywgdXRpbHMsIFdhbGxldCB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcGVydGllcyB9IGZyb20gJ2V0aGVycy9saWIvdXRpbHMnO1xuXG5pbXBvcnQgeyBhYmlzIH0gZnJvbSAnLi4vYWJpcyc7XG5pbXBvcnQge1xuICAgIEVYRUNVVEVfTUVUQV9UUkFOU0FDVElPTl9FSVBfNzEyX1RZUEVTLFxuICAgIE5VTExfQUREUkVTUyxcbiAgICBPTkVfTUlOVVRFX01TLFxuICAgIE9ORV9TRUNPTkRfTVMsXG4gICAgUEVSTUlUX0VJUF83MTJfVFlQRVMsXG4gICAgUkZRTV9UWF9HQVNfRVNUSU1BVEUsXG4gICAgWkVSTyxcbiAgICBaRVJPR19NRVRBVFhfR0FTX0VTVElNQVRFLFxufSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFSVBfNzEyX1JFR0lTVFJZIH0gZnJvbSAnLi4vZWlwNzEycmVnaXN0cnknO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7XG4gICAgQXBwcm92YWwsXG4gICAgRVJDMjBPd25lcixcbiAgICBFeGVjdXRlTWV0YVRyYW5zYWN0aW9uQXBwcm92YWwsXG4gICAgR2FzbGVzc0FwcHJvdmFsVHlwZXMsXG4gICAgUGVybWl0QXBwcm92YWwsXG59IGZyb20gJy4uL2NvcmUvdHlwZXMnO1xuXG5pbXBvcnQgeyBzcGxpdEFkZHJlc3NlcyB9IGZyb20gJy4vYWRkcmVzc191dGlscyc7XG5pbXBvcnQgeyBCYWxhbmNlQ2hlY2tlciB9IGZyb20gJy4vYmFsYW5jZV9jaGVja2VyJztcbmltcG9ydCB7IGV4dHJhY3RFSVA3MTJEb21haW5UeXBlIH0gZnJvbSAnLi9FaXA3MTJVdGlscyc7XG5pbXBvcnQgeyBpc1dvcmtlclJlYWR5QW5kQWJsZUFzeW5jIH0gZnJvbSAnLi9yZnFtX3dvcmtlcl9iYWxhbmNlX3V0aWxzJztcbmltcG9ydCB7IHNlcnZpY2VVdGlscyB9IGZyb20gJy4vc2VydmljZV91dGlscyc7XG5pbXBvcnQgeyBTdWJwcm92aWRlckFkYXB0ZXIgfSBmcm9tICcuL3N1YnByb3ZpZGVyX2FkYXB0ZXInO1xuXG4vLyBhbGxvdyBhIHdpZGUgcmFuZ2UgZm9yIGdhcyBwcmljZSBmb3IgZmxleGliaWxpdHlcbmNvbnN0IE1JTl9HQVNfUFJJQ0UgPSBuZXcgQmlnTnVtYmVyKDApO1xuLy8gMTBLIEd3ZWlcbmNvbnN0IE1BWF9HQVNfUFJJQ0UgPSBuZXcgQmlnTnVtYmVyKDFlMTMpO1xuY29uc3QgUkZRX09SREVSX0ZJTExFRF9FVkVOVF9UT1BJQzAgPSAnMHg4MjlmYTk5ZDk0ZGM0NjM2OTI1YjM4NjMyZTYyNTczNmE2MTRjMTU0ZDU1MDA2YjdhYjZiZWE5NzljMjEwYzMyJztcbmNvbnN0IE9UQ19PUkRFUl9GSUxMRURfRVZFTlRfVE9QSUMwID0gJzB4YWM3NWY3NzNlM2E5MmYxYTAyYjEyMTM0ZDY1ZTFmNDdmOGExNGVhYmU0ZWFmMWUyNDYyNDkxOGU2YThiMjY5Zic7XG5jb25zdCBaRVJPX0VYX0ZJTExfRVZFTlRfQUJJID0gW1xuICAgIHtcbiAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6ICdieXRlczMyJywgbmFtZTogJ29yZGVySGFzaCcsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsIG5hbWU6ICdtYWtlcicsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsIG5hbWU6ICd0YWtlcicsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsIG5hbWU6ICdtYWtlclRva2VuJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJywgbmFtZTogJ3Rha2VyVG9rZW4nLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICAgICAgICAgIHsgaW5kZXhlZDogZmFsc2UsIGludGVybmFsVHlwZTogJ3VpbnQxMjgnLCBuYW1lOiAndGFrZXJUb2tlbkZpbGxlZEFtb3VudCcsIHR5cGU6ICd1aW50MTI4JyB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiAndWludDEyOCcsIG5hbWU6ICdtYWtlclRva2VuRmlsbGVkQW1vdW50JywgdHlwZTogJ3VpbnQxMjgnIH0sXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6ICdieXRlczMyJywgbmFtZTogJ3Bvb2wnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ1JmcU9yZGVyRmlsbGVkJyxcbiAgICAgICAgdHlwZTogJ2V2ZW50JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6ICdieXRlczMyJywgbmFtZTogJ29yZGVySGFzaCcsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsIG5hbWU6ICdtYWtlcicsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsIG5hbWU6ICd0YWtlcicsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsIG5hbWU6ICdtYWtlclRva2VuJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJywgbmFtZTogJ3Rha2VyVG9rZW4nLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICAgICAgICAgIHsgaW5kZXhlZDogZmFsc2UsIGludGVybmFsVHlwZTogJ3VpbnQxMjgnLCBuYW1lOiAnbWFrZXJUb2tlbkZpbGxlZEFtb3VudCcsIHR5cGU6ICd1aW50MTI4JyB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiAndWludDEyOCcsIG5hbWU6ICd0YWtlclRva2VuRmlsbGVkQW1vdW50JywgdHlwZTogJ3VpbnQxMjgnIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdPdGNPcmRlckZpbGxlZCcsXG4gICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgfSxcbl07XG5cbmZ1bmN0aW9uIHRvQmlnTnVtYmVyKGV0aGVyc0JpZ051bWJlcjogRXRoZXJzQmlnTnVtYmVyKTogQmlnTnVtYmVyIHtcbiAgICByZXR1cm4gbmV3IEJpZ051bWJlcihldGhlcnNCaWdOdW1iZXIudG9TdHJpbmcoKSk7XG59XG5cbmV4cG9ydCBjbGFzcyBSZnFCbG9ja2NoYWluVXRpbHMge1xuICAgIHB1YmxpYyByZWFkb25seSBiYWxhbmNlQ2hlY2tVdGlsczogUmZxQmFsYW5jZUNoZWNrVXRpbHM7XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IF9leGNoYW5nZVByb3h5OiBJWmVyb0V4Q29udHJhY3Q7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfYWJpRGVjb2RlcjogQWJpRGVjb2RlcjtcbiAgICAvLyBBbiBldGhlcnMuanMgcHJvdmlkZXIuXG4gICAgcHJpdmF0ZSByZWFkb25seSBfZXRoZXJzUHJvdmlkZXI6IHByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXI7XG4gICAgLy8gQW4gZXRoZXJzLmpzIFdhbGxldC4gTXVzdCBiZSBwb3B1bGF0ZWQgZm9yIFJmcUJsb2NrY2hhaW5VdGlscyBpbnN0YW5jZXMgdXNlZCBieSBSRlFNIFdvcmtlcnMuXG4gICAgcHJpdmF0ZSByZWFkb25seSBfZXRoZXJzV2FsbGV0OiBXYWxsZXQgfCB1bmRlZmluZWQ7XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldFByaXZhdGVLZXlGcm9tSW5kZXhBbmRQaHJhc2UobW5lbW9uaWM6IHN0cmluZywgaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGhkTm9kZSA9IEhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMpLmRlcml2ZVBhdGgodGhpcy5fZ2V0UGF0aEJ5SW5kZXgoaW5kZXgpKTtcblxuICAgICAgICAvLyB0YWtlICcweCcgb2ZmXG4gICAgICAgIHJldHVybiBoZE5vZGUucHJpdmF0ZUtleS5zdWJzdHJpbmcoMik7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRBZGRyZXNzRnJvbUluZGV4QW5kUGhyYXNlKG1uZW1vbmljOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBoZE5vZGUgPSBIRE5vZGUuZnJvbU1uZW1vbmljKG1uZW1vbmljKS5kZXJpdmVQYXRoKHRoaXMuX2dldFBhdGhCeUluZGV4KGluZGV4KSk7XG5cbiAgICAgICAgcmV0dXJuIGhkTm9kZS5hZGRyZXNzO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlUHJpdmF0ZUtleVByb3ZpZGVyKFxuICAgICAgICBycGNQcm92aWRlcjogU3VwcG9ydGVkUHJvdmlkZXIsXG4gICAgICAgIHByaXZhdGVXYWxsZXRTdWJwcm92aWRlcjogUHJpdmF0ZUtleVdhbGxldFN1YnByb3ZpZGVyLFxuICAgICk6IFN1cHBvcnRlZFByb3ZpZGVyIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJFbmdpbmUgPSBuZXcgV2ViM1Byb3ZpZGVyRW5naW5lKCk7XG4gICAgICAgIHByb3ZpZGVyRW5naW5lLmFkZFByb3ZpZGVyKHByaXZhdGVXYWxsZXRTdWJwcm92aWRlcik7XG4gICAgICAgIHByb3ZpZGVyRW5naW5lLmFkZFByb3ZpZGVyKG5ldyBTdWJwcm92aWRlckFkYXB0ZXIocnBjUHJvdmlkZXIpKTtcbiAgICAgICAgcHJvdmlkZXJVdGlscy5zdGFydFByb3ZpZGVyRW5naW5lKHByb3ZpZGVyRW5naW5lKTtcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyRW5naW5lO1xuICAgIH1cblxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpwcmVmZXItZnVuY3Rpb24tb3Zlci1tZXRob2RcbiAgICBwcml2YXRlIHN0YXRpYyBfZ2V0UGF0aEJ5SW5kZXgoaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIC8vIGVuc3VyZSBpbmRleCBpcyBhIDArIGludGVnZXJcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCAhPT0gTWF0aC5mbG9vcihpbmRleCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbmRleGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgbS80NCcvNjAnLzAnLzAvYC5jb25jYXQoU3RyaW5nKGluZGV4KSk7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByb3ZpZGVyOiBTdXBwb3J0ZWRQcm92aWRlcixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfZXhjaGFuZ2VQcm94eUFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgYmFsYW5jZUNoZWNrZXI6IEJhbGFuY2VDaGVja2VyLFxuICAgICAgICBldGhlcnNQcm92aWRlcjogcHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcixcbiAgICAgICAgZXRoZXJzV2FsbGV0PzogV2FsbGV0LFxuICAgICkge1xuICAgICAgICB0aGlzLl9hYmlEZWNvZGVyID0gbmV3IEFiaURlY29kZXIoW1pFUk9fRVhfRklMTF9FVkVOVF9BQkldKTtcbiAgICAgICAgdGhpcy5iYWxhbmNlQ2hlY2tVdGlscyA9IG5ldyBSZnFCYWxhbmNlQ2hlY2tVdGlscyhiYWxhbmNlQ2hlY2tlciwgX2V4Y2hhbmdlUHJveHlBZGRyZXNzKTtcbiAgICAgICAgdGhpcy5fZXRoZXJzUHJvdmlkZXIgPSBldGhlcnNQcm92aWRlcjtcbiAgICAgICAgdGhpcy5fZXRoZXJzV2FsbGV0ID0gZXRoZXJzV2FsbGV0O1xuICAgICAgICB0aGlzLl9leGNoYW5nZVByb3h5ID0gbmV3IElaZXJvRXhDb250cmFjdCh0aGlzLl9leGNoYW5nZVByb3h5QWRkcmVzcywgcHJvdmlkZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgbWluIHZhbHVlIGJldHdlZW4gYmFsYW5jZSBmb3IgYSBsaXN0IG9mIGFkZHJlc3NlcyBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgdG9rZW5zLiBUaGUgaW5kZXggb2ZcbiAgICAgKiBhbiBhZGRyZXNzIGluIGBhZGRyZXNzZXNgIG11c3QgY29ycmVzcG9uZCB3aXRoIHRoZSBpbmRleCBvZiBhIHRva2VuIGluIGB0b2tlbnNgLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKGVyYzIwT3duZXJzOiBFUkMyME93bmVyIHwgRVJDMjBPd25lcltdKTogUHJvbWlzZTxCaWdOdW1iZXJbXT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlQ2hlY2tVdGlscy5nZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKGVyYzIwT3duZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBiYWxhbmNlcyBmb3IgYSBsaXN0IG9mIGFkZHJlc3NlcyBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgdG9rZW5zLiBUaGUgaW5kZXggb2ZcbiAgICAgKiBhbiBhZGRyZXNzIGluIGBhZGRyZXNzZXNgIG11c3QgY29ycmVzcG9uZCB3aXRoIHRoZSBpbmRleCBvZiBhIHRva2VuIGluIGB0b2tlbnNgLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRUb2tlbkJhbGFuY2VzQXN5bmMoZXJjMjBPd25lcnM6IEVSQzIwT3duZXIgfCBFUkMyME93bmVyW10pOiBQcm9taXNlPEJpZ051bWJlcltdPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VDaGVja1V0aWxzLmdldFRva2VuQmFsYW5jZXNBc3luYyhlcmMyME93bmVycyk7XG4gICAgfVxuXG4gICAgLy8gZm9yIHVzZSB3aGVuIDB4IEFQSSBvcGVyYXRvciBzdWJtaXRzIGFuIG9yZGVyIG9uLWNoYWluIG9uIGJlaGFsZiBvZiB0YWtlclxuICAgIHB1YmxpYyBnZW5lcmF0ZU1ldGFUcmFuc2FjdGlvbihcbiAgICAgICAgcmZxT3JkZXI6IFJmcU9yZGVyLFxuICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZSxcbiAgICAgICAgdGFrZXI6IHN0cmluZyxcbiAgICAgICAgdGFrZXJBbW91bnQ6IEJpZ051bWJlcixcbiAgICAgICAgY2hhaW5JZDogQ2hhaW5JZCxcbiAgICApOiBNZXRhVHJhbnNhY3Rpb24ge1xuICAgICAgICAvLyBnZW5lcmF0ZSBjYWxsIGRhdGEgZm9yIGZpbGxSZnFPcmRlclxuICAgICAgICBjb25zdCBjYWxsRGF0YSA9IHRoaXMuX2V4Y2hhbmdlUHJveHlcbiAgICAgICAgICAgIC5maWxsUmZxT3JkZXIocmZxT3JkZXIsIHNpZ25hdHVyZSwgdGFrZXJBbW91bnQpXG4gICAgICAgICAgICAuZ2V0QUJJRW5jb2RlZFRyYW5zYWN0aW9uRGF0YSgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgTWV0YVRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgIHNpZ25lcjogdGFrZXIsXG4gICAgICAgICAgICBzZW5kZXI6IE5VTExfQUREUkVTUyxcbiAgICAgICAgICAgIG1pbkdhc1ByaWNlOiBNSU5fR0FTX1BSSUNFLFxuICAgICAgICAgICAgbWF4R2FzUHJpY2U6IE1BWF9HQVNfUFJJQ0UsXG4gICAgICAgICAgICBleHBpcmF0aW9uVGltZVNlY29uZHM6IHJmcU9yZGVyLmV4cGlyeSxcbiAgICAgICAgICAgIHNhbHQ6IG5ldyBCaWdOdW1iZXIoRGF0ZS5ub3coKSksXG4gICAgICAgICAgICBjYWxsRGF0YSxcbiAgICAgICAgICAgIHZhbHVlOiBaRVJPLFxuICAgICAgICAgICAgZmVlVG9rZW46IE5VTExfQUREUkVTUyxcbiAgICAgICAgICAgIGZlZUFtb3VudDogWkVSTyxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICB2ZXJpZnlpbmdDb250cmFjdDogdGhpcy5fZXhjaGFuZ2VQcm94eS5hZGRyZXNzLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVjb2RlTWV0YVRyYW5zYWN0aW9uQ2FsbERhdGFBbmRWYWxpZGF0ZUFzeW5jKFxuICAgICAgICBjYWxsZGF0YTogc3RyaW5nLFxuICAgICAgICBzZW5kZXI6IHN0cmluZyxcbiAgICAgICAgdHhPcHRpb25zPzogUGFydGlhbDxDYWxsRGF0YT4sXG4gICAgKTogUHJvbWlzZTxbQmlnTnVtYmVyLCBCaWdOdW1iZXJdPiB7XG4gICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgbWV0YVR4SW5wdXQ6IGFueSA9IHRoaXMuX2V4Y2hhbmdlUHJveHkuZ2V0QUJJRGVjb2RlZFRyYW5zYWN0aW9uRGF0YSgnZXhlY3V0ZU1ldGFUcmFuc2FjdGlvbicsIGNhbGxkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVNZXRhVHJhbnNhY3Rpb25PclRocm93QXN5bmMobWV0YVR4SW5wdXRbMF0sIG1ldGFUeElucHV0WzFdLCBzZW5kZXIsIHR4T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGEgbWV0YXRyYW5zYWN0aW9uIGFuZCBpdHMgc2lnbmF0dXJlIGZvciBhIGdpdmVuIHNlbmRlclxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBQcm9taXNlIG9mIFt0YWtlclRva2VuRmlsbGVkQW1vdW50LCBtYWtlclRva2VuRmlsbGVkQW1vdW50XVxuICAgICAqIEB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIG1ldGF0cmFuc2FjdGlvbiBpcyBub3QgdmFsaWRcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgdmFsaWRhdGVNZXRhVHJhbnNhY3Rpb25PclRocm93QXN5bmMoXG4gICAgICAgIG1ldGFUeDogTWV0YVRyYW5zYWN0aW9uLFxuICAgICAgICBtZXRhVHhTaWc6IFNpZ25hdHVyZSxcbiAgICAgICAgc2VuZGVyOiBzdHJpbmcsXG4gICAgICAgIHR4T3B0aW9ucz86IFBhcnRpYWw8Q2FsbERhdGE+LFxuICAgICk6IFByb21pc2U8W0JpZ051bWJlciwgQmlnTnVtYmVyXT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuX2V4Y2hhbmdlUHJveHlcbiAgICAgICAgICAgICAgICAuZXhlY3V0ZU1ldGFUcmFuc2FjdGlvbihtZXRhVHgsIG1ldGFUeFNpZylcbiAgICAgICAgICAgICAgICAuY2FsbEFzeW5jKHsgZnJvbTogc2VuZGVyLCAuLi50eE9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCB0YWtlclRva2VuRmlsbEFtb3VudCA9IC8vICRlc2xpbnQtZml4LW1lIGdpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhjaGFuZ2VQcm94eS5nZXRBQklEZWNvZGVkVHJhbnNhY3Rpb25EYXRhKCdmaWxsUmZxT3JkZXInLCBtZXRhVHguY2FsbERhdGEpIGFzIGFueVxuICAgICAgICAgICAgICAgICkgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovWzJdO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlZFJlc3VsdHM6IFtCaWdOdW1iZXIsIEJpZ051bWJlcl0gPSB0aGlzLl9leGNoYW5nZVByb3h5LmdldEFCSURlY29kZWRSZXR1cm5EYXRhKFxuICAgICAgICAgICAgICAgICdmaWxsUmZxT3JkZXInLFxuICAgICAgICAgICAgICAgIHJlc3VsdHMsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRSZXN1bHRzWzBdLmlzTGVzc1RoYW4odGFrZXJUb2tlbkZpbGxBbW91bnQpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCd2YWxpZGF0aW9uIGZhaWxlZCBiZWNhdXNlIGZpbGxlZCBhbW91bnQgaXMgbGVzcyB0aGFuIHJlcXVlc3RlZCBmaWxsIGFtb3VudCcpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZmlsbGVkIGFtb3VudCBpcyBsZXNzIHRoYW4gcmVxdWVzdGVkIGZpbGwgYW1vdW50YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlZFJlc3VsdHM7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKHsgZXJyb3JNZXNzYWdlOiBlcnI/Lm1lc3NhZ2UgfSwgJ2V0aF9jYWxsIHZhbGlkYXRpb24gZmFpbGVkIGZvciBleGVjdXRlTWV0YVRyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpbXVsYXRlIHRoZSB0cmFuc2FjdGlvbiB3aXRoIGNhbGxkYXRhLlxuICAgICAqXG4gICAgICogTk9URTogSW4gZXRoZXJzLmpzLCBwcm92aWRlci5jYWxsIGFuZCBwcm92aWRlci5zZW5kKCdldGhfY2FsbCcsIC4uLikgbWlnaHQgbm90IHRocm93IGV4Y2VwdGlvbi5cbiAgICAgKiAgICAgICBUaGUgYmVoYXZpb3IgbWlnaHQgYmUgZGVwZW5kZW50IG9uIHByb3ZpZGVycy4gUmV2aXNpdCB0aGlzIGxhdGVyLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBzaW11bGF0ZVRyYW5zYWN0aW9uQXN5bmModG86IHN0cmluZywgY2FsbGRhdGE6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZXRoZXJzUHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgZGF0YTogY2FsbGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGBzaW11bGF0ZVRyYW5zYWN0aW9uQXN5bmM6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXN0aW1hdGUgdGhlIGdhcyBmb3IgZmlsbFRha2VyU2lnbmVkT3RjT3JkZXIgYW5kIGZpbGxUYWtlclNpZ25lZE90Y09yZGVyRm9yRXRoXG4gICAgICogTk9URTogY2FuIGFsc28gYmUgdXNlZCBmb3IgdmFsaWRhdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBQcm9taXNlIG9mIHRoZSBnYXMgZXN0aW1hdGVcbiAgICAgKiBAdGhyb3dzIGFuIGVycm9yIGlmIHRyYW5zYWN0aW9uIHdpbGwgcmV2ZXJ0XG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGVzdGltYXRlR2FzRm9yRmlsbFRha2VyU2lnbmVkT3RjT3JkZXJBc3luYyhcbiAgICAgICAgb3JkZXI6IE90Y09yZGVyLFxuICAgICAgICBtYWtlclNpZ25hdHVyZTogU2lnbmF0dXJlLFxuICAgICAgICB0YWtlclNpZ25hdHVyZTogU2lnbmF0dXJlLFxuICAgICAgICBzZW5kZXI6IHN0cmluZyxcbiAgICAgICAgaXNVbndyYXA6IGJvb2xlYW4sXG4gICAgKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpc1Vud3JhcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9leGNoYW5nZVByb3h5XG4gICAgICAgICAgICAgICAgICAgIC5maWxsVGFrZXJTaWduZWRPdGNPcmRlckZvckV0aChvcmRlciwgbWFrZXJTaWduYXR1cmUsIHRha2VyU2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgICAgICAuZXN0aW1hdGVHYXNBc3luYyh7IGZyb206IHNlbmRlciB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2V4Y2hhbmdlUHJveHlcbiAgICAgICAgICAgICAgICAgICAgLmZpbGxUYWtlclNpZ25lZE90Y09yZGVyKG9yZGVyLCBtYWtlclNpZ25hdHVyZSwgdGFrZXJTaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgICAgIC5lc3RpbWF0ZUdhc0FzeW5jKHsgZnJvbTogc2VuZGVyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVySGFzaDogb3JkZXIuZ2V0SGFzaCgpLFxuICAgICAgICAgICAgICAgICAgICBtYWtlcjogb3JkZXIubWFrZXIsXG4gICAgICAgICAgICAgICAgICAgIHRha2VyOiBvcmRlci50YWtlcixcbiAgICAgICAgICAgICAgICAgICAgaXNVbndyYXAsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZTogZXJyPy5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ZhbGlkYXRpb24gZmFpbGVkIGZvciB0YWtlciBzaWduZWQgT3RjT3JkZXInLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBjYWxsZGF0YSBmb3IgVGFrZXIgU2lnbmVkIE90Y09yZGVyIHNldHRsZW1lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2VuZXJhdGVUYWtlclNpZ25lZE90Y09yZGVyQ2FsbERhdGEoXG4gICAgICAgIG9yZGVyOiBPdGNPcmRlcixcbiAgICAgICAgbWFrZXJTaWduYXR1cmU6IFNpZ25hdHVyZSxcbiAgICAgICAgdGFrZXJTaWduYXR1cmU6IFNpZ25hdHVyZSxcbiAgICAgICAgaXNVbndyYXA6IGJvb2xlYW4sXG4gICAgICAgIGFmZmlsaWF0ZUFkZHJlc3M6IHN0cmluZyB8IG51bGwsXG4gICAgKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgY2FsbERhdGEgPSBpc1Vud3JhcFxuICAgICAgICAgICAgPyB0aGlzLl9leGNoYW5nZVByb3h5XG4gICAgICAgICAgICAgICAgICAuZmlsbFRha2VyU2lnbmVkT3RjT3JkZXJGb3JFdGgob3JkZXIsIG1ha2VyU2lnbmF0dXJlLCB0YWtlclNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICAgIC5nZXRBQklFbmNvZGVkVHJhbnNhY3Rpb25EYXRhKClcbiAgICAgICAgICAgIDogdGhpcy5fZXhjaGFuZ2VQcm94eVxuICAgICAgICAgICAgICAgICAgLmZpbGxUYWtlclNpZ25lZE90Y09yZGVyKG9yZGVyLCBtYWtlclNpZ25hdHVyZSwgdGFrZXJTaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgICAuZ2V0QUJJRW5jb2RlZFRyYW5zYWN0aW9uRGF0YSgpO1xuICAgICAgICByZXR1cm4gc2VydmljZVV0aWxzLmF0dHJpYnV0ZUNhbGxEYXRhKGNhbGxEYXRhLCBhZmZpbGlhdGVBZGRyZXNzKS5hZmZpbGlhdGVkRGF0YTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb25DYWxsRGF0YShcbiAgICAgICAgbWV0YVR4OiBNZXRhVHJhbnNhY3Rpb24sXG4gICAgICAgIG1ldGFUeFNpZzogU2lnbmF0dXJlLFxuICAgICAgICBhZmZpbGlhdGVBZGRyZXNzOiBzdHJpbmcgfCBudWxsLFxuICAgICk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGNhbGxEYXRhID0gdGhpcy5fZXhjaGFuZ2VQcm94eS5leGVjdXRlTWV0YVRyYW5zYWN0aW9uKG1ldGFUeCwgbWV0YVR4U2lnKS5nZXRBQklFbmNvZGVkVHJhbnNhY3Rpb25EYXRhKCk7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlVXRpbHMuYXR0cmlidXRlQ2FsbERhdGEoY2FsbERhdGEsIGFmZmlsaWF0ZUFkZHJlc3MpLmFmZmlsaWF0ZWREYXRhO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBnZXROb25jZUFzeW5jKHdvcmtlckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldGhlcnNQcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHdvcmtlckFkZHJlc3MpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRFeGNoYW5nZVByb3h5QWRkcmVzcygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhjaGFuZ2VQcm94eUFkZHJlc3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdHMgZm9yIHRoZSBnaXZlbiB0cmFuc2FjdGlvbiBoYXNoZXMuXG4gICAgICogSWYgYSByZWNlaXB0IGRvZXMgbm90IGV4aXN0LCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRSZWNlaXB0c0FzeW5jKHRyYW5zYWN0aW9uSGFzaGVzOiBzdHJpbmdbXSk6IFByb21pc2U8KHByb3ZpZGVycy5UcmFuc2FjdGlvblJlY2VpcHQgfCB1bmRlZmluZWQpW10+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoZXMubWFwKGFzeW5jICh0cmFuc2FjdGlvbkhhc2gpID0+XG4gICAgICAgICAgICAgICAgdGhpcy5fZXRoZXJzUHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCksXG4gICAgICAgICAgICApLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBnZXRDdXJyZW50QmxvY2tBc3luYygpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXRoZXJzUHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICB9XG5cbiAgICAvLyBGZXRjaGVzIGEgYmxvY2sgZnJvbSB0aGUgYmxvY2sgbnVtYmVyIG9yIGJsb2NrIGhhc2hcbiAgICBwdWJsaWMgYXN5bmMgZ2V0QmxvY2tBc3luYyhibG9ja0hhc2g6IHByb3ZpZGVycy5CbG9ja1RhZyk6IFByb21pc2U8cHJvdmlkZXJzLkJsb2NrPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldGhlcnNQcm92aWRlci5nZXRCbG9jayhibG9ja0hhc2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3N0aHJvdWdoIHRvIHRoZSBldGhlcnMgYGdldFRyYW5zYWN0aW9uYCBmdW5jdGlvblxuICAgICAqIGh0dHBzOi8vZG9jcy5ldGhlcnMuaW8vdjUvYXBpL3Byb3ZpZGVycy9wcm92aWRlci8jUHJvdmlkZXItZ2V0VHJhbnNhY3Rpb246XG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiB3aXRoIGhhc2ggb3IgbnVsbCBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgdW5rbm93bi5cbiAgICAgKiBJZiBhIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgdGhpcyBtZXRob2Qgd2lsbCBzZWFyY2ggdGhlIHRyYW5zYWN0aW9uIHBvb2wuXG4gICAgICogVmFyaW91cyBiYWNrZW5kcyBtYXkgaGF2ZSBtb3JlIHJlc3RyaWN0aXZlIHRyYW5zYWN0aW9uIHBvb2wgYWNjZXNzXG4gICAgICogKGUuZy4gaWYgdGhlIGdhcyBwcmljZSBpcyB0b28gbG93IG9yIHRoZSB0cmFuc2FjdGlvbiB3YXMgb25seSByZWNlbnRseSBzZW50IGFuZCBub3QgeWV0IGluZGV4ZWQpXG4gICAgICogaW4gd2hpY2ggY2FzZSB0aGlzIG1ldGhvZCBtYXkgYWxzbyByZXR1cm4gbnVsbC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0VHJhbnNhY3Rpb25Bc3luYyh0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyk6IFByb21pc2U8cHJvdmlkZXJzLlRyYW5zYWN0aW9uUmVzcG9uc2UgfCBudWxsPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldGhlcnNQcm92aWRlci5nZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzdGltYXRlIGdhcyAoaW4gd2VpKSBnaXZlbiBhIHRyYW5zYWN0aW9uIHJlcXVlc3QgdXNpbmcgYGV0aF9lc3RpbWF0ZUdhc2AgSlNPTiBSUEMgbWV0aG9kLlxuICAgICAqIFRoZSB0cmFuc2FjdGlvbiByZXF1ZXN0IGNvbnRhaW5zIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhlIHRyYW5zYWN0aW9uIChmcm9tLCB0bywgZGF0YSwgZXRjLikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25SZXF1ZXN0IFRyYW5zYWN0aW9uIHJlcXVlc3Qgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgZ2FzIGVzdGltYXRlIGZvciB0aGUgdHJhbnNhY3Rpb24gaW4gd2VpLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBlc3RpbWF0ZUdhc0ZvckFzeW5jKHRyYW5zYWN0aW9uUmVxdWVzdDogcHJvdmlkZXJzLlRyYW5zYWN0aW9uUmVxdWVzdCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBnYXNFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuX2V0aGVyc1Byb3ZpZGVyLmVzdGltYXRlR2FzKHRyYW5zYWN0aW9uUmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gZ2FzRXN0aW1hdGUudG9OdW1iZXIoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGBlc3RpbWF0ZUdhc0ZvckFzeW5jOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYWNjZXNzIGxpc3QgYW5kIHRoZSBnYXMgZXN0aW1hdGlvbiBnaXZlbiBhIHRyYW5zYWN0aW9uIHJlcXVlc3QuIFVzZXMgdGhlIHByb3ZpZGVyXG4gICAgICogdG8gY2FsbCB0aGUgYGV0aF9jcmVhdGVBY2Nlc3NMaXN0YCBKU09OIFJQQyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBUaGUgdHJhbnNhY3Rpb24gcmVxdWVzdCBjb250YWlucyBpbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoZSB0cmFuc2FjdGlvbiAoZnJvbSwgdG8sIGRhdGEsIGV0Yy4pLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgaW1wbGVtZW50YXRpb24gaXMgc2ltaWxhciB0byB0aGUgb25lIGluIEAweC93ZWIzLXdyYXBwZXIuIFRoaXMgcmVwbyBpc1xuICAgICAqIG1pZ3JhdGluZyBhd2F5IGZyb20gd2ViMy13cmFwcGVyIGluIGZhdm9yIG9mIGV0aGVycy4gVGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGluXG4gICAgICogd2ViMy13cmFwcGVyOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS8weFByb2plY3QvdG9vbHMvYmxvYi9kZXZlbG9wbWVudC93ZWIzLXdyYXBwZXIvc3JjL3dlYjNfd3JhcHBlci50cyNMNTkxXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25SZXF1ZXN0IFRyYW5zYWN0aW9uIHJlcXVlc3Qgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIFR4QWNjZXNzTGlzdFdpdGhHYXMgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGFjY2VzcyBsaXN0IGFuZCBnYXMgZXN0aW1hdGlvbiBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBjcmVhdGVBY2Nlc3NMaXN0Rm9yQXN5bmMoXG4gICAgICAgIHRyYW5zYWN0aW9uUmVxdWVzdDogcHJvdmlkZXJzLlRyYW5zYWN0aW9uUmVxdWVzdCxcbiAgICApOiBQcm9taXNlPHsgYWNjZXNzTGlzdDogVHhBY2Nlc3NMaXN0OyBnYXNFc3RpbWF0ZTogbnVtYmVyIH0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJhd1Jlc3VsdCA9IGF3YWl0IHRoaXMuX2V0aGVyc1Byb3ZpZGVyLnNlbmQoJ2V0aF9jcmVhdGVBY2Nlc3NMaXN0JywgW3RyYW5zYWN0aW9uUmVxdWVzdF0pO1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzTGlzdDogQWNjZXNzTGlzdCA9IHJhd1Jlc3VsdC5hY2Nlc3NMaXN0O1xuICAgICAgICAgICAgY29uc3QgZ2FzVXNlZDogc3RyaW5nID0gcmF3UmVzdWx0Lmdhc1VzZWQ7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHR5cGUgZm9yIGBhY2Nlc3NMaXN0YCBpcyBgQWNjZXNzTGlzdGAgKEFycmF5PHsgYWRkcmVzczogc3RyaW5nLCBzdG9yYWdlS2V5czogQXJyYXk8c3RyaW5nPiB9PikuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlZHVjZSBvcGVyYXRpb24gaXMgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGFycmF5IGludG8gdHlwZSBgVHhBY2Nlc3NMaXN0YCAoW2FkZHJlc3M6IHN0cmluZ106IHN0cmluZ1tdKSB3aG9zZSBrZXlzXG4gICAgICAgICAgICAgICAgLy8gYXJlIGFkZHJlc3NlcyBhbmQgdmFsdWVzIGFyZSBjb3JyZXNwb25kaW5nIHN0b3JhZ2Uga2V5cy4gVGhpcyBpcyB1c2VmdWwgaWYgd2UgbmVlZCB0byByZW1vdmUgYW4gYWRkcmVzcyBmcm9tIHRoZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgYWNjZXNzTGlzdDogYWNjZXNzTGlzdC5yZWR1Y2UoKG86IFR4QWNjZXNzTGlzdCwgdjogeyBhZGRyZXNzOiBzdHJpbmc7IHN0b3JhZ2VLZXlzOiBzdHJpbmdbXSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9bdi5hZGRyZXNzXSA9IG9bdi5hZGRyZXNzXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgb1t2LmFkZHJlc3NdLnB1c2goLi4uKHYuc3RvcmFnZUtleXMgfHwgW10pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgICAgIGdhc0VzdGltYXRlOiBuZXcgQmlnTnVtYmVyKGdhc1VzZWQpLnRvTnVtYmVyKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYGNyZWF0ZUFjY2Vzc0xpc3RGb3JBc3luYzogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXREZWNvZGVkUmZxT3JkZXJGaWxsRXZlbnRMb2dGcm9tTG9ncyhcbiAgICAgICAgbG9nczogTG9nRW50cnlbXSxcbiAgICApOiBMb2dXaXRoRGVjb2RlZEFyZ3M8SVplcm9FeFJmcU9yZGVyRmlsbGVkRXZlbnRBcmdzPiB7XG4gICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3MpIHtcbiAgICAgICAgICAgIGlmIChsb2cudG9waWNzWzBdID09PSBSRlFfT1JERVJfRklMTEVEX0VWRU5UX1RPUElDMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYmlEZWNvZGVyLnRyeVRvRGVjb2RlTG9nT3JOb29wKGxvZykgYXMgTG9nV2l0aERlY29kZWRBcmdzPElaZXJvRXhSZnFPcmRlckZpbGxlZEV2ZW50QXJncz47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYG5vIFJmcU9yZGVyRmlsbGVkRXZlbnQgbG9ncyBhbW9uZyB0aGUgbG9ncyBwYXNzZWQgaW50byBnZXREZWNvZGVkUmZxT3JkZXJGaWxsRXZlbnRMb2dGcm9tTG9nc2AsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIHRoZSBPdGNPcmRlciBGaWxsZWQgRXZlbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0RGVjb2RlZE90Y09yZGVyRmlsbEV2ZW50TG9nRnJvbUxvZ3MoXG4gICAgICAgIGxvZ3M6IExvZ0VudHJ5W10sXG4gICAgKTogTG9nV2l0aERlY29kZWRBcmdzPElaZXJvRXhPdGNPcmRlckZpbGxlZEV2ZW50QXJncz4ge1xuICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiBsb2dzKSB7XG4gICAgICAgICAgICBpZiAobG9nLnRvcGljc1swXSA9PT0gT1RDX09SREVSX0ZJTExFRF9FVkVOVF9UT1BJQzApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWJpRGVjb2Rlci50cnlUb0RlY29kZUxvZ09yTm9vcChsb2cpIGFzIExvZ1dpdGhEZWNvZGVkQXJnczxJWmVyb0V4UmZxT3JkZXJGaWxsZWRFdmVudEFyZ3M+O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBubyBPdGNPcmRlckZpbGxlZEV2ZW50IGxvZ3MgYW1vbmcgdGhlIGxvZ3MgcGFzc2VkIGludG8gZ2V0RGVjb2RlZE90Y09yZGVyRmlsbEV2ZW50TG9nRnJvbUxvZ3NgLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgYSByYXcgdHJhbnNhY3Rpb24gdmlhIHRoZSBgZXRoX3NlbmRSYXdUcmFuc2FjdGlvbmAgSlNPTiBSUEMgbWV0aG9kLlxuICAgICAqIFRoZSB0cmFuc2FjdGlvbiBtdXN0IGJlIHNpZ25lZCBieSB0aGlzIHBvaW50LCBvdGhlcndpc2Ugc3VibWlzc2lvbiB3aWxsIGZhaWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gaGFzaCByZXR1cm5lZCBieSB0aGUgUlBDIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBzdWJtaXRTaWduZWRUcmFuc2FjdGlvbkFzeW5jKHNpZ25lZFRyYW5zYWN0aW9uOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2V0aGVyc1Byb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5oYXNoO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBnZXRBY2NvdW50QmFsYW5jZUFzeW5jKGFjY291bnRBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPEJpZ051bWJlcj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXRoZXJzUHJvdmlkZXIuZ2V0QmFsYW5jZShhY2NvdW50QWRkcmVzcykudGhlbigocikgPT4gdG9CaWdOdW1iZXIocikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgd29ya2VyIGlzIHJlYWR5IHRvIHBpY2sgdXAgYSBuZXcgam9iOlxuICAgICAqIC0gdGhlIHdvcmtlciBoYXMgZW5vdWdoIGJhbGFuY2VcbiAgICAgKiAtIHRoZSB3b3JrZXIgaGFzIG5vIHBlbmRpbmcgdHJhbnNhY3Rpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhaW5JZCBJZCBvZiB0aGUgY2hhaW4uXG4gICAgICogQHBhcmFtIHdvcmtlckFkZHJlc3MgQWRkcmVzcyBvZiB0aGUgd29ya2VyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSBiYWxhbmNlIEJhbGFuY2Ugb2YgdGhlIHdvcmtlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0gZ2FzUHJpY2UgQ3VycmVudCBnYXMgcHJpY2UuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBhIHdvcmtlciBpcyByZWFkeSB0byBwaWNrIHVwIGEgbmV3IGpvYiBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBpc1dvcmtlclJlYWR5QXN5bmMoXG4gICAgICAgIGNoYWluSWQ6IENoYWluSWQsXG4gICAgICAgIHdvcmtlckFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgYmFsYW5jZTogQmlnTnVtYmVyLFxuICAgICAgICBnYXNQcmljZTogQmlnTnVtYmVyLFxuICAgICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBsZXQgZ2FzRXN0aW1hdGU7XG4gICAgICAgIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgICAgICAgICAgY2FzZSBDaGFpbklkLlBvbHlnb246XG4gICAgICAgICAgICAgICAgZ2FzRXN0aW1hdGUgPSBaRVJPR19NRVRBVFhfR0FTX0VTVElNQVRFO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBnYXNFc3RpbWF0ZSA9IFJGUU1fVFhfR0FTX0VTVElNQVRFO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzV29ya2VyUmVhZHlBbmRBYmxlQXN5bmModGhpcy5fZXRoZXJzUHJvdmlkZXIsIHdvcmtlckFkZHJlc3MsIGJhbGFuY2UsIGdhc1ByaWNlLCBnYXNFc3RpbWF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBAMHgvd2ViMy13cmFwcGVyIGBUeERhdGFgIG9iamVjdCBpbnRvIGFuIEV0aGVycyBgVHJhbnNhY3Rpb25SZXF1ZXN0YC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBgZnJvbWAgYWRkcmVzcyBpcyBub3QgcHJlc2VudCBpbiB0aGUgYFR4RGF0YWAsIHRoZSBmdW5jdGlvbiB1c2VzIHRoZSBhZGRyZXNzXG4gICAgICogb2YgdGhlIEV0aGVycyBXYWxsZXQgcGFzc2VkIHRvIGByZnFCbG9ja2NoYWluVXRpbHNgXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYHRvYCBhZGRyZXNzIGlzIG5vdCBwcmVzZW50LCB0aGUgZnVuY3Rpb24gdXNlcyB0aGUgZXhjaGFuZ2UgcHJveHkgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgdHJhbnNmb3JtVHhEYXRhVG9UcmFuc2FjdGlvblJlcXVlc3QoXG4gICAgICAgIHR4T3B0aW9uczogUGFydGlhbDxUeERhdGE+LFxuICAgICAgICBjaGFpbklkPzogQ2hhaW5JZCxcbiAgICAgICAgY2FsbERhdGE/OiB1dGlscy5CeXRlc0xpa2UsXG4gICAgKTogcHJvdmlkZXJzLlRyYW5zYWN0aW9uUmVxdWVzdCB7XG4gICAgICAgIGNvbnN0IGJhc2VSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgIGRhdGE6IGNhbGxEYXRhLFxuICAgICAgICAgICAgZnJvbTogdHhPcHRpb25zLmZyb20sXG4gICAgICAgICAgICAvLyB3ZWIzd3JhcHBlcnMgXCJnYXNcIiBmaWVsZCAtPiBldGhlcnMgXCJnYXNMaW1pdFwiIGZpZWxkXG4gICAgICAgICAgICBnYXNMaW1pdDogdHhPcHRpb25zLmdhcyBpbnN0YW5jZW9mIEJpZ051bWJlciA/IEJpZ0ludCh0eE9wdGlvbnMuZ2FzLnRvU3RyaW5nKCkpIDogdHhPcHRpb25zLmdhcyxcbiAgICAgICAgICAgIG5vbmNlOiB0eE9wdGlvbnMubm9uY2UsXG4gICAgICAgICAgICB0bzogdHhPcHRpb25zLnRvIHx8IHRoaXMuX2V4Y2hhbmdlUHJveHkuYWRkcmVzcyxcbiAgICAgICAgICAgIHZhbHVlOiB0eE9wdGlvbnMudmFsdWUgaW5zdGFuY2VvZiBCaWdOdW1iZXIgPyB0eE9wdGlvbnMudmFsdWUudG9TdHJpbmcoKSA6IHR4T3B0aW9ucy52YWx1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBIYW5kbGUgVHlwZSAwIChMZWdhY3kpIFR4XG4gICAgICAgIGlmICh0eE9wdGlvbnMuZ2FzUHJpY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uYmFzZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdHlwZTogMCxcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogdHhPcHRpb25zLmdhc1ByaWNlIGluc3RhbmNlb2YgQmlnTnVtYmVyID8gdHhPcHRpb25zLmdhc1ByaWNlLnRvU3RyaW5nKCkgOiB0eE9wdGlvbnMuZ2FzUHJpY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIFR5cGUgMiAoRUlQLTE1NTkpIFR4XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5iYXNlUmVxdWVzdCxcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6XG4gICAgICAgICAgICAgICAgdHhPcHRpb25zLm1heEZlZVBlckdhcyBpbnN0YW5jZW9mIEJpZ051bWJlclxuICAgICAgICAgICAgICAgICAgICA/IEJpZ0ludCh0eE9wdGlvbnMubWF4RmVlUGVyR2FzLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIDogdHhPcHRpb25zLm1heEZlZVBlckdhcyxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOlxuICAgICAgICAgICAgICAgIHR4T3B0aW9ucy5tYXhQcmlvcml0eUZlZVBlckdhcyBpbnN0YW5jZW9mIEJpZ051bWJlclxuICAgICAgICAgICAgICAgICAgICA/IEJpZ0ludCh0eE9wdGlvbnMubWF4UHJpb3JpdHlGZWVQZXJHYXMudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgOiB0eE9wdGlvbnMubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyB0aGUgRXRoZXJzIFdhbGxldCB0byBzaWduIGEgdHJhbnNhY3Rpb24uIFJldHVybnMgYm90aCB0aGUgc2lnbmVkIHRyYW5zYWN0aW9uIGFuZCBpdHMgaGFzaC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBjb250YWluaW5nIGNsYXNzIGhhcyBiZWVuIGluaXRpYWxpemVkIHdpdGhvdXQgYSB3YWxsZXQsIHRoZSBmdW5jdGlvbiB0aHJvd3MuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIHNpZ25UcmFuc2FjdGlvbkFzeW5jKFxuICAgICAgICB0cmFuc2FjdGlvbjogcHJvdmlkZXJzLlRyYW5zYWN0aW9uUmVxdWVzdCxcbiAgICApOiBQcm9taXNlPHsgc2lnbmVkVHJhbnNhY3Rpb246IHN0cmluZzsgdHJhbnNhY3Rpb25IYXNoOiBzdHJpbmcgfT4ge1xuICAgICAgICBpZiAoIXRoaXMuX2V0aGVyc1dhbGxldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdSRlEgQmxvY2tjaGFpbiBVdGlscyBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggYW4gRXRoZXJzIFdhbGxldCBpbiBvcmRlciB0byBnZXQgdHJhbnNhY3Rpb24gaGFzaGVzIGJlZm9yZSBzdWJtaXR0aW5nJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGVja2VkUmVxdWVzdCA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHRoaXMuX2V0aGVyc1dhbGxldC5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XG4gICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5fZXRoZXJzV2FsbGV0LnNpZ25UcmFuc2FjdGlvbihjaGVja2VkUmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSB1dGlscy5rZWNjYWsyNTYoc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4geyBzaWduZWRUcmFuc2FjdGlvbiwgdHJhbnNhY3Rpb25IYXNoOiBoYXNoIH07XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGdldFRva2VuRGVjaW1hbHNBc3luYyh0b2tlbkFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIGNvbnN0IGVyYzIwQWJpRGVjaW1hbHMgPSBgW3tcbiAgICAgICAgICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiaW5wdXRzXCI6IFtdLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGVjaW1hbHNcIixcbiAgICAgICAgICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidWludDhcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgICAgICAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInZpZXdcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICAgICAgfV1gO1xuICAgICAgICBjb25zdCB0b2tlbkNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KHRva2VuQWRkcmVzcywgZXJjMjBBYmlEZWNpbWFscywgdGhpcy5fZXRoZXJzUHJvdmlkZXIpO1xuICAgICAgICBjb25zdCBkZWNpbWFscyA9IGF3YWl0IHRva2VuQ29udHJhY3QuZGVjaW1hbHMoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWNpbWFscyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjaW1hbHMgd2FzIG5vdCBhIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNpbWFscztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgMHggRXhjaGFuZ2UgUHJveHkgdG8gYWRkIGFuIGFkZHJlc3MgdG8gdGhlIGxpc3Qgb2YgYWxsb3dlZCBvcmRlciBzaWduZXJzIGZvciB0aGUgbXNnJ3Mgc2VuZGVyLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyByZWdpc3RlckFsbG93ZWRPcmRlclNpZ25lckFzeW5jKFxuICAgICAgICBmcm9tOiBzdHJpbmcsXG4gICAgICAgIHNpZ25lckFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgaXNBbGxvd2VkOiBib29sZWFuLFxuICAgICk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGF3YWl0LXByb21pc2VcbiAgICAgICAgYXdhaXQgdGhpcy5fZXhjaGFuZ2VQcm94eVxuICAgICAgICAgICAgLnJlZ2lzdGVyQWxsb3dlZE9yZGVyU2lnbmVyKHNpZ25lckFkZHJlc3MsIGlzQWxsb3dlZClcbiAgICAgICAgICAgIC5hd2FpdFRyYW5zYWN0aW9uU3VjY2Vzc0FzeW5jKHsgZnJvbSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHNpZ25lciBhZGRyZXNzIGlzIGFuIGFsbG93ZWQgb3JkZXIgc2lnbmVyIG9mIHRoZSBtYWtlci5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgaXNWYWxpZE9yZGVyU2lnbmVyQXN5bmMobWFrZXJBZGRyZXNzOiBzdHJpbmcsIHNpZ25lckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhjaGFuZ2VQcm94eS5pc1ZhbGlkT3JkZXJTaWduZXIobWFrZXJBZGRyZXNzLCBzaWduZXJBZGRyZXNzKS5jYWxsQXN5bmMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGdhc2xlc3MgYXBwcm92YWwgb2JqZWN0IHdoaWNoIGVuY2Fwc3VsYXRlcyB0aGUgRUlQLTcxMiBjb250ZXh0IHRoYXQgd291bGQgYmUgc2lnbmVkIGJ5IHRoZSBgdGFrZXJBZGRyZXNzYFxuICAgICAqIGZvciBnYXNsZXNzIGFwcHJvdmFsLiBUaGUgdHdvIG1haW4gc2NoZW1lcyBmb3IgZ2FzbGVzcyBhcHByb3ZhbHMgYXJlIGBleGVjdXRlTWV0YVRyYW5zYWN0aW9uYCBhbmQgYHBlcm1pdGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhaW5JZCBJZCBvZiB0aGUgY2hhaW4uXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSBhZGRyZXNzIG9mIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gdGFrZXJBZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoZSB0YWtlci5cbiAgICAgKiBAcGFyYW0gbm93TXMgb3B0aW9uYWwgLSB0aGUgY3VycmVudCB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogQHJldHVybnMgVGhlIGNvcnJlc3BvbmRpbmcgZ2FzbGVzcyBhcHByb3ZhbCBvamVjdCBvciBudWxsIGlmIHRoZSB0b2tlbiBkb2VzIG5vdCBzdXBwb3J0IGdhc2xlc3MgYXBwcm92YWwgKGRvZXMgbm90IGV4aXN0IGluIG91ciBFSVAtNzEyIHRva2VuIHJlZ2lzdHJ5KS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0R2FzbGVzc0FwcHJvdmFsQXN5bmMoXG4gICAgICAgIGNoYWluSWQ6IG51bWJlcixcbiAgICAgICAgdG9rZW46IHN0cmluZyxcbiAgICAgICAgdGFrZXJBZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgIG5vd01zOiBudW1iZXIgPSBEYXRlLm5vdygpLFxuICAgICk6IFByb21pc2U8QXBwcm92YWwgfCBudWxsPiB7XG4gICAgICAgIC8vIElmIHRoZSB0b2tlbiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgdG9rZW4gcmVnaXN0cnksIHJldHVybiBudWxsXG4gICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICBpZiAoIUVJUF83MTJfUkVHSVNUUlkuaGFzT3duUHJvcGVydHkoY2hhaW5JZCkgfHwgIUVJUF83MTJfUkVHSVNUUllbY2hhaW5JZF0uaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRva2VuRUlQNzEyID0gRUlQXzcxMl9SRUdJU1RSWVtjaGFpbklkXVt0b2tlbl07XG4gICAgICAgIGNvbnN0IGVpcDcxMkRvbWFpblR5cGUgPSBleHRyYWN0RUlQNzEyRG9tYWluVHlwZSh0b2tlbkVJUDcxMi5kb21haW4pO1xuICAgICAgICBzd2l0Y2ggKHRva2VuRUlQNzEyLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgR2FzbGVzc0FwcHJvdmFsVHlwZXMuRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgdGhpcy5nZXRNZXRhVHJhbnNhY3Rpb25Ob25jZUFzeW5jKHRva2VuLCB0YWtlckFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIC8vIGdlbmVyYXRlIGNhbGxkYXRhIGZvciBhcHByb3ZlIHdpdGggbWF4IG51bWJlciBvZiB1aW50MjU2IGFzIGFtb3VudFxuICAgICAgICAgICAgICAgIGNvbnN0IGVyYzIwID0gbmV3IENvbnRyYWN0KHRva2VuLCBhYmlzLnBvbHlnb25CcmlkZ2VkRVJDMjAsIHRoaXMuX2V0aGVyc1Byb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IGFwcHJvdmVDYWxsZGF0YSB9ID0gYXdhaXQgZXJjMjAucG9wdWxhdGVUcmFuc2FjdGlvbi5hcHByb3ZlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9leGNoYW5nZVByb3h5QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzLk1heFVpbnQyNTYsXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25BcHByb3ZhbDogRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkFwcHJvdmFsID0ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHYXNsZXNzQXBwcm92YWxUeXBlcy5FeGVjdXRlTWV0YVRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBlaXA3MTI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZWlwNzEyRG9tYWluVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5FWEVDVVRFX01FVEFfVFJBTlNBQ1RJT05fRUlQXzcxMl9UWVBFUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VHlwZTogJ01ldGFUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IHRva2VuRUlQNzEyLmRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25jZTogbm9uY2UudG9OdW1iZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB0YWtlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25TaWduYXR1cmU6IGFwcHJvdmVDYWxsZGF0YSEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkFwcHJvdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHYXNsZXNzQXBwcm92YWxUeXBlcy5QZXJtaXQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBub25jZSA9IGF3YWl0IHRoaXMuZ2V0UGVybWl0Tm9uY2VBc3luYyh0b2tlbiwgdGFrZXJBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW5NaW51dGVzQWZ0ZXJOb3dTID0gbmV3IEJpZ051bWJlcihub3dNcyArIE9ORV9NSU5VVEVfTVMgKiAxMCkuZGl2KE9ORV9TRUNPTkRfTVMpLmludGVnZXJWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlcm1pdEFwcHJvdmFsOiBQZXJtaXRBcHByb3ZhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR2FzbGVzc0FwcHJvdmFsVHlwZXMuUGVybWl0LFxuICAgICAgICAgICAgICAgICAgICBlaXA3MTI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZWlwNzEyRG9tYWluVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5QRVJNSVRfRUlQXzcxMl9UWVBFUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VHlwZTogJ1Blcm1pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IHRva2VuRUlQNzEyLmRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogdGFrZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZW5kZXI6IHRoaXMuX2V4Y2hhbmdlUHJveHlBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb25zdGFudHMuTWF4VWludDI1Ni50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbmNlOiBub25jZS50b051bWJlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYWRsaW5lOiB0ZW5NaW51dGVzQWZ0ZXJOb3dTLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGVybWl0QXBwcm92YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR2FzbGVzcyBhcHByb3ZhbCBraW5kICR7dG9rZW5FSVA3MTIua2luZH0gaXMgbm90IGltcGxlbWVudGVkIHlldGApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhbW91bnQgKGluIGJhc2UgdW5pdCkgb2YgYHRva2VuYCBgc3BlbmRlcmAgd2lsbCBiZSBhbGxvd2VkIHRvIHNwZW5kIG9uIGJlaGFsZiBvbiBgb3duZXJgICh0aGUgYWxsb3dhbmNlKS4gTm90ZSB0aGF0XG4gICAgICogYmFzZSB1bml0IG1lYW5zIDEwICoqIGRlY2ltYWxzIChkZWNpbWFscyBvZiB0aGUgdG9rZW4pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSBhZGRyZXNzIG9mIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3duZXIgVGhlIGFkZHJlc3MgdGhhdCBvd25zIGNlcnRhaW4gYW1vdW50IG9mIGB0b2tlbmAuXG4gICAgICogQHBhcmFtIHNwZW5kZXIgVGhlIGFkZHJlc3MgdGhhdCB3b3VsZCBsaWtlIHRvIHNwZW5kIHRva2VuIG9uIGJlaGFsZiBvZiBgb3duZXJgLlxuICAgICAqIEByZXR1cm5zIFRoZSBhbW91bnQgKGluIGJhc2UgdW5pdCkgb2YgdG9rZW5zIHNwZW5kZXIgaXMgYWxsb3dlZCB0byBzcGVuZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0QWxsb3dhbmNlQXN5bmModG9rZW46IHN0cmluZywgb3duZXI6IHN0cmluZywgc3BlbmRlcjogc3RyaW5nKTogUHJvbWlzZTxCaWdOdW1iZXI+IHtcbiAgICAgICAgY29uc3QgZXJjMjAgPSBuZXcgQ29udHJhY3QodG9rZW4sIGFiaXMucG9seWdvbkJyaWRnZWRFUkMyMCwgdGhpcy5fZXRoZXJzUHJvdmlkZXIpO1xuICAgICAgICBjb25zdCBhbGxvd2FuY2UgPSBhd2FpdCBlcmMyMC5hbGxvd2FuY2Uob3duZXIsIHNwZW5kZXIpO1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihhbGxvd2FuY2UudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IG5vbmNlIGZvciBtZXRhIHRyYW5zYWN0aW9uLiBUaGlzIGlzIHVzZWQgYnkgY29udHJhY3RzIHRoYXQgc3VwcG9ydCBCaWNvbm9teSdzIGBleGVjdXRlTWV0YVRyYW5zYWN0aW9uYCB3aGljaCBpbmNsdWRlcyBicmlkZ2VkIHRva2VucyBvbiBQb2x5Z29uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSBhZGRyZXNzIG9mIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gdGFrZXJBZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoZSB0YWtlci5cbiAgICAgKiBAcmV0dXJucyBOb25jZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWV0YVRyYW5zYWN0aW9uTm9uY2VBc3luYyh0b2tlbjogc3RyaW5nLCB0YWtlckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8QmlnTnVtYmVyPiB7XG4gICAgICAgIGNvbnN0IGVyYzIwID0gbmV3IENvbnRyYWN0KHRva2VuLCBhYmlzLnBvbHlnb25CcmlkZ2VkRVJDMjAsIHRoaXMuX2V0aGVyc1Byb3ZpZGVyKTtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCBlcmMyMC5nZXROb25jZSh0YWtlckFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihub25jZS50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGVybWl0IG5vbmNlLCB3aGljaCBpcyB1c2VkIGJ5IGNvbnRyYWN0cyB0aGF0IHN1cHBvcnQgRUlQLTI2MTIgc3RhbmRhcmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSBhZGRyZXNzIG9mIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gdGFrZXJBZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoZSB0YWtlci5cbiAgICAgKiBAcmV0dXJucyBOb25jZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0UGVybWl0Tm9uY2VBc3luYyh0b2tlbjogc3RyaW5nLCB0YWtlckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8QmlnTnVtYmVyPiB7XG4gICAgICAgIGNvbnN0IGVyYzIwID0gbmV3IENvbnRyYWN0KHRva2VuLCBhYmlzLnBlcm1pdEVSQzIwLCB0aGlzLl9ldGhlcnNQcm92aWRlcik7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgZXJjMjAubm9uY2VzKHRha2VyQWRkcmVzcyk7XG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG5vbmNlLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBjYWxsZGF0YSBmb3IgZ2FzbGVzcyBhcHByb3ZhbCBzdWJtaXNzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSBhZGRyZXNzIG9mIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gYXBwcm92YWwgVGhlIEFwcHJvdmFsIG9iamVjdCwgd2hpY2ggY29uc2lzdHMgb2YgJ2tpbmQnIGFuZCBlaXA3MTIgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBzaWduYXR1cmUgVGhlIGdhc2xlc3MgYXBwcm92YWwgdHJhbnNhY3Rpb24gc2lnbmVkIGJ5IHRha2VyLlxuICAgICAqIEByZXR1cm5zIEdlbmVyYXRlZCBjYWxsZGF0YS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2VuZXJhdGVBcHByb3ZhbENhbGxkYXRhQXN5bmMoXG4gICAgICAgIHRva2VuOiBzdHJpbmcsXG4gICAgICAgIGFwcHJvdmFsOiBBcHByb3ZhbCxcbiAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUsXG4gICAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgeyBraW5kLCBlaXA3MTIgfSA9IGFwcHJvdmFsO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgR2FzbGVzc0FwcHJvdmFsVHlwZXMuRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyYzIwID0gbmV3IENvbnRyYWN0KHRva2VuLCBhYmlzLnBvbHlnb25CcmlkZ2VkRVJDMjAsIHRoaXMuX2V0aGVyc1Byb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGVyYzIwLnBvcHVsYXRlVHJhbnNhY3Rpb24uZXhlY3V0ZU1ldGFUcmFuc2FjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgZWlwNzEyLm1lc3NhZ2UuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZWlwNzEyLm1lc3NhZ2UuZnVuY3Rpb25TaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZS5yLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUucyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlLnYsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2VuZXJhdGUgYXBwcm92YWwgc3VibWlzc2lvbiBjYWxsZGF0YSBmb3IgJHtraW5kfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgR2FzbGVzc0FwcHJvdmFsVHlwZXMuUGVybWl0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJjMjAgPSBuZXcgQ29udHJhY3QodG9rZW4sIGFiaXMucGVybWl0RVJDMjAsIHRoaXMuX2V0aGVyc1Byb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGVyYzIwLnBvcHVsYXRlVHJhbnNhY3Rpb24ucGVybWl0KFxuICAgICAgICAgICAgICAgICAgICBlaXA3MTIubWVzc2FnZS5vd25lcixcbiAgICAgICAgICAgICAgICAgICAgZWlwNzEyLm1lc3NhZ2Uuc3BlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgZWlwNzEyLm1lc3NhZ2UudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGVpcDcxMi5tZXNzYWdlLmRlYWRsaW5lLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUudixcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlLnIsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZS5zLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGdlbmVyYXRlIGFwcHJvdmFsIHN1Ym1pc3Npb24gY2FsbGRhdGEgZm9yICR7a2luZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR2FzbGVzcyBhcHByb3ZhbCBraW5kICR7a2luZH0gaXMgbm90IGltcGxlbWVudGVkIHlldGApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmZxQmFsYW5jZUNoZWNrVXRpbHMge1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgX2JhbGFuY2VDaGVja2VyOiBCYWxhbmNlQ2hlY2tlciwgcHJpdmF0ZSByZWFkb25seSBfZXhjaGFuZ2VQcm94eUFkZHJlc3M6IHN0cmluZykge31cblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgbWluIHZhbHVlIGJldHdlZW4gYmFsYW5jZSBmb3IgYSBsaXN0IG9mIGFkZHJlc3NlcyBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgdG9rZW5zLiBUaGUgaW5kZXggb2ZcbiAgICAgKiBhbiBhZGRyZXNzIGluIGBhZGRyZXNzZXNgIG11c3QgY29ycmVzcG9uZCB3aXRoIHRoZSBpbmRleCBvZiBhIHRva2VuIGluIGB0b2tlbnNgLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKGVyYzIwT3duZXJzOiBFUkMyME93bmVyIHwgRVJDMjBPd25lcltdKTogUHJvbWlzZTxCaWdOdW1iZXJbXT4ge1xuICAgICAgICBjb25zdCB7IG93bmVycywgdG9rZW5zIH0gPSBzcGxpdEFkZHJlc3NlcyhlcmMyME93bmVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYWxhbmNlQ2hlY2tlci5nZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKG93bmVycywgdG9rZW5zLCB0aGlzLl9leGNoYW5nZVByb3h5QWRkcmVzcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgYmFsYW5jZXMgZm9yIGEgbGlzdCBvZiBhZGRyZXNzZXMgYWdhaW5zdCB0aGUgc3BlY2lmaWVkIHRva2Vucy4gVGhlIGluZGV4IG9mXG4gICAgICogYW4gYWRkcmVzcyBpbiBgYWRkcmVzc2VzYCBtdXN0IGNvcnJlc3BvbmQgd2l0aCB0aGUgaW5kZXggb2YgYSB0b2tlbiBpbiBgdG9rZW5zYC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0VG9rZW5CYWxhbmNlc0FzeW5jKGVyYzIwT3duZXJzOiBFUkMyME93bmVyIHwgRVJDMjBPd25lcltdKTogUHJvbWlzZTxCaWdOdW1iZXJbXT4ge1xuICAgICAgICBjb25zdCB7IG93bmVycywgdG9rZW5zIH0gPSBzcGxpdEFkZHJlc3NlcyhlcmMyME93bmVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYWxhbmNlQ2hlY2tlci5nZXRUb2tlbkJhbGFuY2VzQXN5bmMob3duZXJzLCB0b2tlbnMpO1xuICAgIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==