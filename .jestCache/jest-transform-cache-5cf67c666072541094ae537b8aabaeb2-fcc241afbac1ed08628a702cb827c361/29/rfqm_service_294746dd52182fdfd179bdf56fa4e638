7339d7dbf46de2ccf28d78119ecfe1b6
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RfqmService = void 0;
// tslint:disable:max-file-line-count
const api_utils_1 = require("@0x/api-utils");
const asset_swapper_1 = require("@0x/asset-swapper");
const protocol_utils_1 = require("@0x/protocol-utils");
const token_metadata_1 = require("@0x/token-metadata");
const utils_1 = require("@0x/utils");
const web3_wrapper_1 = require("@0x/web3-wrapper");
const attempt_1 = require("@lifeomic/attempt");
const _ = require("lodash");
const prom_client_1 = require("prom-client");
const config_1 = require("../config");
const constants_1 = require("../core/constants");
const types_1 = require("../entities/types");
const config_2 = require("../config");
const errors_1 = require("../core/errors");
const logger_1 = require("../logger");
const fee_utils_1 = require("../core/fee_utils");
const pair_utils_1 = require("../core/pair_utils");
const types_2 = require("../core/types");
const quote_comparison_utils_1 = require("../utils/quote_comparison_utils");
const quote_report_utils_1 = require("../utils/quote_report_utils");
const quote_server_client_1 = require("../utils/quote_server_client");
const rfqm_db_utils_1 = require("../utils/rfqm_db_utils");
const rfqm_health_check_1 = require("../utils/rfqm_health_check");
const signature_utils_1 = require("../utils/signature_utils");
const RFQM_QUOTE_INSERTED = new prom_client_1.Counter({
    name: 'rfqm_quote_inserted',
    help: 'An RfqmQuote was inserted in the DB',
    labelNames: ['apiKey', 'integratorId', 'makerUri'],
});
const RFQM_SIGNED_QUOTE_NOT_FOUND = new prom_client_1.Counter({
    name: 'rfqm_signed_quote_not_found',
    labelNames: ['chain_id'],
    help: 'A submitted quote did not match any stored quotes',
});
const RFQM_TAKER_AND_TAKERTOKEN_TRADE_EXISTS = new prom_client_1.Counter({
    name: 'rfqm_signed_quote_taker_and_takertoken_trade_exists',
    labelNames: ['chain_id'],
    help: 'A trade was submitted when the system already had a pending trade for the same taker and takertoken',
});
const RFQM_SUBMIT_BALANCE_CHECK_FAILED = new prom_client_1.Counter({
    name: 'rfqm_submit_balance_check_failed',
    labelNames: ['makerAddress', 'chain_id'],
    help: 'A trade was submitted but our on-chain balance check failed',
});
const RFQM_MAKER_BLOCKED_FOR_LLR_COOLDOWN = new prom_client_1.Counter({
    name: 'rfqm_maker_blocked_for_llr_cooldown',
    help: 'A maker get blocked because of LLR cooldown',
    labelNames: ['maker_id', 'chain_id', 'pair_key'],
});
const RFQM_MM_RETURNED_DIFFERENT_AMOUNT = new prom_client_1.Counter({
    name: 'rfqm_mm_returned_different_amount_total',
    help: 'A maker responded a quote with different amount than requested',
    labelNames: ['maker_uri', 'chain_id', 'modification_type'],
});
const PRICE_DECIMAL_PLACES = 6;
const getTokenAddressFromSymbol = (symbol, chainId) => {
    return (0, token_metadata_1.getTokenMetadataIfExists)(symbol, chainId).tokenAddress;
};
/**
 * RfqmService is the coordination layer for HTTP based RFQM flows.
 */
class RfqmService {
    constructor(_chainId, _feeService, _feeModelVersion, _contractAddresses, _registryAddress, _blockchainUtils, _dbUtils, _sqsProducer, _quoteServerClient, _minExpiryDurationMs, _cacheClient, _rfqMakerBalanceCacheService, _rfqMakerManager, _tokenMetadataManager, _kafkaProducer, _quoteReportTopic) {
        this._chainId = _chainId;
        this._feeService = _feeService;
        this._feeModelVersion = _feeModelVersion;
        this._contractAddresses = _contractAddresses;
        this._registryAddress = _registryAddress;
        this._blockchainUtils = _blockchainUtils;
        this._dbUtils = _dbUtils;
        this._sqsProducer = _sqsProducer;
        this._quoteServerClient = _quoteServerClient;
        this._minExpiryDurationMs = _minExpiryDurationMs;
        this._cacheClient = _cacheClient;
        this._rfqMakerBalanceCacheService = _rfqMakerBalanceCacheService;
        this._rfqMakerManager = _rfqMakerManager;
        this._tokenMetadataManager = _tokenMetadataManager;
        this._kafkaProducer = _kafkaProducer;
        this._quoteReportTopic = _quoteReportTopic;
        this._nativeTokenSymbol = (0, token_metadata_1.nativeTokenSymbol)(this._chainId);
        this._nativeTokenAddress = getTokenAddressFromSymbol(this._nativeTokenSymbol, this._chainId);
        this._nativeWrappedTokenSymbol = (0, token_metadata_1.nativeWrappedTokenSymbol)(this._chainId);
        this._nativeWrappedTokenAddress = getTokenAddressFromSymbol(this._nativeWrappedTokenSymbol, this._chainId);
    }
    static _getSellAmountGivenBuyAmountAndQuote(buyAmount, quotedTakerAmount, quotedMakerAmount) {
        // Solving for x given the following proportion:
        // x / buyAmount = quotedTakerAmount / quotedMakerAmount
        return quotedTakerAmount.div(quotedMakerAmount).times(buyAmount).decimalPlaces(0);
    }
    static _getBuyAmountGivenSellAmountAndQuote(sellAmount, quotedTakerAmount, quotedMakerAmount) {
        // Solving for y given the following proportion:
        // y / sellAmount =  quotedMakerAmount / quotedTakerAmount
        return quotedMakerAmount.div(quotedTakerAmount).times(sellAmount).decimalPlaces(0);
    }
    /**
     * Transform a transaction submission to type `TransactionDetails`.
     *
     * @returns Corresponding `TransactionDetails` or null if transaction hash is not available.
     */
    static _transformTransactionSubmission(transactionSubmission) {
        const { transactionHash: hash, createdAt } = transactionSubmission;
        return hash ? { hash, timestamp: createdAt.getTime() } : null;
    }
    /**
     * Get details of the successful transaction submission (there will only be one).
     *
     * @param opts Options object that contains:
     *             - `hash`: The hash of the order or metatransaction.
     *             - `type`: The type of the transaction submissions.
     *             - `transactionSubmssions`: List of transaction submissions to filter.
     * @returns The details (hash and timestamp) of the successful transaction submission.
     * @throws - When the number of the successful transaction submission is not 1
     *         - The successful transaction submission does not have transaction hash
     */
    static _getSuccessfulTransactionSubmissionDetails(opts) {
        const { hash, type, transactionSubmssions } = opts;
        const successfulTransactionSubmissions = transactionSubmssions.filter((s) => s.status === types_1.RfqmTransactionSubmissionStatus.SucceededUnconfirmed ||
            s.status === types_1.RfqmTransactionSubmissionStatus.SucceededConfirmed);
        if (successfulTransactionSubmissions.length !== 1) {
            throw new Error(`Expected exactly one successful transaction submission of type ${type} for hash ${hash}; found ${successfulTransactionSubmissions.length}`);
        }
        const successfulTransactionSubmission = successfulTransactionSubmissions[0];
        const successfulTransactionSubmissionDetails = this._transformTransactionSubmission(successfulTransactionSubmission);
        if (!successfulTransactionSubmissionDetails) {
            throw new Error(`Successful transaction of type ${type} does not have a hash ${hash}`);
        }
        return successfulTransactionSubmissionDetails;
    }
    static _jobFailureStatusToReason(failureStatus) {
        switch (failureStatus) {
            case types_1.RfqmJobStatus.FailedEthCallFailed:
                return types_1.JobFailureReason.TransactionSimulationFailed;
            case types_1.RfqmJobStatus.FailedExpired:
                return types_1.JobFailureReason.OrderExpired;
            case types_1.RfqmJobStatus.FailedLastLookDeclined:
                return types_1.JobFailureReason.LastLookDeclined;
            case types_1.RfqmJobStatus.FailedSignFailed:
                return types_1.JobFailureReason.MarketMakerSignatureError;
            case types_1.RfqmJobStatus.FailedRevertedConfirmed:
            case types_1.RfqmJobStatus.FailedRevertedUnconfirmed:
                return types_1.JobFailureReason.TransactionReverted;
            default:
                return types_1.JobFailureReason.InternalError;
        }
    }
    /**
     * Passthrough to TokenMetadataManager's `getTokenDecimalsAsync` method
     */
    async getTokenDecimalsAsync(tokenAddress) {
        return this._tokenMetadataManager.getTokenDecimalsAsync(tokenAddress);
    }
    /**
     * Fetch the best indicative quote available. Returns null if no valid quotes found
     */
    async fetchIndicativeQuoteAsync(params, extendedQuoteReportSubmissionBy = 'rfqm') {
        var _a;
        const affiliateAddress = (_a = params.affiliateAddress) !== null && _a !== void 0 ? _a : params.integrator.affiliateAddress;
        // Retrieve quote context
        const quoteContext = this._retrieveQuoteContext({ ...params, affiliateAddress }, /* isFirm */ false);
        const { isFirm, takerAmount, makerAmount, takerToken, makerToken, originalMakerToken, takerTokenDecimals, makerTokenDecimals, takerAddress, isSelling, assetFillAmount, integrator, } = quoteContext;
        // (Optimization) When `quotesWithGasFee` is returned, we can use this value and revise it, to avoid another fetch to MMs
        const { feeWithDetails, quotesWithGasFee, ammQuoteUniqueId } = await this._feeService.calculateFeeAsync(quoteContext, this._fetchIndicativeQuotesAsync.bind(this));
        // Calculate fees (other than gas fee) to charge MMs
        const otherFeesAmount = feeWithDetails.amount.minus(feeWithDetails.details.gasFeeAmount);
        const finalQuotes = quotesWithGasFee
            ? await this._feeService.reviseQuotesAsync(quotesWithGasFee, otherFeesAmount, quoteContext)
            : await this._fetchIndicativeQuotesAsync(quoteContext, feeWithDetails);
        // (Quote Report) If otherFees > 0, then we "revised" the quotes from MMs. We want to save both the original quotes (aka intermediateQuotes) and the revised (finalQuotes)
        const intermediateQuotes = quotesWithGasFee && otherFeesAmount.gt(protocol_utils_1.ZERO) ? quotesWithGasFee : [];
        // Get the best quote
        const bestQuote = (0, quote_comparison_utils_1.getBestQuote)(finalQuotes, isSelling, takerToken, makerToken, assetFillAmount, this._minExpiryDurationMs);
        const isLiquidityAvailable = bestQuote !== null;
        // Quote Report
        if (this._kafkaProducer) {
            await quote_report_utils_1.quoteReportUtils.publishRFQMQuoteReportAsync({
                isFirmQuote: isFirm,
                taker: takerAddress,
                buyTokenAddress: originalMakerToken,
                sellTokenAddress: takerToken,
                buyAmount: makerAmount,
                sellAmount: takerAmount,
                integratorId: integrator === null || integrator === void 0 ? void 0 : integrator.integratorId,
                finalQuotes,
                intermediateQuotes,
                bestQuote,
                fee: (0, fee_utils_1.feeToStoredFee)(feeWithDetails),
                ammQuoteUniqueId,
                isLiquidityAvailable,
            }, this._kafkaProducer, this._quoteReportTopic, extendedQuoteReportSubmissionBy);
        }
        // No quotes found
        if (!isLiquidityAvailable) {
            return null;
        }
        // Prepare the price
        const makerAmountInUnit = web3_wrapper_1.Web3Wrapper.toUnitAmount(bestQuote.makerAmount, makerTokenDecimals);
        const takerAmountInUnit = web3_wrapper_1.Web3Wrapper.toUnitAmount(bestQuote.takerAmount, takerTokenDecimals);
        const price = isSelling ? makerAmountInUnit.div(takerAmountInUnit) : takerAmountInUnit.div(makerAmountInUnit);
        // The way the BigNumber round down behavior (https://mikemcl.github.io/bignumber.js/#dp) works requires us
        // to add 1 to PRICE_DECIMAL_PLACES in order to actually come out with the decimal places specified.
        const roundedPrice = price.decimalPlaces(PRICE_DECIMAL_PLACES + 1, utils_1.BigNumber.ROUND_DOWN);
        // Prepare response
        return {
            price: roundedPrice,
            gas: feeWithDetails.details.gasPrice,
            buyAmount: bestQuote.makerAmount,
            buyTokenAddress: originalMakerToken,
            sellAmount: bestQuote.takerAmount,
            sellTokenAddress: bestQuote.takerToken,
            allowanceTarget: this._contractAddresses.exchangeProxy,
        };
    }
    /**
     * Fetch the best firm quote available, including a metatransaction. Returns null if no valid quotes found
     */
    async fetchFirmQuoteAsync(params, extendedQuoteReportSubmissionBy = 'rfqm') {
        var _a;
        const affiliateAddress = (_a = params.affiliateAddress) !== null && _a !== void 0 ? _a : params.integrator.affiliateAddress;
        // Retrieve quote context
        const quoteContext = this._retrieveQuoteContext({ ...params, affiliateAddress }, /* isFirm */ true);
        const { isFirm, takerAmount, makerAmount, takerToken, makerToken, originalMakerToken, takerTokenDecimals, makerTokenDecimals, takerAddress, integrator, isUnwrap, isSelling, assetFillAmount, } = quoteContext;
        // (Optimization) When `quotesWithGasFee` is returned, we can sometimes reuse it, to avoid another fetch to MMs
        // NOTE: this optimization differs from the optimization for indicative quotes because we do NOT revise firm quotes
        const { feeWithDetails, quotesWithGasFee, ammQuoteUniqueId } = await this._feeService.calculateFeeAsync(quoteContext, this._fetchIndicativeQuotesAsync.bind(this));
        // Calculate fees (other than gas fee) to charge MMs. If there are other fees, we don't reuse `quotesWithGasFee`
        const otherFeesAmount = feeWithDetails.amount.minus(feeWithDetails.details.gasFeeAmount);
        // If `quotesWithGasFee` have been obtained and there are no other fees, reuse the quotes. Otherwise call MMs with full fee to get new quotes.
        const finalQuotes = quotesWithGasFee && otherFeesAmount.eq(protocol_utils_1.ZERO)
            ? await this._convertToFirmQuotesAsync(quotesWithGasFee, quoteContext)
            : await this._fetchFirmQuotesAsync(quoteContext, feeWithDetails);
        // (Quote Report) If `quotesWithGasFee` have not been reused, save them as intermediate quotes
        const intermediateQuotes = quotesWithGasFee && otherFeesAmount.gt(protocol_utils_1.ZERO) ? quotesWithGasFee : [];
        // (Maker Balance Cache) Fetch maker balances to validate whether quotes are fully fillable
        let quotedMakerBalances;
        const quotedERC20Owners = finalQuotes.map((quote) => {
            return {
                owner: quote.order.maker,
                token: makerToken,
            };
        });
        try {
            quotedMakerBalances = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(this._chainId, quotedERC20Owners);
        }
        catch (e) {
            logger_1.logger.error({ chainId: this._chainId, quotedERC20Owners, errorMessage: e.message }, 'Failed to fetch maker balances to validate firm quotes');
        }
        // Get the best quote
        const bestQuote = (0, quote_comparison_utils_1.getBestQuote)(finalQuotes, isSelling, takerToken, makerToken, assetFillAmount, this._minExpiryDurationMs, quotedMakerBalances);
        const isLiquidityAvailable = bestQuote !== null;
        const storedFeeWithDetails = (0, fee_utils_1.feeToStoredFee)(feeWithDetails);
        let quoteReportId = null;
        // Quote Report
        if (this._kafkaProducer) {
            quoteReportId = await quote_report_utils_1.quoteReportUtils.publishRFQMQuoteReportAsync({
                isFirmQuote: isFirm,
                taker: takerAddress,
                buyTokenAddress: originalMakerToken,
                sellTokenAddress: takerToken,
                buyAmount: makerAmount,
                sellAmount: takerAmount,
                integratorId: integrator === null || integrator === void 0 ? void 0 : integrator.integratorId,
                finalQuotes,
                intermediateQuotes,
                bestQuote,
                fee: storedFeeWithDetails,
                ammQuoteUniqueId,
                isLiquidityAvailable,
            }, this._kafkaProducer, this._quoteReportTopic, extendedQuoteReportSubmissionBy);
        }
        // No quote found
        if (!isLiquidityAvailable) {
            return { quote: null, quoteReportId };
        }
        // Get the makerUri
        const makerUri = bestQuote.makerUri;
        if (makerUri === undefined) {
            logger_1.logger.error({ makerAddress: bestQuote.order.maker }, 'makerUri unknown for maker address');
            throw new Error(`makerUri unknown for maker address ${bestQuote.order.maker}`);
        }
        // Prepare the price
        const makerAmountInUnit = web3_wrapper_1.Web3Wrapper.toUnitAmount(bestQuote.order.makerAmount, makerTokenDecimals);
        const takerAmountInUnit = web3_wrapper_1.Web3Wrapper.toUnitAmount(bestQuote.order.takerAmount, takerTokenDecimals);
        const price = isSelling ? makerAmountInUnit.div(takerAmountInUnit) : takerAmountInUnit.div(makerAmountInUnit);
        // The way the BigNumber round down behavior (https://mikemcl.github.io/bignumber.js/#dp) works requires us
        // to add 1 to PRICE_DECIMAL_PLACES in order to actually come out with the decimal places specified.
        const roundedPrice = price.decimalPlaces(PRICE_DECIMAL_PLACES + 1, utils_1.BigNumber.ROUND_DOWN);
        // Prepare the final takerAmount and makerAmount
        const sellAmount = isSelling
            ? // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                takerAmount
            : RfqmService._getSellAmountGivenBuyAmountAndQuote(
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            makerAmount, bestQuote.order.takerAmount, bestQuote.order.makerAmount);
        const buyAmount = isSelling
            ? RfqmService._getBuyAmountGivenSellAmountAndQuote(
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            takerAmount, bestQuote.order.takerAmount, bestQuote.order.makerAmount)
            : // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                makerAmount;
        // Get the Order and its hash
        const orderHash = bestQuote.order.getHash();
        const otcOrder = bestQuote.order;
        await this._dbUtils.writeV2QuoteAsync({
            orderHash,
            chainId: this._chainId,
            fee: storedFeeWithDetails,
            order: (0, rfqm_db_utils_1.otcOrderToStoredOtcOrder)(otcOrder),
            makerUri,
            affiliateAddress,
            integratorId: integrator.integratorId,
            isUnwrap,
            takerSpecifiedSide: params.sellAmount ? 'takerToken' : 'makerToken',
        });
        const approval = params.checkApproval
            ? // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                await this.getGaslessApprovalResponseAsync(takerAddress, takerToken, sellAmount)
            : null;
        RFQM_QUOTE_INSERTED.labels(integrator.integratorId, integrator.integratorId, makerUri).inc();
        return {
            quote: {
                type: types_2.GaslessTypes.OtcOrder,
                price: roundedPrice,
                gas: feeWithDetails.details.gasPrice,
                buyAmount,
                buyTokenAddress: originalMakerToken,
                sellAmount,
                sellTokenAddress: bestQuote.order.takerToken,
                allowanceTarget: this._contractAddresses.exchangeProxy,
                order: bestQuote.order,
                orderHash,
                // use approval variable directly is not ideal as we don't want to include approval field if `approval` is null
                ...(approval && { approval }),
            },
            quoteReportId,
        };
    }
    /**
     * Get the value of the approval response in firm quote responses. The approval response contains whether an approval is required, is gasless approval
     * is available for the token (optional), the type of the gasless approval (optional) and the EIP712 context (optional).
     *
     * @param takerAddress The address of the taker.
     * @param tokenToApprove Token address to be approved.
     * @param sellAmount Amount of token to sell in base unit.
     * @returns The approval response.
     */
    async getGaslessApprovalResponseAsync(takerAddress, tokenToApprove, sellAmount) {
        const allowance = await this._blockchainUtils.getAllowanceAsync(tokenToApprove, takerAddress, this._blockchainUtils.getExchangeProxyAddress());
        const isRequired = allowance.lte(sellAmount);
        if (!isRequired) {
            return {
                isRequired,
            };
        }
        const gaslessApproval = await this._blockchainUtils.getGaslessApprovalAsync(this._chainId, tokenToApprove, takerAddress);
        const isGaslessAvailable = gaslessApproval !== null;
        if (!isGaslessAvailable) {
            return {
                isRequired,
                isGaslessAvailable,
            };
        }
        return {
            isRequired,
            isGaslessAvailable,
            type: gaslessApproval.kind,
            eip712: gaslessApproval.eip712,
        };
    }
    async getStatusAsync(tradeHash) {
        const transformSubmissions = (submissions) => {
            // `_transformTransactionSubmission` is a static method so no-unbound-method does not apply here
            // tslint:disable-next-line:no-unbound-method
            return submissions.map(RfqmService._transformTransactionSubmission).flatMap((s) => (s ? s : []));
        };
        const job = await Promise.all([
            this._dbUtils.findV2JobByOrderHashAsync(tradeHash),
            this._dbUtils.findMetaTransactionJobByMetaTransactionHashAsync(tradeHash),
        ]).then((jobs) => jobs.find((x) => x));
        if (!job) {
            return null;
        }
        const { status, expiry } = job;
        if (status === types_1.RfqmJobStatus.PendingEnqueued && expiry.multipliedBy(constants_1.ONE_SECOND_MS).lt(Date.now())) {
            // the workers are dead/on vacation and the expiration time has passed
            return {
                status: 'failed',
                transactions: [],
                ...(config_2.REASON_ON_STATUS_ERROR_RESPONSE_ENABLED && {
                    reason: types_1.JobFailureReason.OrderExpired,
                }),
            };
        }
        const tradeTransactionSubmissions = job.kind === 'rfqm_v2_job'
            ? await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(job.orderHash, types_1.RfqmTransactionSubmissionType.Trade)
            : await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(job.id, types_1.RfqmTransactionSubmissionType.Trade);
        const shouldIncludeApproval = !!job.approval;
        let approvalTransactionSubmissions = [];
        if (shouldIncludeApproval) {
            approvalTransactionSubmissions =
                job.kind === 'rfqm_v2_job'
                    ? await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(job.orderHash, types_1.RfqmTransactionSubmissionType.Approval)
                    : await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(job.id, types_1.RfqmTransactionSubmissionType.Approval);
        }
        switch (status) {
            case types_1.RfqmJobStatus.PendingEnqueued:
            case types_1.RfqmJobStatus.PendingProcessing:
            case types_1.RfqmJobStatus.PendingLastLookAccepted:
                return { status: 'pending', transactions: [] };
            case types_1.RfqmJobStatus.PendingSubmitted:
                return {
                    status: 'submitted',
                    transactions: transformSubmissions(tradeTransactionSubmissions),
                    ...(shouldIncludeApproval && {
                        approvalTransactions: transformSubmissions(approvalTransactionSubmissions),
                    }),
                };
            case types_1.RfqmJobStatus.FailedEthCallFailed:
            case types_1.RfqmJobStatus.FailedExpired:
            case types_1.RfqmJobStatus.FailedLastLookDeclined:
            case types_1.RfqmJobStatus.FailedPresignValidationFailed:
            case types_1.RfqmJobStatus.FailedRevertedConfirmed:
            case types_1.RfqmJobStatus.FailedRevertedUnconfirmed:
            case types_1.RfqmJobStatus.FailedSignFailed:
            case types_1.RfqmJobStatus.FailedSubmitFailed:
            case types_1.RfqmJobStatus.FailedValidationNoCallData:
            case types_1.RfqmJobStatus.FailedValidationNoFee:
            case types_1.RfqmJobStatus.FailedValidationNoMakerUri:
            case types_1.RfqmJobStatus.FailedValidationNoOrder:
            case types_1.RfqmJobStatus.FailedValidationNoTakerSignature:
                return {
                    status: 'failed',
                    transactions: transformSubmissions(tradeTransactionSubmissions),
                    ...(shouldIncludeApproval && {
                        approvalTransactions: transformSubmissions(approvalTransactionSubmissions),
                    }),
                    ...(config_2.REASON_ON_STATUS_ERROR_RESPONSE_ENABLED && {
                        reason: RfqmService._jobFailureStatusToReason(status),
                    }),
                };
            case types_1.RfqmJobStatus.SucceededConfirmed:
            case types_1.RfqmJobStatus.SucceededUnconfirmed:
                return {
                    status: status === types_1.RfqmJobStatus.SucceededUnconfirmed ? 'succeeded' : 'confirmed',
                    transactions: [
                        RfqmService._getSuccessfulTransactionSubmissionDetails({
                            hash: job.getHash(),
                            type: types_1.RfqmTransactionSubmissionType.Trade,
                            transactionSubmssions: tradeTransactionSubmissions,
                        }),
                    ],
                    ...(shouldIncludeApproval && {
                        approvalTransactions: [
                            RfqmService._getSuccessfulTransactionSubmissionDetails({
                                hash: job.getHash(),
                                type: types_1.RfqmTransactionSubmissionType.Approval,
                                transactionSubmssions: approvalTransactionSubmissions,
                            }),
                        ],
                    }),
                };
            default:
                ((_x) => {
                    throw new Error('Unreachable');
                })(status);
        }
    }
    /**
     * Runs checks to determine the health of the RFQm system. The results may be distilled to a format needed by integrators.
     */
    async runHealthCheckAsync() {
        const heartbeats = await this._dbUtils.findRfqmWorkerHeartbeatsAsync(this._chainId);
        let gasPrice;
        try {
            gasPrice = await this._feeService.getGasPriceEstimationAsync();
        }
        catch (error) {
            logger_1.logger.warn({ errorMessage: error.message }, 'Failed to get gas price for health check');
        }
        return (0, rfqm_health_check_1.computeHealthCheckAsync)(config_1.RFQM_MAINTENANCE_MODE, this._rfqMakerManager.getRfqmV2MakerOfferings(), this._sqsProducer, heartbeats, this._chainId, gasPrice);
    }
    /**
     * Validates and enqueues the Taker Signed Otc Order with approval for submission.
     * Can also be used to submit order without approval if approval params are not supplied.
     */
    async submitTakerSignedOtcOrderWithApprovalAsync(params) {
        let submitRfqmSignedQuoteWithApprovalRes;
        const { approval, trade } = params;
        const rfqmApprovalOpts = approval
            ? await this.createApprovalAsync(approval, trade.order.getHash(), trade.order.takerToken)
            : undefined;
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line prefer-const
        submitRfqmSignedQuoteWithApprovalRes = await this.submitTakerSignedOtcOrderAsync(trade, rfqmApprovalOpts);
        return submitRfqmSignedQuoteWithApprovalRes;
    }
    /**
     * Processes a signed approval sent to the submission endpoint in order to
     * create the approval data needed by the job.
     */
    async createApprovalAsync(approval, tradeHash, takerToken) {
        let { signature } = approval;
        // validate and convert EIP712 context to corresponding Approval object
        const parsedApproval = this._convertEIP712ContextToApproval(approval.eip712, tradeHash);
        // pad approval signature if there are missing bytes
        const paddedSignature = (0, signature_utils_1.padSignature)(signature);
        if (paddedSignature.r !== signature.r || paddedSignature.s !== signature.s) {
            logger_1.logger.warn({ tradeHash, r: paddedSignature.r, s: paddedSignature.s }, 'Got approval signature with missing bytes');
            signature = paddedSignature;
        }
        // perform an eth_call on the approval object and signature
        try {
            const approvalCalldata = await this._blockchainUtils.generateApprovalCalldataAsync(takerToken, parsedApproval, signature);
            await (0, attempt_1.retry)(async () => {
                // Use `estimateGasForAsync` to simulate the transaction. In ethers.js, provider.call and
                // provider.send('eth_call', ...) might not throw exception and the behavior might be dependent
                // on providers. Revisit this later
                return this._blockchainUtils.estimateGasForAsync({ to: takerToken, data: approvalCalldata });
            }, {
                delay: constants_1.ONE_SECOND_MS,
                factor: 1,
                maxAttempts: 3,
                handleError: (error, context, _options) => {
                    const { attemptNum: attemptNumber, attemptsRemaining } = context;
                    logger_1.logger.warn({
                        attemptNumber,
                        attemptsRemaining,
                        errorMessage: error.message,
                        stack: error.stack,
                        tradeHash,
                    }, 'Error during eth_call approval validation. Retrying.');
                },
            });
        }
        catch (error) {
            logger_1.logger.error({ errorMessage: error.message }, 'Eth call approval validation failed');
            throw new Error('Eth call approval validation failed');
        }
        return {
            approval: parsedApproval,
            approvalSignature: signature,
        };
    }
    /**
     * Validates and enqueues the Taker Signed Otc Order for submission
     */
    async submitTakerSignedOtcOrderAsync(params, rfqmApprovalOpts) {
        const { order } = params;
        let { signature: takerSignature } = params;
        const orderHash = order.getHash();
        const takerAddress = order.taker.toLowerCase();
        const makerAddress = order.maker.toLowerCase();
        const takerToken = order.takerToken.toLowerCase();
        const makerToken = order.makerToken.toLowerCase();
        // check that the orderHash is indeed a recognized quote
        const quote = await this._dbUtils.findV2QuoteByOrderHashAsync(orderHash);
        if (!quote) {
            RFQM_SIGNED_QUOTE_NOT_FOUND.inc();
            throw new errors_1.NotFoundError('quote not found');
        }
        // validate that the expiration window is long enough to fill quote
        const currentTimeMs = new Date().getTime();
        if (!order.expiry.times(constants_1.ONE_SECOND_MS).isGreaterThan(currentTimeMs + this._minExpiryDurationMs)) {
            throw new errors_1.ValidationError([
                {
                    field: 'expiryAndNonce',
                    code: errors_1.ValidationErrorCodes.FieldInvalid,
                    reason: `order will expire too soon`,
                },
            ]);
        }
        // validate that there is not a pending transaction for this taker and taker token
        const pendingJobs = await this._dbUtils.findV2JobsWithStatusesAsync([
            types_1.RfqmJobStatus.PendingEnqueued,
            types_1.RfqmJobStatus.PendingProcessing,
            types_1.RfqmJobStatus.PendingLastLookAccepted,
            types_1.RfqmJobStatus.PendingSubmitted,
        ]);
        if (pendingJobs.some((job) => {
            var _a, _b, _c, _d;
            return ((_a = job.order) === null || _a === void 0 ? void 0 : _a.order.taker.toLowerCase()) === ((_b = quote.order) === null || _b === void 0 ? void 0 : _b.order.taker.toLowerCase()) &&
                ((_c = job.order) === null || _c === void 0 ? void 0 : _c.order.takerToken.toLowerCase()) === ((_d = quote.order) === null || _d === void 0 ? void 0 : _d.order.takerToken.toLowerCase()) &&
                // Other logic handles the case where the same order is submitted twice
                job.orderHash !== quote.orderHash;
        })) {
            RFQM_TAKER_AND_TAKERTOKEN_TRADE_EXISTS.labels(this._chainId.toString()).inc();
            throw new api_utils_1.TooManyRequestsError('a pending trade for this taker and takertoken already exists');
        }
        // In the unlikely event that takers submit a signature with a missing byte, pad the signature.
        const paddedSignature = (0, signature_utils_1.padSignature)(takerSignature);
        if (paddedSignature.r !== takerSignature.r || paddedSignature.s !== takerSignature.s) {
            logger_1.logger.warn({ orderHash, r: paddedSignature.r, s: paddedSignature.s }, 'Got taker signature with missing bytes');
            takerSignature = paddedSignature;
        }
        // validate that the given taker signature is valid
        const signerAddress = (0, signature_utils_1.getSignerFromHash)(orderHash, takerSignature).toLowerCase();
        if (signerAddress !== takerAddress) {
            logger_1.logger.warn({ signerAddress, takerAddress, orderHash }, 'Signature is invalid');
            throw new errors_1.ValidationError([
                {
                    field: 'signature',
                    code: errors_1.ValidationErrorCodes.InvalidSignatureOrHash,
                    reason: `signature is not valid`,
                },
            ]);
        }
        // Validate that order is fillable by both the maker and the taker according to balances and/or allowances.
        // If rfqmApprovalOpts is not passed, allowances are not checked at this stage since gasless approval has not been done yet.
        const [makerBalance] = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(this._chainId, [
            {
                owner: makerAddress,
                token: makerToken,
            },
        ]);
        const [takerBalance] = rfqmApprovalOpts
            ? await this._blockchainUtils.getTokenBalancesAsync({ owner: takerAddress, token: takerToken })
            : await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync({
                owner: takerAddress,
                token: takerToken,
            });
        if (makerBalance.lt(order.makerAmount) || takerBalance.lt(order.takerAmount)) {
            RFQM_SUBMIT_BALANCE_CHECK_FAILED.labels(makerAddress, this._chainId.toString()).inc();
            logger_1.logger.warn({
                makerBalance,
                takerBalance,
                makerAddress,
                takerAddress,
                orderHash,
                order,
            }, 'Balance check failed while user was submitting');
            throw new errors_1.ValidationError([
                {
                    field: 'n/a',
                    code: errors_1.ValidationErrorCodes.InvalidOrder,
                    reason: `order is not fillable`,
                },
            ]);
        }
        // prepare the job
        let rfqmJobOpts = {
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            orderHash: quote.orderHash,
            createdAt: new Date(),
            expiry: order.expiry,
            chainId: this._chainId,
            integratorId: quote.integratorId ? quote.integratorId : null,
            makerUri: quote.makerUri,
            status: types_1.RfqmJobStatus.PendingEnqueued,
            fee: quote.fee,
            order: quote.order,
            takerSignature,
            affiliateAddress: quote.affiliateAddress,
            isUnwrap: quote.isUnwrap,
            takerSpecifiedSide: quote.takerSpecifiedSide,
        };
        // if approval opts are supplied, add params to job table
        if (rfqmApprovalOpts) {
            rfqmJobOpts = {
                ...rfqmJobOpts,
                ...rfqmApprovalOpts,
            };
        }
        // this insert will fail if a job has already been created, ensuring
        // that a signed quote cannot be queued twice
        try {
            // make sure job data is persisted to Postgres before queueing task
            await this._dbUtils.writeV2JobAsync(rfqmJobOpts);
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            await this._enqueueJobAsync(quote.orderHash, types_2.GaslessTypes.OtcOrder);
        }
        catch (error) {
            logger_1.logger.error({ errorMessage: error.message }, 'Failed to queue the quote for submission.');
            throw new errors_1.InternalServerError(`failed to queue the quote for submission, it may have already been submitted`);
        }
        return {
            type: types_2.GaslessTypes.OtcOrder,
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            orderHash: quote.orderHash,
        };
    }
    /**
     * Internal method to retrieve quote context, based on either indicative or firm quote parameters
     */
    _retrieveQuoteContext(params, isFirm) {
        const { sellAmount: takerAmount, buyAmount: makerAmount, sellToken: takerToken, buyToken: originalMakerToken, takerAddress, sellTokenDecimals: takerTokenDecimals, buyTokenDecimals: makerTokenDecimals, integrator, affiliateAddress, } = params;
        const isUnwrap = originalMakerToken === this._nativeTokenAddress;
        const isSelling = takerAmount !== undefined;
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const assetFillAmount = isSelling ? takerAmount : makerAmount;
        let makerToken = originalMakerToken;
        // If the originalMakerToken is the native token, we will trade the wrapped version and unwrap at the end
        if (isUnwrap) {
            makerToken = this._nativeWrappedTokenAddress;
        }
        return {
            workflow: 'rfqm',
            chainId: this._chainId,
            isFirm,
            takerAmount,
            makerAmount,
            takerToken,
            makerToken,
            originalMakerToken,
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            takerAddress: takerAddress,
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            trader: takerAddress,
            txOrigin: this._registryAddress,
            takerTokenDecimals,
            makerTokenDecimals,
            integrator,
            affiliateAddress,
            isUnwrap,
            isSelling,
            assetFillAmount,
            feeModelVersion: this._feeModelVersion,
        };
    }
    /**
     * Internal method to fetch indicative quotes.
     */
    async _fetchIndicativeQuotesAsync(quoteContext, fee) {
        // Extract quote context
        const { isSelling, assetFillAmount, takerToken, makerToken, integrator } = quoteContext;
        // Create Otc Order request options
        const otcOrderParams = quote_server_client_1.QuoteServerClient.makeQueryParameters({
            chainId: this._chainId,
            txOrigin: this._registryAddress,
            takerAddress: constants_1.NULL_ADDRESS,
            marketOperation: isSelling ? asset_swapper_1.MarketOperation.Sell : asset_swapper_1.MarketOperation.Buy,
            buyTokenAddress: makerToken,
            sellTokenAddress: takerToken,
            assetFillAmount,
            isLastLook: true,
            fee,
        });
        // If LLR Cooldown is enabled, filter out makers in cooldown before querying the quote server
        let makerIdsInCooldown;
        if (config_1.ENABLE_LLR_COOLDOWN) {
            try {
                makerIdsInCooldown = await this._cacheClient.getMakersInCooldownForPairAsync(this._chainId, makerToken, takerToken);
                // log blocked maker ids
                makerIdsInCooldown.map((makerId) => {
                    RFQM_MAKER_BLOCKED_FOR_LLR_COOLDOWN.labels(makerId, this._chainId.toString(), (0, pair_utils_1.toPairString)(makerToken, takerToken)).inc();
                    logger_1.logger.warn({
                        makerId,
                        makerToken,
                        takerToken,
                        timestamp: Date.now(),
                    }, 'Maker is on cooldown due to a bad last look reject');
                });
            }
            catch (e) {
                logger_1.logger.error({ chainId: this._chainId, makerToken, takerToken, errorMessage: e.message }, 'Encountered an error while filtering makers on LLR cooldown');
            }
        }
        const otcOrderMakerUris = this._rfqMakerManager.getRfqmV2MakerUrisForPair(makerToken, takerToken, integrator.whitelistMakerIds || null, makerIdsInCooldown || null);
        const quotes = await this._quoteServerClient.batchGetPriceV2Async(otcOrderMakerUris, integrator, otcOrderParams);
        // Log any quotes that are for the incorrect amount
        quotes.forEach((quote) => {
            const quotedAmount = isSelling ? quote.takerAmount : quote.makerAmount;
            if (quotedAmount.eq(assetFillAmount)) {
                return;
            }
            const modificationType = quotedAmount.gt(assetFillAmount) ? 'overfill' : 'underfill';
            logger_1.logger.warn({
                isSelling,
                overOrUnder: modificationType,
                requestedAmount: assetFillAmount,
                quotedAmount,
                quote,
            }, 'Maker returned an incorrect amount');
            RFQM_MM_RETURNED_DIFFERENT_AMOUNT.labels(quote.makerUri, this._chainId.toString(), modificationType).inc();
        });
        return quotes;
    }
    /**
     * Internal method to fetch firm quotes.
     */
    async _fetchFirmQuotesAsync(quoteContext, fee) {
        const quotes = await this._fetchIndicativeQuotesAsync(quoteContext, fee);
        return this._convertToFirmQuotesAsync(quotes, quoteContext);
    }
    /**
     * Internal method to convert indicative quotes to firm quotes.
     */
    async _convertToFirmQuotesAsync(quotes, quoteContext) {
        const { takerAddress } = quoteContext;
        const currentBucket = (await this._cacheClient.getNextOtcOrderBucketAsync(this._chainId)) % constants_1.RFQM_NUM_BUCKETS;
        const nowSeconds = Math.floor(Date.now() / constants_1.ONE_SECOND_MS);
        const otcQuotes = quotes.map((q) => this._mapIndicativeQuoteToFirmOtcQuote(q, 
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        takerAddress, new utils_1.BigNumber(currentBucket), new utils_1.BigNumber(nowSeconds)));
        const firmQuotesWithCorrectChainId = otcQuotes.filter((quote) => {
            if (quote.order.chainId !== this._chainId) {
                logger_1.logger.error({ quote }, 'Received a quote with incorrect chain id');
                return false;
            }
            return true;
        });
        return firmQuotesWithCorrectChainId;
    }
    async _enqueueJobAsync(orderHash, type) {
        await this._sqsProducer.send({
            // wait, it's all order hash?
            // always has been.
            groupId: orderHash,
            id: orderHash,
            body: JSON.stringify({ orderHash, type }),
            deduplicationId: orderHash,
        });
    }
    /**
     * Maps an IndicativeQuote to a FirmOtcQuote. Handles txOrigin, chainId, expiryAndNonce, etc
     */
    _mapIndicativeQuoteToFirmOtcQuote(q, takerAddress, nonceBucket, nonce) {
        return {
            kind: 'otc',
            makerUri: q.makerUri,
            order: new protocol_utils_1.OtcOrder({
                txOrigin: this._registryAddress,
                expiryAndNonce: protocol_utils_1.OtcOrder.encodeExpiryAndNonce(q.expiry, nonceBucket, nonce),
                maker: q.maker,
                taker: takerAddress,
                makerToken: q.makerToken,
                takerToken: q.takerToken,
                makerAmount: q.makerAmount,
                takerAmount: q.takerAmount,
                chainId: this._chainId,
                verifyingContract: this._contractAddresses.exchangeProxy,
            }),
        };
    }
    /**
     * Validates and converts EIP-712 context to an Approval object.
     * @param kind Type of gasless approval
     * @param eip712 EIP-712 context parsed from the handler
     * @param tradeHash The order hash or metatransaction hash,
     *  only used for logging in case of validation error
     * @returns The Approval object
     */
    // tslint:disable-next-line: prefer-function-over-method
    _convertEIP712ContextToApproval(eip712, tradeHash) {
        const { types, primaryType, domain, message } = eip712;
        switch (primaryType) {
            case 'MetaTransaction': {
                if (!_.isEqual(_.keys(message).sort(), types.MetaTransaction.map((dataField) => dataField.name).sort())) {
                    logger_1.logger.warn({ primaryType, tradeHash }, 'Invalid message field provided for Approval');
                    throw new errors_1.ValidationError([
                        {
                            field: 'message',
                            code: errors_1.ValidationErrorCodes.FieldInvalid,
                            reason: `Invalid message field provided for Approval of primaryType ${primaryType}`,
                        },
                    ]);
                }
                const executeMetaTransactionApproval = {
                    kind: types_2.GaslessApprovalTypes.ExecuteMetaTransaction,
                    eip712: {
                        types,
                        primaryType,
                        domain,
                        message: {
                            nonce: message.nonce,
                            from: message.from,
                            functionSignature: message.functionSignature,
                        },
                    },
                };
                return executeMetaTransactionApproval;
            }
            case 'Permit': {
                if (!_.isEqual(_.keys(message).sort(), types.Permit.map((dataField) => dataField.name).sort())) {
                    logger_1.logger.warn({ primaryType, tradeHash }, 'Invalid message field provided for Approval');
                    throw new errors_1.ValidationError([
                        {
                            field: 'message',
                            code: errors_1.ValidationErrorCodes.FieldInvalid,
                            reason: `Invalid message field provided for Approval of primaryType ${primaryType}`,
                        },
                    ]);
                }
                const permitApproval = {
                    kind: types_2.GaslessApprovalTypes.Permit,
                    eip712: {
                        types,
                        primaryType,
                        domain,
                        message: {
                            owner: message.owner,
                            spender: message.spender,
                            value: message.value,
                            nonce: message.nonce,
                            deadline: message.deadline,
                        },
                    },
                };
                return permitApproval;
            }
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(primaryType);
        }
    }
}
exports.RfqmService = RfqmService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9zZXJ2aWNlcy9yZnFtX3NlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEscUNBQXFDO0FBQ3JDLDZDQUFxRDtBQUNyRCxxREFBbUY7QUFDbkYsdURBQW9EO0FBQ3BELHVEQUs0QjtBQUM1QixxQ0FBc0M7QUFDdEMsbURBQStDO0FBQy9DLCtDQUEwQztBQUUxQyw0QkFBNEI7QUFDNUIsNkNBQXNDO0FBR3RDLHNDQUF1RTtBQUN2RSxpREFBa0Y7QUFHbEYsNkNBSzJCO0FBQzNCLHNDQUFvRTtBQUNwRSwyQ0FBMkc7QUFDM0csc0NBQW1DO0FBQ25DLGlEQUFtRDtBQUNuRCxtREFBa0Q7QUFDbEQseUNBWXVCO0FBRXZCLDRFQUErRDtBQUMvRCxvRUFBb0Y7QUFDcEYsc0VBQWlFO0FBQ2pFLDBEQUErRTtBQUMvRSxrRUFBd0Y7QUFHeEYsOERBQTJFO0FBcUIzRSxNQUFNLG1CQUFtQixHQUFHLElBQUkscUJBQU8sQ0FBQztJQUNwQyxJQUFJLEVBQUUscUJBQXFCO0lBQzNCLElBQUksRUFBRSxxQ0FBcUM7SUFDM0MsVUFBVSxFQUFFLENBQUMsUUFBUSxFQUFFLGNBQWMsRUFBRSxVQUFVLENBQUM7Q0FDckQsQ0FBQyxDQUFDO0FBRUgsTUFBTSwyQkFBMkIsR0FBRyxJQUFJLHFCQUFPLENBQUM7SUFDNUMsSUFBSSxFQUFFLDZCQUE2QjtJQUNuQyxVQUFVLEVBQUUsQ0FBQyxVQUFVLENBQUM7SUFDeEIsSUFBSSxFQUFFLG1EQUFtRDtDQUM1RCxDQUFDLENBQUM7QUFDSCxNQUFNLHNDQUFzQyxHQUFHLElBQUkscUJBQU8sQ0FBQztJQUN2RCxJQUFJLEVBQUUscURBQXFEO0lBQzNELFVBQVUsRUFBRSxDQUFDLFVBQVUsQ0FBQztJQUN4QixJQUFJLEVBQUUscUdBQXFHO0NBQzlHLENBQUMsQ0FBQztBQUNILE1BQU0sZ0NBQWdDLEdBQUcsSUFBSSxxQkFBTyxDQUFDO0lBQ2pELElBQUksRUFBRSxrQ0FBa0M7SUFDeEMs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QU0sRUFBRTt3QkFDSixLQUFLO3dCQUNMLFdBQVc7d0JBQ1gsTUFBTTt3QkFDTixPQUFPLEVBQUU7NEJBQ0wsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLOzRCQUNwQixPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU87NEJBQ3hCLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSzs0QkFDcEIsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLOzRCQUNwQixRQUFRLEVBQUUsT0FBTyxDQUFDLFFBQVE7eUJBQzdCO3FCQUNKO2lCQUNKLENBQUM7Z0JBRUYsT0FBTyxjQUVhLENBQUM7YUFDeEI7WUFDRDtnQkFDSSxDQUFDLENBQUMsRUFBUyxFQUFFLEVBQUU7b0JBQ1gsTUFBTSxJQUFJLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztnQkFDbkMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDdkI7SUFDTCxDQUFDO0NBQ0o7QUFocUNELGtDQWdxQ0MiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9zZXJ2aWNlcy9yZnFtX3NlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6bWF4LWZpbGUtbGluZS1jb3VudFxyXG5pbXBvcnQgeyBUb29NYW55UmVxdWVzdHNFcnJvciB9IGZyb20gJ0AweC9hcGktdXRpbHMnO1xyXG5pbXBvcnQgeyBBc3NldFN3YXBwZXJDb250cmFjdEFkZHJlc3NlcywgTWFya2V0T3BlcmF0aW9uIH0gZnJvbSAnQDB4L2Fzc2V0LXN3YXBwZXInO1xyXG5pbXBvcnQgeyBPdGNPcmRlciwgWkVSTyB9IGZyb20gJ0AweC9wcm90b2NvbC11dGlscyc7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRUb2tlbk1ldGFkYXRhSWZFeGlzdHMsXHJcbiAgICBuYXRpdmVUb2tlblN5bWJvbCxcclxuICAgIG5hdGl2ZVdyYXBwZWRUb2tlblN5bWJvbCxcclxuICAgIFRva2VuTWV0YWRhdGEsXHJcbn0gZnJvbSAnQDB4L3Rva2VuLW1ldGFkYXRhJztcclxuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnQDB4L3V0aWxzJztcclxuaW1wb3J0IHsgV2ViM1dyYXBwZXIgfSBmcm9tICdAMHgvd2ViMy13cmFwcGVyJztcclxuaW1wb3J0IHsgcmV0cnkgfSBmcm9tICdAbGlmZW9taWMvYXR0ZW1wdCc7XHJcbmltcG9ydCB7IFByb2R1Y2VyIGFzIEthZmthUHJvZHVjZXIgfSBmcm9tICdrYWZrYWpzJztcclxuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBDb3VudGVyIH0gZnJvbSAncHJvbS1jbGllbnQnO1xyXG5pbXBvcnQgeyBQcm9kdWNlciB9IGZyb20gJ3Nxcy1wcm9kdWNlcic7XHJcblxyXG5pbXBvcnQgeyBFTkFCTEVfTExSX0NPT0xET1dOLCBSRlFNX01BSU5URU5BTkNFX01PREUgfSBmcm9tICcuLi9jb25maWcnO1xyXG5pbXBvcnQgeyBOVUxMX0FERFJFU1MsIE9ORV9TRUNPTkRfTVMsIFJGUU1fTlVNX0JVQ0tFVFMgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IE1ldGFUcmFuc2FjdGlvblN1Ym1pc3Npb25FbnRpdHksIFJmcW1WMlRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eSB9IGZyb20gJy4uL2VudGl0aWVzJztcclxuaW1wb3J0IHsgUmZxbVYySm9iQXBwcm92YWxPcHRzLCBSZnFtVjJKb2JDb25zdHJ1Y3Rvck9wdHMgfSBmcm9tICcuLi9lbnRpdGllcy9SZnFtVjJKb2JFbnRpdHknO1xyXG5pbXBvcnQge1xyXG4gICAgSm9iRmFpbHVyZVJlYXNvbixcclxuICAgIFJmcW1Kb2JTdGF0dXMsXHJcbiAgICBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uU3RhdHVzLFxyXG4gICAgUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblR5cGUsXHJcbn0gZnJvbSAnLi4vZW50aXRpZXMvdHlwZXMnO1xyXG5pbXBvcnQgeyBSRUFTT05fT05fU1RBVFVTX0VSUk9SX1JFU1BPTlNFX0VOQUJMRUQgfSBmcm9tICcuLi9jb25maWcnO1xyXG5pbXBvcnQgeyBJbnRlcm5hbFNlcnZlckVycm9yLCBOb3RGb3VuZEVycm9yLCBWYWxpZGF0aW9uRXJyb3IsIFZhbGlkYXRpb25FcnJvckNvZGVzIH0gZnJvbSAnLi4vY29yZS9lcnJvcnMnO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xyXG5pbXBvcnQgeyBmZWVUb1N0b3JlZEZlZSB9IGZyb20gJy4uL2NvcmUvZmVlX3V0aWxzJztcclxuaW1wb3J0IHsgdG9QYWlyU3RyaW5nIH0gZnJvbSAnLi4vY29yZS9wYWlyX3V0aWxzJztcclxuaW1wb3J0IHtcclxuICAgIEVpcDcxMkRhdGFGaWVsZCxcclxuICAgIEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25BcHByb3ZhbCxcclxuICAgIEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0LFxyXG4gICAgRmVlLFxyXG4gICAgRmVlTW9kZWxWZXJzaW9uLFxyXG4gICAgRmlybU90Y1F1b3RlLFxyXG4gICAgR2FzbGVzc0FwcHJvdmFsVHlwZXMsXHJcbiAgICBHYXNsZXNzVHlwZXMsXHJcbiAgICBJbmRpY2F0aXZlUXVvdGUsXHJcbiAgICBQZXJtaXRBcHByb3ZhbCxcclxuICAgIFBlcm1pdEVpcDcxMkNvbnRleHQsXHJcbn0gZnJvbSAnLi4vY29yZS90eXBlcyc7XHJcbmltcG9ydCB7IENhY2hlQ2xpZW50IH0gZnJvbSAnLi4vdXRpbHMvY2FjaGVfY2xpZW50JztcclxuaW1wb3J0IHsgZ2V0QmVzdFF1b3RlIH0gZnJvbSAnLi4vdXRpbHMvcXVvdGVfY29tcGFyaXNvbl91dGlscyc7XHJcbmltcG9ydCB7IEV4dGVuZGVkUXVvdGVSZXBvcnQsIHF1b3RlUmVwb3J0VXRpbHMgfSBmcm9tICcuLi91dGlscy9xdW90ZV9yZXBvcnRfdXRpbHMnO1xyXG5pbXBvcnQgeyBRdW90ZVNlcnZlckNsaWVudCB9IGZyb20gJy4uL3V0aWxzL3F1b3RlX3NlcnZlcl9jbGllbnQnO1xyXG5pbXBvcnQgeyBvdGNPcmRlclRvU3RvcmVkT3RjT3JkZXIsIFJmcW1EYlV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvcmZxbV9kYl91dGlscyc7XHJcbmltcG9ydCB7IGNvbXB1dGVIZWFsdGhDaGVja0FzeW5jLCBIZWFsdGhDaGVja1Jlc3VsdCB9IGZyb20gJy4uL3V0aWxzL3JmcW1faGVhbHRoX2NoZWNrJztcclxuaW1wb3J0IHsgUmZxQmxvY2tjaGFpblV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvcmZxX2Jsb2NrY2hhaW5fdXRpbHMnO1xyXG5pbXBvcnQgeyBSZnFNYWtlck1hbmFnZXIgfSBmcm9tICcuLi91dGlscy9yZnFfbWFrZXJfbWFuYWdlcic7XHJcbmltcG9ydCB7IGdldFNpZ25lckZyb21IYXNoLCBwYWRTaWduYXR1cmUgfSBmcm9tICcuLi91dGlscy9zaWduYXR1cmVfdXRpbHMnO1xyXG5pbXBvcnQgeyBUb2tlbk1ldGFkYXRhTWFuYWdlciB9IGZyb20gJy4uL3V0aWxzL1Rva2VuTWV0YWRhdGFNYW5hZ2VyJztcclxuXHJcbmltcG9ydCB7IEZlZVNlcnZpY2UgfSBmcm9tICcuL2ZlZV9zZXJ2aWNlJztcclxuaW1wb3J0IHsgUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlIH0gZnJvbSAnLi9yZnFfbWFrZXJfYmFsYW5jZV9jYWNoZV9zZXJ2aWNlJztcclxuaW1wb3J0IHtcclxuICAgIEFwcHJvdmFsUmVzcG9uc2UsXHJcbiAgICBGZXRjaEZpcm1RdW90ZVBhcmFtcyxcclxuICAgIEZldGNoSW5kaWNhdGl2ZVF1b3RlUGFyYW1zLFxyXG4gICAgRmV0Y2hJbmRpY2F0aXZlUXVvdGVSZXNwb25zZSxcclxuICAgIE90Y09yZGVyUmZxbVF1b3RlUmVzcG9uc2UsXHJcbiAgICBPdGNPcmRlclN1Ym1pdFJmcW1TaWduZWRRdW90ZVBhcmFtcyxcclxuICAgIE90Y09yZGVyU3VibWl0UmZxbVNpZ25lZFF1b3RlUmVzcG9uc2UsXHJcbiAgICBRdW90ZUNvbnRleHQsXHJcbiAgICBTdGF0dXNSZXNwb25zZSxcclxuICAgIFN1Ym1pdEFwcHJvdmFsUGFyYW1zLFxyXG4gICAgU3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUGFyYW1zLFxyXG4gICAgU3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUmVzcG9uc2UsXHJcbiAgICBUcmFuc2FjdGlvbkRldGFpbHMsXHJcbn0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG5jb25zdCBSRlFNX1FVT1RFX0lOU0VSVEVEID0gbmV3IENvdW50ZXIoe1xyXG4gICAgbmFtZTogJ3JmcW1fcXVvdGVfaW5zZXJ0ZWQnLFxyXG4gICAgaGVscDogJ0FuIFJmcW1RdW90ZSB3YXMgaW5zZXJ0ZWQgaW4gdGhlIERCJyxcclxuICAgIGxhYmVsTmFtZXM6IFsnYXBpS2V5JywgJ2ludGVncmF0b3JJZCcsICdtYWtlclVyaSddLFxyXG59KTtcclxuXHJcbmNvbnN0IFJGUU1fU0lHTkVEX1FVT1RFX05PVF9GT1VORCA9IG5ldyBDb3VudGVyKHtcclxuICAgIG5hbWU6ICdyZnFtX3NpZ25lZF9xdW90ZV9ub3RfZm91bmQnLFxyXG4gICAgbGFiZWxOYW1lczogWydjaGFpbl9pZCddLFxyXG4gICAgaGVscDogJ0Egc3VibWl0dGVkIHF1b3RlIGRpZCBub3QgbWF0Y2ggYW55IHN0b3JlZCBxdW90ZXMnLFxyXG59KTtcclxuY29uc3QgUkZRTV9UQUtFUl9BTkRfVEFLRVJUT0tFTl9UUkFERV9FWElTVFMgPSBuZXcgQ291bnRlcih7XHJcbiAgICBuYW1lOiAncmZxbV9zaWduZWRfcXVvdGVfdGFrZXJfYW5kX3Rha2VydG9rZW5fdHJhZGVfZXhpc3RzJyxcclxuICAgIGxhYmVsTmFtZXM6IFsnY2hhaW5faWQnXSxcclxuICAgIGhlbHA6ICdBIHRyYWRlIHdhcyBzdWJtaXR0ZWQgd2hlbiB0aGUgc3lzdGVtIGFscmVhZHkgaGFkIGEgcGVuZGluZyB0cmFkZSBmb3IgdGhlIHNhbWUgdGFrZXIgYW5kIHRha2VydG9rZW4nLFxyXG59KTtcclxuY29uc3QgUkZRTV9TVUJNSVRfQkFMQU5DRV9DSEVDS19GQUlMRUQgPSBuZXcgQ291bnRlcih7XHJcbiAgICBuYW1lOiAncmZxbV9zdWJtaXRfYmFsYW5jZV9jaGVja19mYWlsZWQnLFxyXG4gICAgbGFiZWxOYW1lczogWydtYWtlckFkZHJlc3MnLCAnY2hhaW5faWQnXSxcclxuICAgIGhlbHA6ICdBIHRyYWRlIHdhcyBzdWJtaXR0ZWQgYnV0IG91ciBvbi1jaGFpbiBiYWxhbmNlIGNoZWNrIGZhaWxlZCcsXHJcbn0pO1xyXG5cclxuY29uc3QgUkZRTV9NQUtFUl9CTE9DS0VEX0ZPUl9MTFJfQ09PTERPV04gPSBuZXcgQ291bnRlcih7XHJcbiAgICBuYW1lOiAncmZxbV9tYWtlcl9ibG9ja2VkX2Zvcl9sbHJfY29vbGRvd24nLFxyXG4gICAgaGVscDogJ0EgbWFrZXIgZ2V0IGJsb2NrZWQgYmVjYXVzZSBvZiBMTFIgY29vbGRvd24nLFxyXG4gICAgbGFiZWxOYW1lczogWydtYWtlcl9pZCcsICdjaGFpbl9pZCcsICdwYWlyX2tleSddLFxyXG59KTtcclxuXHJcbmNvbnN0IFJGUU1fTU1fUkVUVVJORURfRElGRkVSRU5UX0FNT1VOVCA9IG5ldyBDb3VudGVyKHtcclxuICAgIG5hbWU6ICdyZnFtX21tX3JldHVybmVkX2RpZmZlcmVudF9hbW91bnRfdG90YWwnLFxyXG4gICAgaGVscDogJ0EgbWFrZXIgcmVzcG9uZGVkIGEgcXVvdGUgd2l0aCBkaWZmZXJlbnQgYW1vdW50IHRoYW4gcmVxdWVzdGVkJyxcclxuICAgIGxhYmVsTmFtZXM6IFsnbWFrZXJfdXJpJywgJ2NoYWluX2lkJywgJ21vZGlmaWNhdGlvbl90eXBlJ10sXHJcbn0pO1xyXG5cclxuY29uc3QgUFJJQ0VfREVDSU1BTF9QTEFDRVMgPSA2O1xyXG5cclxuY29uc3QgZ2V0VG9rZW5BZGRyZXNzRnJvbVN5bWJvbCA9IChzeW1ib2w6IHN0cmluZywgY2hhaW5JZDogbnVtYmVyKTogc3RyaW5nID0+IHtcclxuICAgIHJldHVybiAoZ2V0VG9rZW5NZXRhZGF0YUlmRXhpc3RzKHN5bWJvbCwgY2hhaW5JZCkgYXMgVG9rZW5NZXRhZGF0YSkudG9rZW5BZGRyZXNzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJmcW1TZXJ2aWNlIGlzIHRoZSBjb29yZGluYXRpb24gbGF5ZXIgZm9yIEhUVFAgYmFzZWQgUkZRTSBmbG93cy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZnFtU2VydmljZSB7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9uYXRpdmVUb2tlbkFkZHJlc3M6IHN0cmluZztcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX25hdGl2ZVRva2VuU3ltYm9sOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9uYXRpdmVXcmFwcGVkVG9rZW5TeW1ib2w6IHN0cmluZztcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX25hdGl2ZVdyYXBwZWRUb2tlbkFkZHJlc3M6IHN0cmluZztcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfZ2V0U2VsbEFtb3VudEdpdmVuQnV5QW1vdW50QW5kUXVvdGUoXHJcbiAgICAgICAgYnV5QW1vdW50OiBCaWdOdW1iZXIsXHJcbiAgICAgICAgcXVvdGVkVGFrZXJBbW91bnQ6IEJpZ051bWJlcixcclxuICAgICAgICBxdW90ZWRNYWtlckFtb3VudDogQmlnTnVtYmVyLFxyXG4gICAgKTogQmlnTnVtYmVyIHtcclxuICAgICAgICAvLyBTb2x2aW5nIGZvciB4IGdpdmVuIHRoZSBmb2xsb3dpbmcgcHJvcG9ydGlvbjpcclxuICAgICAgICAvLyB4IC8gYnV5QW1vdW50ID0gcXVvdGVkVGFrZXJBbW91bnQgLyBxdW90ZWRNYWtlckFtb3VudFxyXG4gICAgICAgIHJldHVybiBxdW90ZWRUYWtlckFtb3VudC5kaXYocXVvdGVkTWFrZXJBbW91bnQpLnRpbWVzKGJ1eUFtb3VudCkuZGVjaW1hbFBsYWNlcygwKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfZ2V0QnV5QW1vdW50R2l2ZW5TZWxsQW1vdW50QW5kUXVvdGUoXHJcbiAgICAgICAgc2VsbEFtb3VudDogQmlnTnVtYmVyLFxyXG4gICAgICAgIHF1b3RlZFRha2VyQW1vdW50OiBCaWdOdW1iZXIsXHJcbiAgICAgICAgcXVvdGVkTWFrZXJBbW91bnQ6IEJpZ051bWJlcixcclxuICAgICk6IEJpZ051bWJlciB7XHJcbiAgICAgICAgLy8gU29sdmluZyBmb3IgeSBnaXZlbiB0aGUgZm9sbG93aW5nIHByb3BvcnRpb246XHJcbiAgICAgICAgLy8geSAvIHNlbGxBbW91bnQgPSAgcXVvdGVkTWFrZXJBbW91bnQgLyBxdW90ZWRUYWtlckFtb3VudFxyXG4gICAgICAgIHJldHVybiBxdW90ZWRNYWtlckFtb3VudC5kaXYocXVvdGVkVGFrZXJBbW91bnQpLnRpbWVzKHNlbGxBbW91bnQpLmRlY2ltYWxQbGFjZXMoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gYSB0cmFuc2FjdGlvbiBzdWJtaXNzaW9uIHRvIHR5cGUgYFRyYW5zYWN0aW9uRGV0YWlsc2AuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQ29ycmVzcG9uZGluZyBgVHJhbnNhY3Rpb25EZXRhaWxzYCBvciBudWxsIGlmIHRyYW5zYWN0aW9uIGhhc2ggaXMgbm90IGF2YWlsYWJsZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3RyYW5zZm9ybVRyYW5zYWN0aW9uU3VibWlzc2lvbihcclxuICAgICAgICB0cmFuc2FjdGlvblN1Ym1pc3Npb246IFBpY2s8XHJcbiAgICAgICAgICAgIFJmcW1WMlRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eSB8IE1ldGFUcmFuc2FjdGlvblN1Ym1pc3Npb25FbnRpdHksXHJcbiAgICAgICAgICAgICdjcmVhdGVkQXQnIHwgJ3RyYW5zYWN0aW9uSGFzaCdcclxuICAgICAgICA+LFxyXG4gICAgKTogVHJhbnNhY3Rpb25EZXRhaWxzIHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsIGNyZWF0ZWRBdCB9ID0gdHJhbnNhY3Rpb25TdWJtaXNzaW9uO1xyXG4gICAgICAgIHJldHVybiBoYXNoID8geyBoYXNoLCB0aW1lc3RhbXA6IGNyZWF0ZWRBdC5nZXRUaW1lKCkgfSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgZGV0YWlscyBvZiB0aGUgc3VjY2Vzc2Z1bCB0cmFuc2FjdGlvbiBzdWJtaXNzaW9uICh0aGVyZSB3aWxsIG9ubHkgYmUgb25lKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0cyBPcHRpb25zIG9iamVjdCB0aGF0IGNvbnRhaW5zOlxyXG4gICAgICogICAgICAgICAgICAgLSBgaGFzaGA6IFRoZSBoYXNoIG9mIHRoZSBvcmRlciBvciBtZXRhdHJhbnNhY3Rpb24uXHJcbiAgICAgKiAgICAgICAgICAgICAtIGB0eXBlYDogVGhlIHR5cGUgb2YgdGhlIHRyYW5zYWN0aW9uIHN1Ym1pc3Npb25zLlxyXG4gICAgICogICAgICAgICAgICAgLSBgdHJhbnNhY3Rpb25TdWJtc3Npb25zYDogTGlzdCBvZiB0cmFuc2FjdGlvbiBzdWJtaXNzaW9ucyB0byBmaWx0ZXIuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGV0YWlscyAoaGFzaCBhbmQgdGltZXN0YW1wKSBvZiB0aGUgc3VjY2Vzc2Z1bCB0cmFuc2FjdGlvbiBzdWJtaXNzaW9uLlxyXG4gICAgICogQHRocm93cyAtIFdoZW4gdGhlIG51bWJlciBvZiB0aGUgc3VjY2Vzc2Z1bCB0cmFuc2FjdGlvbiBzdWJtaXNzaW9uIGlzIG5vdCAxXHJcbiAgICAgKiAgICAgICAgIC0gVGhlIHN1Y2Nlc3NmdWwgdHJhbnNhY3Rpb24gc3VibWlzc2lvbiBkb2VzIG5vdCBoYXZlIHRyYW5zYWN0aW9uIGhhc2hcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2dldFN1Y2Nlc3NmdWxUcmFuc2FjdGlvblN1Ym1pc3Npb25EZXRhaWxzKG9wdHM6IHtcclxuICAgICAgICBoYXNoOiBzdHJpbmc7XHJcbiAgICAgICAgdHlwZTogUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblR5cGU7XHJcbiAgICAgICAgdHJhbnNhY3Rpb25TdWJtc3Npb25zOiBQaWNrPFxyXG4gICAgICAgICAgICBSZnFtVjJUcmFuc2FjdGlvblN1Ym1pc3Npb25FbnRpdHkgfCBNZXRhVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5LFxyXG4gICAgICAgICAgICAnY3JlYXRlZEF0JyB8ICdzdGF0dXMnIHwgJ3RyYW5zYWN0aW9uSGFzaCdcclxuICAgICAgICA+W107XHJcbiAgICB9KTogVHJhbnNhY3Rpb25EZXRhaWxzIHtcclxuICAgICAgICBjb25zdCB7IGhhc2gsIHR5cGUsIHRyYW5zYWN0aW9uU3VibXNzaW9ucyB9ID0gb3B0cztcclxuICAgICAgICBjb25zdCBzdWNjZXNzZnVsVHJhbnNhY3Rpb25TdWJtaXNzaW9ucyA9IHRyYW5zYWN0aW9uU3VibXNzaW9ucy5maWx0ZXIoXHJcbiAgICAgICAgICAgIChzKSA9PlxyXG4gICAgICAgICAgICAgICAgcy5zdGF0dXMgPT09IFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25TdGF0dXMuU3VjY2VlZGVkVW5jb25maXJtZWQgfHxcclxuICAgICAgICAgICAgICAgIHMuc3RhdHVzID09PSBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uU3RhdHVzLlN1Y2NlZWRlZENvbmZpcm1lZCxcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChzdWNjZXNzZnVsVHJhbnNhY3Rpb25TdWJtaXNzaW9ucy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGV4YWN0bHkgb25lIHN1Y2Nlc3NmdWwgdHJhbnNhY3Rpb24gc3VibWlzc2lvbiBvZiB0eXBlICR7dHlwZX0gZm9yIGhhc2ggJHtoYXNofTsgZm91bmQgJHtzdWNjZXNzZnVsVHJhbnNhY3Rpb25TdWJtaXNzaW9ucy5sZW5ndGh9YCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3VjY2Vzc2Z1bFRyYW5zYWN0aW9uU3VibWlzc2lvbiA9IHN1Y2Nlc3NmdWxUcmFuc2FjdGlvblN1Ym1pc3Npb25zWzBdO1xyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NmdWxUcmFuc2FjdGlvblN1Ym1pc3Npb25EZXRhaWxzID0gdGhpcy5fdHJhbnNmb3JtVHJhbnNhY3Rpb25TdWJtaXNzaW9uKFxyXG4gICAgICAgICAgICBzdWNjZXNzZnVsVHJhbnNhY3Rpb25TdWJtaXNzaW9uLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKCFzdWNjZXNzZnVsVHJhbnNhY3Rpb25TdWJtaXNzaW9uRGV0YWlscykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1Y2Nlc3NmdWwgdHJhbnNhY3Rpb24gb2YgdHlwZSAke3R5cGV9IGRvZXMgbm90IGhhdmUgYSBoYXNoICR7aGFzaH1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdWNjZXNzZnVsVHJhbnNhY3Rpb25TdWJtaXNzaW9uRGV0YWlscztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfam9iRmFpbHVyZVN0YXR1c1RvUmVhc29uKGZhaWx1cmVTdGF0dXM6IFJmcW1Kb2JTdGF0dXMpOiBKb2JGYWlsdXJlUmVhc29uIHtcclxuICAgICAgICBzd2l0Y2ggKGZhaWx1cmVTdGF0dXMpIHtcclxuICAgICAgICAgICAgY2FzZSBSZnFtSm9iU3RhdHVzLkZhaWxlZEV0aENhbGxGYWlsZWQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSm9iRmFpbHVyZVJlYXNvbi5UcmFuc2FjdGlvblNpbXVsYXRpb25GYWlsZWQ7XHJcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRFeHBpcmVkOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpvYkZhaWx1cmVSZWFzb24uT3JkZXJFeHBpcmVkO1xyXG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuRmFpbGVkTGFzdExvb2tEZWNsaW5lZDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBKb2JGYWlsdXJlUmVhc29uLkxhc3RMb29rRGVjbGluZWQ7XHJcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRTaWduRmFpbGVkOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpvYkZhaWx1cmVSZWFzb24uTWFya2V0TWFrZXJTaWduYXR1cmVFcnJvcjtcclxuICAgICAgICAgICAgY2FzZSBSZnFtSm9iU3RhdHVzLkZhaWxlZFJldmVydGVkQ29uZmlybWVkOlxyXG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuRmFpbGVkUmV2ZXJ0ZWRVbmNvbmZpcm1lZDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBKb2JGYWlsdXJlUmVhc29uLlRyYW5zYWN0aW9uUmV2ZXJ0ZWQ7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSm9iRmFpbHVyZVJlYXNvbi5JbnRlcm5hbEVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9jaGFpbklkOiBudW1iZXIsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfZmVlU2VydmljZTogRmVlU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9mZWVNb2RlbFZlcnNpb246IEZlZU1vZGVsVmVyc2lvbixcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9jb250cmFjdEFkZHJlc3NlczogQXNzZXRTd2FwcGVyQ29udHJhY3RBZGRyZXNzZXMsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfcmVnaXN0cnlBZGRyZXNzOiBzdHJpbmcsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfYmxvY2tjaGFpblV0aWxzOiBSZnFCbG9ja2NoYWluVXRpbHMsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfZGJVdGlsczogUmZxbURiVXRpbHMsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfc3FzUHJvZHVjZXI6IFByb2R1Y2VyLFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX3F1b3RlU2VydmVyQ2xpZW50OiBRdW90ZVNlcnZlckNsaWVudCxcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9taW5FeHBpcnlEdXJhdGlvbk1zOiBudW1iZXIsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfY2FjaGVDbGllbnQ6IENhY2hlQ2xpZW50LFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX3JmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZTogUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlLFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX3JmcU1ha2VyTWFuYWdlcjogUmZxTWFrZXJNYW5hZ2VyLFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX3Rva2VuTWV0YWRhdGFNYW5hZ2VyOiBUb2tlbk1ldGFkYXRhTWFuYWdlcixcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9rYWZrYVByb2R1Y2VyPzogS2Fma2FQcm9kdWNlcixcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9xdW90ZVJlcG9ydFRvcGljPzogc3RyaW5nLFxyXG4gICAgKSB7XHJcbiAgICAgICAgdGhpcy5fbmF0aXZlVG9rZW5TeW1ib2wgPSBuYXRpdmVUb2tlblN5bWJvbCh0aGlzLl9jaGFpbklkKTtcclxuICAgICAgICB0aGlzLl9uYXRpdmVUb2tlbkFkZHJlc3MgPSBnZXRUb2tlbkFkZHJlc3NGcm9tU3ltYm9sKHRoaXMuX25hdGl2ZVRva2VuU3ltYm9sLCB0aGlzLl9jaGFpbklkKTtcclxuICAgICAgICB0aGlzLl9uYXRpdmVXcmFwcGVkVG9rZW5TeW1ib2wgPSBuYXRpdmVXcmFwcGVkVG9rZW5TeW1ib2wodGhpcy5fY2hhaW5JZCk7XHJcbiAgICAgICAgdGhpcy5fbmF0aXZlV3JhcHBlZFRva2VuQWRkcmVzcyA9IGdldFRva2VuQWRkcmVzc0Zyb21TeW1ib2wodGhpcy5fbmF0aXZlV3JhcHBlZFRva2VuU3ltYm9sLCB0aGlzLl9jaGFpbklkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhc3N0aHJvdWdoIHRvIFRva2VuTWV0YWRhdGFNYW5hZ2VyJ3MgYGdldFRva2VuRGVjaW1hbHNBc3luY2AgbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRUb2tlbkRlY2ltYWxzQXN5bmModG9rZW5BZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbk1ldGFkYXRhTWFuYWdlci5nZXRUb2tlbkRlY2ltYWxzQXN5bmModG9rZW5BZGRyZXNzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoIHRoZSBiZXN0IGluZGljYXRpdmUgcXVvdGUgYXZhaWxhYmxlLiBSZXR1cm5zIG51bGwgaWYgbm8gdmFsaWQgcXVvdGVzIGZvdW5kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBmZXRjaEluZGljYXRpdmVRdW90ZUFzeW5jKFxyXG4gICAgICAgIHBhcmFtczogRmV0Y2hJbmRpY2F0aXZlUXVvdGVQYXJhbXMsXHJcbiAgICAgICAgZXh0ZW5kZWRRdW90ZVJlcG9ydFN1Ym1pc3Npb25CeTogRXh0ZW5kZWRRdW90ZVJlcG9ydFsnc3VibWlzc2lvbkJ5J10gPSAncmZxbScsXHJcbiAgICApOiBQcm9taXNlPEZldGNoSW5kaWNhdGl2ZVF1b3RlUmVzcG9uc2UgfCBudWxsPiB7XHJcbiAgICAgICAgY29uc3QgYWZmaWxpYXRlQWRkcmVzcyA9IHBhcmFtcy5hZmZpbGlhdGVBZGRyZXNzID8/IHBhcmFtcy5pbnRlZ3JhdG9yLmFmZmlsaWF0ZUFkZHJlc3M7XHJcblxyXG4gICAgICAgIC8vIFJldHJpZXZlIHF1b3RlIGNvbnRleHRcclxuICAgICAgICBjb25zdCBxdW90ZUNvbnRleHQgPSB0aGlzLl9yZXRyaWV2ZVF1b3RlQ29udGV4dCh7IC4uLnBhcmFtcywgYWZmaWxpYXRlQWRkcmVzcyB9LCAvKiBpc0Zpcm0gKi8gZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgaXNGaXJtLFxyXG4gICAgICAgICAgICB0YWtlckFtb3VudCxcclxuICAgICAgICAgICAgbWFrZXJBbW91bnQsXHJcbiAgICAgICAgICAgIHRha2VyVG9rZW4sXHJcbiAgICAgICAgICAgIG1ha2VyVG9rZW4sXHJcbiAgICAgICAgICAgIG9yaWdpbmFsTWFrZXJUb2tlbixcclxuICAgICAgICAgICAgdGFrZXJUb2tlbkRlY2ltYWxzLFxyXG4gICAgICAgICAgICBtYWtlclRva2VuRGVjaW1hbHMsXHJcbiAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcclxuICAgICAgICAgICAgaXNTZWxsaW5nLFxyXG4gICAgICAgICAgICBhc3NldEZpbGxBbW91bnQsXHJcbiAgICAgICAgICAgIGludGVncmF0b3IsXHJcbiAgICAgICAgfSA9IHF1b3RlQ29udGV4dDtcclxuXHJcbiAgICAgICAgLy8gKE9wdGltaXphdGlvbikgV2hlbiBgcXVvdGVzV2l0aEdhc0ZlZWAgaXMgcmV0dXJuZWQsIHdlIGNhbiB1c2UgdGhpcyB2YWx1ZSBhbmQgcmV2aXNlIGl0LCB0byBhdm9pZCBhbm90aGVyIGZldGNoIHRvIE1Nc1xyXG4gICAgICAgIGNvbnN0IHsgZmVlV2l0aERldGFpbHMsIHF1b3Rlc1dpdGhHYXNGZWUsIGFtbVF1b3RlVW5pcXVlSWQgfSA9IGF3YWl0IHRoaXMuX2ZlZVNlcnZpY2UuY2FsY3VsYXRlRmVlQXN5bmMoXHJcbiAgICAgICAgICAgIHF1b3RlQ29udGV4dCxcclxuICAgICAgICAgICAgdGhpcy5fZmV0Y2hJbmRpY2F0aXZlUXVvdGVzQXN5bmMuYmluZCh0aGlzKSxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgZmVlcyAob3RoZXIgdGhhbiBnYXMgZmVlKSB0byBjaGFyZ2UgTU1zXHJcbiAgICAgICAgY29uc3Qgb3RoZXJGZWVzQW1vdW50ID0gZmVlV2l0aERldGFpbHMuYW1vdW50Lm1pbnVzKGZlZVdpdGhEZXRhaWxzLmRldGFpbHMuZ2FzRmVlQW1vdW50KTtcclxuXHJcbiAgICAgICAgY29uc3QgZmluYWxRdW90ZXMgPSBxdW90ZXNXaXRoR2FzRmVlXHJcbiAgICAgICAgICAgID8gYXdhaXQgdGhpcy5fZmVlU2VydmljZS5yZXZpc2VRdW90ZXNBc3luYyhxdW90ZXNXaXRoR2FzRmVlLCBvdGhlckZlZXNBbW91bnQsIHF1b3RlQ29udGV4dClcclxuICAgICAgICAgICAgOiBhd2FpdCB0aGlzLl9mZXRjaEluZGljYXRpdmVRdW90ZXNBc3luYyhxdW90ZUNvbnRleHQsIGZlZVdpdGhEZXRhaWxzKTtcclxuXHJcbiAgICAgICAgLy8gKFF1b3RlIFJlcG9ydCkgSWYgb3RoZXJGZWVzID4gMCwgdGhlbiB3ZSBcInJldmlzZWRcIiB0aGUgcXVvdGVzIGZyb20gTU1zLiBXZSB3YW50IHRvIHNhdmUgYm90aCB0aGUgb3JpZ2luYWwgcXVvdGVzIChha2EgaW50ZXJtZWRpYXRlUXVvdGVzKSBhbmQgdGhlIHJldmlzZWQgKGZpbmFsUXVvdGVzKVxyXG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZVF1b3RlcyA9IHF1b3Rlc1dpdGhHYXNGZWUgJiYgb3RoZXJGZWVzQW1vdW50Lmd0KFpFUk8pID8gcXVvdGVzV2l0aEdhc0ZlZSA6IFtdO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGJlc3QgcXVvdGVcclxuICAgICAgICBjb25zdCBiZXN0UXVvdGUgPSBnZXRCZXN0UXVvdGUoXHJcbiAgICAgICAgICAgIGZpbmFsUXVvdGVzLFxyXG4gICAgICAgICAgICBpc1NlbGxpbmcsXHJcbiAgICAgICAgICAgIHRha2VyVG9rZW4sXHJcbiAgICAgICAgICAgIG1ha2VyVG9rZW4sXHJcbiAgICAgICAgICAgIGFzc2V0RmlsbEFtb3VudCxcclxuICAgICAgICAgICAgdGhpcy5fbWluRXhwaXJ5RHVyYXRpb25NcyxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBpc0xpcXVpZGl0eUF2YWlsYWJsZSA9IGJlc3RRdW90ZSAhPT0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gUXVvdGUgUmVwb3J0XHJcbiAgICAgICAgaWYgKHRoaXMuX2thZmthUHJvZHVjZXIpIHtcclxuICAgICAgICAgICAgYXdhaXQgcXVvdGVSZXBvcnRVdGlscy5wdWJsaXNoUkZRTVF1b3RlUmVwb3J0QXN5bmMoXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJtUXVvdGU6IGlzRmlybSxcclxuICAgICAgICAgICAgICAgICAgICB0YWtlcjogdGFrZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ1eVRva2VuQWRkcmVzczogb3JpZ2luYWxNYWtlclRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGxUb2tlbkFkZHJlc3M6IHRha2VyVG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgYnV5QW1vdW50OiBtYWtlckFtb3VudCxcclxuICAgICAgICAgICAgICAgICAgICBzZWxsQW1vdW50OiB0YWtlckFtb3VudCxcclxuICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhdG9ySWQ6IGludGVncmF0b3I/LmludGVncmF0b3JJZCxcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbFF1b3RlcyxcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVRdW90ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdFF1b3RlLFxyXG4gICAgICAgICAgICAgICAgICAgIGZlZTogZmVlVG9TdG9yZWRGZWUoZmVlV2l0aERldGFpbHMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGFtbVF1b3RlVW5pcXVlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNMaXF1aWRpdHlBdmFpbGFibGUsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fa2Fma2FQcm9kdWNlcixcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1b3RlUmVwb3J0VG9waWMsXHJcbiAgICAgICAgICAgICAgICBleHRlbmRlZFF1b3RlUmVwb3J0U3VibWlzc2lvbkJ5LFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm8gcXVvdGVzIGZvdW5kXHJcbiAgICAgICAgaWYgKCFpc0xpcXVpZGl0eUF2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXBhcmUgdGhlIHByaWNlXHJcbiAgICAgICAgY29uc3QgbWFrZXJBbW91bnRJblVuaXQgPSBXZWIzV3JhcHBlci50b1VuaXRBbW91bnQoYmVzdFF1b3RlLm1ha2VyQW1vdW50LCBtYWtlclRva2VuRGVjaW1hbHMpO1xyXG4gICAgICAgIGNvbnN0IHRha2VyQW1vdW50SW5Vbml0ID0gV2ViM1dyYXBwZXIudG9Vbml0QW1vdW50KGJlc3RRdW90ZS50YWtlckFtb3VudCwgdGFrZXJUb2tlbkRlY2ltYWxzKTtcclxuICAgICAgICBjb25zdCBwcmljZSA9IGlzU2VsbGluZyA/IG1ha2VyQW1vdW50SW5Vbml0LmRpdih0YWtlckFtb3VudEluVW5pdCkgOiB0YWtlckFtb3VudEluVW5pdC5kaXYobWFrZXJBbW91bnRJblVuaXQpO1xyXG4gICAgICAgIC8vIFRoZSB3YXkgdGhlIEJpZ051bWJlciByb3VuZCBkb3duIGJlaGF2aW9yIChodHRwczovL21pa2VtY2wuZ2l0aHViLmlvL2JpZ251bWJlci5qcy8jZHApIHdvcmtzIHJlcXVpcmVzIHVzXHJcbiAgICAgICAgLy8gdG8gYWRkIDEgdG8gUFJJQ0VfREVDSU1BTF9QTEFDRVMgaW4gb3JkZXIgdG8gYWN0dWFsbHkgY29tZSBvdXQgd2l0aCB0aGUgZGVjaW1hbCBwbGFjZXMgc3BlY2lmaWVkLlxyXG4gICAgICAgIGNvbnN0IHJvdW5kZWRQcmljZSA9IHByaWNlLmRlY2ltYWxQbGFjZXMoUFJJQ0VfREVDSU1BTF9QTEFDRVMgKyAxLCBCaWdOdW1iZXIuUk9VTkRfRE9XTik7XHJcblxyXG4gICAgICAgIC8vIFByZXBhcmUgcmVzcG9uc2VcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcmljZTogcm91bmRlZFByaWNlLFxyXG4gICAgICAgICAgICBnYXM6IGZlZVdpdGhEZXRhaWxzLmRldGFpbHMuZ2FzUHJpY2UsXHJcbiAgICAgICAgICAgIGJ1eUFtb3VudDogYmVzdFF1b3RlLm1ha2VyQW1vdW50LFxyXG4gICAgICAgICAgICBidXlUb2tlbkFkZHJlc3M6IG9yaWdpbmFsTWFrZXJUb2tlbixcclxuICAgICAgICAgICAgc2VsbEFtb3VudDogYmVzdFF1b3RlLnRha2VyQW1vdW50LFxyXG4gICAgICAgICAgICBzZWxsVG9rZW5BZGRyZXNzOiBiZXN0UXVvdGUudGFrZXJUb2tlbixcclxuICAgICAgICAgICAgYWxsb3dhbmNlVGFyZ2V0OiB0aGlzLl9jb250cmFjdEFkZHJlc3Nlcy5leGNoYW5nZVByb3h5LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaCB0aGUgYmVzdCBmaXJtIHF1b3RlIGF2YWlsYWJsZSwgaW5jbHVkaW5nIGEgbWV0YXRyYW5zYWN0aW9uLiBSZXR1cm5zIG51bGwgaWYgbm8gdmFsaWQgcXVvdGVzIGZvdW5kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBmZXRjaEZpcm1RdW90ZUFzeW5jKFxyXG4gICAgICAgIHBhcmFtczogRmV0Y2hGaXJtUXVvdGVQYXJhbXMsXHJcbiAgICAgICAgZXh0ZW5kZWRRdW90ZVJlcG9ydFN1Ym1pc3Npb25CeTogRXh0ZW5kZWRRdW90ZVJlcG9ydFsnc3VibWlzc2lvbkJ5J10gPSAncmZxbScsXHJcbiAgICApOiBQcm9taXNlPHsgcXVvdGU6IE90Y09yZGVyUmZxbVF1b3RlUmVzcG9uc2UgfCBudWxsOyBxdW90ZVJlcG9ydElkOiBzdHJpbmcgfCBudWxsIH0+IHtcclxuICAgICAgICBjb25zdCBhZmZpbGlhdGVBZGRyZXNzID0gcGFyYW1zLmFmZmlsaWF0ZUFkZHJlc3MgPz8gcGFyYW1zLmludGVncmF0b3IuYWZmaWxpYXRlQWRkcmVzcztcclxuICAgICAgICAvLyBSZXRyaWV2ZSBxdW90ZSBjb250ZXh0XHJcbiAgICAgICAgY29uc3QgcXVvdGVDb250ZXh0ID0gdGhpcy5fcmV0cmlldmVRdW90ZUNvbnRleHQoeyAuLi5wYXJhbXMsIGFmZmlsaWF0ZUFkZHJlc3MgfSwgLyogaXNGaXJtICovIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgaXNGaXJtLFxyXG4gICAgICAgICAgICB0YWtlckFtb3VudCxcclxuICAgICAgICAgICAgbWFrZXJBbW91bnQsXHJcbiAgICAgICAgICAgIHRha2VyVG9rZW4sXHJcbiAgICAgICAgICAgIG1ha2VyVG9rZW4sXHJcbiAgICAgICAgICAgIG9yaWdpbmFsTWFrZXJUb2tlbixcclxuICAgICAgICAgICAgdGFrZXJUb2tlbkRlY2ltYWxzLFxyXG4gICAgICAgICAgICBtYWtlclRva2VuRGVjaW1hbHMsXHJcbiAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcclxuICAgICAgICAgICAgaW50ZWdyYXRvcixcclxuICAgICAgICAgICAgaXNVbndyYXAsXHJcbiAgICAgICAgICAgIGlzU2VsbGluZyxcclxuICAgICAgICAgICAgYXNzZXRGaWxsQW1vdW50LFxyXG4gICAgICAgIH0gPSBxdW90ZUNvbnRleHQ7XHJcblxyXG4gICAgICAgIC8vIChPcHRpbWl6YXRpb24pIFdoZW4gYHF1b3Rlc1dpdGhHYXNGZWVgIGlzIHJldHVybmVkLCB3ZSBjYW4gc29tZXRpbWVzIHJldXNlIGl0LCB0byBhdm9pZCBhbm90aGVyIGZldGNoIHRvIE1Nc1xyXG4gICAgICAgIC8vIE5PVEU6IHRoaXMgb3B0aW1pemF0aW9uIGRpZmZlcnMgZnJvbSB0aGUgb3B0aW1pemF0aW9uIGZvciBpbmRpY2F0aXZlIHF1b3RlcyBiZWNhdXNlIHdlIGRvIE5PVCByZXZpc2UgZmlybSBxdW90ZXNcclxuICAgICAgICBjb25zdCB7IGZlZVdpdGhEZXRhaWxzLCBxdW90ZXNXaXRoR2FzRmVlLCBhbW1RdW90ZVVuaXF1ZUlkIH0gPSBhd2FpdCB0aGlzLl9mZWVTZXJ2aWNlLmNhbGN1bGF0ZUZlZUFzeW5jKFxyXG4gICAgICAgICAgICBxdW90ZUNvbnRleHQsXHJcbiAgICAgICAgICAgIHRoaXMuX2ZldGNoSW5kaWNhdGl2ZVF1b3Rlc0FzeW5jLmJpbmQodGhpcyksXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGZlZXMgKG90aGVyIHRoYW4gZ2FzIGZlZSkgdG8gY2hhcmdlIE1Ncy4gSWYgdGhlcmUgYXJlIG90aGVyIGZlZXMsIHdlIGRvbid0IHJldXNlIGBxdW90ZXNXaXRoR2FzRmVlYFxyXG4gICAgICAgIGNvbnN0IG90aGVyRmVlc0Ftb3VudCA9IGZlZVdpdGhEZXRhaWxzLmFtb3VudC5taW51cyhmZWVXaXRoRGV0YWlscy5kZXRhaWxzLmdhc0ZlZUFtb3VudCk7XHJcblxyXG4gICAgICAgIC8vIElmIGBxdW90ZXNXaXRoR2FzRmVlYCBoYXZlIGJlZW4gb2J0YWluZWQgYW5kIHRoZXJlIGFyZSBubyBvdGhlciBmZWVzLCByZXVzZSB0aGUgcXVvdGVzLiBPdGhlcndpc2UgY2FsbCBNTXMgd2l0aCBmdWxsIGZlZSB0byBnZXQgbmV3IHF1b3Rlcy5cclxuICAgICAgICBjb25zdCBmaW5hbFF1b3RlcyA9XHJcbiAgICAgICAgICAgIHF1b3Rlc1dpdGhHYXNGZWUgJiYgb3RoZXJGZWVzQW1vdW50LmVxKFpFUk8pXHJcbiAgICAgICAgICAgICAgICA/IGF3YWl0IHRoaXMuX2NvbnZlcnRUb0Zpcm1RdW90ZXNBc3luYyhxdW90ZXNXaXRoR2FzRmVlLCBxdW90ZUNvbnRleHQpXHJcbiAgICAgICAgICAgICAgICA6IGF3YWl0IHRoaXMuX2ZldGNoRmlybVF1b3Rlc0FzeW5jKHF1b3RlQ29udGV4dCwgZmVlV2l0aERldGFpbHMpO1xyXG5cclxuICAgICAgICAvLyAoUXVvdGUgUmVwb3J0KSBJZiBgcXVvdGVzV2l0aEdhc0ZlZWAgaGF2ZSBub3QgYmVlbiByZXVzZWQsIHNhdmUgdGhlbSBhcyBpbnRlcm1lZGlhdGUgcXVvdGVzXHJcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlUXVvdGVzID0gcXVvdGVzV2l0aEdhc0ZlZSAmJiBvdGhlckZlZXNBbW91bnQuZ3QoWkVSTykgPyBxdW90ZXNXaXRoR2FzRmVlIDogW107XHJcblxyXG4gICAgICAgIC8vIChNYWtlciBCYWxhbmNlIENhY2hlKSBGZXRjaCBtYWtlciBiYWxhbmNlcyB0byB2YWxpZGF0ZSB3aGV0aGVyIHF1b3RlcyBhcmUgZnVsbHkgZmlsbGFibGVcclxuICAgICAgICBsZXQgcXVvdGVkTWFrZXJCYWxhbmNlczogQmlnTnVtYmVyW10gfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgcXVvdGVkRVJDMjBPd25lcnMgPSBmaW5hbFF1b3Rlcy5tYXAoKHF1b3RlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBvd25lcjogcXVvdGUub3JkZXIubWFrZXIsXHJcbiAgICAgICAgICAgICAgICB0b2tlbjogbWFrZXJUb2tlbixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBxdW90ZWRNYWtlckJhbGFuY2VzID0gYXdhaXQgdGhpcy5fcmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlLmdldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhaW5JZCxcclxuICAgICAgICAgICAgICAgIHF1b3RlZEVSQzIwT3duZXJzLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgeyBjaGFpbklkOiB0aGlzLl9jaGFpbklkLCBxdW90ZWRFUkMyME93bmVycywgZXJyb3JNZXNzYWdlOiBlLm1lc3NhZ2UgfSxcclxuICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZmV0Y2ggbWFrZXIgYmFsYW5jZXMgdG8gdmFsaWRhdGUgZmlybSBxdW90ZXMnLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBiZXN0IHF1b3RlXHJcbiAgICAgICAgY29uc3QgYmVzdFF1b3RlID0gZ2V0QmVzdFF1b3RlKFxyXG4gICAgICAgICAgICBmaW5hbFF1b3RlcyxcclxuICAgICAgICAgICAgaXNTZWxsaW5nLFxyXG4gICAgICAgICAgICB0YWtlclRva2VuLFxyXG4gICAgICAgICAgICBtYWtlclRva2VuLFxyXG4gICAgICAgICAgICBhc3NldEZpbGxBbW91bnQsXHJcbiAgICAgICAgICAgIHRoaXMuX21pbkV4cGlyeUR1cmF0aW9uTXMsXHJcbiAgICAgICAgICAgIHF1b3RlZE1ha2VyQmFsYW5jZXMsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNMaXF1aWRpdHlBdmFpbGFibGUgPSBiZXN0UXVvdGUgIT09IG51bGw7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0b3JlZEZlZVdpdGhEZXRhaWxzID0gZmVlVG9TdG9yZWRGZWUoZmVlV2l0aERldGFpbHMpO1xyXG5cclxuICAgICAgICBsZXQgcXVvdGVSZXBvcnRJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgLy8gUXVvdGUgUmVwb3J0XHJcbiAgICAgICAgaWYgKHRoaXMuX2thZmthUHJvZHVjZXIpIHtcclxuICAgICAgICAgICAgcXVvdGVSZXBvcnRJZCA9IGF3YWl0IHF1b3RlUmVwb3J0VXRpbHMucHVibGlzaFJGUU1RdW90ZVJlcG9ydEFzeW5jKFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRmlybVF1b3RlOiBpc0Zpcm0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGFrZXI6IHRha2VyQWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICBidXlUb2tlbkFkZHJlc3M6IG9yaWdpbmFsTWFrZXJUb2tlbixcclxuICAgICAgICAgICAgICAgICAgICBzZWxsVG9rZW5BZGRyZXNzOiB0YWtlclRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ1eUFtb3VudDogbWFrZXJBbW91bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsbEFtb3VudDogdGFrZXJBbW91bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyYXRvcklkOiBpbnRlZ3JhdG9yPy5pbnRlZ3JhdG9ySWQsXHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxRdW90ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlUXVvdGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RRdW90ZSxcclxuICAgICAgICAgICAgICAgICAgICBmZWU6IHN0b3JlZEZlZVdpdGhEZXRhaWxzLFxyXG4gICAgICAgICAgICAgICAgICAgIGFtbVF1b3RlVW5pcXVlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNMaXF1aWRpdHlBdmFpbGFibGUsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fa2Fma2FQcm9kdWNlcixcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1b3RlUmVwb3J0VG9waWMsXHJcbiAgICAgICAgICAgICAgICBleHRlbmRlZFF1b3RlUmVwb3J0U3VibWlzc2lvbkJ5LFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm8gcXVvdGUgZm91bmRcclxuICAgICAgICBpZiAoIWlzTGlxdWlkaXR5QXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHF1b3RlOiBudWxsLCBxdW90ZVJlcG9ydElkIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIG1ha2VyVXJpXHJcbiAgICAgICAgY29uc3QgbWFrZXJVcmkgPSBiZXN0UXVvdGUubWFrZXJVcmk7XHJcbiAgICAgICAgaWYgKG1ha2VyVXJpID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKHsgbWFrZXJBZGRyZXNzOiBiZXN0UXVvdGUub3JkZXIubWFrZXIgfSwgJ21ha2VyVXJpIHVua25vd24gZm9yIG1ha2VyIGFkZHJlc3MnKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtYWtlclVyaSB1bmtub3duIGZvciBtYWtlciBhZGRyZXNzICR7YmVzdFF1b3RlLm9yZGVyLm1ha2VyfWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgcHJpY2VcclxuICAgICAgICBjb25zdCBtYWtlckFtb3VudEluVW5pdCA9IFdlYjNXcmFwcGVyLnRvVW5pdEFtb3VudChiZXN0UXVvdGUub3JkZXIubWFrZXJBbW91bnQsIG1ha2VyVG9rZW5EZWNpbWFscyk7XHJcbiAgICAgICAgY29uc3QgdGFrZXJBbW91bnRJblVuaXQgPSBXZWIzV3JhcHBlci50b1VuaXRBbW91bnQoYmVzdFF1b3RlLm9yZGVyLnRha2VyQW1vdW50LCB0YWtlclRva2VuRGVjaW1hbHMpO1xyXG4gICAgICAgIGNvbnN0IHByaWNlID0gaXNTZWxsaW5nID8gbWFrZXJBbW91bnRJblVuaXQuZGl2KHRha2VyQW1vdW50SW5Vbml0KSA6IHRha2VyQW1vdW50SW5Vbml0LmRpdihtYWtlckFtb3VudEluVW5pdCk7XHJcbiAgICAgICAgLy8gVGhlIHdheSB0aGUgQmlnTnVtYmVyIHJvdW5kIGRvd24gYmVoYXZpb3IgKGh0dHBzOi8vbWlrZW1jbC5naXRodWIuaW8vYmlnbnVtYmVyLmpzLyNkcCkgd29ya3MgcmVxdWlyZXMgdXNcclxuICAgICAgICAvLyB0byBhZGQgMSB0byBQUklDRV9ERUNJTUFMX1BMQUNFUyBpbiBvcmRlciB0byBhY3R1YWxseSBjb21lIG91dCB3aXRoIHRoZSBkZWNpbWFsIHBsYWNlcyBzcGVjaWZpZWQuXHJcbiAgICAgICAgY29uc3Qgcm91bmRlZFByaWNlID0gcHJpY2UuZGVjaW1hbFBsYWNlcyhQUklDRV9ERUNJTUFMX1BMQUNFUyArIDEsIEJpZ051bWJlci5ST1VORF9ET1dOKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgZmluYWwgdGFrZXJBbW91bnQgYW5kIG1ha2VyQW1vdW50XHJcbiAgICAgICAgY29uc3Qgc2VsbEFtb3VudCA9IGlzU2VsbGluZ1xyXG4gICAgICAgICAgICA/IC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcclxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgICAgICAgICAgIHRha2VyQW1vdW50IVxyXG4gICAgICAgICAgICA6IFJmcW1TZXJ2aWNlLl9nZXRTZWxsQW1vdW50R2l2ZW5CdXlBbW91bnRBbmRRdW90ZShcclxuICAgICAgICAgICAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgICAgICAgICAgICAgICBtYWtlckFtb3VudCEsXHJcbiAgICAgICAgICAgICAgICAgIGJlc3RRdW90ZS5vcmRlci50YWtlckFtb3VudCxcclxuICAgICAgICAgICAgICAgICAgYmVzdFF1b3RlLm9yZGVyLm1ha2VyQW1vdW50LFxyXG4gICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJ1eUFtb3VudCA9IGlzU2VsbGluZ1xyXG4gICAgICAgICAgICA/IFJmcW1TZXJ2aWNlLl9nZXRCdXlBbW91bnRHaXZlblNlbGxBbW91bnRBbmRRdW90ZShcclxuICAgICAgICAgICAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgICAgICAgICAgICAgICB0YWtlckFtb3VudCEsXHJcbiAgICAgICAgICAgICAgICAgIGJlc3RRdW90ZS5vcmRlci50YWtlckFtb3VudCxcclxuICAgICAgICAgICAgICAgICAgYmVzdFF1b3RlLm9yZGVyLm1ha2VyQW1vdW50LFxyXG4gICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgOiAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cclxuICAgICAgICAgICAgICBtYWtlckFtb3VudCE7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgT3JkZXIgYW5kIGl0cyBoYXNoXHJcbiAgICAgICAgY29uc3Qgb3JkZXJIYXNoID0gYmVzdFF1b3RlLm9yZGVyLmdldEhhc2goKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb3RjT3JkZXIgPSBiZXN0UXVvdGUub3JkZXI7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5fZGJVdGlscy53cml0ZVYyUXVvdGVBc3luYyh7XHJcbiAgICAgICAgICAgIG9yZGVySGFzaCxcclxuICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5fY2hhaW5JZCxcclxuICAgICAgICAgICAgZmVlOiBzdG9yZWRGZWVXaXRoRGV0YWlscyxcclxuICAgICAgICAgICAgb3JkZXI6IG90Y09yZGVyVG9TdG9yZWRPdGNPcmRlcihvdGNPcmRlciksXHJcbiAgICAgICAgICAgIG1ha2VyVXJpLFxyXG4gICAgICAgICAgICBhZmZpbGlhdGVBZGRyZXNzLFxyXG4gICAgICAgICAgICBpbnRlZ3JhdG9ySWQ6IGludGVncmF0b3IuaW50ZWdyYXRvcklkLFxyXG4gICAgICAgICAgICBpc1Vud3JhcCxcclxuICAgICAgICAgICAgdGFrZXJTcGVjaWZpZWRTaWRlOiBwYXJhbXMuc2VsbEFtb3VudCA/ICd0YWtlclRva2VuJyA6ICdtYWtlclRva2VuJyxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgYXBwcm92YWwgPSBwYXJhbXMuY2hlY2tBcHByb3ZhbFxyXG4gICAgICAgICAgICA/IC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcclxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0R2FzbGVzc0FwcHJvdmFsUmVzcG9uc2VBc3luYyh0YWtlckFkZHJlc3MhLCB0YWtlclRva2VuLCBzZWxsQW1vdW50KVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcblxyXG4gICAgICAgIFJGUU1fUVVPVEVfSU5TRVJURUQubGFiZWxzKGludGVncmF0b3IuaW50ZWdyYXRvcklkLCBpbnRlZ3JhdG9yLmludGVncmF0b3JJZCwgbWFrZXJVcmkpLmluYygpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHF1b3RlOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBHYXNsZXNzVHlwZXMuT3RjT3JkZXIsXHJcbiAgICAgICAgICAgICAgICBwcmljZTogcm91bmRlZFByaWNlLFxyXG4gICAgICAgICAgICAgICAgZ2FzOiBmZWVXaXRoRGV0YWlscy5kZXRhaWxzLmdhc1ByaWNlLFxyXG4gICAgICAgICAgICAgICAgYnV5QW1vdW50LFxyXG4gICAgICAgICAgICAgICAgYnV5VG9rZW5BZGRyZXNzOiBvcmlnaW5hbE1ha2VyVG9rZW4sXHJcbiAgICAgICAgICAgICAgICBzZWxsQW1vdW50LFxyXG4gICAgICAgICAgICAgICAgc2VsbFRva2VuQWRkcmVzczogYmVzdFF1b3RlLm9yZGVyLnRha2VyVG9rZW4sXHJcbiAgICAgICAgICAgICAgICBhbGxvd2FuY2VUYXJnZXQ6IHRoaXMuX2NvbnRyYWN0QWRkcmVzc2VzLmV4Y2hhbmdlUHJveHksXHJcbiAgICAgICAgICAgICAgICBvcmRlcjogYmVzdFF1b3RlLm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgb3JkZXJIYXNoLFxyXG4gICAgICAgICAgICAgICAgLy8gdXNlIGFwcHJvdmFsIHZhcmlhYmxlIGRpcmVjdGx5IGlzIG5vdCBpZGVhbCBhcyB3ZSBkb24ndCB3YW50IHRvIGluY2x1ZGUgYXBwcm92YWwgZmllbGQgaWYgYGFwcHJvdmFsYCBpcyBudWxsXHJcbiAgICAgICAgICAgICAgICAuLi4oYXBwcm92YWwgJiYgeyBhcHByb3ZhbCB9KSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcXVvdGVSZXBvcnRJZCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgYXBwcm92YWwgcmVzcG9uc2UgaW4gZmlybSBxdW90ZSByZXNwb25zZXMuIFRoZSBhcHByb3ZhbCByZXNwb25zZSBjb250YWlucyB3aGV0aGVyIGFuIGFwcHJvdmFsIGlzIHJlcXVpcmVkLCBpcyBnYXNsZXNzIGFwcHJvdmFsXHJcbiAgICAgKiBpcyBhdmFpbGFibGUgZm9yIHRoZSB0b2tlbiAob3B0aW9uYWwpLCB0aGUgdHlwZSBvZiB0aGUgZ2FzbGVzcyBhcHByb3ZhbCAob3B0aW9uYWwpIGFuZCB0aGUgRUlQNzEyIGNvbnRleHQgKG9wdGlvbmFsKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFrZXJBZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoZSB0YWtlci5cclxuICAgICAqIEBwYXJhbSB0b2tlblRvQXBwcm92ZSBUb2tlbiBhZGRyZXNzIHRvIGJlIGFwcHJvdmVkLlxyXG4gICAgICogQHBhcmFtIHNlbGxBbW91bnQgQW1vdW50IG9mIHRva2VuIHRvIHNlbGwgaW4gYmFzZSB1bml0LlxyXG4gICAgICogQHJldHVybnMgVGhlIGFwcHJvdmFsIHJlc3BvbnNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0R2FzbGVzc0FwcHJvdmFsUmVzcG9uc2VBc3luYyhcclxuICAgICAgICB0YWtlckFkZHJlc3M6IHN0cmluZyxcclxuICAgICAgICB0b2tlblRvQXBwcm92ZTogc3RyaW5nLFxyXG4gICAgICAgIHNlbGxBbW91bnQ6IEJpZ051bWJlcixcclxuICAgICk6IFByb21pc2U8QXBwcm92YWxSZXNwb25zZT4ge1xyXG4gICAgICAgIGNvbnN0IGFsbG93YW5jZSA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZXRBbGxvd2FuY2VBc3luYyhcclxuICAgICAgICAgICAgdG9rZW5Ub0FwcHJvdmUsXHJcbiAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcclxuICAgICAgICAgICAgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldEV4Y2hhbmdlUHJveHlBZGRyZXNzKCksXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBpc1JlcXVpcmVkID0gYWxsb3dhbmNlLmx0ZShzZWxsQW1vdW50KTtcclxuICAgICAgICBpZiAoIWlzUmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlzUmVxdWlyZWQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBnYXNsZXNzQXBwcm92YWwgPSBhd2FpdCB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZ2V0R2FzbGVzc0FwcHJvdmFsQXN5bmMoXHJcbiAgICAgICAgICAgIHRoaXMuX2NoYWluSWQsXHJcbiAgICAgICAgICAgIHRva2VuVG9BcHByb3ZlLFxyXG4gICAgICAgICAgICB0YWtlckFkZHJlc3MsXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBpc0dhc2xlc3NBdmFpbGFibGUgPSBnYXNsZXNzQXBwcm92YWwgIT09IG51bGw7XHJcbiAgICAgICAgaWYgKCFpc0dhc2xlc3NBdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlzUmVxdWlyZWQsXHJcbiAgICAgICAgICAgICAgICBpc0dhc2xlc3NBdmFpbGFibGUsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc1JlcXVpcmVkLFxyXG4gICAgICAgICAgICBpc0dhc2xlc3NBdmFpbGFibGUsXHJcbiAgICAgICAgICAgIHR5cGU6IGdhc2xlc3NBcHByb3ZhbC5raW5kLFxyXG4gICAgICAgICAgICBlaXA3MTI6IGdhc2xlc3NBcHByb3ZhbC5laXA3MTIsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0U3RhdHVzQXN5bmModHJhZGVIYXNoOiBzdHJpbmcpOiBQcm9taXNlPFN0YXR1c1Jlc3BvbnNlIHwgbnVsbD4ge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybVN1Ym1pc3Npb25zID0gKFxyXG4gICAgICAgICAgICBzdWJtaXNzaW9uczogUmZxbVYyVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5W10gfCBNZXRhVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5W10sXHJcbiAgICAgICAgKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGBfdHJhbnNmb3JtVHJhbnNhY3Rpb25TdWJtaXNzaW9uYCBpcyBhIHN0YXRpYyBtZXRob2Qgc28gbm8tdW5ib3VuZC1tZXRob2QgZG9lcyBub3QgYXBwbHkgaGVyZVxyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW5ib3VuZC1tZXRob2RcclxuICAgICAgICAgICAgcmV0dXJuIHN1Ym1pc3Npb25zLm1hcChSZnFtU2VydmljZS5fdHJhbnNmb3JtVHJhbnNhY3Rpb25TdWJtaXNzaW9uKS5mbGF0TWFwKChzKSA9PiAocyA/IHMgOiBbXSkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGpvYiA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgdGhpcy5fZGJVdGlscy5maW5kVjJKb2JCeU9yZGVySGFzaEFzeW5jKHRyYWRlSGFzaCksXHJcbiAgICAgICAgICAgIHRoaXMuX2RiVXRpbHMuZmluZE1ldGFUcmFuc2FjdGlvbkpvYkJ5TWV0YVRyYW5zYWN0aW9uSGFzaEFzeW5jKHRyYWRlSGFzaCksXHJcbiAgICAgICAgXSkudGhlbigoam9icykgPT4gam9icy5maW5kKCh4KSA9PiB4KSk7XHJcblxyXG4gICAgICAgIGlmICgham9iKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGV4cGlyeSB9ID0gam9iO1xyXG5cclxuICAgICAgICBpZiAoc3RhdHVzID09PSBSZnFtSm9iU3RhdHVzLlBlbmRpbmdFbnF1ZXVlZCAmJiBleHBpcnkubXVsdGlwbGllZEJ5KE9ORV9TRUNPTkRfTVMpLmx0KERhdGUubm93KCkpKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSB3b3JrZXJzIGFyZSBkZWFkL29uIHZhY2F0aW9uIGFuZCB0aGUgZXhwaXJhdGlvbiB0aW1lIGhhcyBwYXNzZWRcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN0YXR1czogJ2ZhaWxlZCcsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgLi4uKFJFQVNPTl9PTl9TVEFUVVNfRVJST1JfUkVTUE9OU0VfRU5BQkxFRCAmJiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBKb2JGYWlsdXJlUmVhc29uLk9yZGVyRXhwaXJlZCxcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdHJhZGVUcmFuc2FjdGlvblN1Ym1pc3Npb25zID1cclxuICAgICAgICAgICAgam9iLmtpbmQgPT09ICdyZnFtX3YyX2pvYidcclxuICAgICAgICAgICAgICAgID8gYXdhaXQgdGhpcy5fZGJVdGlscy5maW5kVjJUcmFuc2FjdGlvblN1Ym1pc3Npb25zQnlPcmRlckhhc2hBc3luYyhcclxuICAgICAgICAgICAgICAgICAgICAgIGpvYi5vcmRlckhhc2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZS5UcmFkZSxcclxuICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgOiBhd2FpdCB0aGlzLl9kYlV0aWxzLmZpbmRNZXRhVHJhbnNhY3Rpb25TdWJtaXNzaW9uc0J5Sm9iSWRBc3luYyhcclxuICAgICAgICAgICAgICAgICAgICAgIGpvYi5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgIFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25UeXBlLlRyYWRlLFxyXG4gICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IHNob3VsZEluY2x1ZGVBcHByb3ZhbCA9ICEham9iLmFwcHJvdmFsO1xyXG4gICAgICAgIGxldCBhcHByb3ZhbFRyYW5zYWN0aW9uU3VibWlzc2lvbnM6IFJmcW1WMlRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eVtdIHwgTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eVtdID1cclxuICAgICAgICAgICAgW107XHJcbiAgICAgICAgaWYgKHNob3VsZEluY2x1ZGVBcHByb3ZhbCkge1xyXG4gICAgICAgICAgICBhcHByb3ZhbFRyYW5zYWN0aW9uU3VibWlzc2lvbnMgPVxyXG4gICAgICAgICAgICAgICAgam9iLmtpbmQgPT09ICdyZnFtX3YyX2pvYidcclxuICAgICAgICAgICAgICAgICAgICA/IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZFYyVHJhbnNhY3Rpb25TdWJtaXNzaW9uc0J5T3JkZXJIYXNoQXN5bmMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgam9iLm9yZGVySGFzaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZS5BcHByb3ZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICA6IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZE1ldGFUcmFuc2FjdGlvblN1Ym1pc3Npb25zQnlKb2JJZEFzeW5jKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGpvYi5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZS5BcHByb3ZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xyXG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuUGVuZGluZ0VucXVldWVkOlxyXG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuUGVuZGluZ1Byb2Nlc3Npbmc6XHJcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5QZW5kaW5nTGFzdExvb2tBY2NlcHRlZDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ3BlbmRpbmcnLCB0cmFuc2FjdGlvbnM6IFtdIH07XHJcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5QZW5kaW5nU3VibWl0dGVkOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6ICdzdWJtaXR0ZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uczogdHJhbnNmb3JtU3VibWlzc2lvbnModHJhZGVUcmFuc2FjdGlvblN1Ym1pc3Npb25zKSxcclxuICAgICAgICAgICAgICAgICAgICAuLi4oc2hvdWxkSW5jbHVkZUFwcHJvdmFsICYmIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwcm92YWxUcmFuc2FjdGlvbnM6IHRyYW5zZm9ybVN1Ym1pc3Npb25zKGFwcHJvdmFsVHJhbnNhY3Rpb25TdWJtaXNzaW9ucyksXHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuRmFpbGVkRXRoQ2FsbEZhaWxlZDpcclxuICAgICAgICAgICAgY2FzZSBSZnFtSm9iU3RhdHVzLkZhaWxlZEV4cGlyZWQ6XHJcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRMYXN0TG9va0RlY2xpbmVkOlxyXG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuRmFpbGVkUHJlc2lnblZhbGlkYXRpb25GYWlsZWQ6XHJcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRSZXZlcnRlZENvbmZpcm1lZDpcclxuICAgICAgICAgICAgY2FzZSBSZnFtSm9iU3RhdHVzLkZhaWxlZFJldmVydGVkVW5jb25maXJtZWQ6XHJcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRTaWduRmFpbGVkOlxyXG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuRmFpbGVkU3VibWl0RmFpbGVkOlxyXG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuRmFpbGVkVmFsaWRhdGlvbk5vQ2FsbERhdGE6XHJcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRWYWxpZGF0aW9uTm9GZWU6XHJcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRWYWxpZGF0aW9uTm9NYWtlclVyaTpcclxuICAgICAgICAgICAgY2FzZSBSZnFtSm9iU3RhdHVzLkZhaWxlZFZhbGlkYXRpb25Ob09yZGVyOlxyXG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuRmFpbGVkVmFsaWRhdGlvbk5vVGFrZXJTaWduYXR1cmU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ2ZhaWxlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiB0cmFuc2Zvcm1TdWJtaXNzaW9ucyh0cmFkZVRyYW5zYWN0aW9uU3VibWlzc2lvbnMpLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLihzaG91bGRJbmNsdWRlQXBwcm92YWwgJiYge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHByb3ZhbFRyYW5zYWN0aW9uczogdHJhbnNmb3JtU3VibWlzc2lvbnMoYXBwcm92YWxUcmFuc2FjdGlvblN1Ym1pc3Npb25zKSxcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAuLi4oUkVBU09OX09OX1NUQVRVU19FUlJPUl9SRVNQT05TRV9FTkFCTEVEICYmIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBSZnFtU2VydmljZS5fam9iRmFpbHVyZVN0YXR1c1RvUmVhc29uKHN0YXR1cyksXHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuU3VjY2VlZGVkQ29uZmlybWVkOlxyXG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuU3VjY2VlZGVkVW5jb25maXJtZWQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzID09PSBSZnFtSm9iU3RhdHVzLlN1Y2NlZWRlZFVuY29uZmlybWVkID8gJ3N1Y2NlZWRlZCcgOiAnY29uZmlybWVkJyxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmZxbVNlcnZpY2UuX2dldFN1Y2Nlc3NmdWxUcmFuc2FjdGlvblN1Ym1pc3Npb25EZXRhaWxzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IGpvYi5nZXRIYXNoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZS5UcmFkZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3VibXNzaW9uczogdHJhZGVUcmFuc2FjdGlvblN1Ym1pc3Npb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLihzaG91bGRJbmNsdWRlQXBwcm92YWwgJiYge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHByb3ZhbFRyYW5zYWN0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmZxbVNlcnZpY2UuX2dldFN1Y2Nlc3NmdWxUcmFuc2FjdGlvblN1Ym1pc3Npb25EZXRhaWxzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBqb2IuZ2V0SGFzaCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25UeXBlLkFwcHJvdmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3VibXNzaW9uczogYXBwcm92YWxUcmFuc2FjdGlvblN1Ym1pc3Npb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgKChfeDogbmV2ZXIpOiBuZXZlciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlYWNoYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfSkoc3RhdHVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIGNoZWNrcyB0byBkZXRlcm1pbmUgdGhlIGhlYWx0aCBvZiB0aGUgUkZRbSBzeXN0ZW0uIFRoZSByZXN1bHRzIG1heSBiZSBkaXN0aWxsZWQgdG8gYSBmb3JtYXQgbmVlZGVkIGJ5IGludGVncmF0b3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcnVuSGVhbHRoQ2hlY2tBc3luYygpOiBQcm9taXNlPEhlYWx0aENoZWNrUmVzdWx0PiB7XHJcbiAgICAgICAgY29uc3QgaGVhcnRiZWF0cyA9IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZFJmcW1Xb3JrZXJIZWFydGJlYXRzQXN5bmModGhpcy5fY2hhaW5JZCk7XHJcbiAgICAgICAgbGV0IGdhc1ByaWNlOiBCaWdOdW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZ2FzUHJpY2UgPSBhd2FpdCB0aGlzLl9mZWVTZXJ2aWNlLmdldEdhc1ByaWNlRXN0aW1hdGlvbkFzeW5jKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oeyBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfSwgJ0ZhaWxlZCB0byBnZXQgZ2FzIHByaWNlIGZvciBoZWFsdGggY2hlY2snKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVIZWFsdGhDaGVja0FzeW5jKFxyXG4gICAgICAgICAgICBSRlFNX01BSU5URU5BTkNFX01PREUsXHJcbiAgICAgICAgICAgIHRoaXMuX3JmcU1ha2VyTWFuYWdlci5nZXRSZnFtVjJNYWtlck9mZmVyaW5ncygpLFxyXG4gICAgICAgICAgICB0aGlzLl9zcXNQcm9kdWNlcixcclxuICAgICAgICAgICAgaGVhcnRiZWF0cyxcclxuICAgICAgICAgICAgdGhpcy5fY2hhaW5JZCxcclxuICAgICAgICAgICAgZ2FzUHJpY2UsXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyBhbmQgZW5xdWV1ZXMgdGhlIFRha2VyIFNpZ25lZCBPdGMgT3JkZXIgd2l0aCBhcHByb3ZhbCBmb3Igc3VibWlzc2lvbi5cclxuICAgICAqIENhbiBhbHNvIGJlIHVzZWQgdG8gc3VibWl0IG9yZGVyIHdpdGhvdXQgYXBwcm92YWwgaWYgYXBwcm92YWwgcGFyYW1zIGFyZSBub3Qgc3VwcGxpZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBzdWJtaXRUYWtlclNpZ25lZE90Y09yZGVyV2l0aEFwcHJvdmFsQXN5bmM8XHJcbiAgICAgICAgVCBleHRlbmRzIEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0IHwgUGVybWl0RWlwNzEyQ29udGV4dCxcclxuICAgID4ocGFyYW1zOiBTdWJtaXRSZnFtU2lnbmVkUXVvdGVXaXRoQXBwcm92YWxQYXJhbXM8VD4pOiBQcm9taXNlPFN1Ym1pdFJmcW1TaWduZWRRdW90ZVdpdGhBcHByb3ZhbFJlc3BvbnNlPiB7XHJcbiAgICAgICAgbGV0IHN1Ym1pdFJmcW1TaWduZWRRdW90ZVdpdGhBcHByb3ZhbFJlczogU3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUmVzcG9uc2U7XHJcbiAgICAgICAgY29uc3QgeyBhcHByb3ZhbCwgdHJhZGUgfSA9IHBhcmFtcztcclxuXHJcbiAgICAgICAgY29uc3QgcmZxbUFwcHJvdmFsT3B0cyA9IGFwcHJvdmFsXHJcbiAgICAgICAgICAgID8gYXdhaXQgdGhpcy5jcmVhdGVBcHByb3ZhbEFzeW5jKGFwcHJvdmFsLCB0cmFkZS5vcmRlci5nZXRIYXNoKCksIHRyYWRlLm9yZGVyLnRha2VyVG9rZW4pXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XHJcbiAgICAgICAgc3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUmVzID0gYXdhaXQgdGhpcy5zdWJtaXRUYWtlclNpZ25lZE90Y09yZGVyQXN5bmModHJhZGUsIHJmcW1BcHByb3ZhbE9wdHMpO1xyXG5cclxuICAgICAgICByZXR1cm4gc3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUmVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2Vzc2VzIGEgc2lnbmVkIGFwcHJvdmFsIHNlbnQgdG8gdGhlIHN1Ym1pc3Npb24gZW5kcG9pbnQgaW4gb3JkZXIgdG9cclxuICAgICAqIGNyZWF0ZSB0aGUgYXBwcm92YWwgZGF0YSBuZWVkZWQgYnkgdGhlIGpvYi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGNyZWF0ZUFwcHJvdmFsQXN5bmM8VCBleHRlbmRzIEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0IHwgUGVybWl0RWlwNzEyQ29udGV4dD4oXHJcbiAgICAgICAgYXBwcm92YWw6IFN1Ym1pdEFwcHJvdmFsUGFyYW1zPFQ+LFxyXG4gICAgICAgIHRyYWRlSGFzaDogc3RyaW5nLFxyXG4gICAgICAgIHRha2VyVG9rZW46IHN0cmluZyxcclxuICAgICk6IFByb21pc2U8UmZxbVYySm9iQXBwcm92YWxPcHRzPiB7XHJcbiAgICAgICAgbGV0IHsgc2lnbmF0dXJlIH0gPSBhcHByb3ZhbDtcclxuXHJcbiAgICAgICAgLy8gdmFsaWRhdGUgYW5kIGNvbnZlcnQgRUlQNzEyIGNvbnRleHQgdG8gY29ycmVzcG9uZGluZyBBcHByb3ZhbCBvYmplY3RcclxuICAgICAgICBjb25zdCBwYXJzZWRBcHByb3ZhbCA9IHRoaXMuX2NvbnZlcnRFSVA3MTJDb250ZXh0VG9BcHByb3ZhbChhcHByb3ZhbC5laXA3MTIsIHRyYWRlSGFzaCk7XHJcblxyXG4gICAgICAgIC8vIHBhZCBhcHByb3ZhbCBzaWduYXR1cmUgaWYgdGhlcmUgYXJlIG1pc3NpbmcgYnl0ZXNcclxuICAgICAgICBjb25zdCBwYWRkZWRTaWduYXR1cmUgPSBwYWRTaWduYXR1cmUoc2lnbmF0dXJlKTtcclxuICAgICAgICBpZiAocGFkZGVkU2lnbmF0dXJlLnIgIT09IHNpZ25hdHVyZS5yIHx8IHBhZGRlZFNpZ25hdHVyZS5zICE9PSBzaWduYXR1cmUucykge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihcclxuICAgICAgICAgICAgICAgIHsgdHJhZGVIYXNoLCByOiBwYWRkZWRTaWduYXR1cmUuciwgczogcGFkZGVkU2lnbmF0dXJlLnMgfSxcclxuICAgICAgICAgICAgICAgICdHb3QgYXBwcm92YWwgc2lnbmF0dXJlIHdpdGggbWlzc2luZyBieXRlcycsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IHBhZGRlZFNpZ25hdHVyZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHBlcmZvcm0gYW4gZXRoX2NhbGwgb24gdGhlIGFwcHJvdmFsIG9iamVjdCBhbmQgc2lnbmF0dXJlXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgYXBwcm92YWxDYWxsZGF0YSA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZW5lcmF0ZUFwcHJvdmFsQ2FsbGRhdGFBc3luYyhcclxuICAgICAgICAgICAgICAgIHRha2VyVG9rZW4sXHJcbiAgICAgICAgICAgICAgICBwYXJzZWRBcHByb3ZhbCxcclxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgYXdhaXQgcmV0cnkoXHJcbiAgICAgICAgICAgICAgICBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGBlc3RpbWF0ZUdhc0ZvckFzeW5jYCB0byBzaW11bGF0ZSB0aGUgdHJhbnNhY3Rpb24uIEluIGV0aGVycy5qcywgcHJvdmlkZXIuY2FsbCBhbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyBwcm92aWRlci5zZW5kKCdldGhfY2FsbCcsIC4uLikgbWlnaHQgbm90IHRocm93IGV4Y2VwdGlvbiBhbmQgdGhlIGJlaGF2aW9yIG1pZ2h0IGJlIGRlcGVuZGVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIHByb3ZpZGVycy4gUmV2aXNpdCB0aGlzIGxhdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5lc3RpbWF0ZUdhc0ZvckFzeW5jKHsgdG86IHRha2VyVG9rZW4sIGRhdGE6IGFwcHJvdmFsQ2FsbGRhdGEgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5OiBPTkVfU0VDT05EX01TLFxyXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcjogMSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhBdHRlbXB0czogMyxcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcjogKGVycm9yLCBjb250ZXh0LCBfb3B0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGF0dGVtcHROdW06IGF0dGVtcHROdW1iZXIsIGF0dGVtcHRzUmVtYWluaW5nIH0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRlbXB0TnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzUmVtYWluaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhZGVIYXNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdFcnJvciBkdXJpbmcgZXRoX2NhbGwgYXBwcm92YWwgdmFsaWRhdGlvbi4gUmV0cnlpbmcuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoeyBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfSwgJ0V0aCBjYWxsIGFwcHJvdmFsIHZhbGlkYXRpb24gZmFpbGVkJyk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXRoIGNhbGwgYXBwcm92YWwgdmFsaWRhdGlvbiBmYWlsZWQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGFwcHJvdmFsOiBwYXJzZWRBcHByb3ZhbCxcclxuICAgICAgICAgICAgYXBwcm92YWxTaWduYXR1cmU6IHNpZ25hdHVyZSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGVzIGFuZCBlbnF1ZXVlcyB0aGUgVGFrZXIgU2lnbmVkIE90YyBPcmRlciBmb3Igc3VibWlzc2lvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgc3VibWl0VGFrZXJTaWduZWRPdGNPcmRlckFzeW5jKFxyXG4gICAgICAgIHBhcmFtczogT3RjT3JkZXJTdWJtaXRSZnFtU2lnbmVkUXVvdGVQYXJhbXMsXHJcbiAgICAgICAgcmZxbUFwcHJvdmFsT3B0cz86IFJmcW1WMkpvYkFwcHJvdmFsT3B0cyxcclxuICAgICk6IFByb21pc2U8T3RjT3JkZXJTdWJtaXRSZnFtU2lnbmVkUXVvdGVSZXNwb25zZT4ge1xyXG4gICAgICAgIGNvbnN0IHsgb3JkZXIgfSA9IHBhcmFtcztcclxuICAgICAgICBsZXQgeyBzaWduYXR1cmU6IHRha2VyU2lnbmF0dXJlIH0gPSBwYXJhbXM7XHJcbiAgICAgICAgY29uc3Qgb3JkZXJIYXNoID0gb3JkZXIuZ2V0SGFzaCgpO1xyXG4gICAgICAgIGNvbnN0IHRha2VyQWRkcmVzcyA9IG9yZGVyLnRha2VyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3QgbWFrZXJBZGRyZXNzID0gb3JkZXIubWFrZXIudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBjb25zdCB0YWtlclRva2VuID0gb3JkZXIudGFrZXJUb2tlbi50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGNvbnN0IG1ha2VyVG9rZW4gPSBvcmRlci5tYWtlclRva2VuLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgLy8gY2hlY2sgdGhhdCB0aGUgb3JkZXJIYXNoIGlzIGluZGVlZCBhIHJlY29nbml6ZWQgcXVvdGVcclxuICAgICAgICBjb25zdCBxdW90ZSA9IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZFYyUXVvdGVCeU9yZGVySGFzaEFzeW5jKG9yZGVySGFzaCk7XHJcbiAgICAgICAgaWYgKCFxdW90ZSkge1xyXG4gICAgICAgICAgICBSRlFNX1NJR05FRF9RVU9URV9OT1RfRk9VTkQuaW5jKCk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKCdxdW90ZSBub3QgZm91bmQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHZhbGlkYXRlIHRoYXQgdGhlIGV4cGlyYXRpb24gd2luZG93IGlzIGxvbmcgZW5vdWdoIHRvIGZpbGwgcXVvdGVcclxuICAgICAgICBjb25zdCBjdXJyZW50VGltZU1zID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgaWYgKCFvcmRlci5leHBpcnkudGltZXMoT05FX1NFQ09ORF9NUykuaXNHcmVhdGVyVGhhbihjdXJyZW50VGltZU1zICsgdGhpcy5fbWluRXhwaXJ5RHVyYXRpb25NcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdleHBpcnlBbmROb25jZScsXHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogVmFsaWRhdGlvbkVycm9yQ29kZXMuRmllbGRJbnZhbGlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogYG9yZGVyIHdpbGwgZXhwaXJlIHRvbyBzb29uYCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdmFsaWRhdGUgdGhhdCB0aGVyZSBpcyBub3QgYSBwZW5kaW5nIHRyYW5zYWN0aW9uIGZvciB0aGlzIHRha2VyIGFuZCB0YWtlciB0b2tlblxyXG4gICAgICAgIGNvbnN0IHBlbmRpbmdKb2JzID0gYXdhaXQgdGhpcy5fZGJVdGlscy5maW5kVjJKb2JzV2l0aFN0YXR1c2VzQXN5bmMoW1xyXG4gICAgICAgICAgICBSZnFtSm9iU3RhdHVzLlBlbmRpbmdFbnF1ZXVlZCxcclxuICAgICAgICAgICAgUmZxbUpvYlN0YXR1cy5QZW5kaW5nUHJvY2Vzc2luZyxcclxuICAgICAgICAgICAgUmZxbUpvYlN0YXR1cy5QZW5kaW5nTGFzdExvb2tBY2NlcHRlZCxcclxuICAgICAgICAgICAgUmZxbUpvYlN0YXR1cy5QZW5kaW5nU3VibWl0dGVkLFxyXG4gICAgICAgIF0pO1xyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHBlbmRpbmdKb2JzLnNvbWUoXHJcbiAgICAgICAgICAgICAgICAoam9iKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIGpvYi5vcmRlcj8ub3JkZXIudGFrZXIudG9Mb3dlckNhc2UoKSA9PT0gcXVvdGUub3JkZXI/Lm9yZGVyLnRha2VyLnRvTG93ZXJDYXNlKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICBqb2Iub3JkZXI/Lm9yZGVyLnRha2VyVG9rZW4udG9Mb3dlckNhc2UoKSA9PT0gcXVvdGUub3JkZXI/Lm9yZGVyLnRha2VyVG9rZW4udG9Mb3dlckNhc2UoKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyIGxvZ2ljIGhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgdGhlIHNhbWUgb3JkZXIgaXMgc3VibWl0dGVkIHR3aWNlXHJcbiAgICAgICAgICAgICAgICAgICAgam9iLm9yZGVySGFzaCAhPT0gcXVvdGUub3JkZXJIYXNoLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIFJGUU1fVEFLRVJfQU5EX1RBS0VSVE9LRU5fVFJBREVfRVhJU1RTLmxhYmVscyh0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLmluYygpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9vTWFueVJlcXVlc3RzRXJyb3IoJ2EgcGVuZGluZyB0cmFkZSBmb3IgdGhpcyB0YWtlciBhbmQgdGFrZXJ0b2tlbiBhbHJlYWR5IGV4aXN0cycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW4gdGhlIHVubGlrZWx5IGV2ZW50IHRoYXQgdGFrZXJzIHN1Ym1pdCBhIHNpZ25hdHVyZSB3aXRoIGEgbWlzc2luZyBieXRlLCBwYWQgdGhlIHNpZ25hdHVyZS5cclxuICAgICAgICBjb25zdCBwYWRkZWRTaWduYXR1cmUgPSBwYWRTaWduYXR1cmUodGFrZXJTaWduYXR1cmUpO1xyXG4gICAgICAgIGlmIChwYWRkZWRTaWduYXR1cmUuciAhPT0gdGFrZXJTaWduYXR1cmUuciB8fCBwYWRkZWRTaWduYXR1cmUucyAhPT0gdGFrZXJTaWduYXR1cmUucykge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihcclxuICAgICAgICAgICAgICAgIHsgb3JkZXJIYXNoLCByOiBwYWRkZWRTaWduYXR1cmUuciwgczogcGFkZGVkU2lnbmF0dXJlLnMgfSxcclxuICAgICAgICAgICAgICAgICdHb3QgdGFrZXIgc2lnbmF0dXJlIHdpdGggbWlzc2luZyBieXRlcycsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRha2VyU2lnbmF0dXJlID0gcGFkZGVkU2lnbmF0dXJlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdmFsaWRhdGUgdGhhdCB0aGUgZ2l2ZW4gdGFrZXIgc2lnbmF0dXJlIGlzIHZhbGlkXHJcbiAgICAgICAgY29uc3Qgc2lnbmVyQWRkcmVzcyA9IGdldFNpZ25lckZyb21IYXNoKG9yZGVySGFzaCwgdGFrZXJTaWduYXR1cmUpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKHNpZ25lckFkZHJlc3MgIT09IHRha2VyQWRkcmVzcykge1xyXG4gICAgICAgICAgICBsb2dnZXIud2Fybih7IHNpZ25lckFkZHJlc3MsIHRha2VyQWRkcmVzcywgb3JkZXJIYXNoIH0sICdTaWduYXR1cmUgaXMgaW52YWxpZCcpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ3NpZ25hdHVyZScsXHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogVmFsaWRhdGlvbkVycm9yQ29kZXMuSW52YWxpZFNpZ25hdHVyZU9ySGFzaCxcclxuICAgICAgICAgICAgICAgICAgICByZWFzb246IGBzaWduYXR1cmUgaXMgbm90IHZhbGlkYCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCBvcmRlciBpcyBmaWxsYWJsZSBieSBib3RoIHRoZSBtYWtlciBhbmQgdGhlIHRha2VyIGFjY29yZGluZyB0byBiYWxhbmNlcyBhbmQvb3IgYWxsb3dhbmNlcy5cclxuICAgICAgICAvLyBJZiByZnFtQXBwcm92YWxPcHRzIGlzIG5vdCBwYXNzZWQsIGFsbG93YW5jZXMgYXJlIG5vdCBjaGVja2VkIGF0IHRoaXMgc3RhZ2Ugc2luY2UgZ2FzbGVzcyBhcHByb3ZhbCBoYXMgbm90IGJlZW4gZG9uZSB5ZXQuXHJcbiAgICAgICAgY29uc3QgW21ha2VyQmFsYW5jZV0gPSBhd2FpdCB0aGlzLl9yZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UuZ2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmModGhpcy5fY2hhaW5JZCwgW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvd25lcjogbWFrZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgdG9rZW46IG1ha2VyVG9rZW4sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgY29uc3QgW3Rha2VyQmFsYW5jZV0gPSByZnFtQXBwcm92YWxPcHRzXHJcbiAgICAgICAgICAgID8gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldFRva2VuQmFsYW5jZXNBc3luYyh7IG93bmVyOiB0YWtlckFkZHJlc3MsIHRva2VuOiB0YWtlclRva2VuIH0pXHJcbiAgICAgICAgICAgIDogYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICBvd25lcjogdGFrZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICB0b2tlbjogdGFrZXJUb2tlbixcclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKG1ha2VyQmFsYW5jZS5sdChvcmRlci5tYWtlckFtb3VudCkgfHwgdGFrZXJCYWxhbmNlLmx0KG9yZGVyLnRha2VyQW1vdW50KSkge1xyXG4gICAgICAgICAgICBSRlFNX1NVQk1JVF9CQUxBTkNFX0NIRUNLX0ZBSUxFRC5sYWJlbHMobWFrZXJBZGRyZXNzLCB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLmluYygpO1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBtYWtlckJhbGFuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFrZXJCYWxhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ha2VyQWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICB0YWtlckFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJIYXNoLFxyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICdCYWxhbmNlIGNoZWNrIGZhaWxlZCB3aGlsZSB1c2VyIHdhcyBzdWJtaXR0aW5nJyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICduL2EnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFZhbGlkYXRpb25FcnJvckNvZGVzLkludmFsaWRPcmRlcixcclxuICAgICAgICAgICAgICAgICAgICByZWFzb246IGBvcmRlciBpcyBub3QgZmlsbGFibGVgLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBwcmVwYXJlIHRoZSBqb2JcclxuICAgICAgICBsZXQgcmZxbUpvYk9wdHM6IFJmcW1WMkpvYkNvbnN0cnVjdG9yT3B0cyA9IHtcclxuICAgICAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgICAgICAgICBvcmRlckhhc2g6IHF1b3RlLm9yZGVySGFzaCEsXHJcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgZXhwaXJ5OiBvcmRlci5leHBpcnksXHJcbiAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuX2NoYWluSWQsXHJcbiAgICAgICAgICAgIGludGVncmF0b3JJZDogcXVvdGUuaW50ZWdyYXRvcklkID8gcXVvdGUuaW50ZWdyYXRvcklkIDogbnVsbCxcclxuICAgICAgICAgICAgbWFrZXJVcmk6IHF1b3RlLm1ha2VyVXJpLFxyXG4gICAgICAgICAgICBzdGF0dXM6IFJmcW1Kb2JTdGF0dXMuUGVuZGluZ0VucXVldWVkLFxyXG4gICAgICAgICAgICBmZWU6IHF1b3RlLmZlZSxcclxuICAgICAgICAgICAgb3JkZXI6IHF1b3RlLm9yZGVyLFxyXG4gICAgICAgICAgICB0YWtlclNpZ25hdHVyZSxcclxuICAgICAgICAgICAgYWZmaWxpYXRlQWRkcmVzczogcXVvdGUuYWZmaWxpYXRlQWRkcmVzcyxcclxuICAgICAgICAgICAgaXNVbndyYXA6IHF1b3RlLmlzVW53cmFwLFxyXG4gICAgICAgICAgICB0YWtlclNwZWNpZmllZFNpZGU6IHF1b3RlLnRha2VyU3BlY2lmaWVkU2lkZSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBpZiBhcHByb3ZhbCBvcHRzIGFyZSBzdXBwbGllZCwgYWRkIHBhcmFtcyB0byBqb2IgdGFibGVcclxuICAgICAgICBpZiAocmZxbUFwcHJvdmFsT3B0cykge1xyXG4gICAgICAgICAgICByZnFtSm9iT3B0cyA9IHtcclxuICAgICAgICAgICAgICAgIC4uLnJmcW1Kb2JPcHRzLFxyXG4gICAgICAgICAgICAgICAgLi4ucmZxbUFwcHJvdmFsT3B0cyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRoaXMgaW5zZXJ0IHdpbGwgZmFpbCBpZiBhIGpvYiBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQsIGVuc3VyaW5nXHJcbiAgICAgICAgLy8gdGhhdCBhIHNpZ25lZCBxdW90ZSBjYW5ub3QgYmUgcXVldWVkIHR3aWNlXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGpvYiBkYXRhIGlzIHBlcnNpc3RlZCB0byBQb3N0Z3JlcyBiZWZvcmUgcXVldWVpbmcgdGFza1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9kYlV0aWxzLndyaXRlVjJKb2JBc3luYyhyZnFtSm9iT3B0cyk7XHJcbiAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZW5xdWV1ZUpvYkFzeW5jKHF1b3RlLm9yZGVySGFzaCEsIEdhc2xlc3NUeXBlcy5PdGNPcmRlcik7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKHsgZXJyb3JNZXNzYWdlOiBlcnJvci5tZXNzYWdlIH0sICdGYWlsZWQgdG8gcXVldWUgdGhlIHF1b3RlIGZvciBzdWJtaXNzaW9uLicpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxTZXJ2ZXJFcnJvcihcclxuICAgICAgICAgICAgICAgIGBmYWlsZWQgdG8gcXVldWUgdGhlIHF1b3RlIGZvciBzdWJtaXNzaW9uLCBpdCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gc3VibWl0dGVkYCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IEdhc2xlc3NUeXBlcy5PdGNPcmRlcixcclxuICAgICAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgICAgICAgICBvcmRlckhhc2g6IHF1b3RlLm9yZGVySGFzaCEsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byByZXRyaWV2ZSBxdW90ZSBjb250ZXh0LCBiYXNlZCBvbiBlaXRoZXIgaW5kaWNhdGl2ZSBvciBmaXJtIHF1b3RlIHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfcmV0cmlldmVRdW90ZUNvbnRleHQoXHJcbiAgICAgICAgcGFyYW1zOiBGZXRjaEluZGljYXRpdmVRdW90ZVBhcmFtcyB8IEZldGNoRmlybVF1b3RlUGFyYW1zLFxyXG4gICAgICAgIGlzRmlybTogYm9vbGVhbixcclxuICAgICk6IFF1b3RlQ29udGV4dCB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICBzZWxsQW1vdW50OiB0YWtlckFtb3VudCxcclxuICAgICAgICAgICAgYnV5QW1vdW50OiBtYWtlckFtb3VudCxcclxuICAgICAgICAgICAgc2VsbFRva2VuOiB0YWtlclRva2VuLFxyXG4gICAgICAgICAgICBidXlUb2tlbjogb3JpZ2luYWxNYWtlclRva2VuLFxyXG4gICAgICAgICAgICB0YWtlckFkZHJlc3MsXHJcbiAgICAgICAgICAgIHNlbGxUb2tlbkRlY2ltYWxzOiB0YWtlclRva2VuRGVjaW1hbHMsXHJcbiAgICAgICAgICAgIGJ1eVRva2VuRGVjaW1hbHM6IG1ha2VyVG9rZW5EZWNpbWFscyxcclxuICAgICAgICAgICAgaW50ZWdyYXRvcixcclxuICAgICAgICAgICAgYWZmaWxpYXRlQWRkcmVzcyxcclxuICAgICAgICB9ID0gcGFyYW1zO1xyXG5cclxuICAgICAgICBjb25zdCBpc1Vud3JhcCA9IG9yaWdpbmFsTWFrZXJUb2tlbiA9PT0gdGhpcy5fbmF0aXZlVG9rZW5BZGRyZXNzO1xyXG4gICAgICAgIGNvbnN0IGlzU2VsbGluZyA9IHRha2VyQW1vdW50ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXHJcbiAgICAgICAgY29uc3QgYXNzZXRGaWxsQW1vdW50ID0gaXNTZWxsaW5nID8gdGFrZXJBbW91bnQhIDogbWFrZXJBbW91bnQhO1xyXG5cclxuICAgICAgICBsZXQgbWFrZXJUb2tlbiA9IG9yaWdpbmFsTWFrZXJUb2tlbjtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsTWFrZXJUb2tlbiBpcyB0aGUgbmF0aXZlIHRva2VuLCB3ZSB3aWxsIHRyYWRlIHRoZSB3cmFwcGVkIHZlcnNpb24gYW5kIHVud3JhcCBhdCB0aGUgZW5kXHJcbiAgICAgICAgaWYgKGlzVW53cmFwKSB7XHJcbiAgICAgICAgICAgIG1ha2VyVG9rZW4gPSB0aGlzLl9uYXRpdmVXcmFwcGVkVG9rZW5BZGRyZXNzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgd29ya2Zsb3c6ICdyZnFtJyxcclxuICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5fY2hhaW5JZCxcclxuICAgICAgICAgICAgaXNGaXJtLFxyXG4gICAgICAgICAgICB0YWtlckFtb3VudCxcclxuICAgICAgICAgICAgbWFrZXJBbW91bnQsXHJcbiAgICAgICAgICAgIHRha2VyVG9rZW4sXHJcbiAgICAgICAgICAgIG1ha2VyVG9rZW4sXHJcbiAgICAgICAgICAgIG9yaWdpbmFsTWFrZXJUb2tlbixcclxuICAgICAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgICAgICAgICB0YWtlckFkZHJlc3M6IHRha2VyQWRkcmVzcyEsXHJcbiAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cclxuICAgICAgICAgICAgdHJhZGVyOiB0YWtlckFkZHJlc3MhLFxyXG4gICAgICAgICAgICB0eE9yaWdpbjogdGhpcy5fcmVnaXN0cnlBZGRyZXNzLFxyXG4gICAgICAgICAgICB0YWtlclRva2VuRGVjaW1hbHMsXHJcbiAgICAgICAgICAgIG1ha2VyVG9rZW5EZWNpbWFscyxcclxuICAgICAgICAgICAgaW50ZWdyYXRvcixcclxuICAgICAgICAgICAgYWZmaWxpYXRlQWRkcmVzcyxcclxuICAgICAgICAgICAgaXNVbndyYXAsXHJcbiAgICAgICAgICAgIGlzU2VsbGluZyxcclxuICAgICAgICAgICAgYXNzZXRGaWxsQW1vdW50LFxyXG4gICAgICAgICAgICBmZWVNb2RlbFZlcnNpb246IHRoaXMuX2ZlZU1vZGVsVmVyc2lvbixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGZldGNoIGluZGljYXRpdmUgcXVvdGVzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIF9mZXRjaEluZGljYXRpdmVRdW90ZXNBc3luYyhxdW90ZUNvbnRleHQ6IFF1b3RlQ29udGV4dCwgZmVlOiBGZWUpOiBQcm9taXNlPEluZGljYXRpdmVRdW90ZVtdPiB7XHJcbiAgICAgICAgLy8gRXh0cmFjdCBxdW90ZSBjb250ZXh0XHJcbiAgICAgICAgY29uc3QgeyBpc1NlbGxpbmcsIGFzc2V0RmlsbEFtb3VudCwgdGFrZXJUb2tlbiwgbWFrZXJUb2tlbiwgaW50ZWdyYXRvciB9ID0gcXVvdGVDb250ZXh0O1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgT3RjIE9yZGVyIHJlcXVlc3Qgb3B0aW9uc1xyXG4gICAgICAgIGNvbnN0IG90Y09yZGVyUGFyYW1zID0gUXVvdGVTZXJ2ZXJDbGllbnQubWFrZVF1ZXJ5UGFyYW1ldGVycyh7XHJcbiAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuX2NoYWluSWQsXHJcbiAgICAgICAgICAgIHR4T3JpZ2luOiB0aGlzLl9yZWdpc3RyeUFkZHJlc3MsXHJcbiAgICAgICAgICAgIHRha2VyQWRkcmVzczogTlVMTF9BRERSRVNTLFxyXG4gICAgICAgICAgICBtYXJrZXRPcGVyYXRpb246IGlzU2VsbGluZyA/IE1hcmtldE9wZXJhdGlvbi5TZWxsIDogTWFya2V0T3BlcmF0aW9uLkJ1eSxcclxuICAgICAgICAgICAgYnV5VG9rZW5BZGRyZXNzOiBtYWtlclRva2VuLFxyXG4gICAgICAgICAgICBzZWxsVG9rZW5BZGRyZXNzOiB0YWtlclRva2VuLFxyXG4gICAgICAgICAgICBhc3NldEZpbGxBbW91bnQsXHJcbiAgICAgICAgICAgIGlzTGFzdExvb2s6IHRydWUsXHJcbiAgICAgICAgICAgIGZlZSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gSWYgTExSIENvb2xkb3duIGlzIGVuYWJsZWQsIGZpbHRlciBvdXQgbWFrZXJzIGluIGNvb2xkb3duIGJlZm9yZSBxdWVyeWluZyB0aGUgcXVvdGUgc2VydmVyXHJcbiAgICAgICAgbGV0IG1ha2VySWRzSW5Db29sZG93bjogc3RyaW5nW10gfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKEVOQUJMRV9MTFJfQ09PTERPV04pIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIG1ha2VySWRzSW5Db29sZG93biA9IGF3YWl0IHRoaXMuX2NhY2hlQ2xpZW50LmdldE1ha2Vyc0luQ29vbGRvd25Gb3JQYWlyQXN5bmMoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhaW5JZCxcclxuICAgICAgICAgICAgICAgICAgICBtYWtlclRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgIHRha2VyVG9rZW4sXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgLy8gbG9nIGJsb2NrZWQgbWFrZXIgaWRzXHJcbiAgICAgICAgICAgICAgICBtYWtlcklkc0luQ29vbGRvd24ubWFwKChtYWtlcklkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgUkZRTV9NQUtFUl9CTE9DS0VEX0ZPUl9MTFJfQ09PTERPV04ubGFiZWxzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlcklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUGFpclN0cmluZyhtYWtlclRva2VuLCB0YWtlclRva2VuKSxcclxuICAgICAgICAgICAgICAgICAgICApLmluYygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlcklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZXJUb2tlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRha2VyVG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdNYWtlciBpcyBvbiBjb29sZG93biBkdWUgdG8gYSBiYWQgbGFzdCBsb29rIHJlamVjdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgeyBjaGFpbklkOiB0aGlzLl9jaGFpbklkLCBtYWtlclRva2VuLCB0YWtlclRva2VuLCBlcnJvck1lc3NhZ2U6IGUubWVzc2FnZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICdFbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBmaWx0ZXJpbmcgbWFrZXJzIG9uIExMUiBjb29sZG93bicsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBvdGNPcmRlck1ha2VyVXJpcyA9IHRoaXMuX3JmcU1ha2VyTWFuYWdlci5nZXRSZnFtVjJNYWtlclVyaXNGb3JQYWlyKFxyXG4gICAgICAgICAgICBtYWtlclRva2VuLFxyXG4gICAgICAgICAgICB0YWtlclRva2VuLFxyXG4gICAgICAgICAgICBpbnRlZ3JhdG9yLndoaXRlbGlzdE1ha2VySWRzIHx8IG51bGwsXHJcbiAgICAgICAgICAgIG1ha2VySWRzSW5Db29sZG93biB8fCBudWxsLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IHF1b3RlcyA9IGF3YWl0IHRoaXMuX3F1b3RlU2VydmVyQ2xpZW50LmJhdGNoR2V0UHJpY2VWMkFzeW5jKFxyXG4gICAgICAgICAgICBvdGNPcmRlck1ha2VyVXJpcyxcclxuICAgICAgICAgICAgaW50ZWdyYXRvcixcclxuICAgICAgICAgICAgb3RjT3JkZXJQYXJhbXMsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gTG9nIGFueSBxdW90ZXMgdGhhdCBhcmUgZm9yIHRoZSBpbmNvcnJlY3QgYW1vdW50XHJcbiAgICAgICAgcXVvdGVzLmZvckVhY2goKHF1b3RlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHF1b3RlZEFtb3VudCA9IGlzU2VsbGluZyA/IHF1b3RlLnRha2VyQW1vdW50IDogcXVvdGUubWFrZXJBbW91bnQ7XHJcbiAgICAgICAgICAgIGlmIChxdW90ZWRBbW91bnQuZXEoYXNzZXRGaWxsQW1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWNhdGlvblR5cGUgPSBxdW90ZWRBbW91bnQuZ3QoYXNzZXRGaWxsQW1vdW50KSA/ICdvdmVyZmlsbCcgOiAndW5kZXJmaWxsJztcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNTZWxsaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJPclVuZGVyOiBtb2RpZmljYXRpb25UeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZEFtb3VudDogYXNzZXRGaWxsQW1vdW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHF1b3RlZEFtb3VudCxcclxuICAgICAgICAgICAgICAgICAgICBxdW90ZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAnTWFrZXIgcmV0dXJuZWQgYW4gaW5jb3JyZWN0IGFtb3VudCcsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIFJGUU1fTU1fUkVUVVJORURfRElGRkVSRU5UX0FNT1VOVC5sYWJlbHMocXVvdGUubWFrZXJVcmksIHRoaXMuX2NoYWluSWQudG9TdHJpbmcoKSwgbW9kaWZpY2F0aW9uVHlwZSkuaW5jKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBxdW90ZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gZmV0Y2ggZmlybSBxdW90ZXMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgX2ZldGNoRmlybVF1b3Rlc0FzeW5jKHF1b3RlQ29udGV4dDogUXVvdGVDb250ZXh0LCBmZWU6IEZlZSk6IFByb21pc2U8RmlybU90Y1F1b3RlW10+IHtcclxuICAgICAgICBjb25zdCBxdW90ZXMgPSBhd2FpdCB0aGlzLl9mZXRjaEluZGljYXRpdmVRdW90ZXNBc3luYyhxdW90ZUNvbnRleHQsIGZlZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRUb0Zpcm1RdW90ZXNBc3luYyhxdW90ZXMsIHF1b3RlQ29udGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCBpbmRpY2F0aXZlIHF1b3RlcyB0byBmaXJtIHF1b3Rlcy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBfY29udmVydFRvRmlybVF1b3Rlc0FzeW5jKFxyXG4gICAgICAgIHF1b3RlczogSW5kaWNhdGl2ZVF1b3RlW10sXHJcbiAgICAgICAgcXVvdGVDb250ZXh0OiBRdW90ZUNvbnRleHQsXHJcbiAgICApOiBQcm9taXNlPEZpcm1PdGNRdW90ZVtdPiB7XHJcbiAgICAgICAgY29uc3QgeyB0YWtlckFkZHJlc3MgfSA9IHF1b3RlQ29udGV4dDtcclxuICAgICAgICBjb25zdCBjdXJyZW50QnVja2V0ID0gKGF3YWl0IHRoaXMuX2NhY2hlQ2xpZW50LmdldE5leHRPdGNPcmRlckJ1Y2tldEFzeW5jKHRoaXMuX2NoYWluSWQpKSAlIFJGUU1fTlVNX0JVQ0tFVFM7XHJcbiAgICAgICAgY29uc3Qgbm93U2Vjb25kcyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIE9ORV9TRUNPTkRfTVMpO1xyXG4gICAgICAgIGNvbnN0IG90Y1F1b3RlcyA9IHF1b3Rlcy5tYXAoKHEpID0+XHJcbiAgICAgICAgICAgIHRoaXMuX21hcEluZGljYXRpdmVRdW90ZVRvRmlybU90Y1F1b3RlKFxyXG4gICAgICAgICAgICAgICAgcSxcclxuICAgICAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXHJcbiAgICAgICAgICAgICAgICB0YWtlckFkZHJlc3MhLFxyXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcihjdXJyZW50QnVja2V0KSxcclxuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIobm93U2Vjb25kcyksXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgZmlybVF1b3Rlc1dpdGhDb3JyZWN0Q2hhaW5JZCA9IG90Y1F1b3Rlcy5maWx0ZXIoKHF1b3RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChxdW90ZS5vcmRlci5jaGFpbklkICE9PSB0aGlzLl9jaGFpbklkKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoeyBxdW90ZSB9LCAnUmVjZWl2ZWQgYSBxdW90ZSB3aXRoIGluY29ycmVjdCBjaGFpbiBpZCcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZmlybVF1b3Rlc1dpdGhDb3JyZWN0Q2hhaW5JZDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIF9lbnF1ZXVlSm9iQXN5bmMob3JkZXJIYXNoOiBzdHJpbmcsIHR5cGU6IEdhc2xlc3NUeXBlcyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuX3Nxc1Byb2R1Y2VyLnNlbmQoe1xyXG4gICAgICAgICAgICAvLyB3YWl0LCBpdCdzIGFsbCBvcmRlciBoYXNoP1xyXG4gICAgICAgICAgICAvLyBhbHdheXMgaGFzIGJlZW4uXHJcbiAgICAgICAgICAgIGdyb3VwSWQ6IG9yZGVySGFzaCxcclxuICAgICAgICAgICAgaWQ6IG9yZGVySGFzaCxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBvcmRlckhhc2gsIHR5cGUgfSksXHJcbiAgICAgICAgICAgIGRlZHVwbGljYXRpb25JZDogb3JkZXJIYXNoLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhbiBJbmRpY2F0aXZlUXVvdGUgdG8gYSBGaXJtT3RjUXVvdGUuIEhhbmRsZXMgdHhPcmlnaW4sIGNoYWluSWQsIGV4cGlyeUFuZE5vbmNlLCBldGNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfbWFwSW5kaWNhdGl2ZVF1b3RlVG9GaXJtT3RjUXVvdGUoXHJcbiAgICAgICAgcTogSW5kaWNhdGl2ZVF1b3RlLFxyXG4gICAgICAgIHRha2VyQWRkcmVzczogc3RyaW5nLFxyXG4gICAgICAgIG5vbmNlQnVja2V0OiBCaWdOdW1iZXIsXHJcbiAgICAgICAgbm9uY2U6IEJpZ051bWJlcixcclxuICAgICk6IEZpcm1PdGNRdW90ZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAga2luZDogJ290YycsXHJcbiAgICAgICAgICAgIG1ha2VyVXJpOiBxLm1ha2VyVXJpLFxyXG4gICAgICAgICAgICBvcmRlcjogbmV3IE90Y09yZGVyKHtcclxuICAgICAgICAgICAgICAgIHR4T3JpZ2luOiB0aGlzLl9yZWdpc3RyeUFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICBleHBpcnlBbmROb25jZTogT3RjT3JkZXIuZW5jb2RlRXhwaXJ5QW5kTm9uY2UocS5leHBpcnksIG5vbmNlQnVja2V0LCBub25jZSksXHJcbiAgICAgICAgICAgICAgICBtYWtlcjogcS5tYWtlcixcclxuICAgICAgICAgICAgICAgIHRha2VyOiB0YWtlckFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICBtYWtlclRva2VuOiBxLm1ha2VyVG9rZW4sXHJcbiAgICAgICAgICAgICAgICB0YWtlclRva2VuOiBxLnRha2VyVG9rZW4sXHJcbiAgICAgICAgICAgICAgICBtYWtlckFtb3VudDogcS5tYWtlckFtb3VudCxcclxuICAgICAgICAgICAgICAgIHRha2VyQW1vdW50OiBxLnRha2VyQW1vdW50LFxyXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5fY2hhaW5JZCxcclxuICAgICAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiB0aGlzLl9jb250cmFjdEFkZHJlc3Nlcy5leGNoYW5nZVByb3h5LFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGVzIGFuZCBjb252ZXJ0cyBFSVAtNzEyIGNvbnRleHQgdG8gYW4gQXBwcm92YWwgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGtpbmQgVHlwZSBvZiBnYXNsZXNzIGFwcHJvdmFsXHJcbiAgICAgKiBAcGFyYW0gZWlwNzEyIEVJUC03MTIgY29udGV4dCBwYXJzZWQgZnJvbSB0aGUgaGFuZGxlclxyXG4gICAgICogQHBhcmFtIHRyYWRlSGFzaCBUaGUgb3JkZXIgaGFzaCBvciBtZXRhdHJhbnNhY3Rpb24gaGFzaCxcclxuICAgICAqICBvbmx5IHVzZWQgZm9yIGxvZ2dpbmcgaW4gY2FzZSBvZiB2YWxpZGF0aW9uIGVycm9yXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgQXBwcm92YWwgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcHJlZmVyLWZ1bmN0aW9uLW92ZXItbWV0aG9kXHJcbiAgICBwcml2YXRlIF9jb252ZXJ0RUlQNzEyQ29udGV4dFRvQXBwcm92YWw8VCBleHRlbmRzIEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0IHwgUGVybWl0RWlwNzEyQ29udGV4dD4oXHJcbiAgICAgICAgZWlwNzEyOiBULFxyXG4gICAgICAgIHRyYWRlSGFzaDogc3RyaW5nLFxyXG4gICAgKTogVCBleHRlbmRzIEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0ID8gRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkFwcHJvdmFsIDogUGVybWl0QXBwcm92YWwge1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZXMsIHByaW1hcnlUeXBlLCBkb21haW4sIG1lc3NhZ2UgfSA9IGVpcDcxMjtcclxuICAgICAgICBzd2l0Y2ggKHByaW1hcnlUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ01ldGFUcmFuc2FjdGlvbic6IHtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAhXy5pc0VxdWFsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmtleXMobWVzc2FnZSkuc29ydCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlcy5NZXRhVHJhbnNhY3Rpb24ubWFwKChkYXRhRmllbGQ6IEVpcDcxMkRhdGFGaWVsZCkgPT4gZGF0YUZpZWxkLm5hbWUpLnNvcnQoKSxcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2Fybih7IHByaW1hcnlUeXBlLCB0cmFkZUhhc2ggfSwgJ0ludmFsaWQgbWVzc2FnZSBmaWVsZCBwcm92aWRlZCBmb3IgQXBwcm92YWwnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdtZXNzYWdlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFZhbGlkYXRpb25FcnJvckNvZGVzLkZpZWxkSW52YWxpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogYEludmFsaWQgbWVzc2FnZSBmaWVsZCBwcm92aWRlZCBmb3IgQXBwcm92YWwgb2YgcHJpbWFyeVR5cGUgJHtwcmltYXJ5VHlwZX1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkFwcHJvdmFsOiBFeGVjdXRlTWV0YVRyYW5zYWN0aW9uQXBwcm92YWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2luZDogR2FzbGVzc0FwcHJvdmFsVHlwZXMuRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBlaXA3MTI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbmNlOiBtZXNzYWdlLm5vbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogbWVzc2FnZS5mcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25TaWduYXR1cmU6IG1lc3NhZ2UuZnVuY3Rpb25TaWduYXR1cmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkFwcHJvdmFsIGFzIFQgZXh0ZW5kcyBFeGVjdXRlTWV0YVRyYW5zYWN0aW9uRWlwNzEyQ29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgID8gRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkFwcHJvdmFsXHJcbiAgICAgICAgICAgICAgICAgICAgOiBQZXJtaXRBcHByb3ZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlICdQZXJtaXQnOiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgIV8uaXNFcXVhbChcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy5rZXlzKG1lc3NhZ2UpLnNvcnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMuUGVybWl0Lm1hcCgoZGF0YUZpZWxkOiBFaXA3MTJEYXRhRmllbGQpID0+IGRhdGFGaWVsZC5uYW1lKS5zb3J0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oeyBwcmltYXJ5VHlwZSwgdHJhZGVIYXNoIH0sICdJbnZhbGlkIG1lc3NhZ2UgZmllbGQgcHJvdmlkZWQgZm9yIEFwcHJvdmFsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnbWVzc2FnZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBWYWxpZGF0aW9uRXJyb3JDb2Rlcy5GaWVsZEludmFsaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IGBJbnZhbGlkIG1lc3NhZ2UgZmllbGQgcHJvdmlkZWQgZm9yIEFwcHJvdmFsIG9mIHByaW1hcnlUeXBlICR7cHJpbWFyeVR5cGV9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBlcm1pdEFwcHJvdmFsOiBQZXJtaXRBcHByb3ZhbCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBraW5kOiBHYXNsZXNzQXBwcm92YWxUeXBlcy5QZXJtaXQsXHJcbiAgICAgICAgICAgICAgICAgICAgZWlwNzEyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogbWVzc2FnZS5vd25lcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZW5kZXI6IG1lc3NhZ2Uuc3BlbmRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZXNzYWdlLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uY2U6IG1lc3NhZ2Uubm9uY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWFkbGluZTogbWVzc2FnZS5kZWFkbGluZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGVybWl0QXBwcm92YWwgYXMgVCBleHRlbmRzIEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBFeGVjdXRlTWV0YVRyYW5zYWN0aW9uQXBwcm92YWxcclxuICAgICAgICAgICAgICAgICAgICA6IFBlcm1pdEFwcHJvdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAoKF94OiBuZXZlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcclxuICAgICAgICAgICAgICAgIH0pKHByaW1hcnlUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl0sInZlcnNpb24iOjN9