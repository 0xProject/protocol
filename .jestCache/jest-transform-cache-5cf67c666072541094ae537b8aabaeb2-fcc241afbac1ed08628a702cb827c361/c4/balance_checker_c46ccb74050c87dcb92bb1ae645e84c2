189060359c616e2eb39b5157b803d20e
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BalanceChecker = void 0;
const asset_swapper_1 = require("@0x/asset-swapper");
const artifacts_1 = require("@0x/asset-swapper/lib/src/artifacts");
const dev_utils_1 = require("@0x/dev-utils");
// The eth_call will run out of gas if there are too many balance calls at once
const BALANCE_CHECKER_GAS_LIMIT = 5500000;
// We use this random address on which to override the bytecode (unlikely to conflict with another address)
const RANDOM_ADDRESS = '0xffffffffffffffffffffffffffffffffffffffff';
/**
 * BalanceChecker makes it easy and efficient to look up a large number of token balances at once
 */
class BalanceChecker {
    constructor(provider, balanceCheckerContract) {
        this._balanceCheckerContract =
            balanceCheckerContract ||
                new asset_swapper_1.BalanceCheckerContract(RANDOM_ADDRESS, provider, { gas: BALANCE_CHECKER_GAS_LIMIT });
        this._balanceCheckerBytecode = artifacts_1.artifacts.BalanceChecker.compilerOutput.evm.deployedBytecode.object;
    }
    /**
     * Fetches the tradeable balance for a list of addresses against the specified tokens.
     * Tradeable means the minimum of the balance and allowance.
     *
     * The index of an address in `addresses` must correspond with the index of a token in `tokens`
     *
     * @param addresses - an array of addresses
     * @param tokens - an array of tokens
     * @param allowanceTarget - Target address to check for allowance.
     * @returns - an array of BigNumbers
     */
    async getMinOfBalancesAndAllowancesAsync(addresses, tokens, allowanceTarget) {
        if (addresses.length !== tokens.length) {
            throw new Error(`expected length of addresses and tokens must be the same, actual: ${addresses.length} and ${tokens.length}`);
        }
        // HACK: this checks to see if we're using a real implementation of the balanceCheckerContract or using an override
        // We do this because ganache doesn't allow for overrides. In all other environments, we should use overrides
        const shouldUseOverrides = this._balanceCheckerContract.address.toLowerCase() === RANDOM_ADDRESS;
        const txOpts = shouldUseOverrides
            ? {
                overrides: {
                    [RANDOM_ADDRESS]: {
                        code: this._balanceCheckerBytecode,
                    },
                },
            }
            : {};
        return this._balanceCheckerContract
            .getMinOfBalancesOrAllowances(addresses, tokens, allowanceTarget)
            .callAsync(txOpts, dev_utils_1.BlockParamLiteral.Latest);
    }
    /**
     * Fetches the balances for a list of addresses against the specified tokens.
     *
     * The index of an address in `addresses` must correspond with the index of a token in `tokens`.
     */
    async getTokenBalancesAsync(addresses, tokens) {
        if (addresses.length !== tokens.length) {
            throw new Error(`expected length of addresses and tokens must be the same, actual: ${addresses.length} and ${tokens.length}`);
        }
        // HACK: this checks to see if we're using a real implementation of the balanceCheckerContract or using an override
        // We do this because ganache doesn't allow for overrides. In all other environments, we should use overrides
        const shouldUseOverrides = this._balanceCheckerContract.address.toLowerCase() === RANDOM_ADDRESS;
        const txOpts = shouldUseOverrides
            ? {
                overrides: {
                    [RANDOM_ADDRESS]: {
                        code: this._balanceCheckerBytecode,
                    },
                },
            }
            : {};
        return this._balanceCheckerContract.balances(addresses, tokens).callAsync(txOpts, dev_utils_1.BlockParamLiteral.Latest);
    }
}
exports.BalanceChecker = BalanceChecker;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy91dGlscy9iYWxhbmNlX2NoZWNrZXIudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEscURBQTJEO0FBQzNELG1FQUFnRTtBQUNoRSw2Q0FBcUU7QUFHckUsK0VBQStFO0FBQy9FLE1BQU0seUJBQXlCLEdBQUcsT0FBTyxDQUFDO0FBRTFDLDJHQUEyRztBQUMzRyxNQUFNLGNBQWMsR0FBRyw0Q0FBNEMsQ0FBQztBQUVwRTs7R0FFRztBQUNILE1BQWEsY0FBYztJQUl2QixZQUFZLFFBQTJCLEVBQUUsc0JBQStDO1FBQ3BGLElBQUksQ0FBQyx1QkFBdUI7WUFDeEIsc0JBQXNCO2dCQUN0QixJQUFJLHNDQUFzQixDQUFDLGNBQWMsRUFBRSxRQUFRLEVBQUUsRUFBRSxHQUFHLEVBQUUseUJBQXlCLEVBQUUsQ0FBQyxDQUFDO1FBQzdGLElBQUksQ0FBQyx1QkFBdUIsR0FBRyxxQkFBUyxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQztJQUN2RyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLEtBQUssQ0FBQyxrQ0FBa0MsQ0FDM0MsU0FBbUIsRUFDbkIsTUFBZ0IsRUFDaEIsZUFBdUI7UUFFdkIsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDcEMsTUFBTSxJQUFJLEtBQUssQ0FDWCxxRUFBcUUsU0FBUyxDQUFDLE1BQU0sUUFBUSxNQUFNLENBQUMsTUFBTSxFQUFFLENBQy9HLENBQUM7U0FDTDtRQUVELG1IQUFtSDtRQUNuSCw2R0FBNkc7UUFDN0csTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxLQUFLLGNBQWMsQ0FBQztRQUVqRyxNQUFNLE1BQU0sR0FBRyxrQkFBa0I7WUFDN0IsQ0FBQyxDQUFDO2dCQUNJLFNBQVMsRUFBRTtvQkFDUCxDQUFDLGNBQWMsQ0FBQyxFQUFFO3dCQUNkLElBQUksRUFBRSxJQUFJLENBQUMsdUJBQXVCO3FCQUNyQztpQkFDSjthQUNKO1lBQ0gsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUVULE9BQU8sSUFBSSxDQUFDLHVCQUF1QjthQUM5Qiw0QkFBNEIsQ0FBQyxTQUFTLEVBQUUsTUFBTSxFQUFFLGVBQWUsQ0FBQzthQUNoRSxTQUFTLENBQUMsTUFBTSxFQUFFLDZCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLHFCQUFxQixDQUFDLFNBQW1CLEVBQUUsTUFBZ0I7UUFDcEUsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDcEMsTUFBTSxJQUFJLEtBQUssQ0FDWCxxRUFBcUUsU0FBUyxDQUFDLE1BQU0sUUFBUSxNQUFNLENBQUMsTUFBTSxFQUFFLENBQy9HLENBQUM7U0FDTDtRQUVELG1IQUFtSDtRQUNuSCw2R0FBNkc7UUFDN0csTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxLQUFLLGNBQWMsQ0FBQztRQUVqRyxNQUFNLE1BQU0sR0FBRyxrQkFBa0I7WUFDN0IsQ0FBQyxDQUFDO2dCQUNJLFNBQVMsRUFBRTtvQkFDUCxDQUFDLGNBQWMsQ0FBQyxFQUFFO3dCQUNkLElBQUksRUFBRSxJQUFJLENBQUMsdUJBQXVCO3FCQUNyQztpQkFDSjthQUNKO1lBQ0gsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUVULE9BQU8sSUFBSSxDQUFDLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSw2QkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNoSCxDQUFDO0NBQ0o7QUFoRkQsd0NBZ0ZDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXZpZHdhbHNoL2NvZGUtbG9jYWwvMHgtcmZxLWFwaS9zcmMvdXRpbHMvYmFsYW5jZV9jaGVja2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhbGFuY2VDaGVja2VyQ29udHJhY3QgfSBmcm9tICdAMHgvYXNzZXQtc3dhcHBlcic7XG5pbXBvcnQgeyBhcnRpZmFjdHMgfSBmcm9tICdAMHgvYXNzZXQtc3dhcHBlci9saWIvc3JjL2FydGlmYWN0cyc7XG5pbXBvcnQgeyBCbG9ja1BhcmFtTGl0ZXJhbCwgU3VwcG9ydGVkUHJvdmlkZXIgfSBmcm9tICdAMHgvZGV2LXV0aWxzJztcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ0AweC91dGlscyc7XG5cbi8vIFRoZSBldGhfY2FsbCB3aWxsIHJ1biBvdXQgb2YgZ2FzIGlmIHRoZXJlIGFyZSB0b28gbWFueSBiYWxhbmNlIGNhbGxzIGF0IG9uY2VcbmNvbnN0IEJBTEFOQ0VfQ0hFQ0tFUl9HQVNfTElNSVQgPSA1NTAwMDAwO1xuXG4vLyBXZSB1c2UgdGhpcyByYW5kb20gYWRkcmVzcyBvbiB3aGljaCB0byBvdmVycmlkZSB0aGUgYnl0ZWNvZGUgKHVubGlrZWx5IHRvIGNvbmZsaWN0IHdpdGggYW5vdGhlciBhZGRyZXNzKVxuY29uc3QgUkFORE9NX0FERFJFU1MgPSAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJztcblxuLyoqXG4gKiBCYWxhbmNlQ2hlY2tlciBtYWtlcyBpdCBlYXN5IGFuZCBlZmZpY2llbnQgdG8gbG9vayB1cCBhIGxhcmdlIG51bWJlciBvZiB0b2tlbiBiYWxhbmNlcyBhdCBvbmNlXG4gKi9cbmV4cG9ydCBjbGFzcyBCYWxhbmNlQ2hlY2tlciB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfYmFsYW5jZUNoZWNrZXJDb250cmFjdDogQmFsYW5jZUNoZWNrZXJDb250cmFjdDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9iYWxhbmNlQ2hlY2tlckJ5dGVjb2RlOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcjogU3VwcG9ydGVkUHJvdmlkZXIsIGJhbGFuY2VDaGVja2VyQ29udHJhY3Q/OiBCYWxhbmNlQ2hlY2tlckNvbnRyYWN0KSB7XG4gICAgICAgIHRoaXMuX2JhbGFuY2VDaGVja2VyQ29udHJhY3QgPVxuICAgICAgICAgICAgYmFsYW5jZUNoZWNrZXJDb250cmFjdCB8fFxuICAgICAgICAgICAgbmV3IEJhbGFuY2VDaGVja2VyQ29udHJhY3QoUkFORE9NX0FERFJFU1MsIHByb3ZpZGVyLCB7IGdhczogQkFMQU5DRV9DSEVDS0VSX0dBU19MSU1JVCB9KTtcbiAgICAgICAgdGhpcy5fYmFsYW5jZUNoZWNrZXJCeXRlY29kZSA9IGFydGlmYWN0cy5CYWxhbmNlQ2hlY2tlci5jb21waWxlck91dHB1dC5ldm0uZGVwbG95ZWRCeXRlY29kZS5vYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgdHJhZGVhYmxlIGJhbGFuY2UgZm9yIGEgbGlzdCBvZiBhZGRyZXNzZXMgYWdhaW5zdCB0aGUgc3BlY2lmaWVkIHRva2Vucy5cbiAgICAgKiBUcmFkZWFibGUgbWVhbnMgdGhlIG1pbmltdW0gb2YgdGhlIGJhbGFuY2UgYW5kIGFsbG93YW5jZS5cbiAgICAgKlxuICAgICAqIFRoZSBpbmRleCBvZiBhbiBhZGRyZXNzIGluIGBhZGRyZXNzZXNgIG11c3QgY29ycmVzcG9uZCB3aXRoIHRoZSBpbmRleCBvZiBhIHRva2VuIGluIGB0b2tlbnNgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIC0gYW4gYXJyYXkgb2YgYWRkcmVzc2VzXG4gICAgICogQHBhcmFtIHRva2VucyAtIGFuIGFycmF5IG9mIHRva2Vuc1xuICAgICAqIEBwYXJhbSBhbGxvd2FuY2VUYXJnZXQgLSBUYXJnZXQgYWRkcmVzcyB0byBjaGVjayBmb3IgYWxsb3dhbmNlLlxuICAgICAqIEByZXR1cm5zIC0gYW4gYXJyYXkgb2YgQmlnTnVtYmVyc1xuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKFxuICAgICAgICBhZGRyZXNzZXM6IHN0cmluZ1tdLFxuICAgICAgICB0b2tlbnM6IHN0cmluZ1tdLFxuICAgICAgICBhbGxvd2FuY2VUYXJnZXQ6IHN0cmluZyxcbiAgICApOiBQcm9taXNlPEJpZ051bWJlcltdPiB7XG4gICAgICAgIGlmIChhZGRyZXNzZXMubGVuZ3RoICE9PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYGV4cGVjdGVkIGxlbmd0aCBvZiBhZGRyZXNzZXMgYW5kIHRva2VucyBtdXN0IGJlIHRoZSBzYW1lLCBhY3R1YWw6ICR7YWRkcmVzc2VzLmxlbmd0aH0gYW5kICR7dG9rZW5zLmxlbmd0aH1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhBQ0s6IHRoaXMgY2hlY2tzIHRvIHNlZSBpZiB3ZSdyZSB1c2luZyBhIHJlYWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIGJhbGFuY2VDaGVja2VyQ29udHJhY3Qgb3IgdXNpbmcgYW4gb3ZlcnJpZGVcbiAgICAgICAgLy8gV2UgZG8gdGhpcyBiZWNhdXNlIGdhbmFjaGUgZG9lc24ndCBhbGxvdyBmb3Igb3ZlcnJpZGVzLiBJbiBhbGwgb3RoZXIgZW52aXJvbm1lbnRzLCB3ZSBzaG91bGQgdXNlIG92ZXJyaWRlc1xuICAgICAgICBjb25zdCBzaG91bGRVc2VPdmVycmlkZXMgPSB0aGlzLl9iYWxhbmNlQ2hlY2tlckNvbnRyYWN0LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gUkFORE9NX0FERFJFU1M7XG5cbiAgICAgICAgY29uc3QgdHhPcHRzID0gc2hvdWxkVXNlT3ZlcnJpZGVzXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIG92ZXJyaWRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFtSQU5ET01fQUREUkVTU106IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogdGhpcy5fYmFsYW5jZUNoZWNrZXJCeXRlY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fYmFsYW5jZUNoZWNrZXJDb250cmFjdFxuICAgICAgICAgICAgLmdldE1pbk9mQmFsYW5jZXNPckFsbG93YW5jZXMoYWRkcmVzc2VzLCB0b2tlbnMsIGFsbG93YW5jZVRhcmdldClcbiAgICAgICAgICAgIC5jYWxsQXN5bmModHhPcHRzLCBCbG9ja1BhcmFtTGl0ZXJhbC5MYXRlc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIGJhbGFuY2VzIGZvciBhIGxpc3Qgb2YgYWRkcmVzc2VzIGFnYWluc3QgdGhlIHNwZWNpZmllZCB0b2tlbnMuXG4gICAgICpcbiAgICAgKiBUaGUgaW5kZXggb2YgYW4gYWRkcmVzcyBpbiBgYWRkcmVzc2VzYCBtdXN0IGNvcnJlc3BvbmQgd2l0aCB0aGUgaW5kZXggb2YgYSB0b2tlbiBpbiBgdG9rZW5zYC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0VG9rZW5CYWxhbmNlc0FzeW5jKGFkZHJlc3Nlczogc3RyaW5nW10sIHRva2Vuczogc3RyaW5nW10pOiBQcm9taXNlPEJpZ051bWJlcltdPiB7XG4gICAgICAgIGlmIChhZGRyZXNzZXMubGVuZ3RoICE9PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYGV4cGVjdGVkIGxlbmd0aCBvZiBhZGRyZXNzZXMgYW5kIHRva2VucyBtdXN0IGJlIHRoZSBzYW1lLCBhY3R1YWw6ICR7YWRkcmVzc2VzLmxlbmd0aH0gYW5kICR7dG9rZW5zLmxlbmd0aH1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhBQ0s6IHRoaXMgY2hlY2tzIHRvIHNlZSBpZiB3ZSdyZSB1c2luZyBhIHJlYWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIGJhbGFuY2VDaGVja2VyQ29udHJhY3Qgb3IgdXNpbmcgYW4gb3ZlcnJpZGVcbiAgICAgICAgLy8gV2UgZG8gdGhpcyBiZWNhdXNlIGdhbmFjaGUgZG9lc24ndCBhbGxvdyBmb3Igb3ZlcnJpZGVzLiBJbiBhbGwgb3RoZXIgZW52aXJvbm1lbnRzLCB3ZSBzaG91bGQgdXNlIG92ZXJyaWRlc1xuICAgICAgICBjb25zdCBzaG91bGRVc2VPdmVycmlkZXMgPSB0aGlzLl9iYWxhbmNlQ2hlY2tlckNvbnRyYWN0LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gUkFORE9NX0FERFJFU1M7XG5cbiAgICAgICAgY29uc3QgdHhPcHRzID0gc2hvdWxkVXNlT3ZlcnJpZGVzXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIG92ZXJyaWRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFtSQU5ET01fQUREUkVTU106IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogdGhpcy5fYmFsYW5jZUNoZWNrZXJCeXRlY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fYmFsYW5jZUNoZWNrZXJDb250cmFjdC5iYWxhbmNlcyhhZGRyZXNzZXMsIHRva2VucykuY2FsbEFzeW5jKHR4T3B0cywgQmxvY2tQYXJhbUxpdGVyYWwuTGF0ZXN0KTtcbiAgICB9XG59XG4iXSwidmVyc2lvbiI6M30=