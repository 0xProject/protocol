{"file":"/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts","mappings":";;;AAAA,qDAA2D;AAC3D,mEAAgE;AAChE,6CAAqE;AAGrE,+EAA+E;AAC/E,MAAM,yBAAyB,GAAG,OAAO,CAAC;AAE1C,2GAA2G;AAC3G,MAAM,cAAc,GAAG,4CAA4C,CAAC;AAEpE;;GAEG;AACH,MAAa,cAAc;IAIvB,YAAY,QAA2B,EAAE,sBAA+C;QACpF,IAAI,CAAC,uBAAuB;YACxB,sBAAsB;gBACtB,IAAI,sCAAsB,CAAC,cAAc,EAAE,QAAQ,EAAE,EAAE,GAAG,EAAE,yBAAyB,EAAE,CAAC,CAAC;QAC7F,IAAI,CAAC,uBAAuB,GAAG,qBAAS,CAAC,cAAc,CAAC,cAAc,CAAC,GAAG,CAAC,gBAAgB,CAAC,MAAM,CAAC;IACvG,CAAC;IAED;;;;;;;;;;OAUG;IACI,KAAK,CAAC,kCAAkC,CAC3C,SAAmB,EACnB,MAAgB,EAChB,eAAuB;QAEvB,IAAI,SAAS,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,EAAE;YACpC,MAAM,IAAI,KAAK,CACX,qEAAqE,SAAS,CAAC,MAAM,QAAQ,MAAM,CAAC,MAAM,EAAE,CAC/G,CAAC;SACL;QAED,mHAAmH;QACnH,6GAA6G;QAC7G,MAAM,kBAAkB,GAAG,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,WAAW,EAAE,KAAK,cAAc,CAAC;QAEjG,MAAM,MAAM,GAAG,kBAAkB;YAC7B,CAAC,CAAC;gBACI,SAAS,EAAE;oBACP,CAAC,cAAc,CAAC,EAAE;wBACd,IAAI,EAAE,IAAI,CAAC,uBAAuB;qBACrC;iBACJ;aACJ;YACH,CAAC,CAAC,EAAE,CAAC;QAET,OAAO,IAAI,CAAC,uBAAuB;aAC9B,4BAA4B,CAAC,SAAS,EAAE,MAAM,EAAE,eAAe,CAAC;aAChE,SAAS,CAAC,MAAM,EAAE,6BAAiB,CAAC,MAAM,CAAC,CAAC;IACrD,CAAC;IAED;;;;OAIG;IACI,KAAK,CAAC,qBAAqB,CAAC,SAAmB,EAAE,MAAgB;QACpE,IAAI,SAAS,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,EAAE;YACpC,MAAM,IAAI,KAAK,CACX,qEAAqE,SAAS,CAAC,MAAM,QAAQ,MAAM,CAAC,MAAM,EAAE,CAC/G,CAAC;SACL;QAED,mHAAmH;QACnH,6GAA6G;QAC7G,MAAM,kBAAkB,GAAG,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,WAAW,EAAE,KAAK,cAAc,CAAC;QAEjG,MAAM,MAAM,GAAG,kBAAkB;YAC7B,CAAC,CAAC;gBACI,SAAS,EAAE;oBACP,CAAC,cAAc,CAAC,EAAE;wBACd,IAAI,EAAE,IAAI,CAAC,uBAAuB;qBACrC;iBACJ;aACJ;YACH,CAAC,CAAC,EAAE,CAAC;QAET,OAAO,IAAI,CAAC,uBAAuB,CAAC,QAAQ,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC,SAAS,CAAC,MAAM,EAAE,6BAAiB,CAAC,MAAM,CAAC,CAAC;IAChH,CAAC;CACJ;AAhFD,wCAgFC","names":[],"sources":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/balance_checker.ts"],"sourcesContent":["import { BalanceCheckerContract } from '@0x/asset-swapper';\nimport { artifacts } from '@0x/asset-swapper/lib/src/artifacts';\nimport { BlockParamLiteral, SupportedProvider } from '@0x/dev-utils';\nimport { BigNumber } from '@0x/utils';\n\n// The eth_call will run out of gas if there are too many balance calls at once\nconst BALANCE_CHECKER_GAS_LIMIT = 5500000;\n\n// We use this random address on which to override the bytecode (unlikely to conflict with another address)\nconst RANDOM_ADDRESS = '0xffffffffffffffffffffffffffffffffffffffff';\n\n/**\n * BalanceChecker makes it easy and efficient to look up a large number of token balances at once\n */\nexport class BalanceChecker {\n    private readonly _balanceCheckerContract: BalanceCheckerContract;\n    private readonly _balanceCheckerBytecode: string;\n\n    constructor(provider: SupportedProvider, balanceCheckerContract?: BalanceCheckerContract) {\n        this._balanceCheckerContract =\n            balanceCheckerContract ||\n            new BalanceCheckerContract(RANDOM_ADDRESS, provider, { gas: BALANCE_CHECKER_GAS_LIMIT });\n        this._balanceCheckerBytecode = artifacts.BalanceChecker.compilerOutput.evm.deployedBytecode.object;\n    }\n\n    /**\n     * Fetches the tradeable balance for a list of addresses against the specified tokens.\n     * Tradeable means the minimum of the balance and allowance.\n     *\n     * The index of an address in `addresses` must correspond with the index of a token in `tokens`\n     *\n     * @param addresses - an array of addresses\n     * @param tokens - an array of tokens\n     * @param allowanceTarget - Target address to check for allowance.\n     * @returns - an array of BigNumbers\n     */\n    public async getMinOfBalancesAndAllowancesAsync(\n        addresses: string[],\n        tokens: string[],\n        allowanceTarget: string,\n    ): Promise<BigNumber[]> {\n        if (addresses.length !== tokens.length) {\n            throw new Error(\n                `expected length of addresses and tokens must be the same, actual: ${addresses.length} and ${tokens.length}`,\n            );\n        }\n\n        // HACK: this checks to see if we're using a real implementation of the balanceCheckerContract or using an override\n        // We do this because ganache doesn't allow for overrides. In all other environments, we should use overrides\n        const shouldUseOverrides = this._balanceCheckerContract.address.toLowerCase() === RANDOM_ADDRESS;\n\n        const txOpts = shouldUseOverrides\n            ? {\n                  overrides: {\n                      [RANDOM_ADDRESS]: {\n                          code: this._balanceCheckerBytecode,\n                      },\n                  },\n              }\n            : {};\n\n        return this._balanceCheckerContract\n            .getMinOfBalancesOrAllowances(addresses, tokens, allowanceTarget)\n            .callAsync(txOpts, BlockParamLiteral.Latest);\n    }\n\n    /**\n     * Fetches the balances for a list of addresses against the specified tokens.\n     *\n     * The index of an address in `addresses` must correspond with the index of a token in `tokens`.\n     */\n    public async getTokenBalancesAsync(addresses: string[], tokens: string[]): Promise<BigNumber[]> {\n        if (addresses.length !== tokens.length) {\n            throw new Error(\n                `expected length of addresses and tokens must be the same, actual: ${addresses.length} and ${tokens.length}`,\n            );\n        }\n\n        // HACK: this checks to see if we're using a real implementation of the balanceCheckerContract or using an override\n        // We do this because ganache doesn't allow for overrides. In all other environments, we should use overrides\n        const shouldUseOverrides = this._balanceCheckerContract.address.toLowerCase() === RANDOM_ADDRESS;\n\n        const txOpts = shouldUseOverrides\n            ? {\n                  overrides: {\n                      [RANDOM_ADDRESS]: {\n                          code: this._balanceCheckerBytecode,\n                      },\n                  },\n              }\n            : {};\n\n        return this._balanceCheckerContract.balances(addresses, tokens).callAsync(txOpts, BlockParamLiteral.Latest);\n    }\n}\n"],"version":3}