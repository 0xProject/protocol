{"file":"/Users/davidwalsh/code-local/0x-rfq-api/src/services/GaslessSwapService.ts","mappings":"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","names":[],"sources":["/Users/davidwalsh/code-local/0x-rfq-api/src/services/GaslessSwapService.ts"],"sourcesContent":["// tslint:disable:max-file-line-count\nimport { InternalServerError, TooManyRequestsError, ValidationError, ValidationErrorCodes } from '@0x/api-utils';\nimport { ITransformERC20Contract } from '@0x/contract-wrappers';\nimport { BigNumber, NULL_ADDRESS } from '@0x/utils';\nimport { AxiosInstance } from 'axios';\nimport { utils as ethersUtils } from 'ethers';\nimport Redis from 'ioredis';\nimport { Counter, Summary } from 'prom-client';\nimport { Producer } from 'sqs-producer';\n\nimport { ONE_MINUTE_S, ONE_SECOND_MS } from '../core/constants';\nimport { MetaTransactionJobConstructorOpts } from '../entities/MetaTransactionJobEntity';\nimport { RfqmJobStatus } from '../entities/types';\nimport { logger } from '../logger';\nimport { ExecuteMetaTransactionEip712Context, PermitEip712Context, GaslessTypes } from '../core/types';\nimport { FeeConfigs, TruncatedFees } from '../core/types/meta_transaction_fees';\nimport { getV1QuoteAsync, getV2QuoteAsync, MetaTransactionClientQuoteResponse } from '../utils/MetaTransactionClient';\nimport { RfqmDbUtils } from '../utils/rfqm_db_utils';\nimport { HealthCheckResult } from '../utils/rfqm_health_check';\nimport { RfqBlockchainUtils } from '../utils/rfq_blockchain_utils';\nimport { getSignerFromHash } from '../utils/signature_utils';\n\nimport { RfqmService } from './rfqm_service';\nimport {\n    FetchFirmQuoteParams,\n    FetchIndicativeQuoteParams,\n    FetchIndicativeQuoteResponse,\n    MetaTransactionV1QuoteResponse,\n    MetaTransactionV2QuoteResponse,\n    OtcOrderRfqmQuoteResponse,\n    SubmitMetaTransactionSignedQuoteParams,\n    SubmitMetaTransactionSignedQuoteResponse,\n    SubmitRfqmSignedQuoteWithApprovalParams,\n    SubmitRfqmSignedQuoteWithApprovalResponse,\n    LiquiditySource,\n    SubmitMetaTransactionV2SignedQuoteParams,\n    SubmitMetaTransactionV2SignedQuoteResponse,\n    StatusResponse,\n    FetchQuoteParamsBase,\n} from './types';\nimport { feesToTruncatedFees, getFeeConfigsFromParams } from '../core/meta_transaction_fee_utils';\n\n/**\n * When a metatransaction quote is issued, the hash\n * is stored in Redis. When a quote is submitted, it\n * is only accepted if the metatransaction hash is in\n * Redis. This prevents a malicious user submitting\n * a quote which was not issued by 0x.\n *\n * The length of time the quote metatransaction hash\n * is stored in Redis.\n */\nconst META_TRANSACTION_HASH_TTL_S = 15 * ONE_MINUTE_S; // tslint:disable-line binary-expression-operand-order custom-no-magic-numbers\n\nenum GaslessSwapServiceErrorReason {\n    MetaTransactionAboutToExpire = 'meta_transaction_about_to_expire', // meta-transaction is about to expire\n    MetaTransactionPendingJobAlreadyExist = 'meta_transaction_pending_job_already_exist', // a pendingmeta-transaction job already exists for a taker-takerToken\n    MetaTransactionTakerBalanceCheckFailed = 'meta_transaction_taker_balance_check_failed', // taker balance check failed when submitting a meta-transaction\n    MetaTransactionHashNotExist = 'meta_transaction_hash_does_not_exist', // meta-transaction hash does not exist\n    MetaTransactionInvalidSigner = 'meta_transaction_invalid_signer', // invalid signer for the mta-transaction\n    MetaTransactionFailedToQueue = 'meta_transaction_failed_to_queue', // failed to queue meta-transaction\n    RfqPriceError = 'rfq_price_error', // encountered error when fetching rfq price\n    AmmPriceError = 'amm_price_error', // encountered error when fetching amm price\n    RfqQuoteError = 'rfq_quote_error', // encountered error when fetching rfq quote\n    AmmQuoteError = 'amm_quote_error', // encountered error when fetching amm quote\n}\n\n/**\n * Produces a key for Redis using the MetaTransaction hash\n */\nfunction metaTransactionHashRedisKey(hash: string): string {\n    return `metaTransactionHash.${hash}`;\n}\n\n/**\n * Accepts calldata for a transformErc20 call and extracts\n * arguments from the calldata.\n */\nfunction decodeTransformErc20Calldata(calldata: string): {\n    inputToken: string;\n    outputToken: string;\n    inputTokenAmount: BigNumber;\n    minOutputTokenAmount: BigNumber;\n} {\n    const transformErc20Interface = new ethersUtils.Interface(ITransformERC20Contract.ABI());\n\n    const result = transformErc20Interface.parseTransaction({ data: calldata });\n\n    const {\n        args: [inputToken, outputToken, inputTokenAmount, minOutputTokenAmount],\n    } = result;\n\n    return {\n        inputToken: inputToken as string,\n        outputToken: outputToken as string,\n        // Use `toString` because these are actually Ethers BigNumbers\n        inputTokenAmount: new BigNumber(inputTokenAmount.toString()),\n        minOutputTokenAmount: new BigNumber(minOutputTokenAmount.toString()),\n    };\n}\n\nconst ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS = new Summary({\n    name: 'zerog_meta_transaction_quote_request_duration_seconds',\n    help: 'Histogram of request duration of gasless swap',\n    // tslint:disable-next-line: custom-no-magic-numbers\n    percentiles: [0.5, 0.9, 0.95, 0.99, 0.999],\n    labelNames: ['chainId', 'success'],\n    maxAgeSeconds: 60,\n    ageBuckets: 5,\n});\nconst ZEROG_GASLESSS_SWAP_SERVICE_ERRORS = new Counter({\n    name: 'zerog_gasless_swap_service_errors_total',\n    labelNames: ['chainId', 'reason'],\n    help: 'Number of errors (with specific reason) encountered in galess swap service',\n});\n\n/**\n * Contains logic to fetch RFQm quotes, but with a fallback to\n * a MetaTransaction-wrapped AMM trade in the case no RFQm\n * liquidity is available.\n */\nexport class GaslessSwapService {\n    constructor(\n        private readonly _chainId: number,\n        private readonly _rfqmService: RfqmService,\n        private readonly _metaTransactionServiceBaseUrl: URL,\n        private readonly _axiosInstance: AxiosInstance,\n        private readonly _redis: Redis,\n        private readonly _dbUtils: RfqmDbUtils,\n        private readonly _blockchainUtils: RfqBlockchainUtils,\n        private readonly _sqsProducer: Producer,\n    ) {}\n\n    /**\n     * Fetches a \"price\" (aka \"Indicative Quote\").\n     *\n     * The request is first sent to market maker servers and then to the metatransaction\n     * service if the market makers don't provide liquidity or errors out.\n     *\n     * If RFQ liquidity exists, then it is used to compute the price.\n     * If AMM liquidity exists but RFQ liquidity is unavailable then\n     * AMM liquidity is used to compute the price.\n     *\n     * Returns `null` if neither AMM or RFQ liquidity exists.\n     */\n    public async fetchPriceAsync(\n        params: FetchIndicativeQuoteParams,\n        kind: GaslessTypes,\n    ): Promise<\n        | (FetchIndicativeQuoteResponse &\n              ({ liquiditySource: 'rfq' | 'amm' } | { sources: LiquiditySource[]; fees?: TruncatedFees }))\n        | null\n    > {\n        if (kind === GaslessTypes.MetaTransaction) {\n            try {\n                const rfqPrice = await this._rfqmService.fetchIndicativeQuoteAsync(params, 'gaslessSwapRfq');\n\n                if (rfqPrice) {\n                    return { ...rfqPrice, liquiditySource: 'rfq' };\n                }\n            } catch (e) {\n                ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                    this._chainId.toString(),\n                    GaslessSwapServiceErrorReason.RfqPriceError,\n                ).inc();\n                logger.error(\n                    { params, errorMessage: e.message, stack: e.stack },\n                    'Encountered error when fetching RFQ price in `GaslessSwapService`',\n                );\n            }\n        }\n\n        try {\n            let feeConfigs: FeeConfigs | undefined;\n            if (kind === GaslessTypes.MetaTransactionV2) {\n                feeConfigs = this._getFeeConfigs(params, 'on-chain'); // integrator billing type would always be on-chain for now\n            }\n\n            const metaTransactionRequestParams = {\n                ...params,\n                chainId: this._chainId,\n                integratorId: params.integrator.integratorId,\n                // Can use the null address here since we won't be returning\n                // the actual metatransaction\n                takerAddress: params.takerAddress ?? NULL_ADDRESS,\n                feeConfigs,\n            };\n\n            let metaTransactionQuote: MetaTransactionClientQuoteResponse | null;\n\n            switch (kind) {\n                case GaslessTypes.MetaTransaction:\n                    metaTransactionQuote = await getV1QuoteAsync(\n                        this._axiosInstance,\n                        new URL(`${this._metaTransactionServiceBaseUrl.toString()}/quote`),\n                        metaTransactionRequestParams,\n                        {\n                            requestDurationSummary: ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS,\n                            chainId: this._chainId,\n                        },\n                        logger.warn.bind(logger),\n                    );\n                    break;\n                case GaslessTypes.MetaTransactionV2:\n                    metaTransactionQuote = await getV2QuoteAsync(\n                        this._axiosInstance,\n                        new URL(`${this._metaTransactionServiceBaseUrl.toString()}/quote`),\n                        metaTransactionRequestParams,\n                        {\n                            requestDurationSummary: ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS,\n                            chainId: this._chainId,\n                        },\n                        logger.warn.bind(logger),\n                    );\n                    break;\n                case GaslessTypes.OtcOrder:\n                    // This should never happen\n                    throw new Error('GaslessTypes.OtcOrder should not be reached');\n                default:\n                    ((_x: never) => {\n                        throw new Error('unreachable');\n                    })(kind);\n            }\n\n            if (metaTransactionQuote) {\n                if (kind === GaslessTypes.MetaTransaction) {\n                    return {\n                        ...metaTransactionQuote.price,\n                        allowanceTarget: this._blockchainUtils.getExchangeProxyAddress(),\n                        liquiditySource: 'amm',\n                    };\n                } else {\n                    return {\n                        ...metaTransactionQuote.price,\n                        sources: metaTransactionQuote.sources ?? [],\n                        fees: feesToTruncatedFees(metaTransactionQuote.fees),\n                        allowanceTarget: this._blockchainUtils.getExchangeProxyAddress(),\n                    };\n                }\n            }\n\n            return null;\n        } catch (e) {\n            if (e instanceof ValidationError) {\n                throw e;\n            }\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.AmmPriceError,\n            ).inc();\n            logger.error(\n                { params, errorMessage: e.message, stack: e.stack },\n                'Encountered error when fetching AMM price in `GaslessSwapService`',\n            );\n\n            // Throw here as it means RFQ throws / does not liquidity and AMM throws\n            throw new Error(`Error fetching price for ${params}`);\n        }\n    }\n\n    /**\n     * Fetches a \"quote\" (aka \"Firm Quote\").\n     *\n     * Liquidity selection logic is the same as with `fetchPriceAsync`.\n     *\n     * If an AMM metatransaction is selected as the liquidity source,\n     * its metatransaction hash is stored in Redis to be verified upon\n     * submit.\n     */\n    public async fetchQuoteAsync(\n        params: FetchFirmQuoteParams,\n        kind: GaslessTypes,\n    ): Promise<\n        | ((OtcOrderRfqmQuoteResponse | MetaTransactionV1QuoteResponse) & { liquiditySource: 'rfq' | 'amm' })\n        | MetaTransactionV2QuoteResponse\n        | null\n    > {\n        let rfqQuoteReportId: string | null = null;\n        if (kind === GaslessTypes.MetaTransaction) {\n            try {\n                const { quote: rfqQuote, quoteReportId } = await this._rfqmService.fetchFirmQuoteAsync(\n                    params,\n                    'gaslessSwapRfq',\n                );\n                rfqQuoteReportId = quoteReportId;\n                if (rfqQuote) {\n                    return { ...rfqQuote, liquiditySource: 'rfq' };\n                }\n            } catch (e) {\n                ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                    this._chainId.toString(),\n                    GaslessSwapServiceErrorReason.RfqQuoteError,\n                ).inc();\n                logger.error(\n                    { params, errorMessage: e.message, stack: e.stack },\n                    'Encountered error when fetching RFQ quote in `GaslessSwapService`',\n                );\n            }\n        }\n\n        try {\n            let feeConfigs: FeeConfigs | undefined;\n            if (kind === GaslessTypes.MetaTransactionV2) {\n                feeConfigs = this._getFeeConfigs(params, 'on-chain'); // integrator billing type would always be on-chain for now\n            }\n\n            const metaTransactionRequestParams = {\n                ...params,\n                chainId: this._chainId,\n                affiliateAddress: params.affiliateAddress ?? params.integrator.affiliateAddress,\n                integratorId: params.integrator.integratorId,\n                quoteUniqueId: kind === GaslessTypes.MetaTransaction ? rfqQuoteReportId ?? undefined : undefined,\n                feeConfigs,\n            };\n\n            let metaTransactionQuote: MetaTransactionClientQuoteResponse | null;\n\n            switch (kind) {\n                case GaslessTypes.MetaTransaction:\n                    metaTransactionQuote = await getV1QuoteAsync(\n                        this._axiosInstance,\n                        new URL(`${this._metaTransactionServiceBaseUrl.toString()}/quote`),\n                        metaTransactionRequestParams,\n                        {\n                            requestDurationSummary: ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS,\n                            chainId: this._chainId,\n                        },\n                        logger.warn.bind(logger),\n                    );\n                    break;\n                case GaslessTypes.MetaTransactionV2:\n                    metaTransactionQuote = await getV2QuoteAsync(\n                        this._axiosInstance,\n                        new URL(`${this._metaTransactionServiceBaseUrl.toString()}/quote`),\n                        metaTransactionRequestParams,\n                        {\n                            requestDurationSummary: ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS,\n                            chainId: this._chainId,\n                        },\n                        logger.warn.bind(logger),\n                    );\n                    break;\n                case GaslessTypes.OtcOrder:\n                    // This should never happen\n                    throw new Error('GaslessTypes.OtcOrder should not be reached');\n                default:\n                    ((_x: never) => {\n                        throw new Error('unreachable');\n                    })(kind);\n            }\n\n            if (metaTransactionQuote) {\n                const approval = params.checkApproval\n                    ? await this._rfqmService.getGaslessApprovalResponseAsync(\n                          params.takerAddress,\n                          params.sellToken,\n                          metaTransactionQuote.price.sellAmount,\n                      )\n                    : null;\n                const metaTransaction = metaTransactionQuote.trade.metaTransaction;\n                // TODO: Publish fee event for meta-transaction v2\n                await this._storeMetaTransactionHashAsync(metaTransaction.getHash());\n\n                if (kind === GaslessTypes.MetaTransaction) {\n                    // Response from /meta_transaction/v1 endpoint. The meta-transaction type\n                    // can ONLY be meta-transaction v1\n                    return {\n                        ...metaTransactionQuote.price,\n                        approval: approval ?? undefined,\n                        metaTransaction,\n                        metaTransactionHash: metaTransaction.getHash(),\n                        type: GaslessTypes.MetaTransaction,\n                        allowanceTarget: this._blockchainUtils.getExchangeProxyAddress(),\n                        liquiditySource: 'amm',\n                    };\n                } else {\n                    // Response from /meta_transaction/v2 endpoint. The meta-transaction type\n                    // can either be meta-transaction v1 / v2\n                    return {\n                        ...metaTransactionQuote.price,\n                        approval: approval ?? undefined,\n                        trade: metaTransactionQuote.trade,\n                        sources: metaTransactionQuote.sources ?? [],\n                        fees: feesToTruncatedFees(metaTransactionQuote.fees),\n                        allowanceTarget: this._blockchainUtils.getExchangeProxyAddress(),\n                    };\n                }\n            }\n\n            return null;\n        } catch (e) {\n            if (e instanceof ValidationError) {\n                throw e;\n            }\n\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.AmmQuoteError,\n            ).inc();\n            logger.error(\n                { params, errorMessage: e.message, stack: e.stack },\n                'Encountered error when fetching AMM quote in `GaslessSwapService`',\n            );\n\n            // Throw here as it means RFQ throws / does not liquidity and AMM throws\n            throw new Error(`Error fetching quote for ${params}`);\n        }\n    }\n\n    /**\n     * Accepts a taker-signed MetaTransaction or OtcOrder trade, and optionally,\n     * a signed permit transaction, and produces the appropriate Job and sends\n     * a message to SQS.\n     *\n     * For lots of discussion on why the type assertions are needed, see:\n     * https://github.com/microsoft/TypeScript/issues/33912\n     */\n    public async processSubmitAsync<\n        T extends\n            | SubmitRfqmSignedQuoteWithApprovalParams<ExecuteMetaTransactionEip712Context | PermitEip712Context>\n            | SubmitMetaTransactionSignedQuoteParams<ExecuteMetaTransactionEip712Context | PermitEip712Context>\n            | SubmitMetaTransactionV2SignedQuoteParams<ExecuteMetaTransactionEip712Context | PermitEip712Context>,\n    >(\n        params: T,\n        integratorId: string,\n    ): Promise<\n        T extends SubmitRfqmSignedQuoteWithApprovalParams<ExecuteMetaTransactionEip712Context | PermitEip712Context>\n            ? SubmitRfqmSignedQuoteWithApprovalResponse\n            : T extends SubmitMetaTransactionSignedQuoteParams<\n                  ExecuteMetaTransactionEip712Context | PermitEip712Context\n              >\n            ? SubmitMetaTransactionSignedQuoteResponse\n            : SubmitMetaTransactionV2SignedQuoteResponse\n    > {\n        // OtcOrder\n        if (params.kind === GaslessTypes.OtcOrder) {\n            const otcOrderResult = await this._rfqmService.submitTakerSignedOtcOrderWithApprovalAsync(params);\n            return otcOrderResult as T extends SubmitRfqmSignedQuoteWithApprovalParams<\n                ExecuteMetaTransactionEip712Context | PermitEip712Context\n            >\n                ? SubmitRfqmSignedQuoteWithApprovalResponse\n                : T extends SubmitMetaTransactionSignedQuoteParams<\n                      ExecuteMetaTransactionEip712Context | PermitEip712Context\n                  >\n                ? SubmitMetaTransactionSignedQuoteResponse\n                : SubmitMetaTransactionV2SignedQuoteResponse;\n        }\n\n        // TODO: Add the logic to handle meta-transaction v2 when the type is ready\n        // MetaTransaction\n        const {\n            trade: { metaTransaction },\n        } = params;\n        const { inputToken, inputTokenAmount, outputToken, minOutputTokenAmount } = decodeTransformErc20Calldata(\n            metaTransaction.callData,\n        );\n\n        // Verify that the metatransaction is not expired\n        const currentTimeMs = new Date().getTime();\n        const bufferS = 30;\n        if (\n            metaTransaction.expirationTimeSeconds.minus(bufferS).times(ONE_SECOND_MS).isLessThanOrEqualTo(currentTimeMs)\n        ) {\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.MetaTransactionAboutToExpire,\n            ).inc();\n            logger.warn(\n                { metaTransactionHash: metaTransaction.getHash() },\n                'Received metatransaction submission which is about to expire',\n            );\n\n            throw new ValidationError([\n                {\n                    field: 'expirationTimeSeconds',\n                    code: ValidationErrorCodes.FieldInvalid,\n                    reason: `trade will expire too soon`,\n                },\n            ]);\n        }\n\n        // Verify that the metatransaction was created by 0x API\n        const doesMetaTransactionHashExist = await this._doesMetaTransactionHashExistAsync(metaTransaction.getHash());\n        if (!doesMetaTransactionHashExist) {\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.MetaTransactionHashNotExist,\n            ).inc();\n            logger.warn(\n                { metaTransactionHash: metaTransaction.getHash() },\n                'Received metatransaction submission not created by 0x API',\n            );\n            throw new Error('MetaTransaction hash not found');\n        }\n\n        // Verify that there is not a pending transaction for this taker and taker token\n\n        // TODO (rhinodavid): optimize this query by adding the taker & takerToken instead\n        // of filtering it out in the next step\n        const pendingJobs = await this._dbUtils.findMetaTransactionJobsWithStatusesAsync([\n            RfqmJobStatus.PendingEnqueued,\n            RfqmJobStatus.PendingProcessing,\n            RfqmJobStatus.PendingLastLookAccepted,\n            RfqmJobStatus.PendingSubmitted,\n        ]);\n\n        if (\n            pendingJobs.some(\n                (job) =>\n                    job.takerAddress.toLowerCase() === metaTransaction.signer.toLowerCase() &&\n                    job.inputToken.toLowerCase() === inputToken.toLowerCase() &&\n                    // Other logic handles the case where the same order is submitted twice\n                    job.metaTransactionHash !== metaTransaction.getHash(),\n            )\n        ) {\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.MetaTransactionPendingJobAlreadyExist,\n            ).inc();\n            logger.warn(\n                {\n                    metaTransactionHash: metaTransaction.getHash(),\n                    takerToken: inputToken,\n                    takerAddress: metaTransaction.signer.toLowerCase(),\n                },\n                'Metatransaction submission rejected because a job is pending with the same taker and taker token',\n            );\n            throw new TooManyRequestsError('a pending trade for this taker and takertoken already exists');\n        }\n\n        // validate that the given taker signature is valid\n        const signerAddress = getSignerFromHash(metaTransaction.getHash(), params.trade.signature).toLowerCase();\n        if (signerAddress !== metaTransaction.signer) {\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.MetaTransactionInvalidSigner,\n            ).inc();\n            logger.warn(\n                {\n                    metaTransactionHash: metaTransaction.getHash(),\n                    metaTransactionSigner: metaTransaction.signer,\n                    transactionSigner: signerAddress,\n                },\n                'Received submission with signer mismatch',\n            );\n            throw new ValidationError([\n                {\n                    field: 'signature',\n                    code: ValidationErrorCodes.InvalidSignatureOrHash,\n                    reason: `signature is not valid`,\n                },\n            ]);\n        }\n\n        // Validate that order is fillable according to balance and/or allowance.\n        const [takerBalance] = params.approval\n            ? await this._blockchainUtils.getTokenBalancesAsync([{ owner: metaTransaction.signer, token: inputToken }])\n            : await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync([\n                  { owner: metaTransaction.signer, token: inputToken },\n              ]);\n\n        if (takerBalance.isLessThan(inputTokenAmount)) {\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.MetaTransactionTakerBalanceCheckFailed,\n            ).inc();\n            logger.warn(\n                {\n                    takerBalance,\n                    takerAddress: metaTransaction.signer,\n                    metaTransactionHash: metaTransaction.getHash(),\n                },\n                'Balance check failed while user was submitting',\n            );\n            throw new ValidationError([\n                {\n                    field: 'n/a',\n                    code: ValidationErrorCodes.InvalidOrder,\n                    reason: `order is not fillable`,\n                },\n            ]);\n        }\n\n        const rfqmApprovalOpts = params.approval\n            ? await this._rfqmService.createApprovalAsync(params.approval, metaTransaction.getHash(), inputToken)\n            : undefined;\n\n        const jobOptions: MetaTransactionJobConstructorOpts = {\n            chainId: this._chainId,\n            expiry: metaTransaction.expirationTimeSeconds,\n            fee: { token: metaTransaction.feeToken, amount: metaTransaction.feeAmount, type: 'fixed' },\n            inputToken,\n            inputTokenAmount,\n            integratorId,\n            metaTransaction,\n            metaTransactionHash: metaTransaction.getHash(),\n            minOutputTokenAmount,\n            outputToken,\n            takerAddress: metaTransaction.signer,\n            takerSignature: params.trade.signature,\n            ...rfqmApprovalOpts,\n        };\n\n        try {\n            const { id } = await this._dbUtils.writeMetaTransactionJobAsync(jobOptions);\n            await this._enqueueJobAsync(id, GaslessTypes.MetaTransaction);\n        } catch (error) {\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\n                this._chainId.toString(),\n                GaslessSwapServiceErrorReason.MetaTransactionFailedToQueue,\n            ).inc();\n            logger.error({ errorMessage: error.message }, 'Failed to queue the quote for submission.');\n            throw new InternalServerError(\n                `failed to queue the quote for submission, it may have already been submitted`,\n            );\n        }\n\n        const result: SubmitMetaTransactionSignedQuoteResponse = {\n            metaTransactionHash: metaTransaction.getHash(),\n            type: GaslessTypes.MetaTransaction,\n        };\n\n        return result as T extends SubmitRfqmSignedQuoteWithApprovalParams<\n            ExecuteMetaTransactionEip712Context | PermitEip712Context\n        >\n            ? SubmitRfqmSignedQuoteWithApprovalResponse\n            : T extends SubmitMetaTransactionSignedQuoteParams<\n                  ExecuteMetaTransactionEip712Context | PermitEip712Context\n              >\n            ? SubmitMetaTransactionSignedQuoteResponse\n            : SubmitMetaTransactionV2SignedQuoteResponse;\n    }\n\n    public async getStatusAsync(hash: string): Promise<StatusResponse | null> {\n        return this._rfqmService.getStatusAsync(hash);\n    }\n\n    /**\n     * Passthrough to RFQm Service's `runHealthCheckAsync` method\n     */\n    public async runHealthCheckAsync(): Promise<HealthCheckResult> {\n        return this._rfqmService.runHealthCheckAsync();\n    }\n\n    /**\n     * Passthrough to RFQm Service's `getTokenDecimalsAsync` method\n     */\n    public async getTokenDecimalsAsync(tokenAddress: string): Promise<number> {\n        return this._rfqmService.getTokenDecimalsAsync(tokenAddress);\n    }\n\n    private async _enqueueJobAsync(id: string, type: GaslessTypes): Promise<void> {\n        await this._sqsProducer.send({\n            groupId: id,\n            id,\n            body: JSON.stringify({ id, type }),\n            deduplicationId: id,\n        });\n    }\n\n    private async _doesMetaTransactionHashExistAsync(hash: string): Promise<boolean> {\n        return this._redis.get(metaTransactionHashRedisKey(hash)).then((r) => !!r);\n    }\n\n    private async _storeMetaTransactionHashAsync(hash: string): Promise<void> {\n        await this._redis.set(metaTransactionHashRedisKey(hash), /* value */ 0, 'EX', META_TRANSACTION_HASH_TTL_S);\n    }\n\n    private _getFeeConfigs(params: FetchQuoteParamsBase, integratorBillingType: 'on-chain' | 'off-chain'): FeeConfigs {\n        let integratorFeeConfig;\n\n        if (params.feeType && params.feeRecipient && params.feeSellTokenPercentage) {\n            integratorFeeConfig = {\n                type: params.feeType,\n                recipient: params.feeRecipient,\n                billingType: integratorBillingType,\n                sellTokenPercentage: params.feeSellTokenPercentage,\n            };\n        }\n\n        return getFeeConfigsFromParams({\n            integratorId: params.integrator.integratorId,\n            chainId: this._chainId,\n            sellToken: params.sellToken,\n            buyToken: params.buyToken,\n            integratorFeeConfig,\n        });\n    }\n}\n"],"version":3}