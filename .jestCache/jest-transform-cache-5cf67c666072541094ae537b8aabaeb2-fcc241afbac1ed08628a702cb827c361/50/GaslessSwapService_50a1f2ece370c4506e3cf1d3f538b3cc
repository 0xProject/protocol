77ab3b096c40bb5ecff8255d646410e8
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GaslessSwapService = void 0;
// tslint:disable:max-file-line-count
const api_utils_1 = require("@0x/api-utils");
const contract_wrappers_1 = require("@0x/contract-wrappers");
const utils_1 = require("@0x/utils");
const ethers_1 = require("ethers");
const prom_client_1 = require("prom-client");
const constants_1 = require("../core/constants");
const types_1 = require("../entities/types");
const logger_1 = require("../logger");
const types_2 = require("../core/types");
const MetaTransactionClient_1 = require("../utils/MetaTransactionClient");
const signature_utils_1 = require("../utils/signature_utils");
const meta_transaction_fee_utils_1 = require("../core/meta_transaction_fee_utils");
/**
 * When a metatransaction quote is issued, the hash
 * is stored in Redis. When a quote is submitted, it
 * is only accepted if the metatransaction hash is in
 * Redis. This prevents a malicious user submitting
 * a quote which was not issued by 0x.
 *
 * The length of time the quote metatransaction hash
 * is stored in Redis.
 */
const META_TRANSACTION_HASH_TTL_S = 15 * constants_1.ONE_MINUTE_S; // tslint:disable-line binary-expression-operand-order custom-no-magic-numbers
var GaslessSwapServiceErrorReason;
(function (GaslessSwapServiceErrorReason) {
    GaslessSwapServiceErrorReason["MetaTransactionAboutToExpire"] = "meta_transaction_about_to_expire";
    GaslessSwapServiceErrorReason["MetaTransactionPendingJobAlreadyExist"] = "meta_transaction_pending_job_already_exist";
    GaslessSwapServiceErrorReason["MetaTransactionTakerBalanceCheckFailed"] = "meta_transaction_taker_balance_check_failed";
    GaslessSwapServiceErrorReason["MetaTransactionHashNotExist"] = "meta_transaction_hash_does_not_exist";
    GaslessSwapServiceErrorReason["MetaTransactionInvalidSigner"] = "meta_transaction_invalid_signer";
    GaslessSwapServiceErrorReason["MetaTransactionFailedToQueue"] = "meta_transaction_failed_to_queue";
    GaslessSwapServiceErrorReason["RfqPriceError"] = "rfq_price_error";
    GaslessSwapServiceErrorReason["AmmPriceError"] = "amm_price_error";
    GaslessSwapServiceErrorReason["RfqQuoteError"] = "rfq_quote_error";
    GaslessSwapServiceErrorReason["AmmQuoteError"] = "amm_quote_error";
})(GaslessSwapServiceErrorReason || (GaslessSwapServiceErrorReason = {}));
/**
 * Produces a key for Redis using the MetaTransaction hash
 */
function metaTransactionHashRedisKey(hash) {
    return `metaTransactionHash.${hash}`;
}
/**
 * Accepts calldata for a transformErc20 call and extracts
 * arguments from the calldata.
 */
function decodeTransformErc20Calldata(calldata) {
    const transformErc20Interface = new ethers_1.utils.Interface(contract_wrappers_1.ITransformERC20Contract.ABI());
    const result = transformErc20Interface.parseTransaction({ data: calldata });
    const { args: [inputToken, outputToken, inputTokenAmount, minOutputTokenAmount], } = result;
    return {
        inputToken: inputToken,
        outputToken: outputToken,
        // Use `toString` because these are actually Ethers BigNumbers
        inputTokenAmount: new utils_1.BigNumber(inputTokenAmount.toString()),
        minOutputTokenAmount: new utils_1.BigNumber(minOutputTokenAmount.toString()),
    };
}
const ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS = new prom_client_1.Summary({
    name: 'zerog_meta_transaction_quote_request_duration_seconds',
    help: 'Histogram of request duration of gasless swap',
    // tslint:disable-next-line: custom-no-magic-numbers
    percentiles: [0.5, 0.9, 0.95, 0.99, 0.999],
    labelNames: ['chainId', 'success'],
    maxAgeSeconds: 60,
    ageBuckets: 5,
});
const ZEROG_GASLESSS_SWAP_SERVICE_ERRORS = new prom_client_1.Counter({
    name: 'zerog_gasless_swap_service_errors_total',
    labelNames: ['chainId', 'reason'],
    help: 'Number of errors (with specific reason) encountered in galess swap service',
});
/**
 * Contains logic to fetch RFQm quotes, but with a fallback to
 * a MetaTransaction-wrapped AMM trade in the case no RFQm
 * liquidity is available.
 */
class GaslessSwapService {
    constructor(_chainId, _rfqmService, _metaTransactionServiceBaseUrl, _axiosInstance, _redis, _dbUtils, _blockchainUtils, _sqsProducer) {
        this._chainId = _chainId;
        this._rfqmService = _rfqmService;
        this._metaTransactionServiceBaseUrl = _metaTransactionServiceBaseUrl;
        this._axiosInstance = _axiosInstance;
        this._redis = _redis;
        this._dbUtils = _dbUtils;
        this._blockchainUtils = _blockchainUtils;
        this._sqsProducer = _sqsProducer;
    }
    /**
     * Fetches a "price" (aka "Indicative Quote").
     *
     * The request is first sent to market maker servers and then to the metatransaction
     * service if the market makers don't provide liquidity or errors out.
     *
     * If RFQ liquidity exists, then it is used to compute the price.
     * If AMM liquidity exists but RFQ liquidity is unavailable then
     * AMM liquidity is used to compute the price.
     *
     * Returns `null` if neither AMM or RFQ liquidity exists.
     */
    async fetchPriceAsync(params, kind) {
        var _a, _b;
        if (kind === types_2.GaslessTypes.MetaTransaction) {
            try {
                const rfqPrice = await this._rfqmService.fetchIndicativeQuoteAsync(params, 'gaslessSwapRfq');
                if (rfqPrice) {
                    return { ...rfqPrice, liquiditySource: 'rfq' };
                }
            }
            catch (e) {
                ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(this._chainId.toString(), GaslessSwapServiceErrorReason.RfqPriceError).inc();
                logger_1.logger.error({ params, errorMessage: e.message, stack: e.stack }, 'Encountered error when fetching RFQ price in `GaslessSwapService`');
            }
        }
        try {
            let feeConfigs;
            if (kind === types_2.GaslessTypes.MetaTransactionV2) {
                feeConfigs = this._getFeeConfigs(params, 'on-chain'); // integrator billing type would always be on-chain for now
            }
            const metaTransactionRequestParams = {
                ...params,
                chainId: this._chainId,
                integratorId: params.integrator.integratorId,
                // Can use the null address here since we won't be returning
                // the actual metatransaction
                takerAddress: (_a = params.takerAddress) !== null && _a !== void 0 ? _a : utils_1.NULL_ADDRESS,
                feeConfigs,
            };
            let metaTransactionQuote;
            switch (kind) {
                case types_2.GaslessTypes.MetaTransaction:
                    metaTransactionQuote = await (0, MetaTransactionClient_1.getV1QuoteAsync)(this._axiosInstance, new URL(`${this._metaTransactionServiceBaseUrl.toString()}/quote`), metaTransactionRequestParams, {
                        requestDurationSummary: ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS,
                        chainId: this._chainId,
                    }, logger_1.logger.warn.bind(logger_1.logger));
                    break;
                case types_2.GaslessTypes.MetaTransactionV2:
                    metaTransactionQuote = await (0, MetaTransactionClient_1.getV2QuoteAsync)(this._axiosInstance, new URL(`${this._metaTransactionServiceBaseUrl.toString()}/quote`), metaTransactionRequestParams, {
                        requestDurationSummary: ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS,
                        chainId: this._chainId,
                    }, logger_1.logger.warn.bind(logger_1.logger));
                    break;
                case types_2.GaslessTypes.OtcOrder:
                    // This should never happen
                    throw new Error('GaslessTypes.OtcOrder should not be reached');
                default:
                    ((_x) => {
                        throw new Error('unreachable');
                    })(kind);
            }
            if (metaTransactionQuote) {
                if (kind === types_2.GaslessTypes.MetaTransaction) {
                    return {
                        ...metaTransactionQuote.price,
                        allowanceTarget: this._blockchainUtils.getExchangeProxyAddress(),
                        liquiditySource: 'amm',
                    };
                }
                else {
                    return {
                        ...metaTransactionQuote.price,
                        sources: (_b = metaTransactionQuote.sources) !== null && _b !== void 0 ? _b : [],
                        fees: (0, meta_transaction_fee_utils_1.feesToTruncatedFees)(metaTransactionQuote.fees),
                        allowanceTarget: this._blockchainUtils.getExchangeProxyAddress(),
                    };
                }
            }
            return null;
        }
        catch (e) {
            if (e instanceof api_utils_1.ValidationError) {
                throw e;
            }
            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(this._chainId.toString(), GaslessSwapServiceErrorReason.AmmPriceError).inc();
            logger_1.logger.error({ params, errorMessage: e.message, stack: e.stack }, 'Encountered error when fetching AMM price in `GaslessSwapService`');
            // Throw here as it means RFQ throws / does not liquidity and AMM throws
            throw new Error(`Error fetching price for ${params}`);
        }
    }
    /**
     * Fetches a "quote" (aka "Firm Quote").
     *
     * Liquidity selection logic is the same as with `fetchPriceAsync`.
     *
     * If an AMM metatransaction is selected as the liquidity source,
     * its metatransaction hash is stored in Redis to be verified upon
     * submit.
     */
    async fetchQuoteAsync(params, kind) {
        var _a, _b;
        let rfqQuoteReportId = null;
        if (kind === types_2.GaslessTypes.MetaTransaction) {
            try {
                const { quote: rfqQuote, quoteReportId } = await this._rfqmService.fetchFirmQuoteAsync(params, 'gaslessSwapRfq');
                rfqQuoteReportId = quoteReportId;
                if (rfqQuote) {
                    return { ...rfqQuote, liquiditySource: 'rfq' };
                }
            }
            catch (e) {
                ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(this._chainId.toString(), GaslessSwapServiceErrorReason.RfqQuoteError).inc();
                logger_1.logger.error({ params, errorMessage: e.message, stack: e.stack }, 'Encountered error when fetching RFQ quote in `GaslessSwapService`');
            }
        }
        try {
            let feeConfigs;
            if (kind === types_2.GaslessTypes.MetaTransactionV2) {
                feeConfigs = this._getFeeConfigs(params, 'on-chain'); // integrator billing type would always be on-chain for now
            }
            const metaTransactionRequestParams = {
                ...params,
                chainId: this._chainId,
                affiliateAddress: (_a = params.affiliateAddress) !== null && _a !== void 0 ? _a : params.integrator.affiliateAddress,
                integratorId: params.integrator.integratorId,
                quoteUniqueId: kind === types_2.GaslessTypes.MetaTransaction ? rfqQuoteReportId !== null && rfqQuoteReportId !== void 0 ? rfqQuoteReportId : undefined : undefined,
                feeConfigs,
            };
            let metaTransactionQuote;
            switch (kind) {
                case types_2.GaslessTypes.MetaTransaction:
                    metaTransactionQuote = await (0, MetaTransactionClient_1.getV1QuoteAsync)(this._axiosInstance, new URL(`${this._metaTransactionServiceBaseUrl.toString()}/quote`), metaTransactionRequestParams, {
                        requestDurationSummary: ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS,
                        chainId: this._chainId,
                    }, logger_1.logger.warn.bind(logger_1.logger));
                    break;
                case types_2.GaslessTypes.MetaTransactionV2:
                    metaTransactionQuote = await (0, MetaTransactionClient_1.getV2QuoteAsync)(this._axiosInstance, new URL(`${this._metaTransactionServiceBaseUrl.toString()}/quote`), metaTransactionRequestParams, {
                        requestDurationSummary: ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS,
                        chainId: this._chainId,
                    }, logger_1.logger.warn.bind(logger_1.logger));
                    break;
                case types_2.GaslessTypes.OtcOrder:
                    // This should never happen
                    throw new Error('GaslessTypes.OtcOrder should not be reached');
                default:
                    ((_x) => {
                        throw new Error('unreachable');
                    })(kind);
            }
            if (metaTransactionQuote) {
                const approval = params.checkApproval
                    ? await this._rfqmService.getGaslessApprovalResponseAsync(params.takerAddress, params.sellToken, metaTransactionQuote.price.sellAmount)
                    : null;
                const metaTransaction = metaTransactionQuote.trade.metaTransaction;
                // TODO: Publish fee event for meta-transaction v2
                await this._storeMetaTransactionHashAsync(metaTransaction.getHash());
                if (kind === types_2.GaslessTypes.MetaTransaction) {
                    // Response from /meta_transaction/v1 endpoint. The meta-transaction type
                    // can ONLY be meta-transaction v1
                    return {
                        ...metaTransactionQuote.price,
                        approval: approval !== null && approval !== void 0 ? approval : undefined,
                        metaTransaction,
                        metaTransactionHash: metaTransaction.getHash(),
                        type: types_2.GaslessTypes.MetaTransaction,
                        allowanceTarget: this._blockchainUtils.getExchangeProxyAddress(),
                        liquiditySource: 'amm',
                    };
                }
                else {
                    // Response from /meta_transaction/v2 endpoint. The meta-transaction type
                    // can either be meta-transaction v1 / v2
                    return {
                        ...metaTransactionQuote.price,
                        approval: approval !== null && approval !== void 0 ? approval : undefined,
                        trade: metaTransactionQuote.trade,
                        sources: (_b = metaTransactionQuote.sources) !== null && _b !== void 0 ? _b : [],
                        fees: (0, meta_transaction_fee_utils_1.feesToTruncatedFees)(metaTransactionQuote.fees),
                        allowanceTarget: this._blockchainUtils.getExchangeProxyAddress(),
                    };
                }
            }
            return null;
        }
        catch (e) {
            if (e instanceof api_utils_1.ValidationError) {
                throw e;
            }
            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(this._chainId.toString(), GaslessSwapServiceErrorReason.AmmQuoteError).inc();
            logger_1.logger.error({ params, errorMessage: e.message, stack: e.stack }, 'Encountered error when fetching AMM quote in `GaslessSwapService`');
            // Throw here as it means RFQ throws / does not liquidity and AMM throws
            throw new Error(`Error fetching quote for ${params}`);
        }
    }
    /**
     * Accepts a taker-signed MetaTransaction or OtcOrder trade, and optionally,
     * a signed permit transaction, and produces the appropriate Job and sends
     * a message to SQS.
     *
     * For lots of discussion on why the type assertions are needed, see:
     * https://github.com/microsoft/TypeScript/issues/33912
     */
    async processSubmitAsync(params, integratorId) {
        // OtcOrder
        if (params.kind === types_2.GaslessTypes.OtcOrder) {
            const otcOrderResult = await this._rfqmService.submitTakerSignedOtcOrderWithApprovalAsync(params);
            return otcOrderResult;
        }
        // TODO: Add the logic to handle meta-transaction v2 when the type is ready
        // MetaTransaction
        const { trade: { metaTransaction }, } = params;
        const { inputToken, inputTokenAmount, outputToken, minOutputTokenAmount } = decodeTransformErc20Calldata(metaTransaction.callData);
        // Verify that the metatransaction is not expired
        const currentTimeMs = new Date().getTime();
        const bufferS = 30;
        if (metaTransaction.expirationTimeSeconds.minus(bufferS).times(constants_1.ONE_SECOND_MS).isLessThanOrEqualTo(currentTimeMs)) {
            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(this._chainId.toString(), GaslessSwapServiceErrorReason.MetaTransactionAboutToExpire).inc();
            logger_1.logger.warn({ metaTransactionHash: metaTransaction.getHash() }, 'Received metatransaction submission which is about to expire');
            throw new api_utils_1.ValidationError([
                {
                    field: 'expirationTimeSeconds',
                    code: api_utils_1.ValidationErrorCodes.FieldInvalid,
                    reason: `trade will expire too soon`,
                },
            ]);
        }
        // Verify that the metatransaction was created by 0x API
        const doesMetaTransactionHashExist = await this._doesMetaTransactionHashExistAsync(metaTransaction.getHash());
        if (!doesMetaTransactionHashExist) {
            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(this._chainId.toString(), GaslessSwapServiceErrorReason.MetaTransactionHashNotExist).inc();
            logger_1.logger.warn({ metaTransactionHash: metaTransaction.getHash() }, 'Received metatransaction submission not created by 0x API');
            throw new Error('MetaTransaction hash not found');
        }
        // Verify that there is not a pending transaction for this taker and taker token
        // TODO (rhinodavid): optimize this query by adding the taker & takerToken instead
        // of filtering it out in the next step
        const pendingJobs = await this._dbUtils.findMetaTransactionJobsWithStatusesAsync([
            types_1.RfqmJobStatus.PendingEnqueued,
            types_1.RfqmJobStatus.PendingProcessing,
            types_1.RfqmJobStatus.PendingLastLookAccepted,
            types_1.RfqmJobStatus.PendingSubmitted,
        ]);
        if (pendingJobs.some((job) => job.takerAddress.toLowerCase() === metaTransaction.signer.toLowerCase() &&
            job.inputToken.toLowerCase() === inputToken.toLowerCase() &&
            // Other logic handles the case where the same order is submitted twice
            job.metaTransactionHash !== metaTransaction.getHash())) {
            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(this._chainId.toString(), GaslessSwapServiceErrorReason.MetaTransactionPendingJobAlreadyExist).inc();
            logger_1.logger.warn({
                metaTransactionHash: metaTransaction.getHash(),
                takerToken: inputToken,
                takerAddress: metaTransaction.signer.toLowerCase(),
            }, 'Metatransaction submission rejected because a job is pending with the same taker and taker token');
            throw new api_utils_1.TooManyRequestsError('a pending trade for this taker and takertoken already exists');
        }
        // validate that the given taker signature is valid
        const signerAddress = (0, signature_utils_1.getSignerFromHash)(metaTransaction.getHash(), params.trade.signature).toLowerCase();
        if (signerAddress !== metaTransaction.signer) {
            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(this._chainId.toString(), GaslessSwapServiceErrorReason.MetaTransactionInvalidSigner).inc();
            logger_1.logger.warn({
                metaTransactionHash: metaTransaction.getHash(),
                metaTransactionSigner: metaTransaction.signer,
                transactionSigner: signerAddress,
            }, 'Received submission with signer mismatch');
            throw new api_utils_1.ValidationError([
                {
                    field: 'signature',
                    code: api_utils_1.ValidationErrorCodes.InvalidSignatureOrHash,
                    reason: `signature is not valid`,
                },
            ]);
        }
        // Validate that order is fillable according to balance and/or allowance.
        const [takerBalance] = params.approval
            ? await this._blockchainUtils.getTokenBalancesAsync([{ owner: metaTransaction.signer, token: inputToken }])
            : await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync([
                { owner: metaTransaction.signer, token: inputToken },
            ]);
        if (takerBalance.isLessThan(inputTokenAmount)) {
            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(this._chainId.toString(), GaslessSwapServiceErrorReason.MetaTransactionTakerBalanceCheckFailed).inc();
            logger_1.logger.warn({
                takerBalance,
                takerAddress: metaTransaction.signer,
                metaTransactionHash: metaTransaction.getHash(),
            }, 'Balance check failed while user was submitting');
            throw new api_utils_1.ValidationError([
                {
                    field: 'n/a',
                    code: api_utils_1.ValidationErrorCodes.InvalidOrder,
                    reason: `order is not fillable`,
                },
            ]);
        }
        const rfqmApprovalOpts = params.approval
            ? await this._rfqmService.createApprovalAsync(params.approval, metaTransaction.getHash(), inputToken)
            : undefined;
        const jobOptions = {
            chainId: this._chainId,
            expiry: metaTransaction.expirationTimeSeconds,
            fee: { token: metaTransaction.feeToken, amount: metaTransaction.feeAmount, type: 'fixed' },
            inputToken,
            inputTokenAmount,
            integratorId,
            metaTransaction,
            metaTransactionHash: metaTransaction.getHash(),
            minOutputTokenAmount,
            outputToken,
            takerAddress: metaTransaction.signer,
            takerSignature: params.trade.signature,
            ...rfqmApprovalOpts,
        };
        try {
            const { id } = await this._dbUtils.writeMetaTransactionJobAsync(jobOptions);
            await this._enqueueJobAsync(id, types_2.GaslessTypes.MetaTransaction);
        }
        catch (error) {
            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(this._chainId.toString(), GaslessSwapServiceErrorReason.MetaTransactionFailedToQueue).inc();
            logger_1.logger.error({ errorMessage: error.message }, 'Failed to queue the quote for submission.');
            throw new api_utils_1.InternalServerError(`failed to queue the quote for submission, it may have already been submitted`);
        }
        const result = {
            metaTransactionHash: metaTransaction.getHash(),
            type: types_2.GaslessTypes.MetaTransaction,
        };
        return result;
    }
    async getStatusAsync(hash) {
        return this._rfqmService.getStatusAsync(hash);
    }
    /**
     * Passthrough to RFQm Service's `runHealthCheckAsync` method
     */
    async runHealthCheckAsync() {
        return this._rfqmService.runHealthCheckAsync();
    }
    /**
     * Passthrough to RFQm Service's `getTokenDecimalsAsync` method
     */
    async getTokenDecimalsAsync(tokenAddress) {
        return this._rfqmService.getTokenDecimalsAsync(tokenAddress);
    }
    async _enqueueJobAsync(id, type) {
        await this._sqsProducer.send({
            groupId: id,
            id,
            body: JSON.stringify({ id, type }),
            deduplicationId: id,
        });
    }
    async _doesMetaTransactionHashExistAsync(hash) {
        return this._redis.get(metaTransactionHashRedisKey(hash)).then((r) => !!r);
    }
    async _storeMetaTransactionHashAsync(hash) {
        await this._redis.set(metaTransactionHashRedisKey(hash), /* value */ 0, 'EX', META_TRANSACTION_HASH_TTL_S);
    }
    _getFeeConfigs(params, integratorBillingType) {
        let integratorFeeConfig;
        if (params.feeType && params.feeRecipient && params.feeSellTokenPercentage) {
            integratorFeeConfig = {
                type: params.feeType,
                recipient: params.feeRecipient,
                billingType: integratorBillingType,
                sellTokenPercentage: params.feeSellTokenPercentage,
            };
        }
        return (0, meta_transaction_fee_utils_1.getFeeConfigsFromParams)({
            integratorId: params.integrator.integratorId,
            chainId: this._chainId,
            sellToken: params.sellToken,
            buyToken: params.buyToken,
            integratorFeeConfig,
        });
    }
}
exports.GaslessSwapService = GaslessSwapService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9zZXJ2aWNlcy9HYXNsZXNzU3dhcFNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEscUNBQXFDO0FBQ3JDLDZDQUFpSDtBQUNqSCw2REFBZ0U7QUFDaEUscUNBQW9EO0FBRXBELG1DQUE4QztBQUU5Qyw2Q0FBK0M7QUFHL0MsaURBQWdFO0FBRWhFLDZDQUFrRDtBQUNsRCxzQ0FBbUM7QUFDbkMseUNBQXVHO0FBRXZHLDBFQUFzSDtBQUl0SCw4REFBNkQ7QUFvQjdELG1GQUFrRztBQUVsRzs7Ozs7Ozs7O0dBU0c7QUFDSCxNQUFNLDJCQUEyQixHQUFHLEVBQUUsR0FBRyx3QkFBWSxDQUFDLENBQUMsOEVBQThFO0FBRXJJLElBQUssNkJBV0o7QUFYRCxXQUFLLDZCQUE2QjtJQUM5QixrR0FBaUUsQ0FBQTtJQUNqRSxxSEFBb0YsQ0FBQTtJQUNwRix1SEFBc0YsQ0FBQTtJQUN0RixxR0FBb0UsQ0FBQTtJQUNwRSxpR0FBZ0UsQ0FBQTtJQUNoRSxrR0FBaUUsQ0FBQTtJQUNqRSxrRUFBaUMsQ0FBQTtJQUNqQyxrRUFBaUMsQ0FBQTtJQUNqQyxrRUFBaUMsQ0FBQTtJQUNqQyxrRUFBaUMsQ0FBQTtBQUNyQyxDQUFDLEVBWEksNkJBQTZCLEtBQTdCLDZCQUE2QixRQVdqQztBQUVEOztHQUVHO0FBQ0gsU0FBUywyQkFBMkIsQ0FBQyxJQUFZO0lBQzdDLE9BQU8sdUJBQXVCLElBQUksRUFBRSxDQUFDO0FBQ3pDLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFTLDRCQUE0QixDQUFDLFFBQWdCO0lBTWxELE1BQU0sdUJBQXVCLEdBQUcsSUFBSSxjQUFXLENBQUMsU0FBUyxDQUFDLDJDQUF1QixDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFFekYsTUFBTSxNQUFNLEdBQUcsdUJBQXVCLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUU1RSxNQUFNLEVBQ0YsSUFB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Q0FBQyxZQUFZLElBQUksTUFBTSxDQUFDLHNCQUFzQixFQUFFO1lBQ3hFLG1CQUFtQixHQUFHO2dCQUNsQixJQUFJLEVBQUUsTUFBTSxDQUFDLE9BQU87Z0JBQ3BCLFNBQVMsRUFBRSxNQUFNLENBQUMsWUFBWTtnQkFDOUIsV0FBVyxFQUFFLHFCQUFxQjtnQkFDbEMsbUJBQW1CLEVBQUUsTUFBTSxDQUFDLHNCQUFzQjthQUNyRCxDQUFDO1NBQ0w7UUFFRCxPQUFPLElBQUEsb0RBQXVCLEVBQUM7WUFDM0IsWUFBWSxFQUFFLE1BQU0sQ0FBQyxVQUFVLENBQUMsWUFBWTtZQUM1QyxPQUFPLEVBQUUsSUFBSSxDQUFDLFFBQVE7WUFDdEIsU0FBUyxFQUFFLE1BQU0sQ0FBQyxTQUFTO1lBQzNCLFFBQVEsRUFBRSxNQUFNLENBQUMsUUFBUTtZQUN6QixtQkFBbUI7U0FDdEIsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztDQUNKO0FBdmpCRCxnREF1akJDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXZpZHdhbHNoL2NvZGUtbG9jYWwvMHgtcmZxLWFwaS9zcmMvc2VydmljZXMvR2FzbGVzc1N3YXBTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRzbGludDpkaXNhYmxlOm1heC1maWxlLWxpbmUtY291bnRcbmltcG9ydCB7IEludGVybmFsU2VydmVyRXJyb3IsIFRvb01hbnlSZXF1ZXN0c0Vycm9yLCBWYWxpZGF0aW9uRXJyb3IsIFZhbGlkYXRpb25FcnJvckNvZGVzIH0gZnJvbSAnQDB4L2FwaS11dGlscyc7XG5pbXBvcnQgeyBJVHJhbnNmb3JtRVJDMjBDb250cmFjdCB9IGZyb20gJ0AweC9jb250cmFjdC13cmFwcGVycyc7XG5pbXBvcnQgeyBCaWdOdW1iZXIsIE5VTExfQUREUkVTUyB9IGZyb20gJ0AweC91dGlscyc7XG5pbXBvcnQgeyBBeGlvc0luc3RhbmNlIH0gZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgdXRpbHMgYXMgZXRoZXJzVXRpbHMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IFJlZGlzIGZyb20gJ2lvcmVkaXMnO1xuaW1wb3J0IHsgQ291bnRlciwgU3VtbWFyeSB9IGZyb20gJ3Byb20tY2xpZW50JztcbmltcG9ydCB7IFByb2R1Y2VyIH0gZnJvbSAnc3FzLXByb2R1Y2VyJztcblxuaW1wb3J0IHsgT05FX01JTlVURV9TLCBPTkVfU0VDT05EX01TIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMnO1xuaW1wb3J0IHsgTWV0YVRyYW5zYWN0aW9uSm9iQ29uc3RydWN0b3JPcHRzIH0gZnJvbSAnLi4vZW50aXRpZXMvTWV0YVRyYW5zYWN0aW9uSm9iRW50aXR5JztcbmltcG9ydCB7IFJmcW1Kb2JTdGF0dXMgfSBmcm9tICcuLi9lbnRpdGllcy90eXBlcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkVpcDcxMkNvbnRleHQsIFBlcm1pdEVpcDcxMkNvbnRleHQsIEdhc2xlc3NUeXBlcyB9IGZyb20gJy4uL2NvcmUvdHlwZXMnO1xuaW1wb3J0IHsgRmVlQ29uZmlncywgVHJ1bmNhdGVkRmVlcyB9IGZyb20gJy4uL2NvcmUvdHlwZXMvbWV0YV90cmFuc2FjdGlvbl9mZWVzJztcbmltcG9ydCB7IGdldFYxUXVvdGVBc3luYywgZ2V0VjJRdW90ZUFzeW5jLCBNZXRhVHJhbnNhY3Rpb25DbGllbnRRdW90ZVJlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMvTWV0YVRyYW5zYWN0aW9uQ2xpZW50JztcbmltcG9ydCB7IFJmcW1EYlV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvcmZxbV9kYl91dGlscyc7XG5pbXBvcnQgeyBIZWFsdGhDaGVja1Jlc3VsdCB9IGZyb20gJy4uL3V0aWxzL3JmcW1faGVhbHRoX2NoZWNrJztcbmltcG9ydCB7IFJmcUJsb2NrY2hhaW5VdGlscyB9IGZyb20gJy4uL3V0aWxzL3JmcV9ibG9ja2NoYWluX3V0aWxzJztcbmltcG9ydCB7IGdldFNpZ25lckZyb21IYXNoIH0gZnJvbSAnLi4vdXRpbHMvc2lnbmF0dXJlX3V0aWxzJztcblxuaW1wb3J0IHsgUmZxbVNlcnZpY2UgfSBmcm9tICcuL3JmcW1fc2VydmljZSc7XG5pbXBvcnQge1xuICAgIEZldGNoRmlybVF1b3RlUGFyYW1zLFxuICAgIEZldGNoSW5kaWNhdGl2ZVF1b3RlUGFyYW1zLFxuICAgIEZldGNoSW5kaWNhdGl2ZVF1b3RlUmVzcG9uc2UsXG4gICAgTWV0YVRyYW5zYWN0aW9uVjFRdW90ZVJlc3BvbnNlLFxuICAgIE1ldGFUcmFuc2FjdGlvblYyUXVvdGVSZXNwb25zZSxcbiAgICBPdGNPcmRlclJmcW1RdW90ZVJlc3BvbnNlLFxuICAgIFN1Ym1pdE1ldGFUcmFuc2FjdGlvblNpZ25lZFF1b3RlUGFyYW1zLFxuICAgIFN1Ym1pdE1ldGFUcmFuc2FjdGlvblNpZ25lZFF1b3RlUmVzcG9uc2UsXG4gICAgU3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUGFyYW1zLFxuICAgIFN1Ym1pdFJmcW1TaWduZWRRdW90ZVdpdGhBcHByb3ZhbFJlc3BvbnNlLFxuICAgIExpcXVpZGl0eVNvdXJjZSxcbiAgICBTdWJtaXRNZXRhVHJhbnNhY3Rpb25WMlNpZ25lZFF1b3RlUGFyYW1zLFxuICAgIFN1Ym1pdE1ldGFUcmFuc2FjdGlvblYyU2lnbmVkUXVvdGVSZXNwb25zZSxcbiAgICBTdGF0dXNSZXNwb25zZSxcbiAgICBGZXRjaFF1b3RlUGFyYW1zQmFzZSxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBmZWVzVG9UcnVuY2F0ZWRGZWVzLCBnZXRGZWVDb25maWdzRnJvbVBhcmFtcyB9IGZyb20gJy4uL2NvcmUvbWV0YV90cmFuc2FjdGlvbl9mZWVfdXRpbHMnO1xuXG4vKipcbiAqIFdoZW4gYSBtZXRhdHJhbnNhY3Rpb24gcXVvdGUgaXMgaXNzdWVkLCB0aGUgaGFzaFxuICogaXMgc3RvcmVkIGluIFJlZGlzLiBXaGVuIGEgcXVvdGUgaXMgc3VibWl0dGVkLCBpdFxuICogaXMgb25seSBhY2NlcHRlZCBpZiB0aGUgbWV0YXRyYW5zYWN0aW9uIGhhc2ggaXMgaW5cbiAqIFJlZGlzLiBUaGlzIHByZXZlbnRzIGEgbWFsaWNpb3VzIHVzZXIgc3VibWl0dGluZ1xuICogYSBxdW90ZSB3aGljaCB3YXMgbm90IGlzc3VlZCBieSAweC5cbiAqXG4gKiBUaGUgbGVuZ3RoIG9mIHRpbWUgdGhlIHF1b3RlIG1ldGF0cmFuc2FjdGlvbiBoYXNoXG4gKiBpcyBzdG9yZWQgaW4gUmVkaXMuXG4gKi9cbmNvbnN0IE1FVEFfVFJBTlNBQ1RJT05fSEFTSF9UVExfUyA9IDE1ICogT05FX01JTlVURV9TOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lIGJpbmFyeS1leHByZXNzaW9uLW9wZXJhbmQtb3JkZXIgY3VzdG9tLW5vLW1hZ2ljLW51bWJlcnNcblxuZW51bSBHYXNsZXNzU3dhcFNlcnZpY2VFcnJvclJlYXNvbiB7XG4gICAgTWV0YVRyYW5zYWN0aW9uQWJvdXRUb0V4cGlyZSA9ICdtZXRhX3RyYW5zYWN0aW9uX2Fib3V0X3RvX2V4cGlyZScsIC8vIG1ldGEtdHJhbnNhY3Rpb24gaXMgYWJvdXQgdG8gZXhwaXJlXG4gICAgTWV0YVRyYW5zYWN0aW9uUGVuZGluZ0pvYkFscmVhZHlFeGlzdCA9ICdtZXRhX3RyYW5zYWN0aW9uX3BlbmRpbmdfam9iX2FscmVhZHlfZXhpc3QnLCAvLyBhIHBlbmRpbmdtZXRhLXRyYW5zYWN0aW9uIGpvYiBhbHJlYWR5IGV4aXN0cyBmb3IgYSB0YWtlci10YWtlclRva2VuXG4gICAgTWV0YVRyYW5zYWN0aW9uVGFrZXJCYWxhbmNlQ2hlY2tGYWlsZWQgPSAnbWV0YV90cmFuc2FjdGlvbl90YWtlcl9iYWxhbmNlX2NoZWNrX2ZhaWxlZCcsIC8vIHRha2VyIGJhbGFuY2UgY2hlY2sgZmFpbGVkIHdoZW4gc3VibWl0dGluZyBhIG1ldGEtdHJhbnNhY3Rpb25cbiAgICBNZXRhVHJhbnNhY3Rpb25IYXNoTm90RXhpc3QgPSAnbWV0YV90cmFuc2FjdGlvbl9oYXNoX2RvZXNfbm90X2V4aXN0JywgLy8gbWV0YS10cmFuc2FjdGlvbiBoYXNoIGRvZXMgbm90IGV4aXN0XG4gICAgTWV0YVRyYW5zYWN0aW9uSW52YWxpZFNpZ25lciA9ICdtZXRhX3RyYW5zYWN0aW9uX2ludmFsaWRfc2lnbmVyJywgLy8gaW52YWxpZCBzaWduZXIgZm9yIHRoZSBtdGEtdHJhbnNhY3Rpb25cbiAgICBNZXRhVHJhbnNhY3Rpb25GYWlsZWRUb1F1ZXVlID0gJ21ldGFfdHJhbnNhY3Rpb25fZmFpbGVkX3RvX3F1ZXVlJywgLy8gZmFpbGVkIHRvIHF1ZXVlIG1ldGEtdHJhbnNhY3Rpb25cbiAgICBSZnFQcmljZUVycm9yID0gJ3JmcV9wcmljZV9lcnJvcicsIC8vIGVuY291bnRlcmVkIGVycm9yIHdoZW4gZmV0Y2hpbmcgcmZxIHByaWNlXG4gICAgQW1tUHJpY2VFcnJvciA9ICdhbW1fcHJpY2VfZXJyb3InLCAvLyBlbmNvdW50ZXJlZCBlcnJvciB3aGVuIGZldGNoaW5nIGFtbSBwcmljZVxuICAgIFJmcVF1b3RlRXJyb3IgPSAncmZxX3F1b3RlX2Vycm9yJywgLy8gZW5jb3VudGVyZWQgZXJyb3Igd2hlbiBmZXRjaGluZyByZnEgcXVvdGVcbiAgICBBbW1RdW90ZUVycm9yID0gJ2FtbV9xdW90ZV9lcnJvcicsIC8vIGVuY291bnRlcmVkIGVycm9yIHdoZW4gZmV0Y2hpbmcgYW1tIHF1b3RlXG59XG5cbi8qKlxuICogUHJvZHVjZXMgYSBrZXkgZm9yIFJlZGlzIHVzaW5nIHRoZSBNZXRhVHJhbnNhY3Rpb24gaGFzaFxuICovXG5mdW5jdGlvbiBtZXRhVHJhbnNhY3Rpb25IYXNoUmVkaXNLZXkoaGFzaDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYG1ldGFUcmFuc2FjdGlvbkhhc2guJHtoYXNofWA7XG59XG5cbi8qKlxuICogQWNjZXB0cyBjYWxsZGF0YSBmb3IgYSB0cmFuc2Zvcm1FcmMyMCBjYWxsIGFuZCBleHRyYWN0c1xuICogYXJndW1lbnRzIGZyb20gdGhlIGNhbGxkYXRhLlxuICovXG5mdW5jdGlvbiBkZWNvZGVUcmFuc2Zvcm1FcmMyMENhbGxkYXRhKGNhbGxkYXRhOiBzdHJpbmcpOiB7XG4gICAgaW5wdXRUb2tlbjogc3RyaW5nO1xuICAgIG91dHB1dFRva2VuOiBzdHJpbmc7XG4gICAgaW5wdXRUb2tlbkFtb3VudDogQmlnTnVtYmVyO1xuICAgIG1pbk91dHB1dFRva2VuQW1vdW50OiBCaWdOdW1iZXI7XG59IHtcbiAgICBjb25zdCB0cmFuc2Zvcm1FcmMyMEludGVyZmFjZSA9IG5ldyBldGhlcnNVdGlscy5JbnRlcmZhY2UoSVRyYW5zZm9ybUVSQzIwQ29udHJhY3QuQUJJKCkpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNmb3JtRXJjMjBJbnRlcmZhY2UucGFyc2VUcmFuc2FjdGlvbih7IGRhdGE6IGNhbGxkYXRhIH0pO1xuXG4gICAgY29uc3Qge1xuICAgICAgICBhcmdzOiBbaW5wdXRUb2tlbiwgb3V0cHV0VG9rZW4sIGlucHV0VG9rZW5BbW91bnQsIG1pbk91dHB1dFRva2VuQW1vdW50XSxcbiAgICB9ID0gcmVzdWx0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXRUb2tlbjogaW5wdXRUb2tlbiBhcyBzdHJpbmcsXG4gICAgICAgIG91dHB1dFRva2VuOiBvdXRwdXRUb2tlbiBhcyBzdHJpbmcsXG4gICAgICAgIC8vIFVzZSBgdG9TdHJpbmdgIGJlY2F1c2UgdGhlc2UgYXJlIGFjdHVhbGx5IEV0aGVycyBCaWdOdW1iZXJzXG4gICAgICAgIGlucHV0VG9rZW5BbW91bnQ6IG5ldyBCaWdOdW1iZXIoaW5wdXRUb2tlbkFtb3VudC50b1N0cmluZygpKSxcbiAgICAgICAgbWluT3V0cHV0VG9rZW5BbW91bnQ6IG5ldyBCaWdOdW1iZXIobWluT3V0cHV0VG9rZW5BbW91bnQudG9TdHJpbmcoKSksXG4gICAgfTtcbn1cblxuY29uc3QgWkVST0dfTUVUQV9UUkFOU0FDVElPTl9RVU9URV9SRVFVRVNUX0RVUkFUSU9OX1NFQ09ORFMgPSBuZXcgU3VtbWFyeSh7XG4gICAgbmFtZTogJ3plcm9nX21ldGFfdHJhbnNhY3Rpb25fcXVvdGVfcmVxdWVzdF9kdXJhdGlvbl9zZWNvbmRzJyxcbiAgICBoZWxwOiAnSGlzdG9ncmFtIG9mIHJlcXVlc3QgZHVyYXRpb24gb2YgZ2FzbGVzcyBzd2FwJyxcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGN1c3RvbS1uby1tYWdpYy1udW1iZXJzXG4gICAgcGVyY2VudGlsZXM6IFswLjUsIDAuOSwgMC45NSwgMC45OSwgMC45OTldLFxuICAgIGxhYmVsTmFtZXM6IFsnY2hhaW5JZCcsICdzdWNjZXNzJ10sXG4gICAgbWF4QWdlU2Vjb25kczogNjAsXG4gICAgYWdlQnVja2V0czogNSxcbn0pO1xuY29uc3QgWkVST0dfR0FTTEVTU1NfU1dBUF9TRVJWSUNFX0VSUk9SUyA9IG5ldyBDb3VudGVyKHtcbiAgICBuYW1lOiAnemVyb2dfZ2FzbGVzc19zd2FwX3NlcnZpY2VfZXJyb3JzX3RvdGFsJyxcbiAgICBsYWJlbE5hbWVzOiBbJ2NoYWluSWQnLCAncmVhc29uJ10sXG4gICAgaGVscDogJ051bWJlciBvZiBlcnJvcnMgKHdpdGggc3BlY2lmaWMgcmVhc29uKSBlbmNvdW50ZXJlZCBpbiBnYWxlc3Mgc3dhcCBzZXJ2aWNlJyxcbn0pO1xuXG4vKipcbiAqIENvbnRhaW5zIGxvZ2ljIHRvIGZldGNoIFJGUW0gcXVvdGVzLCBidXQgd2l0aCBhIGZhbGxiYWNrIHRvXG4gKiBhIE1ldGFUcmFuc2FjdGlvbi13cmFwcGVkIEFNTSB0cmFkZSBpbiB0aGUgY2FzZSBubyBSRlFtXG4gKiBsaXF1aWRpdHkgaXMgYXZhaWxhYmxlLlxuICovXG5leHBvcnQgY2xhc3MgR2FzbGVzc1N3YXBTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfY2hhaW5JZDogbnVtYmVyLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9yZnFtU2VydmljZTogUmZxbVNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX21ldGFUcmFuc2FjdGlvblNlcnZpY2VCYXNlVXJsOiBVUkwsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX2F4aW9zSW5zdGFuY2U6IEF4aW9zSW5zdGFuY2UsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX3JlZGlzOiBSZWRpcyxcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfZGJVdGlsczogUmZxbURiVXRpbHMsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX2Jsb2NrY2hhaW5VdGlsczogUmZxQmxvY2tjaGFpblV0aWxzLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9zcXNQcm9kdWNlcjogUHJvZHVjZXIsXG4gICAgKSB7fVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIFwicHJpY2VcIiAoYWthIFwiSW5kaWNhdGl2ZSBRdW90ZVwiKS5cbiAgICAgKlxuICAgICAqIFRoZSByZXF1ZXN0IGlzIGZpcnN0IHNlbnQgdG8gbWFya2V0IG1ha2VyIHNlcnZlcnMgYW5kIHRoZW4gdG8gdGhlIG1ldGF0cmFuc2FjdGlvblxuICAgICAqIHNlcnZpY2UgaWYgdGhlIG1hcmtldCBtYWtlcnMgZG9uJ3QgcHJvdmlkZSBsaXF1aWRpdHkgb3IgZXJyb3JzIG91dC5cbiAgICAgKlxuICAgICAqIElmIFJGUSBsaXF1aWRpdHkgZXhpc3RzLCB0aGVuIGl0IGlzIHVzZWQgdG8gY29tcHV0ZSB0aGUgcHJpY2UuXG4gICAgICogSWYgQU1NIGxpcXVpZGl0eSBleGlzdHMgYnV0IFJGUSBsaXF1aWRpdHkgaXMgdW5hdmFpbGFibGUgdGhlblxuICAgICAqIEFNTSBsaXF1aWRpdHkgaXMgdXNlZCB0byBjb21wdXRlIHRoZSBwcmljZS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYG51bGxgIGlmIG5laXRoZXIgQU1NIG9yIFJGUSBsaXF1aWRpdHkgZXhpc3RzLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBmZXRjaFByaWNlQXN5bmMoXG4gICAgICAgIHBhcmFtczogRmV0Y2hJbmRpY2F0aXZlUXVvdGVQYXJhbXMsXG4gICAgICAgIGtpbmQ6IEdhc2xlc3NUeXBlcyxcbiAgICApOiBQcm9taXNlPFxuICAgICAgICB8IChGZXRjaEluZGljYXRpdmVRdW90ZVJlc3BvbnNlICZcbiAgICAgICAgICAgICAgKHsgbGlxdWlkaXR5U291cmNlOiAncmZxJyB8ICdhbW0nIH0gfCB7IHNvdXJjZXM6IExpcXVpZGl0eVNvdXJjZVtdOyBmZWVzPzogVHJ1bmNhdGVkRmVlcyB9KSlcbiAgICAgICAgfCBudWxsXG4gICAgPiB7XG4gICAgICAgIGlmIChraW5kID09PSBHYXNsZXNzVHlwZXMuTWV0YVRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJmcVByaWNlID0gYXdhaXQgdGhpcy5fcmZxbVNlcnZpY2UuZmV0Y2hJbmRpY2F0aXZlUXVvdGVBc3luYyhwYXJhbXMsICdnYXNsZXNzU3dhcFJmcScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJmcVByaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnJmcVByaWNlLCBsaXF1aWRpdHlTb3VyY2U6ICdyZnEnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIFpFUk9HX0dBU0xFU1NTX1NXQVBfU0VSVklDRV9FUlJPUlMubGFiZWxzKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIEdhc2xlc3NTd2FwU2VydmljZUVycm9yUmVhc29uLlJmcVByaWNlRXJyb3IsXG4gICAgICAgICAgICAgICAgKS5pbmMoKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHsgcGFyYW1zLCBlcnJvck1lc3NhZ2U6IGUubWVzc2FnZSwgc3RhY2s6IGUuc3RhY2sgfSxcbiAgICAgICAgICAgICAgICAgICAgJ0VuY291bnRlcmVkIGVycm9yIHdoZW4gZmV0Y2hpbmcgUkZRIHByaWNlIGluIGBHYXNsZXNzU3dhcFNlcnZpY2VgJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBmZWVDb25maWdzOiBGZWVDb25maWdzIHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09IEdhc2xlc3NUeXBlcy5NZXRhVHJhbnNhY3Rpb25WMikge1xuICAgICAgICAgICAgICAgIGZlZUNvbmZpZ3MgPSB0aGlzLl9nZXRGZWVDb25maWdzKHBhcmFtcywgJ29uLWNoYWluJyk7IC8vIGludGVncmF0b3IgYmlsbGluZyB0eXBlIHdvdWxkIGFsd2F5cyBiZSBvbi1jaGFpbiBmb3Igbm93XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG1ldGFUcmFuc2FjdGlvblJlcXVlc3RQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuX2NoYWluSWQsXG4gICAgICAgICAgICAgICAgaW50ZWdyYXRvcklkOiBwYXJhbXMuaW50ZWdyYXRvci5pbnRlZ3JhdG9ySWQsXG4gICAgICAgICAgICAgICAgLy8gQ2FuIHVzZSB0aGUgbnVsbCBhZGRyZXNzIGhlcmUgc2luY2Ugd2Ugd29uJ3QgYmUgcmV0dXJuaW5nXG4gICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCBtZXRhdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICB0YWtlckFkZHJlc3M6IHBhcmFtcy50YWtlckFkZHJlc3MgPz8gTlVMTF9BRERSRVNTLFxuICAgICAgICAgICAgICAgIGZlZUNvbmZpZ3MsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsZXQgbWV0YVRyYW5zYWN0aW9uUXVvdGU6IE1ldGFUcmFuc2FjdGlvbkNsaWVudFF1b3RlUmVzcG9uc2UgfCBudWxsO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEdhc2xlc3NUeXBlcy5NZXRhVHJhbnNhY3Rpb246XG4gICAgICAgICAgICAgICAgICAgIG1ldGFUcmFuc2FjdGlvblF1b3RlID0gYXdhaXQgZ2V0VjFRdW90ZUFzeW5jKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXhpb3NJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVUkwoYCR7dGhpcy5fbWV0YVRyYW5zYWN0aW9uU2VydmljZUJhc2VVcmwudG9TdHJpbmcoKX0vcXVvdGVgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFUcmFuc2FjdGlvblJlcXVlc3RQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdER1cmF0aW9uU3VtbWFyeTogWkVST0dfTUVUQV9UUkFOU0FDVElPTl9RVU9URV9SRVFVRVNUX0RVUkFUSU9OX1NFQ09ORFMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5fY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2Fybi5iaW5kKGxvZ2dlciksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgR2FzbGVzc1R5cGVzLk1ldGFUcmFuc2FjdGlvblYyOlxuICAgICAgICAgICAgICAgICAgICBtZXRhVHJhbnNhY3Rpb25RdW90ZSA9IGF3YWl0IGdldFYyUXVvdGVBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F4aW9zSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGAke3RoaXMuX21ldGFUcmFuc2FjdGlvblNlcnZpY2VCYXNlVXJsLnRvU3RyaW5nKCl9L3F1b3RlYCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhVHJhbnNhY3Rpb25SZXF1ZXN0UGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REdXJhdGlvblN1bW1hcnk6IFpFUk9HX01FVEFfVFJBTlNBQ1RJT05fUVVPVEVfUkVRVUVTVF9EVVJBVElPTl9TRUNPTkRTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuX2NoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4uYmluZChsb2dnZXIpLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEdhc2xlc3NUeXBlcy5PdGNPcmRlcjpcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2FzbGVzc1R5cGVzLk90Y09yZGVyIHNob3VsZCBub3QgYmUgcmVhY2hlZCcpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICgoX3g6IG5ldmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pKGtpbmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0YVRyYW5zYWN0aW9uUXVvdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gR2FzbGVzc1R5cGVzLk1ldGFUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWV0YVRyYW5zYWN0aW9uUXVvdGUucHJpY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2FuY2VUYXJnZXQ6IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZXRFeGNoYW5nZVByb3h5QWRkcmVzcygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlxdWlkaXR5U291cmNlOiAnYW1tJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWV0YVRyYW5zYWN0aW9uUXVvdGUucHJpY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VzOiBtZXRhVHJhbnNhY3Rpb25RdW90ZS5zb3VyY2VzID8/IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmVlczogZmVlc1RvVHJ1bmNhdGVkRmVlcyhtZXRhVHJhbnNhY3Rpb25RdW90ZS5mZWVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93YW5jZVRhcmdldDogdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldEV4Y2hhbmdlUHJveHlBZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgWkVST0dfR0FTTEVTU1NfU1dBUF9TRVJWSUNFX0VSUk9SUy5sYWJlbHMoXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhaW5JZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIEdhc2xlc3NTd2FwU2VydmljZUVycm9yUmVhc29uLkFtbVByaWNlRXJyb3IsXG4gICAgICAgICAgICApLmluYygpO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgIHsgcGFyYW1zLCBlcnJvck1lc3NhZ2U6IGUubWVzc2FnZSwgc3RhY2s6IGUuc3RhY2sgfSxcbiAgICAgICAgICAgICAgICAnRW5jb3VudGVyZWQgZXJyb3Igd2hlbiBmZXRjaGluZyBBTU0gcHJpY2UgaW4gYEdhc2xlc3NTd2FwU2VydmljZWAnLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gVGhyb3cgaGVyZSBhcyBpdCBtZWFucyBSRlEgdGhyb3dzIC8gZG9lcyBub3QgbGlxdWlkaXR5IGFuZCBBTU0gdGhyb3dzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGZldGNoaW5nIHByaWNlIGZvciAke3BhcmFtc31gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBcInF1b3RlXCIgKGFrYSBcIkZpcm0gUXVvdGVcIikuXG4gICAgICpcbiAgICAgKiBMaXF1aWRpdHkgc2VsZWN0aW9uIGxvZ2ljIGlzIHRoZSBzYW1lIGFzIHdpdGggYGZldGNoUHJpY2VBc3luY2AuXG4gICAgICpcbiAgICAgKiBJZiBhbiBBTU0gbWV0YXRyYW5zYWN0aW9uIGlzIHNlbGVjdGVkIGFzIHRoZSBsaXF1aWRpdHkgc291cmNlLFxuICAgICAqIGl0cyBtZXRhdHJhbnNhY3Rpb24gaGFzaCBpcyBzdG9yZWQgaW4gUmVkaXMgdG8gYmUgdmVyaWZpZWQgdXBvblxuICAgICAqIHN1Ym1pdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZmV0Y2hRdW90ZUFzeW5jKFxuICAgICAgICBwYXJhbXM6IEZldGNoRmlybVF1b3RlUGFyYW1zLFxuICAgICAgICBraW5kOiBHYXNsZXNzVHlwZXMsXG4gICAgKTogUHJvbWlzZTxcbiAgICAgICAgfCAoKE90Y09yZGVyUmZxbVF1b3RlUmVzcG9uc2UgfCBNZXRhVHJhbnNhY3Rpb25WMVF1b3RlUmVzcG9uc2UpICYgeyBsaXF1aWRpdHlTb3VyY2U6ICdyZnEnIHwgJ2FtbScgfSlcbiAgICAgICAgfCBNZXRhVHJhbnNhY3Rpb25WMlF1b3RlUmVzcG9uc2VcbiAgICAgICAgfCBudWxsXG4gICAgPiB7XG4gICAgICAgIGxldCByZnFRdW90ZVJlcG9ydElkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgICAgaWYgKGtpbmQgPT09IEdhc2xlc3NUeXBlcy5NZXRhVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBxdW90ZTogcmZxUXVvdGUsIHF1b3RlUmVwb3J0SWQgfSA9IGF3YWl0IHRoaXMuX3JmcW1TZXJ2aWNlLmZldGNoRmlybVF1b3RlQXN5bmMoXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgJ2dhc2xlc3NTd2FwUmZxJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJmcVF1b3RlUmVwb3J0SWQgPSBxdW90ZVJlcG9ydElkO1xuICAgICAgICAgICAgICAgIGlmIChyZnFRdW90ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZnFRdW90ZSwgbGlxdWlkaXR5U291cmNlOiAncmZxJyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBaRVJPR19HQVNMRVNTU19TV0FQX1NFUlZJQ0VfRVJST1JTLmxhYmVscyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhaW5JZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBHYXNsZXNzU3dhcFNlcnZpY2VFcnJvclJlYXNvbi5SZnFRdW90ZUVycm9yLFxuICAgICAgICAgICAgICAgICkuaW5jKCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICB7IHBhcmFtcywgZXJyb3JNZXNzYWdlOiBlLm1lc3NhZ2UsIHN0YWNrOiBlLnN0YWNrIH0sXG4gICAgICAgICAgICAgICAgICAgICdFbmNvdW50ZXJlZCBlcnJvciB3aGVuIGZldGNoaW5nIFJGUSBxdW90ZSBpbiBgR2FzbGVzc1N3YXBTZXJ2aWNlYCcsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZmVlQ29uZmlnczogRmVlQ29uZmlncyB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChraW5kID09PSBHYXNsZXNzVHlwZXMuTWV0YVRyYW5zYWN0aW9uVjIpIHtcbiAgICAgICAgICAgICAgICBmZWVDb25maWdzID0gdGhpcy5fZ2V0RmVlQ29uZmlncyhwYXJhbXMsICdvbi1jaGFpbicpOyAvLyBpbnRlZ3JhdG9yIGJpbGxpbmcgdHlwZSB3b3VsZCBhbHdheXMgYmUgb24tY2hhaW4gZm9yIG5vd1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBtZXRhVHJhbnNhY3Rpb25SZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiB0aGlzLl9jaGFpbklkLFxuICAgICAgICAgICAgICAgIGFmZmlsaWF0ZUFkZHJlc3M6IHBhcmFtcy5hZmZpbGlhdGVBZGRyZXNzID8/IHBhcmFtcy5pbnRlZ3JhdG9yLmFmZmlsaWF0ZUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgaW50ZWdyYXRvcklkOiBwYXJhbXMuaW50ZWdyYXRvci5pbnRlZ3JhdG9ySWQsXG4gICAgICAgICAgICAgICAgcXVvdGVVbmlxdWVJZDoga2luZCA9PT0gR2FzbGVzc1R5cGVzLk1ldGFUcmFuc2FjdGlvbiA/IHJmcVF1b3RlUmVwb3J0SWQgPz8gdW5kZWZpbmVkIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGZlZUNvbmZpZ3MsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsZXQgbWV0YVRyYW5zYWN0aW9uUXVvdGU6IE1ldGFUcmFuc2FjdGlvbkNsaWVudFF1b3RlUmVzcG9uc2UgfCBudWxsO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEdhc2xlc3NUeXBlcy5NZXRhVHJhbnNhY3Rpb246XG4gICAgICAgICAgICAgICAgICAgIG1ldGFUcmFuc2FjdGlvblF1b3RlID0gYXdhaXQgZ2V0VjFRdW90ZUFzeW5jKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXhpb3NJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVUkwoYCR7dGhpcy5fbWV0YVRyYW5zYWN0aW9uU2VydmljZUJhc2VVcmwudG9TdHJpbmcoKX0vcXVvdGVgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFUcmFuc2FjdGlvblJlcXVlc3RQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdER1cmF0aW9uU3VtbWFyeTogWkVST0dfTUVUQV9UUkFOU0FDVElPTl9RVU9URV9SRVFVRVNUX0RVUkFUSU9OX1NFQ09ORFMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5fY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2Fybi5iaW5kKGxvZ2dlciksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgR2FzbGVzc1R5cGVzLk1ldGFUcmFuc2FjdGlvblYyOlxuICAgICAgICAgICAgICAgICAgICBtZXRhVHJhbnNhY3Rpb25RdW90ZSA9IGF3YWl0IGdldFYyUXVvdGVBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F4aW9zSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGAke3RoaXMuX21ldGFUcmFuc2FjdGlvblNlcnZpY2VCYXNlVXJsLnRvU3RyaW5nKCl9L3F1b3RlYCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhVHJhbnNhY3Rpb25SZXF1ZXN0UGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REdXJhdGlvblN1bW1hcnk6IFpFUk9HX01FVEFfVFJBTlNBQ1RJT05fUVVPVEVfUkVRVUVTVF9EVVJBVElPTl9TRUNPTkRTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuX2NoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4uYmluZChsb2dnZXIpLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEdhc2xlc3NUeXBlcy5PdGNPcmRlcjpcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2FzbGVzc1R5cGVzLk90Y09yZGVyIHNob3VsZCBub3QgYmUgcmVhY2hlZCcpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICgoX3g6IG5ldmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pKGtpbmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0YVRyYW5zYWN0aW9uUXVvdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcHByb3ZhbCA9IHBhcmFtcy5jaGVja0FwcHJvdmFsXG4gICAgICAgICAgICAgICAgICAgID8gYXdhaXQgdGhpcy5fcmZxbVNlcnZpY2UuZ2V0R2FzbGVzc0FwcHJvdmFsUmVzcG9uc2VBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnRha2VyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnNlbGxUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVRyYW5zYWN0aW9uUXVvdGUucHJpY2Uuc2VsbEFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhVHJhbnNhY3Rpb24gPSBtZXRhVHJhbnNhY3Rpb25RdW90ZS50cmFkZS5tZXRhVHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogUHVibGlzaCBmZWUgZXZlbnQgZm9yIG1ldGEtdHJhbnNhY3Rpb24gdjJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zdG9yZU1ldGFUcmFuc2FjdGlvbkhhc2hBc3luYyhtZXRhVHJhbnNhY3Rpb24uZ2V0SGFzaCgpKTtcblxuICAgICAgICAgICAgICAgIGlmIChraW5kID09PSBHYXNsZXNzVHlwZXMuTWV0YVRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3BvbnNlIGZyb20gL21ldGFfdHJhbnNhY3Rpb24vdjEgZW5kcG9pbnQuIFRoZSBtZXRhLXRyYW5zYWN0aW9uIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuIE9OTFkgYmUgbWV0YS10cmFuc2FjdGlvbiB2MVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWV0YVRyYW5zYWN0aW9uUXVvdGUucHJpY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHByb3ZhbDogYXBwcm92YWwgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVRyYW5zYWN0aW9uSGFzaDogbWV0YVRyYW5zYWN0aW9uLmdldEhhc2goKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEdhc2xlc3NUeXBlcy5NZXRhVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2FuY2VUYXJnZXQ6IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZXRFeGNoYW5nZVByb3h5QWRkcmVzcygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlxdWlkaXR5U291cmNlOiAnYW1tJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNwb25zZSBmcm9tIC9tZXRhX3RyYW5zYWN0aW9uL3YyIGVuZHBvaW50LiBUaGUgbWV0YS10cmFuc2FjdGlvbiB0eXBlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbiBlaXRoZXIgYmUgbWV0YS10cmFuc2FjdGlvbiB2MSAvIHYyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5tZXRhVHJhbnNhY3Rpb25RdW90ZS5wcmljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcHJvdmFsOiBhcHByb3ZhbCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFkZTogbWV0YVRyYW5zYWN0aW9uUXVvdGUudHJhZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VzOiBtZXRhVHJhbnNhY3Rpb25RdW90ZS5zb3VyY2VzID8/IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmVlczogZmVlc1RvVHJ1bmNhdGVkRmVlcyhtZXRhVHJhbnNhY3Rpb25RdW90ZS5mZWVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93YW5jZVRhcmdldDogdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldEV4Y2hhbmdlUHJveHlBZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBaRVJPR19HQVNMRVNTU19TV0FQX1NFUlZJQ0VfRVJST1JTLmxhYmVscyhcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgR2FzbGVzc1N3YXBTZXJ2aWNlRXJyb3JSZWFzb24uQW1tUXVvdGVFcnJvcixcbiAgICAgICAgICAgICkuaW5jKCk7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgeyBwYXJhbXMsIGVycm9yTWVzc2FnZTogZS5tZXNzYWdlLCBzdGFjazogZS5zdGFjayB9LFxuICAgICAgICAgICAgICAgICdFbmNvdW50ZXJlZCBlcnJvciB3aGVuIGZldGNoaW5nIEFNTSBxdW90ZSBpbiBgR2FzbGVzc1N3YXBTZXJ2aWNlYCcsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBUaHJvdyBoZXJlIGFzIGl0IG1lYW5zIFJGUSB0aHJvd3MgLyBkb2VzIG5vdCBsaXF1aWRpdHkgYW5kIEFNTSB0aHJvd3NcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgcXVvdGUgZm9yICR7cGFyYW1zfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWNjZXB0cyBhIHRha2VyLXNpZ25lZCBNZXRhVHJhbnNhY3Rpb24gb3IgT3RjT3JkZXIgdHJhZGUsIGFuZCBvcHRpb25hbGx5LFxuICAgICAqIGEgc2lnbmVkIHBlcm1pdCB0cmFuc2FjdGlvbiwgYW5kIHByb2R1Y2VzIHRoZSBhcHByb3ByaWF0ZSBKb2IgYW5kIHNlbmRzXG4gICAgICogYSBtZXNzYWdlIHRvIFNRUy5cbiAgICAgKlxuICAgICAqIEZvciBsb3RzIG9mIGRpc2N1c3Npb24gb24gd2h5IHRoZSB0eXBlIGFzc2VydGlvbnMgYXJlIG5lZWRlZCwgc2VlOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzM5MTJcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgcHJvY2Vzc1N1Ym1pdEFzeW5jPFxuICAgICAgICBUIGV4dGVuZHNcbiAgICAgICAgICAgIHwgU3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUGFyYW1zPEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0IHwgUGVybWl0RWlwNzEyQ29udGV4dD5cbiAgICAgICAgICAgIHwgU3VibWl0TWV0YVRyYW5zYWN0aW9uU2lnbmVkUXVvdGVQYXJhbXM8RXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkVpcDcxMkNvbnRleHQgfCBQZXJtaXRFaXA3MTJDb250ZXh0PlxuICAgICAgICAgICAgfCBTdWJtaXRNZXRhVHJhbnNhY3Rpb25WMlNpZ25lZFF1b3RlUGFyYW1zPEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0IHwgUGVybWl0RWlwNzEyQ29udGV4dD4sXG4gICAgPihcbiAgICAgICAgcGFyYW1zOiBULFxuICAgICAgICBpbnRlZ3JhdG9ySWQ6IHN0cmluZyxcbiAgICApOiBQcm9taXNlPFxuICAgICAgICBUIGV4dGVuZHMgU3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUGFyYW1zPEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0IHwgUGVybWl0RWlwNzEyQ29udGV4dD5cbiAgICAgICAgICAgID8gU3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUmVzcG9uc2VcbiAgICAgICAgICAgIDogVCBleHRlbmRzIFN1Ym1pdE1ldGFUcmFuc2FjdGlvblNpZ25lZFF1b3RlUGFyYW1zPFxuICAgICAgICAgICAgICAgICAgRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkVpcDcxMkNvbnRleHQgfCBQZXJtaXRFaXA3MTJDb250ZXh0XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgID8gU3VibWl0TWV0YVRyYW5zYWN0aW9uU2lnbmVkUXVvdGVSZXNwb25zZVxuICAgICAgICAgICAgOiBTdWJtaXRNZXRhVHJhbnNhY3Rpb25WMlNpZ25lZFF1b3RlUmVzcG9uc2VcbiAgICA+IHtcbiAgICAgICAgLy8gT3RjT3JkZXJcbiAgICAgICAgaWYgKHBhcmFtcy5raW5kID09PSBHYXNsZXNzVHlwZXMuT3RjT3JkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG90Y09yZGVyUmVzdWx0ID0gYXdhaXQgdGhpcy5fcmZxbVNlcnZpY2Uuc3VibWl0VGFrZXJTaWduZWRPdGNPcmRlcldpdGhBcHByb3ZhbEFzeW5jKHBhcmFtcyk7XG4gICAgICAgICAgICByZXR1cm4gb3RjT3JkZXJSZXN1bHQgYXMgVCBleHRlbmRzIFN1Ym1pdFJmcW1TaWduZWRRdW90ZVdpdGhBcHByb3ZhbFBhcmFtczxcbiAgICAgICAgICAgICAgICBFeGVjdXRlTWV0YVRyYW5zYWN0aW9uRWlwNzEyQ29udGV4dCB8IFBlcm1pdEVpcDcxMkNvbnRleHRcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA/IFN1Ym1pdFJmcW1TaWduZWRRdW90ZVdpdGhBcHByb3ZhbFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgOiBUIGV4dGVuZHMgU3VibWl0TWV0YVRyYW5zYWN0aW9uU2lnbmVkUXVvdGVQYXJhbXM8XG4gICAgICAgICAgICAgICAgICAgICAgRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkVpcDcxMkNvbnRleHQgfCBQZXJtaXRFaXA3MTJDb250ZXh0XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPyBTdWJtaXRNZXRhVHJhbnNhY3Rpb25TaWduZWRRdW90ZVJlc3BvbnNlXG4gICAgICAgICAgICAgICAgOiBTdWJtaXRNZXRhVHJhbnNhY3Rpb25WMlNpZ25lZFF1b3RlUmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBBZGQgdGhlIGxvZ2ljIHRvIGhhbmRsZSBtZXRhLXRyYW5zYWN0aW9uIHYyIHdoZW4gdGhlIHR5cGUgaXMgcmVhZHlcbiAgICAgICAgLy8gTWV0YVRyYW5zYWN0aW9uXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRyYWRlOiB7IG1ldGFUcmFuc2FjdGlvbiB9LFxuICAgICAgICB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCB7IGlucHV0VG9rZW4sIGlucHV0VG9rZW5BbW91bnQsIG91dHB1dFRva2VuLCBtaW5PdXRwdXRUb2tlbkFtb3VudCB9ID0gZGVjb2RlVHJhbnNmb3JtRXJjMjBDYWxsZGF0YShcbiAgICAgICAgICAgIG1ldGFUcmFuc2FjdGlvbi5jYWxsRGF0YSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgbWV0YXRyYW5zYWN0aW9uIGlzIG5vdCBleHBpcmVkXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lTXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgYnVmZmVyUyA9IDMwO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBtZXRhVHJhbnNhY3Rpb24uZXhwaXJhdGlvblRpbWVTZWNvbmRzLm1pbnVzKGJ1ZmZlclMpLnRpbWVzKE9ORV9TRUNPTkRfTVMpLmlzTGVzc1RoYW5PckVxdWFsVG8oY3VycmVudFRpbWVNcylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBaRVJPR19HQVNMRVNTU19TV0FQX1NFUlZJQ0VfRVJST1JTLmxhYmVscyhcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgR2FzbGVzc1N3YXBTZXJ2aWNlRXJyb3JSZWFzb24uTWV0YVRyYW5zYWN0aW9uQWJvdXRUb0V4cGlyZSxcbiAgICAgICAgICAgICkuaW5jKCk7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgICB7IG1ldGFUcmFuc2FjdGlvbkhhc2g6IG1ldGFUcmFuc2FjdGlvbi5nZXRIYXNoKCkgfSxcbiAgICAgICAgICAgICAgICAnUmVjZWl2ZWQgbWV0YXRyYW5zYWN0aW9uIHN1Ym1pc3Npb24gd2hpY2ggaXMgYWJvdXQgdG8gZXhwaXJlJyxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdleHBpcmF0aW9uVGltZVNlY29uZHMnLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBWYWxpZGF0aW9uRXJyb3JDb2Rlcy5GaWVsZEludmFsaWQsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogYHRyYWRlIHdpbGwgZXhwaXJlIHRvbyBzb29uYCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgbWV0YXRyYW5zYWN0aW9uIHdhcyBjcmVhdGVkIGJ5IDB4IEFQSVxuICAgICAgICBjb25zdCBkb2VzTWV0YVRyYW5zYWN0aW9uSGFzaEV4aXN0ID0gYXdhaXQgdGhpcy5fZG9lc01ldGFUcmFuc2FjdGlvbkhhc2hFeGlzdEFzeW5jKG1ldGFUcmFuc2FjdGlvbi5nZXRIYXNoKCkpO1xuICAgICAgICBpZiAoIWRvZXNNZXRhVHJhbnNhY3Rpb25IYXNoRXhpc3QpIHtcbiAgICAgICAgICAgIFpFUk9HX0dBU0xFU1NTX1NXQVBfU0VSVklDRV9FUlJPUlMubGFiZWxzKFxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYWluSWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBHYXNsZXNzU3dhcFNlcnZpY2VFcnJvclJlYXNvbi5NZXRhVHJhbnNhY3Rpb25IYXNoTm90RXhpc3QsXG4gICAgICAgICAgICApLmluYygpO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgeyBtZXRhVHJhbnNhY3Rpb25IYXNoOiBtZXRhVHJhbnNhY3Rpb24uZ2V0SGFzaCgpIH0sXG4gICAgICAgICAgICAgICAgJ1JlY2VpdmVkIG1ldGF0cmFuc2FjdGlvbiBzdWJtaXNzaW9uIG5vdCBjcmVhdGVkIGJ5IDB4IEFQSScsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhVHJhbnNhY3Rpb24gaGFzaCBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZXJlIGlzIG5vdCBhIHBlbmRpbmcgdHJhbnNhY3Rpb24gZm9yIHRoaXMgdGFrZXIgYW5kIHRha2VyIHRva2VuXG5cbiAgICAgICAgLy8gVE9ETyAocmhpbm9kYXZpZCk6IG9wdGltaXplIHRoaXMgcXVlcnkgYnkgYWRkaW5nIHRoZSB0YWtlciAmIHRha2VyVG9rZW4gaW5zdGVhZFxuICAgICAgICAvLyBvZiBmaWx0ZXJpbmcgaXQgb3V0IGluIHRoZSBuZXh0IHN0ZXBcbiAgICAgICAgY29uc3QgcGVuZGluZ0pvYnMgPSBhd2FpdCB0aGlzLl9kYlV0aWxzLmZpbmRNZXRhVHJhbnNhY3Rpb25Kb2JzV2l0aFN0YXR1c2VzQXN5bmMoW1xuICAgICAgICAgICAgUmZxbUpvYlN0YXR1cy5QZW5kaW5nRW5xdWV1ZWQsXG4gICAgICAgICAgICBSZnFtSm9iU3RhdHVzLlBlbmRpbmdQcm9jZXNzaW5nLFxuICAgICAgICAgICAgUmZxbUpvYlN0YXR1cy5QZW5kaW5nTGFzdExvb2tBY2NlcHRlZCxcbiAgICAgICAgICAgIFJmcW1Kb2JTdGF0dXMuUGVuZGluZ1N1Ym1pdHRlZCxcbiAgICAgICAgXSk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgcGVuZGluZ0pvYnMuc29tZShcbiAgICAgICAgICAgICAgICAoam9iKSA9PlxuICAgICAgICAgICAgICAgICAgICBqb2IudGFrZXJBZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IG1ldGFUcmFuc2FjdGlvbi5zaWduZXIudG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAgICAgICAgICAgICBqb2IuaW5wdXRUb2tlbi50b0xvd2VyQ2FzZSgpID09PSBpbnB1dFRva2VuLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXIgbG9naWMgaGFuZGxlcyB0aGUgY2FzZSB3aGVyZSB0aGUgc2FtZSBvcmRlciBpcyBzdWJtaXR0ZWQgdHdpY2VcbiAgICAgICAgICAgICAgICAgICAgam9iLm1ldGFUcmFuc2FjdGlvbkhhc2ggIT09IG1ldGFUcmFuc2FjdGlvbi5nZXRIYXNoKCksXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgWkVST0dfR0FTTEVTU1NfU1dBUF9TRVJWSUNFX0VSUk9SUy5sYWJlbHMoXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhaW5JZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIEdhc2xlc3NTd2FwU2VydmljZUVycm9yUmVhc29uLk1ldGFUcmFuc2FjdGlvblBlbmRpbmdKb2JBbHJlYWR5RXhpc3QsXG4gICAgICAgICAgICApLmluYygpO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBtZXRhVHJhbnNhY3Rpb25IYXNoOiBtZXRhVHJhbnNhY3Rpb24uZ2V0SGFzaCgpLFxuICAgICAgICAgICAgICAgICAgICB0YWtlclRva2VuOiBpbnB1dFRva2VuLFxuICAgICAgICAgICAgICAgICAgICB0YWtlckFkZHJlc3M6IG1ldGFUcmFuc2FjdGlvbi5zaWduZXIudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdNZXRhdHJhbnNhY3Rpb24gc3VibWlzc2lvbiByZWplY3RlZCBiZWNhdXNlIGEgam9iIGlzIHBlbmRpbmcgd2l0aCB0aGUgc2FtZSB0YWtlciBhbmQgdGFrZXIgdG9rZW4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb29NYW55UmVxdWVzdHNFcnJvcignYSBwZW5kaW5nIHRyYWRlIGZvciB0aGlzIHRha2VyIGFuZCB0YWtlcnRva2VuIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZGF0ZSB0aGF0IHRoZSBnaXZlbiB0YWtlciBzaWduYXR1cmUgaXMgdmFsaWRcbiAgICAgICAgY29uc3Qgc2lnbmVyQWRkcmVzcyA9IGdldFNpZ25lckZyb21IYXNoKG1ldGFUcmFuc2FjdGlvbi5nZXRIYXNoKCksIHBhcmFtcy50cmFkZS5zaWduYXR1cmUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzaWduZXJBZGRyZXNzICE9PSBtZXRhVHJhbnNhY3Rpb24uc2lnbmVyKSB7XG4gICAgICAgICAgICBaRVJPR19HQVNMRVNTU19TV0FQX1NFUlZJQ0VfRVJST1JTLmxhYmVscyhcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgR2FzbGVzc1N3YXBTZXJ2aWNlRXJyb3JSZWFzb24uTWV0YVRyYW5zYWN0aW9uSW52YWxpZFNpZ25lcixcbiAgICAgICAgICAgICkuaW5jKCk7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFUcmFuc2FjdGlvbkhhc2g6IG1ldGFUcmFuc2FjdGlvbi5nZXRIYXNoKCksXG4gICAgICAgICAgICAgICAgICAgIG1ldGFUcmFuc2FjdGlvblNpZ25lcjogbWV0YVRyYW5zYWN0aW9uLnNpZ25lcixcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TaWduZXI6IHNpZ25lckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnUmVjZWl2ZWQgc3VibWlzc2lvbiB3aXRoIHNpZ25lciBtaXNtYXRjaCcsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ3NpZ25hdHVyZScsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFZhbGlkYXRpb25FcnJvckNvZGVzLkludmFsaWRTaWduYXR1cmVPckhhc2gsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogYHNpZ25hdHVyZSBpcyBub3QgdmFsaWRgLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHRoYXQgb3JkZXIgaXMgZmlsbGFibGUgYWNjb3JkaW5nIHRvIGJhbGFuY2UgYW5kL29yIGFsbG93YW5jZS5cbiAgICAgICAgY29uc3QgW3Rha2VyQmFsYW5jZV0gPSBwYXJhbXMuYXBwcm92YWxcbiAgICAgICAgICAgID8gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldFRva2VuQmFsYW5jZXNBc3luYyhbeyBvd25lcjogbWV0YVRyYW5zYWN0aW9uLnNpZ25lciwgdG9rZW46IGlucHV0VG9rZW4gfV0pXG4gICAgICAgICAgICA6IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKFtcbiAgICAgICAgICAgICAgICAgIHsgb3duZXI6IG1ldGFUcmFuc2FjdGlvbi5zaWduZXIsIHRva2VuOiBpbnB1dFRva2VuIH0sXG4gICAgICAgICAgICAgIF0pO1xuXG4gICAgICAgIGlmICh0YWtlckJhbGFuY2UuaXNMZXNzVGhhbihpbnB1dFRva2VuQW1vdW50KSkge1xuICAgICAgICAgICAgWkVST0dfR0FTTEVTU1NfU1dBUF9TRVJWSUNFX0VSUk9SUy5sYWJlbHMoXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhaW5JZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIEdhc2xlc3NTd2FwU2VydmljZUVycm9yUmVhc29uLk1ldGFUcmFuc2FjdGlvblRha2VyQmFsYW5jZUNoZWNrRmFpbGVkLFxuICAgICAgICAgICAgKS5pbmMoKTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGFrZXJCYWxhbmNlLFxuICAgICAgICAgICAgICAgICAgICB0YWtlckFkZHJlc3M6IG1ldGFUcmFuc2FjdGlvbi5zaWduZXIsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFUcmFuc2FjdGlvbkhhc2g6IG1ldGFUcmFuc2FjdGlvbi5nZXRIYXNoKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnQmFsYW5jZSBjaGVjayBmYWlsZWQgd2hpbGUgdXNlciB3YXMgc3VibWl0dGluZycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ24vYScsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFZhbGlkYXRpb25FcnJvckNvZGVzLkludmFsaWRPcmRlcixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBgb3JkZXIgaXMgbm90IGZpbGxhYmxlYCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZnFtQXBwcm92YWxPcHRzID0gcGFyYW1zLmFwcHJvdmFsXG4gICAgICAgICAgICA/IGF3YWl0IHRoaXMuX3JmcW1TZXJ2aWNlLmNyZWF0ZUFwcHJvdmFsQXN5bmMocGFyYW1zLmFwcHJvdmFsLCBtZXRhVHJhbnNhY3Rpb24uZ2V0SGFzaCgpLCBpbnB1dFRva2VuKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY29uc3Qgam9iT3B0aW9uczogTWV0YVRyYW5zYWN0aW9uSm9iQ29uc3RydWN0b3JPcHRzID0ge1xuICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5fY2hhaW5JZCxcbiAgICAgICAgICAgIGV4cGlyeTogbWV0YVRyYW5zYWN0aW9uLmV4cGlyYXRpb25UaW1lU2Vjb25kcyxcbiAgICAgICAgICAgIGZlZTogeyB0b2tlbjogbWV0YVRyYW5zYWN0aW9uLmZlZVRva2VuLCBhbW91bnQ6IG1ldGFUcmFuc2FjdGlvbi5mZWVBbW91bnQsIHR5cGU6ICdmaXhlZCcgfSxcbiAgICAgICAgICAgIGlucHV0VG9rZW4sXG4gICAgICAgICAgICBpbnB1dFRva2VuQW1vdW50LFxuICAgICAgICAgICAgaW50ZWdyYXRvcklkLFxuICAgICAgICAgICAgbWV0YVRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgbWV0YVRyYW5zYWN0aW9uSGFzaDogbWV0YVRyYW5zYWN0aW9uLmdldEhhc2goKSxcbiAgICAgICAgICAgIG1pbk91dHB1dFRva2VuQW1vdW50LFxuICAgICAgICAgICAgb3V0cHV0VG9rZW4sXG4gICAgICAgICAgICB0YWtlckFkZHJlc3M6IG1ldGFUcmFuc2FjdGlvbi5zaWduZXIsXG4gICAgICAgICAgICB0YWtlclNpZ25hdHVyZTogcGFyYW1zLnRyYWRlLnNpZ25hdHVyZSxcbiAgICAgICAgICAgIC4uLnJmcW1BcHByb3ZhbE9wdHMsXG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQgfSA9IGF3YWl0IHRoaXMuX2RiVXRpbHMud3JpdGVNZXRhVHJhbnNhY3Rpb25Kb2JBc3luYyhqb2JPcHRpb25zKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2VucXVldWVKb2JBc3luYyhpZCwgR2FzbGVzc1R5cGVzLk1ldGFUcmFuc2FjdGlvbik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBaRVJPR19HQVNMRVNTU19TV0FQX1NFUlZJQ0VfRVJST1JTLmxhYmVscyhcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgR2FzbGVzc1N3YXBTZXJ2aWNlRXJyb3JSZWFzb24uTWV0YVRyYW5zYWN0aW9uRmFpbGVkVG9RdWV1ZSxcbiAgICAgICAgICAgICkuaW5jKCk7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoeyBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfSwgJ0ZhaWxlZCB0byBxdWV1ZSB0aGUgcXVvdGUgZm9yIHN1Ym1pc3Npb24uJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxTZXJ2ZXJFcnJvcihcbiAgICAgICAgICAgICAgICBgZmFpbGVkIHRvIHF1ZXVlIHRoZSBxdW90ZSBmb3Igc3VibWlzc2lvbiwgaXQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHN1Ym1pdHRlZGAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBTdWJtaXRNZXRhVHJhbnNhY3Rpb25TaWduZWRRdW90ZVJlc3BvbnNlID0ge1xuICAgICAgICAgICAgbWV0YVRyYW5zYWN0aW9uSGFzaDogbWV0YVRyYW5zYWN0aW9uLmdldEhhc2goKSxcbiAgICAgICAgICAgIHR5cGU6IEdhc2xlc3NUeXBlcy5NZXRhVHJhbnNhY3Rpb24sXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdCBhcyBUIGV4dGVuZHMgU3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUGFyYW1zPFxuICAgICAgICAgICAgRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkVpcDcxMkNvbnRleHQgfCBQZXJtaXRFaXA3MTJDb250ZXh0XG4gICAgICAgID5cbiAgICAgICAgICAgID8gU3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUmVzcG9uc2VcbiAgICAgICAgICAgIDogVCBleHRlbmRzIFN1Ym1pdE1ldGFUcmFuc2FjdGlvblNpZ25lZFF1b3RlUGFyYW1zPFxuICAgICAgICAgICAgICAgICAgRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkVpcDcxMkNvbnRleHQgfCBQZXJtaXRFaXA3MTJDb250ZXh0XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgID8gU3VibWl0TWV0YVRyYW5zYWN0aW9uU2lnbmVkUXVvdGVSZXNwb25zZVxuICAgICAgICAgICAgOiBTdWJtaXRNZXRhVHJhbnNhY3Rpb25WMlNpZ25lZFF1b3RlUmVzcG9uc2U7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGdldFN0YXR1c0FzeW5jKGhhc2g6IHN0cmluZyk6IFByb21pc2U8U3RhdHVzUmVzcG9uc2UgfCBudWxsPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZnFtU2VydmljZS5nZXRTdGF0dXNBc3luYyhoYXNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzdGhyb3VnaCB0byBSRlFtIFNlcnZpY2UncyBgcnVuSGVhbHRoQ2hlY2tBc3luY2AgbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIHJ1bkhlYWx0aENoZWNrQXN5bmMoKTogUHJvbWlzZTxIZWFsdGhDaGVja1Jlc3VsdD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmZxbVNlcnZpY2UucnVuSGVhbHRoQ2hlY2tBc3luYygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3N0aHJvdWdoIHRvIFJGUW0gU2VydmljZSdzIGBnZXRUb2tlbkRlY2ltYWxzQXN5bmNgIG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRUb2tlbkRlY2ltYWxzQXN5bmModG9rZW5BZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmZxbVNlcnZpY2UuZ2V0VG9rZW5EZWNpbWFsc0FzeW5jKHRva2VuQWRkcmVzcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfZW5xdWV1ZUpvYkFzeW5jKGlkOiBzdHJpbmcsIHR5cGU6IEdhc2xlc3NUeXBlcyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLl9zcXNQcm9kdWNlci5zZW5kKHtcbiAgICAgICAgICAgIGdyb3VwSWQ6IGlkLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGlkLCB0eXBlIH0pLFxuICAgICAgICAgICAgZGVkdXBsaWNhdGlvbklkOiBpZCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfZG9lc01ldGFUcmFuc2FjdGlvbkhhc2hFeGlzdEFzeW5jKGhhc2g6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkaXMuZ2V0KG1ldGFUcmFuc2FjdGlvbkhhc2hSZWRpc0tleShoYXNoKSkudGhlbigocikgPT4gISFyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9zdG9yZU1ldGFUcmFuc2FjdGlvbkhhc2hBc3luYyhoYXNoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcmVkaXMuc2V0KG1ldGFUcmFuc2FjdGlvbkhhc2hSZWRpc0tleShoYXNoKSwgLyogdmFsdWUgKi8gMCwgJ0VYJywgTUVUQV9UUkFOU0FDVElPTl9IQVNIX1RUTF9TKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9nZXRGZWVDb25maWdzKHBhcmFtczogRmV0Y2hRdW90ZVBhcmFtc0Jhc2UsIGludGVncmF0b3JCaWxsaW5nVHlwZTogJ29uLWNoYWluJyB8ICdvZmYtY2hhaW4nKTogRmVlQ29uZmlncyB7XG4gICAgICAgIGxldCBpbnRlZ3JhdG9yRmVlQ29uZmlnO1xuXG4gICAgICAgIGlmIChwYXJhbXMuZmVlVHlwZSAmJiBwYXJhbXMuZmVlUmVjaXBpZW50ICYmIHBhcmFtcy5mZWVTZWxsVG9rZW5QZXJjZW50YWdlKSB7XG4gICAgICAgICAgICBpbnRlZ3JhdG9yRmVlQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtcy5mZWVUeXBlLFxuICAgICAgICAgICAgICAgIHJlY2lwaWVudDogcGFyYW1zLmZlZVJlY2lwaWVudCxcbiAgICAgICAgICAgICAgICBiaWxsaW5nVHlwZTogaW50ZWdyYXRvckJpbGxpbmdUeXBlLFxuICAgICAgICAgICAgICAgIHNlbGxUb2tlblBlcmNlbnRhZ2U6IHBhcmFtcy5mZWVTZWxsVG9rZW5QZXJjZW50YWdlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRGZWVDb25maWdzRnJvbVBhcmFtcyh7XG4gICAgICAgICAgICBpbnRlZ3JhdG9ySWQ6IHBhcmFtcy5pbnRlZ3JhdG9yLmludGVncmF0b3JJZCxcbiAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuX2NoYWluSWQsXG4gICAgICAgICAgICBzZWxsVG9rZW46IHBhcmFtcy5zZWxsVG9rZW4sXG4gICAgICAgICAgICBidXlUb2tlbjogcGFyYW1zLmJ1eVRva2VuLFxuICAgICAgICAgICAgaW50ZWdyYXRvckZlZUNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sInZlcnNpb24iOjN9