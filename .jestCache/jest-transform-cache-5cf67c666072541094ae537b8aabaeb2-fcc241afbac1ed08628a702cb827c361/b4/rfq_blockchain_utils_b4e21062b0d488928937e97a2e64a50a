bfbef1c75c8b79572a2ef37931e0b731
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RfqBalanceCheckUtils = exports.RfqBlockchainUtils = void 0;
// tslint:disable:max-file-line-count
const contract_addresses_1 = require("@0x/contract-addresses");
const contracts_zero_ex_1 = require("@0x/contracts-zero-ex");
const protocol_utils_1 = require("@0x/protocol-utils");
const subproviders_1 = require("@0x/subproviders");
const utils_1 = require("@0x/utils");
const hdnode_1 = require("@ethersproject/hdnode");
const ethers_1 = require("ethers");
const utils_2 = require("ethers/lib/utils");
const abis_1 = require("../abis");
const constants_1 = require("../core/constants");
const eip712registry_1 = require("../eip712registry");
const logger_1 = require("../logger");
const types_1 = require("../core/types");
const address_utils_1 = require("./address_utils");
const Eip712Utils_1 = require("./Eip712Utils");
const rfqm_worker_balance_utils_1 = require("./rfqm_worker_balance_utils");
const service_utils_1 = require("./service_utils");
const subprovider_adapter_1 = require("./subprovider_adapter");
// allow a wide range for gas price for flexibility
const MIN_GAS_PRICE = new utils_1.BigNumber(0);
// 10K Gwei
const MAX_GAS_PRICE = new utils_1.BigNumber(1e13);
const RFQ_ORDER_FILLED_EVENT_TOPIC0 = '0x829fa99d94dc4636925b38632e625736a614c154d55006b7ab6bea979c210c32';
const OTC_ORDER_FILLED_EVENT_TOPIC0 = '0xac75f773e3a92f1a02b12134d65e1f47f8a14eabe4eaf1e24624918e6a8b269f';
const ZERO_EX_FILL_EVENT_ABI = [
    {
        anonymous: false,
        inputs: [
            { indexed: false, internalType: 'bytes32', name: 'orderHash', type: 'bytes32' },
            { indexed: false, internalType: 'address', name: 'maker', type: 'address' },
            { indexed: false, internalType: 'address', name: 'taker', type: 'address' },
            { indexed: false, internalType: 'address', name: 'makerToken', type: 'address' },
            { indexed: false, internalType: 'address', name: 'takerToken', type: 'address' },
            { indexed: false, internalType: 'uint128', name: 'takerTokenFilledAmount', type: 'uint128' },
            { indexed: false, internalType: 'uint128', name: 'makerTokenFilledAmount', type: 'uint128' },
            { indexed: false, internalType: 'bytes32', name: 'pool', type: 'bytes32' },
        ],
        name: 'RfqOrderFilled',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            { indexed: false, internalType: 'bytes32', name: 'orderHash', type: 'bytes32' },
            { indexed: false, internalType: 'address', name: 'maker', type: 'address' },
            { indexed: false, internalType: 'address', name: 'taker', type: 'address' },
            { indexed: false, internalType: 'address', name: 'makerToken', type: 'address' },
            { indexed: false, internalType: 'address', name: 'takerToken', type: 'address' },
            { indexed: false, internalType: 'uint128', name: 'makerTokenFilledAmount', type: 'uint128' },
            { indexed: false, internalType: 'uint128', name: 'takerTokenFilledAmount', type: 'uint128' },
        ],
        name: 'OtcOrderFilled',
        type: 'event',
    },
];
function toBigNumber(ethersBigNumber) {
    return new utils_1.BigNumber(ethersBigNumber.toString());
}
class RfqBlockchainUtils {
    constructor(provider, _exchangeProxyAddress, balanceChecker, ethersProvider, ethersWallet) {
        this._exchangeProxyAddress = _exchangeProxyAddress;
        this._abiDecoder = new utils_1.AbiDecoder([ZERO_EX_FILL_EVENT_ABI]);
        this.balanceCheckUtils = new RfqBalanceCheckUtils(balanceChecker, _exchangeProxyAddress);
        this._ethersProvider = ethersProvider;
        this._ethersWallet = ethersWallet;
        this._exchangeProxy = new contracts_zero_ex_1.IZeroExContract(this._exchangeProxyAddress, provider);
    }
    static getPrivateKeyFromIndexAndPhrase(mnemonic, index) {
        const hdNode = hdnode_1.HDNode.fromMnemonic(mnemonic).derivePath(this._getPathByIndex(index));
        // take '0x' off
        return hdNode.privateKey.substring(2);
    }
    static getAddressFromIndexAndPhrase(mnemonic, index) {
        const hdNode = hdnode_1.HDNode.fromMnemonic(mnemonic).derivePath(this._getPathByIndex(index));
        return hdNode.address;
    }
    static createPrivateKeyProvider(rpcProvider, privateWalletSubprovider) {
        const providerEngine = new subproviders_1.Web3ProviderEngine();
        providerEngine.addProvider(privateWalletSubprovider);
        providerEngine.addProvider(new subprovider_adapter_1.SubproviderAdapter(rpcProvider));
        utils_1.providerUtils.startProviderEngine(providerEngine);
        return providerEngine;
    }
    // tslint:disable-next-line:prefer-function-over-method
    static _getPathByIndex(index) {
        // ensure index is a 0+ integer
        if (index < 0 || index !== Math.floor(index)) {
            throw new Error(`invalid index`);
        }
        return `m/44'/60'/0'/0/`.concat(String(index));
    }
    /**
     * Fetches min value between balance for a list of addresses against the specified tokens. The index of
     * an address in `addresses` must correspond with the index of a token in `tokens`.
     */
    async getMinOfBalancesAndAllowancesAsync(erc20Owners) {
        return this.balanceCheckUtils.getMinOfBalancesAndAllowancesAsync(erc20Owners);
    }
    /**
     * Fetches the balances for a list of addresses against the specified tokens. The index of
     * an address in `addresses` must correspond with the index of a token in `tokens`.
     */
    async getTokenBalancesAsync(erc20Owners) {
        return this.balanceCheckUtils.getTokenBalancesAsync(erc20Owners);
    }
    // for use when 0x API operator submits an order on-chain on behalf of taker
    generateMetaTransaction(rfqOrder, signature, taker, takerAmount, chainId) {
        // generate call data for fillRfqOrder
        const callData = this._exchangeProxy
            .fillRfqOrder(rfqOrder, signature, takerAmount)
            .getABIEncodedTransactionData();
        return new protocol_utils_1.MetaTransaction({
            signer: taker,
            sender: constants_1.NULL_ADDRESS,
            minGasPrice: MIN_GAS_PRICE,
            maxGasPrice: MAX_GAS_PRICE,
            expirationTimeSeconds: rfqOrder.expiry,
            salt: new utils_1.BigNumber(Date.now()),
            callData,
            value: constants_1.ZERO,
            feeToken: constants_1.NULL_ADDRESS,
            feeAmount: constants_1.ZERO,
            chainId,
            verifyingContract: this._exchangeProxy.address,
        });
    }
    async decodeMetaTransactionCallDataAndValidateAsync(calldata, sender, txOptions) {
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const metaTxInput = this._exchangeProxy.getABIDecodedTransactionData('executeMetaTransaction', calldata);
        return this.validateMetaTransactionOrThrowAsync(metaTxInput[0], metaTxInput[1], sender, txOptions);
    }
    /**
     * Validates a metatransaction and its signature for a given sender
     *
     * @returns a Promise of [takerTokenFilledAmount, makerTokenFilledAmount]
     * @throws an error if the metatransaction is not valid
     */
    async validateMetaTransactionOrThrowAsync(metaTx, metaTxSig, sender, txOptions) {
        try {
            const results = await this._exchangeProxy
                .executeMetaTransaction(metaTx, metaTxSig)
                .callAsync({ from: sender, ...txOptions });
            const takerTokenFillAmount = // $eslint-fix-me github.com/rhinodavid/eslint-fix-me
             
            /* eslint-disable @typescript-eslint/no-explicit-any */
            this._exchangeProxy.getABIDecodedTransactionData('fillRfqOrder', metaTx.callData) /* eslint-enable @typescript-eslint/no-explicit-any */[2];
            const decodedResults = this._exchangeProxy.getABIDecodedReturnData('fillRfqOrder', results);
            if (decodedResults[0].isLessThan(takerTokenFillAmount)) {
                logger_1.logger.error('validation failed because filled amount is less than requested fill amount');
                throw new Error(`filled amount is less than requested fill amount`);
            }
            return decodedResults;
        }
        catch (err) {
            logger_1.logger.error({ errorMessage: err === null || err === void 0 ? void 0 : err.message }, 'eth_call validation failed for executeMetaTransaction');
            throw new Error(err);
        }
    }
    /**
     * Simulate the transaction with calldata.
     *
     * NOTE: In ethers.js, provider.call and provider.send('eth_call', ...) might not throw exception.
     *       The behavior might be dependent on providers. Revisit this later.
     */
    async simulateTransactionAsync(to, calldata) {
        try {
            await this._ethersProvider.call({
                to,
                data: calldata,
            });
        }
        catch (e) {
            if (e instanceof Error) {
                e.message = `simulateTransactionAsync: ${e.message}`;
            }
            throw e;
        }
    }
    /**
     * Estimate the gas for fillTakerSignedOtcOrder and fillTakerSignedOtcOrderForEth
     * NOTE: can also be used for validation
     *
     * @returns a Promise of the gas estimate
     * @throws an error if transaction will revert
     */
    async estimateGasForFillTakerSignedOtcOrderAsync(order, makerSignature, takerSignature, sender, isUnwrap) {
        try {
            if (isUnwrap) {
                return await this._exchangeProxy
                    .fillTakerSignedOtcOrderForEth(order, makerSignature, takerSignature)
                    .estimateGasAsync({ from: sender });
            }
            else {
                return await this._exchangeProxy
                    .fillTakerSignedOtcOrder(order, makerSignature, takerSignature)
                    .estimateGasAsync({ from: sender });
            }
        }
        catch (err) {
            logger_1.logger.error({
                orderHash: order.getHash(),
                maker: order.maker,
                taker: order.taker,
                isUnwrap,
                errorMessage: err === null || err === void 0 ? void 0 : err.message,
            }, 'validation failed for taker signed OtcOrder');
            throw err;
        }
    }
    /**
     * Generates calldata for Taker Signed OtcOrder settlement
     */
    generateTakerSignedOtcOrderCallData(order, makerSignature, takerSignature, isUnwrap, affiliateAddress) {
        const callData = isUnwrap
            ? this._exchangeProxy
                .fillTakerSignedOtcOrderForEth(order, makerSignature, takerSignature)
                .getABIEncodedTransactionData()
            : this._exchangeProxy
                .fillTakerSignedOtcOrder(order, makerSignature, takerSignature)
                .getABIEncodedTransactionData();
        return service_utils_1.serviceUtils.attributeCallData(callData, affiliateAddress).affiliatedData;
    }
    generateMetaTransactionCallData(metaTx, metaTxSig, affiliateAddress) {
        const callData = this._exchangeProxy.executeMetaTransaction(metaTx, metaTxSig).getABIEncodedTransactionData();
        return service_utils_1.serviceUtils.attributeCallData(callData, affiliateAddress).affiliatedData;
    }
    async getNonceAsync(workerAddress) {
        return this._ethersProvider.getTransactionCount(workerAddress);
    }
    getExchangeProxyAddress() {
        return this._exchangeProxyAddress;
    }
    /**
     * Returns the transaction receipts for the given transaction hashes.
     * If a receipt does not exist, returns `undefined`.
     */
    async getReceiptsAsync(transactionHashes) {
        return Promise.all(transactionHashes.map(async (transactionHash) => this._ethersProvider.getTransactionReceipt(transactionHash)));
    }
    async getCurrentBlockAsync() {
        return this._ethersProvider.getBlockNumber();
    }
    // Fetches a block from the block number or block hash
    async getBlockAsync(blockHash) {
        return this._ethersProvider.getBlock(blockHash);
    }
    /**
     * Passthrough to the ethers `getTransaction` function
     * https://docs.ethers.io/v5/api/providers/provider/#Provider-getTransaction:
     *
     * Returns the transaction with hash or null if the transaction is unknown.
     * If a transaction has not been mined, this method will search the transaction pool.
     * Various backends may have more restrictive transaction pool access
     * (e.g. if the gas price is too low or the transaction was only recently sent and not yet indexed)
     * in which case this method may also return null.
     */
    async getTransactionAsync(transactionHash) {
        return this._ethersProvider.getTransaction(transactionHash);
    }
    /**
     * Estimate gas (in wei) given a transaction request using `eth_estimateGas` JSON RPC method.
     * The transaction request contains information related to the transaction (from, to, data, etc.).
     *
     * @param transactionRequest Transaction request object which contains information about the transaction.
     * @returns The gas estimate for the transaction in wei.
     */
    async estimateGasForAsync(transactionRequest) {
        try {
            const gasEstimate = await this._ethersProvider.estimateGas(transactionRequest);
            return gasEstimate.toNumber();
        }
        catch (e) {
            if (e instanceof Error) {
                e.message = `estimateGasForAsync: ${e.message}`;
            }
            throw e;
        }
    }
    /**
     * Get the access list and the gas estimation given a transaction request. Uses the provider
     * to call the `eth_createAccessList` JSON RPC method.
     *
     * The transaction request contains information related to the transaction (from, to, data, etc.).
     * Note that the implementation is similar to the one in @0x/web3-wrapper. This repo is
     * migrating away from web3-wrapper in favor of ethers. The original implementation in
     * web3-wrapper:
     * https://github.com/0xProject/tools/blob/development/web3-wrapper/src/web3_wrapper.ts#L591
     *
     * @param transactionRequest Transaction request object which contains information about the transaction.
     * @returns A TxAccessListWithGas object which contains access list and gas estimation for the transaction.
     */
    async createAccessListForAsync(transactionRequest) {
        try {
            const rawResult = await this._ethersProvider.send('eth_createAccessList', [transactionRequest]);
            const accessList = rawResult.accessList;
            const gasUsed = rawResult.gasUsed;
            return {
                // The type for `accessList` is `AccessList` (Array<{ address: string, storageKeys: Array<string> }>).
                // The reduce operation is used to transform the array into type `TxAccessList` ([address: string]: string[]) whose keys
                // are addresses and values are corresponding storage keys. This is useful if we need to remove an address from the object.
                accessList: accessList.reduce((o, v) => {
                    o[v.address] = o[v.address] || [];
                    o[v.address].push(...(v.storageKeys || []));
                    return o;
                }, {}),
                gasEstimate: new utils_1.BigNumber(gasUsed).toNumber(),
            };
        }
        catch (e) {
            if (e instanceof Error) {
                e.message = `createAccessListForAsync: ${e.message}`;
            }
            throw e;
        }
    }
    getDecodedRfqOrderFillEventLogFromLogs(logs) {
        for (const log of logs) {
            if (log.topics[0] === RFQ_ORDER_FILLED_EVENT_TOPIC0) {
                return this._abiDecoder.tryToDecodeLogOrNoop(log);
            }
        }
        throw new Error(`no RfqOrderFilledEvent logs among the logs passed into getDecodedRfqOrderFillEventLogFromLogs`);
    }
    /**
     * Decode the OtcOrder Filled Event
     */
    getDecodedOtcOrderFillEventLogFromLogs(logs) {
        for (const log of logs) {
            if (log.topics[0] === OTC_ORDER_FILLED_EVENT_TOPIC0) {
                return this._abiDecoder.tryToDecodeLogOrNoop(log);
            }
        }
        throw new Error(`no OtcOrderFilledEvent logs among the logs passed into getDecodedOtcOrderFillEventLogFromLogs`);
    }
    /**
     * Broadcasts a raw transaction via the `eth_sendRawTransaction` JSON RPC method.
     * The transaction must be signed by this point, otherwise submission will fail.
     *
     * @returns The transaction hash returned by the RPC provider.
     */
    async submitSignedTransactionAsync(signedTransaction) {
        const response = await this._ethersProvider.sendTransaction(signedTransaction);
        return response.hash;
    }
    async getAccountBalanceAsync(accountAddress) {
        return this._ethersProvider.getBalance(accountAddress).then((r) => toBigNumber(r));
    }
    /**
     * Check if a worker is ready to pick up a new job:
     * - the worker has enough balance
     * - the worker has no pending transactions
     *
     * @param chainId Id of the chain.
     * @param workerAddress Address of the worker to check.
     * @param balance Balance of the worker to check.
     * @param gasPrice Current gas price.
     * @returns True if a worker is ready to pick up a new job and false otherwise.
     */
    async isWorkerReadyAsync(chainId, workerAddress, balance, gasPrice) {
        let gasEstimate;
        switch (chainId) {
            case contract_addresses_1.ChainId.Polygon:
                gasEstimate = constants_1.ZEROG_METATX_GAS_ESTIMATE;
                break;
            default:
                gasEstimate = constants_1.RFQM_TX_GAS_ESTIMATE;
                break;
        }
        return (0, rfqm_worker_balance_utils_1.isWorkerReadyAndAbleAsync)(this._ethersProvider, workerAddress, balance, gasPrice, gasEstimate);
    }
    /**
     * Converts a @0x/web3-wrapper `TxData` object into an Ethers `TransactionRequest`.
     *
     * If the `from` address is not present in the `TxData`, the function uses the address
     * of the Ethers Wallet passed to `rfqBlockchainUtils`
     *
     * If the `to` address is not present, the function uses the exchange proxy address.
     */
    transformTxDataToTransactionRequest(txOptions, chainId, callData) {
        const baseRequest = {
            chainId,
            data: callData,
            from: txOptions.from,
            // web3wrappers "gas" field -> ethers "gasLimit" field
            gasLimit: txOptions.gas instanceof utils_1.BigNumber ? BigInt(txOptions.gas.toString()) : txOptions.gas,
            nonce: txOptions.nonce,
            to: txOptions.to || this._exchangeProxy.address,
            value: txOptions.value instanceof utils_1.BigNumber ? txOptions.value.toString() : txOptions.value,
        };
        // Handle Type 0 (Legacy) Tx
        if (txOptions.gasPrice) {
            return {
                ...baseRequest,
                type: 0,
                gasPrice: txOptions.gasPrice instanceof utils_1.BigNumber ? txOptions.gasPrice.toString() : txOptions.gasPrice,
            };
        }
        // Handle Type 2 (EIP-1559) Tx
        return {
            ...baseRequest,
            type: 2,
            maxFeePerGas: txOptions.maxFeePerGas instanceof utils_1.BigNumber
                ? BigInt(txOptions.maxFeePerGas.toString())
                : txOptions.maxFeePerGas,
            maxPriorityFeePerGas: txOptions.maxPriorityFeePerGas instanceof utils_1.BigNumber
                ? BigInt(txOptions.maxPriorityFeePerGas.toString())
                : txOptions.maxPriorityFeePerGas,
        };
    }
    /**
     * Uses the Ethers Wallet to sign a transaction. Returns both the signed transaction and its hash.
     *
     * If the containing class has been initialized without a wallet, the function throws.
     */
    async signTransactionAsync(transaction) {
        if (!this._ethersWallet) {
            throw new Error('RFQ Blockchain Utils must be initialized with an Ethers Wallet in order to get transaction hashes before submitting');
        }
        const checkedRequest = await (0, utils_2.resolveProperties)(this._ethersWallet.checkTransaction(transaction));
        const signedTransaction = await this._ethersWallet.signTransaction(checkedRequest);
        const hash = ethers_1.utils.keccak256(signedTransaction);
        return { signedTransaction, transactionHash: hash };
    }
    async getTokenDecimalsAsync(tokenAddress) {
        const erc20AbiDecimals = `[{
            "constant": true,
            "inputs": [],
            "name": "decimals",
            "outputs": [
                {
                    "name": "",
                    "type": "uint8"
                }
            ],
            "payable": false,
            "stateMutability": "view",
            "type": "function"
        }]`;
        const tokenContract = new ethers_1.Contract(tokenAddress, erc20AbiDecimals, this._ethersProvider);
        const decimals = await tokenContract.decimals();
        if (typeof decimals !== 'number') {
            throw new Error('Decimals was not a number');
        }
        return decimals;
    }
    /**
     * Calls the 0x Exchange Proxy to add an address to the list of allowed order signers for the msg's sender.
     */
    async registerAllowedOrderSignerAsync(from, signerAddress, isAllowed) {
        // tslint:disable-next-line: await-promise
        await this._exchangeProxy
            .registerAllowedOrderSigner(signerAddress, isAllowed)
            .awaitTransactionSuccessAsync({ from });
    }
    /**
     * Returns whether the signer address is an allowed order signer of the maker.
     */
    async isValidOrderSignerAsync(makerAddress, signerAddress) {
        return this._exchangeProxy.isValidOrderSigner(makerAddress, signerAddress).callAsync();
    }
    /**
     * Get the gasless approval object which encapsulates the EIP-712 context that would be signed by the `takerAddress`
     * for gasless approval. The two main schemes for gasless approvals are `executeMetaTransaction` and `permit`.
     *
     * @param chainId Id of the chain.
     * @param token The address of the token.
     * @param takerAddress The address of the taker.
     * @param nowMs optional - the current timestamp in milliseconds
     * @returns The corresponding gasless approval oject or null if the token does not support gasless approval (does not exist in our EIP-712 token registry).
     */
    async getGaslessApprovalAsync(chainId, token, takerAddress, nowMs = Date.now()) {
        // If the token does not exist in the token registry, return null
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line no-prototype-builtins
        if (!eip712registry_1.EIP_712_REGISTRY.hasOwnProperty(chainId) || !eip712registry_1.EIP_712_REGISTRY[chainId].hasOwnProperty(token)) {
            return null;
        }
        const tokenEIP712 = eip712registry_1.EIP_712_REGISTRY[chainId][token];
        const eip712DomainType = (0, Eip712Utils_1.extractEIP712DomainType)(tokenEIP712.domain);
        switch (tokenEIP712.kind) {
            case types_1.GaslessApprovalTypes.ExecuteMetaTransaction: {
                const nonce = await this.getMetaTransactionNonceAsync(token, takerAddress);
                // generate calldata for approve with max number of uint256 as amount
                const erc20 = new ethers_1.Contract(token, abis_1.abis.polygonBridgedERC20, this._ethersProvider);
                const { data: approveCalldata } = await erc20.populateTransaction.approve(this._exchangeProxyAddress, ethers_1.constants.MaxUint256);
                const executeMetaTransactionApproval = {
                    kind: types_1.GaslessApprovalTypes.ExecuteMetaTransaction,
                    eip712: {
                        types: {
                            ...eip712DomainType,
                            ...constants_1.EXECUTE_META_TRANSACTION_EIP_712_TYPES,
                        },
                        primaryType: 'MetaTransaction',
                        domain: tokenEIP712.domain,
                        message: {
                            nonce: nonce.toNumber(),
                            from: takerAddress,
                            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            functionSignature: approveCalldata,
                        },
                    },
                };
                return executeMetaTransactionApproval;
            }
            case types_1.GaslessApprovalTypes.Permit: {
                const nonce = await this.getPermitNonceAsync(token, takerAddress);
                const tenMinutesAfterNowS = new utils_1.BigNumber(nowMs + constants_1.ONE_MINUTE_MS * 10).div(constants_1.ONE_SECOND_MS).integerValue();
                const permitApproval = {
                    kind: types_1.GaslessApprovalTypes.Permit,
                    eip712: {
                        types: {
                            ...eip712DomainType,
                            ...constants_1.PERMIT_EIP_712_TYPES,
                        },
                        primaryType: 'Permit',
                        domain: tokenEIP712.domain,
                        message: {
                            owner: takerAddress,
                            spender: this._exchangeProxyAddress,
                            value: ethers_1.constants.MaxUint256.toString(),
                            nonce: nonce.toNumber(),
                            deadline: tenMinutesAfterNowS.toString(),
                        },
                    },
                };
                return permitApproval;
            }
            default:
                throw new Error(`Gasless approval kind ${tokenEIP712.kind} is not implemented yet`);
        }
    }
    /**
     * Get the amount (in base unit) of `token` `spender` will be allowed to spend on behalf on `owner` (the allowance). Note that
     * base unit means 10 ** decimals (decimals of the token).
     *
     * @param token The address of the token.
     * @param owner The address that owns certain amount of `token`.
     * @param spender The address that would like to spend token on behalf of `owner`.
     * @returns The amount (in base unit) of tokens spender is allowed to spend.
     */
    async getAllowanceAsync(token, owner, spender) {
        const erc20 = new ethers_1.Contract(token, abis_1.abis.polygonBridgedERC20, this._ethersProvider);
        const allowance = await erc20.allowance(owner, spender);
        return new utils_1.BigNumber(allowance.toString());
    }
    /**
     * Get nonce for meta transaction. This is used by contracts that support Biconomy's `executeMetaTransaction` which includes bridged tokens on Polygon.
     *
     * @param token The address of the token.
     * @param takerAddress The address of the taker.
     * @returns Nonce.
     */
    async getMetaTransactionNonceAsync(token, takerAddress) {
        const erc20 = new ethers_1.Contract(token, abis_1.abis.polygonBridgedERC20, this._ethersProvider);
        const nonce = await erc20.getNonce(takerAddress);
        return new utils_1.BigNumber(nonce.toString());
    }
    /**
     * Get permit nonce, which is used by contracts that support EIP-2612 standards.
     *
     * @param token The address of the token.
     * @param takerAddress The address of the taker.
     * @returns Nonce.
     */
    async getPermitNonceAsync(token, takerAddress) {
        const erc20 = new ethers_1.Contract(token, abis_1.abis.permitERC20, this._ethersProvider);
        const nonce = await erc20.nonces(takerAddress);
        return new utils_1.BigNumber(nonce.toString());
    }
    /**
     * Generates calldata for gasless approval submission.
     *
     * @param token The address of the token.
     * @param approval The Approval object, which consists of 'kind' and eip712 object.
     * @param signature The gasless approval transaction signed by taker.
     * @returns Generated calldata.
     */
    async generateApprovalCalldataAsync(token, approval, signature) {
        const { kind, eip712 } = approval;
        switch (kind) {
            case types_1.GaslessApprovalTypes.ExecuteMetaTransaction: {
                const erc20 = new ethers_1.Contract(token, abis_1.abis.polygonBridgedERC20, this._ethersProvider);
                const { data } = await erc20.populateTransaction.executeMetaTransaction(eip712.message.from, eip712.message.functionSignature, signature.r, signature.s, signature.v);
                if (!data) {
                    throw new Error(`Cannot generate approval submission calldata for ${kind}`);
                }
                return data;
            }
            case types_1.GaslessApprovalTypes.Permit: {
                const erc20 = new ethers_1.Contract(token, abis_1.abis.permitERC20, this._ethersProvider);
                const { data } = await erc20.populateTransaction.permit(eip712.message.owner, eip712.message.spender, eip712.message.value, eip712.message.deadline, signature.v, signature.r, signature.s);
                if (!data) {
                    throw new Error(`Cannot generate approval submission calldata for ${kind}`);
                }
                return data;
            }
            default:
                throw new Error(`Gasless approval kind ${kind} is not implemented yet`);
        }
    }
}
exports.RfqBlockchainUtils = RfqBlockchainUtils;
class RfqBalanceCheckUtils {
    constructor(_balanceChecker, _exchangeProxyAddress) {
        this._balanceChecker = _balanceChecker;
        this._exchangeProxyAddress = _exchangeProxyAddress;
    }
    /**
     * Fetches min value between balance for a list of addresses against the specified tokens. The index of
     * an address in `addresses` must correspond with the index of a token in `tokens`.
     */
    async getMinOfBalancesAndAllowancesAsync(erc20Owners) {
        const { owners, tokens } = (0, address_utils_1.splitAddresses)(erc20Owners);
        return this._balanceChecker.getMinOfBalancesAndAllowancesAsync(owners, tokens, this._exchangeProxyAddress);
    }
    /**
     * Fetches the balances for a list of addresses against the specified tokens. The index of
     * an address in `addresses` must correspond with the index of a token in `tokens`.
     */
    async getTokenBalancesAsync(erc20Owners) {
        const { owners, tokens } = (0, address_utils_1.splitAddresses)(erc20Owners);
        return this._balanceChecker.getTokenBalancesAsync(owners, tokens);
    }
}
exports.RfqBalanceCheckUtils = RfqBalanceCheckUtils;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy91dGlscy9yZnFfYmxvY2tjaGFpbl91dGlscy50cyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxxQ0FBcUM7QUFFckMsK0RBQWlEO0FBRWpELDZEQUF3RDtBQUN4RCx1REFBb0Y7QUFDcEYsbURBQXNHO0FBQ3RHLHFDQUFpRTtBQUNqRSxrREFBK0M7QUFHL0MsbUNBQXFHO0FBQ3JHLDRDQUFxRDtBQUVyRCxrQ0FBK0I7QUFDL0IsaURBUzJCO0FBQzNCLHNEQUFxRDtBQUNyRCxzQ0FBbUM7QUFDbkMseUNBTXVCO0FBRXZCLG1EQUFpRDtBQUVqRCwrQ0FBd0Q7QUFDeEQsMkVBQXdFO0FBQ3hFLG1EQUErQztBQUMvQywrREFBMkQ7QUFFM0QsbURBQW1EO0FBQ25ELE1BQU0sYUFBYSxHQUFHLElBQUksaUJBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2QyxXQUFXO0FBQ1gsTUFBTSxhQUFhLEdBQUcsSUFBSSxpQkFBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzFDLE1BQU0sNkJBQTZCLEdBQUcsb0VBQW9FLENBQUM7QUFDM0csTUFBTSw2QkFBNkIsR0FBRyxvRUFBb0UsQ0FBQztBQUMzRyxNQUFNLHNCQUFzQixHQUFHO0lBQzNCO1FBQ0ksU0FBUyxFQUFFLEtBQUs7UUFDaEIsTUFBTSxFQUFFO1lBQ0osRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFO1lBQy9FLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTtZQUMzRSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUU7WUFDM0UsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFO1lBQ2hGLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTtZQUNoRixFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsd0JBQXdCLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTtZQUM1RixFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsd0JBQXdCLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTtZQUM1RixFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUU7U0FDN0U7UUFDRCxJQUFJLEVBQUUsZ0JBQWdCO1FBQ3RCLElBQUksRUFBRSxPQUFPO0tBQ2hCO0lBQ0Q7UUFDSSxTQUFTLEVBQUUsS0FBSztRQUNoQixNQUFNLEVBQUU7WUFDSixFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUU7WUFDL0UsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFO1lBQzNFLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTtZQUMzRSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUU7WUFD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Q0FBQztTQUMvRTtJQUNMLENBQUM7Q0FDSjtBQTdyQkQsZ0RBNnJCQztBQUVELE1BQWEsb0JBQW9CO0lBQzdCLFlBQTZCLGVBQStCLEVBQW1CLHFCQUE2QjtRQUEvRSxvQkFBZSxHQUFmLGVBQWUsQ0FBZ0I7UUFBbUIsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUFRO0lBQUcsQ0FBQztJQUVoSDs7O09BR0c7SUFDSSxLQUFLLENBQUMsa0NBQWtDLENBQUMsV0FBc0M7UUFDbEYsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxJQUFBLDhCQUFjLEVBQUMsV0FBVyxDQUFDLENBQUM7UUFDdkQsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLGtDQUFrQyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDL0csQ0FBQztJQUVEOzs7T0FHRztJQUNJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxXQUFzQztRQUNyRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLElBQUEsOEJBQWMsRUFBQyxXQUFXLENBQUMsQ0FBQztRQUN2RCxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMscUJBQXFCLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3RFLENBQUM7Q0FDSjtBQXBCRCxvREFvQkMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy91dGlscy9yZnFfYmxvY2tjaGFpbl91dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZTptYXgtZmlsZS1saW5lLWNvdW50XHJcblxyXG5pbXBvcnQgeyBDaGFpbklkIH0gZnJvbSAnQDB4L2NvbnRyYWN0LWFkZHJlc3Nlcyc7XHJcbmltcG9ydCB7IElaZXJvRXhPdGNPcmRlckZpbGxlZEV2ZW50QXJncywgSVplcm9FeFJmcU9yZGVyRmlsbGVkRXZlbnRBcmdzIH0gZnJvbSAnQDB4L2NvbnRyYWN0LXdyYXBwZXJzJztcclxuaW1wb3J0IHsgSVplcm9FeENvbnRyYWN0IH0gZnJvbSAnQDB4L2NvbnRyYWN0cy16ZXJvLWV4JztcclxuaW1wb3J0IHsgTWV0YVRyYW5zYWN0aW9uLCBPdGNPcmRlciwgUmZxT3JkZXIsIFNpZ25hdHVyZSB9IGZyb20gJ0AweC9wcm90b2NvbC11dGlscyc7XHJcbmltcG9ydCB7IFByaXZhdGVLZXlXYWxsZXRTdWJwcm92aWRlciwgU3VwcG9ydGVkUHJvdmlkZXIsIFdlYjNQcm92aWRlckVuZ2luZSB9IGZyb20gJ0AweC9zdWJwcm92aWRlcnMnO1xyXG5pbXBvcnQgeyBBYmlEZWNvZGVyLCBCaWdOdW1iZXIsIHByb3ZpZGVyVXRpbHMgfSBmcm9tICdAMHgvdXRpbHMnO1xyXG5pbXBvcnQgeyBIRE5vZGUgfSBmcm9tICdAZXRoZXJzcHJvamVjdC9oZG5vZGUnO1xyXG5pbXBvcnQgeyBBY2Nlc3NMaXN0IH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zJztcclxuaW1wb3J0IHsgQ2FsbERhdGEsIExvZ0VudHJ5LCBMb2dXaXRoRGVjb2RlZEFyZ3MsIFR4QWNjZXNzTGlzdCwgVHhEYXRhIH0gZnJvbSAnZXRoZXJldW0tdHlwZXMnO1xyXG5pbXBvcnQgeyBCaWdOdW1iZXIgYXMgRXRoZXJzQmlnTnVtYmVyLCBjb25zdGFudHMsIENvbnRyYWN0LCBwcm92aWRlcnMsIHV0aWxzLCBXYWxsZXQgfSBmcm9tICdldGhlcnMnO1xyXG5pbXBvcnQgeyByZXNvbHZlUHJvcGVydGllcyB9IGZyb20gJ2V0aGVycy9saWIvdXRpbHMnO1xyXG5cclxuaW1wb3J0IHsgYWJpcyB9IGZyb20gJy4uL2FiaXMnO1xyXG5pbXBvcnQge1xyXG4gICAgRVhFQ1VURV9NRVRBX1RSQU5TQUNUSU9OX0VJUF83MTJfVFlQRVMsXHJcbiAgICBOVUxMX0FERFJFU1MsXHJcbiAgICBPTkVfTUlOVVRFX01TLFxyXG4gICAgT05FX1NFQ09ORF9NUyxcclxuICAgIFBFUk1JVF9FSVBfNzEyX1RZUEVTLFxyXG4gICAgUkZRTV9UWF9HQVNfRVNUSU1BVEUsXHJcbiAgICBaRVJPLFxyXG4gICAgWkVST0dfTUVUQVRYX0dBU19FU1RJTUFURSxcclxufSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IEVJUF83MTJfUkVHSVNUUlkgfSBmcm9tICcuLi9laXA3MTJyZWdpc3RyeSc7XHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL2xvZ2dlcic7XHJcbmltcG9ydCB7XHJcbiAgICBBcHByb3ZhbCxcclxuICAgIEVSQzIwT3duZXIsXHJcbiAgICBFeGVjdXRlTWV0YVRyYW5zYWN0aW9uQXBwcm92YWwsXHJcbiAgICBHYXNsZXNzQXBwcm92YWxUeXBlcyxcclxuICAgIFBlcm1pdEFwcHJvdmFsLFxyXG59IGZyb20gJy4uL2NvcmUvdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgc3BsaXRBZGRyZXNzZXMgfSBmcm9tICcuL2FkZHJlc3NfdXRpbHMnO1xyXG5pbXBvcnQgeyBCYWxhbmNlQ2hlY2tlciB9IGZyb20gJy4vYmFsYW5jZV9jaGVja2VyJztcclxuaW1wb3J0IHsgZXh0cmFjdEVJUDcxMkRvbWFpblR5cGUgfSBmcm9tICcuL0VpcDcxMlV0aWxzJztcclxuaW1wb3J0IHsgaXNXb3JrZXJSZWFkeUFuZEFibGVBc3luYyB9IGZyb20gJy4vcmZxbV93b3JrZXJfYmFsYW5jZV91dGlscyc7XHJcbmltcG9ydCB7IHNlcnZpY2VVdGlscyB9IGZyb20gJy4vc2VydmljZV91dGlscyc7XHJcbmltcG9ydCB7IFN1YnByb3ZpZGVyQWRhcHRlciB9IGZyb20gJy4vc3VicHJvdmlkZXJfYWRhcHRlcic7XHJcblxyXG4vLyBhbGxvdyBhIHdpZGUgcmFuZ2UgZm9yIGdhcyBwcmljZSBmb3IgZmxleGliaWxpdHlcclxuY29uc3QgTUlOX0dBU19QUklDRSA9IG5ldyBCaWdOdW1iZXIoMCk7XHJcbi8vIDEwSyBHd2VpXHJcbmNvbnN0IE1BWF9HQVNfUFJJQ0UgPSBuZXcgQmlnTnVtYmVyKDFlMTMpO1xyXG5jb25zdCBSRlFfT1JERVJfRklMTEVEX0VWRU5UX1RPUElDMCA9ICcweDgyOWZhOTlkOTRkYzQ2MzY5MjViMzg2MzJlNjI1NzM2YTYxNGMxNTRkNTUwMDZiN2FiNmJlYTk3OWMyMTBjMzInO1xyXG5jb25zdCBPVENfT1JERVJfRklMTEVEX0VWRU5UX1RPUElDMCA9ICcweGFjNzVmNzczZTNhOTJmMWEwMmIxMjEzNGQ2NWUxZjQ3ZjhhMTRlYWJlNGVhZjFlMjQ2MjQ5MThlNmE4YjI2OWYnO1xyXG5jb25zdCBaRVJPX0VYX0ZJTExfRVZFTlRfQUJJID0gW1xyXG4gICAge1xyXG4gICAgICAgIGFub255bW91czogZmFsc2UsXHJcbiAgICAgICAgaW5wdXRzOiBbXHJcbiAgICAgICAgICAgIHsgaW5kZXhlZDogZmFsc2UsIGludGVybmFsVHlwZTogJ2J5dGVzMzInLCBuYW1lOiAnb3JkZXJIYXNoJywgdHlwZTogJ2J5dGVzMzInIH0sXHJcbiAgICAgICAgICAgIHsgaW5kZXhlZDogZmFsc2UsIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLCBuYW1lOiAnbWFrZXInLCB0eXBlOiAnYWRkcmVzcycgfSxcclxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsIG5hbWU6ICd0YWtlcicsIHR5cGU6ICdhZGRyZXNzJyB9LFxyXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJywgbmFtZTogJ21ha2VyVG9rZW4nLCB0eXBlOiAnYWRkcmVzcycgfSxcclxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsIG5hbWU6ICd0YWtlclRva2VuJywgdHlwZTogJ2FkZHJlc3MnIH0sXHJcbiAgICAgICAgICAgIHsgaW5kZXhlZDogZmFsc2UsIGludGVybmFsVHlwZTogJ3VpbnQxMjgnLCBuYW1lOiAndGFrZXJUb2tlbkZpbGxlZEFtb3VudCcsIHR5cGU6ICd1aW50MTI4JyB9LFxyXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6ICd1aW50MTI4JywgbmFtZTogJ21ha2VyVG9rZW5GaWxsZWRBbW91bnQnLCB0eXBlOiAndWludDEyOCcgfSxcclxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiAnYnl0ZXMzMicsIG5hbWU6ICdwb29sJywgdHlwZTogJ2J5dGVzMzInIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICBuYW1lOiAnUmZxT3JkZXJGaWxsZWQnLFxyXG4gICAgICAgIHR5cGU6ICdldmVudCcsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGFub255bW91czogZmFsc2UsXHJcbiAgICAgICAgaW5wdXRzOiBbXHJcbiAgICAgICAgICAgIHsgaW5kZXhlZDogZmFsc2UsIGludGVybmFsVHlwZTogJ2J5dGVzMzInLCBuYW1lOiAnb3JkZXJIYXNoJywgdHlwZTogJ2J5dGVzMzInIH0sXHJcbiAgICAgICAgICAgIHsgaW5kZXhlZDogZmFsc2UsIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLCBuYW1lOiAnbWFrZXInLCB0eXBlOiAnYWRkcmVzcycgfSxcclxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsIG5hbWU6ICd0YWtlcicsIHR5cGU6ICdhZGRyZXNzJyB9LFxyXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJywgbmFtZTogJ21ha2VyVG9rZW4nLCB0eXBlOiAnYWRkcmVzcycgfSxcclxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsIG5hbWU6ICd0YWtlclRva2VuJywgdHlwZTogJ2FkZHJlc3MnIH0sXHJcbiAgICAgICAgICAgIHsgaW5kZXhlZDogZmFsc2UsIGludGVybmFsVHlwZTogJ3VpbnQxMjgnLCBuYW1lOiAnbWFrZXJUb2tlbkZpbGxlZEFtb3VudCcsIHR5cGU6ICd1aW50MTI4JyB9LFxyXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6ICd1aW50MTI4JywgbmFtZTogJ3Rha2VyVG9rZW5GaWxsZWRBbW91bnQnLCB0eXBlOiAndWludDEyOCcgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIG5hbWU6ICdPdGNPcmRlckZpbGxlZCcsXHJcbiAgICAgICAgdHlwZTogJ2V2ZW50JyxcclxuICAgIH0sXHJcbl07XHJcblxyXG5mdW5jdGlvbiB0b0JpZ051bWJlcihldGhlcnNCaWdOdW1iZXI6IEV0aGVyc0JpZ051bWJlcik6IEJpZ051bWJlciB7XHJcbiAgICByZXR1cm4gbmV3IEJpZ051bWJlcihldGhlcnNCaWdOdW1iZXIudG9TdHJpbmcoKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBSZnFCbG9ja2NoYWluVXRpbHMge1xyXG4gICAgcHVibGljIHJlYWRvbmx5IGJhbGFuY2VDaGVja1V0aWxzOiBSZnFCYWxhbmNlQ2hlY2tVdGlscztcclxuXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9leGNoYW5nZVByb3h5OiBJWmVyb0V4Q29udHJhY3Q7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9hYmlEZWNvZGVyOiBBYmlEZWNvZGVyO1xyXG4gICAgLy8gQW4gZXRoZXJzLmpzIHByb3ZpZGVyLlxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfZXRoZXJzUHJvdmlkZXI6IHByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXI7XHJcbiAgICAvLyBBbiBldGhlcnMuanMgV2FsbGV0LiBNdXN0IGJlIHBvcHVsYXRlZCBmb3IgUmZxQmxvY2tjaGFpblV0aWxzIGluc3RhbmNlcyB1c2VkIGJ5IFJGUU0gV29ya2Vycy5cclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2V0aGVyc1dhbGxldDogV2FsbGV0IHwgdW5kZWZpbmVkO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0UHJpdmF0ZUtleUZyb21JbmRleEFuZFBocmFzZShtbmVtb25pYzogc3RyaW5nLCBpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBoZE5vZGUgPSBIRE5vZGUuZnJvbU1uZW1vbmljKG1uZW1vbmljKS5kZXJpdmVQYXRoKHRoaXMuX2dldFBhdGhCeUluZGV4KGluZGV4KSk7XHJcblxyXG4gICAgICAgIC8vIHRha2UgJzB4JyBvZmZcclxuICAgICAgICByZXR1cm4gaGROb2RlLnByaXZhdGVLZXkuc3Vic3RyaW5nKDIpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0QWRkcmVzc0Zyb21JbmRleEFuZFBocmFzZShtbmVtb25pYzogc3RyaW5nLCBpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBoZE5vZGUgPSBIRE5vZGUuZnJvbU1uZW1vbmljKG1uZW1vbmljKS5kZXJpdmVQYXRoKHRoaXMuX2dldFBhdGhCeUluZGV4KGluZGV4KSk7XHJcblxyXG4gICAgICAgIHJldHVybiBoZE5vZGUuYWRkcmVzcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZVByaXZhdGVLZXlQcm92aWRlcihcclxuICAgICAgICBycGNQcm92aWRlcjogU3VwcG9ydGVkUHJvdmlkZXIsXHJcbiAgICAgICAgcHJpdmF0ZVdhbGxldFN1YnByb3ZpZGVyOiBQcml2YXRlS2V5V2FsbGV0U3VicHJvdmlkZXIsXHJcbiAgICApOiBTdXBwb3J0ZWRQcm92aWRlciB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXJFbmdpbmUgPSBuZXcgV2ViM1Byb3ZpZGVyRW5naW5lKCk7XHJcbiAgICAgICAgcHJvdmlkZXJFbmdpbmUuYWRkUHJvdmlkZXIocHJpdmF0ZVdhbGxldFN1YnByb3ZpZGVyKTtcclxuICAgICAgICBwcm92aWRlckVuZ2luZS5hZGRQcm92aWRlcihuZXcgU3VicHJvdmlkZXJBZGFwdGVyKHJwY1Byb3ZpZGVyKSk7XHJcbiAgICAgICAgcHJvdmlkZXJVdGlscy5zdGFydFByb3ZpZGVyRW5naW5lKHByb3ZpZGVyRW5naW5lKTtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXJFbmdpbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnByZWZlci1mdW5jdGlvbi1vdmVyLW1ldGhvZFxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2dldFBhdGhCeUluZGV4KGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICAgIC8vIGVuc3VyZSBpbmRleCBpcyBhIDArIGludGVnZXJcclxuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ICE9PSBNYXRoLmZsb29yKGluZGV4KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5kZXhgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGBtLzQ0Jy82MCcvMCcvMC9gLmNvbmNhdChTdHJpbmcoaW5kZXgpKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcm92aWRlcjogU3VwcG9ydGVkUHJvdmlkZXIsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfZXhjaGFuZ2VQcm94eUFkZHJlc3M6IHN0cmluZyxcclxuICAgICAgICBiYWxhbmNlQ2hlY2tlcjogQmFsYW5jZUNoZWNrZXIsXHJcbiAgICAgICAgZXRoZXJzUHJvdmlkZXI6IHByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIsXHJcbiAgICAgICAgZXRoZXJzV2FsbGV0PzogV2FsbGV0LFxyXG4gICAgKSB7XHJcbiAgICAgICAgdGhpcy5fYWJpRGVjb2RlciA9IG5ldyBBYmlEZWNvZGVyKFtaRVJPX0VYX0ZJTExfRVZFTlRfQUJJXSk7XHJcbiAgICAgICAgdGhpcy5iYWxhbmNlQ2hlY2tVdGlscyA9IG5ldyBSZnFCYWxhbmNlQ2hlY2tVdGlscyhiYWxhbmNlQ2hlY2tlciwgX2V4Y2hhbmdlUHJveHlBZGRyZXNzKTtcclxuICAgICAgICB0aGlzLl9ldGhlcnNQcm92aWRlciA9IGV0aGVyc1Byb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuX2V0aGVyc1dhbGxldCA9IGV0aGVyc1dhbGxldDtcclxuICAgICAgICB0aGlzLl9leGNoYW5nZVByb3h5ID0gbmV3IElaZXJvRXhDb250cmFjdCh0aGlzLl9leGNoYW5nZVByb3h5QWRkcmVzcywgcHJvdmlkZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2hlcyBtaW4gdmFsdWUgYmV0d2VlbiBiYWxhbmNlIGZvciBhIGxpc3Qgb2YgYWRkcmVzc2VzIGFnYWluc3QgdGhlIHNwZWNpZmllZCB0b2tlbnMuIFRoZSBpbmRleCBvZlxyXG4gICAgICogYW4gYWRkcmVzcyBpbiBgYWRkcmVzc2VzYCBtdXN0IGNvcnJlc3BvbmQgd2l0aCB0aGUgaW5kZXggb2YgYSB0b2tlbiBpbiBgdG9rZW5zYC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMoZXJjMjBPd25lcnM6IEVSQzIwT3duZXIgfCBFUkMyME93bmVyW10pOiBQcm9taXNlPEJpZ051bWJlcltdPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZUNoZWNrVXRpbHMuZ2V0TWluT2ZCYWxhbmNlc0FuZEFsbG93YW5jZXNBc3luYyhlcmMyME93bmVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaGVzIHRoZSBiYWxhbmNlcyBmb3IgYSBsaXN0IG9mIGFkZHJlc3NlcyBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgdG9rZW5zLiBUaGUgaW5kZXggb2ZcclxuICAgICAqIGFuIGFkZHJlc3MgaW4gYGFkZHJlc3Nlc2AgbXVzdCBjb3JyZXNwb25kIHdpdGggdGhlIGluZGV4IG9mIGEgdG9rZW4gaW4gYHRva2Vuc2AuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRUb2tlbkJhbGFuY2VzQXN5bmMoZXJjMjBPd25lcnM6IEVSQzIwT3duZXIgfCBFUkMyME93bmVyW10pOiBQcm9taXNlPEJpZ051bWJlcltdPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZUNoZWNrVXRpbHMuZ2V0VG9rZW5CYWxhbmNlc0FzeW5jKGVyYzIwT3duZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmb3IgdXNlIHdoZW4gMHggQVBJIG9wZXJhdG9yIHN1Ym1pdHMgYW4gb3JkZXIgb24tY2hhaW4gb24gYmVoYWxmIG9mIHRha2VyXHJcbiAgICBwdWJsaWMgZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb24oXHJcbiAgICAgICAgcmZxT3JkZXI6IFJmcU9yZGVyLFxyXG4gICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLFxyXG4gICAgICAgIHRha2VyOiBzdHJpbmcsXHJcbiAgICAgICAgdGFrZXJBbW91bnQ6IEJpZ051bWJlcixcclxuICAgICAgICBjaGFpbklkOiBDaGFpbklkLFxyXG4gICAgKTogTWV0YVRyYW5zYWN0aW9uIHtcclxuICAgICAgICAvLyBnZW5lcmF0ZSBjYWxsIGRhdGEgZm9yIGZpbGxSZnFPcmRlclxyXG4gICAgICAgIGNvbnN0IGNhbGxEYXRhID0gdGhpcy5fZXhjaGFuZ2VQcm94eVxyXG4gICAgICAgICAgICAuZmlsbFJmcU9yZGVyKHJmcU9yZGVyLCBzaWduYXR1cmUsIHRha2VyQW1vdW50KVxyXG4gICAgICAgICAgICAuZ2V0QUJJRW5jb2RlZFRyYW5zYWN0aW9uRGF0YSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IE1ldGFUcmFuc2FjdGlvbih7XHJcbiAgICAgICAgICAgIHNpZ25lcjogdGFrZXIsXHJcbiAgICAgICAgICAgIHNlbmRlcjogTlVMTF9BRERSRVNTLFxyXG4gICAgICAgICAgICBtaW5HYXNQcmljZTogTUlOX0dBU19QUklDRSxcclxuICAgICAgICAgICAgbWF4R2FzUHJpY2U6IE1BWF9HQVNfUFJJQ0UsXHJcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lU2Vjb25kczogcmZxT3JkZXIuZXhwaXJ5LFxyXG4gICAgICAgICAgICBzYWx0OiBuZXcgQmlnTnVtYmVyKERhdGUubm93KCkpLFxyXG4gICAgICAgICAgICBjYWxsRGF0YSxcclxuICAgICAgICAgICAgdmFsdWU6IFpFUk8sXHJcbiAgICAgICAgICAgIGZlZVRva2VuOiBOVUxMX0FERFJFU1MsXHJcbiAgICAgICAgICAgIGZlZUFtb3VudDogWkVSTyxcclxuICAgICAgICAgICAgY2hhaW5JZCxcclxuICAgICAgICAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6IHRoaXMuX2V4Y2hhbmdlUHJveHkuYWRkcmVzcyxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVjb2RlTWV0YVRyYW5zYWN0aW9uQ2FsbERhdGFBbmRWYWxpZGF0ZUFzeW5jKFxyXG4gICAgICAgIGNhbGxkYXRhOiBzdHJpbmcsXHJcbiAgICAgICAgc2VuZGVyOiBzdHJpbmcsXHJcbiAgICAgICAgdHhPcHRpb25zPzogUGFydGlhbDxDYWxsRGF0YT4sXHJcbiAgICApOiBQcm9taXNlPFtCaWdOdW1iZXIsIEJpZ051bWJlcl0+IHtcclxuICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICBjb25zdCBtZXRhVHhJbnB1dDogYW55ID0gdGhpcy5fZXhjaGFuZ2VQcm94eS5nZXRBQklEZWNvZGVkVHJhbnNhY3Rpb25EYXRhKCdleGVjdXRlTWV0YVRyYW5zYWN0aW9uJywgY2FsbGRhdGEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlTWV0YVRyYW5zYWN0aW9uT3JUaHJvd0FzeW5jKG1ldGFUeElucHV0WzBdLCBtZXRhVHhJbnB1dFsxXSwgc2VuZGVyLCB0eE9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGVzIGEgbWV0YXRyYW5zYWN0aW9uIGFuZCBpdHMgc2lnbmF0dXJlIGZvciBhIGdpdmVuIHNlbmRlclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGEgUHJvbWlzZSBvZiBbdGFrZXJUb2tlbkZpbGxlZEFtb3VudCwgbWFrZXJUb2tlbkZpbGxlZEFtb3VudF1cclxuICAgICAqIEB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIG1ldGF0cmFuc2FjdGlvbiBpcyBub3QgdmFsaWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIHZhbGlkYXRlTWV0YVRyYW5zYWN0aW9uT3JUaHJvd0FzeW5jKFxyXG4gICAgICAgIG1ldGFUeDogTWV0YVRyYW5zYWN0aW9uLFxyXG4gICAgICAgIG1ldGFUeFNpZzogU2lnbmF0dXJlLFxyXG4gICAgICAgIHNlbmRlcjogc3RyaW5nLFxyXG4gICAgICAgIHR4T3B0aW9ucz86IFBhcnRpYWw8Q2FsbERhdGE+LFxyXG4gICAgKTogUHJvbWlzZTxbQmlnTnVtYmVyLCBCaWdOdW1iZXJdPiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuX2V4Y2hhbmdlUHJveHlcclxuICAgICAgICAgICAgICAgIC5leGVjdXRlTWV0YVRyYW5zYWN0aW9uKG1ldGFUeCwgbWV0YVR4U2lnKVxyXG4gICAgICAgICAgICAgICAgLmNhbGxBc3luYyh7IGZyb206IHNlbmRlciwgLi4udHhPcHRpb25zIH0pO1xyXG4gICAgICAgICAgICBjb25zdCB0YWtlclRva2VuRmlsbEFtb3VudCA9IC8vICRlc2xpbnQtZml4LW1lIGdpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXHJcbiAgICAgICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhjaGFuZ2VQcm94eS5nZXRBQklEZWNvZGVkVHJhbnNhY3Rpb25EYXRhKCdmaWxsUmZxT3JkZXInLCBtZXRhVHguY2FsbERhdGEpIGFzIGFueVxyXG4gICAgICAgICAgICAgICAgKSAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9bMl07XHJcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWRSZXN1bHRzOiBbQmlnTnVtYmVyLCBCaWdOdW1iZXJdID0gdGhpcy5fZXhjaGFuZ2VQcm94eS5nZXRBQklEZWNvZGVkUmV0dXJuRGF0YShcclxuICAgICAgICAgICAgICAgICdmaWxsUmZxT3JkZXInLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0cyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKGRlY29kZWRSZXN1bHRzWzBdLmlzTGVzc1RoYW4odGFrZXJUb2tlbkZpbGxBbW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ3ZhbGlkYXRpb24gZmFpbGVkIGJlY2F1c2UgZmlsbGVkIGFtb3VudCBpcyBsZXNzIHRoYW4gcmVxdWVzdGVkIGZpbGwgYW1vdW50Jyk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpbGxlZCBhbW91bnQgaXMgbGVzcyB0aGFuIHJlcXVlc3RlZCBmaWxsIGFtb3VudGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVkUmVzdWx0cztcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKHsgZXJyb3JNZXNzYWdlOiBlcnI/Lm1lc3NhZ2UgfSwgJ2V0aF9jYWxsIHZhbGlkYXRpb24gZmFpbGVkIGZvciBleGVjdXRlTWV0YVRyYW5zYWN0aW9uJyk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbXVsYXRlIHRoZSB0cmFuc2FjdGlvbiB3aXRoIGNhbGxkYXRhLlxyXG4gICAgICpcclxuICAgICAqIE5PVEU6IEluIGV0aGVycy5qcywgcHJvdmlkZXIuY2FsbCBhbmQgcHJvdmlkZXIuc2VuZCgnZXRoX2NhbGwnLCAuLi4pIG1pZ2h0IG5vdCB0aHJvdyBleGNlcHRpb24uXHJcbiAgICAgKiAgICAgICBUaGUgYmVoYXZpb3IgbWlnaHQgYmUgZGVwZW5kZW50IG9uIHByb3ZpZGVycy4gUmV2aXNpdCB0aGlzIGxhdGVyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgc2ltdWxhdGVUcmFuc2FjdGlvbkFzeW5jKHRvOiBzdHJpbmcsIGNhbGxkYXRhOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9ldGhlcnNQcm92aWRlci5jYWxsKHtcclxuICAgICAgICAgICAgICAgIHRvLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogY2FsbGRhdGEsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYHNpbXVsYXRlVHJhbnNhY3Rpb25Bc3luYzogJHtlLm1lc3NhZ2V9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVzdGltYXRlIHRoZSBnYXMgZm9yIGZpbGxUYWtlclNpZ25lZE90Y09yZGVyIGFuZCBmaWxsVGFrZXJTaWduZWRPdGNPcmRlckZvckV0aFxyXG4gICAgICogTk9URTogY2FuIGFsc28gYmUgdXNlZCBmb3IgdmFsaWRhdGlvblxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGEgUHJvbWlzZSBvZiB0aGUgZ2FzIGVzdGltYXRlXHJcbiAgICAgKiBAdGhyb3dzIGFuIGVycm9yIGlmIHRyYW5zYWN0aW9uIHdpbGwgcmV2ZXJ0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBlc3RpbWF0ZUdhc0ZvckZpbGxUYWtlclNpZ25lZE90Y09yZGVyQXN5bmMoXHJcbiAgICAgICAgb3JkZXI6IE90Y09yZGVyLFxyXG4gICAgICAgIG1ha2VyU2lnbmF0dXJlOiBTaWduYXR1cmUsXHJcbiAgICAgICAgdGFrZXJTaWduYXR1cmU6IFNpZ25hdHVyZSxcclxuICAgICAgICBzZW5kZXI6IHN0cmluZyxcclxuICAgICAgICBpc1Vud3JhcDogYm9vbGVhbixcclxuICAgICk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGlzVW53cmFwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZXhjaGFuZ2VQcm94eVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWxsVGFrZXJTaWduZWRPdGNPcmRlckZvckV0aChvcmRlciwgbWFrZXJTaWduYXR1cmUsIHRha2VyU2lnbmF0dXJlKVxyXG4gICAgICAgICAgICAgICAgICAgIC5lc3RpbWF0ZUdhc0FzeW5jKHsgZnJvbTogc2VuZGVyIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2V4Y2hhbmdlUHJveHlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsbFRha2VyU2lnbmVkT3RjT3JkZXIob3JkZXIsIG1ha2VyU2lnbmF0dXJlLCB0YWtlclNpZ25hdHVyZSlcclxuICAgICAgICAgICAgICAgICAgICAuZXN0aW1hdGVHYXNBc3luYyh7IGZyb206IHNlbmRlciB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJIYXNoOiBvcmRlci5nZXRIYXNoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbWFrZXI6IG9yZGVyLm1ha2VyLFxyXG4gICAgICAgICAgICAgICAgICAgIHRha2VyOiBvcmRlci50YWtlcixcclxuICAgICAgICAgICAgICAgICAgICBpc1Vud3JhcCxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6IGVycj8ubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAndmFsaWRhdGlvbiBmYWlsZWQgZm9yIHRha2VyIHNpZ25lZCBPdGNPcmRlcicsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgY2FsbGRhdGEgZm9yIFRha2VyIFNpZ25lZCBPdGNPcmRlciBzZXR0bGVtZW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZW5lcmF0ZVRha2VyU2lnbmVkT3RjT3JkZXJDYWxsRGF0YShcclxuICAgICAgICBvcmRlcjogT3RjT3JkZXIsXHJcbiAgICAgICAgbWFrZXJTaWduYXR1cmU6IFNpZ25hdHVyZSxcclxuICAgICAgICB0YWtlclNpZ25hdHVyZTogU2lnbmF0dXJlLFxyXG4gICAgICAgIGlzVW53cmFwOiBib29sZWFuLFxyXG4gICAgICAgIGFmZmlsaWF0ZUFkZHJlc3M6IHN0cmluZyB8IG51bGwsXHJcbiAgICApOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IGNhbGxEYXRhID0gaXNVbndyYXBcclxuICAgICAgICAgICAgPyB0aGlzLl9leGNoYW5nZVByb3h5XHJcbiAgICAgICAgICAgICAgICAgIC5maWxsVGFrZXJTaWduZWRPdGNPcmRlckZvckV0aChvcmRlciwgbWFrZXJTaWduYXR1cmUsIHRha2VyU2lnbmF0dXJlKVxyXG4gICAgICAgICAgICAgICAgICAuZ2V0QUJJRW5jb2RlZFRyYW5zYWN0aW9uRGF0YSgpXHJcbiAgICAgICAgICAgIDogdGhpcy5fZXhjaGFuZ2VQcm94eVxyXG4gICAgICAgICAgICAgICAgICAuZmlsbFRha2VyU2lnbmVkT3RjT3JkZXIob3JkZXIsIG1ha2VyU2lnbmF0dXJlLCB0YWtlclNpZ25hdHVyZSlcclxuICAgICAgICAgICAgICAgICAgLmdldEFCSUVuY29kZWRUcmFuc2FjdGlvbkRhdGEoKTtcclxuICAgICAgICByZXR1cm4gc2VydmljZVV0aWxzLmF0dHJpYnV0ZUNhbGxEYXRhKGNhbGxEYXRhLCBhZmZpbGlhdGVBZGRyZXNzKS5hZmZpbGlhdGVkRGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb25DYWxsRGF0YShcclxuICAgICAgICBtZXRhVHg6IE1ldGFUcmFuc2FjdGlvbixcclxuICAgICAgICBtZXRhVHhTaWc6IFNpZ25hdHVyZSxcclxuICAgICAgICBhZmZpbGlhdGVBZGRyZXNzOiBzdHJpbmcgfCBudWxsLFxyXG4gICAgKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBjYWxsRGF0YSA9IHRoaXMuX2V4Y2hhbmdlUHJveHkuZXhlY3V0ZU1ldGFUcmFuc2FjdGlvbihtZXRhVHgsIG1ldGFUeFNpZykuZ2V0QUJJRW5jb2RlZFRyYW5zYWN0aW9uRGF0YSgpO1xyXG4gICAgICAgIHJldHVybiBzZXJ2aWNlVXRpbHMuYXR0cmlidXRlQ2FsbERhdGEoY2FsbERhdGEsIGFmZmlsaWF0ZUFkZHJlc3MpLmFmZmlsaWF0ZWREYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXROb25jZUFzeW5jKHdvcmtlckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V0aGVyc1Byb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQod29ya2VyQWRkcmVzcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEV4Y2hhbmdlUHJveHlBZGRyZXNzKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4Y2hhbmdlUHJveHlBZGRyZXNzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdHMgZm9yIHRoZSBnaXZlbiB0cmFuc2FjdGlvbiBoYXNoZXMuXHJcbiAgICAgKiBJZiBhIHJlY2VpcHQgZG9lcyBub3QgZXhpc3QsIHJldHVybnMgYHVuZGVmaW5lZGAuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRSZWNlaXB0c0FzeW5jKHRyYW5zYWN0aW9uSGFzaGVzOiBzdHJpbmdbXSk6IFByb21pc2U8KHByb3ZpZGVycy5UcmFuc2FjdGlvblJlY2VpcHQgfCB1bmRlZmluZWQpW10+IHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaGVzLm1hcChhc3luYyAodHJhbnNhY3Rpb25IYXNoKSA9PlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXRoZXJzUHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCksXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0Q3VycmVudEJsb2NrQXN5bmMoKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXRoZXJzUHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGZXRjaGVzIGEgYmxvY2sgZnJvbSB0aGUgYmxvY2sgbnVtYmVyIG9yIGJsb2NrIGhhc2hcclxuICAgIHB1YmxpYyBhc3luYyBnZXRCbG9ja0FzeW5jKGJsb2NrSGFzaDogcHJvdmlkZXJzLkJsb2NrVGFnKTogUHJvbWlzZTxwcm92aWRlcnMuQmxvY2s+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXRoZXJzUHJvdmlkZXIuZ2V0QmxvY2soYmxvY2tIYXNoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhc3N0aHJvdWdoIHRvIHRoZSBldGhlcnMgYGdldFRyYW5zYWN0aW9uYCBmdW5jdGlvblxyXG4gICAgICogaHR0cHM6Ly9kb2NzLmV0aGVycy5pby92NS9hcGkvcHJvdmlkZXJzL3Byb3ZpZGVyLyNQcm92aWRlci1nZXRUcmFuc2FjdGlvbjpcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiB3aXRoIGhhc2ggb3IgbnVsbCBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgdW5rbm93bi5cclxuICAgICAqIElmIGEgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCB0aGlzIG1ldGhvZCB3aWxsIHNlYXJjaCB0aGUgdHJhbnNhY3Rpb24gcG9vbC5cclxuICAgICAqIFZhcmlvdXMgYmFja2VuZHMgbWF5IGhhdmUgbW9yZSByZXN0cmljdGl2ZSB0cmFuc2FjdGlvbiBwb29sIGFjY2Vzc1xyXG4gICAgICogKGUuZy4gaWYgdGhlIGdhcyBwcmljZSBpcyB0b28gbG93IG9yIHRoZSB0cmFuc2FjdGlvbiB3YXMgb25seSByZWNlbnRseSBzZW50IGFuZCBub3QgeWV0IGluZGV4ZWQpXHJcbiAgICAgKiBpbiB3aGljaCBjYXNlIHRoaXMgbWV0aG9kIG1heSBhbHNvIHJldHVybiBudWxsLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0VHJhbnNhY3Rpb25Bc3luYyh0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyk6IFByb21pc2U8cHJvdmlkZXJzLlRyYW5zYWN0aW9uUmVzcG9uc2UgfCBudWxsPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V0aGVyc1Byb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFc3RpbWF0ZSBnYXMgKGluIHdlaSkgZ2l2ZW4gYSB0cmFuc2FjdGlvbiByZXF1ZXN0IHVzaW5nIGBldGhfZXN0aW1hdGVHYXNgIEpTT04gUlBDIG1ldGhvZC5cclxuICAgICAqIFRoZSB0cmFuc2FjdGlvbiByZXF1ZXN0IGNvbnRhaW5zIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhlIHRyYW5zYWN0aW9uIChmcm9tLCB0bywgZGF0YSwgZXRjLikuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uUmVxdWVzdCBUcmFuc2FjdGlvbiByZXF1ZXN0IG9iamVjdCB3aGljaCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZ2FzIGVzdGltYXRlIGZvciB0aGUgdHJhbnNhY3Rpb24gaW4gd2VpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZXN0aW1hdGVHYXNGb3JBc3luYyh0cmFuc2FjdGlvblJlcXVlc3Q6IHByb3ZpZGVycy5UcmFuc2FjdGlvblJlcXVlc3QpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdhc0VzdGltYXRlID0gYXdhaXQgdGhpcy5fZXRoZXJzUHJvdmlkZXIuZXN0aW1hdGVHYXModHJhbnNhY3Rpb25SZXF1ZXN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIGdhc0VzdGltYXRlLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBgZXN0aW1hdGVHYXNGb3JBc3luYzogJHtlLm1lc3NhZ2V9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYWNjZXNzIGxpc3QgYW5kIHRoZSBnYXMgZXN0aW1hdGlvbiBnaXZlbiBhIHRyYW5zYWN0aW9uIHJlcXVlc3QuIFVzZXMgdGhlIHByb3ZpZGVyXHJcbiAgICAgKiB0byBjYWxsIHRoZSBgZXRoX2NyZWF0ZUFjY2Vzc0xpc3RgIEpTT04gUlBDIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgdHJhbnNhY3Rpb24gcmVxdWVzdCBjb250YWlucyBpbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoZSB0cmFuc2FjdGlvbiAoZnJvbSwgdG8sIGRhdGEsIGV0Yy4pLlxyXG4gICAgICogTm90ZSB0aGF0IHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBzaW1pbGFyIHRvIHRoZSBvbmUgaW4gQDB4L3dlYjMtd3JhcHBlci4gVGhpcyByZXBvIGlzXHJcbiAgICAgKiBtaWdyYXRpbmcgYXdheSBmcm9tIHdlYjMtd3JhcHBlciBpbiBmYXZvciBvZiBldGhlcnMuIFRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBpblxyXG4gICAgICogd2ViMy13cmFwcGVyOlxyXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tLzB4UHJvamVjdC90b29scy9ibG9iL2RldmVsb3BtZW50L3dlYjMtd3JhcHBlci9zcmMvd2ViM193cmFwcGVyLnRzI0w1OTFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25SZXF1ZXN0IFRyYW5zYWN0aW9uIHJlcXVlc3Qgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0cmFuc2FjdGlvbi5cclxuICAgICAqIEByZXR1cm5zIEEgVHhBY2Nlc3NMaXN0V2l0aEdhcyBvYmplY3Qgd2hpY2ggY29udGFpbnMgYWNjZXNzIGxpc3QgYW5kIGdhcyBlc3RpbWF0aW9uIGZvciB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBjcmVhdGVBY2Nlc3NMaXN0Rm9yQXN5bmMoXHJcbiAgICAgICAgdHJhbnNhY3Rpb25SZXF1ZXN0OiBwcm92aWRlcnMuVHJhbnNhY3Rpb25SZXF1ZXN0LFxyXG4gICAgKTogUHJvbWlzZTx7IGFjY2Vzc0xpc3Q6IFR4QWNjZXNzTGlzdDsgZ2FzRXN0aW1hdGU6IG51bWJlciB9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmF3UmVzdWx0ID0gYXdhaXQgdGhpcy5fZXRoZXJzUHJvdmlkZXIuc2VuZCgnZXRoX2NyZWF0ZUFjY2Vzc0xpc3QnLCBbdHJhbnNhY3Rpb25SZXF1ZXN0XSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0xpc3Q6IEFjY2Vzc0xpc3QgPSByYXdSZXN1bHQuYWNjZXNzTGlzdDtcclxuICAgICAgICAgICAgY29uc3QgZ2FzVXNlZDogc3RyaW5nID0gcmF3UmVzdWx0Lmdhc1VzZWQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHR5cGUgZm9yIGBhY2Nlc3NMaXN0YCBpcyBgQWNjZXNzTGlzdGAgKEFycmF5PHsgYWRkcmVzczogc3RyaW5nLCBzdG9yYWdlS2V5czogQXJyYXk8c3RyaW5nPiB9PikuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVkdWNlIG9wZXJhdGlvbiBpcyB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYXJyYXkgaW50byB0eXBlIGBUeEFjY2Vzc0xpc3RgIChbYWRkcmVzczogc3RyaW5nXTogc3RyaW5nW10pIHdob3NlIGtleXNcclxuICAgICAgICAgICAgICAgIC8vIGFyZSBhZGRyZXNzZXMgYW5kIHZhbHVlcyBhcmUgY29ycmVzcG9uZGluZyBzdG9yYWdlIGtleXMuIFRoaXMgaXMgdXNlZnVsIGlmIHdlIG5lZWQgdG8gcmVtb3ZlIGFuIGFkZHJlc3MgZnJvbSB0aGUgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgYWNjZXNzTGlzdDogYWNjZXNzTGlzdC5yZWR1Y2UoKG86IFR4QWNjZXNzTGlzdCwgdjogeyBhZGRyZXNzOiBzdHJpbmc7IHN0b3JhZ2VLZXlzOiBzdHJpbmdbXSB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb1t2LmFkZHJlc3NdID0gb1t2LmFkZHJlc3NdIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIG9bdi5hZGRyZXNzXS5wdXNoKC4uLih2LnN0b3JhZ2VLZXlzIHx8IFtdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XHJcbiAgICAgICAgICAgICAgICB9LCB7fSksXHJcbiAgICAgICAgICAgICAgICBnYXNFc3RpbWF0ZTogbmV3IEJpZ051bWJlcihnYXNVc2VkKS50b051bWJlcigpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYGNyZWF0ZUFjY2Vzc0xpc3RGb3JBc3luYzogJHtlLm1lc3NhZ2V9YDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldERlY29kZWRSZnFPcmRlckZpbGxFdmVudExvZ0Zyb21Mb2dzKFxyXG4gICAgICAgIGxvZ3M6IExvZ0VudHJ5W10sXHJcbiAgICApOiBMb2dXaXRoRGVjb2RlZEFyZ3M8SVplcm9FeFJmcU9yZGVyRmlsbGVkRXZlbnRBcmdzPiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncykge1xyXG4gICAgICAgICAgICBpZiAobG9nLnRvcGljc1swXSA9PT0gUkZRX09SREVSX0ZJTExFRF9FVkVOVF9UT1BJQzApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYmlEZWNvZGVyLnRyeVRvRGVjb2RlTG9nT3JOb29wKGxvZykgYXMgTG9nV2l0aERlY29kZWRBcmdzPElaZXJvRXhSZnFPcmRlckZpbGxlZEV2ZW50QXJncz47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICBgbm8gUmZxT3JkZXJGaWxsZWRFdmVudCBsb2dzIGFtb25nIHRoZSBsb2dzIHBhc3NlZCBpbnRvIGdldERlY29kZWRSZnFPcmRlckZpbGxFdmVudExvZ0Zyb21Mb2dzYCxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlIHRoZSBPdGNPcmRlciBGaWxsZWQgRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldERlY29kZWRPdGNPcmRlckZpbGxFdmVudExvZ0Zyb21Mb2dzKFxyXG4gICAgICAgIGxvZ3M6IExvZ0VudHJ5W10sXHJcbiAgICApOiBMb2dXaXRoRGVjb2RlZEFyZ3M8SVplcm9FeE90Y09yZGVyRmlsbGVkRXZlbnRBcmdzPiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncykge1xyXG4gICAgICAgICAgICBpZiAobG9nLnRvcGljc1swXSA9PT0gT1RDX09SREVSX0ZJTExFRF9FVkVOVF9UT1BJQzApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYmlEZWNvZGVyLnRyeVRvRGVjb2RlTG9nT3JOb29wKGxvZykgYXMgTG9nV2l0aERlY29kZWRBcmdzPElaZXJvRXhSZnFPcmRlckZpbGxlZEV2ZW50QXJncz47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICBgbm8gT3RjT3JkZXJGaWxsZWRFdmVudCBsb2dzIGFtb25nIHRoZSBsb2dzIHBhc3NlZCBpbnRvIGdldERlY29kZWRPdGNPcmRlckZpbGxFdmVudExvZ0Zyb21Mb2dzYCxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnJvYWRjYXN0cyBhIHJhdyB0cmFuc2FjdGlvbiB2aWEgdGhlIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYCBKU09OIFJQQyBtZXRob2QuXHJcbiAgICAgKiBUaGUgdHJhbnNhY3Rpb24gbXVzdCBiZSBzaWduZWQgYnkgdGhpcyBwb2ludCwgb3RoZXJ3aXNlIHN1Ym1pc3Npb24gd2lsbCBmYWlsLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2FjdGlvbiBoYXNoIHJldHVybmVkIGJ5IHRoZSBSUEMgcHJvdmlkZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBzdWJtaXRTaWduZWRUcmFuc2FjdGlvbkFzeW5jKHNpZ25lZFRyYW5zYWN0aW9uOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZXRoZXJzUHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKTtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuaGFzaDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0QWNjb3VudEJhbGFuY2VBc3luYyhhY2NvdW50QWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxCaWdOdW1iZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXRoZXJzUHJvdmlkZXIuZ2V0QmFsYW5jZShhY2NvdW50QWRkcmVzcykudGhlbigocikgPT4gdG9CaWdOdW1iZXIocikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgYSB3b3JrZXIgaXMgcmVhZHkgdG8gcGljayB1cCBhIG5ldyBqb2I6XHJcbiAgICAgKiAtIHRoZSB3b3JrZXIgaGFzIGVub3VnaCBiYWxhbmNlXHJcbiAgICAgKiAtIHRoZSB3b3JrZXIgaGFzIG5vIHBlbmRpbmcgdHJhbnNhY3Rpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNoYWluSWQgSWQgb2YgdGhlIGNoYWluLlxyXG4gICAgICogQHBhcmFtIHdvcmtlckFkZHJlc3MgQWRkcmVzcyBvZiB0aGUgd29ya2VyIHRvIGNoZWNrLlxyXG4gICAgICogQHBhcmFtIGJhbGFuY2UgQmFsYW5jZSBvZiB0aGUgd29ya2VyIHRvIGNoZWNrLlxyXG4gICAgICogQHBhcmFtIGdhc1ByaWNlIEN1cnJlbnQgZ2FzIHByaWNlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBhIHdvcmtlciBpcyByZWFkeSB0byBwaWNrIHVwIGEgbmV3IGpvYiBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgaXNXb3JrZXJSZWFkeUFzeW5jKFxyXG4gICAgICAgIGNoYWluSWQ6IENoYWluSWQsXHJcbiAgICAgICAgd29ya2VyQWRkcmVzczogc3RyaW5nLFxyXG4gICAgICAgIGJhbGFuY2U6IEJpZ051bWJlcixcclxuICAgICAgICBnYXNQcmljZTogQmlnTnVtYmVyLFxyXG4gICAgKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAgICAgbGV0IGdhc0VzdGltYXRlO1xyXG4gICAgICAgIHN3aXRjaCAoY2hhaW5JZCkge1xyXG4gICAgICAgICAgICBjYXNlIENoYWluSWQuUG9seWdvbjpcclxuICAgICAgICAgICAgICAgIGdhc0VzdGltYXRlID0gWkVST0dfTUVUQVRYX0dBU19FU1RJTUFURTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgZ2FzRXN0aW1hdGUgPSBSRlFNX1RYX0dBU19FU1RJTUFURTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGlzV29ya2VyUmVhZHlBbmRBYmxlQXN5bmModGhpcy5fZXRoZXJzUHJvdmlkZXIsIHdvcmtlckFkZHJlc3MsIGJhbGFuY2UsIGdhc1ByaWNlLCBnYXNFc3RpbWF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIEAweC93ZWIzLXdyYXBwZXIgYFR4RGF0YWAgb2JqZWN0IGludG8gYW4gRXRoZXJzIGBUcmFuc2FjdGlvblJlcXVlc3RgLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSBgZnJvbWAgYWRkcmVzcyBpcyBub3QgcHJlc2VudCBpbiB0aGUgYFR4RGF0YWAsIHRoZSBmdW5jdGlvbiB1c2VzIHRoZSBhZGRyZXNzXHJcbiAgICAgKiBvZiB0aGUgRXRoZXJzIFdhbGxldCBwYXNzZWQgdG8gYHJmcUJsb2NrY2hhaW5VdGlsc2BcclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGUgYHRvYCBhZGRyZXNzIGlzIG5vdCBwcmVzZW50LCB0aGUgZnVuY3Rpb24gdXNlcyB0aGUgZXhjaGFuZ2UgcHJveHkgYWRkcmVzcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zZm9ybVR4RGF0YVRvVHJhbnNhY3Rpb25SZXF1ZXN0KFxyXG4gICAgICAgIHR4T3B0aW9uczogUGFydGlhbDxUeERhdGE+LFxyXG4gICAgICAgIGNoYWluSWQ/OiBDaGFpbklkLFxyXG4gICAgICAgIGNhbGxEYXRhPzogdXRpbHMuQnl0ZXNMaWtlLFxyXG4gICAgKTogcHJvdmlkZXJzLlRyYW5zYWN0aW9uUmVxdWVzdCB7XHJcbiAgICAgICAgY29uc3QgYmFzZVJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIGNoYWluSWQsXHJcbiAgICAgICAgICAgIGRhdGE6IGNhbGxEYXRhLFxyXG4gICAgICAgICAgICBmcm9tOiB0eE9wdGlvbnMuZnJvbSxcclxuICAgICAgICAgICAgLy8gd2ViM3dyYXBwZXJzIFwiZ2FzXCIgZmllbGQgLT4gZXRoZXJzIFwiZ2FzTGltaXRcIiBmaWVsZFxyXG4gICAgICAgICAgICBnYXNMaW1pdDogdHhPcHRpb25zLmdhcyBpbnN0YW5jZW9mIEJpZ051bWJlciA/IEJpZ0ludCh0eE9wdGlvbnMuZ2FzLnRvU3RyaW5nKCkpIDogdHhPcHRpb25zLmdhcyxcclxuICAgICAgICAgICAgbm9uY2U6IHR4T3B0aW9ucy5ub25jZSxcclxuICAgICAgICAgICAgdG86IHR4T3B0aW9ucy50byB8fCB0aGlzLl9leGNoYW5nZVByb3h5LmFkZHJlc3MsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0eE9wdGlvbnMudmFsdWUgaW5zdGFuY2VvZiBCaWdOdW1iZXIgPyB0eE9wdGlvbnMudmFsdWUudG9TdHJpbmcoKSA6IHR4T3B0aW9ucy52YWx1ZSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBIYW5kbGUgVHlwZSAwIChMZWdhY3kpIFR4XHJcbiAgICAgICAgaWYgKHR4T3B0aW9ucy5nYXNQcmljZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLi4uYmFzZVJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAwLFxyXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6IHR4T3B0aW9ucy5nYXNQcmljZSBpbnN0YW5jZW9mIEJpZ051bWJlciA/IHR4T3B0aW9ucy5nYXNQcmljZS50b1N0cmluZygpIDogdHhPcHRpb25zLmdhc1ByaWNlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIFR5cGUgMiAoRUlQLTE1NTkpIFR4XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uYmFzZVJlcXVlc3QsXHJcbiAgICAgICAgICAgIHR5cGU6IDIsXHJcbiAgICAgICAgICAgIG1heEZlZVBlckdhczpcclxuICAgICAgICAgICAgICAgIHR4T3B0aW9ucy5tYXhGZWVQZXJHYXMgaW5zdGFuY2VvZiBCaWdOdW1iZXJcclxuICAgICAgICAgICAgICAgICAgICA/IEJpZ0ludCh0eE9wdGlvbnMubWF4RmVlUGVyR2FzLnRvU3RyaW5nKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0eE9wdGlvbnMubWF4RmVlUGVyR2FzLFxyXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczpcclxuICAgICAgICAgICAgICAgIHR4T3B0aW9ucy5tYXhQcmlvcml0eUZlZVBlckdhcyBpbnN0YW5jZW9mIEJpZ051bWJlclxyXG4gICAgICAgICAgICAgICAgICAgID8gQmlnSW50KHR4T3B0aW9ucy5tYXhQcmlvcml0eUZlZVBlckdhcy50b1N0cmluZygpKVxyXG4gICAgICAgICAgICAgICAgICAgIDogdHhPcHRpb25zLm1heFByaW9yaXR5RmVlUGVyR2FzLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VzIHRoZSBFdGhlcnMgV2FsbGV0IHRvIHNpZ24gYSB0cmFuc2FjdGlvbi4gUmV0dXJucyBib3RoIHRoZSBzaWduZWQgdHJhbnNhY3Rpb24gYW5kIGl0cyBoYXNoLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSBjb250YWluaW5nIGNsYXNzIGhhcyBiZWVuIGluaXRpYWxpemVkIHdpdGhvdXQgYSB3YWxsZXQsIHRoZSBmdW5jdGlvbiB0aHJvd3MuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBzaWduVHJhbnNhY3Rpb25Bc3luYyhcclxuICAgICAgICB0cmFuc2FjdGlvbjogcHJvdmlkZXJzLlRyYW5zYWN0aW9uUmVxdWVzdCxcclxuICAgICk6IFByb21pc2U8eyBzaWduZWRUcmFuc2FjdGlvbjogc3RyaW5nOyB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyB9PiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9ldGhlcnNXYWxsZXQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgJ1JGUSBCbG9ja2NoYWluIFV0aWxzIG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBFdGhlcnMgV2FsbGV0IGluIG9yZGVyIHRvIGdldCB0cmFuc2FjdGlvbiBoYXNoZXMgYmVmb3JlIHN1Ym1pdHRpbmcnLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY2hlY2tlZFJlcXVlc3QgPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh0aGlzLl9ldGhlcnNXYWxsZXQuY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpO1xyXG4gICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5fZXRoZXJzV2FsbGV0LnNpZ25UcmFuc2FjdGlvbihjaGVja2VkUmVxdWVzdCk7XHJcbiAgICAgICAgY29uc3QgaGFzaCA9IHV0aWxzLmtlY2NhazI1NihzaWduZWRUcmFuc2FjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHsgc2lnbmVkVHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uSGFzaDogaGFzaCB9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRUb2tlbkRlY2ltYWxzQXN5bmModG9rZW5BZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgICAgIGNvbnN0IGVyYzIwQWJpRGVjaW1hbHMgPSBgW3tcclxuICAgICAgICAgICAgXCJjb25zdGFudFwiOiB0cnVlLFxyXG4gICAgICAgICAgICBcImlucHV0c1wiOiBbXSxcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGVjaW1hbHNcIixcclxuICAgICAgICAgICAgXCJvdXRwdXRzXCI6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1aW50OFwiXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFwicGF5YWJsZVwiOiBmYWxzZSxcclxuICAgICAgICAgICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJ2aWV3XCIsXHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcclxuICAgICAgICB9XWA7XHJcbiAgICAgICAgY29uc3QgdG9rZW5Db250cmFjdCA9IG5ldyBDb250cmFjdCh0b2tlbkFkZHJlc3MsIGVyYzIwQWJpRGVjaW1hbHMsIHRoaXMuX2V0aGVyc1Byb3ZpZGVyKTtcclxuICAgICAgICBjb25zdCBkZWNpbWFscyA9IGF3YWl0IHRva2VuQ29udHJhY3QuZGVjaW1hbHMoKTtcclxuICAgICAgICBpZiAodHlwZW9mIGRlY2ltYWxzICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2ltYWxzIHdhcyBub3QgYSBudW1iZXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlY2ltYWxzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbHMgdGhlIDB4IEV4Y2hhbmdlIFByb3h5IHRvIGFkZCBhbiBhZGRyZXNzIHRvIHRoZSBsaXN0IG9mIGFsbG93ZWQgb3JkZXIgc2lnbmVycyBmb3IgdGhlIG1zZydzIHNlbmRlci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIHJlZ2lzdGVyQWxsb3dlZE9yZGVyU2lnbmVyQXN5bmMoXHJcbiAgICAgICAgZnJvbTogc3RyaW5nLFxyXG4gICAgICAgIHNpZ25lckFkZHJlc3M6IHN0cmluZyxcclxuICAgICAgICBpc0FsbG93ZWQ6IGJvb2xlYW4sXHJcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGF3YWl0LXByb21pc2VcclxuICAgICAgICBhd2FpdCB0aGlzLl9leGNoYW5nZVByb3h5XHJcbiAgICAgICAgICAgIC5yZWdpc3RlckFsbG93ZWRPcmRlclNpZ25lcihzaWduZXJBZGRyZXNzLCBpc0FsbG93ZWQpXHJcbiAgICAgICAgICAgIC5hd2FpdFRyYW5zYWN0aW9uU3VjY2Vzc0FzeW5jKHsgZnJvbSB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgc2lnbmVyIGFkZHJlc3MgaXMgYW4gYWxsb3dlZCBvcmRlciBzaWduZXIgb2YgdGhlIG1ha2VyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgaXNWYWxpZE9yZGVyU2lnbmVyQXN5bmMobWFrZXJBZGRyZXNzOiBzdHJpbmcsIHNpZ25lckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9leGNoYW5nZVByb3h5LmlzVmFsaWRPcmRlclNpZ25lcihtYWtlckFkZHJlc3MsIHNpZ25lckFkZHJlc3MpLmNhbGxBc3luYygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBnYXNsZXNzIGFwcHJvdmFsIG9iamVjdCB3aGljaCBlbmNhcHN1bGF0ZXMgdGhlIEVJUC03MTIgY29udGV4dCB0aGF0IHdvdWxkIGJlIHNpZ25lZCBieSB0aGUgYHRha2VyQWRkcmVzc2BcclxuICAgICAqIGZvciBnYXNsZXNzIGFwcHJvdmFsLiBUaGUgdHdvIG1haW4gc2NoZW1lcyBmb3IgZ2FzbGVzcyBhcHByb3ZhbHMgYXJlIGBleGVjdXRlTWV0YVRyYW5zYWN0aW9uYCBhbmQgYHBlcm1pdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNoYWluSWQgSWQgb2YgdGhlIGNoYWluLlxyXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSBhZGRyZXNzIG9mIHRoZSB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB0YWtlckFkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhlIHRha2VyLlxyXG4gICAgICogQHBhcmFtIG5vd01zIG9wdGlvbmFsIC0gdGhlIGN1cnJlbnQgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICogQHJldHVybnMgVGhlIGNvcnJlc3BvbmRpbmcgZ2FzbGVzcyBhcHByb3ZhbCBvamVjdCBvciBudWxsIGlmIHRoZSB0b2tlbiBkb2VzIG5vdCBzdXBwb3J0IGdhc2xlc3MgYXBwcm92YWwgKGRvZXMgbm90IGV4aXN0IGluIG91ciBFSVAtNzEyIHRva2VuIHJlZ2lzdHJ5KS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldEdhc2xlc3NBcHByb3ZhbEFzeW5jKFxyXG4gICAgICAgIGNoYWluSWQ6IG51bWJlcixcclxuICAgICAgICB0b2tlbjogc3RyaW5nLFxyXG4gICAgICAgIHRha2VyQWRkcmVzczogc3RyaW5nLFxyXG4gICAgICAgIG5vd01zOiBudW1iZXIgPSBEYXRlLm5vdygpLFxyXG4gICAgKTogUHJvbWlzZTxBcHByb3ZhbCB8IG51bGw+IHtcclxuICAgICAgICAvLyBJZiB0aGUgdG9rZW4gZG9lcyBub3QgZXhpc3QgaW4gdGhlIHRva2VuIHJlZ2lzdHJ5LCByZXR1cm4gbnVsbFxyXG4gICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXHJcbiAgICAgICAgaWYgKCFFSVBfNzEyX1JFR0lTVFJZLmhhc093blByb3BlcnR5KGNoYWluSWQpIHx8ICFFSVBfNzEyX1JFR0lTVFJZW2NoYWluSWRdLmhhc093blByb3BlcnR5KHRva2VuKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRva2VuRUlQNzEyID0gRUlQXzcxMl9SRUdJU1RSWVtjaGFpbklkXVt0b2tlbl07XHJcbiAgICAgICAgY29uc3QgZWlwNzEyRG9tYWluVHlwZSA9IGV4dHJhY3RFSVA3MTJEb21haW5UeXBlKHRva2VuRUlQNzEyLmRvbWFpbik7XHJcbiAgICAgICAgc3dpdGNoICh0b2tlbkVJUDcxMi5raW5kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgR2FzbGVzc0FwcHJvdmFsVHlwZXMuRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCB0aGlzLmdldE1ldGFUcmFuc2FjdGlvbk5vbmNlQXN5bmModG9rZW4sIHRha2VyQWRkcmVzcyk7XHJcbiAgICAgICAgICAgICAgICAvLyBnZW5lcmF0ZSBjYWxsZGF0YSBmb3IgYXBwcm92ZSB3aXRoIG1heCBudW1iZXIgb2YgdWludDI1NiBhcyBhbW91bnRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVyYzIwID0gbmV3IENvbnRyYWN0KHRva2VuLCBhYmlzLnBvbHlnb25CcmlkZ2VkRVJDMjAsIHRoaXMuX2V0aGVyc1Byb3ZpZGVyKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogYXBwcm92ZUNhbGxkYXRhIH0gPSBhd2FpdCBlcmMyMC5wb3B1bGF0ZVRyYW5zYWN0aW9uLmFwcHJvdmUoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhjaGFuZ2VQcm94eUFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzLk1heFVpbnQyNTYsXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25BcHByb3ZhbDogRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkFwcHJvdmFsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdhc2xlc3NBcHByb3ZhbFR5cGVzLkV4ZWN1dGVNZXRhVHJhbnNhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgZWlwNzEyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5laXA3MTJEb21haW5UeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uRVhFQ1VURV9NRVRBX1RSQU5TQUNUSU9OX0VJUF83MTJfVFlQRVMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUeXBlOiAnTWV0YVRyYW5zYWN0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiB0b2tlbkVJUDcxMi5kb21haW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbmNlOiBub25jZS50b051bWJlcigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogdGFrZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uU2lnbmF0dXJlOiBhcHByb3ZlQ2FsbGRhdGEhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBleGVjdXRlTWV0YVRyYW5zYWN0aW9uQXBwcm92YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBHYXNsZXNzQXBwcm92YWxUeXBlcy5QZXJtaXQ6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgdGhpcy5nZXRQZXJtaXROb25jZUFzeW5jKHRva2VuLCB0YWtlckFkZHJlc3MpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGVuTWludXRlc0FmdGVyTm93UyA9IG5ldyBCaWdOdW1iZXIobm93TXMgKyBPTkVfTUlOVVRFX01TICogMTApLmRpdihPTkVfU0VDT05EX01TKS5pbnRlZ2VyVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBlcm1pdEFwcHJvdmFsOiBQZXJtaXRBcHByb3ZhbCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBraW5kOiBHYXNsZXNzQXBwcm92YWxUeXBlcy5QZXJtaXQsXHJcbiAgICAgICAgICAgICAgICAgICAgZWlwNzEyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5laXA3MTJEb21haW5UeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uUEVSTUlUX0VJUF83MTJfVFlQRVMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUeXBlOiAnUGVybWl0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiB0b2tlbkVJUDcxMi5kb21haW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB0YWtlckFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVuZGVyOiB0aGlzLl9leGNoYW5nZVByb3h5QWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb25zdGFudHMuTWF4VWludDI1Ni50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uY2U6IG5vbmNlLnRvTnVtYmVyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWFkbGluZTogdGVuTWludXRlc0FmdGVyTm93Uy50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBwZXJtaXRBcHByb3ZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHYXNsZXNzIGFwcHJvdmFsIGtpbmQgJHt0b2tlbkVJUDcxMi5raW5kfSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBhbW91bnQgKGluIGJhc2UgdW5pdCkgb2YgYHRva2VuYCBgc3BlbmRlcmAgd2lsbCBiZSBhbGxvd2VkIHRvIHNwZW5kIG9uIGJlaGFsZiBvbiBgb3duZXJgICh0aGUgYWxsb3dhbmNlKS4gTm90ZSB0aGF0XHJcbiAgICAgKiBiYXNlIHVuaXQgbWVhbnMgMTAgKiogZGVjaW1hbHMgKGRlY2ltYWxzIG9mIHRoZSB0b2tlbikuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSBhZGRyZXNzIG9mIHRoZSB0b2tlbi5cclxuICAgICAqIEBwYXJhbSBvd25lciBUaGUgYWRkcmVzcyB0aGF0IG93bnMgY2VydGFpbiBhbW91bnQgb2YgYHRva2VuYC5cclxuICAgICAqIEBwYXJhbSBzcGVuZGVyIFRoZSBhZGRyZXNzIHRoYXQgd291bGQgbGlrZSB0byBzcGVuZCB0b2tlbiBvbiBiZWhhbGYgb2YgYG93bmVyYC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBhbW91bnQgKGluIGJhc2UgdW5pdCkgb2YgdG9rZW5zIHNwZW5kZXIgaXMgYWxsb3dlZCB0byBzcGVuZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldEFsbG93YW5jZUFzeW5jKHRva2VuOiBzdHJpbmcsIG93bmVyOiBzdHJpbmcsIHNwZW5kZXI6IHN0cmluZyk6IFByb21pc2U8QmlnTnVtYmVyPiB7XHJcbiAgICAgICAgY29uc3QgZXJjMjAgPSBuZXcgQ29udHJhY3QodG9rZW4sIGFiaXMucG9seWdvbkJyaWRnZWRFUkMyMCwgdGhpcy5fZXRoZXJzUHJvdmlkZXIpO1xyXG4gICAgICAgIGNvbnN0IGFsbG93YW5jZSA9IGF3YWl0IGVyYzIwLmFsbG93YW5jZShvd25lciwgc3BlbmRlcik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYWxsb3dhbmNlLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG5vbmNlIGZvciBtZXRhIHRyYW5zYWN0aW9uLiBUaGlzIGlzIHVzZWQgYnkgY29udHJhY3RzIHRoYXQgc3VwcG9ydCBCaWNvbm9teSdzIGBleGVjdXRlTWV0YVRyYW5zYWN0aW9uYCB3aGljaCBpbmNsdWRlcyBicmlkZ2VkIHRva2VucyBvbiBQb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0b2tlbiBUaGUgYWRkcmVzcyBvZiB0aGUgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0gdGFrZXJBZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoZSB0YWtlci5cclxuICAgICAqIEByZXR1cm5zIE5vbmNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWV0YVRyYW5zYWN0aW9uTm9uY2VBc3luYyh0b2tlbjogc3RyaW5nLCB0YWtlckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8QmlnTnVtYmVyPiB7XHJcbiAgICAgICAgY29uc3QgZXJjMjAgPSBuZXcgQ29udHJhY3QodG9rZW4sIGFiaXMucG9seWdvbkJyaWRnZWRFUkMyMCwgdGhpcy5fZXRoZXJzUHJvdmlkZXIpO1xyXG4gICAgICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgZXJjMjAuZ2V0Tm9uY2UodGFrZXJBZGRyZXNzKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihub25jZS50b1N0cmluZygpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBwZXJtaXQgbm9uY2UsIHdoaWNoIGlzIHVzZWQgYnkgY29udHJhY3RzIHRoYXQgc3VwcG9ydCBFSVAtMjYxMiBzdGFuZGFyZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSBhZGRyZXNzIG9mIHRoZSB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB0YWtlckFkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhlIHRha2VyLlxyXG4gICAgICogQHJldHVybnMgTm9uY2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRQZXJtaXROb25jZUFzeW5jKHRva2VuOiBzdHJpbmcsIHRha2VyQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxCaWdOdW1iZXI+IHtcclxuICAgICAgICBjb25zdCBlcmMyMCA9IG5ldyBDb250cmFjdCh0b2tlbiwgYWJpcy5wZXJtaXRFUkMyMCwgdGhpcy5fZXRoZXJzUHJvdmlkZXIpO1xyXG4gICAgICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgZXJjMjAubm9uY2VzKHRha2VyQWRkcmVzcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobm9uY2UudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgY2FsbGRhdGEgZm9yIGdhc2xlc3MgYXBwcm92YWwgc3VibWlzc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdG9rZW4gVGhlIGFkZHJlc3Mgb2YgdGhlIHRva2VuLlxyXG4gICAgICogQHBhcmFtIGFwcHJvdmFsIFRoZSBBcHByb3ZhbCBvYmplY3QsIHdoaWNoIGNvbnNpc3RzIG9mICdraW5kJyBhbmQgZWlwNzEyIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBzaWduYXR1cmUgVGhlIGdhc2xlc3MgYXBwcm92YWwgdHJhbnNhY3Rpb24gc2lnbmVkIGJ5IHRha2VyLlxyXG4gICAgICogQHJldHVybnMgR2VuZXJhdGVkIGNhbGxkYXRhLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2VuZXJhdGVBcHByb3ZhbENhbGxkYXRhQXN5bmMoXHJcbiAgICAgICAgdG9rZW46IHN0cmluZyxcclxuICAgICAgICBhcHByb3ZhbDogQXBwcm92YWwsXHJcbiAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmUsXHJcbiAgICApOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIGNvbnN0IHsga2luZCwgZWlwNzEyIH0gPSBhcHByb3ZhbDtcclxuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcclxuICAgICAgICAgICAgY2FzZSBHYXNsZXNzQXBwcm92YWxUeXBlcy5FeGVjdXRlTWV0YVRyYW5zYWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcmMyMCA9IG5ldyBDb250cmFjdCh0b2tlbiwgYWJpcy5wb2x5Z29uQnJpZGdlZEVSQzIwLCB0aGlzLl9ldGhlcnNQcm92aWRlcik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGVyYzIwLnBvcHVsYXRlVHJhbnNhY3Rpb24uZXhlY3V0ZU1ldGFUcmFuc2FjdGlvbihcclxuICAgICAgICAgICAgICAgICAgICBlaXA3MTIubWVzc2FnZS5mcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgIGVpcDcxMi5tZXNzYWdlLmZ1bmN0aW9uU2lnbmF0dXJlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZS5yLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZS5zLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZS52LFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGdlbmVyYXRlIGFwcHJvdmFsIHN1Ym1pc3Npb24gY2FsbGRhdGEgZm9yICR7a2luZH1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgR2FzbGVzc0FwcHJvdmFsVHlwZXMuUGVybWl0OiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcmMyMCA9IG5ldyBDb250cmFjdCh0b2tlbiwgYWJpcy5wZXJtaXRFUkMyMCwgdGhpcy5fZXRoZXJzUHJvdmlkZXIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBlcmMyMC5wb3B1bGF0ZVRyYW5zYWN0aW9uLnBlcm1pdChcclxuICAgICAgICAgICAgICAgICAgICBlaXA3MTIubWVzc2FnZS5vd25lcixcclxuICAgICAgICAgICAgICAgICAgICBlaXA3MTIubWVzc2FnZS5zcGVuZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGVpcDcxMi5tZXNzYWdlLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGVpcDcxMi5tZXNzYWdlLmRlYWRsaW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZS52LFxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZS5yLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZS5zLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGdlbmVyYXRlIGFwcHJvdmFsIHN1Ym1pc3Npb24gY2FsbGRhdGEgZm9yICR7a2luZH1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdhc2xlc3MgYXBwcm92YWwga2luZCAke2tpbmR9IGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXRgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBSZnFCYWxhbmNlQ2hlY2tVdGlscyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IF9iYWxhbmNlQ2hlY2tlcjogQmFsYW5jZUNoZWNrZXIsIHByaXZhdGUgcmVhZG9ubHkgX2V4Y2hhbmdlUHJveHlBZGRyZXNzOiBzdHJpbmcpIHt9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaGVzIG1pbiB2YWx1ZSBiZXR3ZWVuIGJhbGFuY2UgZm9yIGEgbGlzdCBvZiBhZGRyZXNzZXMgYWdhaW5zdCB0aGUgc3BlY2lmaWVkIHRva2Vucy4gVGhlIGluZGV4IG9mXHJcbiAgICAgKiBhbiBhZGRyZXNzIGluIGBhZGRyZXNzZXNgIG11c3QgY29ycmVzcG9uZCB3aXRoIHRoZSBpbmRleCBvZiBhIHRva2VuIGluIGB0b2tlbnNgLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWluT2ZCYWxhbmNlc0FuZEFsbG93YW5jZXNBc3luYyhlcmMyME93bmVyczogRVJDMjBPd25lciB8IEVSQzIwT3duZXJbXSk6IFByb21pc2U8QmlnTnVtYmVyW10+IHtcclxuICAgICAgICBjb25zdCB7IG93bmVycywgdG9rZW5zIH0gPSBzcGxpdEFkZHJlc3NlcyhlcmMyME93bmVycyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhbGFuY2VDaGVja2VyLmdldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMob3duZXJzLCB0b2tlbnMsIHRoaXMuX2V4Y2hhbmdlUHJveHlBZGRyZXNzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoZXMgdGhlIGJhbGFuY2VzIGZvciBhIGxpc3Qgb2YgYWRkcmVzc2VzIGFnYWluc3QgdGhlIHNwZWNpZmllZCB0b2tlbnMuIFRoZSBpbmRleCBvZlxyXG4gICAgICogYW4gYWRkcmVzcyBpbiBgYWRkcmVzc2VzYCBtdXN0IGNvcnJlc3BvbmQgd2l0aCB0aGUgaW5kZXggb2YgYSB0b2tlbiBpbiBgdG9rZW5zYC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldFRva2VuQmFsYW5jZXNBc3luYyhlcmMyME93bmVyczogRVJDMjBPd25lciB8IEVSQzIwT3duZXJbXSk6IFByb21pc2U8QmlnTnVtYmVyW10+IHtcclxuICAgICAgICBjb25zdCB7IG93bmVycywgdG9rZW5zIH0gPSBzcGxpdEFkZHJlc3NlcyhlcmMyME93bmVycyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhbGFuY2VDaGVja2VyLmdldFRva2VuQmFsYW5jZXNBc3luYyhvd25lcnMsIHRva2Vucyk7XHJcbiAgICB9XHJcbn1cclxuIl0sInZlcnNpb24iOjN9