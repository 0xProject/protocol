131196297559b58bd6ff0dedebce6ba5
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderEventEndState = exports.GaslessApprovalTypes = exports.GaslessTypes = void 0;
var GaslessTypes;
(function (GaslessTypes) {
    GaslessTypes["MetaTransaction"] = "metatransaction";
    GaslessTypes["MetaTransactionV2"] = "metatransactionV2";
    GaslessTypes["OtcOrder"] = "otc";
})(GaslessTypes = exports.GaslessTypes || (exports.GaslessTypes = {}));
/**
 * Approval is an object that encapsulates the EIP-712 context that will eventually be signed by takers
 * for gasless approvals. There are multiple flavors of these approval objects, which can be distinguished
 * by their `kind`
 */
var GaslessApprovalTypes;
(function (GaslessApprovalTypes) {
    GaslessApprovalTypes["ExecuteMetaTransaction"] = "executeMetaTransaction::approve";
    GaslessApprovalTypes["Permit"] = "permit";
    GaslessApprovalTypes["DaiPermit"] = "daiPermit";
})(GaslessApprovalTypes = exports.GaslessApprovalTypes || (exports.GaslessApprovalTypes = {}));
var OrderEventEndState;
(function (OrderEventEndState) {
    // The order was successfully validated and added to the Mesh node. The order is now being watched and any changes to
    // the fillability will result in subsequent order events.
    OrderEventEndState["Added"] = "ADDED";
    // The order was filled for a partial amount. The order is still fillable up to the fillableTakerAssetAmount.
    OrderEventEndState["Filled"] = "FILLED";
    // The order was fully filled and its remaining fillableTakerAssetAmount is 0. The order is no longer fillable.
    OrderEventEndState["FullyFilled"] = "FULLY_FILLED";
    // The order was cancelled and is no longer fillable.
    OrderEventEndState["Cancelled"] = "CANCELLED";
    // The order expired and is no longer fillable.
    OrderEventEndState["Expired"] = "EXPIRED";
    // Catch all 'Invalid' state when invalid orders are submitted.
    OrderEventEndState["Invalid"] = "INVALID";
    // The order was previously expired, but due to a block re-org it is no longer considered expired (should be rare).
    OrderEventEndState["Unexpired"] = "UNEXPIRED";
    // The order has become unfunded and is no longer fillable. This can happen if the maker makes a transfer or changes their allowance.
    OrderEventEndState["Unfunded"] = "UNFUNDED";
    // The fillability of the order has increased. This can happen if a previously processed fill event gets reverted due to a block re-org,
    // or if a maker makes a transfer or changes their allowance.
    OrderEventEndState["FillabilityIncreased"] = "FILLABILITY_INCREASED";
    // The order is potentially still valid but was removed for a different reason (e.g.
    // the database is full or the peer that sent the order was misbehaving). The order will no longer be watched
    // and no further events for this order will be emitted. In some cases, the order may be re-added in the
    // future.
    OrderEventEndState["StoppedWatching"] = "STOPPED_WATCHING";
})(OrderEventEndState = exports.OrderEventEndState || (exports.OrderEventEndState = {}));
__exportStar(require("./fees"), exports);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9jb3JlL3R5cGVzL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NBLElBQVksWUFJWDtBQUpELFdBQVksWUFBWTtJQUNwQixtREFBbUMsQ0FBQTtJQUNuQyx1REFBdUMsQ0FBQTtJQUN2QyxnQ0FBZ0IsQ0FBQTtBQUNwQixDQUFDLEVBSlcsWUFBWSxHQUFaLG9CQUFZLEtBQVosb0JBQVksUUFJdkI7QUFFRDs7OztHQUlHO0FBQ0gsSUFBWSxvQkFJWDtBQUpELFdBQVksb0JBQW9CO0lBQzVCLGtGQUEwRCxDQUFBO0lBQzFELHlDQUFpQixDQUFBO0lBQ2pCLCtDQUF1QixDQUFBO0FBQzNCLENBQUMsRUFKVyxvQkFBb0IsR0FBcEIsNEJBQW9CLEtBQXBCLDRCQUFvQixRQUkvQjtBQW9JRCxJQUFZLGtCQTBCWDtBQTFCRCxXQUFZLGtCQUFrQjtJQUMxQixxSEFBcUg7SUFDckgsMERBQTBEO0lBQzFELHFDQUFlLENBQUE7SUFDZiw2R0FBNkc7SUFDN0csdUNBQWlCLENBQUE7SUFDakIsK0dBQStHO0lBQy9HLGtEQUE0QixDQUFBO0lBQzVCLHFEQUFxRDtJQUNyRCw2Q0FBdUIsQ0FBQTtJQUN2QiwrQ0FBK0M7SUFDL0MseUNBQW1CLENBQUE7SUFDbkIsK0RBQStEO0lBQy9ELHlDQUFtQixDQUFBO0lBQ25CLG1IQUFtSDtJQUNuSCw2Q0FBdUIsQ0FBQTtJQUN2QixxSUFBcUk7SUFDckksMkNBQXFCLENBQUE7SUFDckIsd0lBQXdJO0lBQ3hJLDZEQUE2RDtJQUM3RCxvRUFBOEMsQ0FBQTtJQUM5QyxvRkFBb0Y7SUFDcEYsNkdBQTZHO0lBQzdHLHdHQUF3RztJQUN4RyxVQUFVO0lBQ1YsMERBQW9DLENBQUE7QUFDeEMsQ0FBQyxFQTFCVyxrQkFBa0IsR0FBbEIsMEJBQWtCLEtBQWxCLDBCQUFrQixRQTBCN0I7QUFFRCx5Q0FBdUIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9jb3JlL3R5cGVzL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE90Y09yZGVyLCBTaWduYXR1cmUgfSBmcm9tICdAMHgvcHJvdG9jb2wtdXRpbHMnO1xyXG5pbXBvcnQgeyBNYXJrZXRPcGVyYXRpb24gfSBmcm9tICdAMHgvdHlwZXMnO1xyXG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdAMHgvdXRpbHMnO1xyXG5cclxuZXhwb3J0IHR5cGUgUmVxdWlyZU9ubHlPbmU8VCwgS2V5cyBleHRlbmRzIGtleW9mIFQgPSBrZXlvZiBUPiA9IFBpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLZXlzPj4gJlxyXG4gICAge1xyXG4gICAgICAgIFtLIGluIEtleXNdLT86IFJlcXVpcmVkPFBpY2s8VCwgSz4+ICYgUGFydGlhbDxSZWNvcmQ8RXhjbHVkZTxLZXlzLCBLPiwgdW5kZWZpbmVkPj47XHJcbiAgICB9W0tleXNdO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJbmRpY2F0aXZlUXVvdGUge1xyXG4gICAgbWFrZXI6IHN0cmluZztcclxuICAgIG1ha2VyVXJpOiBzdHJpbmc7XHJcbiAgICBtYWtlclRva2VuOiBzdHJpbmc7XHJcbiAgICB0YWtlclRva2VuOiBzdHJpbmc7XHJcbiAgICBtYWtlckFtb3VudDogQmlnTnVtYmVyO1xyXG4gICAgdGFrZXJBbW91bnQ6IEJpZ051bWJlcjtcclxuICAgIGV4cGlyeTogQmlnTnVtYmVyO1xyXG59XHJcblxyXG4vKipcclxuICogRmlybU90Y1F1b3RlIGlzIGEgcXVvdGUgZm9yIGFuIE90Y09yZGVyLiBUaGUgbWFrZXJTaWduYXR1cmUgbWF5IG5vdCBiZSBwcmVzZW50IGlmIHRoZSBtYWtlciBnZXRzXHJcbiAqIHRoZSBcImxhc3QgbG9va1wiIChSRlFtKS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgRmlybU90Y1F1b3RlIHtcclxuICAgIGtpbmQ6ICdvdGMnO1xyXG4gICAgbWFrZXJVcmk6IHN0cmluZztcclxuICAgIG9yZGVyOiBPdGNPcmRlcjtcclxuICAgIG1ha2VyU2lnbmF0dXJlPzogU2lnbmF0dXJlO1xyXG59XHJcblxyXG4vKipcclxuICogRVJDMjBPd25lciBpcyBhbiBhZGRyZXNzLXRva2VuIHBhaXIgdXNlZCB0byBwZXJmb3JtIGJhbGFuY2UgY2hlY2tzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBFUkMyME93bmVyIHtcclxuICAgIG93bmVyOiBzdHJpbmc7XHJcbiAgICB0b2tlbjogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgZW51bSBHYXNsZXNzVHlwZXMge1xyXG4gICAgTWV0YVRyYW5zYWN0aW9uID0gJ21ldGF0cmFuc2FjdGlvbicsXHJcbiAgICBNZXRhVHJhbnNhY3Rpb25WMiA9ICdtZXRhdHJhbnNhY3Rpb25WMicsXHJcbiAgICBPdGNPcmRlciA9ICdvdGMnLFxyXG59XHJcblxyXG4vKipcclxuICogQXBwcm92YWwgaXMgYW4gb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIHRoZSBFSVAtNzEyIGNvbnRleHQgdGhhdCB3aWxsIGV2ZW50dWFsbHkgYmUgc2lnbmVkIGJ5IHRha2Vyc1xyXG4gKiBmb3IgZ2FzbGVzcyBhcHByb3ZhbHMuIFRoZXJlIGFyZSBtdWx0aXBsZSBmbGF2b3JzIG9mIHRoZXNlIGFwcHJvdmFsIG9iamVjdHMsIHdoaWNoIGNhbiBiZSBkaXN0aW5ndWlzaGVkXHJcbiAqIGJ5IHRoZWlyIGBraW5kYFxyXG4gKi9cclxuZXhwb3J0IGVudW0gR2FzbGVzc0FwcHJvdmFsVHlwZXMge1xyXG4gICAgRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbiA9ICdleGVjdXRlTWV0YVRyYW5zYWN0aW9uOjphcHByb3ZlJyxcclxuICAgIFBlcm1pdCA9ICdwZXJtaXQnLFxyXG4gICAgRGFpUGVybWl0ID0gJ2RhaVBlcm1pdCcsXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEFwcHJvdmFsID0gRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkFwcHJvdmFsIHwgUGVybWl0QXBwcm92YWw7XHJcbmV4cG9ydCBpbnRlcmZhY2UgRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkFwcHJvdmFsIHtcclxuICAgIGtpbmQ6IEdhc2xlc3NBcHByb3ZhbFR5cGVzLkV4ZWN1dGVNZXRhVHJhbnNhY3Rpb247XHJcbiAgICBlaXA3MTI6IEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFBlcm1pdEFwcHJvdmFsIHtcclxuICAgIGtpbmQ6IEdhc2xlc3NBcHByb3ZhbFR5cGVzLlBlcm1pdDtcclxuICAgIGVpcDcxMjogUGVybWl0RWlwNzEyQ29udGV4dDtcclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0IHtcclxuICAgIHR5cGVzOiBFeGVjdXRlTWV0YVRyYW5zYWN0aW9uRWlwNzEyVHlwZXM7XHJcbiAgICBwcmltYXJ5VHlwZTogJ01ldGFUcmFuc2FjdGlvbic7XHJcbiAgICBkb21haW46IEVpcDcxMkRvbWFpbjtcclxuICAgIG1lc3NhZ2U6IHtcclxuICAgICAgICBub25jZTogbnVtYmVyO1xyXG4gICAgICAgIGZyb206IHN0cmluZztcclxuICAgICAgICBmdW5jdGlvblNpZ25hdHVyZTogc3RyaW5nO1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQZXJtaXRFaXA3MTJDb250ZXh0IHtcclxuICAgIHR5cGVzOiBQZXJtaXRFaXA3MTJUeXBlcztcclxuICAgIHByaW1hcnlUeXBlOiAnUGVybWl0JztcclxuICAgIGRvbWFpbjogRWlwNzEyRG9tYWluO1xyXG4gICAgbWVzc2FnZToge1xyXG4gICAgICAgIG93bmVyOiBzdHJpbmc7XHJcbiAgICAgICAgc3BlbmRlcjogc3RyaW5nO1xyXG4gICAgICAgIHZhbHVlOiBzdHJpbmc7XHJcbiAgICAgICAgbm9uY2U6IG51bWJlcjtcclxuICAgICAgICBkZWFkbGluZTogc3RyaW5nO1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFeGVjdXRlTWV0YVRyYW5zYWN0aW9uRWlwNzEyVHlwZXMge1xyXG4gICAgRUlQNzEyRG9tYWluOiBFaXA3MTJEYXRhRmllbGRbXTtcclxuICAgIE1ldGFUcmFuc2FjdGlvbjogRWlwNzEyRGF0YUZpZWxkW107XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBQZXJtaXRFaXA3MTJUeXBlcyB7XHJcbiAgICBFSVA3MTJEb21haW46IEVpcDcxMkRhdGFGaWVsZFtdO1xyXG4gICAgUGVybWl0OiBFaXA3MTJEYXRhRmllbGRbXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFaXA3MTJEb21haW4ge1xyXG4gICAgbmFtZT86IHN0cmluZztcclxuICAgIHZlcnNpb24/OiBzdHJpbmc7XHJcbiAgICBjaGFpbklkPzogbnVtYmVyO1xyXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q/OiBzdHJpbmc7XHJcbiAgICBzYWx0Pzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVpcDcxMkRhdGFGaWVsZCB7XHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICB0eXBlOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJhbWV0ZXJzIGZvciB0aGUgcmVxdWVzdCBmcm9tIDB4IEFQSVxyXG4gKiB0byAweCBSRlEgYXBpIGZvciB0aGUgUkZRdCB2MiBgcHJpY2VzYCBlbmRwb2ludFxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBSZnF0VjJSZXF1ZXN0IHtcclxuICAgIGFzc2V0RmlsbEFtb3VudDogQmlnTnVtYmVyO1xyXG4gICAgY2hhaW5JZDogbnVtYmVyO1xyXG4gICAgZ2FzbGVzcz86IGJvb2xlYW47IC8vIHdoZXRoZXIgb3Igbm90IHRoZSByZXF1ZXN0IGlzIGZvciBnYXNsZXNzIFJGUXRcclxuICAgIGludGVncmF0b3JJZDogc3RyaW5nO1xyXG4gICAgaW50ZW50T25GaWxsaW5nOiBib29sZWFuO1xyXG4gICAgbWFrZXJUb2tlbjogc3RyaW5nO1xyXG4gICAgbWFya2V0T3BlcmF0aW9uOiBNYXJrZXRPcGVyYXRpb247XHJcbiAgICB0YWtlckFkZHJlc3M6IHN0cmluZzsgLy8gZXhwZWN0IHRoaXMgdG8gYmUgTlVMTF9BRERSRVNTXHJcbiAgICB0YWtlclRva2VuOiBzdHJpbmc7XHJcbiAgICB0cmFkZXI/OiBzdHJpbmc7IC8vIHRoaXMgaXMgdGhlIGFjdHVhbCB0cmFkZXIuIE9wdGlvbmFsIG9ubHkgZHVyaW5nIEdhc2xlc3MgUkZRdCByb2xsb3V0LiBJbnRlbnQgaXMgdG8gYmUgcmVxdWlyZWQgaW4gdGhlIGxvbmcgdGVybVxyXG4gICAgdHhPcmlnaW4/OiBzdHJpbmc7IC8vIGV4cGVjdCB0aGlzIHRvIGJlIHRoZSB0YWtlciBhZGRyZXNzLCBleGNlcHQgZm9yIGdhc2xlc3MgUkZRdCB3aGVyZSBpdCB3aWxsIGJlIHRoZSByZWdpc3RyeSwgY2FuIGJlIG1pc3NpbmcgZm9yIC9wcmljZSBidXQgbm90IC9xdW90ZVxyXG59XHJcblxyXG4vKipcclxuICogRm9ybWF0IG9mIHJlc3BvbnNlIHBheWxvYWQgd2hpY2ggaXMgc2VudCB0byAweCBBUElcclxuICogZnJvbSAweCBSRlEgQVBJIGZvciB0aGUgUkZRdCB2MiBgcHJpY2VzYCBlbmRwb2ludFxyXG4gKi9cclxuZXhwb3J0IHR5cGUgUmZxdFYyUHJpY2UgPSB7XHJcbiAgICBleHBpcnk6IEJpZ051bWJlcjtcclxuICAgIG1ha2VyQWRkcmVzczogc3RyaW5nO1xyXG4gICAgbWFrZXJBbW91bnQ6IEJpZ051bWJlcjtcclxuICAgIG1ha2VySWQ6IHN0cmluZztcclxuICAgIG1ha2VyVG9rZW46IHN0cmluZztcclxuICAgIG1ha2VyVXJpOiBzdHJpbmc7XHJcbiAgICB0YWtlckFtb3VudDogQmlnTnVtYmVyO1xyXG4gICAgdGFrZXJUb2tlbjogc3RyaW5nO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCBvZiByZXNwb25zZSBwYXlsb2FkIHdoaWNoIGlzIHNlbnQgdG8gMHggQVBJXHJcbiAqIGZyb20gMHggUkZRIEFQSSBmb3IgdGhlIFJGUXQgdjIgYHF1b3Rlc2AgZW5kcG9pbnRcclxuICovXHJcbmV4cG9ydCB0eXBlIFJmcXRWMlF1b3RlID0ge1xyXG4gICAgZmlsbGFibGVNYWtlckFtb3VudDogQmlnTnVtYmVyO1xyXG4gICAgZmlsbGFibGVUYWtlckFtb3VudDogQmlnTnVtYmVyO1xyXG4gICAgZmlsbGFibGVUYWtlckZlZUFtb3VudDogQmlnTnVtYmVyO1xyXG4gICAgbWFrZXJJZDogc3RyaW5nO1xyXG4gICAgbWFrZXJVcmk6IHN0cmluZztcclxuICAgIG9yZGVyOiBPdGNPcmRlcjtcclxuICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgUXVvdGVTZXJ2ZXJQcmljZVBhcmFtcyA9IFJlcXVpcmVPbmx5T25lPFxyXG4gICAge1xyXG4gICAgICAgIGJ1eUFtb3VudEJhc2VVbml0cz86IHN0cmluZztcclxuICAgICAgICBidXlUb2tlbkFkZHJlc3M6IHN0cmluZztcclxuICAgICAgICBjaGFpbklkPzogc3RyaW5nOyAvLyBUT0RPIC0gbWFrZSB0aGlzIHJlcXVpcmVkIGFmdGVyIHRoZSByb2xsb3V0XHJcbiAgICAgICAgY29tcGFyaXNvblByaWNlPzogc3RyaW5nO1xyXG4gICAgICAgIGZlZUFtb3VudD86IHN0cmluZztcclxuICAgICAgICBmZWVUb2tlbj86IHN0cmluZztcclxuICAgICAgICBmZWVUeXBlPzogc3RyaW5nO1xyXG4gICAgICAgIGlzTGFzdExvb2s/OiBzdHJpbmc7XHJcbiAgICAgICAgaW50ZWdyYXRvcklkPzogc3RyaW5nO1xyXG4gICAgICAgIG5vbmNlPzogc3RyaW5nO1xyXG4gICAgICAgIG5vbmNlQnVja2V0Pzogc3RyaW5nO1xyXG4gICAgICAgIHByb3RvY29sVmVyc2lvbj86IHN0cmluZztcclxuICAgICAgICBzZWxsQW1vdW50QmFzZVVuaXRzPzogc3RyaW5nO1xyXG4gICAgICAgIHNlbGxUb2tlbkFkZHJlc3M6IHN0cmluZztcclxuICAgICAgICB0YWtlckFkZHJlc3M6IHN0cmluZztcclxuICAgICAgICB0eE9yaWdpbj86IHN0cmluZztcclxuICAgIH0sXHJcbiAgICAnc2VsbEFtb3VudEJhc2VVbml0cycgfCAnYnV5QW1vdW50QmFzZVVuaXRzJ1xyXG4+O1xyXG5leHBvcnQgaW50ZXJmYWNlIFRva2VuTWV0YWRhdGEge1xyXG4gICAgc3ltYm9sOiBzdHJpbmc7XHJcbiAgICBkZWNpbWFsczogbnVtYmVyO1xyXG4gICAgdG9rZW5BZGRyZXNzOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIE9yZGVyRXZlbnRFbmRTdGF0ZSB7XHJcbiAgICAvLyBUaGUgb3JkZXIgd2FzIHN1Y2Nlc3NmdWxseSB2YWxpZGF0ZWQgYW5kIGFkZGVkIHRvIHRoZSBNZXNoIG5vZGUuIFRoZSBvcmRlciBpcyBub3cgYmVpbmcgd2F0Y2hlZCBhbmQgYW55IGNoYW5nZXMgdG9cclxuICAgIC8vIHRoZSBmaWxsYWJpbGl0eSB3aWxsIHJlc3VsdCBpbiBzdWJzZXF1ZW50IG9yZGVyIGV2ZW50cy5cclxuICAgIEFkZGVkID0gJ0FEREVEJyxcclxuICAgIC8vIFRoZSBvcmRlciB3YXMgZmlsbGVkIGZvciBhIHBhcnRpYWwgYW1vdW50LiBUaGUgb3JkZXIgaXMgc3RpbGwgZmlsbGFibGUgdXAgdG8gdGhlIGZpbGxhYmxlVGFrZXJBc3NldEFtb3VudC5cclxuICAgIEZpbGxlZCA9ICdGSUxMRUQnLFxyXG4gICAgLy8gVGhlIG9yZGVyIHdhcyBmdWxseSBmaWxsZWQgYW5kIGl0cyByZW1haW5pbmcgZmlsbGFibGVUYWtlckFzc2V0QW1vdW50IGlzIDAuIFRoZSBvcmRlciBpcyBubyBsb25nZXIgZmlsbGFibGUuXHJcbiAgICBGdWxseUZpbGxlZCA9ICdGVUxMWV9GSUxMRUQnLFxyXG4gICAgLy8gVGhlIG9yZGVyIHdhcyBjYW5jZWxsZWQgYW5kIGlzIG5vIGxvbmdlciBmaWxsYWJsZS5cclxuICAgIENhbmNlbGxlZCA9ICdDQU5DRUxMRUQnLFxyXG4gICAgLy8gVGhlIG9yZGVyIGV4cGlyZWQgYW5kIGlzIG5vIGxvbmdlciBmaWxsYWJsZS5cclxuICAgIEV4cGlyZWQgPSAnRVhQSVJFRCcsXHJcbiAgICAvLyBDYXRjaCBhbGwgJ0ludmFsaWQnIHN0YXRlIHdoZW4gaW52YWxpZCBvcmRlcnMgYXJlIHN1Ym1pdHRlZC5cclxuICAgIEludmFsaWQgPSAnSU5WQUxJRCcsXHJcbiAgICAvLyBUaGUgb3JkZXIgd2FzIHByZXZpb3VzbHkgZXhwaXJlZCwgYnV0IGR1ZSB0byBhIGJsb2NrIHJlLW9yZyBpdCBpcyBubyBsb25nZXIgY29uc2lkZXJlZCBleHBpcmVkIChzaG91bGQgYmUgcmFyZSkuXHJcbiAgICBVbmV4cGlyZWQgPSAnVU5FWFBJUkVEJyxcclxuICAgIC8vIFRoZSBvcmRlciBoYXMgYmVjb21lIHVuZnVuZGVkIGFuZCBpcyBubyBsb25nZXIgZmlsbGFibGUuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgbWFrZXIgbWFrZXMgYSB0cmFuc2ZlciBvciBjaGFuZ2VzIHRoZWlyIGFsbG93YW5jZS5cclxuICAgIFVuZnVuZGVkID0gJ1VORlVOREVEJyxcclxuICAgIC8vIFRoZSBmaWxsYWJpbGl0eSBvZiB0aGUgb3JkZXIgaGFzIGluY3JlYXNlZC4gVGhpcyBjYW4gaGFwcGVuIGlmIGEgcHJldmlvdXNseSBwcm9jZXNzZWQgZmlsbCBldmVudCBnZXRzIHJldmVydGVkIGR1ZSB0byBhIGJsb2NrIHJlLW9yZyxcclxuICAgIC8vIG9yIGlmIGEgbWFrZXIgbWFrZXMgYSB0cmFuc2ZlciBvciBjaGFuZ2VzIHRoZWlyIGFsbG93YW5jZS5cclxuICAgIEZpbGxhYmlsaXR5SW5jcmVhc2VkID0gJ0ZJTExBQklMSVRZX0lOQ1JFQVNFRCcsXHJcbiAgICAvLyBUaGUgb3JkZXIgaXMgcG90ZW50aWFsbHkgc3RpbGwgdmFsaWQgYnV0IHdhcyByZW1vdmVkIGZvciBhIGRpZmZlcmVudCByZWFzb24gKGUuZy5cclxuICAgIC8vIHRoZSBkYXRhYmFzZSBpcyBmdWxsIG9yIHRoZSBwZWVyIHRoYXQgc2VudCB0aGUgb3JkZXIgd2FzIG1pc2JlaGF2aW5nKS4gVGhlIG9yZGVyIHdpbGwgbm8gbG9uZ2VyIGJlIHdhdGNoZWRcclxuICAgIC8vIGFuZCBubyBmdXJ0aGVyIGV2ZW50cyBmb3IgdGhpcyBvcmRlciB3aWxsIGJlIGVtaXR0ZWQuIEluIHNvbWUgY2FzZXMsIHRoZSBvcmRlciBtYXkgYmUgcmUtYWRkZWQgaW4gdGhlXHJcbiAgICAvLyBmdXR1cmUuXHJcbiAgICBTdG9wcGVkV2F0Y2hpbmcgPSAnU1RPUFBFRF9XQVRDSElORycsXHJcbn1cclxuXHJcbmV4cG9ydCAqIGZyb20gJy4vZmVlcyc7XHJcblxyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm1heC1maWxlLWxpbmUtY291bnRcclxuIl0sInZlcnNpb24iOjN9