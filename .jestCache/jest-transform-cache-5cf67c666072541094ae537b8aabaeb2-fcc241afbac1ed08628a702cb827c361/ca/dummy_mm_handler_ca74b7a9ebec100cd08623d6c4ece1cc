9e77613696d0b4e40b7d39b22a7b9974
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DummyMMHandlers = void 0;
// tslint:disable:max-file-line-count
// tslint:disable: custom-no-magic-numbers
// tslint:disable: prefer-function-over-method
const contract_addresses_1 = require("@0x/contract-addresses");
const protocol_utils_1 = require("@0x/protocol-utils");
const utils_1 = require("@0x/utils");
const ethers_1 = require("ethers");
const HttpStatus = require("http-status-codes");
const constants_1 = require("../core/constants");
const rfqm_request_utils_1 = require("../utils/rfqm_request_utils");
const WETH_ROPSTEN = '0xc778417e063141139fce010982780140aa0cd5ab';
const TTA_ROPSTEN = '0x374a16f5e686c09b0cc9e8bc3466b3b645c74aa7';
const TTB_ROPSTEN = '0xf84830b73b2ed3c7267e7638f500110ea47fdf30';
const WMATIC_POLYGON = '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270';
const DAI_POLYGON = '0x8f3cf7ad23cd3cadbd9735aff958023239c6a063';
const USDC_POLYGON = '0x2791bca1f2de4661ed88a30c99a7a9449aa84174';
const USDT_POLYGON = '0xc2132d05d31c914a87c6611c10748aeb04b58e8f';
const RFQ1_MUMBAI = '0xbea1bca733a6f58c363d9eccfc62a806fa1afee7';
const RFQ2_MUMBAI = '0x72115b83bb0dc128785f3a66ad7d2dc484852d0c';
const RFQ3_MUMBAI = '0xb0a53dd97d672486f35787d23dc285a621537f21';
const MM_PRIVATE_KEY = process.env.MM_PRIVATE_KEY || '0xf0d8f376ca991256ddb256fb7cd28d68d971b07f5c0cf62cf0294c1ff8078a90';
const MM_ADDRESS = new ethers_1.Wallet(MM_PRIVATE_KEY).address;
const ROPSTEN_CHAIN_ID = 3;
const POLYGON_CHAIN_ID = 137;
const MUMBAI_CHAIN_ID = 80001;
const RFQT_NONCE_BUCKET = 0;
const tokenToDecimals = {
    [WETH_ROPSTEN]: 18,
    [TTA_ROPSTEN]: 18,
    [TTB_ROPSTEN]: 18,
    [WMATIC_POLYGON]: 18,
    [DAI_POLYGON]: 18,
    [USDC_POLYGON]: 6,
    [USDT_POLYGON]: 6,
    [RFQ1_MUMBAI]: 18,
    [RFQ2_MUMBAI]: 18,
    [RFQ3_MUMBAI]: 18,
};
const whitelistedIntegrators = new Set([
    '74188355-c85b-4f18-9de4-6dec3ec61b8d',
    '301e83b5-61f4-409b-bc61-8886dd56189d',
    '1c016c87-3128-4f78-b0f5-e90038d165ef',
    '83b02232-83ca-4e1e-af5d-46c563d6688e',
    '37f254d7-8fcf-4e97-ab6b-060364c0eaf5', // Simbot
]);
/**
 * This class implements handlers that are used to satisfy the MM Quote Server spec
 */
class DummyMMHandlers {
    constructor() {
        this._tokenSetByChainId = new Map();
        this._tokenSetByChainId.set(ROPSTEN_CHAIN_ID, new Set([WETH_ROPSTEN.toLocaleLowerCase(), TTA_ROPSTEN.toLowerCase(), TTB_ROPSTEN.toLowerCase()]));
        this._tokenSetByChainId.set(POLYGON_CHAIN_ID, new Set([
            USDC_POLYGON.toLowerCase(),
            USDT_POLYGON.toLowerCase(),
            WMATIC_POLYGON.toLowerCase(),
            DAI_POLYGON.toLowerCase(),
        ]));
        this._tokenSetByChainId.set(MUMBAI_CHAIN_ID, new Set([RFQ1_MUMBAI.toLowerCase(), RFQ2_MUMBAI.toLowerCase(), RFQ3_MUMBAI.toLowerCase()]));
    }
    static _parseQuoteRequest(req) {
        const { sellTokenAddress, buyTokenAddress, takerAddress, sellAmountBaseUnits, buyAmountBaseUnits, txOrigin, isLastLook, feeToken, feeAmount, feeType, chainId, } = req.query;
        const integratorId = req.headers['0x-integrator-id'];
        const isSelling = sellAmountBaseUnits !== undefined;
        const BASE_REQUEST = {
            sellTokenAddress: sellTokenAddress,
            buyTokenAddress: buyTokenAddress,
            takerAddress: takerAddress,
            txOrigin: txOrigin,
            isLastLook: isLastLook,
            feeToken: feeToken,
            feeAmount: feeAmount,
            feeType: feeType,
            chainId: chainId,
            integratorId: integratorId,
        };
        if (isSelling) {
            return {
                ...BASE_REQUEST,
                sellAmountBaseUnits: sellAmountBaseUnits,
            };
        }
        else {
            return {
                ...BASE_REQUEST,
                buyAmountBaseUnits: buyAmountBaseUnits,
            };
        }
    }
    static _parseSubmitRequest(
    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
    // eslint-disable-next-line @typescript-eslint/ban-types
    req) {
        const { order, orderHash, fee, takerTokenFillAmount } = req.body;
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const rawOrder = order;
        const rfqOrder = new protocol_utils_1.RfqOrder({
            txOrigin: rawOrder.txOrigin,
            expiry: new utils_1.BigNumber(rawOrder.expiry),
            pool: rawOrder.pool,
            salt: new utils_1.BigNumber(rawOrder.salt),
            makerToken: rawOrder.makerToken,
            takerToken: rawOrder.takerToken,
            makerAmount: new utils_1.BigNumber(rawOrder.makerAmount),
            takerAmount: new utils_1.BigNumber(rawOrder.takerAmount),
            maker: rawOrder.maker,
            taker: rawOrder.taker,
            chainId: rawOrder.chainId,
        });
        return {
            order: rfqOrder,
            orderHash,
            fee: fee,
            takerTokenFillAmount: new utils_1.BigNumber(takerTokenFillAmount),
        };
    }
    /**
     * Parse RFQm sign request.
     * @param req Incoming sign request.
     * @returns Parsed RFQm sign request object.
     */
    static _parseSignRfqmRequest(req) {
        const { order: orderRaw, orderHash, feeAmount: feeAmountRaw, feeToken: feeTokenRaw, expiry: expiryRaw, takerSignature: takerSignatureRaw, } = req.body;
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const order = new protocol_utils_1.OtcOrder((0, rfqm_request_utils_1.stringsToOtcOrderFields)(orderRaw));
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const takerSignature = (0, rfqm_request_utils_1.stringsToSignature)(takerSignatureRaw);
        const expiry = new utils_1.BigNumber(expiryRaw);
        return {
            order,
            orderHash: orderHash,
            feeAmount: feeAmountRaw,
            feeToken: feeTokenRaw,
            takerSignature,
            expiry,
        };
    }
    /**
     * Parse RFQt sign request.
     * @param req Incoming sign request.
     * @returns Parsed RFQt sign request object.
     */
    static _parseSignRfqtRequest(req) {
        const { order: orderRaw, orderHash, feeAmount: feeAmountRaw, feeToken: feeTokenRaw, expiry: expiryRaw, } = req.body;
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const order = new protocol_utils_1.OtcOrder((0, rfqm_request_utils_1.stringsToOtcOrderFields)(orderRaw));
        const expiry = new utils_1.BigNumber(expiryRaw);
        return {
            order,
            orderHash: orderHash,
            feeAmount: feeAmountRaw,
            feeToken: feeTokenRaw,
            expiry,
        };
    }
    /**
     * Simple pricing that always returns 1:1 v1 prices
     */
    async getPriceV1Async(req, res) {
        const params = DummyMMHandlers._parseQuoteRequest(req);
        const tokenSet = this._tokenSetByChainId.get(Number(params.chainId));
        const { sellTokenAddress, buyTokenAddress, sellAmountBaseUnits, buyAmountBaseUnits, integratorId } = params;
        // Check integrator
        if (!integratorId || !whitelistedIntegrators.has(integratorId)) {
            res.status(HttpStatus.BAD_REQUEST).send('Invalid integrator id');
            return;
        }
        // Check tokens
        if (!tokenSet ||
            !tokenSet.has(sellTokenAddress.toLowerCase()) ||
            !tokenSet.has(buyTokenAddress.toLowerCase())) {
            res.status(HttpStatus.NO_CONTENT).send({});
            return;
        }
        // Get amount (direction doesn't matter because price is always 1:1)
        const isSelling = sellAmountBaseUnits !== undefined;
        const rawAmount = (isSelling ? sellAmountBaseUnits : buyAmountBaseUnits);
        const amount = new utils_1.BigNumber(rawAmount);
        // Tokens
        const takerToken = sellTokenAddress;
        const makerToken = buyTokenAddress;
        // Expiry
        const now = new utils_1.BigNumber(Date.now());
        const fiveMinLater = now.plus(new utils_1.BigNumber(5).times(constants_1.ONE_MINUTE_MS)).div(constants_1.ONE_SECOND_MS).integerValue();
        const indicativeQuote = {
            expiry: fiveMinLater.toString(),
            makerToken,
            takerToken,
            makerAmount: amount.toString(),
            takerAmount: amount.toString(),
        };
        res.status(HttpStatus.OK).send(indicativeQuote);
        return;
    }
    /**
     * Simple pricing that always returns 1:1 v2 prices
     */
    async getPriceV2Async(req, res) {
        const params = DummyMMHandlers._parseQuoteRequest(req);
        const tokenSet = this._tokenSetByChainId.get(Number(params.chainId));
        const { sellTokenAddress, buyTokenAddress, sellAmountBaseUnits, buyAmountBaseUnits, integratorId } = params;
        // Check integrator
        if (!integratorId || !whitelistedIntegrators.has(integratorId)) {
            res.status(HttpStatus.BAD_REQUEST).send('Invalid integrator id');
            return;
        }
        // Check tokens
        if (!tokenSet ||
            !tokenSet.has(sellTokenAddress.toLowerCase()) ||
            !tokenSet.has(buyTokenAddress.toLowerCase())) {
            res.status(HttpStatus.NO_CONTENT).send({});
            return;
        }
        // Get amount (direction doesn't matter because price is always 1:1)
        const isSelling = sellAmountBaseUnits !== undefined;
        const rawAmount = (isSelling ? sellAmountBaseUnits : buyAmountBaseUnits);
        const amount = new utils_1.BigNumber(rawAmount);
        // Tokens
        const takerToken = sellTokenAddress;
        const makerToken = buyTokenAddress;
        // Expiry
        const now = new utils_1.BigNumber(Date.now());
        const fiveMinLater = now.plus(new utils_1.BigNumber(5).times(constants_1.ONE_MINUTE_MS)).div(constants_1.ONE_SECOND_MS).integerValue();
        const indicativeQuote = {
            expiry: fiveMinLater.toString(),
            makerToken,
            takerToken,
            makerAmount: amount.toString(),
            takerAmount: amount.toString(),
            maker: MM_ADDRESS,
        };
        res.status(HttpStatus.OK).send(indicativeQuote);
        return;
    }
    /**
     * Simple quoting that always signs an order 1:1 for RFQM v1
     */
    async getQuoteV1Async(req, res) {
        const params = DummyMMHandlers._parseQuoteRequest(req);
        const tokenSet = this._tokenSetByChainId.get(Number(params.chainId));
        const { sellTokenAddress, buyTokenAddress, sellAmountBaseUnits, buyAmountBaseUnits, txOrigin, takerAddress, integratorId, } = params;
        // Check integrator
        if (!integratorId || !whitelistedIntegrators.has(integratorId)) {
            res.status(HttpStatus.BAD_REQUEST).send('Invalid integrator id');
            return;
        }
        // Check tokens
        if (!tokenSet ||
            !tokenSet.has(sellTokenAddress.toLowerCase()) ||
            !tokenSet.has(buyTokenAddress.toLowerCase())) {
            res.status(HttpStatus.NO_CONTENT).send({});
            return;
        }
        // Get amount (direction doesn't matter because price is always 1:1)
        const isSelling = sellAmountBaseUnits !== undefined;
        const rawAmount = (isSelling ? sellAmountBaseUnits : buyAmountBaseUnits);
        const amount = new utils_1.BigNumber(rawAmount);
        // Tokens
        const takerToken = sellTokenAddress;
        const makerToken = buyTokenAddress;
        // Enforce a 5 unit maximum
        const oneUnit = 10 ** tokenToDecimals[takerToken];
        const fiveUnits = oneUnit * 5;
        if (amount.gt(fiveUnits)) {
            res.status(HttpStatus.NO_CONTENT).send({});
            return;
        }
        // Expiry
        const now = new utils_1.BigNumber(Date.now());
        const fiveMinLater = now.plus(new utils_1.BigNumber(5).times(constants_1.ONE_MINUTE_MS)).div(constants_1.ONE_SECOND_MS).integerValue();
        const rfqOrder = new protocol_utils_1.RfqOrder({
            txOrigin,
            taker: takerAddress,
            maker: MM_ADDRESS,
            takerToken,
            makerToken,
            makerAmount: new utils_1.BigNumber(amount.toString()),
            takerAmount: new utils_1.BigNumber(amount.toString()),
            expiry: fiveMinLater,
            chainId: Number(params.chainId),
            salt: now,
        });
        const orderHash = rfqOrder.getHash();
        const signature = (0, protocol_utils_1.ethSignHashWithKey)(orderHash, MM_PRIVATE_KEY);
        const firmQuote = {
            signedOrder: {
                ...rfqOrder,
                signature,
            },
        };
        res.status(HttpStatus.OK).send(firmQuote);
        return;
    }
    /**
     * Simple quoting for RFQt v2 that signs even taker amounts, but refuses to sign odd taker amounts, ignoring decimals.
     * The max trading size is 2 tokens.
     *
     * Example for WETH:
     * - 1.000_000_000_000_000_000 is considered odd!
     * - 2.000_000_000_000_000_001 is considered even!
     */
    async getQuoteRfqtV2Async(req, res) {
        const params = DummyMMHandlers._parseQuoteRequest(req);
        const chainId = Number(params.chainId);
        const tokenSet = this._tokenSetByChainId.get(chainId);
        const { sellTokenAddress, buyTokenAddress, sellAmountBaseUnits, buyAmountBaseUnits, txOrigin, takerAddress, integratorId, feeAmount, } = params;
        // Check integrator
        if (!integratorId || !whitelistedIntegrators.has(integratorId)) {
            res.status(HttpStatus.BAD_REQUEST).send('Invalid integrator id');
            return;
        }
        // Check tokens
        if (!tokenSet ||
            !tokenSet.has(sellTokenAddress.toLowerCase()) ||
            !tokenSet.has(buyTokenAddress.toLowerCase())) {
            res.status(HttpStatus.NO_CONTENT).send(`No liquidity for ${sellTokenAddress}:${buyTokenAddress}`);
            return;
        }
        // Get amount (direction doesn't matter because price is always 1:1)
        const isSelling = sellAmountBaseUnits !== undefined;
        const rawAmount = (isSelling ? sellAmountBaseUnits : buyAmountBaseUnits);
        const amount = new utils_1.BigNumber(rawAmount);
        // Tokens
        const takerToken = sellTokenAddress;
        const makerToken = buyTokenAddress;
        const decimals = tokenToDecimals[takerToken];
        // Enforce a 2 units maximum for trading
        const oneUnit = 10 ** decimals;
        if (amount.gt(oneUnit * 2)) {
            res.status(HttpStatus.NO_CONTENT).send('Trading limit for buy/sell tokens should not exceed 2');
            return;
        }
        const isEven = amount
            .div(10 ** decimals)
            .integerValue()
            .mod(2)
            .eq(0);
        // Reject
        if (!isEven) {
            res.status(HttpStatus.NO_CONTENT).send({});
            return;
        }
        // Expiry and nonce
        const now = new utils_1.BigNumber(Date.now());
        const expiry = now.plus(new utils_1.BigNumber(5).times(constants_1.ONE_MINUTE_MS)).div(constants_1.ONE_SECOND_MS).integerValue();
        const nowSeconds = Math.floor(Date.now() / constants_1.ONE_SECOND_MS);
        // Get Exchange Proxy contract address
        const exchangeProxyContractAddress = (0, contract_addresses_1.getContractAddressesForChainOrThrow)(chainId).exchangeProxy;
        const otcOrder = new protocol_utils_1.OtcOrder({
            txOrigin,
            expiryAndNonce: protocol_utils_1.OtcOrder.encodeExpiryAndNonce(expiry, new utils_1.BigNumber(RFQT_NONCE_BUCKET), new utils_1.BigNumber(nowSeconds)),
            takerToken,
            makerToken,
            makerAmount: amount,
            takerAmount: amount,
            maker: MM_ADDRESS,
            taker: takerAddress,
            chainId,
            verifyingContract: exchangeProxyContractAddress,
        });
        const orderHash = otcOrder.getHash();
        const signature = (0, protocol_utils_1.ethSignHashWithKey)(orderHash, MM_PRIVATE_KEY);
        const response = {
            feeAmount,
            order: otcOrder,
            orderHash,
            makerSignature: signature,
        };
        res.status(HttpStatus.OK).send(response);
    }
    /**
     * Approves even amounts and rejects odd amounts, ignoring decimals
     *
     * Example for WETH:
     * - 1.000_000_000_000_000_000 is considered odd!
     * - 2.000_000_000_000_000_001 is considered even!
     */
    async submitAsync(req, res) {
        const requestParams = DummyMMHandlers._parseSubmitRequest(req);
        const { order, fee, orderHash, takerTokenFillAmount } = requestParams;
        const decimals = tokenToDecimals[order.takerToken];
        const isEven = order.takerAmount
            .div(10 ** decimals)
            .integerValue()
            .mod(2)
            .eq(0);
        const response = {
            fee,
            proceedWithFill: isEven,
            signedOrderHash: orderHash,
            takerTokenFillAmount: takerTokenFillAmount.toString(),
        };
        res.status(HttpStatus.OK).send(response);
    }
    /**
     * Approves even amounts and rejects odd amounts, ignoring decimals
     *
     * Example for WETH:
     * - 1.000_000_000_000_000_000 is considered odd!
     * - 2.000_000_000_000_000_001 is considered even!
     */
    async signRfqmV2Async(req, res) {
        const requestParams = DummyMMHandlers._parseSignRfqmRequest(req);
        const { order, feeAmount, orderHash } = requestParams;
        const decimals = tokenToDecimals[order.takerToken];
        const isEven = order.takerAmount
            .div(10 ** decimals)
            .integerValue()
            .mod(2)
            .eq(0);
        // Reject
        if (!isEven) {
            res.status(HttpStatus.OK).send({
                proceedWithFill: false,
            });
            return;
        }
        // Accept and sign
        const signature = (0, protocol_utils_1.ethSignHashWithKey)(orderHash, MM_PRIVATE_KEY);
        const response = {
            feeAmount,
            proceedWithFill: isEven,
            makerSignature: signature,
        };
        res.status(HttpStatus.OK).send(response);
    }
    /**
     * Signs for even taker amounts, but refuses odd taker amounts, ignoring decimals. The logic is very similar to
     * `signRfqmV2Async` for consistency.
     *
     * Example for WETH:
     * - 1.000_000_000_000_000_000 is considered odd!
     * - 2.000_000_000_000_000_001 is considered even!
     */
    async signRfqtV2Async(req, res) {
        const requestParams = DummyMMHandlers._parseSignRfqtRequest(req);
        const { order, feeAmount, orderHash: orderHashParam } = requestParams;
        const orderHash = order.getHash();
        const tokenSet = this._tokenSetByChainId.get(Number(requestParams.order.chainId));
        // Check order hash computed from order is the same as order hash in query param
        if (orderHash !== orderHashParam) {
            res.status(HttpStatus.BAD_REQUEST).send(`orderHash query param provided ${orderHashParam} is not equal to the actual order hash ${orderHash}`);
            return;
        }
        // Check tokens
        if (!tokenSet ||
            !tokenSet.has(order.makerToken.toLowerCase()) ||
            !tokenSet.has(order.takerToken.toLowerCase())) {
            res.status(HttpStatus.NO_CONTENT).send(`No liquidity for ${order.makerToken}:${order.takerToken}`);
            return;
        }
        const decimals = tokenToDecimals[order.takerToken];
        const isEven = order.takerAmount
            .div(10 ** decimals)
            .integerValue()
            .mod(2)
            .eq(0);
        // Reject
        if (!isEven) {
            res.status(HttpStatus.NO_CONTENT).send({});
            return;
        }
        // Refuse to sign
        const signature = (0, protocol_utils_1.ethSignHashWithKey)(orderHash, MM_PRIVATE_KEY);
        const response = {
            feeAmount,
            makerSignature: signature,
        };
        res.status(HttpStatus.OK).send(response);
    }
}
exports.DummyMMHandlers = DummyMMHandlers;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9oYW5kbGVycy9kdW1teV9tbV9oYW5kbGVyLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUFxQztBQUNyQywwQ0FBMEM7QUFDMUMsOENBQThDO0FBQzlDLCtEQUE2RTtBQUM3RSx1REFBdUY7QUFDdkYscUNBQXNDO0FBQ3RDLG1DQUFnQztBQUVoQyxnREFBZ0Q7QUFFaEQsaURBQWlFO0FBR2pFLG9FQUEwRjtBQUUxRixNQUFNLFlBQVksR0FBRyw0Q0FBNEMsQ0FBQztBQUNsRSxNQUFNLFdBQVcsR0FBRyw0Q0FBNEMsQ0FBQztBQUNqRSxNQUFNLFdBQVcsR0FBRyw0Q0FBNEMsQ0FBQztBQUVqRSxNQUFNLGNBQWMsR0FBRyw0Q0FBNEMsQ0FBQztBQUNwRSxNQUFNLFdBQVcsR0FBRyw0Q0FBNEMsQ0FBQztBQUNqRSxNQUFNLFlBQVksR0FBRyw0Q0FBNEMsQ0FBQztBQUNsRSxNQUFNLFlBQVksR0FBRyw0Q0FBNEMsQ0FBQztBQUVsRSxNQUFNLFdBQVcsR0FBRyw0Q0FBNEMsQ0FBQztBQUNqRSxNQUFNLFdBQVcsR0FBRyw0Q0FBNEMsQ0FBQztBQUNqRSxNQUFNLFdBQVcsR0FBRyw0Q0FBNEMsQ0FBQztBQUVqRSxNQUFNLGNBQWMsR0FDaEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLElBQUksb0VBQW9FLENBQUM7QUFDdkcsTUFBTSxVQUFVLEdBQUcsSUFBSSxlQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsT0FBTyxDQUFDO0FBRXRELE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO0FBQzNCLE1BQU0sZ0JBQWdCLEdBQUcsR0FBRyxDQUFDO0FBQzdCLE1BQU0sZUFBZSxHQUFHLEtBQUssQ0FBQztBQUU5QixNQUFNLGlCQUFpQixHQUFHLENBQUMsQ0FBQztBQUU1QixNQUFNLGVBQWUsR0FBMkI7SUFDNUMsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFO0lBQ2xCLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFBRTtJQUNq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Q0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDM0MsT0FBTztTQUNWO1FBRUQsaUJBQWlCO1FBQ2pCLE1BQU0sU0FBUyxHQUFHLElBQUEsbUNBQWtCLEVBQUMsU0FBUyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ2hFLE1BQU0sUUFBUSxHQUFHO1lBQ2IsU0FBUztZQUNULGNBQWMsRUFBRSxTQUFTO1NBQzVCLENBQUM7UUFFRixHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0MsQ0FBQztDQUNKO0FBOWpCRCwwQ0E4akJDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXZpZHdhbHNoL2NvZGUtbG9jYWwvMHgtcmZxLWFwaS9zcmMvaGFuZGxlcnMvZHVtbXlfbW1faGFuZGxlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZTptYXgtZmlsZS1saW5lLWNvdW50XG4vLyB0c2xpbnQ6ZGlzYWJsZTogY3VzdG9tLW5vLW1hZ2ljLW51bWJlcnNcbi8vIHRzbGludDpkaXNhYmxlOiBwcmVmZXItZnVuY3Rpb24tb3Zlci1tZXRob2RcbmltcG9ydCB7IGdldENvbnRyYWN0QWRkcmVzc2VzRm9yQ2hhaW5PclRocm93IH0gZnJvbSAnQDB4L2NvbnRyYWN0LWFkZHJlc3Nlcyc7XG5pbXBvcnQgeyBldGhTaWduSGFzaFdpdGhLZXksIE90Y09yZGVyLCBSZnFPcmRlciwgU2lnbmF0dXJlIH0gZnJvbSAnQDB4L3Byb3RvY29sLXV0aWxzJztcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ0AweC91dGlscyc7XG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0ICogYXMgZXhwcmVzcyBmcm9tICdleHByZXNzJztcbmltcG9ydCAqIGFzIEh0dHBTdGF0dXMgZnJvbSAnaHR0cC1zdGF0dXMtY29kZXMnO1xuXG5pbXBvcnQgeyBPTkVfTUlOVVRFX01TLCBPTkVfU0VDT05EX01TIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMnO1xuaW1wb3J0IHsgRmVlLCBRdW90ZVNlcnZlclByaWNlUGFyYW1zIH0gZnJvbSAnLi4vY29yZS90eXBlcyc7XG5pbXBvcnQgeyBTdWJtaXRSZXF1ZXN0IH0gZnJvbSAnLi4vcXVvdGUtc2VydmVyL3R5cGVzJztcbmltcG9ydCB7IHN0cmluZ3NUb090Y09yZGVyRmllbGRzLCBzdHJpbmdzVG9TaWduYXR1cmUgfSBmcm9tICcuLi91dGlscy9yZnFtX3JlcXVlc3RfdXRpbHMnO1xuXG5jb25zdCBXRVRIX1JPUFNURU4gPSAnMHhjNzc4NDE3ZTA2MzE0MTEzOWZjZTAxMDk4Mjc4MDE0MGFhMGNkNWFiJztcbmNvbnN0IFRUQV9ST1BTVEVOID0gJzB4Mzc0YTE2ZjVlNjg2YzA5YjBjYzllOGJjMzQ2NmIzYjY0NWM3NGFhNyc7XG5jb25zdCBUVEJfUk9QU1RFTiA9ICcweGY4NDgzMGI3M2IyZWQzYzcyNjdlNzYzOGY1MDAxMTBlYTQ3ZmRmMzAnO1xuXG5jb25zdCBXTUFUSUNfUE9MWUdPTiA9ICcweDBkNTAwYjFkOGU4ZWYzMWUyMWM5OWQxZGI5YTY0NDRkM2FkZjEyNzAnO1xuY29uc3QgREFJX1BPTFlHT04gPSAnMHg4ZjNjZjdhZDIzY2QzY2FkYmQ5NzM1YWZmOTU4MDIzMjM5YzZhMDYzJztcbmNvbnN0IFVTRENfUE9MWUdPTiA9ICcweDI3OTFiY2ExZjJkZTQ2NjFlZDg4YTMwYzk5YTdhOTQ0OWFhODQxNzQnO1xuY29uc3QgVVNEVF9QT0xZR09OID0gJzB4YzIxMzJkMDVkMzFjOTE0YTg3YzY2MTFjMTA3NDhhZWIwNGI1OGU4Zic7XG5cbmNvbnN0IFJGUTFfTVVNQkFJID0gJzB4YmVhMWJjYTczM2E2ZjU4YzM2M2Q5ZWNjZmM2MmE4MDZmYTFhZmVlNyc7XG5jb25zdCBSRlEyX01VTUJBSSA9ICcweDcyMTE1YjgzYmIwZGMxMjg3ODVmM2E2NmFkN2QyZGM0ODQ4NTJkMGMnO1xuY29uc3QgUkZRM19NVU1CQUkgPSAnMHhiMGE1M2RkOTdkNjcyNDg2ZjM1Nzg3ZDIzZGMyODVhNjIxNTM3ZjIxJztcblxuY29uc3QgTU1fUFJJVkFURV9LRVkgPVxuICAgIHByb2Nlc3MuZW52Lk1NX1BSSVZBVEVfS0VZIHx8ICcweGYwZDhmMzc2Y2E5OTEyNTZkZGIyNTZmYjdjZDI4ZDY4ZDk3MWIwN2Y1YzBjZjYyY2YwMjk0YzFmZjgwNzhhOTAnO1xuY29uc3QgTU1fQUREUkVTUyA9IG5ldyBXYWxsZXQoTU1fUFJJVkFURV9LRVkpLmFkZHJlc3M7XG5cbmNvbnN0IFJPUFNURU5fQ0hBSU5fSUQgPSAzO1xuY29uc3QgUE9MWUdPTl9DSEFJTl9JRCA9IDEzNztcbmNvbnN0IE1VTUJBSV9DSEFJTl9JRCA9IDgwMDAxO1xuXG5jb25zdCBSRlFUX05PTkNFX0JVQ0tFVCA9IDA7XG5cbmNvbnN0IHRva2VuVG9EZWNpbWFsczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgICBbV0VUSF9ST1BTVEVOXTogMTgsXG4gICAgW1RUQV9ST1BTVEVOXTogMTgsXG4gICAgW1RUQl9ST1BTVEVOXTogMTgsXG4gICAgW1dNQVRJQ19QT0xZR09OXTogMTgsXG4gICAgW0RBSV9QT0xZR09OXTogMTgsXG4gICAgW1VTRENfUE9MWUdPTl06IDYsXG4gICAgW1VTRFRfUE9MWUdPTl06IDYsXG4gICAgW1JGUTFfTVVNQkFJXTogMTgsXG4gICAgW1JGUTJfTVVNQkFJXTogMTgsXG4gICAgW1JGUTNfTVVNQkFJXTogMTgsXG59O1xuXG5jb25zdCB3aGl0ZWxpc3RlZEludGVncmF0b3JzID0gbmV3IFNldChbXG4gICAgJzc0MTg4MzU1LWM4NWItNGYxOC05ZGU0LTZkZWMzZWM2MWI4ZCcsIC8vIFJIXG4gICAgJzMwMWU4M2I1LTYxZjQtNDA5Yi1iYzYxLTg4ODZkZDU2MTg5ZCcsIC8vIFJIIFRlc3RuZXRzXG4gICAgJzFjMDE2Yzg3LTMxMjgtNGY3OC1iMGY1LWU5MDAzOGQxNjVlZicsIC8vIDB4IFJGUVxuICAgICc4M2IwMjIzMi04M2NhLTRlMWUtYWY1ZC00NmM1NjNkNjY4OGUnLCAvLyBSRlEgTG9hZCBUZXN0ZXJcbiAgICAnMzdmMjU0ZDctOGZjZi00ZTk3LWFiNmItMDYwMzY0YzBlYWY1JywgLy8gU2ltYm90XG5dKTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGltcGxlbWVudHMgaGFuZGxlcnMgdGhhdCBhcmUgdXNlZCB0byBzYXRpc2Z5IHRoZSBNTSBRdW90ZSBTZXJ2ZXIgc3BlY1xuICovXG5leHBvcnQgY2xhc3MgRHVtbXlNTUhhbmRsZXJzIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF90b2tlblNldEJ5Q2hhaW5JZDogTWFwPG51bWJlciB8IHVuZGVmaW5lZCwgU2V0PHN0cmluZz4+O1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3BhcnNlUXVvdGVSZXF1ZXN0KHJlcTogZXhwcmVzcy5SZXF1ZXN0KTogUXVvdGVTZXJ2ZXJQcmljZVBhcmFtcyAmIHsgaW50ZWdyYXRvcklkPzogc3RyaW5nIH0ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBzZWxsVG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgYnV5VG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgdGFrZXJBZGRyZXNzLFxuICAgICAgICAgICAgc2VsbEFtb3VudEJhc2VVbml0cyxcbiAgICAgICAgICAgIGJ1eUFtb3VudEJhc2VVbml0cyxcbiAgICAgICAgICAgIHR4T3JpZ2luLFxuICAgICAgICAgICAgaXNMYXN0TG9vayxcbiAgICAgICAgICAgIGZlZVRva2VuLFxuICAgICAgICAgICAgZmVlQW1vdW50LFxuICAgICAgICAgICAgZmVlVHlwZSxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgIH0gPSByZXEucXVlcnk7XG5cbiAgICAgICAgY29uc3QgaW50ZWdyYXRvcklkID0gcmVxLmhlYWRlcnNbJzB4LWludGVncmF0b3ItaWQnXTtcblxuICAgICAgICBjb25zdCBpc1NlbGxpbmcgPSBzZWxsQW1vdW50QmFzZVVuaXRzICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgY29uc3QgQkFTRV9SRVFVRVNUID0ge1xuICAgICAgICAgICAgc2VsbFRva2VuQWRkcmVzczogc2VsbFRva2VuQWRkcmVzcyBhcyBzdHJpbmcsXG4gICAgICAgICAgICBidXlUb2tlbkFkZHJlc3M6IGJ1eVRva2VuQWRkcmVzcyBhcyBzdHJpbmcsXG4gICAgICAgICAgICB0YWtlckFkZHJlc3M6IHRha2VyQWRkcmVzcyBhcyBzdHJpbmcsXG4gICAgICAgICAgICB0eE9yaWdpbjogdHhPcmlnaW4gYXMgc3RyaW5nLFxuICAgICAgICAgICAgaXNMYXN0TG9vazogaXNMYXN0TG9vayBhcyBzdHJpbmcsXG4gICAgICAgICAgICBmZWVUb2tlbjogZmVlVG9rZW4gYXMgc3RyaW5nLFxuICAgICAgICAgICAgZmVlQW1vdW50OiBmZWVBbW91bnQgYXMgc3RyaW5nLFxuICAgICAgICAgICAgZmVlVHlwZTogZmVlVHlwZSBhcyBzdHJpbmcsXG4gICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkIGFzIHN0cmluZyxcbiAgICAgICAgICAgIGludGVncmF0b3JJZDogaW50ZWdyYXRvcklkIGFzIHN0cmluZyxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaXNTZWxsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLkJBU0VfUkVRVUVTVCxcbiAgICAgICAgICAgICAgICBzZWxsQW1vdW50QmFzZVVuaXRzOiBzZWxsQW1vdW50QmFzZVVuaXRzIGFzIHN0cmluZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLkJBU0VfUkVRVUVTVCxcbiAgICAgICAgICAgICAgICBidXlBbW91bnRCYXNlVW5pdHM6IGJ1eUFtb3VudEJhc2VVbml0cyBhcyBzdHJpbmcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3BhcnNlU3VibWl0UmVxdWVzdChcbiAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgICAgICByZXE6IGV4cHJlc3MuUmVxdWVzdDx7fSwge30sIFJlY29yZDxrZXlvZiBTdWJtaXRSZXF1ZXN0LCBzdHJpbmc+PixcbiAgICApOiBTdWJtaXRSZXF1ZXN0IHtcbiAgICAgICAgY29uc3QgeyBvcmRlciwgb3JkZXJIYXNoLCBmZWUsIHRha2VyVG9rZW5GaWxsQW1vdW50IH0gPSByZXEuYm9keTtcblxuICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHJhd09yZGVyID0gb3JkZXIgYXMgYW55O1xuICAgICAgICBjb25zdCByZnFPcmRlciA9IG5ldyBSZnFPcmRlcih7XG4gICAgICAgICAgICB0eE9yaWdpbjogcmF3T3JkZXIudHhPcmlnaW4sXG4gICAgICAgICAgICBleHBpcnk6IG5ldyBCaWdOdW1iZXIocmF3T3JkZXIuZXhwaXJ5KSxcbiAgICAgICAgICAgIHBvb2w6IHJhd09yZGVyLnBvb2wsXG4gICAgICAgICAgICBzYWx0OiBuZXcgQmlnTnVtYmVyKHJhd09yZGVyLnNhbHQpLFxuICAgICAgICAgICAgbWFrZXJUb2tlbjogcmF3T3JkZXIubWFrZXJUb2tlbixcbiAgICAgICAgICAgIHRha2VyVG9rZW46IHJhd09yZGVyLnRha2VyVG9rZW4sXG4gICAgICAgICAgICBtYWtlckFtb3VudDogbmV3IEJpZ051bWJlcihyYXdPcmRlci5tYWtlckFtb3VudCksXG4gICAgICAgICAgICB0YWtlckFtb3VudDogbmV3IEJpZ051bWJlcihyYXdPcmRlci50YWtlckFtb3VudCksXG4gICAgICAgICAgICBtYWtlcjogcmF3T3JkZXIubWFrZXIsXG4gICAgICAgICAgICB0YWtlcjogcmF3T3JkZXIudGFrZXIsXG4gICAgICAgICAgICBjaGFpbklkOiByYXdPcmRlci5jaGFpbklkLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3JkZXI6IHJmcU9yZGVyLFxuICAgICAgICAgICAgb3JkZXJIYXNoLFxuICAgICAgICAgICAgZmVlOiBmZWUgYXMgdW5rbm93biBhcyBGZWUsXG4gICAgICAgICAgICB0YWtlclRva2VuRmlsbEFtb3VudDogbmV3IEJpZ051bWJlcih0YWtlclRva2VuRmlsbEFtb3VudCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgUkZRbSBzaWduIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcSBJbmNvbWluZyBzaWduIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMgUGFyc2VkIFJGUW0gc2lnbiByZXF1ZXN0IG9iamVjdC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBfcGFyc2VTaWduUmZxbVJlcXVlc3QocmVxOiBleHByZXNzLlJlcXVlc3QpOiB7XG4gICAgICAgIGZlZUFtb3VudDogc3RyaW5nO1xuICAgICAgICBmZWVUb2tlbjogc3RyaW5nO1xuICAgICAgICBvcmRlcjogT3RjT3JkZXI7XG4gICAgICAgIG9yZGVySGFzaDogc3RyaW5nO1xuICAgICAgICBleHBpcnk6IEJpZ051bWJlcjtcbiAgICAgICAgdGFrZXJTaWduYXR1cmU6IFNpZ25hdHVyZTtcbiAgICB9IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgb3JkZXI6IG9yZGVyUmF3LFxuICAgICAgICAgICAgb3JkZXJIYXNoLFxuICAgICAgICAgICAgZmVlQW1vdW50OiBmZWVBbW91bnRSYXcsXG4gICAgICAgICAgICBmZWVUb2tlbjogZmVlVG9rZW5SYXcsXG4gICAgICAgICAgICBleHBpcnk6IGV4cGlyeVJhdyxcbiAgICAgICAgICAgIHRha2VyU2lnbmF0dXJlOiB0YWtlclNpZ25hdHVyZVJhdyxcbiAgICAgICAgfSA9IHJlcS5ib2R5O1xuXG4gICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgb3JkZXIgPSBuZXcgT3RjT3JkZXIoc3RyaW5nc1RvT3RjT3JkZXJGaWVsZHMob3JkZXJSYXcgYXMgYW55KSk7XG4gICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgdGFrZXJTaWduYXR1cmUgPSBzdHJpbmdzVG9TaWduYXR1cmUodGFrZXJTaWduYXR1cmVSYXcgYXMgYW55KTtcbiAgICAgICAgY29uc3QgZXhwaXJ5ID0gbmV3IEJpZ051bWJlcihleHBpcnlSYXcgYXMgc3RyaW5nKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3JkZXIsXG4gICAgICAgICAgICBvcmRlckhhc2g6IG9yZGVySGFzaCBhcyBzdHJpbmcsXG4gICAgICAgICAgICBmZWVBbW91bnQ6IGZlZUFtb3VudFJhdyBhcyBzdHJpbmcsXG4gICAgICAgICAgICBmZWVUb2tlbjogZmVlVG9rZW5SYXcgYXMgc3RyaW5nLFxuICAgICAgICAgICAgdGFrZXJTaWduYXR1cmUsXG4gICAgICAgICAgICBleHBpcnksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgUkZRdCBzaWduIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcSBJbmNvbWluZyBzaWduIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMgUGFyc2VkIFJGUXQgc2lnbiByZXF1ZXN0IG9iamVjdC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBfcGFyc2VTaWduUmZxdFJlcXVlc3QocmVxOiBleHByZXNzLlJlcXVlc3QpOiB7XG4gICAgICAgIGZlZUFtb3VudDogc3RyaW5nO1xuICAgICAgICBmZWVUb2tlbjogc3RyaW5nO1xuICAgICAgICBvcmRlcjogT3RjT3JkZXI7XG4gICAgICAgIG9yZGVySGFzaDogc3RyaW5nO1xuICAgICAgICBleHBpcnk6IEJpZ051bWJlcjtcbiAgICB9IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgb3JkZXI6IG9yZGVyUmF3LFxuICAgICAgICAgICAgb3JkZXJIYXNoLFxuICAgICAgICAgICAgZmVlQW1vdW50OiBmZWVBbW91bnRSYXcsXG4gICAgICAgICAgICBmZWVUb2tlbjogZmVlVG9rZW5SYXcsXG4gICAgICAgICAgICBleHBpcnk6IGV4cGlyeVJhdyxcbiAgICAgICAgfSA9IHJlcS5ib2R5O1xuXG4gICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgb3JkZXIgPSBuZXcgT3RjT3JkZXIoc3RyaW5nc1RvT3RjT3JkZXJGaWVsZHMob3JkZXJSYXcgYXMgYW55KSk7XG4gICAgICAgIGNvbnN0IGV4cGlyeSA9IG5ldyBCaWdOdW1iZXIoZXhwaXJ5UmF3IGFzIHN0cmluZyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9yZGVyLFxuICAgICAgICAgICAgb3JkZXJIYXNoOiBvcmRlckhhc2ggYXMgc3RyaW5nLFxuICAgICAgICAgICAgZmVlQW1vdW50OiBmZWVBbW91bnRSYXcgYXMgc3RyaW5nLFxuICAgICAgICAgICAgZmVlVG9rZW46IGZlZVRva2VuUmF3IGFzIHN0cmluZyxcbiAgICAgICAgICAgIGV4cGlyeSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdG9rZW5TZXRCeUNoYWluSWQgPSBuZXcgTWFwPG51bWJlciB8IHVuZGVmaW5lZCwgU2V0PHN0cmluZz4+KCk7XG4gICAgICAgIHRoaXMuX3Rva2VuU2V0QnlDaGFpbklkLnNldChcbiAgICAgICAgICAgIFJPUFNURU5fQ0hBSU5fSUQsXG4gICAgICAgICAgICBuZXcgU2V0KFtXRVRIX1JPUFNURU4udG9Mb2NhbGVMb3dlckNhc2UoKSwgVFRBX1JPUFNURU4udG9Mb3dlckNhc2UoKSwgVFRCX1JPUFNURU4udG9Mb3dlckNhc2UoKV0pLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLl90b2tlblNldEJ5Q2hhaW5JZC5zZXQoXG4gICAgICAgICAgICBQT0xZR09OX0NIQUlOX0lELFxuICAgICAgICAgICAgbmV3IFNldChbXG4gICAgICAgICAgICAgICAgVVNEQ19QT0xZR09OLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgVVNEVF9QT0xZR09OLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgV01BVElDX1BPTFlHT04udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBEQUlfUE9MWUdPTi50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgXSksXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3Rva2VuU2V0QnlDaGFpbklkLnNldChcbiAgICAgICAgICAgIE1VTUJBSV9DSEFJTl9JRCxcbiAgICAgICAgICAgIG5ldyBTZXQoW1JGUTFfTVVNQkFJLnRvTG93ZXJDYXNlKCksIFJGUTJfTVVNQkFJLnRvTG93ZXJDYXNlKCksIFJGUTNfTVVNQkFJLnRvTG93ZXJDYXNlKCldKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgcHJpY2luZyB0aGF0IGFsd2F5cyByZXR1cm5zIDE6MSB2MSBwcmljZXNcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0UHJpY2VWMUFzeW5jKHJlcTogZXhwcmVzcy5SZXF1ZXN0LCByZXM6IGV4cHJlc3MuUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gRHVtbXlNTUhhbmRsZXJzLl9wYXJzZVF1b3RlUmVxdWVzdChyZXEpO1xuICAgICAgICBjb25zdCB0b2tlblNldCA9IHRoaXMuX3Rva2VuU2V0QnlDaGFpbklkLmdldChOdW1iZXIocGFyYW1zLmNoYWluSWQpKTtcbiAgICAgICAgY29uc3QgeyBzZWxsVG9rZW5BZGRyZXNzLCBidXlUb2tlbkFkZHJlc3MsIHNlbGxBbW91bnRCYXNlVW5pdHMsIGJ1eUFtb3VudEJhc2VVbml0cywgaW50ZWdyYXRvcklkIH0gPSBwYXJhbXM7XG5cbiAgICAgICAgLy8gQ2hlY2sgaW50ZWdyYXRvclxuICAgICAgICBpZiAoIWludGVncmF0b3JJZCB8fCAhd2hpdGVsaXN0ZWRJbnRlZ3JhdG9ycy5oYXMoaW50ZWdyYXRvcklkKSkge1xuICAgICAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLkJBRF9SRVFVRVNUKS5zZW5kKCdJbnZhbGlkIGludGVncmF0b3IgaWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRva2Vuc1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdG9rZW5TZXQgfHxcbiAgICAgICAgICAgICF0b2tlblNldC5oYXMoc2VsbFRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB8fFxuICAgICAgICAgICAgIXRva2VuU2V0LmhhcyhidXlUb2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuTk9fQ09OVEVOVCkuc2VuZCh7fSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgYW1vdW50IChkaXJlY3Rpb24gZG9lc24ndCBtYXR0ZXIgYmVjYXVzZSBwcmljZSBpcyBhbHdheXMgMToxKVxuICAgICAgICBjb25zdCBpc1NlbGxpbmcgPSBzZWxsQW1vdW50QmFzZVVuaXRzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJhd0Ftb3VudCA9IChpc1NlbGxpbmcgPyBzZWxsQW1vdW50QmFzZVVuaXRzIDogYnV5QW1vdW50QmFzZVVuaXRzKSBhcyBzdHJpbmc7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IG5ldyBCaWdOdW1iZXIocmF3QW1vdW50KTtcblxuICAgICAgICAvLyBUb2tlbnNcbiAgICAgICAgY29uc3QgdGFrZXJUb2tlbiA9IHNlbGxUb2tlbkFkZHJlc3MgYXMgc3RyaW5nO1xuICAgICAgICBjb25zdCBtYWtlclRva2VuID0gYnV5VG9rZW5BZGRyZXNzIGFzIHN0cmluZztcblxuICAgICAgICAvLyBFeHBpcnlcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IEJpZ051bWJlcihEYXRlLm5vdygpKTtcbiAgICAgICAgY29uc3QgZml2ZU1pbkxhdGVyID0gbm93LnBsdXMobmV3IEJpZ051bWJlcig1KS50aW1lcyhPTkVfTUlOVVRFX01TKSkuZGl2KE9ORV9TRUNPTkRfTVMpLmludGVnZXJWYWx1ZSgpO1xuXG4gICAgICAgIGNvbnN0IGluZGljYXRpdmVRdW90ZSA9IHtcbiAgICAgICAgICAgIGV4cGlyeTogZml2ZU1pbkxhdGVyLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBtYWtlclRva2VuLFxuICAgICAgICAgICAgdGFrZXJUb2tlbixcbiAgICAgICAgICAgIG1ha2VyQW1vdW50OiBhbW91bnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHRha2VyQW1vdW50OiBhbW91bnQudG9TdHJpbmcoKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLk9LKS5zZW5kKGluZGljYXRpdmVRdW90ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgcHJpY2luZyB0aGF0IGFsd2F5cyByZXR1cm5zIDE6MSB2MiBwcmljZXNcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0UHJpY2VWMkFzeW5jKHJlcTogZXhwcmVzcy5SZXF1ZXN0LCByZXM6IGV4cHJlc3MuUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gRHVtbXlNTUhhbmRsZXJzLl9wYXJzZVF1b3RlUmVxdWVzdChyZXEpO1xuICAgICAgICBjb25zdCB0b2tlblNldCA9IHRoaXMuX3Rva2VuU2V0QnlDaGFpbklkLmdldChOdW1iZXIocGFyYW1zLmNoYWluSWQpKTtcbiAgICAgICAgY29uc3QgeyBzZWxsVG9rZW5BZGRyZXNzLCBidXlUb2tlbkFkZHJlc3MsIHNlbGxBbW91bnRCYXNlVW5pdHMsIGJ1eUFtb3VudEJhc2VVbml0cywgaW50ZWdyYXRvcklkIH0gPSBwYXJhbXM7XG5cbiAgICAgICAgLy8gQ2hlY2sgaW50ZWdyYXRvclxuICAgICAgICBpZiAoIWludGVncmF0b3JJZCB8fCAhd2hpdGVsaXN0ZWRJbnRlZ3JhdG9ycy5oYXMoaW50ZWdyYXRvcklkKSkge1xuICAgICAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLkJBRF9SRVFVRVNUKS5zZW5kKCdJbnZhbGlkIGludGVncmF0b3IgaWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRva2Vuc1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdG9rZW5TZXQgfHxcbiAgICAgICAgICAgICF0b2tlblNldC5oYXMoc2VsbFRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB8fFxuICAgICAgICAgICAgIXRva2VuU2V0LmhhcyhidXlUb2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuTk9fQ09OVEVOVCkuc2VuZCh7fSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgYW1vdW50IChkaXJlY3Rpb24gZG9lc24ndCBtYXR0ZXIgYmVjYXVzZSBwcmljZSBpcyBhbHdheXMgMToxKVxuICAgICAgICBjb25zdCBpc1NlbGxpbmcgPSBzZWxsQW1vdW50QmFzZVVuaXRzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJhd0Ftb3VudCA9IChpc1NlbGxpbmcgPyBzZWxsQW1vdW50QmFzZVVuaXRzIDogYnV5QW1vdW50QmFzZVVuaXRzKSBhcyBzdHJpbmc7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IG5ldyBCaWdOdW1iZXIocmF3QW1vdW50KTtcblxuICAgICAgICAvLyBUb2tlbnNcbiAgICAgICAgY29uc3QgdGFrZXJUb2tlbiA9IHNlbGxUb2tlbkFkZHJlc3MgYXMgc3RyaW5nO1xuICAgICAgICBjb25zdCBtYWtlclRva2VuID0gYnV5VG9rZW5BZGRyZXNzIGFzIHN0cmluZztcblxuICAgICAgICAvLyBFeHBpcnlcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IEJpZ051bWJlcihEYXRlLm5vdygpKTtcbiAgICAgICAgY29uc3QgZml2ZU1pbkxhdGVyID0gbm93LnBsdXMobmV3IEJpZ051bWJlcig1KS50aW1lcyhPTkVfTUlOVVRFX01TKSkuZGl2KE9ORV9TRUNPTkRfTVMpLmludGVnZXJWYWx1ZSgpO1xuXG4gICAgICAgIGNvbnN0IGluZGljYXRpdmVRdW90ZSA9IHtcbiAgICAgICAgICAgIGV4cGlyeTogZml2ZU1pbkxhdGVyLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBtYWtlclRva2VuLFxuICAgICAgICAgICAgdGFrZXJUb2tlbixcbiAgICAgICAgICAgIG1ha2VyQW1vdW50OiBhbW91bnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHRha2VyQW1vdW50OiBhbW91bnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIG1ha2VyOiBNTV9BRERSRVNTLFxuICAgICAgICB9O1xuICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuT0spLnNlbmQoaW5kaWNhdGl2ZVF1b3RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBxdW90aW5nIHRoYXQgYWx3YXlzIHNpZ25zIGFuIG9yZGVyIDE6MSBmb3IgUkZRTSB2MVxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRRdW90ZVYxQXN5bmMocmVxOiBleHByZXNzLlJlcXVlc3QsIHJlczogZXhwcmVzcy5SZXNwb25zZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBEdW1teU1NSGFuZGxlcnMuX3BhcnNlUXVvdGVSZXF1ZXN0KHJlcSk7XG4gICAgICAgIGNvbnN0IHRva2VuU2V0ID0gdGhpcy5fdG9rZW5TZXRCeUNoYWluSWQuZ2V0KE51bWJlcihwYXJhbXMuY2hhaW5JZCkpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBzZWxsVG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgYnV5VG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgc2VsbEFtb3VudEJhc2VVbml0cyxcbiAgICAgICAgICAgIGJ1eUFtb3VudEJhc2VVbml0cyxcbiAgICAgICAgICAgIHR4T3JpZ2luLFxuICAgICAgICAgICAgdGFrZXJBZGRyZXNzLFxuICAgICAgICAgICAgaW50ZWdyYXRvcklkLFxuICAgICAgICB9ID0gcGFyYW1zO1xuXG4gICAgICAgIC8vIENoZWNrIGludGVncmF0b3JcbiAgICAgICAgaWYgKCFpbnRlZ3JhdG9ySWQgfHwgIXdoaXRlbGlzdGVkSW50ZWdyYXRvcnMuaGFzKGludGVncmF0b3JJZCkpIHtcbiAgICAgICAgICAgIHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5CQURfUkVRVUVTVCkuc2VuZCgnSW52YWxpZCBpbnRlZ3JhdG9yIGlkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayB0b2tlbnNcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXRva2VuU2V0IHx8XG4gICAgICAgICAgICAhdG9rZW5TZXQuaGFzKHNlbGxUb2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgICAgICAgICF0b2tlblNldC5oYXMoYnV5VG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLk5PX0NPTlRFTlQpLnNlbmQoe30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGFtb3VudCAoZGlyZWN0aW9uIGRvZXNuJ3QgbWF0dGVyIGJlY2F1c2UgcHJpY2UgaXMgYWx3YXlzIDE6MSlcbiAgICAgICAgY29uc3QgaXNTZWxsaW5nID0gc2VsbEFtb3VudEJhc2VVbml0cyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCByYXdBbW91bnQgPSAoaXNTZWxsaW5nID8gc2VsbEFtb3VudEJhc2VVbml0cyA6IGJ1eUFtb3VudEJhc2VVbml0cykgYXMgc3RyaW5nO1xuICAgICAgICBjb25zdCBhbW91bnQgPSBuZXcgQmlnTnVtYmVyKHJhd0Ftb3VudCk7XG5cbiAgICAgICAgLy8gVG9rZW5zXG4gICAgICAgIGNvbnN0IHRha2VyVG9rZW4gPSBzZWxsVG9rZW5BZGRyZXNzIGFzIHN0cmluZztcbiAgICAgICAgY29uc3QgbWFrZXJUb2tlbiA9IGJ1eVRva2VuQWRkcmVzcyBhcyBzdHJpbmc7XG5cbiAgICAgICAgLy8gRW5mb3JjZSBhIDUgdW5pdCBtYXhpbXVtXG4gICAgICAgIGNvbnN0IG9uZVVuaXQgPSAxMCAqKiB0b2tlblRvRGVjaW1hbHNbdGFrZXJUb2tlbl07XG4gICAgICAgIGNvbnN0IGZpdmVVbml0cyA9IG9uZVVuaXQgKiA1O1xuICAgICAgICBpZiAoYW1vdW50Lmd0KGZpdmVVbml0cykpIHtcbiAgICAgICAgICAgIHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5OT19DT05URU5UKS5zZW5kKHt9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4cGlyeVxuICAgICAgICBjb25zdCBub3cgPSBuZXcgQmlnTnVtYmVyKERhdGUubm93KCkpO1xuICAgICAgICBjb25zdCBmaXZlTWluTGF0ZXIgPSBub3cucGx1cyhuZXcgQmlnTnVtYmVyKDUpLnRpbWVzKE9ORV9NSU5VVEVfTVMpKS5kaXYoT05FX1NFQ09ORF9NUykuaW50ZWdlclZhbHVlKCk7XG5cbiAgICAgICAgY29uc3QgcmZxT3JkZXIgPSBuZXcgUmZxT3JkZXIoe1xuICAgICAgICAgICAgdHhPcmlnaW4sXG4gICAgICAgICAgICB0YWtlcjogdGFrZXJBZGRyZXNzLFxuICAgICAgICAgICAgbWFrZXI6IE1NX0FERFJFU1MsXG4gICAgICAgICAgICB0YWtlclRva2VuLFxuICAgICAgICAgICAgbWFrZXJUb2tlbixcbiAgICAgICAgICAgIG1ha2VyQW1vdW50OiBuZXcgQmlnTnVtYmVyKGFtb3VudC50b1N0cmluZygpKSxcbiAgICAgICAgICAgIHRha2VyQW1vdW50OiBuZXcgQmlnTnVtYmVyKGFtb3VudC50b1N0cmluZygpKSxcbiAgICAgICAgICAgIGV4cGlyeTogZml2ZU1pbkxhdGVyLFxuICAgICAgICAgICAgY2hhaW5JZDogTnVtYmVyKHBhcmFtcy5jaGFpbklkKSxcbiAgICAgICAgICAgIHNhbHQ6IG5vdyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgb3JkZXJIYXNoID0gcmZxT3JkZXIuZ2V0SGFzaCgpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBldGhTaWduSGFzaFdpdGhLZXkob3JkZXJIYXNoLCBNTV9QUklWQVRFX0tFWSk7XG5cbiAgICAgICAgY29uc3QgZmlybVF1b3RlID0ge1xuICAgICAgICAgICAgc2lnbmVkT3JkZXI6IHtcbiAgICAgICAgICAgICAgICAuLi5yZnFPcmRlcixcbiAgICAgICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuT0spLnNlbmQoZmlybVF1b3RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBxdW90aW5nIGZvciBSRlF0IHYyIHRoYXQgc2lnbnMgZXZlbiB0YWtlciBhbW91bnRzLCBidXQgcmVmdXNlcyB0byBzaWduIG9kZCB0YWtlciBhbW91bnRzLCBpZ25vcmluZyBkZWNpbWFscy5cbiAgICAgKiBUaGUgbWF4IHRyYWRpbmcgc2l6ZSBpcyAyIHRva2Vucy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgZm9yIFdFVEg6XG4gICAgICogLSAxLjAwMF8wMDBfMDAwXzAwMF8wMDBfMDAwIGlzIGNvbnNpZGVyZWQgb2RkIVxuICAgICAqIC0gMi4wMDBfMDAwXzAwMF8wMDBfMDAwXzAwMSBpcyBjb25zaWRlcmVkIGV2ZW4hXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGdldFF1b3RlUmZxdFYyQXN5bmMocmVxOiBleHByZXNzLlJlcXVlc3QsIHJlczogZXhwcmVzcy5SZXNwb25zZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBEdW1teU1NSGFuZGxlcnMuX3BhcnNlUXVvdGVSZXF1ZXN0KHJlcSk7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSBOdW1iZXIocGFyYW1zLmNoYWluSWQpO1xuICAgICAgICBjb25zdCB0b2tlblNldCA9IHRoaXMuX3Rva2VuU2V0QnlDaGFpbklkLmdldChjaGFpbklkKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgc2VsbFRva2VuQWRkcmVzcyxcbiAgICAgICAgICAgIGJ1eVRva2VuQWRkcmVzcyxcbiAgICAgICAgICAgIHNlbGxBbW91bnRCYXNlVW5pdHMsXG4gICAgICAgICAgICBidXlBbW91bnRCYXNlVW5pdHMsXG4gICAgICAgICAgICB0eE9yaWdpbixcbiAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcbiAgICAgICAgICAgIGludGVncmF0b3JJZCxcbiAgICAgICAgICAgIGZlZUFtb3VudCxcbiAgICAgICAgfSA9IHBhcmFtcztcblxuICAgICAgICAvLyBDaGVjayBpbnRlZ3JhdG9yXG4gICAgICAgIGlmICghaW50ZWdyYXRvcklkIHx8ICF3aGl0ZWxpc3RlZEludGVncmF0b3JzLmhhcyhpbnRlZ3JhdG9ySWQpKSB7XG4gICAgICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuQkFEX1JFUVVFU1QpLnNlbmQoJ0ludmFsaWQgaW50ZWdyYXRvciBpZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgdG9rZW5zXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICF0b2tlblNldCB8fFxuICAgICAgICAgICAgIXRva2VuU2V0LmhhcyhzZWxsVG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICAgICAgICAhdG9rZW5TZXQuaGFzKGJ1eVRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5OT19DT05URU5UKS5zZW5kKGBObyBsaXF1aWRpdHkgZm9yICR7c2VsbFRva2VuQWRkcmVzc306JHtidXlUb2tlbkFkZHJlc3N9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgYW1vdW50IChkaXJlY3Rpb24gZG9lc24ndCBtYXR0ZXIgYmVjYXVzZSBwcmljZSBpcyBhbHdheXMgMToxKVxuICAgICAgICBjb25zdCBpc1NlbGxpbmcgPSBzZWxsQW1vdW50QmFzZVVuaXRzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJhd0Ftb3VudCA9IChpc1NlbGxpbmcgPyBzZWxsQW1vdW50QmFzZVVuaXRzIDogYnV5QW1vdW50QmFzZVVuaXRzKSBhcyBzdHJpbmc7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IG5ldyBCaWdOdW1iZXIocmF3QW1vdW50KTtcblxuICAgICAgICAvLyBUb2tlbnNcbiAgICAgICAgY29uc3QgdGFrZXJUb2tlbiA9IHNlbGxUb2tlbkFkZHJlc3MgYXMgc3RyaW5nO1xuICAgICAgICBjb25zdCBtYWtlclRva2VuID0gYnV5VG9rZW5BZGRyZXNzIGFzIHN0cmluZztcblxuICAgICAgICBjb25zdCBkZWNpbWFscyA9IHRva2VuVG9EZWNpbWFsc1t0YWtlclRva2VuXTtcbiAgICAgICAgLy8gRW5mb3JjZSBhIDIgdW5pdHMgbWF4aW11bSBmb3IgdHJhZGluZ1xuICAgICAgICBjb25zdCBvbmVVbml0ID0gMTAgKiogZGVjaW1hbHM7XG4gICAgICAgIGlmIChhbW91bnQuZ3Qob25lVW5pdCAqIDIpKSB7XG4gICAgICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuTk9fQ09OVEVOVCkuc2VuZCgnVHJhZGluZyBsaW1pdCBmb3IgYnV5L3NlbGwgdG9rZW5zIHNob3VsZCBub3QgZXhjZWVkIDInKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzRXZlbiA9IGFtb3VudFxuICAgICAgICAgICAgLmRpdigxMCAqKiBkZWNpbWFscylcbiAgICAgICAgICAgIC5pbnRlZ2VyVmFsdWUoKVxuICAgICAgICAgICAgLm1vZCgyKVxuICAgICAgICAgICAgLmVxKDApO1xuXG4gICAgICAgIC8vIFJlamVjdFxuICAgICAgICBpZiAoIWlzRXZlbikge1xuICAgICAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLk5PX0NPTlRFTlQpLnNlbmQoe30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhwaXJ5IGFuZCBub25jZVxuICAgICAgICBjb25zdCBub3cgPSBuZXcgQmlnTnVtYmVyKERhdGUubm93KCkpO1xuICAgICAgICBjb25zdCBleHBpcnkgPSBub3cucGx1cyhuZXcgQmlnTnVtYmVyKDUpLnRpbWVzKE9ORV9NSU5VVEVfTVMpKS5kaXYoT05FX1NFQ09ORF9NUykuaW50ZWdlclZhbHVlKCk7XG4gICAgICAgIGNvbnN0IG5vd1NlY29uZHMgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyBPTkVfU0VDT05EX01TKTtcblxuICAgICAgICAvLyBHZXQgRXhjaGFuZ2UgUHJveHkgY29udHJhY3QgYWRkcmVzc1xuICAgICAgICBjb25zdCBleGNoYW5nZVByb3h5Q29udHJhY3RBZGRyZXNzOiBzdHJpbmcgPSBnZXRDb250cmFjdEFkZHJlc3Nlc0ZvckNoYWluT3JUaHJvdyhjaGFpbklkKS5leGNoYW5nZVByb3h5O1xuXG4gICAgICAgIGNvbnN0IG90Y09yZGVyID0gbmV3IE90Y09yZGVyKHtcbiAgICAgICAgICAgIHR4T3JpZ2luLFxuICAgICAgICAgICAgZXhwaXJ5QW5kTm9uY2U6IE90Y09yZGVyLmVuY29kZUV4cGlyeUFuZE5vbmNlKFxuICAgICAgICAgICAgICAgIGV4cGlyeSxcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKFJGUVRfTk9OQ0VfQlVDS0VUKSxcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKG5vd1NlY29uZHMpLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHRha2VyVG9rZW4sXG4gICAgICAgICAgICBtYWtlclRva2VuLFxuICAgICAgICAgICAgbWFrZXJBbW91bnQ6IGFtb3VudCxcbiAgICAgICAgICAgIHRha2VyQW1vdW50OiBhbW91bnQsXG4gICAgICAgICAgICBtYWtlcjogTU1fQUREUkVTUyxcbiAgICAgICAgICAgIHRha2VyOiB0YWtlckFkZHJlc3MsXG4gICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGV4Y2hhbmdlUHJveHlDb250cmFjdEFkZHJlc3MsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG9yZGVySGFzaCA9IG90Y09yZGVyLmdldEhhc2goKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZXRoU2lnbkhhc2hXaXRoS2V5KG9yZGVySGFzaCwgTU1fUFJJVkFURV9LRVkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIGZlZUFtb3VudCxcbiAgICAgICAgICAgIG9yZGVyOiBvdGNPcmRlcixcbiAgICAgICAgICAgIG9yZGVySGFzaCxcbiAgICAgICAgICAgIG1ha2VyU2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLk9LKS5zZW5kKHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHByb3ZlcyBldmVuIGFtb3VudHMgYW5kIHJlamVjdHMgb2RkIGFtb3VudHMsIGlnbm9yaW5nIGRlY2ltYWxzXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIGZvciBXRVRIOlxuICAgICAqIC0gMS4wMDBfMDAwXzAwMF8wMDBfMDAwXzAwMCBpcyBjb25zaWRlcmVkIG9kZCFcbiAgICAgKiAtIDIuMDAwXzAwMF8wMDBfMDAwXzAwMF8wMDEgaXMgY29uc2lkZXJlZCBldmVuIVxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBzdWJtaXRBc3luYyhyZXE6IGV4cHJlc3MuUmVxdWVzdCwgcmVzOiBleHByZXNzLlJlc3BvbnNlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSBEdW1teU1NSGFuZGxlcnMuX3BhcnNlU3VibWl0UmVxdWVzdChyZXEpO1xuICAgICAgICBjb25zdCB7IG9yZGVyLCBmZWUsIG9yZGVySGFzaCwgdGFrZXJUb2tlbkZpbGxBbW91bnQgfSA9IHJlcXVlc3RQYXJhbXM7XG4gICAgICAgIGNvbnN0IGRlY2ltYWxzID0gdG9rZW5Ub0RlY2ltYWxzW29yZGVyLnRha2VyVG9rZW5dO1xuXG4gICAgICAgIGNvbnN0IGlzRXZlbiA9IG9yZGVyLnRha2VyQW1vdW50XG4gICAgICAgICAgICAuZGl2KDEwICoqIGRlY2ltYWxzKVxuICAgICAgICAgICAgLmludGVnZXJWYWx1ZSgpXG4gICAgICAgICAgICAubW9kKDIpXG4gICAgICAgICAgICAuZXEoMCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgZmVlLFxuICAgICAgICAgICAgcHJvY2VlZFdpdGhGaWxsOiBpc0V2ZW4sXG4gICAgICAgICAgICBzaWduZWRPcmRlckhhc2g6IG9yZGVySGFzaCxcbiAgICAgICAgICAgIHRha2VyVG9rZW5GaWxsQW1vdW50OiB0YWtlclRva2VuRmlsbEFtb3VudC50b1N0cmluZygpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5PSykuc2VuZChyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwcm92ZXMgZXZlbiBhbW91bnRzIGFuZCByZWplY3RzIG9kZCBhbW91bnRzLCBpZ25vcmluZyBkZWNpbWFsc1xuICAgICAqXG4gICAgICogRXhhbXBsZSBmb3IgV0VUSDpcbiAgICAgKiAtIDEuMDAwXzAwMF8wMDBfMDAwXzAwMF8wMDAgaXMgY29uc2lkZXJlZCBvZGQhXG4gICAgICogLSAyLjAwMF8wMDBfMDAwXzAwMF8wMDBfMDAxIGlzIGNvbnNpZGVyZWQgZXZlbiFcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgc2lnblJmcW1WMkFzeW5jKHJlcTogZXhwcmVzcy5SZXF1ZXN0LCByZXM6IGV4cHJlc3MuUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IER1bW15TU1IYW5kbGVycy5fcGFyc2VTaWduUmZxbVJlcXVlc3QocmVxKTtcbiAgICAgICAgY29uc3QgeyBvcmRlciwgZmVlQW1vdW50LCBvcmRlckhhc2ggfSA9IHJlcXVlc3RQYXJhbXM7XG4gICAgICAgIGNvbnN0IGRlY2ltYWxzID0gdG9rZW5Ub0RlY2ltYWxzW29yZGVyLnRha2VyVG9rZW5dO1xuXG4gICAgICAgIGNvbnN0IGlzRXZlbiA9IG9yZGVyLnRha2VyQW1vdW50XG4gICAgICAgICAgICAuZGl2KDEwICoqIGRlY2ltYWxzKVxuICAgICAgICAgICAgLmludGVnZXJWYWx1ZSgpXG4gICAgICAgICAgICAubW9kKDIpXG4gICAgICAgICAgICAuZXEoMCk7XG5cbiAgICAgICAgLy8gUmVqZWN0XG4gICAgICAgIGlmICghaXNFdmVuKSB7XG4gICAgICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuT0spLnNlbmQoe1xuICAgICAgICAgICAgICAgIHByb2NlZWRXaXRoRmlsbDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjY2VwdCBhbmQgc2lnblxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBldGhTaWduSGFzaFdpdGhLZXkob3JkZXJIYXNoLCBNTV9QUklWQVRFX0tFWSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgZmVlQW1vdW50LFxuICAgICAgICAgICAgcHJvY2VlZFdpdGhGaWxsOiBpc0V2ZW4sXG4gICAgICAgICAgICBtYWtlclNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5PSykuc2VuZChyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2lnbnMgZm9yIGV2ZW4gdGFrZXIgYW1vdW50cywgYnV0IHJlZnVzZXMgb2RkIHRha2VyIGFtb3VudHMsIGlnbm9yaW5nIGRlY2ltYWxzLiBUaGUgbG9naWMgaXMgdmVyeSBzaW1pbGFyIHRvXG4gICAgICogYHNpZ25SZnFtVjJBc3luY2AgZm9yIGNvbnNpc3RlbmN5LlxuICAgICAqXG4gICAgICogRXhhbXBsZSBmb3IgV0VUSDpcbiAgICAgKiAtIDEuMDAwXzAwMF8wMDBfMDAwXzAwMF8wMDAgaXMgY29uc2lkZXJlZCBvZGQhXG4gICAgICogLSAyLjAwMF8wMDBfMDAwXzAwMF8wMDBfMDAxIGlzIGNvbnNpZGVyZWQgZXZlbiFcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgc2lnblJmcXRWMkFzeW5jKHJlcTogZXhwcmVzcy5SZXF1ZXN0LCByZXM6IGV4cHJlc3MuUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IER1bW15TU1IYW5kbGVycy5fcGFyc2VTaWduUmZxdFJlcXVlc3QocmVxKTtcbiAgICAgICAgY29uc3QgeyBvcmRlciwgZmVlQW1vdW50LCBvcmRlckhhc2g6IG9yZGVySGFzaFBhcmFtIH0gPSByZXF1ZXN0UGFyYW1zO1xuICAgICAgICBjb25zdCBvcmRlckhhc2ggPSBvcmRlci5nZXRIYXNoKCk7XG4gICAgICAgIGNvbnN0IHRva2VuU2V0ID0gdGhpcy5fdG9rZW5TZXRCeUNoYWluSWQuZ2V0KE51bWJlcihyZXF1ZXN0UGFyYW1zLm9yZGVyLmNoYWluSWQpKTtcblxuICAgICAgICAvLyBDaGVjayBvcmRlciBoYXNoIGNvbXB1dGVkIGZyb20gb3JkZXIgaXMgdGhlIHNhbWUgYXMgb3JkZXIgaGFzaCBpbiBxdWVyeSBwYXJhbVxuICAgICAgICBpZiAob3JkZXJIYXNoICE9PSBvcmRlckhhc2hQYXJhbSkge1xuICAgICAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLkJBRF9SRVFVRVNUKS5zZW5kKFxuICAgICAgICAgICAgICAgIGBvcmRlckhhc2ggcXVlcnkgcGFyYW0gcHJvdmlkZWQgJHtvcmRlckhhc2hQYXJhbX0gaXMgbm90IGVxdWFsIHRvIHRoZSBhY3R1YWwgb3JkZXIgaGFzaCAke29yZGVySGFzaH1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRva2Vuc1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdG9rZW5TZXQgfHxcbiAgICAgICAgICAgICF0b2tlblNldC5oYXMob3JkZXIubWFrZXJUb2tlbi50b0xvd2VyQ2FzZSgpKSB8fFxuICAgICAgICAgICAgIXRva2VuU2V0LmhhcyhvcmRlci50YWtlclRva2VuLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLk5PX0NPTlRFTlQpLnNlbmQoYE5vIGxpcXVpZGl0eSBmb3IgJHtvcmRlci5tYWtlclRva2VufToke29yZGVyLnRha2VyVG9rZW59YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZWNpbWFscyA9IHRva2VuVG9EZWNpbWFsc1tvcmRlci50YWtlclRva2VuXTtcbiAgICAgICAgY29uc3QgaXNFdmVuID0gb3JkZXIudGFrZXJBbW91bnRcbiAgICAgICAgICAgIC5kaXYoMTAgKiogZGVjaW1hbHMpXG4gICAgICAgICAgICAuaW50ZWdlclZhbHVlKClcbiAgICAgICAgICAgIC5tb2QoMilcbiAgICAgICAgICAgIC5lcSgwKTtcblxuICAgICAgICAvLyBSZWplY3RcbiAgICAgICAgaWYgKCFpc0V2ZW4pIHtcbiAgICAgICAgICAgIHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5OT19DT05URU5UKS5zZW5kKHt9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlZnVzZSB0byBzaWduXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGV0aFNpZ25IYXNoV2l0aEtleShvcmRlckhhc2gsIE1NX1BSSVZBVEVfS0VZKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICBmZWVBbW91bnQsXG4gICAgICAgICAgICBtYWtlclNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5PSykuc2VuZChyZXNwb25zZSk7XG4gICAgfVxufVxuIl0sInZlcnNpb24iOjN9