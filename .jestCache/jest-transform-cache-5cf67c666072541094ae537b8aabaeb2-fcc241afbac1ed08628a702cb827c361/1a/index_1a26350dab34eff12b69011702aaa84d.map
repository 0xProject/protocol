{"file":"/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts","mappings":";;;;;;;;;;;;;;;;;AAsCA,IAAY,YAIX;AAJD,WAAY,YAAY;IACpB,mDAAmC,CAAA;IACnC,wDAAwC,CAAA;IACxC,gCAAgB,CAAA;AACpB,CAAC,EAJW,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAIvB;AAED;;;;GAIG;AACH,IAAY,oBAIX;AAJD,WAAY,oBAAoB;IAC5B,kFAA0D,CAAA;IAC1D,yCAAiB,CAAA;IACjB,+CAAuB,CAAA;AAC3B,CAAC,EAJW,oBAAoB,GAApB,4BAAoB,KAApB,4BAAoB,QAI/B;AAuID,IAAY,kBA0BX;AA1BD,WAAY,kBAAkB;IAC1B,qHAAqH;IACrH,0DAA0D;IAC1D,qCAAe,CAAA;IACf,6GAA6G;IAC7G,uCAAiB,CAAA;IACjB,+GAA+G;IAC/G,kDAA4B,CAAA;IAC5B,qDAAqD;IACrD,6CAAuB,CAAA;IACvB,+CAA+C;IAC/C,yCAAmB,CAAA;IACnB,+DAA+D;IAC/D,yCAAmB,CAAA;IACnB,mHAAmH;IACnH,6CAAuB,CAAA;IACvB,qIAAqI;IACrI,2CAAqB,CAAA;IACrB,wIAAwI;IACxI,6DAA6D;IAC7D,oEAA8C,CAAA;IAC9C,oFAAoF;IACpF,6GAA6G;IAC7G,wGAAwG;IACxG,UAAU;IACV,0DAAoC,CAAA;AACxC,CAAC,EA1BW,kBAAkB,GAAlB,0BAAkB,KAAlB,0BAAkB,QA0B7B;AAED,iDAA+B;AAC/B,yCAAuB","names":[],"sources":["/Users/davidwalsh/code-local/0x-rfq-api/src/core/types/index.ts"],"sourcesContent":["import { OtcOrder, Signature } from '@0x/protocol-utils';\nimport { MarketOperation } from '@0x/types';\nimport { BigNumber } from '@0x/utils';\n\nexport type RequireOnlyOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n    {\n        [K in Keys]-?: Required<Pick<T, K>> & Partial<Record<Exclude<Keys, K>, undefined>>;\n    }[Keys];\n\nexport interface IndicativeQuote {\n    maker: string;\n    makerUri: string;\n    makerToken: string;\n    takerToken: string;\n    makerAmount: BigNumber;\n    takerAmount: BigNumber;\n    expiry: BigNumber;\n}\n\n/**\n * FirmOtcQuote is a quote for an OtcOrder. The makerSignature may not be present if the maker gets\n * the \"last look\" (RFQm).\n */\nexport interface FirmOtcQuote {\n    kind: 'otc';\n    makerUri: string;\n    order: OtcOrder;\n    makerSignature?: Signature;\n}\n\n/**\n * ERC20Owner is an address-token pair used to perform balance checks.\n */\nexport interface ERC20Owner {\n    owner: string;\n    token: string;\n}\n\nexport enum GaslessTypes {\n    MetaTransaction = 'metatransaction',\n    MetaTransactionV2 = 'metatransaction_v2',\n    OtcOrder = 'otc',\n}\n\n/**\n * Approval is an object that encapsulates the EIP-712 context that will eventually be signed by takers\n * for gasless approvals. There are multiple flavors of these approval objects, which can be distinguished\n * by their `kind`\n */\nexport enum GaslessApprovalTypes {\n    ExecuteMetaTransaction = 'executeMetaTransaction::approve',\n    Permit = 'permit',\n    DaiPermit = 'daiPermit',\n}\n\nexport type Approval = ExecuteMetaTransactionApproval | PermitApproval;\nexport interface ExecuteMetaTransactionApproval {\n    kind: GaslessApprovalTypes.ExecuteMetaTransaction;\n    eip712: ExecuteMetaTransactionEip712Context;\n}\n\nexport interface PermitApproval {\n    kind: GaslessApprovalTypes.Permit;\n    eip712: PermitEip712Context;\n}\nexport interface ExecuteMetaTransactionEip712Context {\n    types: ExecuteMetaTransactionEip712Types;\n    primaryType: 'MetaTransaction';\n    domain: Eip712Domain;\n    message: {\n        nonce: number;\n        from: string;\n        functionSignature: string;\n    };\n}\n\nexport interface PermitEip712Context {\n    types: PermitEip712Types;\n    primaryType: 'Permit';\n    domain: Eip712Domain;\n    message: {\n        owner: string;\n        spender: string;\n        value: string;\n        nonce: number;\n        deadline: string;\n    };\n}\n\nexport interface ExecuteMetaTransactionEip712Types {\n    EIP712Domain: Eip712DataField[];\n    MetaTransaction: Eip712DataField[];\n}\nexport interface PermitEip712Types {\n    EIP712Domain: Eip712DataField[];\n    Permit: Eip712DataField[];\n}\n\nexport interface Eip712Domain {\n    name?: string;\n    version?: string;\n    chainId?: number;\n    verifyingContract?: string;\n    salt?: string;\n}\n\nexport interface Eip712DataField {\n    name: string;\n    type: string;\n}\n\n/**\n * Parameters for the request from 0x API\n * to 0x RFQ api for the RFQt v2 `prices` endpoint\n */\nexport interface RfqtV2Request {\n    assetFillAmount: BigNumber;\n    chainId: number;\n    gasless?: boolean; // whether or not the request is for gasless RFQt\n    integratorId: string;\n    intentOnFilling: boolean;\n    makerToken: string;\n    marketOperation: MarketOperation;\n    takerAddress: string; // expect this to be NULL_ADDRESS\n    takerToken: string;\n    trader?: string; // this is the actual trader. Optional only during Gasless RFQt rollout. Intent is to be required in the long term\n    txOrigin?: string; // expect this to be the taker address, except for gasless RFQt where it will be the registry, can be missing for /price but not /quote\n    bucket?: number;\n}\n\n/**\n * Format of response payload which is sent to 0x API\n * from 0x RFQ API for the RFQt v2 `prices` endpoint\n */\nexport type RfqtV2Price = {\n    expiry: BigNumber;\n    makerAddress: string;\n    makerAmount: BigNumber;\n    makerId: string;\n    makerToken: string;\n    makerUri: string;\n    takerAmount: BigNumber;\n    takerToken: string;\n};\n\n/**\n * Format of response payload which is sent to 0x API\n * from 0x RFQ API for the RFQt v2 `quotes` endpoint\n */\nexport type RfqtV2Quote = {\n    fillableMakerAmount: BigNumber;\n    fillableTakerAmount: BigNumber;\n    fillableTakerFeeAmount: BigNumber;\n    makerId: string;\n    makerUri: string;\n    order: OtcOrder;\n    signature: Signature;\n};\n\nexport type QuoteServerPriceParams = RequireOnlyOne<\n    {\n        buyAmountBaseUnits?: string;\n        buyTokenAddress: string;\n        chainId?: string; // TODO - make this required after the rollout\n        comparisonPrice?: string;\n        feeAmount?: string;\n        feeToken?: string;\n        feeType?: string;\n        isLastLook?: string;\n        integratorId?: string;\n        nonce?: string;\n        nonceBucket?: string;\n        protocolVersion?: string;\n        sellAmountBaseUnits?: string;\n        sellTokenAddress: string;\n        takerAddress: string;\n        trader?: string;\n        txOrigin?: string;\n        worflow?: string;\n    },\n    'sellAmountBaseUnits' | 'buyAmountBaseUnits'\n>;\nexport interface TokenMetadata {\n    symbol: string;\n    decimals: number;\n    tokenAddress: string;\n}\n\nexport enum OrderEventEndState {\n    // The order was successfully validated and added to the Mesh node. The order is now being watched and any changes to\n    // the fillability will result in subsequent order events.\n    Added = 'ADDED',\n    // The order was filled for a partial amount. The order is still fillable up to the fillableTakerAssetAmount.\n    Filled = 'FILLED',\n    // The order was fully filled and its remaining fillableTakerAssetAmount is 0. The order is no longer fillable.\n    FullyFilled = 'FULLY_FILLED',\n    // The order was cancelled and is no longer fillable.\n    Cancelled = 'CANCELLED',\n    // The order expired and is no longer fillable.\n    Expired = 'EXPIRED',\n    // Catch all 'Invalid' state when invalid orders are submitted.\n    Invalid = 'INVALID',\n    // The order was previously expired, but due to a block re-org it is no longer considered expired (should be rare).\n    Unexpired = 'UNEXPIRED',\n    // The order has become unfunded and is no longer fillable. This can happen if the maker makes a transfer or changes their allowance.\n    Unfunded = 'UNFUNDED',\n    // The fillability of the order has increased. This can happen if a previously processed fill event gets reverted due to a block re-org,\n    // or if a maker makes a transfer or changes their allowance.\n    FillabilityIncreased = 'FILLABILITY_INCREASED',\n    // The order is potentially still valid but was removed for a different reason (e.g.\n    // the database is full or the peer that sent the order was misbehaving). The order will no longer be watched\n    // and no further events for this order will be emitted. In some cases, the order may be re-added in the\n    // future.\n    StoppedWatching = 'STOPPED_WATCHING',\n}\n\nexport * from './assetSwapper';\nexport * from './fees';\n\n// tslint:disable-line:max-file-line-count\n"],"version":3}