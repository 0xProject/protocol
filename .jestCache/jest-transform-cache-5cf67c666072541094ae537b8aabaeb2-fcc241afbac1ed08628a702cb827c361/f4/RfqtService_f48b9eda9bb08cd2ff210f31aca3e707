3f692f44e8e71f57358b28984e718afb
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RfqtService = void 0;
const orders_1 = require("@0x/protocol-utils/lib/src/orders");
const token_metadata_1 = require("@0x/token-metadata");
const utils_1 = require("@0x/utils");
const constants_1 = require("../core/constants");
const fee_utils_1 = require("../core/fee_utils");
const logger_1 = require("../logger");
const number_utils_1 = require("../utils/number_utils");
const quote_report_utils_1 = require("../utils/quote_report_utils");
const RfqtQuoteValidator_1 = require("../utils/RfqtQuoteValidator");
const signature_utils_1 = require("../utils/signature_utils");
const getTokenAddressFromSymbol = (symbol, chainId) => {
    return (0, token_metadata_1.getTokenMetadataIfExists)(symbol, chainId).tokenAddress;
};
/**
 * Converts the parameters of an RFQt v2 prices request from 0x API
 * into the format needed for `QuoteServerClient` to call the market makers
 */
function transformRfqtV2PricesParameters(p, fee, chainId) {
    const buyTokenAddress = p.makerToken;
    const sellTokenAddress = p.takerToken;
    // Typescript gymnastics with `baseUnits` to caputure the "oneof" nature--
    // By packaging them in their own little object, the type becomes:
    //
    // { buyAmountBaseUnits: BigNumber, sellAmountBaseUnits: undefined } |
    // { buyAmountBaseUnits: undefined, sellAmountBaseUnits: BigNumber }
    //
    // This is different from not packaging them together, where the types would be:
    //
    // buyAmountBaseUnits: BigNumber | undefined
    // sellAmountBaseUnits: BigNumber | undefined
    const baseUnits = p.isSelling === false
        ? {
            buyAmountBaseUnits: p.assetFillAmount,
            sellAmountBaseUnits: undefined,
        }
        : {
            // This is a SELL
            buyAmountBaseUnits: undefined,
            sellAmountBaseUnits: p.assetFillAmount,
        };
    const mmRequestParameters = {
        ...baseUnits,
        buyTokenAddress,
        sellTokenAddress,
        chainId,
        feeAmount: fee.amount,
        feeToken: fee.token,
        integratorId: p.integrator.integratorId,
        takerAddress: p.takerAddress,
        txOrigin: p.txOrigin,
        // trader: p.trader,
        // workflow: p.workflow,
        protocolVersion: '4', //hardcode - will break some MMs if missing!
    };
    // Convert mmRequestParameters values to strings
    const stringParameters = ((o) => {
        return Object.keys(o).reduce((result, key) => {
            const value = o[key];
            if (value !== undefined && value.toString) {
                const stringValue = value.toString();
                result[key] = stringValue;
            }
            return result;
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }, {});
    })(mmRequestParameters);
    return stringParameters;
}
/**
 * Contains the logic to handle RFQT Trades.
 *
 * `"v1"` functions support `MetaTransaction` trades while
 * `"v2"` functions (will) support `OtcOrder` trades.
 *
 * `v1` relies heavily on `QuoteRequestor` which has been copied over
 * from `0x/asset-swapper`.
 */
class RfqtService {
    constructor(_chainId, _rfqMakerManager, 
    // Used for RFQt v1 requests
    _quoteRequestor, 
    // Used for RFQt v2 requests
    _quoteServerClient, _minExpiryDurationMs, _blockchainUtils, _tokenMetadataManager, _contractAddresses, _feeService, _feeModelVersion, _rfqMakerBalanceCacheService, _cacheClient, _kafkaProducer, _feeEventTopic) {
        this._chainId = _chainId;
        this._rfqMakerManager = _rfqMakerManager;
        this._quoteRequestor = _quoteRequestor;
        this._quoteServerClient = _quoteServerClient;
        this._minExpiryDurationMs = _minExpiryDurationMs;
        this._blockchainUtils = _blockchainUtils;
        this._tokenMetadataManager = _tokenMetadataManager;
        this._contractAddresses = _contractAddresses;
        this._feeService = _feeService;
        this._feeModelVersion = _feeModelVersion;
        this._rfqMakerBalanceCacheService = _rfqMakerBalanceCacheService;
        this._cacheClient = _cacheClient;
        this._kafkaProducer = _kafkaProducer;
        this._feeEventTopic = _feeEventTopic;
        this._nativeTokenSymbol = (0, token_metadata_1.nativeTokenSymbol)(this._chainId);
        this._nativeTokenAddress = getTokenAddressFromSymbol(this._nativeTokenSymbol, this._chainId);
        this._nativeWrappedTokenSymbol = (0, token_metadata_1.nativeWrappedTokenSymbol)(this._chainId);
        this._nativeWrappedTokenAddress = getTokenAddressFromSymbol(this._nativeWrappedTokenSymbol, this._chainId);
    }
    /**
     * Pass through to `QuoteRequestor::requestRfqtIndicativeQuotesAsync` to fetch
     * indicative quotes from market makers.
     *
     * Note that by this point, 0x API should be sending the null address
     * as the `takerAddress` and the taker's address as the `txOrigin`.
     */
    async getV1PricesAsync(parameters) {
        const { altRfqAssetOfferings, assetFillAmount, comparisonPrice, integrator, intentOnFilling, // tslint:disable-line boolean-naming
        makerToken, marketOperation, takerAddress, takerToken, txOrigin, } = parameters;
        return this._quoteRequestor.requestRfqtIndicativeQuotesAsync(makerToken, takerToken, assetFillAmount, marketOperation, comparisonPrice, {
            altRfqAssetOfferings,
            integrator,
            intentOnFilling,
            isIndicative: true,
            isLastLook: false,
            makerEndpointMaxResponseTimeMs: 600,
            takerAddress,
            txOrigin: txOrigin || constants_1.NULL_ADDRESS,
        });
    }
    /**
     * Pass through to `QuoteRequestor::requestRfqtFirmQuotesAsync` to fetch
     * firm quotes from market makers.
     *
     * Note that by this point, 0x API should be sending the null address
     * as the `takerAddress` and the taker's address as the `txOrigin`.
     */
    async getV1QuotesAsync(parameters) {
        const { altRfqAssetOfferings, assetFillAmount, comparisonPrice, integrator, intentOnFilling, // tslint:disable-line boolean-naming
        makerToken, marketOperation, takerAddress, takerToken, txOrigin, } = parameters;
        const quotes = await this._quoteRequestor.requestRfqtFirmQuotesAsync(makerToken, takerToken, assetFillAmount, marketOperation, comparisonPrice, {
            altRfqAssetOfferings,
            integrator,
            intentOnFilling,
            isIndicative: false,
            isLastLook: false,
            makerEndpointMaxResponseTimeMs: 600,
            takerAddress,
            txOrigin,
        });
        return quotes.map((q) => {
            return {
                ...q,
                makerUri: this._quoteRequestor.getMakerUriForSignature(q.signature),
            };
        });
    }
    /**
     * Accepts data sent by 0x API and fetches prices from Market Makers
     * configured on the given pair.
     *
     * Note that by this point, 0x API should be sending the null address
     * as the `takerAddress` and the taker's address as the `txOrigin`.
     */
    async getV2PricesAsync(quoteContext, now = new Date()) {
        const { feeWithDetails: fee } = await this._feeService.calculateFeeAsync(quoteContext);
        return this._getV2PricesInternalAsync(quoteContext, fee, now);
    }
    /**
     * Accepts data sent by 0x API and fetches quotes from market makers
     * configured on the given pair.
     *
     * Preparing quotes is a two step process:
     *  1. Requests are made to the market makers' `/price` endpoint using
     *     logic similar to that of `getV2PricesAsync`
     *  2. Valid prices are then sent to the market makers' `/sign`
     *     endpoint to get a signed quote
     */
    async getV2QuotesAsync(quoteContext, now = new Date()) {
        var _a, _b;
        const { feeWithDetails: fee } = await this._feeService.calculateFeeAsync(quoteContext);
        const storedFee = (0, fee_utils_1.feeToStoredFee)(fee);
        // TODO (rhinodavid): put a meter on this response time
        const prices = await this._getV2PricesInternalAsync(quoteContext, fee, now);
        // Handle nonce
        let pricesAndOrders = [];
        if (quoteContext.workflow === 'gasless-rfqt') {
            // For gasless RFQt, each order needs a different bucket
            // "Reserve" the next N buckets and get the last one
            const lastReservedBucket = (await this._cacheClient.getNextNOtcOrderBucketsAsync(quoteContext.chainId, prices.length)) %
                constants_1.GASLESS_OTC_ORDER_NUM_BUCKETS;
            // Starting with the last bucket, we give each request its own bucket by decrementing
            // and wrapping around if negative (via modulo)
            const baseNonce = new utils_1.BigNumber(Math.floor(now.getTime() / constants_1.ONE_SECOND_MS));
            pricesAndOrders = prices.map((price, i) => ({
                order: this._v2priceToOrder(price, quoteContext.txOrigin, baseNonce, new utils_1.BigNumber((0, number_utils_1.modulo)(lastReservedBucket - i, constants_1.GASLESS_OTC_ORDER_NUM_BUCKETS))),
                price,
            }));
        }
        else if (quoteContext.workflow === 'rfqt') {
            // For RFQt, all orders share the same bucket, but must have different nonces
            // For RFQtMultiHop all orders have different buckets and nonces
            const baseNonce = new utils_1.BigNumber(Math.floor(now.getTime() / constants_1.ONE_SECOND_MS));
            pricesAndOrders = prices.map((price, i) => ({
                order: this._v2priceToOrder(price, quoteContext.txOrigin, baseNonce.plus(i), quoteContext.bucket !== undefined ? new utils_1.BigNumber(quoteContext.bucket + i) : new utils_1.BigNumber(0)),
                price,
            }));
        }
        const pricesAndOrdersAndSignatures = await Promise.all(pricesAndOrders.map(async ({ price, order }) => {
            let signature;
            try {
                const orderHash = order.getHash();
                signature = await this._quoteServerClient.signV2Async(price.makerUri, quoteContext.integrator.integratorId, {
                    order,
                    orderHash,
                    expiry: price.expiry,
                    fee,
                    trader: quoteContext.trader,
                    workflow: quoteContext.workflow,
                }, (u) => `${u}/rfqt/v2/sign`, 
                /* requireProceedWithFill */ false);
                if (signature) {
                    // Certain market makers are returning signature components which are missing
                    // leading bytes. Add them if they don't exist.
                    const paddedSignature = (0, signature_utils_1.padSignature)(signature);
                    if (paddedSignature.r !== signature.r || paddedSignature.s !== signature.s) {
                        logger_1.logger.warn({ orderHash, r: paddedSignature.r, s: paddedSignature.s }, 'Got market maker signature with missing bytes');
                        signature = paddedSignature;
                    }
                    // Verify the signer was the maker
                    const signerAddress = (0, signature_utils_1.getSignerFromHash)(orderHash, signature).toLowerCase();
                    const makerAddress = order.maker.toLowerCase();
                    if (signerAddress !== makerAddress) {
                        const isValidSigner = await this._blockchainUtils.isValidOrderSignerAsync(makerAddress, signerAddress);
                        if (!isValidSigner) {
                            logger_1.logger.warn({ signerAddress, makerAddress, orderHash, makerUri: price.makerUri }, 'Invalid maker signature');
                            // Quotes with `undefined` signature will be filtered out later
                            signature = undefined;
                        }
                    }
                }
            }
            catch (e) {
                logger_1.logger.warn({ orderHash: order.getHash(), makerId: price.makerId }, 'Failed trying to get rfqt signature from market maker');
            }
            return {
                price,
                order,
                signature: signature !== null && signature !== void 0 ? signature : null,
            };
        }));
        // (Maker Balance Cache) Fetch maker balances to calculate fillable amounts
        let quotedMakerBalances;
        const quotedERC20Owners = prices.map((price) => ({
            owner: price.makerAddress,
            token: price.makerToken,
        }));
        try {
            quotedMakerBalances = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(this._chainId, quotedERC20Owners);
        }
        catch (e) {
            logger_1.logger.error({ chainId: this._chainId, quotedERC20Owners, errorMessage: e.message }, 'Failed to fetch maker balances to calculate fillable amounts');
        }
        const fillableAmounts = (0, RfqtQuoteValidator_1.getRfqtV2FillableAmounts)(prices, this._chainId, quotedMakerBalances);
        const quotes = pricesAndOrdersAndSignatures
            .filter((pos) => pos.signature)
            .map(({ price, order, signature }, i) => ({
            ...fillableAmounts[i],
            fillableTakerFeeAmount: new utils_1.BigNumber(0),
            makerId: price.makerId,
            makerUri: price.makerUri,
            order,
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            signature: signature, // `null` signatures already filtered out
        }));
        // Write to Fee Event Report
        if (this._kafkaProducer) {
            try {
                await quote_report_utils_1.quoteReportUtils.publishRfqtV2FeeEvent({
                    requestedBuyAmount: (_a = quoteContext.makerAmount) !== null && _a !== void 0 ? _a : null,
                    requestedSellAmount: (_b = quoteContext.takerAmount) !== null && _b !== void 0 ? _b : null,
                    requestedTakerAddress: quoteContext.takerAddress,
                    buyTokenAddress: quoteContext.makerToken,
                    sellTokenAddress: quoteContext.takerToken,
                    integratorId: quoteContext.integrator.integratorId,
                    quotes,
                    fee: storedFee,
                }, this._kafkaProducer, this._feeEventTopic);
            }
            catch (e) {
                logger_1.logger.error({
                    chainId: this._chainId,
                    requestedBuyAmount: quoteContext.makerAmount,
                    requestedSellAmount: quoteContext.takerAmount,
                    requestedTakerAddress: quoteContext.takerAddress,
                    buyTokenAddress: quoteContext.makerToken,
                    sellTokenAddress: quoteContext.takerToken,
                    integratorId: quoteContext.integrator.integratorId,
                    errorMessage: e.message,
                }, 'Failed to publish RFQt quote to Fee Event Report');
            }
        }
        return quotes;
    }
    get feeModelVersion() {
        return this._feeModelVersion;
    }
    /**
     * Passthrough to TokenMetadataManager's `getTokenDecimalsAsync` method
     */
    async getTokenDecimalsAsync(tokenAddress) {
        return this._tokenMetadataManager.getTokenDecimalsAsync(tokenAddress);
    }
    /**
     * Get prices from MMs for given quote context and fee.
     */
    async _getV2PricesInternalAsync(quoteContext, fee, now = new Date()) {
        const { integrator, makerToken, takerToken } = quoteContext;
        // Fetch the makers active on this pair
        const makers = this._rfqMakerManager.getRfqtV2MakersForPair(makerToken, takerToken).filter((m) => {
            if (m.rfqtUri === null) {
                return false;
            }
            if (integrator.whitelistMakerIds && !integrator.whitelistMakerIds.includes(m.makerId)) {
                return false;
            }
            return true;
        });
        // Short circuit if no makers are active
        if (!makers.length) {
            return [];
        }
        // TODO (haozhuo): check to see if MM passes circuit breaker
        const prices = (await this._quoteServerClient.batchGetPriceV2Async(
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        makers.map((m) => /* won't be null because of previous `filter` operation */ m.rfqtUri), integrator, transformRfqtV2PricesParameters(quoteContext, fee, this._chainId), (url) => `${url}/rfqt/v2/price`)).map((price) => {
            const maker = makers.find((m) => m.rfqtUri === price.makerUri);
            if (!maker) {
                throw new Error(`Could not find maker with URI ${price.makerUri}`);
            }
            return {
                expiry: price.expiry,
                makerAddress: price.maker,
                makerAmount: price.makerAmount,
                makerId: maker.makerId,
                makerToken: price.makerToken,
                makerUri: price.makerUri,
                takerAmount: price.takerAmount,
                takerToken: price.takerToken,
            };
        });
        // Filter out invalid prices
        const validatedPrices = (0, RfqtQuoteValidator_1.validateV2Prices)(prices, quoteContext, this._minExpiryDurationMs, now);
        return validatedPrices;
    }
    /**
     * Converts a price returned from the market maker's `price` endpoint
     * into an v2 order
     */
    _v2priceToOrder(price, txOrigin, nonce, nonceBucket) {
        return new orders_1.OtcOrder({
            chainId: this._chainId,
            expiryAndNonce: orders_1.OtcOrder.encodeExpiryAndNonce(price.expiry, nonceBucket, nonce),
            maker: price.makerAddress,
            makerAmount: price.makerAmount,
            makerToken: price.makerToken,
            taker: constants_1.NULL_ADDRESS,
            takerAmount: price.takerAmount,
            takerToken: price.takerToken,
            txOrigin,
            verifyingContract: this._contractAddresses.exchangeProxy,
        });
    }
}
exports.RfqtService = RfqtService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9zZXJ2aWNlcy9SZnF0U2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7QUFDQSw4REFBNkQ7QUFFN0QsdURBSzRCO0FBRTVCLHFDQUFzQztBQUl0QyxpREFBK0Y7QUFDL0YsaURBQW1EO0FBVW5ELHNDQUFtQztBQUluQyx3REFBK0M7QUFDL0Msb0VBQStEO0FBRS9ELG9FQUF5RjtBQUd6Riw4REFBMkU7QUFPM0UsTUFBTSx5QkFBeUIsR0FBRyxDQUFDLE1BQWMsRUFBRSxPQUFlLEVBQVUsRUFBRTtJQUMxRSxPQUFRLElBQUEseUNBQXdCLEVBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBbUIsQ0FBQyxZQUFZLENBQUM7QUFDckYsQ0FBQyxDQUFDO0FBRUY7OztHQUdHO0FBQ0gsU0FBUywrQkFBK0IsQ0FBQyxDQUFlLEVBQUUsR0FBUSxFQUFFLE9BQWU7SUFDL0UsTUFBTSxlQUFlLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQztJQUNyQyxNQUFNLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUM7SUFDdEMsMEVBQTBFO0lBQzFFLGtFQUFrRTtJQUNsRSxFQUFFO0lBQ0Ysc0VBQXNFO0lBQ3RFLG9FQUFvRTtJQUNwRSxFQUFFO0lBQ0YsZ0ZBQWdGO0lBQ2hGLEVBQUU7SUFDRiw0Q0FBNEM7SUFDNUMsNkNBQTZDO0lBQzdDLE1BQU0sU0FBUyxHQUNYLENBQUMsQ0FBQyxTQUFTLEtBQUssS0FBSztRQUNqQixDQUFDLENBQUM7WUFDSSxrQkFBa0IsRUFBRSxDQUFDLENBQUMsZUFBZTtZQUNyQyxtQkFBbUIsRUFBRSxTQUFTO1NBQ2pDO1FBQ0gsQ0FBQyxDQUFDO1lBQ0ksaUJBQWlCO1lBQ2pCLGtCQUFrQixFQUFFLFNBQVM7WUFDN0IsbUJBQW1CLEVBQUUsQ0FBQyxDQUFDLGVBQWU7U0FDekMsQ0FBQztJQUVaLE1BQU0sbUJBQW1CLEdBQUc7UUFDeEIsR0FBRyxTQUFTO1FBQ1osZUFBZTtRQUNmLGdCQUFnQjtRQUNo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QUUsd0JBQVk7WUFDbkIsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXO1lBQzlCLFVBQVUsRUFBRSxLQUFLLENBQUMsVUFBVTtZQUM1QixRQUFRO1lBQ1IsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWE7U0FDM0QsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztDQUNKO0FBOWFELGtDQThhQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvZGF2aWR3YWxzaC9jb2RlLWxvY2FsLzB4LXJmcS1hcGkvc3JjL3NlcnZpY2VzL1JmcXRTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFzc2V0U3dhcHBlckNvbnRyYWN0QWRkcmVzc2VzIH0gZnJvbSAnQDB4L2Fzc2V0LXN3YXBwZXIvbGliL3NyYy90eXBlcyc7XG5pbXBvcnQgeyBPdGNPcmRlciB9IGZyb20gJ0AweC9wcm90b2NvbC11dGlscy9saWIvc3JjL29yZGVycyc7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdAMHgvcHJvdG9jb2wtdXRpbHMvbGliL3NyYy9zaWduYXR1cmVfdXRpbHMnO1xuaW1wb3J0IHtcbiAgICBnZXRUb2tlbk1ldGFkYXRhSWZFeGlzdHMsXG4gICAgbmF0aXZlVG9rZW5TeW1ib2wsXG4gICAgbmF0aXZlV3JhcHBlZFRva2VuU3ltYm9sLFxuICAgIFRva2VuTWV0YWRhdGEsXG59IGZyb20gJ0AweC90b2tlbi1tZXRhZGF0YSc7XG5pbXBvcnQgeyBNYXJrZXRPcGVyYXRpb24gfSBmcm9tICdAMHgvdHlwZXMnO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnQDB4L3V0aWxzJztcbmltcG9ydCB7IFByb2R1Y2VyIGFzIEthZmthUHJvZHVjZXIgfSBmcm9tICdrYWZrYWpzJztcblxuaW1wb3J0IHsgSW50ZWdyYXRvciB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgeyBHQVNMRVNTX09UQ19PUkRFUl9OVU1fQlVDS0VUUywgTlVMTF9BRERSRVNTLCBPTkVfU0VDT05EX01TIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMnO1xuaW1wb3J0IHsgZmVlVG9TdG9yZWRGZWUgfSBmcm9tICcuLi9jb3JlL2ZlZV91dGlscyc7XG5pbXBvcnQge1xuICAgIEZlZSxcbiAgICBGZWVNb2RlbFZlcnNpb24sXG4gICAgUXVvdGVTZXJ2ZXJQcmljZVBhcmFtcyxcbiAgICBSZXF1aXJlT25seU9uZSxcbiAgICBSZnF0VjJQcmljZSxcbiAgICBSZnF0VjJRdW90ZSxcbiAgICBTdG9yZWRGZWUsXG59IGZyb20gJy4uL2NvcmUvdHlwZXMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IEFsdFJmcU1ha2VyQXNzZXRPZmZlcmluZ3MgfSBmcm9tICcuLi9xdW90ZVJlcXVlc3Rvci9hbHRNbVR5cGVzJztcbmltcG9ydCB7IFF1b3RlUmVxdWVzdG9yLCBTaWduZWROYXRpdmVPcmRlck1NLCBWNFJGUUluZGljYXRpdmVRdW90ZU1NIH0gZnJvbSAnLi4vcXVvdGVSZXF1ZXN0b3IvUXVvdGVSZXF1ZXN0b3InO1xuaW1wb3J0IHsgQ2FjaGVDbGllbnQgfSBmcm9tICcuLi91dGlscy9jYWNoZV9jbGllbnQnO1xuaW1wb3J0IHsgbW9kdWxvIH0gZnJvbSAnLi4vdXRpbHMvbnVtYmVyX3V0aWxzJztcbmltcG9ydCB7IHF1b3RlUmVwb3J0VXRpbHMgfSBmcm9tICcuLi91dGlscy9xdW90ZV9yZXBvcnRfdXRpbHMnO1xuaW1wb3J0IHsgUXVvdGVTZXJ2ZXJDbGllbnQgfSBmcm9tICcuLi91dGlscy9xdW90ZV9zZXJ2ZXJfY2xpZW50JztcbmltcG9ydCB7IGdldFJmcXRWMkZpbGxhYmxlQW1vdW50cywgdmFsaWRhdGVWMlByaWNlcyB9IGZyb20gJy4uL3V0aWxzL1JmcXRRdW90ZVZhbGlkYXRvcic7XG5pbXBvcnQgeyBSZnFCbG9ja2NoYWluVXRpbHMgfSBmcm9tICcuLi91dGlscy9yZnFfYmxvY2tjaGFpbl91dGlscyc7XG5pbXBvcnQgeyBSZnFNYWtlck1hbmFnZXIgfSBmcm9tICcuLi91dGlscy9yZnFfbWFrZXJfbWFuYWdlcic7XG5pbXBvcnQgeyBnZXRTaWduZXJGcm9tSGFzaCwgcGFkU2lnbmF0dXJlIH0gZnJvbSAnLi4vdXRpbHMvc2lnbmF0dXJlX3V0aWxzJztcbmltcG9ydCB7IFRva2VuTWV0YWRhdGFNYW5hZ2VyIH0gZnJvbSAnLi4vdXRpbHMvVG9rZW5NZXRhZGF0YU1hbmFnZXInO1xuXG5pbXBvcnQgeyBGZWVTZXJ2aWNlIH0gZnJvbSAnLi9mZWVfc2VydmljZSc7XG5pbXBvcnQgeyBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UgfSBmcm9tICcuL3JmcV9tYWtlcl9iYWxhbmNlX2NhY2hlX3NlcnZpY2UnO1xuaW1wb3J0IHsgRmlybVF1b3RlQ29udGV4dCwgUXVvdGVDb250ZXh0IH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGdldFRva2VuQWRkcmVzc0Zyb21TeW1ib2wgPSAoc3ltYm9sOiBzdHJpbmcsIGNoYWluSWQ6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIChnZXRUb2tlbk1ldGFkYXRhSWZFeGlzdHMoc3ltYm9sLCBjaGFpbklkKSBhcyBUb2tlbk1ldGFkYXRhKS50b2tlbkFkZHJlc3M7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBwYXJhbWV0ZXJzIG9mIGFuIFJGUXQgdjIgcHJpY2VzIHJlcXVlc3QgZnJvbSAweCBBUElcbiAqIGludG8gdGhlIGZvcm1hdCBuZWVkZWQgZm9yIGBRdW90ZVNlcnZlckNsaWVudGAgdG8gY2FsbCB0aGUgbWFya2V0IG1ha2Vyc1xuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZnF0VjJQcmljZXNQYXJhbWV0ZXJzKHA6IFF1b3RlQ29udGV4dCwgZmVlOiBGZWUsIGNoYWluSWQ6IG51bWJlcik6IFF1b3RlU2VydmVyUHJpY2VQYXJhbXMge1xuICAgIGNvbnN0IGJ1eVRva2VuQWRkcmVzcyA9IHAubWFrZXJUb2tlbjtcbiAgICBjb25zdCBzZWxsVG9rZW5BZGRyZXNzID0gcC50YWtlclRva2VuO1xuICAgIC8vIFR5cGVzY3JpcHQgZ3ltbmFzdGljcyB3aXRoIGBiYXNlVW5pdHNgIHRvIGNhcHV0dXJlIHRoZSBcIm9uZW9mXCIgbmF0dXJlLS1cbiAgICAvLyBCeSBwYWNrYWdpbmcgdGhlbSBpbiB0aGVpciBvd24gbGl0dGxlIG9iamVjdCwgdGhlIHR5cGUgYmVjb21lczpcbiAgICAvL1xuICAgIC8vIHsgYnV5QW1vdW50QmFzZVVuaXRzOiBCaWdOdW1iZXIsIHNlbGxBbW91bnRCYXNlVW5pdHM6IHVuZGVmaW5lZCB9IHxcbiAgICAvLyB7IGJ1eUFtb3VudEJhc2VVbml0czogdW5kZWZpbmVkLCBzZWxsQW1vdW50QmFzZVVuaXRzOiBCaWdOdW1iZXIgfVxuICAgIC8vXG4gICAgLy8gVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBub3QgcGFja2FnaW5nIHRoZW0gdG9nZXRoZXIsIHdoZXJlIHRoZSB0eXBlcyB3b3VsZCBiZTpcbiAgICAvL1xuICAgIC8vIGJ1eUFtb3VudEJhc2VVbml0czogQmlnTnVtYmVyIHwgdW5kZWZpbmVkXG4gICAgLy8gc2VsbEFtb3VudEJhc2VVbml0czogQmlnTnVtYmVyIHwgdW5kZWZpbmVkXG4gICAgY29uc3QgYmFzZVVuaXRzID1cbiAgICAgICAgcC5pc1NlbGxpbmcgPT09IGZhbHNlXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIGJ1eUFtb3VudEJhc2VVbml0czogcC5hc3NldEZpbGxBbW91bnQsXG4gICAgICAgICAgICAgICAgICBzZWxsQW1vdW50QmFzZVVuaXRzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIFNFTExcbiAgICAgICAgICAgICAgICAgIGJ1eUFtb3VudEJhc2VVbml0czogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgc2VsbEFtb3VudEJhc2VVbml0czogcC5hc3NldEZpbGxBbW91bnQsXG4gICAgICAgICAgICAgIH07XG5cbiAgICBjb25zdCBtbVJlcXVlc3RQYXJhbWV0ZXJzID0ge1xuICAgICAgICAuLi5iYXNlVW5pdHMsXG4gICAgICAgIGJ1eVRva2VuQWRkcmVzcyxcbiAgICAgICAgc2VsbFRva2VuQWRkcmVzcyxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgZmVlQW1vdW50OiBmZWUuYW1vdW50LFxuICAgICAgICBmZWVUb2tlbjogZmVlLnRva2VuLFxuICAgICAgICBpbnRlZ3JhdG9ySWQ6IHAuaW50ZWdyYXRvci5pbnRlZ3JhdG9ySWQsXG4gICAgICAgIHRha2VyQWRkcmVzczogcC50YWtlckFkZHJlc3MsXG4gICAgICAgIHR4T3JpZ2luOiBwLnR4T3JpZ2luLFxuICAgICAgICAvLyB0cmFkZXI6IHAudHJhZGVyLFxuICAgICAgICAvLyB3b3JrZmxvdzogcC53b3JrZmxvdyxcbiAgICAgICAgcHJvdG9jb2xWZXJzaW9uOiAnNCcsIC8vaGFyZGNvZGUgLSB3aWxsIGJyZWFrIHNvbWUgTU1zIGlmIG1pc3NpbmchXG4gICAgfTtcblxuICAgIC8vIENvbnZlcnQgbW1SZXF1ZXN0UGFyYW1ldGVycyB2YWx1ZXMgdG8gc3RyaW5nc1xuICAgIGNvbnN0IHN0cmluZ1BhcmFtZXRlcnMgPSAoKFxuICAgICAgICBvOiB0eXBlb2YgbW1SZXF1ZXN0UGFyYW1ldGVycyxcbiAgICApOiBSZXF1aXJlT25seU9uZTxcbiAgICAgICAgUmVjb3JkPGtleW9mIHR5cGVvZiBtbVJlcXVlc3RQYXJhbWV0ZXJzLCBzdHJpbmc+LFxuICAgICAgICAnYnV5QW1vdW50QmFzZVVuaXRzJyB8ICdzZWxsQW1vdW50QmFzZVVuaXRzJ1xuICAgID4gPT4ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobykucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWU6IHsgdG9TdHJpbmc6ICgpID0+IHN0cmluZyB9IHwgdW5kZWZpbmVkID0gb1trZXkgYXMga2V5b2YgdHlwZW9mIG1tUmVxdWVzdFBhcmFtZXRlcnNdO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUudG9TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdWYWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBzdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB9LCB7fSBhcyBhbnkpO1xuICAgIH0pKG1tUmVxdWVzdFBhcmFtZXRlcnMpO1xuXG4gICAgcmV0dXJuIHN0cmluZ1BhcmFtZXRlcnM7XG59XG5cbi8qKlxuICogQ29udGFpbnMgdGhlIGxvZ2ljIHRvIGhhbmRsZSBSRlFUIFRyYWRlcy5cbiAqXG4gKiBgXCJ2MVwiYCBmdW5jdGlvbnMgc3VwcG9ydCBgTWV0YVRyYW5zYWN0aW9uYCB0cmFkZXMgd2hpbGVcbiAqIGBcInYyXCJgIGZ1bmN0aW9ucyAod2lsbCkgc3VwcG9ydCBgT3RjT3JkZXJgIHRyYWRlcy5cbiAqXG4gKiBgdjFgIHJlbGllcyBoZWF2aWx5IG9uIGBRdW90ZVJlcXVlc3RvcmAgd2hpY2ggaGFzIGJlZW4gY29waWVkIG92ZXJcbiAqIGZyb20gYDB4L2Fzc2V0LXN3YXBwZXJgLlxuICovXG5leHBvcnQgY2xhc3MgUmZxdFNlcnZpY2Uge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX25hdGl2ZVRva2VuU3ltYm9sOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfbmF0aXZlVG9rZW5BZGRyZXNzOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfbmF0aXZlV3JhcHBlZFRva2VuU3ltYm9sOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfbmF0aXZlV3JhcHBlZFRva2VuQWRkcmVzczogc3RyaW5nO1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9jaGFpbklkOiBudW1iZXIsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX3JmcU1ha2VyTWFuYWdlcjogUmZxTWFrZXJNYW5hZ2VyLFxuICAgICAgICAvLyBVc2VkIGZvciBSRlF0IHYxIHJlcXVlc3RzXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX3F1b3RlUmVxdWVzdG9yOiBQaWNrPFxuICAgICAgICAgICAgUXVvdGVSZXF1ZXN0b3IsXG4gICAgICAgICAgICAncmVxdWVzdFJmcXRJbmRpY2F0aXZlUXVvdGVzQXN5bmMnIHwgJ3JlcXVlc3RSZnF0RmlybVF1b3Rlc0FzeW5jJyB8ICdnZXRNYWtlclVyaUZvclNpZ25hdHVyZSdcbiAgICAgICAgPixcbiAgICAgICAgLy8gVXNlZCBmb3IgUkZRdCB2MiByZXF1ZXN0c1xuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9xdW90ZVNlcnZlckNsaWVudDogUXVvdGVTZXJ2ZXJDbGllbnQsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX21pbkV4cGlyeUR1cmF0aW9uTXM6IG51bWJlcixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfYmxvY2tjaGFpblV0aWxzOiBSZnFCbG9ja2NoYWluVXRpbHMsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX3Rva2VuTWV0YWRhdGFNYW5hZ2VyOiBUb2tlbk1ldGFkYXRhTWFuYWdlcixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfY29udHJhY3RBZGRyZXNzZXM6IEFzc2V0U3dhcHBlckNvbnRyYWN0QWRkcmVzc2VzLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9mZWVTZXJ2aWNlOiBGZWVTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9mZWVNb2RlbFZlcnNpb246IEZlZU1vZGVsVmVyc2lvbixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfcmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlOiBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX2NhY2hlQ2xpZW50OiBDYWNoZUNsaWVudCxcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfa2Fma2FQcm9kdWNlcj86IEthZmthUHJvZHVjZXIsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX2ZlZUV2ZW50VG9waWM/OiBzdHJpbmcsXG4gICAgKSB7XG4gICAgICAgIHRoaXMuX25hdGl2ZVRva2VuU3ltYm9sID0gbmF0aXZlVG9rZW5TeW1ib2wodGhpcy5fY2hhaW5JZCk7XG4gICAgICAgIHRoaXMuX25hdGl2ZVRva2VuQWRkcmVzcyA9IGdldFRva2VuQWRkcmVzc0Zyb21TeW1ib2wodGhpcy5fbmF0aXZlVG9rZW5TeW1ib2wsIHRoaXMuX2NoYWluSWQpO1xuICAgICAgICB0aGlzLl9uYXRpdmVXcmFwcGVkVG9rZW5TeW1ib2wgPSBuYXRpdmVXcmFwcGVkVG9rZW5TeW1ib2wodGhpcy5fY2hhaW5JZCk7XG4gICAgICAgIHRoaXMuX25hdGl2ZVdyYXBwZWRUb2tlbkFkZHJlc3MgPSBnZXRUb2tlbkFkZHJlc3NGcm9tU3ltYm9sKHRoaXMuX25hdGl2ZVdyYXBwZWRUb2tlblN5bWJvbCwgdGhpcy5fY2hhaW5JZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzcyB0aHJvdWdoIHRvIGBRdW90ZVJlcXVlc3Rvcjo6cmVxdWVzdFJmcXRJbmRpY2F0aXZlUXVvdGVzQXN5bmNgIHRvIGZldGNoXG4gICAgICogaW5kaWNhdGl2ZSBxdW90ZXMgZnJvbSBtYXJrZXQgbWFrZXJzLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGJ5IHRoaXMgcG9pbnQsIDB4IEFQSSBzaG91bGQgYmUgc2VuZGluZyB0aGUgbnVsbCBhZGRyZXNzXG4gICAgICogYXMgdGhlIGB0YWtlckFkZHJlc3NgIGFuZCB0aGUgdGFrZXIncyBhZGRyZXNzIGFzIHRoZSBgdHhPcmlnaW5gLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRWMVByaWNlc0FzeW5jKHBhcmFtZXRlcnM6IHtcbiAgICAgICAgYWx0UmZxQXNzZXRPZmZlcmluZ3M6IEFsdFJmcU1ha2VyQXNzZXRPZmZlcmluZ3M7XG4gICAgICAgIGFzc2V0RmlsbEFtb3VudDogQmlnTnVtYmVyO1xuICAgICAgICBjb21wYXJpc29uUHJpY2U6IEJpZ051bWJlciB8IHVuZGVmaW5lZDtcbiAgICAgICAgbWFrZXJUb2tlbjogc3RyaW5nO1xuICAgICAgICBtYXJrZXRPcGVyYXRpb246IE1hcmtldE9wZXJhdGlvbjtcbiAgICAgICAgdGFrZXJUb2tlbjogc3RyaW5nOyAvLyBleHBlY3QgdGhpcyB0byBiZSBOVUxMX0FERFJFU1NcbiAgICAgICAgdGFrZXJBZGRyZXNzOiBzdHJpbmc7XG4gICAgICAgIHR4T3JpZ2luPzogc3RyaW5nOyAvLyBleHBlY3QgdGhpcyB0byBiZSB0aGUgdGFrZXIgYWRkcmVzc1xuICAgICAgICBpbnRlbnRPbkZpbGxpbmc6IGJvb2xlYW47XG4gICAgICAgIGludGVncmF0b3I6IEludGVncmF0b3I7XG4gICAgfSk6IFByb21pc2U8VjRSRlFJbmRpY2F0aXZlUXVvdGVNTVtdPiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGFsdFJmcUFzc2V0T2ZmZXJpbmdzLFxuICAgICAgICAgICAgYXNzZXRGaWxsQW1vdW50LFxuICAgICAgICAgICAgY29tcGFyaXNvblByaWNlLFxuICAgICAgICAgICAgaW50ZWdyYXRvcixcbiAgICAgICAgICAgIGludGVudE9uRmlsbGluZywgLy8gdHNsaW50OmRpc2FibGUtbGluZSBib29sZWFuLW5hbWluZ1xuICAgICAgICAgICAgbWFrZXJUb2tlbixcbiAgICAgICAgICAgIG1hcmtldE9wZXJhdGlvbixcbiAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcbiAgICAgICAgICAgIHRha2VyVG9rZW4sXG4gICAgICAgICAgICB0eE9yaWdpbixcbiAgICAgICAgfSA9IHBhcmFtZXRlcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1b3RlUmVxdWVzdG9yLnJlcXVlc3RSZnF0SW5kaWNhdGl2ZVF1b3Rlc0FzeW5jKFxuICAgICAgICAgICAgbWFrZXJUb2tlbixcbiAgICAgICAgICAgIHRha2VyVG9rZW4sXG4gICAgICAgICAgICBhc3NldEZpbGxBbW91bnQsXG4gICAgICAgICAgICBtYXJrZXRPcGVyYXRpb24sXG4gICAgICAgICAgICBjb21wYXJpc29uUHJpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWx0UmZxQXNzZXRPZmZlcmluZ3MsXG4gICAgICAgICAgICAgICAgaW50ZWdyYXRvcixcbiAgICAgICAgICAgICAgICBpbnRlbnRPbkZpbGxpbmcsXG4gICAgICAgICAgICAgICAgaXNJbmRpY2F0aXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzTGFzdExvb2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1ha2VyRW5kcG9pbnRNYXhSZXNwb25zZVRpbWVNczogNjAwLFxuICAgICAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICB0eE9yaWdpbjogdHhPcmlnaW4gfHwgTlVMTF9BRERSRVNTLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzIHRocm91Z2ggdG8gYFF1b3RlUmVxdWVzdG9yOjpyZXF1ZXN0UmZxdEZpcm1RdW90ZXNBc3luY2AgdG8gZmV0Y2hcbiAgICAgKiBmaXJtIHF1b3RlcyBmcm9tIG1hcmtldCBtYWtlcnMuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgYnkgdGhpcyBwb2ludCwgMHggQVBJIHNob3VsZCBiZSBzZW5kaW5nIHRoZSBudWxsIGFkZHJlc3NcbiAgICAgKiBhcyB0aGUgYHRha2VyQWRkcmVzc2AgYW5kIHRoZSB0YWtlcidzIGFkZHJlc3MgYXMgdGhlIGB0eE9yaWdpbmAuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGdldFYxUXVvdGVzQXN5bmMocGFyYW1ldGVyczoge1xuICAgICAgICBhbHRSZnFBc3NldE9mZmVyaW5nczogQWx0UmZxTWFrZXJBc3NldE9mZmVyaW5ncztcbiAgICAgICAgYXNzZXRGaWxsQW1vdW50OiBCaWdOdW1iZXI7XG4gICAgICAgIGNvbXBhcmlzb25QcmljZTogQmlnTnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgICAgICBpbnRlZ3JhdG9yOiBJbnRlZ3JhdG9yO1xuICAgICAgICBpbnRlbnRPbkZpbGxpbmc6IGJvb2xlYW47XG4gICAgICAgIG1ha2VyVG9rZW46IHN0cmluZztcbiAgICAgICAgbWFya2V0T3BlcmF0aW9uOiBNYXJrZXRPcGVyYXRpb247XG4gICAgICAgIHRha2VyQWRkcmVzczogc3RyaW5nOyAvLyBleHBlY3QgdGhpcyB0byBiZSB0aGUgdGFrZXIgYWRkcmVzc1xuICAgICAgICB0YWtlclRva2VuOiBzdHJpbmc7XG4gICAgICAgIHR4T3JpZ2luOiBzdHJpbmc7XG4gICAgfSk6IFByb21pc2U8U2lnbmVkTmF0aXZlT3JkZXJNTVtdPiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGFsdFJmcUFzc2V0T2ZmZXJpbmdzLFxuICAgICAgICAgICAgYXNzZXRGaWxsQW1vdW50LFxuICAgICAgICAgICAgY29tcGFyaXNvblByaWNlLFxuICAgICAgICAgICAgaW50ZWdyYXRvcixcbiAgICAgICAgICAgIGludGVudE9uRmlsbGluZywgLy8gdHNsaW50OmRpc2FibGUtbGluZSBib29sZWFuLW5hbWluZ1xuICAgICAgICAgICAgbWFrZXJUb2tlbixcbiAgICAgICAgICAgIG1hcmtldE9wZXJhdGlvbixcbiAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcbiAgICAgICAgICAgIHRha2VyVG9rZW4sXG4gICAgICAgICAgICB0eE9yaWdpbixcbiAgICAgICAgfSA9IHBhcmFtZXRlcnM7XG5cbiAgICAgICAgY29uc3QgcXVvdGVzID0gYXdhaXQgdGhpcy5fcXVvdGVSZXF1ZXN0b3IucmVxdWVzdFJmcXRGaXJtUXVvdGVzQXN5bmMoXG4gICAgICAgICAgICBtYWtlclRva2VuLFxuICAgICAgICAgICAgdGFrZXJUb2tlbixcbiAgICAgICAgICAgIGFzc2V0RmlsbEFtb3VudCxcbiAgICAgICAgICAgIG1hcmtldE9wZXJhdGlvbixcbiAgICAgICAgICAgIGNvbXBhcmlzb25QcmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhbHRSZnFBc3NldE9mZmVyaW5ncyxcbiAgICAgICAgICAgICAgICBpbnRlZ3JhdG9yLFxuICAgICAgICAgICAgICAgIGludGVudE9uRmlsbGluZyxcbiAgICAgICAgICAgICAgICBpc0luZGljYXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzTGFzdExvb2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1ha2VyRW5kcG9pbnRNYXhSZXNwb25zZVRpbWVNczogNjAwLFxuICAgICAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICB0eE9yaWdpbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHF1b3Rlcy5tYXAoKHEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucSxcbiAgICAgICAgICAgICAgICBtYWtlclVyaTogdGhpcy5fcXVvdGVSZXF1ZXN0b3IuZ2V0TWFrZXJVcmlGb3JTaWduYXR1cmUocS5zaWduYXR1cmUpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWNjZXB0cyBkYXRhIHNlbnQgYnkgMHggQVBJIGFuZCBmZXRjaGVzIHByaWNlcyBmcm9tIE1hcmtldCBNYWtlcnNcbiAgICAgKiBjb25maWd1cmVkIG9uIHRoZSBnaXZlbiBwYWlyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGJ5IHRoaXMgcG9pbnQsIDB4IEFQSSBzaG91bGQgYmUgc2VuZGluZyB0aGUgbnVsbCBhZGRyZXNzXG4gICAgICogYXMgdGhlIGB0YWtlckFkZHJlc3NgIGFuZCB0aGUgdGFrZXIncyBhZGRyZXNzIGFzIHRoZSBgdHhPcmlnaW5gLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRWMlByaWNlc0FzeW5jKHF1b3RlQ29udGV4dDogUXVvdGVDb250ZXh0LCBub3c6IERhdGUgPSBuZXcgRGF0ZSgpKTogUHJvbWlzZTxSZnF0VjJQcmljZVtdPiB7XG4gICAgICAgIGNvbnN0IHsgZmVlV2l0aERldGFpbHM6IGZlZSB9ID0gYXdhaXQgdGhpcy5fZmVlU2VydmljZS5jYWxjdWxhdGVGZWVBc3luYyhxdW90ZUNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VjJQcmljZXNJbnRlcm5hbEFzeW5jKHF1b3RlQ29udGV4dCwgZmVlLCBub3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgZGF0YSBzZW50IGJ5IDB4IEFQSSBhbmQgZmV0Y2hlcyBxdW90ZXMgZnJvbSBtYXJrZXQgbWFrZXJzXG4gICAgICogY29uZmlndXJlZCBvbiB0aGUgZ2l2ZW4gcGFpci5cbiAgICAgKlxuICAgICAqIFByZXBhcmluZyBxdW90ZXMgaXMgYSB0d28gc3RlcCBwcm9jZXNzOlxuICAgICAqICAxLiBSZXF1ZXN0cyBhcmUgbWFkZSB0byB0aGUgbWFya2V0IG1ha2VycycgYC9wcmljZWAgZW5kcG9pbnQgdXNpbmdcbiAgICAgKiAgICAgbG9naWMgc2ltaWxhciB0byB0aGF0IG9mIGBnZXRWMlByaWNlc0FzeW5jYFxuICAgICAqICAyLiBWYWxpZCBwcmljZXMgYXJlIHRoZW4gc2VudCB0byB0aGUgbWFya2V0IG1ha2VycycgYC9zaWduYFxuICAgICAqICAgICBlbmRwb2ludCB0byBnZXQgYSBzaWduZWQgcXVvdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0VjJRdW90ZXNBc3luYyhxdW90ZUNvbnRleHQ6IEZpcm1RdW90ZUNvbnRleHQsIG5vdzogRGF0ZSA9IG5ldyBEYXRlKCkpOiBQcm9taXNlPFJmcXRWMlF1b3RlW10+IHtcbiAgICAgICAgY29uc3QgeyBmZWVXaXRoRGV0YWlsczogZmVlIH0gPSBhd2FpdCB0aGlzLl9mZWVTZXJ2aWNlLmNhbGN1bGF0ZUZlZUFzeW5jKHF1b3RlQ29udGV4dCk7XG4gICAgICAgIGNvbnN0IHN0b3JlZEZlZTogU3RvcmVkRmVlID0gZmVlVG9TdG9yZWRGZWUoZmVlKTtcblxuICAgICAgICAvLyBUT0RPIChyaGlub2RhdmlkKTogcHV0IGEgbWV0ZXIgb24gdGhpcyByZXNwb25zZSB0aW1lXG4gICAgICAgIGNvbnN0IHByaWNlcyA9IGF3YWl0IHRoaXMuX2dldFYyUHJpY2VzSW50ZXJuYWxBc3luYyhxdW90ZUNvbnRleHQsIGZlZSwgbm93KTtcblxuICAgICAgICAvLyBIYW5kbGUgbm9uY2VcbiAgICAgICAgbGV0IHByaWNlc0FuZE9yZGVyczogeyBwcmljZTogUmZxdFYyUHJpY2U7IG9yZGVyOiBPdGNPcmRlciB9W10gPSBbXTtcblxuICAgICAgICBpZiAocXVvdGVDb250ZXh0LndvcmtmbG93ID09PSAnZ2FzbGVzcy1yZnF0Jykge1xuICAgICAgICAgICAgLy8gRm9yIGdhc2xlc3MgUkZRdCwgZWFjaCBvcmRlciBuZWVkcyBhIGRpZmZlcmVudCBidWNrZXRcbiAgICAgICAgICAgIC8vIFwiUmVzZXJ2ZVwiIHRoZSBuZXh0IE4gYnVja2V0cyBhbmQgZ2V0IHRoZSBsYXN0IG9uZVxuICAgICAgICAgICAgY29uc3QgbGFzdFJlc2VydmVkQnVja2V0ID1cbiAgICAgICAgICAgICAgICAoYXdhaXQgdGhpcy5fY2FjaGVDbGllbnQuZ2V0TmV4dE5PdGNPcmRlckJ1Y2tldHNBc3luYyhxdW90ZUNvbnRleHQuY2hhaW5JZCwgcHJpY2VzLmxlbmd0aCkpICVcbiAgICAgICAgICAgICAgICBHQVNMRVNTX09UQ19PUkRFUl9OVU1fQlVDS0VUUztcblxuICAgICAgICAgICAgLy8gU3RhcnRpbmcgd2l0aCB0aGUgbGFzdCBidWNrZXQsIHdlIGdpdmUgZWFjaCByZXF1ZXN0IGl0cyBvd24gYnVja2V0IGJ5IGRlY3JlbWVudGluZ1xuICAgICAgICAgICAgLy8gYW5kIHdyYXBwaW5nIGFyb3VuZCBpZiBuZWdhdGl2ZSAodmlhIG1vZHVsbylcbiAgICAgICAgICAgIGNvbnN0IGJhc2VOb25jZSA9IG5ldyBCaWdOdW1iZXIoTWF0aC5mbG9vcihub3cuZ2V0VGltZSgpIC8gT05FX1NFQ09ORF9NUykpO1xuICAgICAgICAgICAgcHJpY2VzQW5kT3JkZXJzID0gcHJpY2VzLm1hcCgocHJpY2UsIGkpID0+ICh7XG4gICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMuX3YycHJpY2VUb09yZGVyKFxuICAgICAgICAgICAgICAgICAgICBwcmljZSxcbiAgICAgICAgICAgICAgICAgICAgcXVvdGVDb250ZXh0LnR4T3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBiYXNlTm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIobW9kdWxvKGxhc3RSZXNlcnZlZEJ1Y2tldCAtIGksIEdBU0xFU1NfT1RDX09SREVSX05VTV9CVUNLRVRTKSksIC8vIGRlY3JlbWVudCBmcm9tIGxhc3QgYnVja2V0IGFuZCB3cmFwIGFyb3VuZCBpZiBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgcHJpY2UsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSBpZiAocXVvdGVDb250ZXh0LndvcmtmbG93ID09PSAncmZxdCcpIHtcbiAgICAgICAgICAgIC8vIEZvciBSRlF0LCBhbGwgb3JkZXJzIHNoYXJlIHRoZSBzYW1lIGJ1Y2tldCwgYnV0IG11c3QgaGF2ZSBkaWZmZXJlbnQgbm9uY2VzXG4gICAgICAgICAgICAvLyBGb3IgUkZRdE11bHRpSG9wIGFsbCBvcmRlcnMgaGF2ZSBkaWZmZXJlbnQgYnVja2V0cyBhbmQgbm9uY2VzXG4gICAgICAgICAgICBjb25zdCBiYXNlTm9uY2UgPSBuZXcgQmlnTnVtYmVyKE1hdGguZmxvb3Iobm93LmdldFRpbWUoKSAvIE9ORV9TRUNPTkRfTVMpKTtcbiAgICAgICAgICAgIHByaWNlc0FuZE9yZGVycyA9IHByaWNlcy5tYXAoKHByaWNlLCBpKSA9PiAoe1xuICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLl92MnByaWNlVG9PcmRlcihcbiAgICAgICAgICAgICAgICAgICAgcHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIHF1b3RlQ29udGV4dC50eE9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgYmFzZU5vbmNlLnBsdXMoaSksXG4gICAgICAgICAgICAgICAgICAgIHF1b3RlQ29udGV4dC5idWNrZXQgIT09IHVuZGVmaW5lZCA/IG5ldyBCaWdOdW1iZXIocXVvdGVDb250ZXh0LmJ1Y2tldCArIGkpIDogbmV3IEJpZ051bWJlcigwKSwgLy8gYnVja2V0XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBwcmljZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByaWNlc0FuZE9yZGVyc0FuZFNpZ25hdHVyZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIHByaWNlc0FuZE9yZGVycy5tYXAoYXN5bmMgKHsgcHJpY2UsIG9yZGVyIH0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2lnbmF0dXJlOiBTaWduYXR1cmUgfCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJIYXNoID0gb3JkZXIuZ2V0SGFzaCgpO1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLl9xdW90ZVNlcnZlckNsaWVudC5zaWduVjJBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlLm1ha2VyVXJpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGVDb250ZXh0LmludGVncmF0b3IuaW50ZWdyYXRvcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVySGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBpcnk6IHByaWNlLmV4cGlyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhZGVyOiBxdW90ZUNvbnRleHQudHJhZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtmbG93OiBxdW90ZUNvbnRleHQud29ya2Zsb3csXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgKHU6IHN0cmluZykgPT4gYCR7dX0vcmZxdC92Mi9zaWduYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIHJlcXVpcmVQcm9jZWVkV2l0aEZpbGwgKi8gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2VydGFpbiBtYXJrZXQgbWFrZXJzIGFyZSByZXR1cm5pbmcgc2lnbmF0dXJlIGNvbXBvbmVudHMgd2hpY2ggYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlYWRpbmcgYnl0ZXMuIEFkZCB0aGVtIGlmIHRoZXkgZG9uJ3QgZXhpc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWRkZWRTaWduYXR1cmUgPSBwYWRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWRkZWRTaWduYXR1cmUuciAhPT0gc2lnbmF0dXJlLnIgfHwgcGFkZGVkU2lnbmF0dXJlLnMgIT09IHNpZ25hdHVyZS5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgb3JkZXJIYXNoLCByOiBwYWRkZWRTaWduYXR1cmUuciwgczogcGFkZGVkU2lnbmF0dXJlLnMgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0dvdCBtYXJrZXQgbWFrZXIgc2lnbmF0dXJlIHdpdGggbWlzc2luZyBieXRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBwYWRkZWRTaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmeSB0aGUgc2lnbmVyIHdhcyB0aGUgbWFrZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lckFkZHJlc3MgPSBnZXRTaWduZXJGcm9tSGFzaChvcmRlckhhc2gsIHNpZ25hdHVyZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ha2VyQWRkcmVzcyA9IG9yZGVyLm1ha2VyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbmVyQWRkcmVzcyAhPT0gbWFrZXJBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNpZ25lciA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5pc1ZhbGlkT3JkZXJTaWduZXJBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkU2lnbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzaWduZXJBZGRyZXNzLCBtYWtlckFkZHJlc3MsIG9yZGVySGFzaCwgbWFrZXJVcmk6IHByaWNlLm1ha2VyVXJpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBtYWtlciBzaWduYXR1cmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFF1b3RlcyB3aXRoIGB1bmRlZmluZWRgIHNpZ25hdHVyZSB3aWxsIGJlIGZpbHRlcmVkIG91dCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgb3JkZXJIYXNoOiBvcmRlci5nZXRIYXNoKCksIG1ha2VySWQ6IHByaWNlLm1ha2VySWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdHJ5aW5nIHRvIGdldCByZnF0IHNpZ25hdHVyZSBmcm9tIG1hcmtldCBtYWtlcicsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHByaWNlLFxuICAgICAgICAgICAgICAgICAgICBvcmRlcixcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gKE1ha2VyIEJhbGFuY2UgQ2FjaGUpIEZldGNoIG1ha2VyIGJhbGFuY2VzIHRvIGNhbGN1bGF0ZSBmaWxsYWJsZSBhbW91bnRzXG4gICAgICAgIGxldCBxdW90ZWRNYWtlckJhbGFuY2VzOiBCaWdOdW1iZXJbXSB8IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcXVvdGVkRVJDMjBPd25lcnMgPSBwcmljZXMubWFwKChwcmljZSkgPT4gKHtcbiAgICAgICAgICAgIG93bmVyOiBwcmljZS5tYWtlckFkZHJlc3MsXG4gICAgICAgICAgICB0b2tlbjogcHJpY2UubWFrZXJUb2tlbixcbiAgICAgICAgfSkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcXVvdGVkTWFrZXJCYWxhbmNlcyA9IGF3YWl0IHRoaXMuX3JmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZS5nZXRFUkMyME93bmVyQmFsYW5jZXNBc3luYyhcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbklkLFxuICAgICAgICAgICAgICAgIHF1b3RlZEVSQzIwT3duZXJzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgIHsgY2hhaW5JZDogdGhpcy5fY2hhaW5JZCwgcXVvdGVkRVJDMjBPd25lcnMsIGVycm9yTWVzc2FnZTogZS5tZXNzYWdlIH0sXG4gICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBmZXRjaCBtYWtlciBiYWxhbmNlcyB0byBjYWxjdWxhdGUgZmlsbGFibGUgYW1vdW50cycsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsbGFibGVBbW91bnRzID0gZ2V0UmZxdFYyRmlsbGFibGVBbW91bnRzKHByaWNlcywgdGhpcy5fY2hhaW5JZCwgcXVvdGVkTWFrZXJCYWxhbmNlcyk7XG5cbiAgICAgICAgY29uc3QgcXVvdGVzID0gcHJpY2VzQW5kT3JkZXJzQW5kU2lnbmF0dXJlc1xuICAgICAgICAgICAgLmZpbHRlcigocG9zKSA9PiBwb3Muc2lnbmF0dXJlKVxuICAgICAgICAgICAgLm1hcCgoeyBwcmljZSwgb3JkZXIsIHNpZ25hdHVyZSB9LCBpKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLmZpbGxhYmxlQW1vdW50c1tpXSxcbiAgICAgICAgICAgICAgICBmaWxsYWJsZVRha2VyRmVlQW1vdW50OiBuZXcgQmlnTnVtYmVyKDApLFxuICAgICAgICAgICAgICAgIG1ha2VySWQ6IHByaWNlLm1ha2VySWQsXG4gICAgICAgICAgICAgICAgbWFrZXJVcmk6IHByaWNlLm1ha2VyVXJpLFxuICAgICAgICAgICAgICAgIG9yZGVyLFxuICAgICAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlISwgLy8gYG51bGxgIHNpZ25hdHVyZXMgYWxyZWFkeSBmaWx0ZXJlZCBvdXRcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyBXcml0ZSB0byBGZWUgRXZlbnQgUmVwb3J0XG4gICAgICAgIGlmICh0aGlzLl9rYWZrYVByb2R1Y2VyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHF1b3RlUmVwb3J0VXRpbHMucHVibGlzaFJmcXRWMkZlZUV2ZW50KFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRCdXlBbW91bnQ6IHF1b3RlQ29udGV4dC5tYWtlckFtb3VudCA/PyBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkU2VsbEFtb3VudDogcXVvdGVDb250ZXh0LnRha2VyQW1vdW50ID8/IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRUYWtlckFkZHJlc3M6IHF1b3RlQ29udGV4dC50YWtlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBidXlUb2tlbkFkZHJlc3M6IHF1b3RlQ29udGV4dC5tYWtlclRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsbFRva2VuQWRkcmVzczogcXVvdGVDb250ZXh0LnRha2VyVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhdG9ySWQ6IHF1b3RlQ29udGV4dC5pbnRlZ3JhdG9yLmludGVncmF0b3JJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlZTogc3RvcmVkRmVlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rYWZrYVByb2R1Y2VyLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mZWVFdmVudFRvcGljLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiB0aGlzLl9jaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkQnV5QW1vdW50OiBxdW90ZUNvbnRleHQubWFrZXJBbW91bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRTZWxsQW1vdW50OiBxdW90ZUNvbnRleHQudGFrZXJBbW91bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRUYWtlckFkZHJlc3M6IHF1b3RlQ29udGV4dC50YWtlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBidXlUb2tlbkFkZHJlc3M6IHF1b3RlQ29udGV4dC5tYWtlclRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsbFRva2VuQWRkcmVzczogcXVvdGVDb250ZXh0LnRha2VyVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhdG9ySWQ6IHF1b3RlQ29udGV4dC5pbnRlZ3JhdG9yLmludGVncmF0b3JJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIHB1Ymxpc2ggUkZRdCBxdW90ZSB0byBGZWUgRXZlbnQgUmVwb3J0JyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1b3RlcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGZlZU1vZGVsVmVyc2lvbigpOiBGZWVNb2RlbFZlcnNpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmVlTW9kZWxWZXJzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3N0aHJvdWdoIHRvIFRva2VuTWV0YWRhdGFNYW5hZ2VyJ3MgYGdldFRva2VuRGVjaW1hbHNBc3luY2AgbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGdldFRva2VuRGVjaW1hbHNBc3luYyh0b2tlbkFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbk1ldGFkYXRhTWFuYWdlci5nZXRUb2tlbkRlY2ltYWxzQXN5bmModG9rZW5BZGRyZXNzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcHJpY2VzIGZyb20gTU1zIGZvciBnaXZlbiBxdW90ZSBjb250ZXh0IGFuZCBmZWUuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIF9nZXRWMlByaWNlc0ludGVybmFsQXN5bmMoXG4gICAgICAgIHF1b3RlQ29udGV4dDogUXVvdGVDb250ZXh0LFxuICAgICAgICBmZWU6IEZlZSxcbiAgICAgICAgbm93OiBEYXRlID0gbmV3IERhdGUoKSxcbiAgICApOiBQcm9taXNlPFJmcXRWMlByaWNlW10+IHtcbiAgICAgICAgY29uc3QgeyBpbnRlZ3JhdG9yLCBtYWtlclRva2VuLCB0YWtlclRva2VuIH0gPSBxdW90ZUNvbnRleHQ7XG4gICAgICAgIC8vIEZldGNoIHRoZSBtYWtlcnMgYWN0aXZlIG9uIHRoaXMgcGFpclxuICAgICAgICBjb25zdCBtYWtlcnMgPSB0aGlzLl9yZnFNYWtlck1hbmFnZXIuZ2V0UmZxdFYyTWFrZXJzRm9yUGFpcihtYWtlclRva2VuLCB0YWtlclRva2VuKS5maWx0ZXIoKG0pID0+IHtcbiAgICAgICAgICAgIGlmIChtLnJmcXRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW50ZWdyYXRvci53aGl0ZWxpc3RNYWtlcklkcyAmJiAhaW50ZWdyYXRvci53aGl0ZWxpc3RNYWtlcklkcy5pbmNsdWRlcyhtLm1ha2VySWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgbm8gbWFrZXJzIGFyZSBhY3RpdmVcbiAgICAgICAgaWYgKCFtYWtlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPIChoYW96aHVvKTogY2hlY2sgdG8gc2VlIGlmIE1NIHBhc3NlcyBjaXJjdWl0IGJyZWFrZXJcblxuICAgICAgICBjb25zdCBwcmljZXMgPSAoXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9xdW90ZVNlcnZlckNsaWVudC5iYXRjaEdldFByaWNlVjJBc3luYyhcbiAgICAgICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICBtYWtlcnMubWFwKChtKSA9PiAvKiB3b24ndCBiZSBudWxsIGJlY2F1c2Ugb2YgcHJldmlvdXMgYGZpbHRlcmAgb3BlcmF0aW9uICovIG0ucmZxdFVyaSEpLFxuICAgICAgICAgICAgICAgIGludGVncmF0b3IsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtUmZxdFYyUHJpY2VzUGFyYW1ldGVycyhxdW90ZUNvbnRleHQsIGZlZSwgdGhpcy5fY2hhaW5JZCksXG4gICAgICAgICAgICAgICAgKHVybCkgPT4gYCR7dXJsfS9yZnF0L3YyL3ByaWNlYCxcbiAgICAgICAgICAgIClcbiAgICAgICAgKS5tYXAoKHByaWNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYWtlciA9IG1ha2Vycy5maW5kKChtKSA9PiBtLnJmcXRVcmkgPT09IHByaWNlLm1ha2VyVXJpKTtcbiAgICAgICAgICAgIGlmICghbWFrZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIG1ha2VyIHdpdGggVVJJICR7cHJpY2UubWFrZXJVcml9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGV4cGlyeTogcHJpY2UuZXhwaXJ5LFxuICAgICAgICAgICAgICAgIG1ha2VyQWRkcmVzczogcHJpY2UubWFrZXIsXG4gICAgICAgICAgICAgICAgbWFrZXJBbW91bnQ6IHByaWNlLm1ha2VyQW1vdW50LFxuICAgICAgICAgICAgICAgIG1ha2VySWQ6IG1ha2VyLm1ha2VySWQsXG4gICAgICAgICAgICAgICAgbWFrZXJUb2tlbjogcHJpY2UubWFrZXJUb2tlbixcbiAgICAgICAgICAgICAgICBtYWtlclVyaTogcHJpY2UubWFrZXJVcmksXG4gICAgICAgICAgICAgICAgdGFrZXJBbW91bnQ6IHByaWNlLnRha2VyQW1vdW50LFxuICAgICAgICAgICAgICAgIHRha2VyVG9rZW46IHByaWNlLnRha2VyVG9rZW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaWx0ZXIgb3V0IGludmFsaWQgcHJpY2VzXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZFByaWNlcyA9IHZhbGlkYXRlVjJQcmljZXMocHJpY2VzLCBxdW90ZUNvbnRleHQsIHRoaXMuX21pbkV4cGlyeUR1cmF0aW9uTXMsIG5vdyk7XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZFByaWNlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHByaWNlIHJldHVybmVkIGZyb20gdGhlIG1hcmtldCBtYWtlcidzIGBwcmljZWAgZW5kcG9pbnRcbiAgICAgKiBpbnRvIGFuIHYyIG9yZGVyXG4gICAgICovXG4gICAgcHJpdmF0ZSBfdjJwcmljZVRvT3JkZXIocHJpY2U6IFJmcXRWMlByaWNlLCB0eE9yaWdpbjogc3RyaW5nLCBub25jZTogQmlnTnVtYmVyLCBub25jZUJ1Y2tldDogQmlnTnVtYmVyKTogT3RjT3JkZXIge1xuICAgICAgICByZXR1cm4gbmV3IE90Y09yZGVyKHtcbiAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuX2NoYWluSWQsXG4gICAgICAgICAgICBleHBpcnlBbmROb25jZTogT3RjT3JkZXIuZW5jb2RlRXhwaXJ5QW5kTm9uY2UocHJpY2UuZXhwaXJ5LCBub25jZUJ1Y2tldCwgbm9uY2UpLFxuICAgICAgICAgICAgbWFrZXI6IHByaWNlLm1ha2VyQWRkcmVzcyxcbiAgICAgICAgICAgIG1ha2VyQW1vdW50OiBwcmljZS5tYWtlckFtb3VudCxcbiAgICAgICAgICAgIG1ha2VyVG9rZW46IHByaWNlLm1ha2VyVG9rZW4sXG4gICAgICAgICAgICB0YWtlcjogTlVMTF9BRERSRVNTLFxuICAgICAgICAgICAgdGFrZXJBbW91bnQ6IHByaWNlLnRha2VyQW1vdW50LFxuICAgICAgICAgICAgdGFrZXJUb2tlbjogcHJpY2UudGFrZXJUb2tlbixcbiAgICAgICAgICAgIHR4T3JpZ2luLFxuICAgICAgICAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6IHRoaXMuX2NvbnRyYWN0QWRkcmVzc2VzLmV4Y2hhbmdlUHJveHksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==