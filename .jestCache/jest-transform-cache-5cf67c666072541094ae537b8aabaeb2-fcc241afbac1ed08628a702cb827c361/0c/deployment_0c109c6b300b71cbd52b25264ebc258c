20f458bd22178d02d20eae055937ef51
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupDependenciesAsync = void 0;
const child_process_1 = require("child_process");
const path = require("path");
const constants_1 = require("../../src/core/constants");
const initDbDataSourceAsync_1 = require("./initDbDataSourceAsync");
// depends on a `docker-compose.yml` existing in the api root directory
const dockerComposeFilename = 'docker-compose.yml';
/**
 * Sets up 0x-api's dependencies
 *
 * @param services An array of services to start
 * @returns A function handle which will tear down the dependencies when called
 */
async function setupDependenciesAsync(services) {
    if (services.length === 0) {
        throw new Error('Pick at least one service to start');
    }
    const configFilePath = path.resolve(__dirname, '../../', dockerComposeFilename);
    /**
     * Only starts the services specified in `services`.
     */
    const up = (0, child_process_1.spawn)(`docker-compose`, ['-f', configFilePath, 'up', ...services], {});
    await waitForDependencyStartupAsync(up, services);
    if (services.includes('postgres')) {
        await confirmPostgresConnectivityAsync();
    }
    // Return the function handle which will shutdown the services
    return function closeFunction() {
        const wasSuccessfulKill = up.kill();
        return wasSuccessfulKill;
    };
}
exports.setupDependenciesAsync = setupDependenciesAsync;
/**
 * Monitor the logs being emitted from the docker containers to detect
 * when services have started up. Postgres startup is managed with
 * `confirmPostgresConnectivityAsync`
 */
async function waitForDependencyStartupAsync(logStream, services) {
    return new Promise((resolve, reject) => {
        const startupTimeout = constants_1.ONE_MINUTE_MS * 3; // tslint:disable-line custom-no-magic-numbers
        const timeoutHandle = setTimeout(() => {
            reject(new Error(`Timed out waiting for dependency logs\n${JSON.stringify(isServiceStarted)}`));
        }, startupTimeout);
        const startupRegexSqs = /.*sqs.*listening on port \d{4}/;
        const startupRegexRedis = /.*redis.*Ready to accept connections/;
        const startupRegexGananche = /.*ganache.*Listening on 0.0.0.0:\d{4}/;
        const isServiceStarted = {
            sqs: !services.includes('sqs'),
            postgres: true,
            redis: !services.includes('redis'),
            ganache: !services.includes('ganache'),
        };
        logStream.on('error', (error) => {
            reject(`Stream closed with error: ${error}`);
        });
        logStream.stdout.on('data', (data) => {
            const log = data.toString();
            if (startupRegexRedis.test(log)) {
                isServiceStarted.redis = true;
            }
            if (startupRegexSqs.test(log)) {
                isServiceStarted.sqs = true;
            }
            if (startupRegexGananche.test(log)) {
                isServiceStarted.ganache = true;
            }
            // Once all the services are started, resolve the promise
            if (Object.values(isServiceStarted).every((v) => v)) {
                // logStream.stdout.removeAllListeners('data');
                // logStream.removeAllListeners('error');
                clearTimeout(timeoutHandle);
                resolve();
            }
        });
    });
}
// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
// eslint-disable-next-line @typescript-eslint/no-inferrable-types
async function confirmPostgresConnectivityAsync(maxTries = 5) {
    try {
        await Promise.all([
            // delay before retrying
            new Promise((resolve) => setTimeout(resolve, 2000)),
            async () => {
                await (0, initDbDataSourceAsync_1.initDbDataSourceAsync)();
            },
        ]);
        return;
    }
    catch (e) {
        if (maxTries > 0) {
            await confirmPostgresConnectivityAsync(maxTries - 1);
        }
        else {
            throw e;
        }
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3Rlc3QvdGVzdF91dGlscy9kZXBsb3ltZW50LnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLGlEQUFzRTtBQUN0RSw2QkFBNkI7QUFFN0Isd0RBQXlEO0FBRXpELG1FQUFnRTtBQUVoRSx1RUFBdUU7QUFDdkUsTUFBTSxxQkFBcUIsR0FBRyxvQkFBb0IsQ0FBQztBQVduRDs7Ozs7R0FLRztBQUNJLEtBQUssVUFBVSxzQkFBc0IsQ0FBQyxRQUFtQjtJQUM1RCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQztLQUN6RDtJQUVELE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO0lBRWhGOztPQUVHO0lBQ0gsTUFBTSxFQUFFLEdBQUcsSUFBQSxxQkFBSyxFQUFDLGdCQUFnQixFQUFFLENBQUMsSUFBSSxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsR0FBRyxRQUFRLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUVsRixNQUFNLDZCQUE2QixDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUVsRCxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUU7UUFDL0IsTUFBTSxnQ0FBZ0MsRUFBRSxDQUFDO0tBQzVDO0lBQ0QsOERBQThEO0lBQzlELE9BQU8sU0FBUyxhQUFhO1FBQ3pCLE1BQU0saUJBQWlCLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3BDLE9BQU8saUJBQWlCLENBQUM7SUFDN0IsQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQXRCRCx3REFzQkM7QUFFRDs7OztHQUlHO0FBQ0gsS0FBSyxVQUFVLDZCQUE2QixDQUN4QyxTQUF5QyxFQUN6QyxRQUFtQjtJQUVuQixPQUFPLElBQUksT0FBTyxDQUFPLENBQUMs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LXJmcS1hcGkvdGVzdC90ZXN0X3V0aWxzL2RlcGxveW1lbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hpbGRQcm9jZXNzV2l0aG91dE51bGxTdHJlYW1zLCBzcGF3biB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgT05FX01JTlVURV9NUyB9IGZyb20gJy4uLy4uL3NyYy9jb3JlL2NvbnN0YW50cyc7XG5cbmltcG9ydCB7IGluaXREYkRhdGFTb3VyY2VBc3luYyB9IGZyb20gJy4vaW5pdERiRGF0YVNvdXJjZUFzeW5jJztcblxuLy8gZGVwZW5kcyBvbiBhIGBkb2NrZXItY29tcG9zZS55bWxgIGV4aXN0aW5nIGluIHRoZSBhcGkgcm9vdCBkaXJlY3RvcnlcbmNvbnN0IGRvY2tlckNvbXBvc2VGaWxlbmFtZSA9ICdkb2NrZXItY29tcG9zZS55bWwnO1xuXG4vKipcbiAqIFJldHVybmVkIGJ5IGBzZXR1cERlcGVuZGVuY2llc0FzeW5jYC4gQ2FsbCB0byBzaHV0ZG93biB0aGVcbiAqIGRlcGVuZGVuY2llcyBzcHVuIHVwIGJ5IGBzZXR1cERlcGVuZGVuY2llc0FzeW5jYC4gUmV0dXJuc1xuICogYHRydWVgIGlmIHRoZSB0ZWFyZG93biBpcyBzdWNjZXNzZnVsLlxuICovXG5leHBvcnQgdHlwZSBUZWFyZG93bkRlcGVuZGVuY2llc0Z1bmN0aW9uSGFuZGxlID0gKCkgPT4gYm9vbGVhbjtcblxudHlwZSBTZXJ2aWNlID0gJ3NxcycgfCAncG9zdGdyZXMnIHwgJ3JlZGlzJyB8ICdnYW5hY2hlJztcblxuLyoqXG4gKiBTZXRzIHVwIDB4LWFwaSdzIGRlcGVuZGVuY2llc1xuICpcbiAqIEBwYXJhbSBzZXJ2aWNlcyBBbiBhcnJheSBvZiBzZXJ2aWNlcyB0byBzdGFydFxuICogQHJldHVybnMgQSBmdW5jdGlvbiBoYW5kbGUgd2hpY2ggd2lsbCB0ZWFyIGRvd24gdGhlIGRlcGVuZGVuY2llcyB3aGVuIGNhbGxlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0dXBEZXBlbmRlbmNpZXNBc3luYyhzZXJ2aWNlczogU2VydmljZVtdKTogUHJvbWlzZTxUZWFyZG93bkRlcGVuZGVuY2llc0Z1bmN0aW9uSGFuZGxlPiB7XG4gICAgaWYgKHNlcnZpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpY2sgYXQgbGVhc3Qgb25lIHNlcnZpY2UgdG8gc3RhcnQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25maWdGaWxlUGF0aCA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLi8uLi8nLCBkb2NrZXJDb21wb3NlRmlsZW5hbWUpO1xuXG4gICAgLyoqXG4gICAgICogT25seSBzdGFydHMgdGhlIHNlcnZpY2VzIHNwZWNpZmllZCBpbiBgc2VydmljZXNgLlxuICAgICAqL1xuICAgIGNvbnN0IHVwID0gc3Bhd24oYGRvY2tlci1jb21wb3NlYCwgWyctZicsIGNvbmZpZ0ZpbGVQYXRoLCAndXAnLCAuLi5zZXJ2aWNlc10sIHt9KTtcblxuICAgIGF3YWl0IHdhaXRGb3JEZXBlbmRlbmN5U3RhcnR1cEFzeW5jKHVwLCBzZXJ2aWNlcyk7XG5cbiAgICBpZiAoc2VydmljZXMuaW5jbHVkZXMoJ3Bvc3RncmVzJykpIHtcbiAgICAgICAgYXdhaXQgY29uZmlybVBvc3RncmVzQ29ubmVjdGl2aXR5QXN5bmMoKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSBmdW5jdGlvbiBoYW5kbGUgd2hpY2ggd2lsbCBzaHV0ZG93biB0aGUgc2VydmljZXNcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xvc2VGdW5jdGlvbigpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3Qgd2FzU3VjY2Vzc2Z1bEtpbGwgPSB1cC5raWxsKCk7XG4gICAgICAgIHJldHVybiB3YXNTdWNjZXNzZnVsS2lsbDtcbiAgICB9O1xufVxuXG4vKipcbiAqIE1vbml0b3IgdGhlIGxvZ3MgYmVpbmcgZW1pdHRlZCBmcm9tIHRoZSBkb2NrZXIgY29udGFpbmVycyB0byBkZXRlY3RcbiAqIHdoZW4gc2VydmljZXMgaGF2ZSBzdGFydGVkIHVwLiBQb3N0Z3JlcyBzdGFydHVwIGlzIG1hbmFnZWQgd2l0aFxuICogYGNvbmZpcm1Qb3N0Z3Jlc0Nvbm5lY3Rpdml0eUFzeW5jYFxuICovXG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yRGVwZW5kZW5jeVN0YXJ0dXBBc3luYyhcbiAgICBsb2dTdHJlYW06IENoaWxkUHJvY2Vzc1dpdGhvdXROdWxsU3RyZWFtcyxcbiAgICBzZXJ2aWNlczogU2VydmljZVtdLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnR1cFRpbWVvdXQgPSBPTkVfTUlOVVRFX01TICogMzsgLy8gdHNsaW50OmRpc2FibGUtbGluZSBjdXN0b20tbm8tbWFnaWMtbnVtYmVyc1xuICAgICAgICBjb25zdCB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBUaW1lZCBvdXQgd2FpdGluZyBmb3IgZGVwZW5kZW5jeSBsb2dzXFxuJHtKU09OLnN0cmluZ2lmeShpc1NlcnZpY2VTdGFydGVkKX1gKSk7XG4gICAgICAgIH0sIHN0YXJ0dXBUaW1lb3V0KTtcblxuICAgICAgICBjb25zdCBzdGFydHVwUmVnZXhTcXMgPSAvLipzcXMuKmxpc3RlbmluZyBvbiBwb3J0IFxcZHs0fS87XG4gICAgICAgIGNvbnN0IHN0YXJ0dXBSZWdleFJlZGlzID0gLy4qcmVkaXMuKlJlYWR5IHRvIGFjY2VwdCBjb25uZWN0aW9ucy87XG4gICAgICAgIGNvbnN0IHN0YXJ0dXBSZWdleEdhbmFuY2hlID0gLy4qZ2FuYWNoZS4qTGlzdGVuaW5nIG9uIDAuMC4wLjA6XFxkezR9LztcblxuICAgICAgICBjb25zdCBpc1NlcnZpY2VTdGFydGVkOiBSZWNvcmQ8U2VydmljZSwgYm9vbGVhbj4gPSB7XG4gICAgICAgICAgICBzcXM6ICFzZXJ2aWNlcy5pbmNsdWRlcygnc3FzJyksXG4gICAgICAgICAgICBwb3N0Z3JlczogdHJ1ZSwgLy8gbWFuYWdlZCBieSBjb25maXJtUG9zdGdyZXNDb25uZWN0aXZpdHlBc3luY1xuICAgICAgICAgICAgcmVkaXM6ICFzZXJ2aWNlcy5pbmNsdWRlcygncmVkaXMnKSxcbiAgICAgICAgICAgIGdhbmFjaGU6ICFzZXJ2aWNlcy5pbmNsdWRlcygnZ2FuYWNoZScpLFxuICAgICAgICB9O1xuXG4gICAgICAgIGxvZ1N0cmVhbS5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChgU3RyZWFtIGNsb3NlZCB3aXRoIGVycm9yOiAke2Vycm9yfWApO1xuICAgICAgICB9KTtcblxuICAgICAgICBsb2dTdHJlYW0uc3Rkb3V0Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvZyA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChzdGFydHVwUmVnZXhSZWRpcy50ZXN0KGxvZykpIHtcbiAgICAgICAgICAgICAgICBpc1NlcnZpY2VTdGFydGVkLnJlZGlzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydHVwUmVnZXhTcXMudGVzdChsb2cpKSB7XG4gICAgICAgICAgICAgICAgaXNTZXJ2aWNlU3RhcnRlZC5zcXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0dXBSZWdleEdhbmFuY2hlLnRlc3QobG9nKSkge1xuICAgICAgICAgICAgICAgIGlzU2VydmljZVN0YXJ0ZWQuZ2FuYWNoZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9uY2UgYWxsIHRoZSBzZXJ2aWNlcyBhcmUgc3RhcnRlZCwgcmVzb2x2ZSB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoaXNTZXJ2aWNlU3RhcnRlZCkuZXZlcnkoKHYpID0+IHYpKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9nU3RyZWFtLnN0ZG91dC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcbiAgICAgICAgICAgICAgICAvLyBsb2dTdHJlYW0ucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWluZmVycmFibGUtdHlwZXNcbmFzeW5jIGZ1bmN0aW9uIGNvbmZpcm1Qb3N0Z3Jlc0Nvbm5lY3Rpdml0eUFzeW5jKG1heFRyaWVzOiBudW1iZXIgPSA1KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgLy8gZGVsYXkgYmVmb3JlIHJldHJ5aW5nXG4gICAgICAgICAgICBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAwKSksIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6Y3VzdG9tLW5vLW1hZ2ljLW51bWJlcnNcbiAgICAgICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBpbml0RGJEYXRhU291cmNlQXN5bmMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm47XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAobWF4VHJpZXMgPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBjb25maXJtUG9zdGdyZXNDb25uZWN0aXZpdHlBc3luYyhtYXhUcmllcyAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==