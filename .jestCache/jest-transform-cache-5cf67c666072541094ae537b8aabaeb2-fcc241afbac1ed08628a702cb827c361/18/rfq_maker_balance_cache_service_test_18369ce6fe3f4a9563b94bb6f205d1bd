5181a6820ab6c5dd5ffde3ccb4519c5f
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const contract_addresses_1 = require("@0x/contract-addresses");
const utils_1 = require("@0x/utils");
const chai_1 = require("chai");
const ts_mockito_1 = require("ts-mockito");
const rfq_maker_balance_cache_service_1 = require("../../src/services/rfq_maker_balance_cache_service");
const cache_client_1 = require("../../src/utils/cache_client");
const rfq_blockchain_utils_1 = require("../../src/utils/rfq_blockchain_utils");
describe('RfqMakerBalanceCacheService', () => {
    const chainId = contract_addresses_1.ChainId.Ganache;
    const makerA = '0x1111111111111111111111111111111111111111';
    const makerB = '0x2222222222222222222222222222222222222222';
    const makerC = '0x3333333333333333333333333333333333333333';
    const tokenA = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';
    const tokenB = '0x6B175474E89094C44Da98b954EedeAC495271d0F';
    const tokenC = '0xdAC17F958D2ee523a2206206994597C13D831ec7';
    describe('getERC20OwnerBalancesAsync', () => {
        it('should get maker balances from the cache', async () => {
            const addresses = [
                { owner: makerA, token: tokenA },
                { owner: makerB, token: tokenB },
                { owner: makerC, token: tokenC },
            ];
            const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
            (0, ts_mockito_1.when)(cacheClientMock.getERC20OwnerBalancesAsync(chainId, addresses)).thenResolve([
                new utils_1.BigNumber(1),
                new utils_1.BigNumber(2),
                new utils_1.BigNumber(3),
            ]);
            const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
            const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
            (0, chai_1.expect)(await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, addresses)).to.deep.eq([
                new utils_1.BigNumber(1),
                new utils_1.BigNumber(2),
                new utils_1.BigNumber(3),
            ]);
            (0, ts_mockito_1.verify)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).never();
        });
        it('should fetch balances through balance check for addresses not found in the cache', async () => {
            const addresses = [
                { owner: makerA, token: tokenA },
                { owner: makerB, token: tokenB },
                { owner: makerC, token: tokenC },
            ];
            const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
            (0, ts_mockito_1.when)(cacheClientMock.getERC20OwnerBalancesAsync(chainId, addresses)).thenResolve([
                null,
                new utils_1.BigNumber(2),
                null,
            ]);
            (0, ts_mockito_1.when)(cacheClientMock.addERC20OwnerAsync(chainId, (0, ts_mockito_1.anything)())).thenResolve();
            const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
            (0, ts_mockito_1.when)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).thenResolve([
                new utils_1.BigNumber(1),
                new utils_1.BigNumber(3),
            ]);
            const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
            (0, chai_1.expect)(await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, addresses)).to.deep.eq([
                new utils_1.BigNumber(1),
                new utils_1.BigNumber(2),
                new utils_1.BigNumber(3),
            ]);
            (0, ts_mockito_1.verify)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).once();
        });
        it('should get zero addresses if balance check returns malformed results', async () => {
            const addresses = [
                { owner: makerA, token: tokenA },
                { owner: makerB, token: tokenB },
                { owner: makerC, token: tokenC },
            ];
            const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
            (0, ts_mockito_1.when)(cacheClientMock.getERC20OwnerBalancesAsync(chainId, addresses)).thenResolve([
                null,
                new utils_1.BigNumber(2),
                null,
            ]);
            (0, ts_mockito_1.when)(cacheClientMock.addERC20OwnerAsync(chainId, (0, ts_mockito_1.anything)())).thenResolve();
            const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
            (0, ts_mockito_1.when)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).thenResolve([]);
            const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
            (0, chai_1.expect)(await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, addresses)).to.deep.eq([
                new utils_1.BigNumber(0),
                new utils_1.BigNumber(2),
                new utils_1.BigNumber(0),
            ]);
            (0, ts_mockito_1.verify)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).once();
        });
        it('should throw an error if reading entries from the cache fails', async () => {
            const addresses = [
                { owner: makerA, token: tokenA },
                { owner: makerB, token: tokenB },
                { owner: makerC, token: '0xbadaddress' },
            ];
            const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
            (0, ts_mockito_1.when)(cacheClientMock.getERC20OwnerBalancesAsync((0, ts_mockito_1.anything)(), addresses)).thenReject(new Error('Failed to read entries from maker balance cache'));
            const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
            const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
            try {
                await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, addresses);
                chai_1.expect.fail();
            }
            catch (error) {
                (0, chai_1.expect)(error.message).to.contain('maker balance cache');
                (0, ts_mockito_1.verify)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).never();
            }
        });
        it('should get empty array when addresses are empty', async () => {
            const emptyAddresses = [];
            const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
            (0, ts_mockito_1.when)(cacheClientMock.getERC20OwnerBalancesAsync(chainId, emptyAddresses)).thenResolve([]);
            const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
            const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
            (0, chai_1.expect)(await makerBalanceCacheService.getERC20OwnerBalancesAsync(chainId, emptyAddresses)).to.deep.eq([]);
            (0, ts_mockito_1.verify)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).never();
        });
    });
    describe('updateERC20OwnerBalancesAsync', () => {
        it('should update the cache with given maker balances', async () => {
            const addresses = [
                { owner: makerA, token: tokenA },
                { owner: makerB, token: tokenB },
                { owner: makerC, token: tokenC },
            ];
            const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
            (0, ts_mockito_1.when)(cacheClientMock.getERC20OwnersAsync(chainId)).thenResolve(addresses);
            (0, ts_mockito_1.when)(cacheClientMock.setERC20OwnerBalancesAsync(chainId, addresses, (0, ts_mockito_1.anything)())).thenResolve();
            const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
            (0, ts_mockito_1.when)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(addresses)).thenResolve([
                new utils_1.BigNumber(1),
                new utils_1.BigNumber(2),
                new utils_1.BigNumber(3),
            ]);
            const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
            try {
                await makerBalanceCacheService.updateERC20OwnerBalancesAsync(chainId);
                (0, ts_mockito_1.verify)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).once();
            }
            catch (error) {
                chai_1.expect.fail();
            }
        });
    });
    it('should throw an error if writing entries to the cache fails', async () => {
        const addresses = [
            { owner: makerA, token: tokenA },
            { owner: makerB, token: tokenB },
            { owner: makerC, token: tokenC },
        ];
        const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
        (0, ts_mockito_1.when)(cacheClientMock.getERC20OwnersAsync(chainId)).thenResolve(addresses);
        (0, ts_mockito_1.when)(cacheClientMock.setERC20OwnerBalancesAsync(chainId, addresses, (0, ts_mockito_1.anything)())).thenReject(new Error('Failed to update entries for maker balance cache'));
        const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
        (0, ts_mockito_1.when)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync(addresses)).thenResolve([
            new utils_1.BigNumber(1),
            new utils_1.BigNumber(2),
            new utils_1.BigNumber(3),
        ]);
        const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
        try {
            await makerBalanceCacheService.updateERC20OwnerBalancesAsync(chainId);
            chai_1.expect.fail();
        }
        catch (error) {
            (0, chai_1.expect)(error.message).to.contain('maker balance cache');
            (0, ts_mockito_1.verify)(balanceCheckUtilsMock.getMinOfBalancesAndAllowancesAsync((0, ts_mockito_1.anything)())).once();
        }
    });
    describe('evictZeroBalancesAsync', () => {
        it('should evict entries from the cache', async () => {
            const cacheClientMock = (0, ts_mockito_1.mock)(cache_client_1.CacheClient);
            (0, ts_mockito_1.when)(cacheClientMock.evictZeroBalancesAsync(chainId)).thenResolve(1);
            const balanceCheckUtilsMock = (0, ts_mockito_1.mock)(rfq_blockchain_utils_1.RfqBalanceCheckUtils);
            const makerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService((0, ts_mockito_1.instance)(cacheClientMock), (0, ts_mockito_1.instance)(balanceCheckUtilsMock));
            try {
                const numEvicted = await makerBalanceCacheService.evictZeroBalancesAsync(chainId);
                (0, chai_1.expect)(numEvicted).to.eq(1);
                (0, ts_mockito_1.verify)(cacheClientMock.evictZeroBalancesAsync(chainId)).once();
            }
            catch (error) {
                chai_1.expect.fail();
            }
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3Rlc3Qvc2VydmljZXMvcmZxX21ha2VyX2JhbGFuY2VfY2FjaGVfc2VydmljZV90ZXN0LnRzIiwibWFwcGluZ3MiOiI7O0FBQUEsK0RBQWlEO0FBQ2pELHFDQUFzQztBQUN0QywrQkFBOEI7QUFDOUIsMkNBQW9FO0FBRXBFLHdHQUFpRztBQUVqRywrREFBMkQ7QUFDM0QsK0VBQTRFO0FBRTVFLFFBQVEsQ0FBQyw2QkFBNkIsRUFBRSxHQUFHLEVBQUU7SUFDekMsTUFBTSxPQUFPLEdBQUcsNEJBQU8sQ0FBQyxPQUFPLENBQUM7SUFFaEMsTUFBTSxNQUFNLEdBQUcsNENBQTRDLENBQUM7SUFDNUQsTUFBTSxNQUFNLEdBQUcsNENBQTRDLENBQUM7SUFDNUQsTUFBTSxNQUFNLEdBQUcsNENBQTRDLENBQUM7SUFFNUQsTUFBTSxNQUFNLEdBQUcsNENBQTRDLENBQUM7SUFDNUQsTUFBTSxNQUFNLEdBQUcsNENBQTRDLENBQUM7SUFDNUQsTUFBTSxNQUFNLEdBQUcsNENBQTRDLENBQUM7SUFFNUQsUUFBUSxDQUFDLDRCQUE0QixFQUFFLEdBQUcsRUFBRTtRQUN4QyxFQUFFLENBQUMsMENBQTBDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDdEQsTUFBTSxTQUFTLEdBQUc7Z0JBQ2QsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUU7Z0JBQ2hDLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFO2dCQUNoQyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRTthQUNuQyxDQUFDO1lBRUYsTUFBTSxlQUFlLEdBQUcsSUFBQSxpQkFBSSxFQUFDLDBCQUFXLENBQUMsQ0FBQztZQUMxQyxJQUFBLGlCQUFJLEVBQUMsZUFBZSxDQUFDLDBCQUEwQixDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQztnQkFDN0UsSUFBSSxpQkFBUyxDQUFDLENBQUMsQ0FBQztnQkFDaEIsSUFBSSxpQkFBUyxDQUFDLENBQUMsQ0FBQztnQkFDaEIsSUFBSSxpQkFBUyxDQUFDLENBQUMsQ0FBQzthQUNuQixDQUFDLENBQUM7WUFDSCxNQUFNLHFCQUFxQixHQUFHLElBQUEsaUJBQUksRUFBQywyQ0FBb0IsQ0FBQyxDQUFDO1lBQ3pELE1BQU0sd0JBQXdCLEdBQUcsSUFBSSw2REFBMkIsQ0FDNUQsSUFBQSxxQkFBUSxFQUFDLGVBQWUsQ0FBQyxFQUN6QixJQUFBLHFCQUFRLEVBQUMscUJBQXFCLENBQUMsQ0FDbEMsQ0FBQztZQUVGLElBQUEsYUFBTSxFQUFDLE1BQU0sd0JBQXdCLENBQUMsMEJBQTBCLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7Z0JBQzdGLElBQUksaUJBQVMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hCLElBQUksaUJBQVMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hCLElBQUksaUJBQVMsQ0FBQyxDQUFDLENBQUM7YUFDbkIsQ0FBQyxDQUFDO1lBQ0gsSUFBQSxtQkFBTSxFQUFDLHFCQUFxQixDQUFDLGtDQUFrQyxDQUFDLElBQUEscUJBQVEsR0FBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUN6RixDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxrRkFBa0YsRUFBRSxLQUFLLElBQUksRUFBRTtZQUM5RixNQUFNLFNBQVMsR0FBRztnQkFDZCxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRTtnQkFDaEMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUU7Z0JBQ2hDLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFO2FBQ25DLENBQUM7WUFFRixNQUFNLGVBQWUsR0FBRyxJQUFBLGlCQUFJLEVBQUMsMEJBQVcsQ0FBQyxDQUFDO1lBQzFDLElBQUEsaUJBQUksRUFBQyxlQUFlLENBQUMsMEJBQTBCLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDO2dCQUM3RSxJQUFJO2dCQUNKLElBQUksaUJBQVMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hCLElBQUk7YUFDUCxDQUFDLENBQUM7WUFDSCxJQUFBLGlCQUFJLEVBQUMsZUFBZSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxJQUFBLHFCQUFRLEdBQUUsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDNUUsTUFBTSxxQkFBcUIsR0FBRyxJQUFBLGlCQUFJLEVBQUMsMkNBQW9CLENBQUMsQ0FBQztZQUN6RCxJQUFBLGlCQUFJLEVBQUMscUJBQXFCLENBQUMsa0NBQWtDLENBQUMsSUFBQSxxQkFBUSxHQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQztnQkFDbkYsSUFBSSxpQkFBUyxDQUFDLENBQUMsQ0FBQztnQkFDaEIsSUFBSSxpQkFBUyxDQUFDLENBQUMsQ0FBQzthQUNuQixDQUFDLENBQUM7WUFDSCxNQUFNLHdCQUF3QixHQUFHLElBQUksNkRBQTJCLENBQzVELElBQUEscUJBQVEsRUFBQyxlQUFlLENBQUMsRUFDekIsSUFBQSxxQkFBUSxFQUFDLHFCQUFxQixDQUFDLENBQ2xDLENBQUM7WUFFRixJQUFBLGFBQU0sRUFBQyxNQUFNLHdCQUF3QixDQUFDLDBCQUEwQixDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUM3RixJQUFJLGlCQUFTLENBQUMsQ0FBQyxDQUFDO2dCQUNoQixJQUFJLGlCQUFTLENBQUMsQ0FBQyxDQUFDO2dCQUNoQixJQUFJLGlCQUFTLENBQUMsQ0FBQyxDQUFDO2FBQ25CLENBQUMsQ0FBQztZQUNILElBQUEsbUJBQU0sRUFBQyxxQkFBcUIsQ0FBQyxrQ0FBa0MsQ0FBQyxJQUFBLHFCQUFRLEdBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDeEYsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsc0VBQXNFLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDbEYsTUFBTSxTQUFTLEdBQUc7Z0JBQ2QsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUU7Z0JBQ2hDLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFO2dCQUNoQyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRTthQUNuQyxDQUFDO1lBRUYsTUFBTSxlQUFlLEdBQUcsSUFBQSxpQkFBSSxFQUFDLDBCQUFXLENBQUMsQ0FBQztZQUMxQyxJQUFBLGlCQUFJLEVBQUMsZUFBZSxDQUFDLDBCQUEwQixDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQztnQkFDN0UsSUFBSTtnQkFDSixJQUFJLGlCQUFTLENBQUMsQ0FBQyxDQUFDO2dCQUNoQixJQUFJO2FBQ1AsQ0FBQyxDQUFDO1lBQ0gsSUFBQSxpQkFBSSxFQUFDLGVBQWUsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsSUFBQSxxQkFBUSxHQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQzVFLE1BQU0scUJBQXFCLEdBQUcsSUFBQSxpQkFBSSxFQUFDLDJDQUFvQixDQUFDLENBQUM7WUFDekQsSUFBQSxpQkFBSSxFQUFDLHFCQUFxQixDQUFDLGtDQUFrQyxDQUFDLElBQUEscUJBQVEsR0FBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDM0YsTUFBTSx3QkFBd0IsR0FBRyxJQUFJLDZEQUEyQixDQUM1RCxJQUFBLHFCQUFRLEVBQUMsZUFBZSxDQUFDLEVBQ3pCLElBQUEscUJBQVEsRUFBQyxxQkFBcUIsQ0FBQyxDQUNsQyxDQUFDO1lBRUYsSUFBQSxhQUFNLEVBQUMsTUFBTSx3QkFBd0IsQ0FBQywwQkFBMEIsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDN0YsSUFBSSxpQkFBUyxDQUFDLENBQUMsQ0FBQztnQkFDaEIsSUFBSSxpQkFBUyxDQUFDLENBQUMsQ0FBQztnQkFDaEIsSUFBSSxpQkFBUyxDQUFDLENBQUMsQ0FBQzthQUNuQixDQUFDLENBQUM7WUFDSCxJQUFBLG1CQUFNLEVBQUMscUJBQXFCLENBQUMsa0NBQWtDLENBQUMsSUFBQSxxQkFBUSxHQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3hGLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLCtEQUErRCxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzNFLE1BQU0sU0FBUyxHQUFHO2dCQUNkLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFO2dCQUNoQyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRTtnQkFDaEMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUU7YUFDM0MsQ0FBQztZQUVGLE1BQU0sZUFBZSxHQUFHLElBQUEsaUJBQUksRUFBQywwQkFBVyxDQUFDLENBQUM7WUFDMUMsSUFBQSxpQkFBSSxFQUFDLGVBQWUsQ0FBQywwQkFBMEIsQ0FBQyxJQUFBLHFCQUFRLEdBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FDOUUsSUFBSSxLQUFLLENBQUMsaURBQWlELENBQUMsQ0FDL0QsQ0FBQztZQUNGLE1BQU0scUJBQXFCLEdBQUcsSUFBQSxpQkFBSSxFQUFDLDJDQUFvQixDQUFDLENBQUM7WUFDekQsTUFBTSx3QkFBd0IsR0FBRyxJQUFJLDZEQUEyQixDQUM1RCxJQUFBLHFCQUFRLEVBQUMsZUFBZSxDQUFDLEVBQ3pCLElBQUEscUJBQVEsRUFBQyxxQkFBcUIsQ0FBQyxDQUNsQyxDQUFDO1lBRUYsSUFBSTtnQkFDQSxNQUFNLHdCQUF3QixDQUFDLDBCQUEwQixDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztnQkFDOUUsYUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO2FBQ2pCO1lBQUMsT0FBTyxLQUFLLEVBQUU7Z0JBQ1osSUFBQSxhQUFNLEVBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQztnQkFDeEQsSUFBQSxtQkFBTSxFQUFDLHFCQUFxQixDQUFDLGtDQUFrQyxDQUFDLElBQUEscUJBQVEsR0FBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUN4RjtRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLGlEQUFpRCxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzdELE1BQU0sY0FBYyxHQUFpQixFQUFFLENBQUM7WUFFeEMsTUFBTSxlQUFlLEdBQUcsSUFBQSxpQkFBSSxFQUFDLDBCQUFXLENBQUMsQ0FBQztZQUMxQyxJQUFBLGlCQUFJLEVBQUMsZUFBZSxDQUFDLDBCQUEwQixDQUFDLE9BQU8sRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUMxRixNQUFNLHFCQUFxQixHQUFHLElBQUEsaUJBQUksRUFBQywyQ0FBb0IsQ0FBQyxDQUFDO1lBQ3pELE1BQU0sd0JBQXdCLEdBQUcsSUFBSSw2REFBMkIsQ0FDNUQsSUFBQSxxQkFBUSxFQUFDLGVBQWUsQ0FBQyxFQUN6QixJQUFBLHFCQUFRLEVBQUMscUJBQXFCLENBQUMsQ0FDbEMsQ0FBQztZQUVGLElBQUEsYUFBTSxFQUFDLE1BQU0sd0JBQXdCLENBQUMsMEJBQTBCLENBQUMsT0FBTyxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDMUcsSUFBQSxtQkFBTSxFQUFDLHFCQUFxQixDQUFDLGtDQUFrQyxDQUFDLElBQUEscUJBQVEsR0FBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUN6RixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLCtCQUErQixFQUFFLEdBQUcsRUFBRTtRQUMzQyxFQUFFLENBQUMsbURBQW1ELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDL0QsTUFBTSxTQUFTLEdBQUc7Z0JBQ2QsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUU7Z0JBQ2hDLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFO2dCQUNoQyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRTthQUNuQyxDQUFDO1lBQ0YsTUFBTSxlQUFlLEdBQUcsSUFBQSxpQkFBSSxFQUFDLDBCQUFXLENBQUMsQ0FBQztZQUMxQyxJQUFBLGlCQUFJLEVBQUMsZUFBZSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQzFFLElBQUEsaUJBQUksRUFBQyxlQUFlLENBQUMsMEJBQTBCLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFBLHFCQUFRLEdBQUUsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDL0YsTUFBTSxxQkFBcUIsR0FBRyxJQUFBLGlCQUFJLEVBQUMsMkNBQW9CLENBQUMsQ0FBQztZQUN6RCxJQUFBLGlCQUFJLEVBQUMscUJBQXFCLENBQUMsa0NBQWtDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7Z0JBQ2xGLElBQUksaUJBQVMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hCLElBQUksaUJBQVMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hCLElBQUksaUJBQVMsQ0FBQyxDQUFDLENBQUM7YUFDbkIsQ0FBQyxDQUFDO1lBQ0gsTUFBTSx3QkFBd0IsR0FBRyxJQUFJLDZEQUEyQixDQUM1RCxJQUFBLHFCQUFRLEVBQUMsZUFBZSxDQUFDLEVBQ3pCLElBQUEscUJBQVEsRUFBQyxxQkFBcUIsQ0FBQyxDQUNsQyxDQUFDO1lBRUYsSUFBSTtnQkFDQSxNQUFNLHdCQUF3QixDQUFDLDZCQUE2QixDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUN0RSxJQUFBLG1CQUFNLEVBQUMscUJBQXFCLENBQUMsa0NBQWtDLENBQUMsSUFBQSxxQkFBUSxHQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO2FBQ3ZGO1lBQUMsT0FBTyxLQUFLLEVBQUU7Z0JBQ1osYUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO2FBQ2pCO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDLENBQUMsQ0FBQztJQUVILEVBQUUsQ0FBQyw2REFBNkQsRUFBRSxLQUFLLElBQUksRUFBRTtRQUN6RSxNQUFNLFNBQVMsR0FBRztZQUNkLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFO1lBQ2hDLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFO1lBQ2hDLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFO1NBQ25DLENBQUM7UUFDRixNQUFNLGVBQWUsR0FBRyxJQUFBLGlCQUFJLEVBQUMsMEJBQVcsQ0FBQyxDQUFDO1FBQzFDLElBQUEsaUJBQUksRUFBQyxlQUFlLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDMUUsSUFBQSxpQkFBSSxFQUFDLGVBQWUsQ0FBQywwQkFBMEIsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLElBQUEscUJBQVEsR0FBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQ3ZGLElBQUksS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQ2hFLENBQUM7UUFDRixNQUFNLHFCQUFxQixHQUFHLElBQUEsaUJBQUksRUFBQywyQ0FBb0IsQ0FBQyxDQUFDO1FBQ3pELElBQUEsaUJBQUksRUFBQyxxQkFBcUIsQ0FBQyxrQ0FBa0MsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQztZQUNsRixJQUFJLGlCQUFTLENBQUMsQ0FBQyxDQUFDO1lBQ2hCLElBQUksaUJBQVMsQ0FBQyxDQUFDLENBQUM7WUFDaEIsSUFBSSxpQkFBUyxDQUFDLENBQUMsQ0FBQztTQUNuQixDQUFDLENBQUM7UUFDSCxNQUFNLHdCQUF3QixHQUFHLElBQUksNkRBQTJCLENBQzVELElBQUEscUJBQVEsRUFBQyxlQUFlLENBQUMsRUFDekIsSUFBQSxxQkFBUSxFQUFDLHFCQUFxQixDQUFDLENBQ2xDLENBQUM7UUFFRixJQUFJO1lBQ0EsTUFBTSx3QkFBd0IsQ0FBQyw2QkFBNkIsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN0RSxhQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDakI7UUFBQyxPQUFPLEtBQUssRUFBRTtZQUNaLElBQUEsYUFBTSxFQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUM7WUFDeEQsSUFBQSxtQkFBTSxFQUFDLHFCQUFxQixDQUFDLGtDQUFrQyxDQUFDLElBQUEscUJBQVEsR0FBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUN2RjtJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLHdCQUF3QixFQUFFLEdBQUcsRUFBRTtRQUNwQyxFQUFFLENBQUMscUNBQXFDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDakQsTUFBTSxlQUFlLEdBQUcsSUFBQSxpQkFBSSxFQUFDLDBCQUFXLENBQUMsQ0FBQztZQUMxQyxJQUFBLGlCQUFJLEVBQUMsZUFBZSxDQUFDLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JFLE1BQU0scUJBQXFCLEdBQUcsSUFBQSxpQkFBSSxFQUFDLDJDQUFvQixDQUFDLENBQUM7WUFDekQsTUFBTSx3QkFBd0IsR0FBRyxJQUFJLDZEQUEyQixDQUM1RCxJQUFBLHFCQUFRLEVBQUMsZUFBZSxDQUFDLEVBQ3pCLElBQUEscUJBQVEsRUFBQyxxQkFBcUIsQ0FBQyxDQUNsQyxDQUFDO1lBRUYsSUFBSTtnQkFDQSxNQUFNLFVBQVUsR0FBRyxNQUFNLHdCQUF3QixDQUFDLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUNsRixJQUFBLGFBQU0sRUFBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM1QixJQUFBLG1CQUFNLEVBQUMsZUFBZSxDQUFDLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDbEU7WUFBQyxPQUFPLEtBQUssRUFBRTtnQkFDWixhQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDakI7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3Rlc3Qvc2VydmljZXMvcmZxX21ha2VyX2JhbGFuY2VfY2FjaGVfc2VydmljZV90ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYWluSWQgfSBmcm9tICdAMHgvY29udHJhY3QtYWRkcmVzc2VzJztcclxuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnQDB4L3V0aWxzJztcclxuaW1wb3J0IHsgZXhwZWN0IH0gZnJvbSAnY2hhaSc7XHJcbmltcG9ydCB7IGFueXRoaW5nLCBpbnN0YW5jZSwgbW9jaywgdmVyaWZ5LCB3aGVuIH0gZnJvbSAndHMtbW9ja2l0byc7XHJcblxyXG5pbXBvcnQgeyBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zcmMvc2VydmljZXMvcmZxX21ha2VyX2JhbGFuY2VfY2FjaGVfc2VydmljZSc7XHJcbmltcG9ydCB7IEVSQzIwT3duZXIgfSBmcm9tICcuLi8uLi9zcmMvY29yZS90eXBlcyc7XHJcbmltcG9ydCB7IENhY2hlQ2xpZW50IH0gZnJvbSAnLi4vLi4vc3JjL3V0aWxzL2NhY2hlX2NsaWVudCc7XHJcbmltcG9ydCB7IFJmcUJhbGFuY2VDaGVja1V0aWxzIH0gZnJvbSAnLi4vLi4vc3JjL3V0aWxzL3JmcV9ibG9ja2NoYWluX3V0aWxzJztcclxuXHJcbmRlc2NyaWJlKCdSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UnLCAoKSA9PiB7XHJcbiAgICBjb25zdCBjaGFpbklkID0gQ2hhaW5JZC5HYW5hY2hlO1xyXG5cclxuICAgIGNvbnN0IG1ha2VyQSA9ICcweDExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnO1xyXG4gICAgY29uc3QgbWFrZXJCID0gJzB4MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMic7XHJcbiAgICBjb25zdCBtYWtlckMgPSAnMHgzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzJztcclxuXHJcbiAgICBjb25zdCB0b2tlbkEgPSAnMHhDMDJhYUEzOWIyMjNGRThEMEEwZTVDNEYyN2VBRDkwODNDNzU2Q2MyJztcclxuICAgIGNvbnN0IHRva2VuQiA9ICcweDZCMTc1NDc0RTg5MDk0QzQ0RGE5OGI5NTRFZWRlQUM0OTUyNzFkMEYnO1xyXG4gICAgY29uc3QgdG9rZW5DID0gJzB4ZEFDMTdGOTU4RDJlZTUyM2EyMjA2MjA2OTk0NTk3QzEzRDgzMWVjNyc7XHJcblxyXG4gICAgZGVzY3JpYmUoJ2dldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCdzaG91bGQgZ2V0IG1ha2VyIGJhbGFuY2VzIGZyb20gdGhlIGNhY2hlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXHJcbiAgICAgICAgICAgICAgICB7IG93bmVyOiBtYWtlckEsIHRva2VuOiB0b2tlbkEgfSxcclxuICAgICAgICAgICAgICAgIHsgb3duZXI6IG1ha2VyQiwgdG9rZW46IHRva2VuQiB9LFxyXG4gICAgICAgICAgICAgICAgeyBvd25lcjogbWFrZXJDLCB0b2tlbjogdG9rZW5DIH0sXHJcbiAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjYWNoZUNsaWVudE1vY2sgPSBtb2NrKENhY2hlQ2xpZW50KTtcclxuICAgICAgICAgICAgd2hlbihjYWNoZUNsaWVudE1vY2suZ2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmMoY2hhaW5JZCwgYWRkcmVzc2VzKSkudGhlblJlc29sdmUoW1xyXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcigxKSxcclxuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMiksXHJcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDMpLFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgY29uc3QgYmFsYW5jZUNoZWNrVXRpbHNNb2NrID0gbW9jayhSZnFCYWxhbmNlQ2hlY2tVdGlscyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSA9IG5ldyBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UoXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZShjYWNoZUNsaWVudE1vY2spLFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UoYmFsYW5jZUNoZWNrVXRpbHNNb2NrKSxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChhd2FpdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UuZ2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmMoY2hhaW5JZCwgYWRkcmVzc2VzKSkudG8uZGVlcC5lcShbXHJcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDEpLFxyXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcigyKSxcclxuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMyksXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB2ZXJpZnkoYmFsYW5jZUNoZWNrVXRpbHNNb2NrLmdldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMoYW55dGhpbmcoKSkpLm5ldmVyKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgZmV0Y2ggYmFsYW5jZXMgdGhyb3VnaCBiYWxhbmNlIGNoZWNrIGZvciBhZGRyZXNzZXMgbm90IGZvdW5kIGluIHRoZSBjYWNoZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW1xyXG4gICAgICAgICAgICAgICAgeyBvd25lcjogbWFrZXJBLCB0b2tlbjogdG9rZW5BIH0sXHJcbiAgICAgICAgICAgICAgICB7IG93bmVyOiBtYWtlckIsIHRva2VuOiB0b2tlbkIgfSxcclxuICAgICAgICAgICAgICAgIHsgb3duZXI6IG1ha2VyQywgdG9rZW46IHRva2VuQyB9LFxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY2FjaGVDbGllbnRNb2NrID0gbW9jayhDYWNoZUNsaWVudCk7XHJcbiAgICAgICAgICAgIHdoZW4oY2FjaGVDbGllbnRNb2NrLmdldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKGNoYWluSWQsIGFkZHJlc3NlcykpLnRoZW5SZXNvbHZlKFtcclxuICAgICAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDIpLFxyXG4gICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIHdoZW4oY2FjaGVDbGllbnRNb2NrLmFkZEVSQzIwT3duZXJBc3luYyhjaGFpbklkLCBhbnl0aGluZygpKSkudGhlblJlc29sdmUoKTtcclxuICAgICAgICAgICAgY29uc3QgYmFsYW5jZUNoZWNrVXRpbHNNb2NrID0gbW9jayhSZnFCYWxhbmNlQ2hlY2tVdGlscyk7XHJcbiAgICAgICAgICAgIHdoZW4oYmFsYW5jZUNoZWNrVXRpbHNNb2NrLmdldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMoYW55dGhpbmcoKSkpLnRoZW5SZXNvbHZlKFtcclxuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMSksXHJcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDMpLFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgY29uc3QgbWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlID0gbmV3IFJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZShcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlKGNhY2hlQ2xpZW50TW9jayksXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZShiYWxhbmNlQ2hlY2tVdGlsc01vY2spLFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KGF3YWl0IG1ha2VyQmFsYW5jZUNhY2hlU2VydmljZS5nZXRFUkMyME93bmVyQmFsYW5jZXNBc3luYyhjaGFpbklkLCBhZGRyZXNzZXMpKS50by5kZWVwLmVxKFtcclxuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMSksXHJcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDIpLFxyXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcigzKSxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIHZlcmlmeShiYWxhbmNlQ2hlY2tVdGlsc01vY2suZ2V0TWluT2ZCYWxhbmNlc0FuZEFsbG93YW5jZXNBc3luYyhhbnl0aGluZygpKSkub25jZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGdldCB6ZXJvIGFkZHJlc3NlcyBpZiBiYWxhbmNlIGNoZWNrIHJldHVybnMgbWFsZm9ybWVkIHJlc3VsdHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IFtcclxuICAgICAgICAgICAgICAgIHsgb3duZXI6IG1ha2VyQSwgdG9rZW46IHRva2VuQSB9LFxyXG4gICAgICAgICAgICAgICAgeyBvd25lcjogbWFrZXJCLCB0b2tlbjogdG9rZW5CIH0sXHJcbiAgICAgICAgICAgICAgICB7IG93bmVyOiBtYWtlckMsIHRva2VuOiB0b2tlbkMgfSxcclxuICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlQ2xpZW50TW9jayA9IG1vY2soQ2FjaGVDbGllbnQpO1xyXG4gICAgICAgICAgICB3aGVuKGNhY2hlQ2xpZW50TW9jay5nZXRFUkMyME93bmVyQmFsYW5jZXNBc3luYyhjaGFpbklkLCBhZGRyZXNzZXMpKS50aGVuUmVzb2x2ZShbXHJcbiAgICAgICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcigyKSxcclxuICAgICAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB3aGVuKGNhY2hlQ2xpZW50TW9jay5hZGRFUkMyME93bmVyQXN5bmMoY2hhaW5JZCwgYW55dGhpbmcoKSkpLnRoZW5SZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2VDaGVja1V0aWxzTW9jayA9IG1vY2soUmZxQmFsYW5jZUNoZWNrVXRpbHMpO1xyXG4gICAgICAgICAgICB3aGVuKGJhbGFuY2VDaGVja1V0aWxzTW9jay5nZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKGFueXRoaW5nKCkpKS50aGVuUmVzb2x2ZShbXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSA9IG5ldyBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UoXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZShjYWNoZUNsaWVudE1vY2spLFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UoYmFsYW5jZUNoZWNrVXRpbHNNb2NrKSxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChhd2FpdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UuZ2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmMoY2hhaW5JZCwgYWRkcmVzc2VzKSkudG8uZGVlcC5lcShbXHJcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDApLFxyXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcigyKSxcclxuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMCksXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB2ZXJpZnkoYmFsYW5jZUNoZWNrVXRpbHNNb2NrLmdldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMoYW55dGhpbmcoKSkpLm9uY2UoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCB0aHJvdyBhbiBlcnJvciBpZiByZWFkaW5nIGVudHJpZXMgZnJvbSB0aGUgY2FjaGUgZmFpbHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IFtcclxuICAgICAgICAgICAgICAgIHsgb3duZXI6IG1ha2VyQSwgdG9rZW46IHRva2VuQSB9LFxyXG4gICAgICAgICAgICAgICAgeyBvd25lcjogbWFrZXJCLCB0b2tlbjogdG9rZW5CIH0sXHJcbiAgICAgICAgICAgICAgICB7IG93bmVyOiBtYWtlckMsIHRva2VuOiAnMHhiYWRhZGRyZXNzJyB9LFxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY2FjaGVDbGllbnRNb2NrID0gbW9jayhDYWNoZUNsaWVudCk7XHJcbiAgICAgICAgICAgIHdoZW4oY2FjaGVDbGllbnRNb2NrLmdldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKGFueXRoaW5nKCksIGFkZHJlc3NlcykpLnRoZW5SZWplY3QoXHJcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZWFkIGVudHJpZXMgZnJvbSBtYWtlciBiYWxhbmNlIGNhY2hlJyksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2VDaGVja1V0aWxzTW9jayA9IG1vY2soUmZxQmFsYW5jZUNoZWNrVXRpbHMpO1xyXG4gICAgICAgICAgICBjb25zdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UgPSBuZXcgUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlKFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UoY2FjaGVDbGllbnRNb2NrKSxcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlKGJhbGFuY2VDaGVja1V0aWxzTW9jayksXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgbWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlLmdldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKGNoYWluSWQsIGFkZHJlc3Nlcyk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QuZmFpbCgpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLnRvLmNvbnRhaW4oJ21ha2VyIGJhbGFuY2UgY2FjaGUnKTtcclxuICAgICAgICAgICAgICAgIHZlcmlmeShiYWxhbmNlQ2hlY2tVdGlsc01vY2suZ2V0TWluT2ZCYWxhbmNlc0FuZEFsbG93YW5jZXNBc3luYyhhbnl0aGluZygpKSkubmV2ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGdldCBlbXB0eSBhcnJheSB3aGVuIGFkZHJlc3NlcyBhcmUgZW1wdHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVtcHR5QWRkcmVzc2VzOiBFUkMyME93bmVyW10gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlQ2xpZW50TW9jayA9IG1vY2soQ2FjaGVDbGllbnQpO1xyXG4gICAgICAgICAgICB3aGVuKGNhY2hlQ2xpZW50TW9jay5nZXRFUkMyME93bmVyQmFsYW5jZXNBc3luYyhjaGFpbklkLCBlbXB0eUFkZHJlc3NlcykpLnRoZW5SZXNvbHZlKFtdKTtcclxuICAgICAgICAgICAgY29uc3QgYmFsYW5jZUNoZWNrVXRpbHNNb2NrID0gbW9jayhSZnFCYWxhbmNlQ2hlY2tVdGlscyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSA9IG5ldyBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UoXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZShjYWNoZUNsaWVudE1vY2spLFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UoYmFsYW5jZUNoZWNrVXRpbHNNb2NrKSxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChhd2FpdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UuZ2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmMoY2hhaW5JZCwgZW1wdHlBZGRyZXNzZXMpKS50by5kZWVwLmVxKFtdKTtcclxuICAgICAgICAgICAgdmVyaWZ5KGJhbGFuY2VDaGVja1V0aWxzTW9jay5nZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKGFueXRoaW5nKCkpKS5uZXZlcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ3VwZGF0ZUVSQzIwT3duZXJCYWxhbmNlc0FzeW5jJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCdzaG91bGQgdXBkYXRlIHRoZSBjYWNoZSB3aXRoIGdpdmVuIG1ha2VyIGJhbGFuY2VzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXHJcbiAgICAgICAgICAgICAgICB7IG93bmVyOiBtYWtlckEsIHRva2VuOiB0b2tlbkEgfSxcclxuICAgICAgICAgICAgICAgIHsgb3duZXI6IG1ha2VyQiwgdG9rZW46IHRva2VuQiB9LFxyXG4gICAgICAgICAgICAgICAgeyBvd25lcjogbWFrZXJDLCB0b2tlbjogdG9rZW5DIH0sXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlQ2xpZW50TW9jayA9IG1vY2soQ2FjaGVDbGllbnQpO1xyXG4gICAgICAgICAgICB3aGVuKGNhY2hlQ2xpZW50TW9jay5nZXRFUkMyME93bmVyc0FzeW5jKGNoYWluSWQpKS50aGVuUmVzb2x2ZShhZGRyZXNzZXMpO1xyXG4gICAgICAgICAgICB3aGVuKGNhY2hlQ2xpZW50TW9jay5zZXRFUkMyME93bmVyQmFsYW5jZXNBc3luYyhjaGFpbklkLCBhZGRyZXNzZXMsIGFueXRoaW5nKCkpKS50aGVuUmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlQ2hlY2tVdGlsc01vY2sgPSBtb2NrKFJmcUJhbGFuY2VDaGVja1V0aWxzKTtcclxuICAgICAgICAgICAgd2hlbihiYWxhbmNlQ2hlY2tVdGlsc01vY2suZ2V0TWluT2ZCYWxhbmNlc0FuZEFsbG93YW5jZXNBc3luYyhhZGRyZXNzZXMpKS50aGVuUmVzb2x2ZShbXHJcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDEpLFxyXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcigyKSxcclxuICAgICAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMyksXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICBjb25zdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UgPSBuZXcgUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlKFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UoY2FjaGVDbGllbnRNb2NrKSxcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlKGJhbGFuY2VDaGVja1V0aWxzTW9jayksXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgbWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlLnVwZGF0ZUVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKGNoYWluSWQpO1xyXG4gICAgICAgICAgICAgICAgdmVyaWZ5KGJhbGFuY2VDaGVja1V0aWxzTW9jay5nZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKGFueXRoaW5nKCkpKS5vbmNlKCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QuZmFpbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIHdyaXRpbmcgZW50cmllcyB0byB0aGUgY2FjaGUgZmFpbHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW1xyXG4gICAgICAgICAgICB7IG93bmVyOiBtYWtlckEsIHRva2VuOiB0b2tlbkEgfSxcclxuICAgICAgICAgICAgeyBvd25lcjogbWFrZXJCLCB0b2tlbjogdG9rZW5CIH0sXHJcbiAgICAgICAgICAgIHsgb3duZXI6IG1ha2VyQywgdG9rZW46IHRva2VuQyB9LFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgY29uc3QgY2FjaGVDbGllbnRNb2NrID0gbW9jayhDYWNoZUNsaWVudCk7XHJcbiAgICAgICAgd2hlbihjYWNoZUNsaWVudE1vY2suZ2V0RVJDMjBPd25lcnNBc3luYyhjaGFpbklkKSkudGhlblJlc29sdmUoYWRkcmVzc2VzKTtcclxuICAgICAgICB3aGVuKGNhY2hlQ2xpZW50TW9jay5zZXRFUkMyME93bmVyQmFsYW5jZXNBc3luYyhjaGFpbklkLCBhZGRyZXNzZXMsIGFueXRoaW5nKCkpKS50aGVuUmVqZWN0KFxyXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgZW50cmllcyBmb3IgbWFrZXIgYmFsYW5jZSBjYWNoZScpLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgYmFsYW5jZUNoZWNrVXRpbHNNb2NrID0gbW9jayhSZnFCYWxhbmNlQ2hlY2tVdGlscyk7XHJcbiAgICAgICAgd2hlbihiYWxhbmNlQ2hlY2tVdGlsc01vY2suZ2V0TWluT2ZCYWxhbmNlc0FuZEFsbG93YW5jZXNBc3luYyhhZGRyZXNzZXMpKS50aGVuUmVzb2x2ZShbXHJcbiAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMSksXHJcbiAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMiksXHJcbiAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMyksXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgY29uc3QgbWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlID0gbmV3IFJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZShcclxuICAgICAgICAgICAgaW5zdGFuY2UoY2FjaGVDbGllbnRNb2NrKSxcclxuICAgICAgICAgICAgaW5zdGFuY2UoYmFsYW5jZUNoZWNrVXRpbHNNb2NrKSxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UudXBkYXRlRVJDMjBPd25lckJhbGFuY2VzQXN5bmMoY2hhaW5JZCk7XHJcbiAgICAgICAgICAgIGV4cGVjdC5mYWlsKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLnRvLmNvbnRhaW4oJ21ha2VyIGJhbGFuY2UgY2FjaGUnKTtcclxuICAgICAgICAgICAgdmVyaWZ5KGJhbGFuY2VDaGVja1V0aWxzTW9jay5nZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKGFueXRoaW5nKCkpKS5vbmNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ2V2aWN0WmVyb0JhbGFuY2VzQXN5bmMnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ3Nob3VsZCBldmljdCBlbnRyaWVzIGZyb20gdGhlIGNhY2hlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZUNsaWVudE1vY2sgPSBtb2NrKENhY2hlQ2xpZW50KTtcclxuICAgICAgICAgICAgd2hlbihjYWNoZUNsaWVudE1vY2suZXZpY3RaZXJvQmFsYW5jZXNBc3luYyhjaGFpbklkKSkudGhlblJlc29sdmUoMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2VDaGVja1V0aWxzTW9jayA9IG1vY2soUmZxQmFsYW5jZUNoZWNrVXRpbHMpO1xyXG4gICAgICAgICAgICBjb25zdCBtYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UgPSBuZXcgUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlKFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UoY2FjaGVDbGllbnRNb2NrKSxcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlKGJhbGFuY2VDaGVja1V0aWxzTW9jayksXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbnVtRXZpY3RlZCA9IGF3YWl0IG1ha2VyQmFsYW5jZUNhY2hlU2VydmljZS5ldmljdFplcm9CYWxhbmNlc0FzeW5jKGNoYWluSWQpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KG51bUV2aWN0ZWQpLnRvLmVxKDEpO1xyXG4gICAgICAgICAgICAgICAgdmVyaWZ5KGNhY2hlQ2xpZW50TW9jay5ldmljdFplcm9CYWxhbmNlc0FzeW5jKGNoYWluSWQpKS5vbmNlKCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QuZmFpbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufSk7XHJcbiJdLCJ2ZXJzaW9uIjozfQ==