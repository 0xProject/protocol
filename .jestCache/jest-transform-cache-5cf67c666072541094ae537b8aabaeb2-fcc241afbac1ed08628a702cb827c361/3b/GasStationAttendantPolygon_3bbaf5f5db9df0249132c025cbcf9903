83c5c93fa806ded325aaafb1f2b8bf5f
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GasStationAttendantPolygon = void 0;
const utils_1 = require("@0x/utils");
const constants_1 = require("../core/constants");
// The total minimum bid recommended by the post here:
// https://forum.matic.network/t/recommended-min-gas-price-setting/2531
// Expect bids lower than this to be rejected by the RPC node.
const MINIMUM_BID_WEI = 30000000000;
// The maximum tip we're willing to pay, based on p99 historical data
const MAXIMUM_TIP_WEI = new utils_1.BigNumber(3000).shiftedBy(constants_1.GWEI_DECIMALS);
// Increase multiplier for tip with each resubmission cycle
const TEN_PERCENT_INCREASE = 1.1;
/**
 * An implementation of `GasStationAttendant` designed for Polygon.
 *
 * Currently, the 0x Gas Oracle does not provide pricing for Polygon
 * in EIP-1559 format. Therefore, we'll use the 'fast' gas as a
 * `maxPriorityFeePerGas` estimate. This actually works out okay because
 * the Polygon base fee is always essentially zero as of April 2022.
 */
class GasStationAttendantPolygon {
    constructor(protocolFeeUtils) {
        this._protocolFeeUtils = protocolFeeUtils;
    }
    /**
     * The Safe Balance For Trade is from the p95 data shown here:
     * https://0xproject.slack.com/archives/CQG0ZGBFS/p1649708977452469
     */
    // tslint:disable-next-line: prefer-function-over-method
    async getSafeBalanceForTradeAsync() {
        const p95PriorityFeeGwei = 261;
        // Base fee is essentially zero
        // TODO (rhinodavid): Make this smarter as we have more historical data
        const gasEstimate = constants_1.RFQM_TX_OTC_ORDER_GAS_ESTIMATE;
        // 0.0261 MATIC
        return new utils_1.BigNumber(p95PriorityFeeGwei).shiftedBy(constants_1.GWEI_DECIMALS).times(gasEstimate);
    }
    /**
     * Uses the current fast gas price as the `maxPriorityFeePerGas`
     * estimate. Plans for 3 resubmits at a 10% tip increase. Assumes
     * no base fee.
     *
     * Uses a fixed value of 110,000 for the transaction gas amount
     * estimate.
     */
    async getWorkerBalanceForTradeAsync() {
        // TODO (rhinodavid): Once the 0x gas oracle can give EIP-1559 data for Polygon
        // use that instead of the legacy fast gas price.
        const gasPriceEstimateWei = await this._protocolFeeUtils.getGasPriceEstimationOrThrowAsync();
        // Since the base fee is basically nothing, use this for our initial max priority fee
        const maxPriorityFeePerGas = gasPriceEstimateWei;
        // Pad the tip for 3 10% increases
        const maxPriorityFeePad = Math.pow(TEN_PERCENT_INCREASE, 3); // tslint:disable-line: custom-no-magic-numbers
        const paddedMaxPriorityFeePerGas = maxPriorityFeePerGas.times(maxPriorityFeePad);
        const gasRateWei = utils_1.BigNumber.max(paddedMaxPriorityFeePerGas.plus(0), MINIMUM_BID_WEI); // Amortizing the base fee to 0
        // Pad a little until we get a better idea of token-specific costs
        const padding = 1.1;
        const gasEstimate = constants_1.RFQM_TX_OTC_ORDER_GAS_ESTIMATE * padding;
        return gasRateWei.times(gasEstimate);
    }
    /**
     * Calculated using a similar methodology to `getWorkerBalanceForTradeAsync`,
     * but assumes we submit and average 1.5 transactions per trade, which is
     * what we see on Ethereum.
     *
     * TODO (rhinodavid): Update this once we have more historical data
     */
    async getExpectedTransactionGasRateAsync() {
        // use that instead of the legacy fast gas price.
        // `@0x/asset-swapper ProtocolFeeUtils::getGasPriceEstimationOrThrowAsync
        // returns WEI even though it's not documented anywhere in our public open source library
        // we intend other developers to use.
        const gasPriceEstimateWei = await this._protocolFeeUtils.getGasPriceEstimationOrThrowAsync();
        // Since the base fee is basically nothing, use this for our initial max priority fee
        const maxPriorityFeePerGas = gasPriceEstimateWei;
        // Pad the tip for 1.5 10% increases
        const baseFeePad = Math.pow(TEN_PERCENT_INCREASE, 1.5); // tslint:disable-line: custom-no-magic-numbers
        const paddedMaxPriorityFeePerGas = maxPriorityFeePerGas.times(baseFeePad);
        const gasRateWei = paddedMaxPriorityFeePerGas.plus(0); // Amortizing the base fee to 0
        return gasRateWei.integerValue(utils_1.BigNumber.ROUND_CEIL);
    }
    /**
     * The submission strategy mostly relies on updating the max priority fee
     * as we assume the base fee is always ~0.
     *
     * For the max priority fee, we'll start with the "fast" gas price. On
     * resubmits, we'll use either the new fast gas price or a 10% increase
     * on the previous gas price, whichever is higher.
     */
    async getNextBidAsync(submissionContext) {
        const gasPriceEstimateWei = await this._protocolFeeUtils.getGasPriceEstimationOrThrowAsync();
        const maxPriorityFeePerGas = gasPriceEstimateWei;
        // Always use 1 GWEI since it's pretty much always 0
        const baseFee = new utils_1.BigNumber(1).shiftedBy(constants_1.GWEI_DECIMALS);
        if (!submissionContext) {
            const initialMaxPriorityFeePerGasWei = new utils_1.BigNumber(maxPriorityFeePerGas);
            return {
                maxPriorityFeePerGas: initialMaxPriorityFeePerGasWei,
                maxFeePerGas: utils_1.BigNumber.max(baseFee.plus(initialMaxPriorityFeePerGasWei), MINIMUM_BID_WEI),
            };
        }
        const { maxFeePerGas: oldMaxFeePerGas, maxPriorityFeePerGas: oldMaxPriorityFeePerGas } = submissionContext.maxGasFees;
        const newMaxPriorityFeePerGas = utils_1.BigNumber.max(oldMaxPriorityFeePerGas.times(TEN_PERCENT_INCREASE), gasPriceEstimateWei);
        if (newMaxPriorityFeePerGas.isGreaterThan(MAXIMUM_TIP_WEI)) {
            return null;
        }
        const newMaxFeePerGas = utils_1.BigNumber.max(newMaxPriorityFeePerGas.plus(baseFee), oldMaxFeePerGas.multipliedBy(TEN_PERCENT_INCREASE));
        return {
            maxPriorityFeePerGas: newMaxPriorityFeePerGas.integerValue(utils_1.BigNumber.ROUND_CEIL),
            maxFeePerGas: newMaxFeePerGas.integerValue(utils_1.BigNumber.ROUND_CEIL),
        };
    }
}
exports.GasStationAttendantPolygon = GasStationAttendantPolygon;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy91dGlscy9HYXNTdGF0aW9uQXR0ZW5kYW50UG9seWdvbi50cyIsIm1hcHBpbmdzIjoiOzs7QUFDQSxxQ0FBc0M7QUFFdEMsaURBQWtGO0FBTWxGLHNEQUFzRDtBQUN0RCx1RUFBdUU7QUFDdkUsOERBQThEO0FBQzlELE1BQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQztBQUVwQyxxRUFBcUU7QUFDckUsTUFBTSxlQUFlLEdBQUcsSUFBSSxpQkFBUyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyx5QkFBYSxDQUFDLENBQUM7QUFFckUsMkRBQTJEO0FBQzNELE1BQU0sb0JBQW9CLEdBQUcsR0FBRyxDQUFDO0FBRWpDOzs7Ozs7O0dBT0c7QUFDSCxNQUFhLDBCQUEwQjtJQUduQyxZQUFZLGdCQUFrQztRQUMxQyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsZ0JBQWdCLENBQUM7SUFDOUMsQ0FBQztJQUVEOzs7T0FHRztJQUNILHdEQUF3RDtJQUNqRCxLQUFLLENBQUMsMkJBQTJCO1FBQ3BDLE1BQU0sa0JBQWtCLEdBQUcsR0FBRyxDQUFDO1FBQy9CLCtCQUErQjtRQUMvQix1RUFBdUU7UUFDdkUsTUFBTSxXQUFXLEdBQUcsMENBQThCLENBQUM7UUFDbkQsZUFBZTtRQUNmLE9BQU8sSUFBSSxpQkFBUyxDQUFDLGtCQUFrQixDQUFDLENBQUMsU0FBUyxDQUFDLHlCQUFhLENBQUMsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDekYsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxLQUFLLENBQUMsNkJBQTZCO1FBQ3RDLCtFQUErRTtRQUMvRSxpREFBaUQ7UUFDakQsTUFBTSxtQkFBbUIsR0FBRyxNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxpQ0FBaUMsRUFBRSxDQUFDO1FBRTdGLHFGQUFxRjtRQUNyRixNQUFNLG9CQUFvQixHQUFHLG1CQUFtQixDQUFDO1FBRWpELGtDQUFrQztRQUNsQyxNQUFNLGlC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QUFZLEVBQUUsZUFBZSxDQUFDLFlBQVksQ0FBQyxpQkFBUyxDQUFDLFVBQVUsQ0FBQztTQUNuRSxDQUFDO0lBQ04sQ0FBQztDQUNKO0FBMUhELGdFQTBIQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvZGF2aWR3YWxzaC9jb2RlLWxvY2FsLzB4LXJmcS1hcGkvc3JjL3V0aWxzL0dhc1N0YXRpb25BdHRlbmRhbnRQb2x5Z29uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByb3RvY29sRmVlVXRpbHMgfSBmcm9tICdAMHgvYXNzZXQtc3dhcHBlcic7XHJcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ0AweC91dGlscyc7XHJcblxyXG5pbXBvcnQgeyBHV0VJX0RFQ0lNQUxTLCBSRlFNX1RYX09UQ19PUkRFUl9HQVNfRVNUSU1BVEUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IE1ldGFUcmFuc2FjdGlvblN1Ym1pc3Npb25FbnRpdHksIFJmcW1WMlRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eSB9IGZyb20gJy4uL2VudGl0aWVzJztcclxuXHJcbmltcG9ydCB7IEdhc1N0YXRpb25BdHRlbmRhbnQsIFdlaSwgV2VpUGVyR2FzIH0gZnJvbSAnLi9HYXNTdGF0aW9uQXR0ZW5kYW50JztcclxuaW1wb3J0IHsgU3VibWlzc2lvbkNvbnRleHQgfSBmcm9tICcuL1N1Ym1pc3Npb25Db250ZXh0JztcclxuXHJcbi8vIFRoZSB0b3RhbCBtaW5pbXVtIGJpZCByZWNvbW1lbmRlZCBieSB0aGUgcG9zdCBoZXJlOlxyXG4vLyBodHRwczovL2ZvcnVtLm1hdGljLm5ldHdvcmsvdC9yZWNvbW1lbmRlZC1taW4tZ2FzLXByaWNlLXNldHRpbmcvMjUzMVxyXG4vLyBFeHBlY3QgYmlkcyBsb3dlciB0aGFuIHRoaXMgdG8gYmUgcmVqZWN0ZWQgYnkgdGhlIFJQQyBub2RlLlxyXG5jb25zdCBNSU5JTVVNX0JJRF9XRUkgPSAzMDAwMDAwMDAwMDtcclxuXHJcbi8vIFRoZSBtYXhpbXVtIHRpcCB3ZSdyZSB3aWxsaW5nIHRvIHBheSwgYmFzZWQgb24gcDk5IGhpc3RvcmljYWwgZGF0YVxyXG5jb25zdCBNQVhJTVVNX1RJUF9XRUkgPSBuZXcgQmlnTnVtYmVyKDMwMDApLnNoaWZ0ZWRCeShHV0VJX0RFQ0lNQUxTKTtcclxuXHJcbi8vIEluY3JlYXNlIG11bHRpcGxpZXIgZm9yIHRpcCB3aXRoIGVhY2ggcmVzdWJtaXNzaW9uIGN5Y2xlXHJcbmNvbnN0IFRFTl9QRVJDRU5UX0lOQ1JFQVNFID0gMS4xO1xyXG5cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGBHYXNTdGF0aW9uQXR0ZW5kYW50YCBkZXNpZ25lZCBmb3IgUG9seWdvbi5cclxuICpcclxuICogQ3VycmVudGx5LCB0aGUgMHggR2FzIE9yYWNsZSBkb2VzIG5vdCBwcm92aWRlIHByaWNpbmcgZm9yIFBvbHlnb25cclxuICogaW4gRUlQLTE1NTkgZm9ybWF0LiBUaGVyZWZvcmUsIHdlJ2xsIHVzZSB0aGUgJ2Zhc3QnIGdhcyBhcyBhXHJcbiAqIGBtYXhQcmlvcml0eUZlZVBlckdhc2AgZXN0aW1hdGUuIFRoaXMgYWN0dWFsbHkgd29ya3Mgb3V0IG9rYXkgYmVjYXVzZVxyXG4gKiB0aGUgUG9seWdvbiBiYXNlIGZlZSBpcyBhbHdheXMgZXNzZW50aWFsbHkgemVybyBhcyBvZiBBcHJpbCAyMDIyLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdhc1N0YXRpb25BdHRlbmRhbnRQb2x5Z29uIGltcGxlbWVudHMgR2FzU3RhdGlvbkF0dGVuZGFudCB7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9wcm90b2NvbEZlZVV0aWxzOiBQcm90b2NvbEZlZVV0aWxzO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByb3RvY29sRmVlVXRpbHM6IFByb3RvY29sRmVlVXRpbHMpIHtcclxuICAgICAgICB0aGlzLl9wcm90b2NvbEZlZVV0aWxzID0gcHJvdG9jb2xGZWVVdGlscztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBTYWZlIEJhbGFuY2UgRm9yIFRyYWRlIGlzIGZyb20gdGhlIHA5NSBkYXRhIHNob3duIGhlcmU6XHJcbiAgICAgKiBodHRwczovLzB4cHJvamVjdC5zbGFjay5jb20vYXJjaGl2ZXMvQ1FHMFpHQkZTL3AxNjQ5NzA4OTc3NDUyNDY5XHJcbiAgICAgKi9cclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcHJlZmVyLWZ1bmN0aW9uLW92ZXItbWV0aG9kXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0U2FmZUJhbGFuY2VGb3JUcmFkZUFzeW5jKCk6IFByb21pc2U8V2VpPiB7XHJcbiAgICAgICAgY29uc3QgcDk1UHJpb3JpdHlGZWVHd2VpID0gMjYxO1xyXG4gICAgICAgIC8vIEJhc2UgZmVlIGlzIGVzc2VudGlhbGx5IHplcm9cclxuICAgICAgICAvLyBUT0RPIChyaGlub2RhdmlkKTogTWFrZSB0aGlzIHNtYXJ0ZXIgYXMgd2UgaGF2ZSBtb3JlIGhpc3RvcmljYWwgZGF0YVxyXG4gICAgICAgIGNvbnN0IGdhc0VzdGltYXRlID0gUkZRTV9UWF9PVENfT1JERVJfR0FTX0VTVElNQVRFO1xyXG4gICAgICAgIC8vIDAuMDI2MSBNQVRJQ1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHA5NVByaW9yaXR5RmVlR3dlaSkuc2hpZnRlZEJ5KEdXRUlfREVDSU1BTFMpLnRpbWVzKGdhc0VzdGltYXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZXMgdGhlIGN1cnJlbnQgZmFzdCBnYXMgcHJpY2UgYXMgdGhlIGBtYXhQcmlvcml0eUZlZVBlckdhc2BcclxuICAgICAqIGVzdGltYXRlLiBQbGFucyBmb3IgMyByZXN1Ym1pdHMgYXQgYSAxMCUgdGlwIGluY3JlYXNlLiBBc3N1bWVzXHJcbiAgICAgKiBubyBiYXNlIGZlZS5cclxuICAgICAqXHJcbiAgICAgKiBVc2VzIGEgZml4ZWQgdmFsdWUgb2YgMTEwLDAwMCBmb3IgdGhlIHRyYW5zYWN0aW9uIGdhcyBhbW91bnRcclxuICAgICAqIGVzdGltYXRlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0V29ya2VyQmFsYW5jZUZvclRyYWRlQXN5bmMoKTogUHJvbWlzZTxXZWlQZXJHYXM+IHtcclxuICAgICAgICAvLyBUT0RPIChyaGlub2RhdmlkKTogT25jZSB0aGUgMHggZ2FzIG9yYWNsZSBjYW4gZ2l2ZSBFSVAtMTU1OSBkYXRhIGZvciBQb2x5Z29uXHJcbiAgICAgICAgLy8gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgbGVnYWN5IGZhc3QgZ2FzIHByaWNlLlxyXG4gICAgICAgIGNvbnN0IGdhc1ByaWNlRXN0aW1hdGVXZWkgPSBhd2FpdCB0aGlzLl9wcm90b2NvbEZlZVV0aWxzLmdldEdhc1ByaWNlRXN0aW1hdGlvbk9yVGhyb3dBc3luYygpO1xyXG5cclxuICAgICAgICAvLyBTaW5jZSB0aGUgYmFzZSBmZWUgaXMgYmFzaWNhbGx5IG5vdGhpbmcsIHVzZSB0aGlzIGZvciBvdXIgaW5pdGlhbCBtYXggcHJpb3JpdHkgZmVlXHJcbiAgICAgICAgY29uc3QgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBnYXNQcmljZUVzdGltYXRlV2VpO1xyXG5cclxuICAgICAgICAvLyBQYWQgdGhlIHRpcCBmb3IgMyAxMCUgaW5jcmVhc2VzXHJcbiAgICAgICAgY29uc3QgbWF4UHJpb3JpdHlGZWVQYWQgPSBNYXRoLnBvdyhURU5fUEVSQ0VOVF9JTkNSRUFTRSwgMyk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6IGN1c3RvbS1uby1tYWdpYy1udW1iZXJzXHJcbiAgICAgICAgY29uc3QgcGFkZGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBtYXhQcmlvcml0eUZlZVBlckdhcy50aW1lcyhtYXhQcmlvcml0eUZlZVBhZCk7XHJcbiAgICAgICAgY29uc3QgZ2FzUmF0ZVdlaSA9IEJpZ051bWJlci5tYXgocGFkZGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMucGx1cygwKSwgTUlOSU1VTV9CSURfV0VJKTsgLy8gQW1vcnRpemluZyB0aGUgYmFzZSBmZWUgdG8gMFxyXG5cclxuICAgICAgICAvLyBQYWQgYSBsaXR0bGUgdW50aWwgd2UgZ2V0IGEgYmV0dGVyIGlkZWEgb2YgdG9rZW4tc3BlY2lmaWMgY29zdHNcclxuICAgICAgICBjb25zdCBwYWRkaW5nID0gMS4xO1xyXG4gICAgICAgIGNvbnN0IGdhc0VzdGltYXRlID0gUkZRTV9UWF9PVENfT1JERVJfR0FTX0VTVElNQVRFICogcGFkZGluZztcclxuXHJcbiAgICAgICAgcmV0dXJuIGdhc1JhdGVXZWkudGltZXMoZ2FzRXN0aW1hdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlZCB1c2luZyBhIHNpbWlsYXIgbWV0aG9kb2xvZ3kgdG8gYGdldFdvcmtlckJhbGFuY2VGb3JUcmFkZUFzeW5jYCxcclxuICAgICAqIGJ1dCBhc3N1bWVzIHdlIHN1Ym1pdCBhbmQgYXZlcmFnZSAxLjUgdHJhbnNhY3Rpb25zIHBlciB0cmFkZSwgd2hpY2ggaXNcclxuICAgICAqIHdoYXQgd2Ugc2VlIG9uIEV0aGVyZXVtLlxyXG4gICAgICpcclxuICAgICAqIFRPRE8gKHJoaW5vZGF2aWQpOiBVcGRhdGUgdGhpcyBvbmNlIHdlIGhhdmUgbW9yZSBoaXN0b3JpY2FsIGRhdGFcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldEV4cGVjdGVkVHJhbnNhY3Rpb25HYXNSYXRlQXN5bmMoKTogUHJvbWlzZTxXZWlQZXJHYXM+IHtcclxuICAgICAgICAvLyB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBsZWdhY3kgZmFzdCBnYXMgcHJpY2UuXHJcbiAgICAgICAgLy8gYEAweC9hc3NldC1zd2FwcGVyIFByb3RvY29sRmVlVXRpbHM6OmdldEdhc1ByaWNlRXN0aW1hdGlvbk9yVGhyb3dBc3luY1xyXG4gICAgICAgIC8vIHJldHVybnMgV0VJIGV2ZW4gdGhvdWdoIGl0J3Mgbm90IGRvY3VtZW50ZWQgYW55d2hlcmUgaW4gb3VyIHB1YmxpYyBvcGVuIHNvdXJjZSBsaWJyYXJ5XHJcbiAgICAgICAgLy8gd2UgaW50ZW5kIG90aGVyIGRldmVsb3BlcnMgdG8gdXNlLlxyXG4gICAgICAgIGNvbnN0IGdhc1ByaWNlRXN0aW1hdGVXZWkgPSBhd2FpdCB0aGlzLl9wcm90b2NvbEZlZVV0aWxzLmdldEdhc1ByaWNlRXN0aW1hdGlvbk9yVGhyb3dBc3luYygpO1xyXG5cclxuICAgICAgICAvLyBTaW5jZSB0aGUgYmFzZSBmZWUgaXMgYmFzaWNhbGx5IG5vdGhpbmcsIHVzZSB0aGlzIGZvciBvdXIgaW5pdGlhbCBtYXggcHJpb3JpdHkgZmVlXHJcbiAgICAgICAgY29uc3QgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBnYXNQcmljZUVzdGltYXRlV2VpO1xyXG5cclxuICAgICAgICAvLyBQYWQgdGhlIHRpcCBmb3IgMS41IDEwJSBpbmNyZWFzZXNcclxuICAgICAgICBjb25zdCBiYXNlRmVlUGFkID0gTWF0aC5wb3coVEVOX1BFUkNFTlRfSU5DUkVBU0UsIDEuNSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6IGN1c3RvbS1uby1tYWdpYy1udW1iZXJzXHJcbiAgICAgICAgY29uc3QgcGFkZGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBtYXhQcmlvcml0eUZlZVBlckdhcy50aW1lcyhiYXNlRmVlUGFkKTtcclxuICAgICAgICBjb25zdCBnYXNSYXRlV2VpID0gcGFkZGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMucGx1cygwKTsgLy8gQW1vcnRpemluZyB0aGUgYmFzZSBmZWUgdG8gMFxyXG5cclxuICAgICAgICByZXR1cm4gZ2FzUmF0ZVdlaS5pbnRlZ2VyVmFsdWUoQmlnTnVtYmVyLlJPVU5EX0NFSUwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN1Ym1pc3Npb24gc3RyYXRlZ3kgbW9zdGx5IHJlbGllcyBvbiB1cGRhdGluZyB0aGUgbWF4IHByaW9yaXR5IGZlZVxyXG4gICAgICogYXMgd2UgYXNzdW1lIHRoZSBiYXNlIGZlZSBpcyBhbHdheXMgfjAuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIHRoZSBtYXggcHJpb3JpdHkgZmVlLCB3ZSdsbCBzdGFydCB3aXRoIHRoZSBcImZhc3RcIiBnYXMgcHJpY2UuIE9uXHJcbiAgICAgKiByZXN1Ym1pdHMsIHdlJ2xsIHVzZSBlaXRoZXIgdGhlIG5ldyBmYXN0IGdhcyBwcmljZSBvciBhIDEwJSBpbmNyZWFzZVxyXG4gICAgICogb24gdGhlIHByZXZpb3VzIGdhcyBwcmljZSwgd2hpY2hldmVyIGlzIGhpZ2hlci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldE5leHRCaWRBc3luYyhcclxuICAgICAgICBzdWJtaXNzaW9uQ29udGV4dDogU3VibWlzc2lvbkNvbnRleHQ8XHJcbiAgICAgICAgICAgIFJmcW1WMlRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eVtdIHwgTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eVtdXHJcbiAgICAgICAgPiB8IG51bGwsXHJcbiAgICApOiBQcm9taXNlPHsgbWF4RmVlUGVyR2FzOiBCaWdOdW1iZXI7IG1heFByaW9yaXR5RmVlUGVyR2FzOiBCaWdOdW1iZXIgfSB8IG51bGw+IHtcclxuICAgICAgICBjb25zdCBnYXNQcmljZUVzdGltYXRlV2VpID0gYXdhaXQgdGhpcy5fcHJvdG9jb2xGZWVVdGlscy5nZXRHYXNQcmljZUVzdGltYXRpb25PclRocm93QXN5bmMoKTtcclxuICAgICAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IGdhc1ByaWNlRXN0aW1hdGVXZWk7XHJcbiAgICAgICAgLy8gQWx3YXlzIHVzZSAxIEdXRUkgc2luY2UgaXQncyBwcmV0dHkgbXVjaCBhbHdheXMgMFxyXG4gICAgICAgIGNvbnN0IGJhc2VGZWUgPSBuZXcgQmlnTnVtYmVyKDEpLnNoaWZ0ZWRCeShHV0VJX0RFQ0lNQUxTKTtcclxuXHJcbiAgICAgICAgaWYgKCFzdWJtaXNzaW9uQ29udGV4dCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbml0aWFsTWF4UHJpb3JpdHlGZWVQZXJHYXNXZWkgPSBuZXcgQmlnTnVtYmVyKG1heFByaW9yaXR5RmVlUGVyR2FzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBpbml0aWFsTWF4UHJpb3JpdHlGZWVQZXJHYXNXZWksXHJcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXM6IEJpZ051bWJlci5tYXgoYmFzZUZlZS5wbHVzKGluaXRpYWxNYXhQcmlvcml0eUZlZVBlckdhc1dlaSksIE1JTklNVU1fQklEX1dFSSksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB7IG1heEZlZVBlckdhczogb2xkTWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhczogb2xkTWF4UHJpb3JpdHlGZWVQZXJHYXMgfSA9XHJcbiAgICAgICAgICAgIHN1Ym1pc3Npb25Db250ZXh0Lm1heEdhc0ZlZXM7XHJcblxyXG4gICAgICAgIGNvbnN0IG5ld01heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnTnVtYmVyLm1heChcclxuICAgICAgICAgICAgb2xkTWF4UHJpb3JpdHlGZWVQZXJHYXMudGltZXMoVEVOX1BFUkNFTlRfSU5DUkVBU0UpLFxyXG4gICAgICAgICAgICBnYXNQcmljZUVzdGltYXRlV2VpLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmIChuZXdNYXhQcmlvcml0eUZlZVBlckdhcy5pc0dyZWF0ZXJUaGFuKE1BWElNVU1fVElQX1dFSSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBuZXdNYXhGZWVQZXJHYXMgPSBCaWdOdW1iZXIubWF4KFxyXG4gICAgICAgICAgICBuZXdNYXhQcmlvcml0eUZlZVBlckdhcy5wbHVzKGJhc2VGZWUpLFxyXG4gICAgICAgICAgICBvbGRNYXhGZWVQZXJHYXMubXVsdGlwbGllZEJ5KFRFTl9QRVJDRU5UX0lOQ1JFQVNFKSxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXMuaW50ZWdlclZhbHVlKEJpZ051bWJlci5ST1VORF9DRUlMKSxcclxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBuZXdNYXhGZWVQZXJHYXMuaW50ZWdlclZhbHVlKEJpZ051bWJlci5ST1VORF9DRUlMKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbiJdLCJ2ZXJzaW9uIjozfQ==