f15918c8c877f9388e6a8c4381aef1a1
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupDependenciesAsync = void 0;
const child_process_1 = require("child_process");
const path = require("path");
const constants_1 = require("../../src/core/constants");
const initDbDataSourceAsync_1 = require("./initDbDataSourceAsync");
// depends on a `docker-compose.yml` existing in the api root directory
const dockerComposeFilename = 'docker-compose.yml';
/**
 * Sets up 0x-api's dependencies
 *
 * @param services An array of services to start
 * @returns A function handle which will tear down the dependencies when called
 */
async function setupDependenciesAsync(services) {
    if (services.length === 0) {
        throw new Error('Pick at least one service to start');
    }
    const configFilePath = path.resolve(__dirname, '../../', dockerComposeFilename);
    /**
     * Only starts the services specified in `services`.
     */
    const up = (0, child_process_1.spawn)(`docker-compose`, ['-f', configFilePath, 'up', ...services], {});
    await waitForDependencyStartupAsync(up, services);
    if (services.includes('postgres')) {
        await confirmPostgresConnectivityAsync();
    }
    // Return the function handle which will shutdown the services
    return function closeFunction() {
        const wasSuccessfulKill = up.kill();
        return wasSuccessfulKill;
    };
}
exports.setupDependenciesAsync = setupDependenciesAsync;
/**
 * Monitor the logs being emitted from the docker containers to detect
 * when services have started up. Postgres startup is managed with
 * `confirmPostgresConnectivityAsync`
 */
async function waitForDependencyStartupAsync(logStream, services) {
    return new Promise((resolve, reject) => {
        const startupTimeout = constants_1.ONE_MINUTE_MS * 3; // tslint:disable-line custom-no-magic-numbers
        const timeoutHandle = setTimeout(() => {
            reject(new Error(`Timed out waiting for dependency logs\n${JSON.stringify(isServiceStarted)}`));
        }, startupTimeout);
        const startupRegexSqs = /.*sqs.*listening on port \d{4}/;
        const startupRegexRedis = /.*redis.*Ready to accept connections/;
        const startupRegexGananche = /.*ganache.*Listening on 0.0.0.0:\d{4}/;
        const isServiceStarted = {
            sqs: !services.includes('sqs'),
            postgres: true,
            redis: !services.includes('redis'),
            ganache: !services.includes('ganache'),
        };
        logStream.on('error', (error) => {
            reject(`Stream closed with error: ${error}`);
        });
        logStream.stdout.on('data', (data) => {
            const log = data.toString();
            if (startupRegexRedis.test(log)) {
                isServiceStarted.redis = true;
            }
            if (startupRegexSqs.test(log)) {
                isServiceStarted.sqs = true;
            }
            if (startupRegexGananche.test(log)) {
                isServiceStarted.ganache = true;
            }
            // Once all the services are started, resolve the promise
            if (Object.values(isServiceStarted).every((v) => v)) {
                // logStream.stdout.removeAllListeners('data');
                // logStream.removeAllListeners('error');
                clearTimeout(timeoutHandle);
                resolve();
            }
        });
    });
}
// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
// eslint-disable-next-line @typescript-eslint/no-inferrable-types
async function confirmPostgresConnectivityAsync(maxTries = 5) {
    try {
        await Promise.all([
            // delay before retrying
            new Promise((resolve) => setTimeout(resolve, 2000)),
            async () => {
                await (0, initDbDataSourceAsync_1.initDbDataSourceAsync)();
            },
        ]);
        return;
    }
    catch (e) {
        if (maxTries > 0) {
            await confirmPostgresConnectivityAsync(maxTries - 1);
        }
        else {
            throw e;
        }
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3Rlc3QvdGVzdF91dGlscy9kZXBsb3ltZW50LnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLGlEQUFzRTtBQUN0RSw2QkFBNkI7QUFFN0Isd0RBQXlEO0FBRXpELG1FQUFnRTtBQUVoRSx1RUFBdUU7QUFDdkUsTUFBTSxxQkFBcUIsR0FBRyxvQkFBb0IsQ0FBQztBQVduRDs7Ozs7R0FLRztBQUNJLEtBQUssVUFBVSxzQkFBc0IsQ0FBQyxRQUFtQjtJQUM1RCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQztLQUN6RDtJQUVELE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO0lBRWhGOztPQUVHO0lBQ0gsTUFBTSxFQUFFLEdBQUcsSUFBQSxxQkFBSyxFQUFDLGdCQUFnQixFQUFFLENBQUMsSUFBSSxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsR0FBRyxRQUFRLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUVsRixNQUFNLDZCQUE2QixDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUVsRCxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUU7UUFDL0IsTUFBTSxnQ0FBZ0MsRUFBRSxDQUFDO0tBQzVDO0lBQ0QsOERBQThEO0lBQzlELE9BQU8sU0FBUyxhQUFhO1FBQ3pCLE1BQU0saUJBQWlCLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3BDLE9BQU8saUJBQWlCLENBQUM7SUFDN0IsQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQXRCRCx3REFzQkM7QUFFRDs7OztHQUlHO0FBQ0gsS0FBSyxVQUFVLDZCQUE2QixDQUN4QyxTQUF5QyxFQUN6QyxRQUFtQjtJQUVuQixPQUFPLElBQUksT0FBTyxDQUFPLENBQUMs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LXJmcS1hcGkvdGVzdC90ZXN0X3V0aWxzL2RlcGxveW1lbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hpbGRQcm9jZXNzV2l0aG91dE51bGxTdHJlYW1zLCBzcGF3biB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuaW1wb3J0IHsgT05FX01JTlVURV9NUyB9IGZyb20gJy4uLy4uL3NyYy9jb3JlL2NvbnN0YW50cyc7XHJcblxyXG5pbXBvcnQgeyBpbml0RGJEYXRhU291cmNlQXN5bmMgfSBmcm9tICcuL2luaXREYkRhdGFTb3VyY2VBc3luYyc7XHJcblxyXG4vLyBkZXBlbmRzIG9uIGEgYGRvY2tlci1jb21wb3NlLnltbGAgZXhpc3RpbmcgaW4gdGhlIGFwaSByb290IGRpcmVjdG9yeVxyXG5jb25zdCBkb2NrZXJDb21wb3NlRmlsZW5hbWUgPSAnZG9ja2VyLWNvbXBvc2UueW1sJztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5lZCBieSBgc2V0dXBEZXBlbmRlbmNpZXNBc3luY2AuIENhbGwgdG8gc2h1dGRvd24gdGhlXHJcbiAqIGRlcGVuZGVuY2llcyBzcHVuIHVwIGJ5IGBzZXR1cERlcGVuZGVuY2llc0FzeW5jYC4gUmV0dXJuc1xyXG4gKiBgdHJ1ZWAgaWYgdGhlIHRlYXJkb3duIGlzIHN1Y2Nlc3NmdWwuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBUZWFyZG93bkRlcGVuZGVuY2llc0Z1bmN0aW9uSGFuZGxlID0gKCkgPT4gYm9vbGVhbjtcclxuXHJcbnR5cGUgU2VydmljZSA9ICdzcXMnIHwgJ3Bvc3RncmVzJyB8ICdyZWRpcycgfCAnZ2FuYWNoZSc7XHJcblxyXG4vKipcclxuICogU2V0cyB1cCAweC1hcGkncyBkZXBlbmRlbmNpZXNcclxuICpcclxuICogQHBhcmFtIHNlcnZpY2VzIEFuIGFycmF5IG9mIHNlcnZpY2VzIHRvIHN0YXJ0XHJcbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gaGFuZGxlIHdoaWNoIHdpbGwgdGVhciBkb3duIHRoZSBkZXBlbmRlbmNpZXMgd2hlbiBjYWxsZWRcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXR1cERlcGVuZGVuY2llc0FzeW5jKHNlcnZpY2VzOiBTZXJ2aWNlW10pOiBQcm9taXNlPFRlYXJkb3duRGVwZW5kZW5jaWVzRnVuY3Rpb25IYW5kbGU+IHtcclxuICAgIGlmIChzZXJ2aWNlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpY2sgYXQgbGVhc3Qgb25lIHNlcnZpY2UgdG8gc3RhcnQnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb25maWdGaWxlUGF0aCA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLi8uLi8nLCBkb2NrZXJDb21wb3NlRmlsZW5hbWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT25seSBzdGFydHMgdGhlIHNlcnZpY2VzIHNwZWNpZmllZCBpbiBgc2VydmljZXNgLlxyXG4gICAgICovXHJcbiAgICBjb25zdCB1cCA9IHNwYXduKGBkb2NrZXItY29tcG9zZWAsIFsnLWYnLCBjb25maWdGaWxlUGF0aCwgJ3VwJywgLi4uc2VydmljZXNdLCB7fSk7XHJcblxyXG4gICAgYXdhaXQgd2FpdEZvckRlcGVuZGVuY3lTdGFydHVwQXN5bmModXAsIHNlcnZpY2VzKTtcclxuXHJcbiAgICBpZiAoc2VydmljZXMuaW5jbHVkZXMoJ3Bvc3RncmVzJykpIHtcclxuICAgICAgICBhd2FpdCBjb25maXJtUG9zdGdyZXNDb25uZWN0aXZpdHlBc3luYygpO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJuIHRoZSBmdW5jdGlvbiBoYW5kbGUgd2hpY2ggd2lsbCBzaHV0ZG93biB0aGUgc2VydmljZXNcclxuICAgIHJldHVybiBmdW5jdGlvbiBjbG9zZUZ1bmN0aW9uKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IHdhc1N1Y2Nlc3NmdWxLaWxsID0gdXAua2lsbCgpO1xyXG4gICAgICAgIHJldHVybiB3YXNTdWNjZXNzZnVsS2lsbDtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNb25pdG9yIHRoZSBsb2dzIGJlaW5nIGVtaXR0ZWQgZnJvbSB0aGUgZG9ja2VyIGNvbnRhaW5lcnMgdG8gZGV0ZWN0XHJcbiAqIHdoZW4gc2VydmljZXMgaGF2ZSBzdGFydGVkIHVwLiBQb3N0Z3JlcyBzdGFydHVwIGlzIG1hbmFnZWQgd2l0aFxyXG4gKiBgY29uZmlybVBvc3RncmVzQ29ubmVjdGl2aXR5QXN5bmNgXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yRGVwZW5kZW5jeVN0YXJ0dXBBc3luYyhcclxuICAgIGxvZ1N0cmVhbTogQ2hpbGRQcm9jZXNzV2l0aG91dE51bGxTdHJlYW1zLFxyXG4gICAgc2VydmljZXM6IFNlcnZpY2VbXSxcclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0dXBUaW1lb3V0ID0gT05FX01JTlVURV9NUyAqIDM7IC8vIHRzbGludDpkaXNhYmxlLWxpbmUgY3VzdG9tLW5vLW1hZ2ljLW51bWJlcnNcclxuICAgICAgICBjb25zdCB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFRpbWVkIG91dCB3YWl0aW5nIGZvciBkZXBlbmRlbmN5IGxvZ3NcXG4ke0pTT04uc3RyaW5naWZ5KGlzU2VydmljZVN0YXJ0ZWQpfWApKTtcclxuICAgICAgICB9LCBzdGFydHVwVGltZW91dCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YXJ0dXBSZWdleFNxcyA9IC8uKnNxcy4qbGlzdGVuaW5nIG9uIHBvcnQgXFxkezR9LztcclxuICAgICAgICBjb25zdCBzdGFydHVwUmVnZXhSZWRpcyA9IC8uKnJlZGlzLipSZWFkeSB0byBhY2NlcHQgY29ubmVjdGlvbnMvO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0dXBSZWdleEdhbmFuY2hlID0gLy4qZ2FuYWNoZS4qTGlzdGVuaW5nIG9uIDAuMC4wLjA6XFxkezR9LztcclxuXHJcbiAgICAgICAgY29uc3QgaXNTZXJ2aWNlU3RhcnRlZDogUmVjb3JkPFNlcnZpY2UsIGJvb2xlYW4+ID0ge1xyXG4gICAgICAgICAgICBzcXM6ICFzZXJ2aWNlcy5pbmNsdWRlcygnc3FzJyksXHJcbiAgICAgICAgICAgIHBvc3RncmVzOiB0cnVlLCAvLyBtYW5hZ2VkIGJ5IGNvbmZpcm1Qb3N0Z3Jlc0Nvbm5lY3Rpdml0eUFzeW5jXHJcbiAgICAgICAgICAgIHJlZGlzOiAhc2VydmljZXMuaW5jbHVkZXMoJ3JlZGlzJyksXHJcbiAgICAgICAgICAgIGdhbmFjaGU6ICFzZXJ2aWNlcy5pbmNsdWRlcygnZ2FuYWNoZScpLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGxvZ1N0cmVhbS5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgcmVqZWN0KGBTdHJlYW0gY2xvc2VkIHdpdGggZXJyb3I6ICR7ZXJyb3J9YCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxvZ1N0cmVhbS5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsb2cgPSBkYXRhLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChzdGFydHVwUmVnZXhSZWRpcy50ZXN0KGxvZykpIHtcclxuICAgICAgICAgICAgICAgIGlzU2VydmljZVN0YXJ0ZWQucmVkaXMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGFydHVwUmVnZXhTcXMudGVzdChsb2cpKSB7XHJcbiAgICAgICAgICAgICAgICBpc1NlcnZpY2VTdGFydGVkLnNxcyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXJ0dXBSZWdleEdhbmFuY2hlLnRlc3QobG9nKSkge1xyXG4gICAgICAgICAgICAgICAgaXNTZXJ2aWNlU3RhcnRlZC5nYW5hY2hlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT25jZSBhbGwgdGhlIHNlcnZpY2VzIGFyZSBzdGFydGVkLCByZXNvbHZlIHRoZSBwcm9taXNlXHJcbiAgICAgICAgICAgIGlmIChPYmplY3QudmFsdWVzKGlzU2VydmljZVN0YXJ0ZWQpLmV2ZXJ5KCh2KSA9PiB2KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbG9nU3RyZWFtLnN0ZG91dC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcclxuICAgICAgICAgICAgICAgIC8vIGxvZ1N0cmVhbS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Vycm9yJyk7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8taW5mZXJyYWJsZS10eXBlc1xyXG5hc3luYyBmdW5jdGlvbiBjb25maXJtUG9zdGdyZXNDb25uZWN0aXZpdHlBc3luYyhtYXhUcmllczogbnVtYmVyID0gNSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgIC8vIGRlbGF5IGJlZm9yZSByZXRyeWluZ1xyXG4gICAgICAgICAgICBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAwKSksIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6Y3VzdG9tLW5vLW1hZ2ljLW51bWJlcnNcclxuICAgICAgICAgICAgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgaW5pdERiRGF0YVNvdXJjZUFzeW5jKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChtYXhUcmllcyA+IDApIHtcclxuICAgICAgICAgICAgYXdhaXQgY29uZmlybVBvc3RncmVzQ29ubmVjdGl2aXR5QXN5bmMobWF4VHJpZXMgLSAxKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXSwidmVyc2lvbiI6M30=