5a22269f1c48923a071376a3c7f2aa9d
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const prom_client_1 = require("prom-client");
const config_1 = require("../config");
const logger_1 = require("../logger");
const rfqm_service_builder_1 = require("../utils/rfqm_service_builder");
const QUEUE_NAME = 'maker-balance-cache-update';
// keep successful job history for 1 day
const REMOVE_ON_COMPLETE_OPS = {
    count: 24 * 60 * 6,
};
// keep failed job history for 3 days
const REMOVE_ON_FAILURE_OPS = {
    count: 3 * 24 * 60 * 6,
};
const MAKER_BALANCE_CACHE_UPDATE_SCHEDULE = '*/10 * * * * *'; // job will be scheduled at every 10 seconds
const DESCRIPTION = 'Periodically updates observed entries in maker balance cache through balance checks.';
const backgroundJobMBCUpdate = {
    queueName: QUEUE_NAME,
    schedule: MAKER_BALANCE_CACHE_UPDATE_SCHEDULE,
    description: DESCRIPTION,
    createAsync,
    processAsync,
};
// tslint:disable-next-line: no-default-export
exports.default = backgroundJobMBCUpdate;
const MAKER_BALANCE_CACHE_UPDATE_PROCESS_COUNT = new prom_client_1.Counter({
    name: 'rfq_background_job_mbc_update_process_total',
    help: 'Number of times the processor method of the maker balance cache update background job is triggered',
});
/**
 * Creates a background job by queues a message that performs an update on the maker balance cache.
 *
 * @param queue Queue to push the message.
 * @param data Necessary data for processor to execute the background job.
 * @returns Promise of the background job.
 */
async function createAsync(queue, data) {
    logger_1.logger.info({ queue: QUEUE_NAME, data }, 'Creating the maker balance cache background job on queue');
    return queue.add(`${QUEUE_NAME}.${data.timestamp}`, data, {
        removeOnComplete: REMOVE_ON_COMPLETE_OPS,
        removeOnFail: REMOVE_ON_FAILURE_OPS,
    });
}
/**
 * Processor method for the maker balance cache update job. Runs a cache update,
 * performing balance checks on observed maker balances.
 *
 * @param job Maker balance cache update background job.
 * @returns Result of the update background job.
 */
async function processAsync(job) {
    await job.updateProgress(0);
    logger_1.logger.info({ jobName: job.name, queue: job.queueName, data: job.data, timestamp: Date.now() }, 'Processing the maker balance cache update background job on queue');
    const chainId = job.data.chainId;
    // Build dependencies
    const chain = config_1.CHAIN_CONFIGURATIONS.find((c) => c.chainId === chainId);
    if (!chain) {
        throw new Error(`Tried to start background job process for chain ${chainId}
        but no chain configuration was present`);
    }
    const rfqMakerBalanceCacheService = await (0, rfqm_service_builder_1.buildRfqMakerBalanceCacheServiceAsync)(chain);
    if (!rfqMakerBalanceCacheService) {
        logger_1.logger.error({ jobName: job.name, queue: job.queueName, data: job.data, timestamp: Date.now() }, 'Failed to initialize dependencies for maker-balance-cache-update');
        throw new Error('Failed to initialize dependencies for maker-balance-cache-update');
    }
    await job.updateProgress(50);
    // Perform update on maker balance cache
    try {
        await rfqMakerBalanceCacheService.updateERC20OwnerBalancesAsync(chainId);
        MAKER_BALANCE_CACHE_UPDATE_PROCESS_COUNT.inc();
    }
    catch (error) {
        logger_1.logger.error({ jobName: job.name, queue: job.queueName, data: job.data, timestamp: Date.now() }, 'Failed to update maker balance cache while running scheduled background job');
        throw new Error('Failed to update maker balance cache while running scheduled background job');
    }
    finally {
        await rfqMakerBalanceCacheService.closeAsync();
    }
    await job.updateProgress(100);
    return {
        chainId,
        jobName: job.name,
        timestamp: Date.now(),
    };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9iYWNrZ3JvdW5kLWpvYnMvbWFrZXJfYmFsYW5jZV9jYWNoZV91cGRhdGUudHMiLCJtYXBwaW5ncyI6Ijs7QUFFQSw2Q0FBc0M7QUFFdEMsc0NBQWlEO0FBQ2pELHNDQUFtQztBQUNuQyx3RUFBc0Y7QUFJdEYsTUFBTSxVQUFVLEdBQUcsNEJBQTRCLENBQUM7QUFDaEQsd0NBQXdDO0FBQ3hDLE1BQU0sc0JBQXNCLEdBQUc7SUFDM0IsS0FBSyxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQztDQUNyQixDQUFDO0FBQ0YscUNBQXFDO0FBQ3JDLE1BQU0scUJBQXFCLEdBQUc7SUFDMUIsS0FBSyxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUM7Q0FDekIsQ0FBQztBQUNGLE1BQU0sbUNBQW1DLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQyw0Q0FBNEM7QUFDMUcsTUFBTSxXQUFXLEdBQUcsc0ZBQXNGLENBQUM7QUFhM0csTUFBTSxzQkFBc0IsR0FBcUY7SUFDN0csU0FBUyxFQUFFLFVBQVU7SUFDckIsUUFBUSxFQUFFLG1DQUFtQztJQUM3QyxXQUFXLEVBQUUsV0FBVztJQUN4QixXQUFXO0lBQ1gsWUFBWTtDQUNmLENBQUM7QUFDRiw4Q0FBOEM7QUFDOUMsa0JBQWUsc0JBQXNCLENBQUM7QUFFdEMsTUFBTSx3Q0FBd0MsR0FBRyxJQUFJLHFCQUFPLENBQUM7SUFDekQsSUFBSSxFQUFFLDZDQUE2QztJQUNuRCxJQUFJLEVBQUUsb0dBQW9HO0NBQzdHLENBQUMsQ0FBQztBQUVIOzs7Ozs7R0FNRztBQUNILEtBQUssVUFBVSxXQUFXLENBQ3RCLEtBQVksRUFDWixJQUF5QztJQUV6QyxlQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsRUFBRSwwREFBMEQsQ0FBQyxDQUFDO0lBQ3JHLE9BQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFVBQVUsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUUsSUFBSSxFQUFFO1FBQ3RELGdCQUFnQixFQUFFLHNCQUFzQjtRQUN4QyxZQUFZLEVBQUUscUJBQXFCO0tBQ3RDLENBQUMsQ0FBQztBQUNQLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxLQUFLLFVBQVUsWUFBWSxDQUN2QixHQUFrRTtJQUVsRSxNQUFNLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUIsZUFBTSxDQUFDLElBQUksQ0FDUCxFQUFFLE9BQU8sRUFBRSxHQUFHLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFDbEYsbUVBQW1FLENBQ3RFLENBQUM7SUFFRixNQUFNLE9BQU8sR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUVqQyxxQkFBcUI7SUFDckIsTUFBTSxLQUFLLEdBQUcsNkJBQW9CLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxLQUFLLE9BQU8sQ0FBQyxDQUFDO0lBQ3RFLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDUixNQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxPQUFPOytDQUNuQyxDQUFDLENBQUM7S0FDNUM7SUFDRCxNQUFNLDJCQUEyQixHQUFHLE1BQU0sSUFBQSw0REFBcUMsRUFBQyxLQUFLLENBQUMsQ0FBQztJQUV2RixJQUFJLENBQUMsMkJBQTJCLEVBQUU7UUFDOUIsZUFBTSxDQUFDLEtBQUssQ0FDUixFQUFFLE9BQU8sRUFBRSxHQUFHLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFDbEYsa0VBQWtFLENBQ3JFLENBQUM7UUFDRixNQUFNLElBQUksS0FBSyxDQUFDLGtFQUFrRSxDQUFDLENBQUM7S0FDdkY7SUFDRCxNQUFNLEdBQUcsQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7SUFFN0Isd0NBQXdDO0lBQ3hDLElBQUk7UUFDQSxNQUFNLDJCQUEyQixDQUFDLDZCQUE2QixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3pFLHdDQUF3QyxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ2xEO0lBQUMsT0FBTyxLQUFLLEVBQUU7UUFDWixlQUFNLENBQUMsS0FBSyxDQUNSLEVBQUUsT0FBTyxFQUFFLEdBQUcsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUNsRiw2RUFBNkUsQ0FDaEYsQ0FBQztRQUNGLE1BQU0sSUFBSSxLQUFLLENBQUMsNkVBQTZFLENBQUMsQ0FBQztLQUNsRztZQUFTO1FBQ04sTUFBTSwyQkFBMkIsQ0FBQyxVQUFVLEVBQUUsQ0FBQztLQUNsRDtJQUVELE1BQU0sR0FBRyxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM5QixPQUFPO1FBQ0gsT0FBTztRQUNQLE9BQU8sRUFBRSxHQUFHLENBQUMsSUFBSTtRQUNqQixTQUFTLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRTtLQUN4QixDQUFDO0FBQ04sQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvZGF2aWR3YWxzaC9jb2RlLWxvY2FsLzB4LXJmcS1hcGkvc3JjL2JhY2tncm91bmQtam9icy9tYWtlcl9iYWxhbmNlX2NhY2hlX3VwZGF0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZTpjdXN0b20tbm8tbWFnaWMtbnVtYmVyc1xuaW1wb3J0IHsgSm9iLCBRdWV1ZSB9IGZyb20gJ2J1bGxtcSc7XG5pbXBvcnQgeyBDb3VudGVyIH0gZnJvbSAncHJvbS1jbGllbnQnO1xuXG5pbXBvcnQgeyBDSEFJTl9DT05GSUdVUkFUSU9OUyB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgYnVpbGRSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2VBc3luYyB9IGZyb20gJy4uL3V0aWxzL3JmcW1fc2VydmljZV9idWlsZGVyJztcblxuaW1wb3J0IHsgQmFja2dyb3VuZEpvYkJsdWVwcmludCB9IGZyb20gJy4vYmx1ZXByaW50JztcblxuY29uc3QgUVVFVUVfTkFNRSA9ICdtYWtlci1iYWxhbmNlLWNhY2hlLXVwZGF0ZSc7XG4vLyBrZWVwIHN1Y2Nlc3NmdWwgam9iIGhpc3RvcnkgZm9yIDEgZGF5XG5jb25zdCBSRU1PVkVfT05fQ09NUExFVEVfT1BTID0ge1xuICAgIGNvdW50OiAyNCAqIDYwICogNixcbn07XG4vLyBrZWVwIGZhaWxlZCBqb2IgaGlzdG9yeSBmb3IgMyBkYXlzXG5jb25zdCBSRU1PVkVfT05fRkFJTFVSRV9PUFMgPSB7XG4gICAgY291bnQ6IDMgKiAyNCAqIDYwICogNixcbn07XG5jb25zdCBNQUtFUl9CQUxBTkNFX0NBQ0hFX1VQREFURV9TQ0hFRFVMRSA9ICcqLzEwICogKiAqICogKic7IC8vIGpvYiB3aWxsIGJlIHNjaGVkdWxlZCBhdCBldmVyeSAxMCBzZWNvbmRzXG5jb25zdCBERVNDUklQVElPTiA9ICdQZXJpb2RpY2FsbHkgdXBkYXRlcyBvYnNlcnZlZCBlbnRyaWVzIGluIG1ha2VyIGJhbGFuY2UgY2FjaGUgdGhyb3VnaCBiYWxhbmNlIGNoZWNrcy4nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tncm91bmRKb2JNQkNVcGRhdGVEYXRhIHtcbiAgICBjaGFpbklkOiBudW1iZXI7XG4gICAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2dyb3VuZEpvYk1CQ1VwZGF0ZVJlc3VsdCB7XG4gICAgY2hhaW5JZDogbnVtYmVyO1xuICAgIGpvYk5hbWU6IHN0cmluZztcbiAgICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuY29uc3QgYmFja2dyb3VuZEpvYk1CQ1VwZGF0ZTogQmFja2dyb3VuZEpvYkJsdWVwcmludDxCYWNrZ3JvdW5kSm9iTUJDVXBkYXRlRGF0YSwgQmFja2dyb3VuZEpvYk1CQ1VwZGF0ZVJlc3VsdD4gPSB7XG4gICAgcXVldWVOYW1lOiBRVUVVRV9OQU1FLFxuICAgIHNjaGVkdWxlOiBNQUtFUl9CQUxBTkNFX0NBQ0hFX1VQREFURV9TQ0hFRFVMRSxcbiAgICBkZXNjcmlwdGlvbjogREVTQ1JJUFRJT04sXG4gICAgY3JlYXRlQXN5bmMsXG4gICAgcHJvY2Vzc0FzeW5jLFxufTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tZGVmYXVsdC1leHBvcnRcbmV4cG9ydCBkZWZhdWx0IGJhY2tncm91bmRKb2JNQkNVcGRhdGU7XG5cbmNvbnN0IE1BS0VSX0JBTEFOQ0VfQ0FDSEVfVVBEQVRFX1BST0NFU1NfQ09VTlQgPSBuZXcgQ291bnRlcih7XG4gICAgbmFtZTogJ3JmcV9iYWNrZ3JvdW5kX2pvYl9tYmNfdXBkYXRlX3Byb2Nlc3NfdG90YWwnLFxuICAgIGhlbHA6ICdOdW1iZXIgb2YgdGltZXMgdGhlIHByb2Nlc3NvciBtZXRob2Qgb2YgdGhlIG1ha2VyIGJhbGFuY2UgY2FjaGUgdXBkYXRlIGJhY2tncm91bmQgam9iIGlzIHRyaWdnZXJlZCcsXG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYmFja2dyb3VuZCBqb2IgYnkgcXVldWVzIGEgbWVzc2FnZSB0aGF0IHBlcmZvcm1zIGFuIHVwZGF0ZSBvbiB0aGUgbWFrZXIgYmFsYW5jZSBjYWNoZS5cbiAqXG4gKiBAcGFyYW0gcXVldWUgUXVldWUgdG8gcHVzaCB0aGUgbWVzc2FnZS5cbiAqIEBwYXJhbSBkYXRhIE5lY2Vzc2FyeSBkYXRhIGZvciBwcm9jZXNzb3IgdG8gZXhlY3V0ZSB0aGUgYmFja2dyb3VuZCBqb2IuXG4gKiBAcmV0dXJucyBQcm9taXNlIG9mIHRoZSBiYWNrZ3JvdW5kIGpvYi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQXN5bmMoXG4gICAgcXVldWU6IFF1ZXVlLFxuICAgIGRhdGE6IFBhcnRpYWw8QmFja2dyb3VuZEpvYk1CQ1VwZGF0ZURhdGE+LFxuKTogUHJvbWlzZTxKb2I8QmFja2dyb3VuZEpvYk1CQ1VwZGF0ZURhdGEsIEJhY2tncm91bmRKb2JNQkNVcGRhdGVSZXN1bHQ+PiB7XG4gICAgbG9nZ2VyLmluZm8oeyBxdWV1ZTogUVVFVUVfTkFNRSwgZGF0YSB9LCAnQ3JlYXRpbmcgdGhlIG1ha2VyIGJhbGFuY2UgY2FjaGUgYmFja2dyb3VuZCBqb2Igb24gcXVldWUnKTtcbiAgICByZXR1cm4gcXVldWUuYWRkKGAke1FVRVVFX05BTUV9LiR7ZGF0YS50aW1lc3RhbXB9YCwgZGF0YSwge1xuICAgICAgICByZW1vdmVPbkNvbXBsZXRlOiBSRU1PVkVfT05fQ09NUExFVEVfT1BTLFxuICAgICAgICByZW1vdmVPbkZhaWw6IFJFTU9WRV9PTl9GQUlMVVJFX09QUyxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzb3IgbWV0aG9kIGZvciB0aGUgbWFrZXIgYmFsYW5jZSBjYWNoZSB1cGRhdGUgam9iLiBSdW5zIGEgY2FjaGUgdXBkYXRlLFxuICogcGVyZm9ybWluZyBiYWxhbmNlIGNoZWNrcyBvbiBvYnNlcnZlZCBtYWtlciBiYWxhbmNlcy5cbiAqXG4gKiBAcGFyYW0gam9iIE1ha2VyIGJhbGFuY2UgY2FjaGUgdXBkYXRlIGJhY2tncm91bmQgam9iLlxuICogQHJldHVybnMgUmVzdWx0IG9mIHRoZSB1cGRhdGUgYmFja2dyb3VuZCBqb2IuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NBc3luYyhcbiAgICBqb2I6IEpvYjxCYWNrZ3JvdW5kSm9iTUJDVXBkYXRlRGF0YSwgQmFja2dyb3VuZEpvYk1CQ1VwZGF0ZVJlc3VsdD4sXG4pOiBQcm9taXNlPEJhY2tncm91bmRKb2JNQkNVcGRhdGVSZXN1bHQ+IHtcbiAgICBhd2FpdCBqb2IudXBkYXRlUHJvZ3Jlc3MoMCk7XG4gICAgbG9nZ2VyLmluZm8oXG4gICAgICAgIHsgam9iTmFtZTogam9iLm5hbWUsIHF1ZXVlOiBqb2IucXVldWVOYW1lLCBkYXRhOiBqb2IuZGF0YSwgdGltZXN0YW1wOiBEYXRlLm5vdygpIH0sXG4gICAgICAgICdQcm9jZXNzaW5nIHRoZSBtYWtlciBiYWxhbmNlIGNhY2hlIHVwZGF0ZSBiYWNrZ3JvdW5kIGpvYiBvbiBxdWV1ZScsXG4gICAgKTtcblxuICAgIGNvbnN0IGNoYWluSWQgPSBqb2IuZGF0YS5jaGFpbklkO1xuXG4gICAgLy8gQnVpbGQgZGVwZW5kZW5jaWVzXG4gICAgY29uc3QgY2hhaW4gPSBDSEFJTl9DT05GSUdVUkFUSU9OUy5maW5kKChjKSA9PiBjLmNoYWluSWQgPT09IGNoYWluSWQpO1xuICAgIGlmICghY2hhaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmllZCB0byBzdGFydCBiYWNrZ3JvdW5kIGpvYiBwcm9jZXNzIGZvciBjaGFpbiAke2NoYWluSWR9XG4gICAgICAgIGJ1dCBubyBjaGFpbiBjb25maWd1cmF0aW9uIHdhcyBwcmVzZW50YCk7XG4gICAgfVxuICAgIGNvbnN0IHJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSA9IGF3YWl0IGJ1aWxkUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlQXN5bmMoY2hhaW4pO1xuXG4gICAgaWYgKCFyZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgeyBqb2JOYW1lOiBqb2IubmFtZSwgcXVldWU6IGpvYi5xdWV1ZU5hbWUsIGRhdGE6IGpvYi5kYXRhLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfSxcbiAgICAgICAgICAgICdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBkZXBlbmRlbmNpZXMgZm9yIG1ha2VyLWJhbGFuY2UtY2FjaGUtdXBkYXRlJyxcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBkZXBlbmRlbmNpZXMgZm9yIG1ha2VyLWJhbGFuY2UtY2FjaGUtdXBkYXRlJyk7XG4gICAgfVxuICAgIGF3YWl0IGpvYi51cGRhdGVQcm9ncmVzcyg1MCk7XG5cbiAgICAvLyBQZXJmb3JtIHVwZGF0ZSBvbiBtYWtlciBiYWxhbmNlIGNhY2hlXG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlLnVwZGF0ZUVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKGNoYWluSWQpO1xuICAgICAgICBNQUtFUl9CQUxBTkNFX0NBQ0hFX1VQREFURV9QUk9DRVNTX0NPVU5ULmluYygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgIHsgam9iTmFtZTogam9iLm5hbWUsIHF1ZXVlOiBqb2IucXVldWVOYW1lLCBkYXRhOiBqb2IuZGF0YSwgdGltZXN0YW1wOiBEYXRlLm5vdygpIH0sXG4gICAgICAgICAgICAnRmFpbGVkIHRvIHVwZGF0ZSBtYWtlciBiYWxhbmNlIGNhY2hlIHdoaWxlIHJ1bm5pbmcgc2NoZWR1bGVkIGJhY2tncm91bmQgam9iJyxcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIG1ha2VyIGJhbGFuY2UgY2FjaGUgd2hpbGUgcnVubmluZyBzY2hlZHVsZWQgYmFja2dyb3VuZCBqb2InKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBhd2FpdCByZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UuY2xvc2VBc3luYygpO1xuICAgIH1cblxuICAgIGF3YWl0IGpvYi51cGRhdGVQcm9ncmVzcygxMDApO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIGpvYk5hbWU6IGpvYi5uYW1lLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgfTtcbn1cbiJdLCJ2ZXJzaW9uIjozfQ==