{"file":"/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts","mappings":"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","names":[],"sources":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/TokenPriceOracle.ts"],"sourcesContent":["import { BigNumber } from '@0x/utils';\nimport { AxiosInstance } from 'axios';\nimport { Summary } from 'prom-client';\n\nimport { logger } from '../logger';\n\n/**\n * With this summary metric, some of the things you can do are:\n * - Get the rate of failed price fetch requests:\n *      rate(rfq_token_price_fetch_request_duration_seconds_count{success=\"false\"}[5m])\n * - Get the rate of success price fetch requests:\n *      rate(rfq_token_price_fetch_request_duration_seconds_count{success=\"true\"}[5m])\n * - Get the p95 of request duration of all success price fetch (with the sliding window of 1 minute):\n *      rfq_token_price_fetch_request_duration_seconds{quantile=\"0.99\", success=\"true\"}\n */\nconst RFQ_TOKEN_PRICE_FETCH_REQUEST_DURATION_SECONDS = new Summary({\n    name: 'rfq_token_price_fetch_request_duration_seconds',\n    help: 'Histogram of request duration of token price fetch request',\n    percentiles: [0.5, 0.9, 0.95, 0.99, 0.999], // tslint:disable-line: custom-no-magic-numbers\n    labelNames: ['chainId', 'success'],\n    // Set sliding window to 1 minutes\n    maxAgeSeconds: 60,\n    // The more number of age buckets, the smoother the time window is moved\n    // but it also consumes more memory & CPU for maintaining the bucket.\n    ageBuckets: 5,\n});\n\nexport interface FetchTokenPriceParams {\n    chainId: number;\n    /**\n     * Must be a valid ERC-20 contract address\n     */\n    tokenAddress: string;\n    tokenDecimals: number;\n}\n\ntype TokenPriceFetchResponse = BigNumber | null;\n\nexport class TokenPriceOracle {\n    /**\n     * In-memory cache implementation for token price. A map with:\n     * - Key is `${chainId}:${tokenAddress}`\n     * - Value is a 2-items array with the first item is cache expiry timestamp (ms), second item\n     *   is the cached response.\n     */\n    private readonly _tokenPriceCache: Map<string, [number, TokenPriceFetchResponse]>;\n\n    public constructor(\n        private readonly _axiosInstance: AxiosInstance,\n        private readonly _definedFiApiKey: string,\n        private readonly _definedFiEndpoint: string,\n        private readonly _cacheTTLMs: number = 20000,\n    ) {\n        if (!_definedFiApiKey) {\n            throw new Error('Missing Defined.Fi API Key');\n        }\n        this._tokenPriceCache = new Map();\n    }\n\n    /**\n     * Fetch the current price of multiple tokens. The returned array will be a list\n     * of result for each item in passed via params in the same order.\n     */\n    public async batchFetchTokenPriceAsync(params: FetchTokenPriceParams[]): Promise<TokenPriceFetchResponse[]> {\n        // Note: we can actually batching the getPrice requests in a single GraphQL query\n        // but this is for future improvement. For now, batching via sending multiple graphql requests\n        // in parallel should be sufficient\n        return Promise.all(params.map((p) => this._fetchTokenPriceCachedAsync(p)));\n    }\n\n    private async _fetchTokenPriceCachedAsync(params: FetchTokenPriceParams): Promise<TokenPriceFetchResponse> {\n        const cacheKey = `${params.chainId}:${params.tokenAddress}`;\n        const cacheData = this._tokenPriceCache.get(cacheKey);\n        if (cacheData && cacheData[0] > Date.now()) {\n            return cacheData[1];\n        }\n        const freshData = await this._fetchTokenPriceAsync(params);\n        this._tokenPriceCache.set(cacheKey, [Date.now() + this._cacheTTLMs, freshData]);\n        return freshData;\n    }\n\n    private async _fetchTokenPriceAsync(params: FetchTokenPriceParams): Promise<TokenPriceFetchResponse> {\n        const stopTimer = RFQ_TOKEN_PRICE_FETCH_REQUEST_DURATION_SECONDS.startTimer({\n            chainId: params.chainId.toString(),\n        });\n        try {\n            const { data } = await this._axiosInstance.post(\n                this._definedFiEndpoint,\n                {\n                    query: `\n                        query getPrice {\n                            getPrice(address: \"${params.tokenAddress}\", networkId: ${params.chainId}) {\n                              priceUsd\n                            }\n                        }\n                    `,\n                },\n                {\n                    headers: { 'x-api-key': this._definedFiApiKey },\n                },\n            );\n\n            const priceInUsd = data?.data?.getPrice?.priceUsd || null;\n            logger.info(\n                {\n                    priceInUsd,\n                    params,\n                },\n                'price and params in `_fetchTokenPriceAsync`',\n            );\n            if (!priceInUsd) {\n                throw new Error(`Got 200 but without price value. Response body: ${JSON.stringify(data)}`);\n            }\n\n            stopTimer({ success: 'true' });\n            return new BigNumber(priceInUsd).shiftedBy(params.tokenDecimals * -1); // USD price of 1 base unit\n        } catch (error) {\n            logger.error({ ...params, message: error.message }, 'Failed to fetch token price');\n\n            stopTimer({ success: 'false' });\n            return null;\n        }\n    }\n}\n"],"version":3}