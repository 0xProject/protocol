8ba6a28c396434a9cb298a476ad3f138
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildRfqmServicesAsync = exports.buildRfqMakerBalanceCacheServiceAsync = exports.buildWorkerServiceAsync = exports.buildRfqmServiceAsync = exports.getContractAddressesForNetworkOrThrowAsync = exports.getAxiosRequestConfigWithProxy = exports.getAxiosRequestConfig = void 0;
const asset_swapper_1 = require("@0x/asset-swapper");
const contract_addresses_1 = require("@0x/contract-addresses");
const subproviders_1 = require("@0x/subproviders");
const token_metadata_1 = require("@0x/token-metadata");
const web3_wrapper_1 = require("@0x/web3-wrapper");
const axios_1 = require("axios");
const ethers_1 = require("ethers");
const http_1 = require("http");
const https_1 = require("https");
const ioredis_1 = require("ioredis");
const kafkajs_1 = require("kafkajs");
const sqs_producer_1 = require("sqs-producer");
const config_1 = require("../config");
const constants_1 = require("../core/constants");
const logger_1 = require("../logger");
const fee_service_1 = require("../services/fee_service");
const rfqm_service_1 = require("../services/rfqm_service");
const rfq_maker_balance_cache_service_1 = require("../services/rfq_maker_balance_cache_service");
const WorkerService_1 = require("../services/WorkerService");
const balance_checker_1 = require("./balance_checker");
const cache_client_1 = require("./cache_client");
const config_manager_1 = require("./config_manager");
const GasStationAttendantUtils_1 = require("./GasStationAttendantUtils");
const provider_utils_1 = require("./provider_utils");
const quote_server_client_1 = require("./quote_server_client");
const rfq_blockchain_utils_1 = require("./rfq_blockchain_utils");
const rfq_maker_manager_1 = require("./rfq_maker_manager");
const TokenMetadataManager_1 = require("./TokenMetadataManager");
const ZeroExApiClient_1 = require("./ZeroExApiClient");
const DEFAULT_AXIOS_TIMEOUT = 600; // ms
/**
 * Initialize a kafka producer if KAFKA_BROKERS is set
 */
function getKafkaProducer() {
    let kafkaProducer;
    if (config_1.KAFKA_BROKERS !== undefined) {
        const kafka = new kafkajs_1.Kafka({
            clientId: '0x-api',
            brokers: config_1.KAFKA_BROKERS,
        });
        kafkaProducer = kafka.producer();
        // tslint:disable-next-line: no-floating-promises
        kafkaProducer.connect();
    }
    return kafkaProducer;
}
/**
 * Creates the default Axios Request Config
 */
function getAxiosRequestConfig(timeout = DEFAULT_AXIOS_TIMEOUT) {
    return {
        httpAgent: new http_1.Agent({ keepAlive: true, timeout: constants_1.KEEP_ALIVE_TTL }),
        httpsAgent: new https_1.Agent({ keepAlive: true, timeout: constants_1.KEEP_ALIVE_TTL }),
        timeout,
    };
}
exports.getAxiosRequestConfig = getAxiosRequestConfig;
/**
 * Creates the Axios Request Config with egress proxy
 */
function getAxiosRequestConfigWithProxy() {
    const axiosRequestConfig = getAxiosRequestConfig();
    if (config_1.RFQ_PROXY_ADDRESS !== undefined && config_1.RFQ_PROXY_PORT !== undefined) {
        axiosRequestConfig.proxy = {
            host: config_1.RFQ_PROXY_ADDRESS,
            port: config_1.RFQ_PROXY_PORT,
        };
    }
    return axiosRequestConfig;
}
exports.getAxiosRequestConfigWithProxy = getAxiosRequestConfigWithProxy;
async function deploySamplerContractAsync(provider, chainId) {
    const web3Wrapper = new web3_wrapper_1.Web3Wrapper(provider);
    const _chainId = await web3Wrapper.getChainIdAsync();
    if (_chainId !== chainId) {
        throw new Error(`Incorrect Chain Id: ${_chainId}`);
    }
    const [account] = await web3Wrapper.getAvailableAddressesAsync();
    try {
        const sampler = await asset_swapper_1.ERC20BridgeSamplerContract.deployFrom0xArtifactAsync(asset_swapper_1.artifacts.ERC20BridgeSampler, provider, { from: account }, {});
        logger_1.logger.info(`Deployed ERC20BridgeSamplerContract on network ${chainId}: ${sampler.address}`);
        return sampler;
    }
    catch (err) {
        logger_1.logger.error(`Failed to deploy ERC20BridgeSamplerContract on network ${chainId}: ${err}`);
        throw err;
    }
}
/**
 * Determines the contract addresses needed for the network. For testing (ganache)
 * required contracts are deployed
 * @param provider provider to the network, used for ganache deployment
 * @param chainConfiguration used for getting chainId and exchangeProxyContractAddressOverride
 */
async function getContractAddressesForNetworkOrThrowAsync(provider, chainConfiguration) {
    const { chainId, exchangeProxyContractAddressOverride } = chainConfiguration;
    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let contractAddresses = (0, contract_addresses_1.getContractAddressesForChainOrThrow)(chainId.toString());
    // In a testnet where the environment does not support overrides
    // so we deploy the latest sampler
    if (chainId === contract_addresses_1.ChainId.Ganache) {
        const sampler = await deploySamplerContractAsync(provider, chainId);
        contractAddresses = { ...contractAddresses, erc20BridgeSampler: sampler.address };
    }
    // If 0x Exchange Proxy contract address override is defined in the chain config
    // we use address instead of the one provided from `@0x/contract-addresses`
    if (exchangeProxyContractAddressOverride) {
        contractAddresses = { ...contractAddresses, exchangeProxy: exchangeProxyContractAddressOverride };
    }
    return contractAddresses;
}
exports.getContractAddressesForNetworkOrThrowAsync = getContractAddressesForNetworkOrThrowAsync;
/**
 * Builds a single instance of RfqmService
 */
async function buildRfqmServiceAsync(rfqmDbUtils, rfqMakerManager, tokenPriceOracle, configManager, chain, redis) {
    const { rfqm: rfqmConfiguration, chainId } = chain;
    if (!rfqmConfiguration) {
        throw new Error(`RFQm Service for chain ${chainId} does not exist`);
    }
    // ether.js Provider coexists with web3 provider during migration away from 0x/web3-wrapper.
    const ethersProvider = new ethers_1.providers.JsonRpcProvider(chain.rpcUrl, chainId);
    const rpcProvider = provider_utils_1.providerUtils.createWeb3Provider(chain.rpcUrl);
    const provider = rpcProvider;
    const contractAddresses = await getContractAddressesForNetworkOrThrowAsync(provider, chain);
    const axiosInstance = axios_1.default.create(getAxiosRequestConfig());
    const proxiedAxiosInstance = axios_1.default.create(getAxiosRequestConfigWithProxy());
    const balanceChecker = new balance_checker_1.BalanceChecker(provider);
    const rfqBlockchainUtils = new rfq_blockchain_utils_1.RfqBlockchainUtils(provider, contractAddresses.exchangeProxy, balanceChecker, ethersProvider);
    const tokenMetadataManager = new TokenMetadataManager_1.TokenMetadataManager(chainId, rfqBlockchainUtils);
    const sqsProducer = sqs_producer_1.Producer.create({
        queueUrl: chain.sqsUrl,
    });
    const quoteServerClient = new quote_server_client_1.QuoteServerClient(proxiedAxiosInstance);
    const cacheClient = new cache_client_1.CacheClient(redis);
    const kafkaProducer = getKafkaProducer();
    const gasStationAttendant = (0, GasStationAttendantUtils_1.getGasStationAttendant)(chain, axiosInstance);
    const feeTokenMetadata = (0, token_metadata_1.getTokenMetadataIfExists)(contractAddresses.etherToken, chainId);
    if (feeTokenMetadata === undefined) {
        throw new Error(`Fee token ${contractAddresses.etherToken} on chain ${chainId} could not be found!`);
    }
    const zeroExApiClient = new ZeroExApiClient_1.ZeroExApiClient(axios_1.default.create(), config_1.ZERO_EX_API_KEY, chain);
    const feeService = new fee_service_1.FeeService(chainId, feeTokenMetadata, configManager, gasStationAttendant, tokenPriceOracle, zeroExApiClient, rfqmConfiguration.minExpiryDurationMs || constants_1.DEFAULT_MIN_EXPIRY_DURATION_MS);
    const rfqMakerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService(cacheClient, rfqBlockchainUtils.balanceCheckUtils);
    return new rfqm_service_1.RfqmService(chainId, feeService, rfqmConfiguration.feeModelVersion || 0, contractAddresses, chain.registryAddress, rfqBlockchainUtils, rfqmDbUtils, sqsProducer, quoteServerClient, rfqmConfiguration.minExpiryDurationMs || constants_1.DEFAULT_MIN_EXPIRY_DURATION_MS, cacheClient, rfqMakerBalanceCacheService, rfqMakerManager, tokenMetadataManager, kafkaProducer, rfqmConfiguration.quoteReportTopic);
}
exports.buildRfqmServiceAsync = buildRfqmServiceAsync;
/**
 * Builds a single instance of the WorkerService
 */
async function buildWorkerServiceAsync(rfqmDbUtils, rfqMakerManager, chain, redis, workerIndex) {
    const { worker: workerConfiguration, chainId } = chain;
    if (!workerConfiguration) {
        throw new Error(`Worker Service for chain ${chainId} does not exist`);
    }
    let provider;
    // ether.js Provider coexists with web3 provider during migration away from 0x/web3-wrapper.
    const ethersProvider = new ethers_1.providers.JsonRpcProvider(chain.rpcUrl, chainId);
    let ethersWallet;
    const rpcProvider = provider_utils_1.providerUtils.createWeb3Provider(chain.rpcUrl);
    if (config_1.META_TX_WORKER_MNEMONIC === undefined) {
        throw new Error(`META_TX_WORKER_MNEMONIC must be defined to run RFQM service as a worker`);
    }
    const workerPrivateKey = rfq_blockchain_utils_1.RfqBlockchainUtils.getPrivateKeyFromIndexAndPhrase(config_1.META_TX_WORKER_MNEMONIC, workerIndex);
    // TODO (rhinodavid): Remove once migration to ethers.js is complete
    const privateWalletSubprovider = new subproviders_1.PrivateKeyWalletSubprovider(workerPrivateKey);
    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
    // eslint-disable-next-line prefer-const
    provider = rfq_blockchain_utils_1.RfqBlockchainUtils.createPrivateKeyProvider(rpcProvider, privateWalletSubprovider);
    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ethersWallet = ethers_1.Wallet.fromMnemonic(config_1.META_TX_WORKER_MNEMONIC, `m/44'/60'/0'/0/${workerIndex}`);
    ethersWallet = ethersWallet.connect(ethersProvider);
    const contractAddresses = await getContractAddressesForNetworkOrThrowAsync(provider, chain);
    const axiosInstance = axios_1.default.create(getAxiosRequestConfigWithProxy());
    const balanceChecker = new balance_checker_1.BalanceChecker(provider);
    const rfqBlockchainUtils = new rfq_blockchain_utils_1.RfqBlockchainUtils(provider, contractAddresses.exchangeProxy, balanceChecker, ethersProvider, ethersWallet);
    const quoteServerClient = new quote_server_client_1.QuoteServerClient(axiosInstance);
    const cacheClient = new cache_client_1.CacheClient(redis);
    const gasStationAttendant = (0, GasStationAttendantUtils_1.getGasStationAttendant)(chain, axiosInstance);
    const feeTokenMetadata = (0, token_metadata_1.getTokenMetadataIfExists)(contractAddresses.etherToken, chainId);
    if (feeTokenMetadata === undefined) {
        throw new Error(`Fee token ${contractAddresses.etherToken} on chain ${chainId} could not be found!`);
    }
    const rfqMakerBalanceCacheService = new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService(cacheClient, rfqBlockchainUtils.balanceCheckUtils);
    return new WorkerService_1.WorkerService(chainId, gasStationAttendant, chain.registryAddress, rfqBlockchainUtils, rfqmDbUtils, quoteServerClient, workerConfiguration.transactionWatcherSleepTimeMs || constants_1.DEFAULT_WORKER_TRANSACTION_WATCHER_SLEEP_TIME_MS, cacheClient, rfqMakerBalanceCacheService, rfqMakerManager, workerConfiguration.initialMaxPriorityFeePerGasGwei, workerConfiguration.maxFeePerGasCapGwei, workerConfiguration.enableAccessList);
}
exports.buildWorkerServiceAsync = buildWorkerServiceAsync;
/**
 * Builds an instance of maker balance cache service.
 * Intended to be used by maker balance cache background jobs.
 */
async function buildRfqMakerBalanceCacheServiceAsync(chain) {
    const provider = provider_utils_1.providerUtils.createWeb3Provider(chain.rpcUrl);
    const contractAddresses = await getContractAddressesForNetworkOrThrowAsync(provider, chain);
    const balanceChecker = new balance_checker_1.BalanceChecker(provider);
    const balanceCheckUtils = new rfq_blockchain_utils_1.RfqBalanceCheckUtils(balanceChecker, contractAddresses.exchangeProxy);
    if (!config_1.REDIS_URI) {
        throw new Error('No redis URI provided to maker balance cache service');
    }
    const redis = new ioredis_1.default(config_1.REDIS_URI);
    const cacheClient = new cache_client_1.CacheClient(redis);
    return new rfq_maker_balance_cache_service_1.RfqMakerBalanceCacheService(cacheClient, balanceCheckUtils);
}
exports.buildRfqMakerBalanceCacheServiceAsync = buildRfqMakerBalanceCacheServiceAsync;
/**
 * Creates an RFQM Service for each chain present in `ChainConfigurations`.
 *
 * Intended for use by the top-level runners.
 */
async function buildRfqmServicesAsync(asWorker, rfqmDbUtils, rfqMakerDbUtils, chainConfigurations, tokenPriceOracle, configManager = new config_manager_1.ConfigManager(), redis, 
// $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
// eslint-disable-next-line @typescript-eslint/no-inferrable-types
_workerIndex = 0) {
    const services = await Promise.all(chainConfigurations.map(async (chain) => {
        const rfqMakerManager = new rfq_maker_manager_1.RfqMakerManager(configManager, rfqMakerDbUtils, chain.chainId);
        await rfqMakerManager.initializeAsync();
        return buildRfqmServiceAsync(rfqmDbUtils, rfqMakerManager, tokenPriceOracle, configManager, chain, redis);
    }));
    return new Map(services.map((s, i) => [chainConfigurations[i].chainId, s]));
}
exports.buildRfqmServicesAsync = buildRfqmServicesAsync;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy91dGlscy9yZnFtX3NlcnZpY2VfYnVpbGRlci50cyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxxREFLMkI7QUFDM0IsK0RBQXNGO0FBQ3RGLG1EQUErRDtBQUMvRCx1REFBOEQ7QUFDOUQsbURBQStDO0FBQy9DLGlDQUFrRDtBQUNsRCxtQ0FBMkM7QUFDM0MsK0JBQTBDO0FBQzFDLGlDQUE0QztBQUM1QyxxQ0FBNEI7QUFDNUIscUNBQTJEO0FBQzNELCtDQUF3QztBQUV4QyxzQ0FTbUI7QUFDbkIsaURBSTJCO0FBQzNCLHNDQUFtQztBQUNuQyx5REFBcUQ7QUFDckQsMkRBQXVEO0FBQ3ZELGlHQUEwRjtBQUMxRiw2REFBMEQ7QUFFMUQsdURBQW1EO0FBQ25ELGlEQUE2QztBQUM3QyxxREFBaUQ7QUFDakQseUVBQW9FO0FBQ3BFLHFEQUFpRDtBQUNqRCwrREFBMEQ7QUFFMUQsaUVBQWtGO0FBRWxGLDJEQUFzRDtBQUN0RCxpRUFBOEQ7QUFFOUQsdURBQW9EO0FBSXBELE1BQU0scUJBQXFCLEdBQUcsR0FBRyxDQUFDLENBQUMsS0FBSztBQUV4Qzs7R0FFRztBQUNILFNBQVMsZ0JBQWdCO0lBQ3JCLElBQUksYUFBd0MsQ0FBQztJQUM3QyxJQUFJLHNCQUFhLEtBQUssU0FBUyxFQUFFO1FBQzdCLE1BQU0sS0FBSyxHQUFHLElBQUksZUFBSyxDQUFDO1lBQ3BCLFFBQVEsRUFBRSxRQUFRO1lBQ2xCLE9BQU8sRUFBRSxzQkFBYTtTQUN6QixDQUFDLENBQUM7UUFFSCxhQUFhLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2pDLGlEQUFpRDtRQUNqRCxhQUFhLENBQUMsT0FBTyxFQUFFLENBQUM7S0FDM0I7SUFDRCxPQUFPLGFBQWEsQ0FBQztBQUN6QixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixxQkFBcUIsQ0FBQyxVQUFrQixxQkFBcUI7SUFDekUsT0FBTztRQUNILFNBQVMsRUFBRSxJQUFJLFlBQVMs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Wiw2REFBNkQ7QUFDN0Qsa0VBQWtFO0FBQ2xFLGVBQXVCLENBQUM7SUFFeEIsTUFBTSxRQUFRLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUM5QixtQkFBbUIsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFO1FBQ3BDLE1BQU0sZUFBZSxHQUFHLElBQUksbUNBQWUsQ0FBQyxhQUFhLEVBQUUsZUFBZSxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzRixNQUFNLGVBQWUsQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN4QyxPQUFPLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM5RyxDQUFDLENBQUMsQ0FDTCxDQUFDO0lBQ0YsT0FBTyxJQUFJLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hGLENBQUM7QUFwQkQsd0RBb0JDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXZpZHdhbHNoL2NvZGUtbG9jYWwvMHgtcmZxLWFwaS9zcmMvdXRpbHMvcmZxbV9zZXJ2aWNlX2J1aWxkZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBhcnRpZmFjdHMsXG4gICAgQXNzZXRTd2FwcGVyQ29udHJhY3RBZGRyZXNzZXMsXG4gICAgRVJDMjBCcmlkZ2VTYW1wbGVyQ29udHJhY3QsXG4gICAgU3VwcG9ydGVkUHJvdmlkZXIsXG59IGZyb20gJ0AweC9hc3NldC1zd2FwcGVyJztcbmltcG9ydCB7IENoYWluSWQsIGdldENvbnRyYWN0QWRkcmVzc2VzRm9yQ2hhaW5PclRocm93IH0gZnJvbSAnQDB4L2NvbnRyYWN0LWFkZHJlc3Nlcyc7XG5pbXBvcnQgeyBQcml2YXRlS2V5V2FsbGV0U3VicHJvdmlkZXIgfSBmcm9tICdAMHgvc3VicHJvdmlkZXJzJztcbmltcG9ydCB7IGdldFRva2VuTWV0YWRhdGFJZkV4aXN0cyB9IGZyb20gJ0AweC90b2tlbi1tZXRhZGF0YSc7XG5pbXBvcnQgeyBXZWIzV3JhcHBlciB9IGZyb20gJ0AweC93ZWIzLXdyYXBwZXInO1xuaW1wb3J0IEF4aW9zLCB7IEF4aW9zUmVxdWVzdENvbmZpZyB9IGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IHByb3ZpZGVycywgV2FsbGV0IH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IEFnZW50IGFzIEh0dHBBZ2VudCB9IGZyb20gJ2h0dHAnO1xuaW1wb3J0IHsgQWdlbnQgYXMgSHR0cHNBZ2VudCB9IGZyb20gJ2h0dHBzJztcbmltcG9ydCBSZWRpcyBmcm9tICdpb3JlZGlzJztcbmltcG9ydCB7IEthZmthLCBQcm9kdWNlciBhcyBLYWZrYVByb2R1Y2VyIH0gZnJvbSAna2Fma2Fqcyc7XG5pbXBvcnQgeyBQcm9kdWNlciB9IGZyb20gJ3Nxcy1wcm9kdWNlcic7XG5cbmltcG9ydCB7XG4gICAgQ2hhaW5Db25maWd1cmF0aW9uLFxuICAgIENoYWluQ29uZmlndXJhdGlvbnMsXG4gICAgS0FGS0FfQlJPS0VSUyxcbiAgICBNRVRBX1RYX1dPUktFUl9NTkVNT05JQyxcbiAgICBSRURJU19VUkksXG4gICAgUkZRX1BST1hZX0FERFJFU1MsXG4gICAgUkZRX1BST1hZX1BPUlQsXG4gICAgWkVST19FWF9BUElfS0VZLFxufSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHtcbiAgICBERUZBVUxUX01JTl9FWFBJUllfRFVSQVRJT05fTVMsXG4gICAgREVGQVVMVF9XT1JLRVJfVFJBTlNBQ1RJT05fV0FUQ0hFUl9TTEVFUF9USU1FX01TLFxuICAgIEtFRVBfQUxJVkVfVFRMLFxufSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgRmVlU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2ZlZV9zZXJ2aWNlJztcbmltcG9ydCB7IFJmcW1TZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvcmZxbV9zZXJ2aWNlJztcbmltcG9ydCB7IFJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL3JmcV9tYWtlcl9iYWxhbmNlX2NhY2hlX3NlcnZpY2UnO1xuaW1wb3J0IHsgV29ya2VyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL1dvcmtlclNlcnZpY2UnO1xuXG5pbXBvcnQgeyBCYWxhbmNlQ2hlY2tlciB9IGZyb20gJy4vYmFsYW5jZV9jaGVja2VyJztcbmltcG9ydCB7IENhY2hlQ2xpZW50IH0gZnJvbSAnLi9jYWNoZV9jbGllbnQnO1xuaW1wb3J0IHsgQ29uZmlnTWFuYWdlciB9IGZyb20gJy4vY29uZmlnX21hbmFnZXInO1xuaW1wb3J0IHsgZ2V0R2FzU3RhdGlvbkF0dGVuZGFudCB9IGZyb20gJy4vR2FzU3RhdGlvbkF0dGVuZGFudFV0aWxzJztcbmltcG9ydCB7IHByb3ZpZGVyVXRpbHMgfSBmcm9tICcuL3Byb3ZpZGVyX3V0aWxzJztcbmltcG9ydCB7IFF1b3RlU2VydmVyQ2xpZW50IH0gZnJvbSAnLi9xdW90ZV9zZXJ2ZXJfY2xpZW50JztcbmltcG9ydCB7IFJmcW1EYlV0aWxzIH0gZnJvbSAnLi9yZnFtX2RiX3V0aWxzJztcbmltcG9ydCB7IFJmcUJhbGFuY2VDaGVja1V0aWxzLCBSZnFCbG9ja2NoYWluVXRpbHMgfSBmcm9tICcuL3JmcV9ibG9ja2NoYWluX3V0aWxzJztcbmltcG9ydCB7IFJmcU1ha2VyRGJVdGlscyB9IGZyb20gJy4vcmZxX21ha2VyX2RiX3V0aWxzJztcbmltcG9ydCB7IFJmcU1ha2VyTWFuYWdlciB9IGZyb20gJy4vcmZxX21ha2VyX21hbmFnZXInO1xuaW1wb3J0IHsgVG9rZW5NZXRhZGF0YU1hbmFnZXIgfSBmcm9tICcuL1Rva2VuTWV0YWRhdGFNYW5hZ2VyJztcbmltcG9ydCB7IFRva2VuUHJpY2VPcmFjbGUgfSBmcm9tICcuL1Rva2VuUHJpY2VPcmFjbGUnO1xuaW1wb3J0IHsgWmVyb0V4QXBpQ2xpZW50IH0gZnJvbSAnLi9aZXJvRXhBcGlDbGllbnQnO1xuXG5leHBvcnQgdHlwZSBSZnFtU2VydmljZXMgPSBNYXA8bnVtYmVyLCBSZnFtU2VydmljZT47XG5cbmNvbnN0IERFRkFVTFRfQVhJT1NfVElNRU9VVCA9IDYwMDsgLy8gbXNcblxuLyoqXG4gKiBJbml0aWFsaXplIGEga2Fma2EgcHJvZHVjZXIgaWYgS0FGS0FfQlJPS0VSUyBpcyBzZXRcbiAqL1xuZnVuY3Rpb24gZ2V0S2Fma2FQcm9kdWNlcigpOiBLYWZrYVByb2R1Y2VyIHwgdW5kZWZpbmVkIHtcbiAgICBsZXQga2Fma2FQcm9kdWNlcjogS2Fma2FQcm9kdWNlciB8IHVuZGVmaW5lZDtcbiAgICBpZiAoS0FGS0FfQlJPS0VSUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGthZmthID0gbmV3IEthZmthKHtcbiAgICAgICAgICAgIGNsaWVudElkOiAnMHgtYXBpJyxcbiAgICAgICAgICAgIGJyb2tlcnM6IEtBRktBX0JST0tFUlMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGthZmthUHJvZHVjZXIgPSBrYWZrYS5wcm9kdWNlcigpO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIGthZmthUHJvZHVjZXIuY29ubmVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4ga2Fma2FQcm9kdWNlcjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBkZWZhdWx0IEF4aW9zIFJlcXVlc3QgQ29uZmlnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBeGlvc1JlcXVlc3RDb25maWcodGltZW91dDogbnVtYmVyID0gREVGQVVMVF9BWElPU19USU1FT1VUKTogQXhpb3NSZXF1ZXN0Q29uZmlnIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBodHRwQWdlbnQ6IG5ldyBIdHRwQWdlbnQoeyBrZWVwQWxpdmU6IHRydWUsIHRpbWVvdXQ6IEtFRVBfQUxJVkVfVFRMIH0pLFxuICAgICAgICBodHRwc0FnZW50OiBuZXcgSHR0cHNBZ2VudCh7IGtlZXBBbGl2ZTogdHJ1ZSwgdGltZW91dDogS0VFUF9BTElWRV9UVEwgfSksXG4gICAgICAgIHRpbWVvdXQsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBBeGlvcyBSZXF1ZXN0IENvbmZpZyB3aXRoIGVncmVzcyBwcm94eVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXhpb3NSZXF1ZXN0Q29uZmlnV2l0aFByb3h5KCk6IEF4aW9zUmVxdWVzdENvbmZpZyB7XG4gICAgY29uc3QgYXhpb3NSZXF1ZXN0Q29uZmlnOiBBeGlvc1JlcXVlc3RDb25maWcgPSBnZXRBeGlvc1JlcXVlc3RDb25maWcoKTtcbiAgICBpZiAoUkZRX1BST1hZX0FERFJFU1MgIT09IHVuZGVmaW5lZCAmJiBSRlFfUFJPWFlfUE9SVCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF4aW9zUmVxdWVzdENvbmZpZy5wcm94eSA9IHtcbiAgICAgICAgICAgIGhvc3Q6IFJGUV9QUk9YWV9BRERSRVNTLFxuICAgICAgICAgICAgcG9ydDogUkZRX1BST1hZX1BPUlQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGF4aW9zUmVxdWVzdENvbmZpZztcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGVwbG95U2FtcGxlckNvbnRyYWN0QXN5bmMoXG4gICAgcHJvdmlkZXI6IFN1cHBvcnRlZFByb3ZpZGVyLFxuICAgIGNoYWluSWQ6IENoYWluSWQsXG4pOiBQcm9taXNlPEVSQzIwQnJpZGdlU2FtcGxlckNvbnRyYWN0PiB7XG4gICAgY29uc3Qgd2ViM1dyYXBwZXIgPSBuZXcgV2ViM1dyYXBwZXIocHJvdmlkZXIpO1xuICAgIGNvbnN0IF9jaGFpbklkID0gYXdhaXQgd2ViM1dyYXBwZXIuZ2V0Q2hhaW5JZEFzeW5jKCk7XG4gICAgaWYgKF9jaGFpbklkICE9PSBjaGFpbklkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb3JyZWN0IENoYWluIElkOiAke19jaGFpbklkfWApO1xuICAgIH1cbiAgICBjb25zdCBbYWNjb3VudF0gPSBhd2FpdCB3ZWIzV3JhcHBlci5nZXRBdmFpbGFibGVBZGRyZXNzZXNBc3luYygpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZXIgPSBhd2FpdCBFUkMyMEJyaWRnZVNhbXBsZXJDb250cmFjdC5kZXBsb3lGcm9tMHhBcnRpZmFjdEFzeW5jKFxuICAgICAgICAgICAgYXJ0aWZhY3RzLkVSQzIwQnJpZGdlU2FtcGxlcixcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgeyBmcm9tOiBhY2NvdW50IH0sXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYERlcGxveWVkIEVSQzIwQnJpZGdlU2FtcGxlckNvbnRyYWN0IG9uIG5ldHdvcmsgJHtjaGFpbklkfTogJHtzYW1wbGVyLmFkZHJlc3N9YCk7XG4gICAgICAgIHJldHVybiBzYW1wbGVyO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBkZXBsb3kgRVJDMjBCcmlkZ2VTYW1wbGVyQ29udHJhY3Qgb24gbmV0d29yayAke2NoYWluSWR9OiAke2Vycn1gKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBjb250cmFjdCBhZGRyZXNzZXMgbmVlZGVkIGZvciB0aGUgbmV0d29yay4gRm9yIHRlc3RpbmcgKGdhbmFjaGUpXG4gKiByZXF1aXJlZCBjb250cmFjdHMgYXJlIGRlcGxveWVkXG4gKiBAcGFyYW0gcHJvdmlkZXIgcHJvdmlkZXIgdG8gdGhlIG5ldHdvcmssIHVzZWQgZm9yIGdhbmFjaGUgZGVwbG95bWVudFxuICogQHBhcmFtIGNoYWluQ29uZmlndXJhdGlvbiB1c2VkIGZvciBnZXR0aW5nIGNoYWluSWQgYW5kIGV4Y2hhbmdlUHJveHlDb250cmFjdEFkZHJlc3NPdmVycmlkZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29udHJhY3RBZGRyZXNzZXNGb3JOZXR3b3JrT3JUaHJvd0FzeW5jKFxuICAgIHByb3ZpZGVyOiBTdXBwb3J0ZWRQcm92aWRlcixcbiAgICBjaGFpbkNvbmZpZ3VyYXRpb246IFBpY2s8Q2hhaW5Db25maWd1cmF0aW9uLCAnY2hhaW5JZCcgfCAnZXhjaGFuZ2VQcm94eUNvbnRyYWN0QWRkcmVzc092ZXJyaWRlJz4sXG4pOiBQcm9taXNlPEFzc2V0U3dhcHBlckNvbnRyYWN0QWRkcmVzc2VzPiB7XG4gICAgY29uc3QgeyBjaGFpbklkLCBleGNoYW5nZVByb3h5Q29udHJhY3RBZGRyZXNzT3ZlcnJpZGUgfSA9IGNoYWluQ29uZmlndXJhdGlvbjtcbiAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBsZXQgY29udHJhY3RBZGRyZXNzZXMgPSBnZXRDb250cmFjdEFkZHJlc3Nlc0ZvckNoYWluT3JUaHJvdyhjaGFpbklkLnRvU3RyaW5nKCkgYXMgYW55KTtcbiAgICAvLyBJbiBhIHRlc3RuZXQgd2hlcmUgdGhlIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgb3ZlcnJpZGVzXG4gICAgLy8gc28gd2UgZGVwbG95IHRoZSBsYXRlc3Qgc2FtcGxlclxuICAgIGlmIChjaGFpbklkID09PSBDaGFpbklkLkdhbmFjaGUpIHtcbiAgICAgICAgY29uc3Qgc2FtcGxlciA9IGF3YWl0IGRlcGxveVNhbXBsZXJDb250cmFjdEFzeW5jKHByb3ZpZGVyLCBjaGFpbklkKTtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzZXMgPSB7IC4uLmNvbnRyYWN0QWRkcmVzc2VzLCBlcmMyMEJyaWRnZVNhbXBsZXI6IHNhbXBsZXIuYWRkcmVzcyB9O1xuICAgIH1cbiAgICAvLyBJZiAweCBFeGNoYW5nZSBQcm94eSBjb250cmFjdCBhZGRyZXNzIG92ZXJyaWRlIGlzIGRlZmluZWQgaW4gdGhlIGNoYWluIGNvbmZpZ1xuICAgIC8vIHdlIHVzZSBhZGRyZXNzIGluc3RlYWQgb2YgdGhlIG9uZSBwcm92aWRlZCBmcm9tIGBAMHgvY29udHJhY3QtYWRkcmVzc2VzYFxuICAgIGlmIChleGNoYW5nZVByb3h5Q29udHJhY3RBZGRyZXNzT3ZlcnJpZGUpIHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzZXMgPSB7IC4uLmNvbnRyYWN0QWRkcmVzc2VzLCBleGNoYW5nZVByb3h5OiBleGNoYW5nZVByb3h5Q29udHJhY3RBZGRyZXNzT3ZlcnJpZGUgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyYWN0QWRkcmVzc2VzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyBhIHNpbmdsZSBpbnN0YW5jZSBvZiBSZnFtU2VydmljZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGRSZnFtU2VydmljZUFzeW5jKFxuICAgIHJmcW1EYlV0aWxzOiBSZnFtRGJVdGlscyxcbiAgICByZnFNYWtlck1hbmFnZXI6IFJmcU1ha2VyTWFuYWdlcixcbiAgICB0b2tlblByaWNlT3JhY2xlOiBUb2tlblByaWNlT3JhY2xlLFxuICAgIGNvbmZpZ01hbmFnZXI6IENvbmZpZ01hbmFnZXIsXG4gICAgY2hhaW46IENoYWluQ29uZmlndXJhdGlvbixcbiAgICByZWRpczogUmVkaXMsXG4pOiBQcm9taXNlPFJmcW1TZXJ2aWNlPiB7XG4gICAgY29uc3QgeyByZnFtOiByZnFtQ29uZmlndXJhdGlvbiwgY2hhaW5JZCB9ID0gY2hhaW47XG4gICAgaWYgKCFyZnFtQ29uZmlndXJhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJGUW0gU2VydmljZSBmb3IgY2hhaW4gJHtjaGFpbklkfSBkb2VzIG5vdCBleGlzdGApO1xuICAgIH1cblxuICAgIC8vIGV0aGVyLmpzIFByb3ZpZGVyIGNvZXhpc3RzIHdpdGggd2ViMyBwcm92aWRlciBkdXJpbmcgbWlncmF0aW9uIGF3YXkgZnJvbSAweC93ZWIzLXdyYXBwZXIuXG4gICAgY29uc3QgZXRoZXJzUHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcihjaGFpbi5ycGNVcmwsIGNoYWluSWQpO1xuXG4gICAgY29uc3QgcnBjUHJvdmlkZXIgPSBwcm92aWRlclV0aWxzLmNyZWF0ZVdlYjNQcm92aWRlcihjaGFpbi5ycGNVcmwpO1xuICAgIGNvbnN0IHByb3ZpZGVyOiBTdXBwb3J0ZWRQcm92aWRlciA9IHJwY1Byb3ZpZGVyO1xuXG4gICAgY29uc3QgY29udHJhY3RBZGRyZXNzZXMgPSBhd2FpdCBnZXRDb250cmFjdEFkZHJlc3Nlc0Zvck5ldHdvcmtPclRocm93QXN5bmMocHJvdmlkZXIsIGNoYWluKTtcbiAgICBjb25zdCBheGlvc0luc3RhbmNlID0gQXhpb3MuY3JlYXRlKGdldEF4aW9zUmVxdWVzdENvbmZpZygpKTtcbiAgICBjb25zdCBwcm94aWVkQXhpb3NJbnN0YW5jZSA9IEF4aW9zLmNyZWF0ZShnZXRBeGlvc1JlcXVlc3RDb25maWdXaXRoUHJveHkoKSk7XG5cbiAgICBjb25zdCBiYWxhbmNlQ2hlY2tlciA9IG5ldyBCYWxhbmNlQ2hlY2tlcihwcm92aWRlcik7XG4gICAgY29uc3QgcmZxQmxvY2tjaGFpblV0aWxzID0gbmV3IFJmcUJsb2NrY2hhaW5VdGlscyhcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIGNvbnRyYWN0QWRkcmVzc2VzLmV4Y2hhbmdlUHJveHksXG4gICAgICAgIGJhbGFuY2VDaGVja2VyLFxuICAgICAgICBldGhlcnNQcm92aWRlcixcbiAgICApO1xuXG4gICAgY29uc3QgdG9rZW5NZXRhZGF0YU1hbmFnZXIgPSBuZXcgVG9rZW5NZXRhZGF0YU1hbmFnZXIoY2hhaW5JZCwgcmZxQmxvY2tjaGFpblV0aWxzKTtcblxuICAgIGNvbnN0IHNxc1Byb2R1Y2VyID0gUHJvZHVjZXIuY3JlYXRlKHtcbiAgICAgICAgcXVldWVVcmw6IGNoYWluLnNxc1VybCxcbiAgICB9KTtcblxuICAgIGNvbnN0IHF1b3RlU2VydmVyQ2xpZW50ID0gbmV3IFF1b3RlU2VydmVyQ2xpZW50KHByb3hpZWRBeGlvc0luc3RhbmNlKTtcblxuICAgIGNvbnN0IGNhY2hlQ2xpZW50ID0gbmV3IENhY2hlQ2xpZW50KHJlZGlzKTtcblxuICAgIGNvbnN0IGthZmthUHJvZHVjZXIgPSBnZXRLYWZrYVByb2R1Y2VyKCk7XG5cbiAgICBjb25zdCBnYXNTdGF0aW9uQXR0ZW5kYW50ID0gZ2V0R2FzU3RhdGlvbkF0dGVuZGFudChjaGFpbiwgYXhpb3NJbnN0YW5jZSk7XG5cbiAgICBjb25zdCBmZWVUb2tlbk1ldGFkYXRhID0gZ2V0VG9rZW5NZXRhZGF0YUlmRXhpc3RzKGNvbnRyYWN0QWRkcmVzc2VzLmV0aGVyVG9rZW4sIGNoYWluSWQpO1xuICAgIGlmIChmZWVUb2tlbk1ldGFkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGZWUgdG9rZW4gJHtjb250cmFjdEFkZHJlc3Nlcy5ldGhlclRva2VufSBvbiBjaGFpbiAke2NoYWluSWR9IGNvdWxkIG5vdCBiZSBmb3VuZCFgKTtcbiAgICB9XG5cbiAgICBjb25zdCB6ZXJvRXhBcGlDbGllbnQgPSBuZXcgWmVyb0V4QXBpQ2xpZW50KEF4aW9zLmNyZWF0ZSgpLCBaRVJPX0VYX0FQSV9LRVksIGNoYWluKTtcblxuICAgIGNvbnN0IGZlZVNlcnZpY2UgPSBuZXcgRmVlU2VydmljZShcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgZmVlVG9rZW5NZXRhZGF0YSxcbiAgICAgICAgY29uZmlnTWFuYWdlcixcbiAgICAgICAgZ2FzU3RhdGlvbkF0dGVuZGFudCxcbiAgICAgICAgdG9rZW5QcmljZU9yYWNsZSxcbiAgICAgICAgemVyb0V4QXBpQ2xpZW50LFxuICAgICAgICByZnFtQ29uZmlndXJhdGlvbi5taW5FeHBpcnlEdXJhdGlvbk1zIHx8IERFRkFVTFRfTUlOX0VYUElSWV9EVVJBVElPTl9NUyxcbiAgICApO1xuXG4gICAgY29uc3QgcmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlID0gbmV3IFJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZShcbiAgICAgICAgY2FjaGVDbGllbnQsXG4gICAgICAgIHJmcUJsb2NrY2hhaW5VdGlscy5iYWxhbmNlQ2hlY2tVdGlscyxcbiAgICApO1xuXG4gICAgcmV0dXJuIG5ldyBSZnFtU2VydmljZShcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgZmVlU2VydmljZSxcbiAgICAgICAgcmZxbUNvbmZpZ3VyYXRpb24uZmVlTW9kZWxWZXJzaW9uIHx8IDAsXG4gICAgICAgIGNvbnRyYWN0QWRkcmVzc2VzLFxuICAgICAgICBjaGFpbi5yZWdpc3RyeUFkZHJlc3MsXG4gICAgICAgIHJmcUJsb2NrY2hhaW5VdGlscyxcbiAgICAgICAgcmZxbURiVXRpbHMsXG4gICAgICAgIHNxc1Byb2R1Y2VyLFxuICAgICAgICBxdW90ZVNlcnZlckNsaWVudCxcbiAgICAgICAgcmZxbUNvbmZpZ3VyYXRpb24ubWluRXhwaXJ5RHVyYXRpb25NcyB8fCBERUZBVUxUX01JTl9FWFBJUllfRFVSQVRJT05fTVMsXG4gICAgICAgIGNhY2hlQ2xpZW50LFxuICAgICAgICByZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UsXG4gICAgICAgIHJmcU1ha2VyTWFuYWdlcixcbiAgICAgICAgdG9rZW5NZXRhZGF0YU1hbmFnZXIsXG4gICAgICAgIGthZmthUHJvZHVjZXIsXG4gICAgICAgIHJmcW1Db25maWd1cmF0aW9uLnF1b3RlUmVwb3J0VG9waWMsXG4gICAgKTtcbn1cblxuLyoqXG4gKiBCdWlsZHMgYSBzaW5nbGUgaW5zdGFuY2Ugb2YgdGhlIFdvcmtlclNlcnZpY2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJ1aWxkV29ya2VyU2VydmljZUFzeW5jKFxuICAgIHJmcW1EYlV0aWxzOiBSZnFtRGJVdGlscyxcbiAgICByZnFNYWtlck1hbmFnZXI6IFJmcU1ha2VyTWFuYWdlcixcbiAgICBjaGFpbjogQ2hhaW5Db25maWd1cmF0aW9uLFxuICAgIHJlZGlzOiBSZWRpcyxcbiAgICB3b3JrZXJJbmRleDogbnVtYmVyLFxuKTogUHJvbWlzZTxXb3JrZXJTZXJ2aWNlPiB7XG4gICAgY29uc3QgeyB3b3JrZXI6IHdvcmtlckNvbmZpZ3VyYXRpb24sIGNoYWluSWQgfSA9IGNoYWluO1xuICAgIGlmICghd29ya2VyQ29uZmlndXJhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdvcmtlciBTZXJ2aWNlIGZvciBjaGFpbiAke2NoYWluSWR9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgfVxuXG4gICAgbGV0IHByb3ZpZGVyOiBTdXBwb3J0ZWRQcm92aWRlcjtcblxuICAgIC8vIGV0aGVyLmpzIFByb3ZpZGVyIGNvZXhpc3RzIHdpdGggd2ViMyBwcm92aWRlciBkdXJpbmcgbWlncmF0aW9uIGF3YXkgZnJvbSAweC93ZWIzLXdyYXBwZXIuXG4gICAgY29uc3QgZXRoZXJzUHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcihjaGFpbi5ycGNVcmwsIGNoYWluSWQpO1xuICAgIGxldCBldGhlcnNXYWxsZXQ6IFdhbGxldCB8IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IHJwY1Byb3ZpZGVyID0gcHJvdmlkZXJVdGlscy5jcmVhdGVXZWIzUHJvdmlkZXIoY2hhaW4ucnBjVXJsKTtcbiAgICBpZiAoTUVUQV9UWF9XT1JLRVJfTU5FTU9OSUMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1FVEFfVFhfV09SS0VSX01ORU1PTklDIG11c3QgYmUgZGVmaW5lZCB0byBydW4gUkZRTSBzZXJ2aWNlIGFzIGEgd29ya2VyYCk7XG4gICAgfVxuICAgIGNvbnN0IHdvcmtlclByaXZhdGVLZXkgPSBSZnFCbG9ja2NoYWluVXRpbHMuZ2V0UHJpdmF0ZUtleUZyb21JbmRleEFuZFBocmFzZShNRVRBX1RYX1dPUktFUl9NTkVNT05JQywgd29ya2VySW5kZXgpO1xuXG4gICAgLy8gVE9ETyAocmhpbm9kYXZpZCk6IFJlbW92ZSBvbmNlIG1pZ3JhdGlvbiB0byBldGhlcnMuanMgaXMgY29tcGxldGVcbiAgICBjb25zdCBwcml2YXRlV2FsbGV0U3VicHJvdmlkZXIgPSBuZXcgUHJpdmF0ZUtleVdhbGxldFN1YnByb3ZpZGVyKHdvcmtlclByaXZhdGVLZXkpO1xuICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgcHJvdmlkZXIgPSBSZnFCbG9ja2NoYWluVXRpbHMuY3JlYXRlUHJpdmF0ZUtleVByb3ZpZGVyKHJwY1Byb3ZpZGVyLCBwcml2YXRlV2FsbGV0U3VicHJvdmlkZXIpO1xuXG4gICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgZXRoZXJzV2FsbGV0ID0gV2FsbGV0LmZyb21NbmVtb25pYyhNRVRBX1RYX1dPUktFUl9NTkVNT05JQywgYG0vNDQnLzYwJy8wJy8wLyR7d29ya2VySW5kZXghfWApO1xuICAgIGV0aGVyc1dhbGxldCA9IGV0aGVyc1dhbGxldC5jb25uZWN0KGV0aGVyc1Byb3ZpZGVyKTtcblxuICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzc2VzID0gYXdhaXQgZ2V0Q29udHJhY3RBZGRyZXNzZXNGb3JOZXR3b3JrT3JUaHJvd0FzeW5jKHByb3ZpZGVyLCBjaGFpbik7XG4gICAgY29uc3QgYXhpb3NJbnN0YW5jZSA9IEF4aW9zLmNyZWF0ZShnZXRBeGlvc1JlcXVlc3RDb25maWdXaXRoUHJveHkoKSk7XG5cbiAgICBjb25zdCBiYWxhbmNlQ2hlY2tlciA9IG5ldyBCYWxhbmNlQ2hlY2tlcihwcm92aWRlcik7XG4gICAgY29uc3QgcmZxQmxvY2tjaGFpblV0aWxzID0gbmV3IFJmcUJsb2NrY2hhaW5VdGlscyhcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIGNvbnRyYWN0QWRkcmVzc2VzLmV4Y2hhbmdlUHJveHksXG4gICAgICAgIGJhbGFuY2VDaGVja2VyLFxuICAgICAgICBldGhlcnNQcm92aWRlcixcbiAgICAgICAgZXRoZXJzV2FsbGV0LFxuICAgICk7XG5cbiAgICBjb25zdCBxdW90ZVNlcnZlckNsaWVudCA9IG5ldyBRdW90ZVNlcnZlckNsaWVudChheGlvc0luc3RhbmNlKTtcblxuICAgIGNvbnN0IGNhY2hlQ2xpZW50ID0gbmV3IENhY2hlQ2xpZW50KHJlZGlzKTtcblxuICAgIGNvbnN0IGdhc1N0YXRpb25BdHRlbmRhbnQgPSBnZXRHYXNTdGF0aW9uQXR0ZW5kYW50KGNoYWluLCBheGlvc0luc3RhbmNlKTtcblxuICAgIGNvbnN0IGZlZVRva2VuTWV0YWRhdGEgPSBnZXRUb2tlbk1ldGFkYXRhSWZFeGlzdHMoY29udHJhY3RBZGRyZXNzZXMuZXRoZXJUb2tlbiwgY2hhaW5JZCk7XG4gICAgaWYgKGZlZVRva2VuTWV0YWRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZlZSB0b2tlbiAke2NvbnRyYWN0QWRkcmVzc2VzLmV0aGVyVG9rZW59IG9uIGNoYWluICR7Y2hhaW5JZH0gY291bGQgbm90IGJlIGZvdW5kIWApO1xuICAgIH1cblxuICAgIGNvbnN0IHJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSA9IG5ldyBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UoXG4gICAgICAgIGNhY2hlQ2xpZW50LFxuICAgICAgICByZnFCbG9ja2NoYWluVXRpbHMuYmFsYW5jZUNoZWNrVXRpbHMsXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgV29ya2VyU2VydmljZShcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgZ2FzU3RhdGlvbkF0dGVuZGFudCxcbiAgICAgICAgY2hhaW4ucmVnaXN0cnlBZGRyZXNzLFxuICAgICAgICByZnFCbG9ja2NoYWluVXRpbHMsXG4gICAgICAgIHJmcW1EYlV0aWxzLFxuICAgICAgICBxdW90ZVNlcnZlckNsaWVudCxcbiAgICAgICAgd29ya2VyQ29uZmlndXJhdGlvbi50cmFuc2FjdGlvbldhdGNoZXJTbGVlcFRpbWVNcyB8fCBERUZBVUxUX1dPUktFUl9UUkFOU0FDVElPTl9XQVRDSEVSX1NMRUVQX1RJTUVfTVMsXG4gICAgICAgIGNhY2hlQ2xpZW50LFxuICAgICAgICByZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UsXG4gICAgICAgIHJmcU1ha2VyTWFuYWdlcixcbiAgICAgICAgd29ya2VyQ29uZmlndXJhdGlvbi5pbml0aWFsTWF4UHJpb3JpdHlGZWVQZXJHYXNHd2VpLFxuICAgICAgICB3b3JrZXJDb25maWd1cmF0aW9uLm1heEZlZVBlckdhc0NhcEd3ZWksXG4gICAgICAgIHdvcmtlckNvbmZpZ3VyYXRpb24uZW5hYmxlQWNjZXNzTGlzdCxcbiAgICApO1xufVxuXG4vKipcbiAqIEJ1aWxkcyBhbiBpbnN0YW5jZSBvZiBtYWtlciBiYWxhbmNlIGNhY2hlIHNlcnZpY2UuXG4gKiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IG1ha2VyIGJhbGFuY2UgY2FjaGUgYmFja2dyb3VuZCBqb2JzLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGRSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2VBc3luYyhcbiAgICBjaGFpbjogQ2hhaW5Db25maWd1cmF0aW9uLFxuKTogUHJvbWlzZTxSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2U+IHtcbiAgICBjb25zdCBwcm92aWRlciA9IHByb3ZpZGVyVXRpbHMuY3JlYXRlV2ViM1Byb3ZpZGVyKGNoYWluLnJwY1VybCk7XG4gICAgY29uc3QgY29udHJhY3RBZGRyZXNzZXMgPSBhd2FpdCBnZXRDb250cmFjdEFkZHJlc3Nlc0Zvck5ldHdvcmtPclRocm93QXN5bmMocHJvdmlkZXIsIGNoYWluKTtcbiAgICBjb25zdCBiYWxhbmNlQ2hlY2tlciA9IG5ldyBCYWxhbmNlQ2hlY2tlcihwcm92aWRlcik7XG4gICAgY29uc3QgYmFsYW5jZUNoZWNrVXRpbHMgPSBuZXcgUmZxQmFsYW5jZUNoZWNrVXRpbHMoYmFsYW5jZUNoZWNrZXIsIGNvbnRyYWN0QWRkcmVzc2VzLmV4Y2hhbmdlUHJveHkpO1xuXG4gICAgaWYgKCFSRURJU19VUkkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZWRpcyBVUkkgcHJvdmlkZWQgdG8gbWFrZXIgYmFsYW5jZSBjYWNoZSBzZXJ2aWNlJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlzID0gbmV3IFJlZGlzKFJFRElTX1VSSSk7XG4gICAgY29uc3QgY2FjaGVDbGllbnQgPSBuZXcgQ2FjaGVDbGllbnQocmVkaXMpO1xuXG4gICAgcmV0dXJuIG5ldyBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UoY2FjaGVDbGllbnQsIGJhbGFuY2VDaGVja1V0aWxzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJGUU0gU2VydmljZSBmb3IgZWFjaCBjaGFpbiBwcmVzZW50IGluIGBDaGFpbkNvbmZpZ3VyYXRpb25zYC5cbiAqXG4gKiBJbnRlbmRlZCBmb3IgdXNlIGJ5IHRoZSB0b3AtbGV2ZWwgcnVubmVycy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJ1aWxkUmZxbVNlcnZpY2VzQXN5bmMoXG4gICAgYXNXb3JrZXI6IGJvb2xlYW4sXG4gICAgcmZxbURiVXRpbHM6IFJmcW1EYlV0aWxzLFxuICAgIHJmcU1ha2VyRGJVdGlsczogUmZxTWFrZXJEYlV0aWxzLFxuICAgIGNoYWluQ29uZmlndXJhdGlvbnM6IENoYWluQ29uZmlndXJhdGlvbnMsXG4gICAgdG9rZW5QcmljZU9yYWNsZTogVG9rZW5QcmljZU9yYWNsZSxcbiAgICBjb25maWdNYW5hZ2VyOiBDb25maWdNYW5hZ2VyID0gbmV3IENvbmZpZ01hbmFnZXIoKSxcbiAgICByZWRpczogUmVkaXMsXG4gICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8taW5mZXJyYWJsZS10eXBlc1xuICAgIF93b3JrZXJJbmRleDogbnVtYmVyID0gMCxcbik6IFByb21pc2U8UmZxbVNlcnZpY2VzPiB7XG4gICAgY29uc3Qgc2VydmljZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgY2hhaW5Db25maWd1cmF0aW9ucy5tYXAoYXN5bmMgKGNoYWluKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZnFNYWtlck1hbmFnZXIgPSBuZXcgUmZxTWFrZXJNYW5hZ2VyKGNvbmZpZ01hbmFnZXIsIHJmcU1ha2VyRGJVdGlscywgY2hhaW4uY2hhaW5JZCk7XG4gICAgICAgICAgICBhd2FpdCByZnFNYWtlck1hbmFnZXIuaW5pdGlhbGl6ZUFzeW5jKCk7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRSZnFtU2VydmljZUFzeW5jKHJmcW1EYlV0aWxzLCByZnFNYWtlck1hbmFnZXIsIHRva2VuUHJpY2VPcmFjbGUsIGNvbmZpZ01hbmFnZXIsIGNoYWluLCByZWRpcyk7XG4gICAgICAgIH0pLFxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBNYXAoc2VydmljZXMubWFwKChzLCBpKSA9PiBbY2hhaW5Db25maWd1cmF0aW9uc1tpXS5jaGFpbklkLCBzXSkpO1xufVxuIl0sInZlcnNpb24iOjN9