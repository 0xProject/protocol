706931c7dcbbe959ca77a1808dab0c2e
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serviceUtils = void 0;
const utils_1 = require("@0x/utils");
const config_1 = require("../config");
const constants_1 = require("../core/constants");
const number_utils_1 = require("./number_utils");
exports.serviceUtils = {
    attributeCallData(data, affiliateAddress) {
        const affiliateAddressOrDefault = affiliateAddress ? affiliateAddress : config_1.FEE_RECIPIENT_ADDRESS;
        const affiliateCallDataEncoder = new utils_1.AbiEncoder.Method({
            constant: true,
            outputs: [],
            name: 'ZeroExAPIAffiliate',
            inputs: [
                { name: 'affiliate', type: 'address' },
                { name: 'timestamp', type: 'uint256' },
            ],
            payable: false,
            stateMutability: 'view',
            type: 'function',
        });
        // Generate unique identiifer
        const timestampInSeconds = new utils_1.BigNumber(Date.now() / constants_1.ONE_SECOND_MS).integerValue();
        const hexTimestamp = timestampInSeconds.toString(constants_1.HEX_BASE);
        const randomNumber = number_utils_1.numberUtils.randomHexNumberOfLength(10);
        // Concatenate the hex identifier with the hex timestamp
        // In the final encoded call data, this will leave us with a 5-byte ID followed by
        // a 4-byte timestamp, and won't break parsers of the timestamp made prior to the
        // addition of the ID
        const uniqueIdentifier = new utils_1.BigNumber(`${randomNumber}${hexTimestamp}`, constants_1.HEX_BASE);
        // Encode additional call data and return
        const encodedAffiliateData = affiliateCallDataEncoder.encode([affiliateAddressOrDefault, uniqueIdentifier]);
        const affiliatedData = `${data}${encodedAffiliateData.slice(2)}`;
        return { affiliatedData, decodedUniqueId: `${randomNumber}-${timestampInSeconds}` };
    },
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy91dGlscy9zZXJ2aWNlX3V0aWxzLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUFrRDtBQUVsRCxzQ0FBa0Q7QUFDbEQsaURBQTREO0FBRTVELGlEQUE2QztBQUVoQyxRQUFBLFlBQVksR0FBRztJQUN4QixpQkFBaUIsQ0FDYixJQUFZLEVBQ1osZ0JBQStCO1FBSy9CLE1BQU0seUJBQXlCLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyw4QkFBcUIsQ0FBQztRQUM5RixNQUFNLHdCQUF3QixHQUFHLElBQUksa0JBQVUsQ0FBQyxNQUFNLENBQUM7WUFDbkQsUUFBUSxFQUFFLElBQUk7WUFDZCxPQUFPLEVBQUUsRUFBRTtZQUNYLElBQUksRUFBRSxvQkFBb0I7WUFDMUIsTUFBTSxFQUFFO2dCQUNKLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFO2dCQUN0QyxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTthQUN6QztZQUNELE9BQU8sRUFBRSxLQUFLO1lBQ2QsZUFBZSxFQUFFLE1BQU07WUFDdkIsSUFBSSxFQUFFLFVBQVU7U0FDbkIsQ0FBQyxDQUFDO1FBRUgsNkJBQTZCO1FBQzdCLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxpQkFBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyx5QkFBYSxDQUFDLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDcEYsTUFBTSxZQUFZLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxDQUFDLG9CQUFRLENBQUMsQ0FBQztRQUMzRCxNQUFNLFlBQVksR0FBRywwQkFBVyxDQUFDLHVCQUF1QixDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRTdELHdEQUF3RDtRQUN4RCxrRkFBa0Y7UUFDbEYsaUZBQWlGO1FBQ2pGLHFCQUFxQjtRQUNyQixNQUFNLGdCQUFnQixHQUFHLElBQUksaUJBQVMsQ0FBQyxHQUFHLFlBQVksR0FBRyxZQUFZLEVBQUUsRUFBRSxvQkFBUSxDQUFDLENBQUM7UUFFbkYseUNBQXlDO1FBQ3pDLE1BQU0sb0JBQW9CLEdBQUcsd0JBQXdCLENBQUMsTUFBTSxDQUFDLENBQUMseUJBQXlCLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1FBQzVHLE1BQU0sY0FBYyxHQUFHLEdBQUcsSUFBSSxHQUFHLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ2pFLE9BQU8sRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLEdBQUcsWUFBWSxJQUFJLGtCQUFrQixFQUFFLEVBQUUsQ0FBQztJQUN4RixDQUFDO0NBQ0osQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvZGF2aWR3YWxzaC9jb2RlLWxvY2FsLzB4LXJmcS1hcGkvc3JjL3V0aWxzL3NlcnZpY2VfdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWJpRW5jb2RlciwgQmlnTnVtYmVyIH0gZnJvbSAnQDB4L3V0aWxzJztcclxuXHJcbmltcG9ydCB7IEZFRV9SRUNJUElFTlRfQUREUkVTUyB9IGZyb20gJy4uL2NvbmZpZyc7XHJcbmltcG9ydCB7IEhFWF9CQVNFLCBPTkVfU0VDT05EX01TIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMnO1xyXG5cclxuaW1wb3J0IHsgbnVtYmVyVXRpbHMgfSBmcm9tICcuL251bWJlcl91dGlscyc7XHJcblxyXG5leHBvcnQgY29uc3Qgc2VydmljZVV0aWxzID0ge1xyXG4gICAgYXR0cmlidXRlQ2FsbERhdGEoXHJcbiAgICAgICAgZGF0YTogc3RyaW5nLFxyXG4gICAgICAgIGFmZmlsaWF0ZUFkZHJlc3M6IHN0cmluZyB8IG51bGwsXHJcbiAgICApOiB7XHJcbiAgICAgICAgYWZmaWxpYXRlZERhdGE6IHN0cmluZztcclxuICAgICAgICBkZWNvZGVkVW5pcXVlSWQ6IHN0cmluZztcclxuICAgIH0ge1xyXG4gICAgICAgIGNvbnN0IGFmZmlsaWF0ZUFkZHJlc3NPckRlZmF1bHQgPSBhZmZpbGlhdGVBZGRyZXNzID8gYWZmaWxpYXRlQWRkcmVzcyA6IEZFRV9SRUNJUElFTlRfQUREUkVTUztcclxuICAgICAgICBjb25zdCBhZmZpbGlhdGVDYWxsRGF0YUVuY29kZXIgPSBuZXcgQWJpRW5jb2Rlci5NZXRob2Qoe1xyXG4gICAgICAgICAgICBjb25zdGFudDogdHJ1ZSxcclxuICAgICAgICAgICAgb3V0cHV0czogW10sXHJcbiAgICAgICAgICAgIG5hbWU6ICdaZXJvRXhBUElBZmZpbGlhdGUnLFxyXG4gICAgICAgICAgICBpbnB1dHM6IFtcclxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2FmZmlsaWF0ZScsIHR5cGU6ICdhZGRyZXNzJyB9LFxyXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAndGltZXN0YW1wJywgdHlwZTogJ3VpbnQyNTYnIH0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHBheWFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcclxuICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gR2VuZXJhdGUgdW5pcXVlIGlkZW50aWlmZXJcclxuICAgICAgICBjb25zdCB0aW1lc3RhbXBJblNlY29uZHMgPSBuZXcgQmlnTnVtYmVyKERhdGUubm93KCkgLyBPTkVfU0VDT05EX01TKS5pbnRlZ2VyVmFsdWUoKTtcclxuICAgICAgICBjb25zdCBoZXhUaW1lc3RhbXAgPSB0aW1lc3RhbXBJblNlY29uZHMudG9TdHJpbmcoSEVYX0JBU0UpO1xyXG4gICAgICAgIGNvbnN0IHJhbmRvbU51bWJlciA9IG51bWJlclV0aWxzLnJhbmRvbUhleE51bWJlck9mTGVuZ3RoKDEwKTtcclxuXHJcbiAgICAgICAgLy8gQ29uY2F0ZW5hdGUgdGhlIGhleCBpZGVudGlmaWVyIHdpdGggdGhlIGhleCB0aW1lc3RhbXBcclxuICAgICAgICAvLyBJbiB0aGUgZmluYWwgZW5jb2RlZCBjYWxsIGRhdGEsIHRoaXMgd2lsbCBsZWF2ZSB1cyB3aXRoIGEgNS1ieXRlIElEIGZvbGxvd2VkIGJ5XHJcbiAgICAgICAgLy8gYSA0LWJ5dGUgdGltZXN0YW1wLCBhbmQgd29uJ3QgYnJlYWsgcGFyc2VycyBvZiB0aGUgdGltZXN0YW1wIG1hZGUgcHJpb3IgdG8gdGhlXHJcbiAgICAgICAgLy8gYWRkaXRpb24gb2YgdGhlIElEXHJcbiAgICAgICAgY29uc3QgdW5pcXVlSWRlbnRpZmllciA9IG5ldyBCaWdOdW1iZXIoYCR7cmFuZG9tTnVtYmVyfSR7aGV4VGltZXN0YW1wfWAsIEhFWF9CQVNFKTtcclxuXHJcbiAgICAgICAgLy8gRW5jb2RlIGFkZGl0aW9uYWwgY2FsbCBkYXRhIGFuZCByZXR1cm5cclxuICAgICAgICBjb25zdCBlbmNvZGVkQWZmaWxpYXRlRGF0YSA9IGFmZmlsaWF0ZUNhbGxEYXRhRW5jb2Rlci5lbmNvZGUoW2FmZmlsaWF0ZUFkZHJlc3NPckRlZmF1bHQsIHVuaXF1ZUlkZW50aWZpZXJdKTtcclxuICAgICAgICBjb25zdCBhZmZpbGlhdGVkRGF0YSA9IGAke2RhdGF9JHtlbmNvZGVkQWZmaWxpYXRlRGF0YS5zbGljZSgyKX1gO1xyXG4gICAgICAgIHJldHVybiB7IGFmZmlsaWF0ZWREYXRhLCBkZWNvZGVkVW5pcXVlSWQ6IGAke3JhbmRvbU51bWJlcn0tJHt0aW1lc3RhbXBJblNlY29uZHN9YCB9O1xyXG4gICAgfSxcclxufTtcclxuIl0sInZlcnNpb24iOjN9