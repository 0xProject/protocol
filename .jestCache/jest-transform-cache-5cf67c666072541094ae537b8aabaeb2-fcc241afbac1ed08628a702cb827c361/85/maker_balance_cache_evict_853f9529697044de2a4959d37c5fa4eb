e1a08a0f24f13a246e3c5415a7073a75
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const prom_client_1 = require("prom-client");
const config_1 = require("../config");
const logger_1 = require("../logger");
const rfqm_service_builder_1 = require("../utils/rfqm_service_builder");
const QUEUE_NAME = 'maker-balance-cache-evict';
// keep successful job history for 1 day
const REMOVE_ON_COMPLETE_OPS = {
    count: 24 * 60 * 0.5,
};
// keep failed job history for 3 days
const REMOVE_ON_FAILURE_OPS = {
    count: 3 * 24 * 60 * 0.5,
};
const MAKER_BALANCE_CACHE_EVICT_SCHEDULE = '*/2 * * * *'; // job will be scheduled at every 2 minutes
const DESCRIPTION = 'Periodically evicts stale entries from maker balance cache.';
const backgroundJobMBCEvict = {
    queueName: QUEUE_NAME,
    schedule: MAKER_BALANCE_CACHE_EVICT_SCHEDULE,
    description: DESCRIPTION,
    createAsync,
    processAsync,
};
// tslint:disable-next-line: no-default-export
exports.default = backgroundJobMBCEvict;
const MAKER_BALANCE_CACHE_EVICT_PROCESS_COUNT = new prom_client_1.Counter({
    name: 'rfq_background_job_mbc_evict_process_total',
    help: 'Number of times the processor method of the maker balance cache evict background job is triggered',
});
/**
 * Creates a background job by queues a message that performs an eviction on the maker balance cache.
 *
 * @param queue Queue to push the message.
 * @param data Necessary data for processor to execute the background job.
 * @returns Promise of the background job.
 */
async function createAsync(queue, data) {
    logger_1.logger.info({ queue: QUEUE_NAME, data }, 'Creating the maker balance cache background job on queue');
    return queue.add(`${QUEUE_NAME}.${data.timestamp}`, data, {
        removeOnComplete: REMOVE_ON_COMPLETE_OPS,
        removeOnFail: REMOVE_ON_FAILURE_OPS,
    });
}
/**
 * Processor method for the maker balance cache evict job. Evicts entries with zero balances from the cache.
 *
 * @param job Maker balance cache evict background job.
 * @returns Result of the evict background job.
 */
async function processAsync(job) {
    await job.updateProgress(0);
    logger_1.logger.info({ jobName: job.name, queue: job.queueName, data: job.data, timestamp: Date.now() }, 'Processing the maker balance cache evict background job on queue');
    const chainId = job.data.chainId;
    // Build dependencies
    const chain = config_1.CHAIN_CONFIGURATIONS.find((c) => c.chainId === chainId);
    if (!chain) {
        throw new Error(`Tried to start background job process for chain ${chainId}
        but no chain configuration was present`);
    }
    const rfqMakerBalanceCacheService = await (0, rfqm_service_builder_1.buildRfqMakerBalanceCacheServiceAsync)(chain);
    if (!rfqMakerBalanceCacheService) {
        logger_1.logger.error({ jobName: job.name, queue: job.queueName, data: job.data, timestamp: Date.now() }, 'Failed to initialize dependencies for maker-balance-cache-evict');
        throw new Error('Failed to initialize dependencies for maker-balance-cache-evict');
    }
    await job.updateProgress(50);
    // Perform eviction on maker balance cache entries
    let numEvicted;
    try {
        numEvicted = await rfqMakerBalanceCacheService.evictZeroBalancesAsync(chainId);
        MAKER_BALANCE_CACHE_EVICT_PROCESS_COUNT.inc();
    }
    catch (error) {
        logger_1.logger.error({ jobName: job.name, queue: job.queueName, data: job.data, timestamp: Date.now() }, 'Failed to evict maker balance cache while running scheduled background job');
        throw new Error('Failed to evict maker balance cache while running scheduled background job');
    }
    finally {
        await rfqMakerBalanceCacheService.closeAsync();
    }
    await job.updateProgress(100);
    return {
        chainId,
        jobName: job.name,
        numEvicted,
        timestamp: Date.now(),
    };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9iYWNrZ3JvdW5kLWpvYnMvbWFrZXJfYmFsYW5jZV9jYWNoZV9ldmljdC50cyIsIm1hcHBpbmdzIjoiOztBQUVBLDZDQUFzQztBQUV0QyxzQ0FBaUQ7QUFDakQsc0NBQW1DO0FBQ25DLHdFQUFzRjtBQUl0RixNQUFNLFVBQVUsR0FBRywyQkFBMkIsQ0FBQztBQUMvQyx3Q0FBd0M7QUFDeEMsTUFBTSxzQkFBc0IsR0FBRztJQUMzQixLQUFLLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFHO0NBQ3ZCLENBQUM7QUFDRixxQ0FBcUM7QUFDckMsTUFBTSxxQkFBcUIsR0FBRztJQUMxQixLQUFLLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRztDQUMzQixDQUFDO0FBQ0YsTUFBTSxrQ0FBa0MsR0FBRyxhQUFhLENBQUMsQ0FBQywyQ0FBMkM7QUFDckcsTUFBTSxXQUFXLEdBQUcsNkRBQTZELENBQUM7QUFjbEYsTUFBTSxxQkFBcUIsR0FBbUY7SUFDMUcsU0FBUyxFQUFFLFVBQVU7SUFDckIsUUFBUSxFQUFFLGtDQUFrQztJQUM1QyxXQUFXLEVBQUUsV0FBVztJQUN4QixXQUFXO0lBQ1gsWUFBWTtDQUNmLENBQUM7QUFDRiw4Q0FBOEM7QUFDOUMsa0JBQWUscUJBQXFCLENBQUM7QUFFckMsTUFBTSx1Q0FBdUMsR0FBRyxJQUFJLHFCQUFPLENBQUM7SUFDeEQsSUFBSSxFQUFFLDRDQUE0QztJQUNsRCxJQUFJLEVBQUUsbUdBQW1HO0NBQzVHLENBQUMsQ0FBQztBQUVIOzs7Ozs7R0FNRztBQUNILEtBQUssVUFBVSxXQUFXLENBQ3RCLEtBQVksRUFDWixJQUErQjtJQUUvQixlQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsRUFBRSwwREFBMEQsQ0FBQyxDQUFDO0lBQ3JHLE9BQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFVBQVUsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUUsSUFBSSxFQUFFO1FBQ3RELGdCQUFnQixFQUFFLHNCQUFzQjtRQUN4QyxZQUFZLEVBQUUscUJBQXFCO0tBQ3RDLENBQUMsQ0FBQztBQUNQLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILEtBQUssVUFBVSxZQUFZLENBQ3ZCLEdBQWdFO0lBRWhFLE1BQU0sR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QixlQUFNLENBQUMsSUFBSSxDQUNQLEVBQUUsT0FBTyxFQUFFLEdBQUcsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUNsRixrRUFBa0UsQ0FDckUsQ0FBQztJQUVGLE1BQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBRWpDLHFCQUFxQjtJQUNyQixNQUFNLEtBQUssR0FBRyw2QkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLEtBQUssT0FBTyxDQUFDLENBQUM7SUFDdEUsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNSLE1BQU0sSUFBSSxLQUFLLENBQUMsbURBQW1ELE9BQU87K0NBQ25DLENBQUMsQ0FBQztLQUM1QztJQUNELE1BQU0sMkJBQTJCLEdBQUcsTUFBTSxJQUFBLDREQUFxQyxFQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZGLElBQUksQ0FBQywyQkFBMkIsRUFBRTtRQUM5QixlQUFNLENBQUMsS0FBSyxDQUNSLEVBQUUsT0FBTyxFQUFFLEdBQUcsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUNsRixpRUFBaUUsQ0FDcEUsQ0FBQztRQUNGLE1BQU0sSUFBSSxLQUFLLENBQUMsaUVBQWlFLENBQUMsQ0FBQztLQUN0RjtJQUNELE1BQU0sR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUU3QixrREFBa0Q7SUFDbEQsSUFBSSxVQUFVLENBQUM7SUFDZixJQUFJO1FBQ0EsVUFBVSxHQUFHLE1BQU0sMkJBQTJCLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDL0UsdUNBQXVDLENBQUMsR0FBRyxFQUFFLENBQUM7S0FDakQ7SUFBQyxPQUFPLEtBQUssRUFBRTtRQUNaLGVBQU0sQ0FBQyxLQUFLLENBQ1IsRUFBRSxPQUFPLEVBQUUsR0FBRyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxDQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsR0FBRyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQ2xGLDRFQUE0RSxDQUMvRSxDQUFDO1FBQ0YsTUFBTSxJQUFJLEtBQUssQ0FBQyw0RUFBNEUsQ0FBQyxDQUFDO0tBQ2pHO1lBQVM7UUFDTixNQUFNLDJCQUEyQixDQUFDLFVBQVUsRUFBRSxDQUFDO0tBQ2xEO0lBRUQsTUFBTSxHQUFHLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzlCLE9BQU87UUFDSCxPQUFPO1FBQ1AsT0FBTyxFQUFFLEdBQUcsQ0FBQyxJQUFJO1FBQ2pCLFVBQVU7UUFDVixTQUFTLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRTtLQUN4QixDQUFDO0FBQ04sQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvZGF2aWR3YWxzaC9jb2RlLWxvY2FsLzB4LXJmcS1hcGkvc3JjL2JhY2tncm91bmQtam9icy9tYWtlcl9iYWxhbmNlX2NhY2hlX2V2aWN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRzbGludDpkaXNhYmxlOmN1c3RvbS1uby1tYWdpYy1udW1iZXJzXG5pbXBvcnQgeyBKb2IsIFF1ZXVlIH0gZnJvbSAnYnVsbG1xJztcbmltcG9ydCB7IENvdW50ZXIgfSBmcm9tICdwcm9tLWNsaWVudCc7XG5cbmltcG9ydCB7IENIQUlOX0NPTkZJR1VSQVRJT05TIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBidWlsZFJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZUFzeW5jIH0gZnJvbSAnLi4vdXRpbHMvcmZxbV9zZXJ2aWNlX2J1aWxkZXInO1xuXG5pbXBvcnQgeyBCYWNrZ3JvdW5kSm9iQmx1ZXByaW50IH0gZnJvbSAnLi9ibHVlcHJpbnQnO1xuXG5jb25zdCBRVUVVRV9OQU1FID0gJ21ha2VyLWJhbGFuY2UtY2FjaGUtZXZpY3QnO1xuLy8ga2VlcCBzdWNjZXNzZnVsIGpvYiBoaXN0b3J5IGZvciAxIGRheVxuY29uc3QgUkVNT1ZFX09OX0NPTVBMRVRFX09QUyA9IHtcbiAgICBjb3VudDogMjQgKiA2MCAqIDAuNSxcbn07XG4vLyBrZWVwIGZhaWxlZCBqb2IgaGlzdG9yeSBmb3IgMyBkYXlzXG5jb25zdCBSRU1PVkVfT05fRkFJTFVSRV9PUFMgPSB7XG4gICAgY291bnQ6IDMgKiAyNCAqIDYwICogMC41LFxufTtcbmNvbnN0IE1BS0VSX0JBTEFOQ0VfQ0FDSEVfRVZJQ1RfU0NIRURVTEUgPSAnKi8yICogKiAqIConOyAvLyBqb2Igd2lsbCBiZSBzY2hlZHVsZWQgYXQgZXZlcnkgMiBtaW51dGVzXG5jb25zdCBERVNDUklQVElPTiA9ICdQZXJpb2RpY2FsbHkgZXZpY3RzIHN0YWxlIGVudHJpZXMgZnJvbSBtYWtlciBiYWxhbmNlIGNhY2hlLic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2dyb3VuZEpvYk1CQ0V2aWN0RGF0YSB7XG4gICAgY2hhaW5JZDogbnVtYmVyO1xuICAgIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tncm91bmRKb2JNQkNFdmljdFJlc3VsdCB7XG4gICAgY2hhaW5JZDogbnVtYmVyO1xuICAgIGpvYk5hbWU6IHN0cmluZztcbiAgICBudW1FdmljdGVkOiBudW1iZXI7XG4gICAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmNvbnN0IGJhY2tncm91bmRKb2JNQkNFdmljdDogQmFja2dyb3VuZEpvYkJsdWVwcmludDxCYWNrZ3JvdW5kSm9iTUJDRXZpY3REYXRhLCBCYWNrZ3JvdW5kSm9iTUJDRXZpY3RSZXN1bHQ+ID0ge1xuICAgIHF1ZXVlTmFtZTogUVVFVUVfTkFNRSxcbiAgICBzY2hlZHVsZTogTUFLRVJfQkFMQU5DRV9DQUNIRV9FVklDVF9TQ0hFRFVMRSxcbiAgICBkZXNjcmlwdGlvbjogREVTQ1JJUFRJT04sXG4gICAgY3JlYXRlQXN5bmMsXG4gICAgcHJvY2Vzc0FzeW5jLFxufTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tZGVmYXVsdC1leHBvcnRcbmV4cG9ydCBkZWZhdWx0IGJhY2tncm91bmRKb2JNQkNFdmljdDtcblxuY29uc3QgTUFLRVJfQkFMQU5DRV9DQUNIRV9FVklDVF9QUk9DRVNTX0NPVU5UID0gbmV3IENvdW50ZXIoe1xuICAgIG5hbWU6ICdyZnFfYmFja2dyb3VuZF9qb2JfbWJjX2V2aWN0X3Byb2Nlc3NfdG90YWwnLFxuICAgIGhlbHA6ICdOdW1iZXIgb2YgdGltZXMgdGhlIHByb2Nlc3NvciBtZXRob2Qgb2YgdGhlIG1ha2VyIGJhbGFuY2UgY2FjaGUgZXZpY3QgYmFja2dyb3VuZCBqb2IgaXMgdHJpZ2dlcmVkJyxcbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBiYWNrZ3JvdW5kIGpvYiBieSBxdWV1ZXMgYSBtZXNzYWdlIHRoYXQgcGVyZm9ybXMgYW4gZXZpY3Rpb24gb24gdGhlIG1ha2VyIGJhbGFuY2UgY2FjaGUuXG4gKlxuICogQHBhcmFtIHF1ZXVlIFF1ZXVlIHRvIHB1c2ggdGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0gZGF0YSBOZWNlc3NhcnkgZGF0YSBmb3IgcHJvY2Vzc29yIHRvIGV4ZWN1dGUgdGhlIGJhY2tncm91bmQgam9iLlxuICogQHJldHVybnMgUHJvbWlzZSBvZiB0aGUgYmFja2dyb3VuZCBqb2IuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jKFxuICAgIHF1ZXVlOiBRdWV1ZSxcbiAgICBkYXRhOiBCYWNrZ3JvdW5kSm9iTUJDRXZpY3REYXRhLFxuKTogUHJvbWlzZTxKb2I8QmFja2dyb3VuZEpvYk1CQ0V2aWN0RGF0YSwgQmFja2dyb3VuZEpvYk1CQ0V2aWN0UmVzdWx0Pj4ge1xuICAgIGxvZ2dlci5pbmZvKHsgcXVldWU6IFFVRVVFX05BTUUsIGRhdGEgfSwgJ0NyZWF0aW5nIHRoZSBtYWtlciBiYWxhbmNlIGNhY2hlIGJhY2tncm91bmQgam9iIG9uIHF1ZXVlJyk7XG4gICAgcmV0dXJuIHF1ZXVlLmFkZChgJHtRVUVVRV9OQU1FfS4ke2RhdGEudGltZXN0YW1wfWAsIGRhdGEsIHtcbiAgICAgICAgcmVtb3ZlT25Db21wbGV0ZTogUkVNT1ZFX09OX0NPTVBMRVRFX09QUyxcbiAgICAgICAgcmVtb3ZlT25GYWlsOiBSRU1PVkVfT05fRkFJTFVSRV9PUFMsXG4gICAgfSk7XG59XG5cbi8qKlxuICogUHJvY2Vzc29yIG1ldGhvZCBmb3IgdGhlIG1ha2VyIGJhbGFuY2UgY2FjaGUgZXZpY3Qgam9iLiBFdmljdHMgZW50cmllcyB3aXRoIHplcm8gYmFsYW5jZXMgZnJvbSB0aGUgY2FjaGUuXG4gKlxuICogQHBhcmFtIGpvYiBNYWtlciBiYWxhbmNlIGNhY2hlIGV2aWN0IGJhY2tncm91bmQgam9iLlxuICogQHJldHVybnMgUmVzdWx0IG9mIHRoZSBldmljdCBiYWNrZ3JvdW5kIGpvYi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0FzeW5jKFxuICAgIGpvYjogSm9iPEJhY2tncm91bmRKb2JNQkNFdmljdERhdGEsIEJhY2tncm91bmRKb2JNQkNFdmljdFJlc3VsdD4sXG4pOiBQcm9taXNlPEJhY2tncm91bmRKb2JNQkNFdmljdFJlc3VsdD4ge1xuICAgIGF3YWl0IGpvYi51cGRhdGVQcm9ncmVzcygwKTtcbiAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgeyBqb2JOYW1lOiBqb2IubmFtZSwgcXVldWU6IGpvYi5xdWV1ZU5hbWUsIGRhdGE6IGpvYi5kYXRhLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfSxcbiAgICAgICAgJ1Byb2Nlc3NpbmcgdGhlIG1ha2VyIGJhbGFuY2UgY2FjaGUgZXZpY3QgYmFja2dyb3VuZCBqb2Igb24gcXVldWUnLFxuICAgICk7XG5cbiAgICBjb25zdCBjaGFpbklkID0gam9iLmRhdGEuY2hhaW5JZDtcblxuICAgIC8vIEJ1aWxkIGRlcGVuZGVuY2llc1xuICAgIGNvbnN0IGNoYWluID0gQ0hBSU5fQ09ORklHVVJBVElPTlMuZmluZCgoYykgPT4gYy5jaGFpbklkID09PSBjaGFpbklkKTtcbiAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJpZWQgdG8gc3RhcnQgYmFja2dyb3VuZCBqb2IgcHJvY2VzcyBmb3IgY2hhaW4gJHtjaGFpbklkfVxuICAgICAgICBidXQgbm8gY2hhaW4gY29uZmlndXJhdGlvbiB3YXMgcHJlc2VudGApO1xuICAgIH1cbiAgICBjb25zdCByZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UgPSBhd2FpdCBidWlsZFJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZUFzeW5jKGNoYWluKTtcbiAgICBpZiAoIXJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICB7IGpvYk5hbWU6IGpvYi5uYW1lLCBxdWV1ZTogam9iLnF1ZXVlTmFtZSwgZGF0YTogam9iLmRhdGEsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9LFxuICAgICAgICAgICAgJ0ZhaWxlZCB0byBpbml0aWFsaXplIGRlcGVuZGVuY2llcyBmb3IgbWFrZXItYmFsYW5jZS1jYWNoZS1ldmljdCcsXG4gICAgICAgICk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgZGVwZW5kZW5jaWVzIGZvciBtYWtlci1iYWxhbmNlLWNhY2hlLWV2aWN0Jyk7XG4gICAgfVxuICAgIGF3YWl0IGpvYi51cGRhdGVQcm9ncmVzcyg1MCk7XG5cbiAgICAvLyBQZXJmb3JtIGV2aWN0aW9uIG9uIG1ha2VyIGJhbGFuY2UgY2FjaGUgZW50cmllc1xuICAgIGxldCBudW1FdmljdGVkO1xuICAgIHRyeSB7XG4gICAgICAgIG51bUV2aWN0ZWQgPSBhd2FpdCByZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UuZXZpY3RaZXJvQmFsYW5jZXNBc3luYyhjaGFpbklkKTtcbiAgICAgICAgTUFLRVJfQkFMQU5DRV9DQUNIRV9FVklDVF9QUk9DRVNTX0NPVU5ULmluYygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgIHsgam9iTmFtZTogam9iLm5hbWUsIHF1ZXVlOiBqb2IucXVldWVOYW1lLCBkYXRhOiBqb2IuZGF0YSwgdGltZXN0YW1wOiBEYXRlLm5vdygpIH0sXG4gICAgICAgICAgICAnRmFpbGVkIHRvIGV2aWN0IG1ha2VyIGJhbGFuY2UgY2FjaGUgd2hpbGUgcnVubmluZyBzY2hlZHVsZWQgYmFja2dyb3VuZCBqb2InLFxuICAgICAgICApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBldmljdCBtYWtlciBiYWxhbmNlIGNhY2hlIHdoaWxlIHJ1bm5pbmcgc2NoZWR1bGVkIGJhY2tncm91bmQgam9iJyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgYXdhaXQgcmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlLmNsb3NlQXN5bmMoKTtcbiAgICB9XG5cbiAgICBhd2FpdCBqb2IudXBkYXRlUHJvZ3Jlc3MoMTAwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFpbklkLFxuICAgICAgICBqb2JOYW1lOiBqb2IubmFtZSxcbiAgICAgICAgbnVtRXZpY3RlZCxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIH07XG59XG4iXSwidmVyc2lvbiI6M30=