93079dc3dac4031190474cb684cf6d5a
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RfqMakerBalanceCacheService = void 0;
const utils_1 = require("@0x/utils");
const prom_client_1 = require("prom-client");
const logger_1 = require("../logger");
const RFQ_BALANCE_CACHE_CHECKED = new prom_client_1.Counter({
    name: 'rfq_balance_cache_checked',
    help: 'Number of times we checked balance cache',
});
const RFQ_BALANCE_CACHE_MISS = new prom_client_1.Counter({
    name: 'rfq_balance_cache_missed',
    help: 'cache miss observed in balance cache',
});
const RFQ_BALANCE_CACHE_READ_LATENCY = new prom_client_1.Summary({
    name: 'rfq_balance_cache_read_latency',
    help: 'Read latency for balance cache',
});
const RFQ_BALANCE_CACHE_WRITE_LATENCY = new prom_client_1.Summary({
    name: 'rfq_balance_cache_write_latency',
    help: 'Write latency for balance cache',
});
const RFQ_BALANCE_CACHE_EVICT_LATENCY = new prom_client_1.Summary({
    name: 'rfq_balance_cache_evict_latency',
    help: 'Evict latency for balance cache',
});
const RFQ_BALANCE_CACHE_NUM_ADDRESSES = new prom_client_1.Gauge({
    name: 'rfq_balance_cache_num_addresses',
    help: 'Number of unique addresses in balance cache',
});
/**
 * RfqMakerBalanceCacheService is used by RfqmService to fetch maker token balances.
 * It maintains a balance cache that is periodically updated via on-chain balance checks.
 */
class RfqMakerBalanceCacheService {
    constructor(_cacheClient, _balanceCheckUtils) {
        this._cacheClient = _cacheClient;
        this._balanceCheckUtils = _balanceCheckUtils;
    }
    /**
     * Gets token balances for supplied maker and token addresses from the maker balance cache.
     * Performs a balance check if balances are not found in the cache.
     * Returns an array of balances ordered by corresponding erc20Owner objects.
     */
    async getERC20OwnerBalancesAsync(chainId, erc20Owners) {
        const timerStopFunction = RFQ_BALANCE_CACHE_READ_LATENCY.startTimer();
        const erc20OwnersArr = Array.isArray(erc20Owners) ? erc20Owners : [erc20Owners];
        let cachedBalances;
        try {
            RFQ_BALANCE_CACHE_CHECKED.inc(erc20OwnersArr.length);
            cachedBalances = await this._cacheClient.getERC20OwnerBalancesAsync(chainId, erc20OwnersArr);
        }
        catch (e) {
            timerStopFunction();
            logger_1.logger.error({ chainId, erc20Owners }, 'Failed to read entries from maker balance cache');
            throw e;
        }
        // On cache miss (i.e. if balance is null), add to pending maker token addresses
        const pendingIndices = [];
        await Promise.all(cachedBalances.map(async (balance, i) => {
            if (balance === null) {
                RFQ_BALANCE_CACHE_MISS.inc();
                await this._cacheClient.addERC20OwnerAsync(chainId, erc20OwnersArr[i]);
                pendingIndices.push(i);
            }
        }));
        // Perform balance check and update balances accordingly
        // At this point, remaining null balances will be represented as zero balances
        // and will be subject to eviction.
        let balances;
        if (pendingIndices.length !== 0) {
            const fetchedBalances = await this._balanceCheckUtils.getMinOfBalancesAndAllowancesAsync(erc20OwnersArr.filter((_, i) => pendingIndices.includes(i)));
            balances = cachedBalances.map((balance) => {
                if (balance === null) {
                    const fetchedBalance = fetchedBalances.shift();
                    return fetchedBalance ? fetchedBalance : new utils_1.BigNumber(0);
                }
                // balance should be a valid BigNumber at this point
                return balance;
            });
        }
        else {
            // balances should not be null here
            balances = cachedBalances.filter((balance) => balance !== null);
        }
        timerStopFunction();
        return balances;
    }
    /**
     * Updates cached token balances by making an on-chain balance check.
     * All newly observed erc20Owners included in the set of maintained maker token addresses are updated.
     */
    async updateERC20OwnerBalancesAsync(chainId) {
        const timerStopFunction = RFQ_BALANCE_CACHE_WRITE_LATENCY.startTimer();
        try {
            const erc20Owners = await this._cacheClient.getERC20OwnersAsync(chainId);
            if (erc20Owners.length > 0) {
                RFQ_BALANCE_CACHE_NUM_ADDRESSES.set(erc20Owners.length);
                const balances = await this._balanceCheckUtils.getMinOfBalancesAndAllowancesAsync(erc20Owners);
                await this._cacheClient.setERC20OwnerBalancesAsync(chainId, erc20Owners, balances);
            }
        }
        catch (e) {
            logger_1.logger.error({ chainId }, 'Failed to update entries for maker balance cache');
            throw e;
        }
        finally {
            timerStopFunction();
        }
    }
    /**
     * Performs eviction of stale cache entries with zero balances.
     */
    async evictZeroBalancesAsync(chainId) {
        const timerStopFunction = RFQ_BALANCE_CACHE_EVICT_LATENCY.startTimer();
        try {
            return this._cacheClient.evictZeroBalancesAsync(chainId);
        }
        catch (e) {
            logger_1.logger.error({ chainId }, 'Failed to evict entries from maker balance cache');
            throw e;
        }
        finally {
            timerStopFunction();
        }
    }
    /**
     * Safely close the maker balance cache service to avoid potential memory leak.
     */
    async closeAsync() {
        try {
            return this._cacheClient.closeAsync();
        }
        catch (e) {
            logger_1.logger.error({ message: e.message, stack: e.stack }, 'Failed to close RFQm maker balance cache service');
            throw e;
        }
    }
}
exports.RfqMakerBalanceCacheService = RfqMakerBalanceCacheService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9zZXJ2aWNlcy9yZnFfbWFrZXJfYmFsYW5jZV9jYWNoZV9zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUFzQztBQUN0Qyw2Q0FBc0Q7QUFFdEQsc0NBQW1DO0FBS25DLE1BQU0seUJBQXlCLEdBQUcsSUFBSSxxQkFBTyxDQUFDO0lBQzFDLElBQUksRUFBRSwyQkFBMkI7SUFDakMsSUFBSSxFQUFFLDBDQUEwQztDQUNuRCxDQUFDLENBQUM7QUFDSCxNQUFNLHNCQUFzQixHQUFHLElBQUkscUJBQU8sQ0FBQztJQUN2QyxJQUFJLEVBQUUsMEJBQTBCO0lBQ2hDLElBQUksRUFBRSxzQ0FBc0M7Q0FDL0MsQ0FBQyxDQUFDO0FBQ0gsTUFBTSw4QkFBOEIsR0FBRyxJQUFJLHFCQUFPLENBQUM7SUFDL0MsSUFBSSxFQUFFLGdDQUFnQztJQUN0QyxJQUFJLEVBQUUsZ0NBQWdDO0NBQ3pDLENBQUMsQ0FBQztBQUNILE1BQU0sK0JBQStCLEdBQUcsSUFBSSxxQkFBTyxDQUFDO0lBQ2hELElBQUksRUFBRSxpQ0FBaUM7SUFDdkMsSUFBSSxFQUFFLGlDQUFpQztDQUMxQyxDQUFDLENBQUM7QUFDSCxNQUFNLCtCQUErQixHQUFHLElBQUkscUJBQU8sQ0FBQztJQUNoRCxJQUFJLEVBQUUsaUNBQWlDO0lBQ3ZDLElBQUksRUFBRSxpQ0FBaUM7Q0FDMUMsQ0FBQyxDQUFDO0FBQ0gsTUFBTSwrQkFBK0IsR0FBRyxJQUFJLG1CQUFLLENBQUM7SUFDOUMsSUFBSSxFQUFFLGlDQUFpQztJQUN2QyxJQUFJLEVBQUUsNkNBQTZDO0NBQ3RELENBQUMsQ0FBQztBQUVIOzs7R0FHRztBQUNILE1BQWEsMkJBQTJCO0lBQ3BDLFlBQ3FCLFlBQXlCLEVBQ3pCLGtCQUF3QztRQUR4QyxpQkFBWSxHQUFaLFlBQVksQ0FBYTtRQUN6Qix1QkFBa0IsR0FBbEIsa0JBQWtCLENBQXNCO0lBQzFELENBQUM7SUFFSjs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLDBCQUEwQixDQUNuQyxPQUFlLEVBQ2YsV0FBc0M7UUFFdEMsTUFBTSxpQkFBaUIsR0FBRyw4QkFBOEIsQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUV0RSxNQUFNLGNBQWMsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDaEYsSUFBSSxjQUFvQyxDQUFDO1FBQ3pDLElBQUk7WUFDQSx5QkFBeUIsQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3JELGNBQWMsR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLENBQUMsMEJBQTBCLENBQUMsT0FBTyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1NBQ2hHO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDUixpQkFBaUIsRUFBRSxDQUFDO1lBQ3BCLGVBQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLEVBQUUsaURBQWlELENBQUMsQ0FBQztZQUMxRixNQUFNLENBQUMsQ0FBQztTQUNYO1FBRUQsZ0ZBQWdGO1FBQ2hGLE1BQU0sY0FBYyxHQUFhLEVBQUUsQ0FBQztRQUNwQyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQ2IsY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3BDLElBQUksT0FBTyxLQUFLLElBQUksRUFBRTtnQkFDbEIsc0JBQXNCLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQzdCLE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZFLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDMUI7UUFDTCxDQUFDLENBQUMsQ0FDTCxDQUFDO1FBRUYsd0RBQXdEO1FBQ3hELDhFQUE4RTtRQUM5RSxtQ0FBbUM7UUFDbkMsSUFBSSxRQUFxQixDQUFDO1FBQzFCLElBQUksY0FBYyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDN0IsTUFBTSxlQUFlLEdBQUcsTUFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsa0NBQWtDLENBQ3BGLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQzlELENBQUM7WUFDRixRQUFRLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO2dCQUN0QyxJQUFJLE9BQU8sS0FBSyxJQUFJLEVBQUU7b0JBQ2xCLE1BQU0sY0FBYyxHQUFHLGVBQWUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztvQkFDL0MsT0FBTyxjQUFjLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsSUFBSSxpQkFBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUM3RDtnQkFDRCxvREFBb0Q7Z0JBQ3BELE9BQU8sT0FBTyxDQUFDO1lBQ25CLENBQUMsQ0FBQyxDQUFDO1NBQ047YUFBTTtZQUNILG1DQUFtQztZQUNuQyxRQUFRLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sRUFBd0IsRUFBRSxDQUFDLE9BQU8sS0FBSyxJQUFJLENBQUMsQ0FBQztTQUN6RjtRQUVELGlCQUFpQixFQUFFLENBQUM7UUFDcEIsT0FBTyxRQUFRLENBQUM7SUFDcEIsQ0FBQztJQUVEOzs7T0FHRztJQUNJLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxPQUFlO1FBQ3RELE1BQU0saUJBQWlCLEdBQUcsK0JBQStCLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDdkUsSUFBSTtZQUNBLE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN6RSxJQUFJLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUN4QiwrQkFBK0IsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUN4RCxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxrQ0FBa0MsQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFFL0YsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLDBCQUEwQixDQUFDLE9BQU8sRUFBRSxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUM7YUFDdEY7U0FDSjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1IsZUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLGtEQUFrRCxDQUFDLENBQUM7WUFDOUUsTUFBTSxDQUFDLENBQUM7U0FDWDtnQkFBUztZQUNOLGlCQUFpQixFQUFFLENBQUM7U0FDdkI7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxLQUFLLENBQUMsc0JBQXNCLENBQUMsT0FBZTtRQUMvQyxNQUFNLGlCQUFpQixHQUFHLCtCQUErQixDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3ZFLElBQUk7WUFDQSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDNUQ7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNSLGVBQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRSxrREFBa0QsQ0FBQyxDQUFDO1lBQzlFLE1BQU0sQ0FBQyxDQUFDO1NBQ1g7Z0JBQVM7WUFDTixpQkFBaUIsRUFBRSxDQUFDO1NBQ3ZCO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0ksS0FBSyxDQUFDLFVBQVU7UUFDbkIsSUFBSTtZQUNBLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUN6QztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1IsZUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsa0RBQWtELENBQUMsQ0FBQztZQUN6RyxNQUFNLENBQUMsQ0FBQztTQUNYO0lBQ0wsQ0FBQztDQUNKO0FBakhELGtFQWlIQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvZGF2aWR3YWxzaC9jb2RlLWxvY2FsLzB4LXJmcS1hcGkvc3JjL3NlcnZpY2VzL3JmcV9tYWtlcl9iYWxhbmNlX2NhY2hlX3NlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnQDB4L3V0aWxzJztcclxuaW1wb3J0IHsgQ291bnRlciwgR2F1Z2UsIFN1bW1hcnkgfSBmcm9tICdwcm9tLWNsaWVudCc7XHJcblxyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xyXG5pbXBvcnQgeyBFUkMyME93bmVyIH0gZnJvbSAnLi4vY29yZS90eXBlcyc7XHJcbmltcG9ydCB7IENhY2hlQ2xpZW50IH0gZnJvbSAnLi4vdXRpbHMvY2FjaGVfY2xpZW50JztcclxuaW1wb3J0IHsgUmZxQmFsYW5jZUNoZWNrVXRpbHMgfSBmcm9tICcuLi91dGlscy9yZnFfYmxvY2tjaGFpbl91dGlscyc7XHJcblxyXG5jb25zdCBSRlFfQkFMQU5DRV9DQUNIRV9DSEVDS0VEID0gbmV3IENvdW50ZXIoe1xyXG4gICAgbmFtZTogJ3JmcV9iYWxhbmNlX2NhY2hlX2NoZWNrZWQnLFxyXG4gICAgaGVscDogJ051bWJlciBvZiB0aW1lcyB3ZSBjaGVja2VkIGJhbGFuY2UgY2FjaGUnLFxyXG59KTtcclxuY29uc3QgUkZRX0JBTEFOQ0VfQ0FDSEVfTUlTUyA9IG5ldyBDb3VudGVyKHtcclxuICAgIG5hbWU6ICdyZnFfYmFsYW5jZV9jYWNoZV9taXNzZWQnLFxyXG4gICAgaGVscDogJ2NhY2hlIG1pc3Mgb2JzZXJ2ZWQgaW4gYmFsYW5jZSBjYWNoZScsXHJcbn0pO1xyXG5jb25zdCBSRlFfQkFMQU5DRV9DQUNIRV9SRUFEX0xBVEVOQ1kgPSBuZXcgU3VtbWFyeSh7XHJcbiAgICBuYW1lOiAncmZxX2JhbGFuY2VfY2FjaGVfcmVhZF9sYXRlbmN5JyxcclxuICAgIGhlbHA6ICdSZWFkIGxhdGVuY3kgZm9yIGJhbGFuY2UgY2FjaGUnLFxyXG59KTtcclxuY29uc3QgUkZRX0JBTEFOQ0VfQ0FDSEVfV1JJVEVfTEFURU5DWSA9IG5ldyBTdW1tYXJ5KHtcclxuICAgIG5hbWU6ICdyZnFfYmFsYW5jZV9jYWNoZV93cml0ZV9sYXRlbmN5JyxcclxuICAgIGhlbHA6ICdXcml0ZSBsYXRlbmN5IGZvciBiYWxhbmNlIGNhY2hlJyxcclxufSk7XHJcbmNvbnN0IFJGUV9CQUxBTkNFX0NBQ0hFX0VWSUNUX0xBVEVOQ1kgPSBuZXcgU3VtbWFyeSh7XHJcbiAgICBuYW1lOiAncmZxX2JhbGFuY2VfY2FjaGVfZXZpY3RfbGF0ZW5jeScsXHJcbiAgICBoZWxwOiAnRXZpY3QgbGF0ZW5jeSBmb3IgYmFsYW5jZSBjYWNoZScsXHJcbn0pO1xyXG5jb25zdCBSRlFfQkFMQU5DRV9DQUNIRV9OVU1fQUREUkVTU0VTID0gbmV3IEdhdWdlKHtcclxuICAgIG5hbWU6ICdyZnFfYmFsYW5jZV9jYWNoZV9udW1fYWRkcmVzc2VzJyxcclxuICAgIGhlbHA6ICdOdW1iZXIgb2YgdW5pcXVlIGFkZHJlc3NlcyBpbiBiYWxhbmNlIGNhY2hlJyxcclxufSk7XHJcblxyXG4vKipcclxuICogUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlIGlzIHVzZWQgYnkgUmZxbVNlcnZpY2UgdG8gZmV0Y2ggbWFrZXIgdG9rZW4gYmFsYW5jZXMuXHJcbiAqIEl0IG1haW50YWlucyBhIGJhbGFuY2UgY2FjaGUgdGhhdCBpcyBwZXJpb2RpY2FsbHkgdXBkYXRlZCB2aWEgb24tY2hhaW4gYmFsYW5jZSBjaGVja3MuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX2NhY2hlQ2xpZW50OiBDYWNoZUNsaWVudCxcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9iYWxhbmNlQ2hlY2tVdGlsczogUmZxQmFsYW5jZUNoZWNrVXRpbHMsXHJcbiAgICApIHt9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRva2VuIGJhbGFuY2VzIGZvciBzdXBwbGllZCBtYWtlciBhbmQgdG9rZW4gYWRkcmVzc2VzIGZyb20gdGhlIG1ha2VyIGJhbGFuY2UgY2FjaGUuXHJcbiAgICAgKiBQZXJmb3JtcyBhIGJhbGFuY2UgY2hlY2sgaWYgYmFsYW5jZXMgYXJlIG5vdCBmb3VuZCBpbiB0aGUgY2FjaGUuXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGJhbGFuY2VzIG9yZGVyZWQgYnkgY29ycmVzcG9uZGluZyBlcmMyME93bmVyIG9iamVjdHMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRFUkMyME93bmVyQmFsYW5jZXNBc3luYyhcclxuICAgICAgICBjaGFpbklkOiBudW1iZXIsXHJcbiAgICAgICAgZXJjMjBPd25lcnM6IEVSQzIwT3duZXIgfCBFUkMyME93bmVyW10sXHJcbiAgICApOiBQcm9taXNlPEJpZ051bWJlcltdPiB7XHJcbiAgICAgICAgY29uc3QgdGltZXJTdG9wRnVuY3Rpb24gPSBSRlFfQkFMQU5DRV9DQUNIRV9SRUFEX0xBVEVOQ1kuc3RhcnRUaW1lcigpO1xyXG5cclxuICAgICAgICBjb25zdCBlcmMyME93bmVyc0FyciA9IEFycmF5LmlzQXJyYXkoZXJjMjBPd25lcnMpID8gZXJjMjBPd25lcnMgOiBbZXJjMjBPd25lcnNdO1xyXG4gICAgICAgIGxldCBjYWNoZWRCYWxhbmNlczogKEJpZ051bWJlciB8IG51bGwpW107XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgUkZRX0JBTEFOQ0VfQ0FDSEVfQ0hFQ0tFRC5pbmMoZXJjMjBPd25lcnNBcnIubGVuZ3RoKTtcclxuICAgICAgICAgICAgY2FjaGVkQmFsYW5jZXMgPSBhd2FpdCB0aGlzLl9jYWNoZUNsaWVudC5nZXRFUkMyME93bmVyQmFsYW5jZXNBc3luYyhjaGFpbklkLCBlcmMyME93bmVyc0Fycik7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aW1lclN0b3BGdW5jdGlvbigpO1xyXG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoeyBjaGFpbklkLCBlcmMyME93bmVycyB9LCAnRmFpbGVkIHRvIHJlYWQgZW50cmllcyBmcm9tIG1ha2VyIGJhbGFuY2UgY2FjaGUnKTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE9uIGNhY2hlIG1pc3MgKGkuZS4gaWYgYmFsYW5jZSBpcyBudWxsKSwgYWRkIHRvIHBlbmRpbmcgbWFrZXIgdG9rZW4gYWRkcmVzc2VzXHJcbiAgICAgICAgY29uc3QgcGVuZGluZ0luZGljZXM6IG51bWJlcltdID0gW107XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgICAgICAgIGNhY2hlZEJhbGFuY2VzLm1hcChhc3luYyAoYmFsYW5jZSwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJhbGFuY2UgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBSRlFfQkFMQU5DRV9DQUNIRV9NSVNTLmluYygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NhY2hlQ2xpZW50LmFkZEVSQzIwT3duZXJBc3luYyhjaGFpbklkLCBlcmMyME93bmVyc0FycltpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0luZGljZXMucHVzaChpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gUGVyZm9ybSBiYWxhbmNlIGNoZWNrIGFuZCB1cGRhdGUgYmFsYW5jZXMgYWNjb3JkaW5nbHlcclxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCByZW1haW5pbmcgbnVsbCBiYWxhbmNlcyB3aWxsIGJlIHJlcHJlc2VudGVkIGFzIHplcm8gYmFsYW5jZXNcclxuICAgICAgICAvLyBhbmQgd2lsbCBiZSBzdWJqZWN0IHRvIGV2aWN0aW9uLlxyXG4gICAgICAgIGxldCBiYWxhbmNlczogQmlnTnVtYmVyW107XHJcbiAgICAgICAgaWYgKHBlbmRpbmdJbmRpY2VzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBmZXRjaGVkQmFsYW5jZXMgPSBhd2FpdCB0aGlzLl9iYWxhbmNlQ2hlY2tVdGlscy5nZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKFxyXG4gICAgICAgICAgICAgICAgZXJjMjBPd25lcnNBcnIuZmlsdGVyKChfLCBpKSA9PiBwZW5kaW5nSW5kaWNlcy5pbmNsdWRlcyhpKSksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGJhbGFuY2VzID0gY2FjaGVkQmFsYW5jZXMubWFwKChiYWxhbmNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmFsYW5jZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoZWRCYWxhbmNlID0gZmV0Y2hlZEJhbGFuY2VzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoZWRCYWxhbmNlID8gZmV0Y2hlZEJhbGFuY2UgOiBuZXcgQmlnTnVtYmVyKDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYmFsYW5jZSBzaG91bGQgYmUgYSB2YWxpZCBCaWdOdW1iZXIgYXQgdGhpcyBwb2ludFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhbGFuY2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGJhbGFuY2VzIHNob3VsZCBub3QgYmUgbnVsbCBoZXJlXHJcbiAgICAgICAgICAgIGJhbGFuY2VzID0gY2FjaGVkQmFsYW5jZXMuZmlsdGVyKChiYWxhbmNlKTogYmFsYW5jZSBpcyBCaWdOdW1iZXIgPT4gYmFsYW5jZSAhPT0gbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aW1lclN0b3BGdW5jdGlvbigpO1xyXG4gICAgICAgIHJldHVybiBiYWxhbmNlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgY2FjaGVkIHRva2VuIGJhbGFuY2VzIGJ5IG1ha2luZyBhbiBvbi1jaGFpbiBiYWxhbmNlIGNoZWNrLlxyXG4gICAgICogQWxsIG5ld2x5IG9ic2VydmVkIGVyYzIwT3duZXJzIGluY2x1ZGVkIGluIHRoZSBzZXQgb2YgbWFpbnRhaW5lZCBtYWtlciB0b2tlbiBhZGRyZXNzZXMgYXJlIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyB1cGRhdGVFUkMyME93bmVyQmFsYW5jZXNBc3luYyhjaGFpbklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB0aW1lclN0b3BGdW5jdGlvbiA9IFJGUV9CQUxBTkNFX0NBQ0hFX1dSSVRFX0xBVEVOQ1kuc3RhcnRUaW1lcigpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVyYzIwT3duZXJzID0gYXdhaXQgdGhpcy5fY2FjaGVDbGllbnQuZ2V0RVJDMjBPd25lcnNBc3luYyhjaGFpbklkKTtcclxuICAgICAgICAgICAgaWYgKGVyYzIwT3duZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIFJGUV9CQUxBTkNFX0NBQ0hFX05VTV9BRERSRVNTRVMuc2V0KGVyYzIwT3duZXJzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMuX2JhbGFuY2VDaGVja1V0aWxzLmdldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMoZXJjMjBPd25lcnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NhY2hlQ2xpZW50LnNldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKGNoYWluSWQsIGVyYzIwT3duZXJzLCBiYWxhbmNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcih7IGNoYWluSWQgfSwgJ0ZhaWxlZCB0byB1cGRhdGUgZW50cmllcyBmb3IgbWFrZXIgYmFsYW5jZSBjYWNoZScpO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRpbWVyU3RvcEZ1bmN0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgZXZpY3Rpb24gb2Ygc3RhbGUgY2FjaGUgZW50cmllcyB3aXRoIHplcm8gYmFsYW5jZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBldmljdFplcm9CYWxhbmNlc0FzeW5jKGNoYWluSWQ6IG51bWJlcik6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICAgICAgY29uc3QgdGltZXJTdG9wRnVuY3Rpb24gPSBSRlFfQkFMQU5DRV9DQUNIRV9FVklDVF9MQVRFTkNZLnN0YXJ0VGltZXIoKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVDbGllbnQuZXZpY3RaZXJvQmFsYW5jZXNBc3luYyhjaGFpbklkKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcih7IGNoYWluSWQgfSwgJ0ZhaWxlZCB0byBldmljdCBlbnRyaWVzIGZyb20gbWFrZXIgYmFsYW5jZSBjYWNoZScpO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRpbWVyU3RvcEZ1bmN0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2FmZWx5IGNsb3NlIHRoZSBtYWtlciBiYWxhbmNlIGNhY2hlIHNlcnZpY2UgdG8gYXZvaWQgcG90ZW50aWFsIG1lbW9yeSBsZWFrLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgY2xvc2VBc3luYygpOiBQcm9taXNlPCdPSyc+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVDbGllbnQuY2xvc2VBc3luYygpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKHsgbWVzc2FnZTogZS5tZXNzYWdlLCBzdGFjazogZS5zdGFjayB9LCAnRmFpbGVkIHRvIGNsb3NlIFJGUW0gbWFrZXIgYmFsYW5jZSBjYWNoZSBzZXJ2aWNlJyk7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdLCJ2ZXJzaW9uIjozfQ==