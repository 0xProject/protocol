b07dd76219ea977e0da6b50e9fdf94a4
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RfqtService = void 0;
const orders_1 = require("@0x/protocol-utils/lib/src/orders");
const token_metadata_1 = require("@0x/token-metadata");
const utils_1 = require("@0x/utils");
const constants_1 = require("../core/constants");
const fee_utils_1 = require("../core/fee_utils");
const logger_1 = require("../logger");
const quote_report_utils_1 = require("../utils/quote_report_utils");
const RfqtQuoteValidator_1 = require("../utils/RfqtQuoteValidator");
const signature_utils_1 = require("../utils/signature_utils");
const getTokenAddressFromSymbol = (symbol, chainId) => {
    return (0, token_metadata_1.getTokenMetadataIfExists)(symbol, chainId).tokenAddress;
};
/**
 * Converts the parameters of an RFQt v2 prices request from 0x API
 * into the format needed for `QuoteServerClient` to call the market makers
 */
function transformRfqtV2PricesParameters(p, fee, chainId) {
    const buyTokenAddress = p.makerToken;
    const sellTokenAddress = p.takerToken;
    // Typescript gymnastics with `baseUnits` to caputure the "oneof" nature--
    // By packaging them in their own little object, the type becomes:
    //
    // { buyAmountBaseUnits: BigNumber, sellAmountBaseUnits: undefined } |
    // { buyAmountBaseUnits: undefined, sellAmountBaseUnits: BigNumber }
    //
    // This is different from not packaging them together, where the types would be:
    //
    // buyAmountBaseUnits: BigNumber | undefined
    // sellAmountBaseUnits: BigNumber | undefined
    const baseUnits = p.isSelling === false
        ? {
            buyAmountBaseUnits: p.assetFillAmount,
            sellAmountBaseUnits: undefined,
        }
        : {
            // This is a SELL
            buyAmountBaseUnits: undefined,
            sellAmountBaseUnits: p.assetFillAmount,
        };
    const mmRequestParameters = {
        ...baseUnits,
        buyTokenAddress,
        sellTokenAddress,
        chainId,
        feeAmount: fee.amount,
        feeToken: fee.token,
        integratorId: p.integrator.integratorId,
        takerAddress: p.takerAddress,
        txOrigin: p.txOrigin,
        trader: p.trader,
        gasless: p.workflow === 'gasless-rfqt',
        protocolVersion: '4', //hardcode - will break some MMs if missing!
    };
    // Convert mmRequestParameters values to strings
    const stringParameters = ((o) => {
        return Object.keys(o).reduce((result, key) => {
            const value = o[key];
            if (value !== undefined && value.toString) {
                const stringValue = value.toString();
                result[key] = stringValue;
            }
            return result;
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }, {});
    })(mmRequestParameters);
    return stringParameters;
}
/**
 * Contains the logic to handle RFQT Trades.
 *
 * `"v1"` functions support `MetaTransaction` trades while
 * `"v2"` functions (will) support `OtcOrder` trades.
 *
 * `v1` relies heavily on `QuoteRequestor` which has been copied over
 * from `0x/asset-swapper`.
 */
class RfqtService {
    constructor(_chainId, _rfqMakerManager, 
    // Used for RFQt v1 requests
    _quoteRequestor, 
    // Used for RFQt v2 requests
    _quoteServerClient, _minExpiryDurationMs, _blockchainUtils, _tokenMetadataManager, _contractAddresses, _feeService, _feeModelVersion, _rfqMakerBalanceCacheService, _kafkaProducer, _feeEventTopic) {
        this._chainId = _chainId;
        this._rfqMakerManager = _rfqMakerManager;
        this._quoteRequestor = _quoteRequestor;
        this._quoteServerClient = _quoteServerClient;
        this._minExpiryDurationMs = _minExpiryDurationMs;
        this._blockchainUtils = _blockchainUtils;
        this._tokenMetadataManager = _tokenMetadataManager;
        this._contractAddresses = _contractAddresses;
        this._feeService = _feeService;
        this._feeModelVersion = _feeModelVersion;
        this._rfqMakerBalanceCacheService = _rfqMakerBalanceCacheService;
        this._kafkaProducer = _kafkaProducer;
        this._feeEventTopic = _feeEventTopic;
        this._nativeTokenSymbol = (0, token_metadata_1.nativeTokenSymbol)(this._chainId);
        this._nativeTokenAddress = getTokenAddressFromSymbol(this._nativeTokenSymbol, this._chainId);
        this._nativeWrappedTokenSymbol = (0, token_metadata_1.nativeWrappedTokenSymbol)(this._chainId);
        this._nativeWrappedTokenAddress = getTokenAddressFromSymbol(this._nativeWrappedTokenSymbol, this._chainId);
    }
    /**
     * Pass through to `QuoteRequestor::requestRfqtIndicativeQuotesAsync` to fetch
     * indicative quotes from market makers.
     *
     * Note that by this point, 0x API should be sending the null address
     * as the `takerAddress` and the taker's address as the `txOrigin`.
     */
    async getV1PricesAsync(parameters) {
        const { altRfqAssetOfferings, assetFillAmount, comparisonPrice, integrator, intentOnFilling, // tslint:disable-line boolean-naming
        makerToken, marketOperation, takerAddress, takerToken, txOrigin, } = parameters;
        return this._quoteRequestor.requestRfqtIndicativeQuotesAsync(makerToken, takerToken, assetFillAmount, marketOperation, comparisonPrice, {
            altRfqAssetOfferings,
            integrator,
            intentOnFilling,
            isIndicative: true,
            isLastLook: false,
            makerEndpointMaxResponseTimeMs: 600,
            takerAddress,
            txOrigin: txOrigin || constants_1.NULL_ADDRESS,
        });
    }
    /**
     * Pass through to `QuoteRequestor::requestRfqtFirmQuotesAsync` to fetch
     * firm quotes from market makers.
     *
     * Note that by this point, 0x API should be sending the null address
     * as the `takerAddress` and the taker's address as the `txOrigin`.
     */
    async getV1QuotesAsync(parameters) {
        const { altRfqAssetOfferings, assetFillAmount, comparisonPrice, integrator, intentOnFilling, // tslint:disable-line boolean-naming
        makerToken, marketOperation, takerAddress, takerToken, txOrigin, } = parameters;
        const quotes = await this._quoteRequestor.requestRfqtFirmQuotesAsync(makerToken, takerToken, assetFillAmount, marketOperation, comparisonPrice, {
            altRfqAssetOfferings,
            integrator,
            intentOnFilling,
            isIndicative: false,
            isLastLook: false,
            makerEndpointMaxResponseTimeMs: 600,
            takerAddress,
            txOrigin,
        });
        return quotes.map((q) => {
            return {
                ...q,
                makerUri: this._quoteRequestor.getMakerUriForSignature(q.signature),
            };
        });
    }
    /**
     * Accepts data sent by 0x API and fetches prices from Market Makers
     * configured on the given pair.
     *
     * Note that by this point, 0x API should be sending the null address
     * as the `takerAddress` and the taker's address as the `txOrigin`.
     */
    async getV2PricesAsync(quoteContext, now = new Date()) {
        const { feeWithDetails: fee } = await this._feeService.calculateFeeAsync(quoteContext);
        return this._getV2PricesInternalAsync(quoteContext, fee, now);
    }
    /**
     * Accepts data sent by 0x API and fetches quotes from market makers
     * configured on the given pair.
     *
     * Preparing quotes is a two step process:
     *  1. Requests are made to the market makers' `/price` endpoint using
     *     logic similar to that of `getV2PricesAsync`
     *  2. Valid prices are then sent to the market makers' `/sign`
     *     endpoint to get a signed quote
     */
    async getV2QuotesAsync(quoteContext, now = new Date()) {
        var _a, _b;
        const { feeWithDetails: fee } = await this._feeService.calculateFeeAsync(quoteContext);
        const storedFee = (0, fee_utils_1.feeToStoredFee)(fee);
        // TODO (rhinodavid): put a meter on this response time
        const prices = await this._getV2PricesInternalAsync(quoteContext, fee, now);
        // If multiple quotes are aggregated into the final order, they must
        // all have unique nonces. Otherwise they'll be rejected by the smart contract.
        const baseNonce = new utils_1.BigNumber(Math.floor(now.getTime() / constants_1.ONE_SECOND_MS));
        const pricesAndOrders = prices.map((price, i) => ({
            order: this._v2priceToOrder(price, quoteContext.txOrigin, baseNonce.plus(i)),
            price,
        }));
        const pricesAndOrdersAndSignatures = await Promise.all(pricesAndOrders.map(async ({ price, order }) => {
            let signature;
            try {
                const orderHash = order.getHash();
                signature = await this._quoteServerClient.signV2Async(price.makerUri, quoteContext.integrator.integratorId, { order, orderHash, expiry: price.expiry, fee }, (u) => `${u}/rfqt/v2/sign`, 
                /* requireProceedWithFill */ false);
                if (signature) {
                    // Certain market makers are returning signature components which are missing
                    // leading bytes. Add them if they don't exist.
                    const paddedSignature = (0, signature_utils_1.padSignature)(signature);
                    if (paddedSignature.r !== signature.r || paddedSignature.s !== signature.s) {
                        logger_1.logger.warn({ orderHash, r: paddedSignature.r, s: paddedSignature.s }, 'Got market maker signature with missing bytes');
                        signature = paddedSignature;
                    }
                    // Verify the signer was the maker
                    const signerAddress = (0, signature_utils_1.getSignerFromHash)(orderHash, signature).toLowerCase();
                    const makerAddress = order.maker.toLowerCase();
                    if (signerAddress !== makerAddress) {
                        const isValidSigner = await this._blockchainUtils.isValidOrderSignerAsync(makerAddress, signerAddress);
                        if (!isValidSigner) {
                            logger_1.logger.warn({ signerAddress, makerAddress, orderHash, makerUri: price.makerUri }, 'Invalid maker signature');
                            // Quotes with `undefined` signature will be filtered out later
                            signature = undefined;
                        }
                    }
                }
            }
            catch (e) {
                logger_1.logger.warn({ orderHash: order.getHash(), makerId: price.makerId }, 'Failed trying to get rfqt signature from market maker');
            }
            return {
                price,
                order,
                signature: signature !== null && signature !== void 0 ? signature : null,
            };
        }));
        // (Maker Balance Cache) Fetch maker balances to calculate fillable amounts
        let quotedMakerBalances;
        const quotedERC20Owners = prices.map((price) => ({
            owner: price.makerAddress,
            token: price.makerToken,
        }));
        try {
            quotedMakerBalances = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(this._chainId, quotedERC20Owners);
        }
        catch (e) {
            logger_1.logger.error({ chainId: this._chainId, quotedERC20Owners, errorMessage: e.message }, 'Failed to fetch maker balances to calculate fillable amounts');
        }
        const fillableAmounts = (0, RfqtQuoteValidator_1.getRfqtV2FillableAmounts)(prices, this._chainId, quotedMakerBalances);
        const quotes = pricesAndOrdersAndSignatures
            .filter((pos) => pos.signature)
            .map(({ price, order, signature }, i) => ({
            ...fillableAmounts[i],
            fillableTakerFeeAmount: new utils_1.BigNumber(0),
            makerId: price.makerId,
            makerUri: price.makerUri,
            order,
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            signature: signature, // `null` signatures already filtered out
        }));
        // Write to Fee Event Report
        if (this._kafkaProducer) {
            try {
                await quote_report_utils_1.quoteReportUtils.publishRfqtV2FeeEvent({
                    requestedBuyAmount: (_a = quoteContext.makerAmount) !== null && _a !== void 0 ? _a : null,
                    requestedSellAmount: (_b = quoteContext.takerAmount) !== null && _b !== void 0 ? _b : null,
                    requestedTakerAddress: quoteContext.takerAddress,
                    buyTokenAddress: quoteContext.makerToken,
                    sellTokenAddress: quoteContext.takerToken,
                    integratorId: quoteContext.integrator.integratorId,
                    quotes,
                    fee: storedFee,
                }, this._kafkaProducer, this._feeEventTopic);
            }
            catch (e) {
                logger_1.logger.error({
                    chainId: this._chainId,
                    requestedBuyAmount: quoteContext.makerAmount,
                    requestedSellAmount: quoteContext.takerAmount,
                    requestedTakerAddress: quoteContext.takerAddress,
                    buyTokenAddress: quoteContext.makerToken,
                    sellTokenAddress: quoteContext.takerToken,
                    integratorId: quoteContext.integrator.integratorId,
                    errorMessage: e.message,
                }, 'Failed to publish RFQt quote to Fee Event Report');
            }
        }
        return quotes;
    }
    get feeModelVersion() {
        return this._feeModelVersion;
    }
    /**
     * Passthrough to TokenMetadataManager's `getTokenDecimalsAsync` method
     */
    async getTokenDecimalsAsync(tokenAddress) {
        return this._tokenMetadataManager.getTokenDecimalsAsync(tokenAddress);
    }
    /**
     * Get prices from MMs for given quote context and fee.
     */
    async _getV2PricesInternalAsync(quoteContext, fee, now = new Date()) {
        const { integrator, makerToken, takerToken } = quoteContext;
        // Fetch the makers active on this pair
        const makers = this._rfqMakerManager.getRfqtV2MakersForPair(makerToken, takerToken).filter((m) => {
            if (m.rfqtUri === null) {
                return false;
            }
            if (integrator.whitelistMakerIds && !integrator.whitelistMakerIds.includes(m.makerId)) {
                return false;
            }
            return true;
        });
        // Short circuit if no makers are active
        if (!makers.length) {
            return [];
        }
        // TODO (haozhuo): check to see if MM passes circuit breaker
        const prices = (await this._quoteServerClient.batchGetPriceV2Async(
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        makers.map((m) => /* won't be null because of previous `filter` operation */ m.rfqtUri), integrator, transformRfqtV2PricesParameters(quoteContext, fee, this._chainId), (url) => `${url}/rfqt/v2/price`)).map((price) => {
            const maker = makers.find((m) => m.rfqtUri === price.makerUri);
            if (!maker) {
                throw new Error(`Could not find maker with URI ${price.makerUri}`);
            }
            return {
                expiry: price.expiry,
                makerAddress: price.maker,
                makerAmount: price.makerAmount,
                makerId: maker.makerId,
                makerToken: price.makerToken,
                makerUri: price.makerUri,
                takerAmount: price.takerAmount,
                takerToken: price.takerToken,
            };
        });
        // Filter out invalid prices
        const validatedPrices = (0, RfqtQuoteValidator_1.validateV2Prices)(prices, quoteContext, this._minExpiryDurationMs, now);
        return validatedPrices;
    }
    /**
     * Converts a price returned from the market maker's `price` endpoint
     * into an v2 order
     */
    _v2priceToOrder(price, txOrigin, nonce, nonceBucket = new utils_1.BigNumber(0)) {
        return new orders_1.OtcOrder({
            chainId: this._chainId,
            expiryAndNonce: orders_1.OtcOrder.encodeExpiryAndNonce(price.expiry, nonceBucket, nonce),
            maker: price.makerAddress,
            makerAmount: price.makerAmount,
            makerToken: price.makerToken,
            taker: constants_1.NULL_ADDRESS,
            takerAmount: price.takerAmount,
            takerToken: price.takerToken,
            txOrigin,
            verifyingContract: this._contractAddresses.exchangeProxy,
        });
    }
}
exports.RfqtService = RfqtService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9zZXJ2aWNlcy9SZnF0U2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7QUFDQSw4REFBNkQ7QUFFN0QsdURBSzRCO0FBRTVCLHFDQUFzQztBQUl0QyxpREFBZ0U7QUFDaEUsaURBQW1EO0FBVW5ELHNDQUFtQztBQUVuQyxvRUFBK0Q7QUFFL0Qsb0VBQXlGO0FBR3pGLDhEQUEyRTtBQU8zRSxNQUFNLHlCQUF5QixHQUFHLENBQUMsTUFBYyxFQUFFLE9BQWUsRUFBVSxFQUFFO0lBQzFFLE9BQVEsSUFBQSx5Q0FBd0IsRUFBQyxNQUFNLEVBQUUsT0FBTyxDQUFtQixDQUFDLFlBQVksQ0FBQztBQUNyRixDQUFDLENBQUM7QUFFRjs7O0dBR0c7QUFDSCxTQUFTLCtCQUErQixDQUFDLENBQWUsRUFBRSxHQUFRLEVBQUUsT0FBZTtJQUMvRSxNQUFNLGVBQWUsR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDO0lBQ3JDLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQztJQUN0QywwRUFBMEU7SUFDMUUsa0VBQWtFO0lBQ2xFLEVBQUU7SUFDRixzRUFBc0U7SUFDdEUsb0VBQW9FO0lBQ3BFLEVBQUU7SUFDRixnRkFBZ0Y7SUFDaEYsRUFBRTtJQUNGLDRDQUE0QztJQUM1Qyw2Q0FBNkM7SUFDN0MsTUFBTSxTQUFTLEdBQ1gsQ0FBQyxDQUFDLFNBQVMsS0FBSyxLQUFLO1FBQ2pCLENBQUMsQ0FBQztZQUNJLGtCQUFrQixFQUFFLENBQUMsQ0FBQyxlQUFlO1lBQ3JDLG1CQUFtQixFQUFFLFNBQVM7U0FDakM7UUFDSCxDQUFDLENBQUM7WUFDSSxpQkFBaUI7WUFDakIsa0JBQWtCLEVBQUUsU0FBUztZQUM3QixtQkFBbUIsRUFBRSxDQUFDLENBQUMsZUFBZTtTQUN6QyxDQUFDO0lBRVosTUFBTSxtQkFBbUIsR0FBRztRQUN4QixHQUFHLFNBQVM7UUFDWixlQUFlO1FBQ2YsZ0JBQWdCO1FBQ2hCLE9BQU87UUFDUCxT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QzlCLFVBQVUsRUFBRSxLQUFLLENBQUMsVUFBVTtZQUM1QixLQUFLLEVBQUUsd0JBQVk7WUFDbkIsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXO1lBQzlCLFVBQVUsRUFBRSxLQUFLLENBQUMsVUFBVTtZQUM1QixRQUFRO1lBQ1IsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWE7U0FDM0QsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztDQUNKO0FBOVlELGtDQThZQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvZGF2aWR3YWxzaC9jb2RlLWxvY2FsLzB4LXJmcS1hcGkvc3JjL3NlcnZpY2VzL1JmcXRTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFsdFJmcU1ha2VyQXNzZXRPZmZlcmluZ3MsIEFzc2V0U3dhcHBlckNvbnRyYWN0QWRkcmVzc2VzIH0gZnJvbSAnQDB4L2Fzc2V0LXN3YXBwZXIvbGliL3NyYy90eXBlcyc7XHJcbmltcG9ydCB7IE90Y09yZGVyIH0gZnJvbSAnQDB4L3Byb3RvY29sLXV0aWxzL2xpYi9zcmMvb3JkZXJzJztcclxuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnQDB4L3Byb3RvY29sLXV0aWxzL2xpYi9zcmMvc2lnbmF0dXJlX3V0aWxzJztcclxuaW1wb3J0IHtcclxuICAgIGdldFRva2VuTWV0YWRhdGFJZkV4aXN0cyxcclxuICAgIG5hdGl2ZVRva2VuU3ltYm9sLFxyXG4gICAgbmF0aXZlV3JhcHBlZFRva2VuU3ltYm9sLFxyXG4gICAgVG9rZW5NZXRhZGF0YSxcclxufSBmcm9tICdAMHgvdG9rZW4tbWV0YWRhdGEnO1xyXG5pbXBvcnQgeyBNYXJrZXRPcGVyYXRpb24gfSBmcm9tICdAMHgvdHlwZXMnO1xyXG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdAMHgvdXRpbHMnO1xyXG5pbXBvcnQgeyBQcm9kdWNlciBhcyBLYWZrYVByb2R1Y2VyIH0gZnJvbSAna2Fma2Fqcyc7XHJcblxyXG5pbXBvcnQgeyBJbnRlZ3JhdG9yIH0gZnJvbSAnLi4vY29uZmlnJztcclxuaW1wb3J0IHsgTlVMTF9BRERSRVNTLCBPTkVfU0VDT05EX01TIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMnO1xyXG5pbXBvcnQgeyBmZWVUb1N0b3JlZEZlZSB9IGZyb20gJy4uL2NvcmUvZmVlX3V0aWxzJztcclxuaW1wb3J0IHtcclxuICAgIEZlZSxcclxuICAgIEZlZU1vZGVsVmVyc2lvbixcclxuICAgIFF1b3RlU2VydmVyUHJpY2VQYXJhbXMsXHJcbiAgICBSZXF1aXJlT25seU9uZSxcclxuICAgIFJmcXRWMlByaWNlLFxyXG4gICAgUmZxdFYyUXVvdGUsXHJcbiAgICBTdG9yZWRGZWUsXHJcbn0gZnJvbSAnLi4vY29yZS90eXBlcyc7XHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL2xvZ2dlcic7XHJcbmltcG9ydCB7IFF1b3RlUmVxdWVzdG9yLCBTaWduZWROYXRpdmVPcmRlck1NLCBWNFJGUUluZGljYXRpdmVRdW90ZU1NIH0gZnJvbSAnLi4vcXVvdGVSZXF1ZXN0b3IvUXVvdGVSZXF1ZXN0b3InO1xyXG5pbXBvcnQgeyBxdW90ZVJlcG9ydFV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvcXVvdGVfcmVwb3J0X3V0aWxzJztcclxuaW1wb3J0IHsgUXVvdGVTZXJ2ZXJDbGllbnQgfSBmcm9tICcuLi91dGlscy9xdW90ZV9zZXJ2ZXJfY2xpZW50JztcclxuaW1wb3J0IHsgZ2V0UmZxdFYyRmlsbGFibGVBbW91bnRzLCB2YWxpZGF0ZVYyUHJpY2VzIH0gZnJvbSAnLi4vdXRpbHMvUmZxdFF1b3RlVmFsaWRhdG9yJztcclxuaW1wb3J0IHsgUmZxQmxvY2tjaGFpblV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvcmZxX2Jsb2NrY2hhaW5fdXRpbHMnO1xyXG5pbXBvcnQgeyBSZnFNYWtlck1hbmFnZXIgfSBmcm9tICcuLi91dGlscy9yZnFfbWFrZXJfbWFuYWdlcic7XHJcbmltcG9ydCB7IGdldFNpZ25lckZyb21IYXNoLCBwYWRTaWduYXR1cmUgfSBmcm9tICcuLi91dGlscy9zaWduYXR1cmVfdXRpbHMnO1xyXG5pbXBvcnQgeyBUb2tlbk1ldGFkYXRhTWFuYWdlciB9IGZyb20gJy4uL3V0aWxzL1Rva2VuTWV0YWRhdGFNYW5hZ2VyJztcclxuXHJcbmltcG9ydCB7IEZlZVNlcnZpY2UgfSBmcm9tICcuL2ZlZV9zZXJ2aWNlJztcclxuaW1wb3J0IHsgUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlIH0gZnJvbSAnLi9yZnFfbWFrZXJfYmFsYW5jZV9jYWNoZV9zZXJ2aWNlJztcclxuaW1wb3J0IHsgRmlybVF1b3RlQ29udGV4dCwgUXVvdGVDb250ZXh0IH0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG5jb25zdCBnZXRUb2tlbkFkZHJlc3NGcm9tU3ltYm9sID0gKHN5bWJvbDogc3RyaW5nLCBjaGFpbklkOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xyXG4gICAgcmV0dXJuIChnZXRUb2tlbk1ldGFkYXRhSWZFeGlzdHMoc3ltYm9sLCBjaGFpbklkKSBhcyBUb2tlbk1ldGFkYXRhKS50b2tlbkFkZHJlc3M7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIHBhcmFtZXRlcnMgb2YgYW4gUkZRdCB2MiBwcmljZXMgcmVxdWVzdCBmcm9tIDB4IEFQSVxyXG4gKiBpbnRvIHRoZSBmb3JtYXQgbmVlZGVkIGZvciBgUXVvdGVTZXJ2ZXJDbGllbnRgIHRvIGNhbGwgdGhlIG1hcmtldCBtYWtlcnNcclxuICovXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVJmcXRWMlByaWNlc1BhcmFtZXRlcnMocDogUXVvdGVDb250ZXh0LCBmZWU6IEZlZSwgY2hhaW5JZDogbnVtYmVyKTogUXVvdGVTZXJ2ZXJQcmljZVBhcmFtcyB7XHJcbiAgICBjb25zdCBidXlUb2tlbkFkZHJlc3MgPSBwLm1ha2VyVG9rZW47XHJcbiAgICBjb25zdCBzZWxsVG9rZW5BZGRyZXNzID0gcC50YWtlclRva2VuO1xyXG4gICAgLy8gVHlwZXNjcmlwdCBneW1uYXN0aWNzIHdpdGggYGJhc2VVbml0c2AgdG8gY2FwdXR1cmUgdGhlIFwib25lb2ZcIiBuYXR1cmUtLVxyXG4gICAgLy8gQnkgcGFja2FnaW5nIHRoZW0gaW4gdGhlaXIgb3duIGxpdHRsZSBvYmplY3QsIHRoZSB0eXBlIGJlY29tZXM6XHJcbiAgICAvL1xyXG4gICAgLy8geyBidXlBbW91bnRCYXNlVW5pdHM6IEJpZ051bWJlciwgc2VsbEFtb3VudEJhc2VVbml0czogdW5kZWZpbmVkIH0gfFxyXG4gICAgLy8geyBidXlBbW91bnRCYXNlVW5pdHM6IHVuZGVmaW5lZCwgc2VsbEFtb3VudEJhc2VVbml0czogQmlnTnVtYmVyIH1cclxuICAgIC8vXHJcbiAgICAvLyBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIG5vdCBwYWNrYWdpbmcgdGhlbSB0b2dldGhlciwgd2hlcmUgdGhlIHR5cGVzIHdvdWxkIGJlOlxyXG4gICAgLy9cclxuICAgIC8vIGJ1eUFtb3VudEJhc2VVbml0czogQmlnTnVtYmVyIHwgdW5kZWZpbmVkXHJcbiAgICAvLyBzZWxsQW1vdW50QmFzZVVuaXRzOiBCaWdOdW1iZXIgfCB1bmRlZmluZWRcclxuICAgIGNvbnN0IGJhc2VVbml0cyA9XHJcbiAgICAgICAgcC5pc1NlbGxpbmcgPT09IGZhbHNlXHJcbiAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICBidXlBbW91bnRCYXNlVW5pdHM6IHAuYXNzZXRGaWxsQW1vdW50LFxyXG4gICAgICAgICAgICAgICAgICBzZWxsQW1vdW50QmFzZVVuaXRzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIFNFTExcclxuICAgICAgICAgICAgICAgICAgYnV5QW1vdW50QmFzZVVuaXRzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgIHNlbGxBbW91bnRCYXNlVW5pdHM6IHAuYXNzZXRGaWxsQW1vdW50LFxyXG4gICAgICAgICAgICAgIH07XHJcblxyXG4gICAgY29uc3QgbW1SZXF1ZXN0UGFyYW1ldGVycyA9IHtcclxuICAgICAgICAuLi5iYXNlVW5pdHMsXHJcbiAgICAgICAgYnV5VG9rZW5BZGRyZXNzLFxyXG4gICAgICAgIHNlbGxUb2tlbkFkZHJlc3MsXHJcbiAgICAgICAgY2hhaW5JZCxcclxuICAgICAgICBmZWVBbW91bnQ6IGZlZS5hbW91bnQsXHJcbiAgICAgICAgZmVlVG9rZW46IGZlZS50b2tlbixcclxuICAgICAgICBpbnRlZ3JhdG9ySWQ6IHAuaW50ZWdyYXRvci5pbnRlZ3JhdG9ySWQsXHJcbiAgICAgICAgdGFrZXJBZGRyZXNzOiBwLnRha2VyQWRkcmVzcyxcclxuICAgICAgICB0eE9yaWdpbjogcC50eE9yaWdpbixcclxuICAgICAgICB0cmFkZXI6IHAudHJhZGVyLFxyXG4gICAgICAgIGdhc2xlc3M6IHAud29ya2Zsb3cgPT09ICdnYXNsZXNzLXJmcXQnLFxyXG4gICAgICAgIHByb3RvY29sVmVyc2lvbjogJzQnLCAvL2hhcmRjb2RlIC0gd2lsbCBicmVhayBzb21lIE1NcyBpZiBtaXNzaW5nIVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDb252ZXJ0IG1tUmVxdWVzdFBhcmFtZXRlcnMgdmFsdWVzIHRvIHN0cmluZ3NcclxuICAgIGNvbnN0IHN0cmluZ1BhcmFtZXRlcnMgPSAoKFxyXG4gICAgICAgIG86IHR5cGVvZiBtbVJlcXVlc3RQYXJhbWV0ZXJzLFxyXG4gICAgKTogUmVxdWlyZU9ubHlPbmU8XHJcbiAgICAgICAgUmVjb3JkPGtleW9mIHR5cGVvZiBtbVJlcXVlc3RQYXJhbWV0ZXJzLCBzdHJpbmc+LFxyXG4gICAgICAgICdidXlBbW91bnRCYXNlVW5pdHMnIHwgJ3NlbGxBbW91bnRCYXNlVW5pdHMnXHJcbiAgICA+ID0+IHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobykucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZTogeyB0b1N0cmluZzogKCkgPT4gc3RyaW5nIH0gfCB1bmRlZmluZWQgPSBvW2tleSBhcyBrZXlvZiB0eXBlb2YgbW1SZXF1ZXN0UGFyYW1ldGVyc107XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLnRvU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdWYWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHN0cmluZ1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB9LCB7fSBhcyBhbnkpO1xyXG4gICAgfSkobW1SZXF1ZXN0UGFyYW1ldGVycyk7XHJcblxyXG4gICAgcmV0dXJuIHN0cmluZ1BhcmFtZXRlcnM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb250YWlucyB0aGUgbG9naWMgdG8gaGFuZGxlIFJGUVQgVHJhZGVzLlxyXG4gKlxyXG4gKiBgXCJ2MVwiYCBmdW5jdGlvbnMgc3VwcG9ydCBgTWV0YVRyYW5zYWN0aW9uYCB0cmFkZXMgd2hpbGVcclxuICogYFwidjJcImAgZnVuY3Rpb25zICh3aWxsKSBzdXBwb3J0IGBPdGNPcmRlcmAgdHJhZGVzLlxyXG4gKlxyXG4gKiBgdjFgIHJlbGllcyBoZWF2aWx5IG9uIGBRdW90ZVJlcXVlc3RvcmAgd2hpY2ggaGFzIGJlZW4gY29waWVkIG92ZXJcclxuICogZnJvbSBgMHgvYXNzZXQtc3dhcHBlcmAuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmZxdFNlcnZpY2Uge1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfbmF0aXZlVG9rZW5TeW1ib2w6IHN0cmluZztcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX25hdGl2ZVRva2VuQWRkcmVzczogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfbmF0aXZlV3JhcHBlZFRva2VuU3ltYm9sOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9uYXRpdmVXcmFwcGVkVG9rZW5BZGRyZXNzOiBzdHJpbmc7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9jaGFpbklkOiBudW1iZXIsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfcmZxTWFrZXJNYW5hZ2VyOiBSZnFNYWtlck1hbmFnZXIsXHJcbiAgICAgICAgLy8gVXNlZCBmb3IgUkZRdCB2MSByZXF1ZXN0c1xyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX3F1b3RlUmVxdWVzdG9yOiBQaWNrPFxyXG4gICAgICAgICAgICBRdW90ZVJlcXVlc3RvcixcclxuICAgICAgICAgICAgJ3JlcXVlc3RSZnF0SW5kaWNhdGl2ZVF1b3Rlc0FzeW5jJyB8ICdyZXF1ZXN0UmZxdEZpcm1RdW90ZXNBc3luYycgfCAnZ2V0TWFrZXJVcmlGb3JTaWduYXR1cmUnXHJcbiAgICAgICAgPixcclxuICAgICAgICAvLyBVc2VkIGZvciBSRlF0IHYyIHJlcXVlc3RzXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfcXVvdGVTZXJ2ZXJDbGllbnQ6IFF1b3RlU2VydmVyQ2xpZW50LFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX21pbkV4cGlyeUR1cmF0aW9uTXM6IG51bWJlcixcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9ibG9ja2NoYWluVXRpbHM6IFJmcUJsb2NrY2hhaW5VdGlscyxcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF90b2tlbk1ldGFkYXRhTWFuYWdlcjogVG9rZW5NZXRhZGF0YU1hbmFnZXIsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfY29udHJhY3RBZGRyZXNzZXM6IEFzc2V0U3dhcHBlckNvbnRyYWN0QWRkcmVzc2VzLFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX2ZlZVNlcnZpY2U6IEZlZVNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfZmVlTW9kZWxWZXJzaW9uOiBGZWVNb2RlbFZlcnNpb24sXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfcmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlOiBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfa2Fma2FQcm9kdWNlcj86IEthZmthUHJvZHVjZXIsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfZmVlRXZlbnRUb3BpYz86IHN0cmluZyxcclxuICAgICkge1xyXG4gICAgICAgIHRoaXMuX25hdGl2ZVRva2VuU3ltYm9sID0gbmF0aXZlVG9rZW5TeW1ib2wodGhpcy5fY2hhaW5JZCk7XHJcbiAgICAgICAgdGhpcy5fbmF0aXZlVG9rZW5BZGRyZXNzID0gZ2V0VG9rZW5BZGRyZXNzRnJvbVN5bWJvbCh0aGlzLl9uYXRpdmVUb2tlblN5bWJvbCwgdGhpcy5fY2hhaW5JZCk7XHJcbiAgICAgICAgdGhpcy5fbmF0aXZlV3JhcHBlZFRva2VuU3ltYm9sID0gbmF0aXZlV3JhcHBlZFRva2VuU3ltYm9sKHRoaXMuX2NoYWluSWQpO1xyXG4gICAgICAgIHRoaXMuX25hdGl2ZVdyYXBwZWRUb2tlbkFkZHJlc3MgPSBnZXRUb2tlbkFkZHJlc3NGcm9tU3ltYm9sKHRoaXMuX25hdGl2ZVdyYXBwZWRUb2tlblN5bWJvbCwgdGhpcy5fY2hhaW5JZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXNzIHRocm91Z2ggdG8gYFF1b3RlUmVxdWVzdG9yOjpyZXF1ZXN0UmZxdEluZGljYXRpdmVRdW90ZXNBc3luY2AgdG8gZmV0Y2hcclxuICAgICAqIGluZGljYXRpdmUgcXVvdGVzIGZyb20gbWFya2V0IG1ha2Vycy5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgYnkgdGhpcyBwb2ludCwgMHggQVBJIHNob3VsZCBiZSBzZW5kaW5nIHRoZSBudWxsIGFkZHJlc3NcclxuICAgICAqIGFzIHRoZSBgdGFrZXJBZGRyZXNzYCBhbmQgdGhlIHRha2VyJ3MgYWRkcmVzcyBhcyB0aGUgYHR4T3JpZ2luYC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldFYxUHJpY2VzQXN5bmMocGFyYW1ldGVyczoge1xyXG4gICAgICAgIGFsdFJmcUFzc2V0T2ZmZXJpbmdzOiBBbHRSZnFNYWtlckFzc2V0T2ZmZXJpbmdzO1xyXG4gICAgICAgIGFzc2V0RmlsbEFtb3VudDogQmlnTnVtYmVyO1xyXG4gICAgICAgIGNvbXBhcmlzb25QcmljZTogQmlnTnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIG1ha2VyVG9rZW46IHN0cmluZztcclxuICAgICAgICBtYXJrZXRPcGVyYXRpb246IE1hcmtldE9wZXJhdGlvbjtcclxuICAgICAgICB0YWtlclRva2VuOiBzdHJpbmc7IC8vIGV4cGVjdCB0aGlzIHRvIGJlIE5VTExfQUREUkVTU1xyXG4gICAgICAgIHRha2VyQWRkcmVzczogc3RyaW5nO1xyXG4gICAgICAgIHR4T3JpZ2luPzogc3RyaW5nOyAvLyBleHBlY3QgdGhpcyB0byBiZSB0aGUgdGFrZXIgYWRkcmVzc1xyXG4gICAgICAgIGludGVudE9uRmlsbGluZzogYm9vbGVhbjtcclxuICAgICAgICBpbnRlZ3JhdG9yOiBJbnRlZ3JhdG9yO1xyXG4gICAgfSk6IFByb21pc2U8VjRSRlFJbmRpY2F0aXZlUXVvdGVNTVtdPiB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICBhbHRSZnFBc3NldE9mZmVyaW5ncyxcclxuICAgICAgICAgICAgYXNzZXRGaWxsQW1vdW50LFxyXG4gICAgICAgICAgICBjb21wYXJpc29uUHJpY2UsXHJcbiAgICAgICAgICAgIGludGVncmF0b3IsXHJcbiAgICAgICAgICAgIGludGVudE9uRmlsbGluZywgLy8gdHNsaW50OmRpc2FibGUtbGluZSBib29sZWFuLW5hbWluZ1xyXG4gICAgICAgICAgICBtYWtlclRva2VuLFxyXG4gICAgICAgICAgICBtYXJrZXRPcGVyYXRpb24sXHJcbiAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcclxuICAgICAgICAgICAgdGFrZXJUb2tlbixcclxuICAgICAgICAgICAgdHhPcmlnaW4sXHJcbiAgICAgICAgfSA9IHBhcmFtZXRlcnM7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9xdW90ZVJlcXVlc3Rvci5yZXF1ZXN0UmZxdEluZGljYXRpdmVRdW90ZXNBc3luYyhcclxuICAgICAgICAgICAgbWFrZXJUb2tlbixcclxuICAgICAgICAgICAgdGFrZXJUb2tlbixcclxuICAgICAgICAgICAgYXNzZXRGaWxsQW1vdW50LFxyXG4gICAgICAgICAgICBtYXJrZXRPcGVyYXRpb24sXHJcbiAgICAgICAgICAgIGNvbXBhcmlzb25QcmljZSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYWx0UmZxQXNzZXRPZmZlcmluZ3MsXHJcbiAgICAgICAgICAgICAgICBpbnRlZ3JhdG9yLFxyXG4gICAgICAgICAgICAgICAgaW50ZW50T25GaWxsaW5nLFxyXG4gICAgICAgICAgICAgICAgaXNJbmRpY2F0aXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaXNMYXN0TG9vazogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBtYWtlckVuZHBvaW50TWF4UmVzcG9uc2VUaW1lTXM6IDYwMCxcclxuICAgICAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcclxuICAgICAgICAgICAgICAgIHR4T3JpZ2luOiB0eE9yaWdpbiB8fCBOVUxMX0FERFJFU1MsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhc3MgdGhyb3VnaCB0byBgUXVvdGVSZXF1ZXN0b3I6OnJlcXVlc3RSZnF0RmlybVF1b3Rlc0FzeW5jYCB0byBmZXRjaFxyXG4gICAgICogZmlybSBxdW90ZXMgZnJvbSBtYXJrZXQgbWFrZXJzLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCBieSB0aGlzIHBvaW50LCAweCBBUEkgc2hvdWxkIGJlIHNlbmRpbmcgdGhlIG51bGwgYWRkcmVzc1xyXG4gICAgICogYXMgdGhlIGB0YWtlckFkZHJlc3NgIGFuZCB0aGUgdGFrZXIncyBhZGRyZXNzIGFzIHRoZSBgdHhPcmlnaW5gLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0VjFRdW90ZXNBc3luYyhwYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgYWx0UmZxQXNzZXRPZmZlcmluZ3M6IEFsdFJmcU1ha2VyQXNzZXRPZmZlcmluZ3M7XHJcbiAgICAgICAgYXNzZXRGaWxsQW1vdW50OiBCaWdOdW1iZXI7XHJcbiAgICAgICAgY29tcGFyaXNvblByaWNlOiBCaWdOdW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgaW50ZWdyYXRvcjogSW50ZWdyYXRvcjtcclxuICAgICAgICBpbnRlbnRPbkZpbGxpbmc6IGJvb2xlYW47XHJcbiAgICAgICAgbWFrZXJUb2tlbjogc3RyaW5nO1xyXG4gICAgICAgIG1hcmtldE9wZXJhdGlvbjogTWFya2V0T3BlcmF0aW9uO1xyXG4gICAgICAgIHRha2VyQWRkcmVzczogc3RyaW5nOyAvLyBleHBlY3QgdGhpcyB0byBiZSB0aGUgdGFrZXIgYWRkcmVzc1xyXG4gICAgICAgIHRha2VyVG9rZW46IHN0cmluZztcclxuICAgICAgICB0eE9yaWdpbjogc3RyaW5nO1xyXG4gICAgfSk6IFByb21pc2U8U2lnbmVkTmF0aXZlT3JkZXJNTVtdPiB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICBhbHRSZnFBc3NldE9mZmVyaW5ncyxcclxuICAgICAgICAgICAgYXNzZXRGaWxsQW1vdW50LFxyXG4gICAgICAgICAgICBjb21wYXJpc29uUHJpY2UsXHJcbiAgICAgICAgICAgIGludGVncmF0b3IsXHJcbiAgICAgICAgICAgIGludGVudE9uRmlsbGluZywgLy8gdHNsaW50OmRpc2FibGUtbGluZSBib29sZWFuLW5hbWluZ1xyXG4gICAgICAgICAgICBtYWtlclRva2VuLFxyXG4gICAgICAgICAgICBtYXJrZXRPcGVyYXRpb24sXHJcbiAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcclxuICAgICAgICAgICAgdGFrZXJUb2tlbixcclxuICAgICAgICAgICAgdHhPcmlnaW4sXHJcbiAgICAgICAgfSA9IHBhcmFtZXRlcnM7XHJcblxyXG4gICAgICAgIGNvbnN0IHF1b3RlcyA9IGF3YWl0IHRoaXMuX3F1b3RlUmVxdWVzdG9yLnJlcXVlc3RSZnF0RmlybVF1b3Rlc0FzeW5jKFxyXG4gICAgICAgICAgICBtYWtlclRva2VuLFxyXG4gICAgICAgICAgICB0YWtlclRva2VuLFxyXG4gICAgICAgICAgICBhc3NldEZpbGxBbW91bnQsXHJcbiAgICAgICAgICAgIG1hcmtldE9wZXJhdGlvbixcclxuICAgICAgICAgICAgY29tcGFyaXNvblByaWNlLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhbHRSZnFBc3NldE9mZmVyaW5ncyxcclxuICAgICAgICAgICAgICAgIGludGVncmF0b3IsXHJcbiAgICAgICAgICAgICAgICBpbnRlbnRPbkZpbGxpbmcsXHJcbiAgICAgICAgICAgICAgICBpc0luZGljYXRpdmU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaXNMYXN0TG9vazogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBtYWtlckVuZHBvaW50TWF4UmVzcG9uc2VUaW1lTXM6IDYwMCxcclxuICAgICAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcclxuICAgICAgICAgICAgICAgIHR4T3JpZ2luLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiBxdW90ZXMubWFwKChxKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5xLFxyXG4gICAgICAgICAgICAgICAgbWFrZXJVcmk6IHRoaXMuX3F1b3RlUmVxdWVzdG9yLmdldE1ha2VyVXJpRm9yU2lnbmF0dXJlKHEuc2lnbmF0dXJlKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFjY2VwdHMgZGF0YSBzZW50IGJ5IDB4IEFQSSBhbmQgZmV0Y2hlcyBwcmljZXMgZnJvbSBNYXJrZXQgTWFrZXJzXHJcbiAgICAgKiBjb25maWd1cmVkIG9uIHRoZSBnaXZlbiBwYWlyLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCBieSB0aGlzIHBvaW50LCAweCBBUEkgc2hvdWxkIGJlIHNlbmRpbmcgdGhlIG51bGwgYWRkcmVzc1xyXG4gICAgICogYXMgdGhlIGB0YWtlckFkZHJlc3NgIGFuZCB0aGUgdGFrZXIncyBhZGRyZXNzIGFzIHRoZSBgdHhPcmlnaW5gLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0VjJQcmljZXNBc3luYyhxdW90ZUNvbnRleHQ6IFF1b3RlQ29udGV4dCwgbm93OiBEYXRlID0gbmV3IERhdGUoKSk6IFByb21pc2U8UmZxdFYyUHJpY2VbXT4ge1xyXG4gICAgICAgIGNvbnN0IHsgZmVlV2l0aERldGFpbHM6IGZlZSB9ID0gYXdhaXQgdGhpcy5fZmVlU2VydmljZS5jYWxjdWxhdGVGZWVBc3luYyhxdW90ZUNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRWMlByaWNlc0ludGVybmFsQXN5bmMocXVvdGVDb250ZXh0LCBmZWUsIG5vdyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY2NlcHRzIGRhdGEgc2VudCBieSAweCBBUEkgYW5kIGZldGNoZXMgcXVvdGVzIGZyb20gbWFya2V0IG1ha2Vyc1xyXG4gICAgICogY29uZmlndXJlZCBvbiB0aGUgZ2l2ZW4gcGFpci5cclxuICAgICAqXHJcbiAgICAgKiBQcmVwYXJpbmcgcXVvdGVzIGlzIGEgdHdvIHN0ZXAgcHJvY2VzczpcclxuICAgICAqICAxLiBSZXF1ZXN0cyBhcmUgbWFkZSB0byB0aGUgbWFya2V0IG1ha2VycycgYC9wcmljZWAgZW5kcG9pbnQgdXNpbmdcclxuICAgICAqICAgICBsb2dpYyBzaW1pbGFyIHRvIHRoYXQgb2YgYGdldFYyUHJpY2VzQXN5bmNgXHJcbiAgICAgKiAgMi4gVmFsaWQgcHJpY2VzIGFyZSB0aGVuIHNlbnQgdG8gdGhlIG1hcmtldCBtYWtlcnMnIGAvc2lnbmBcclxuICAgICAqICAgICBlbmRwb2ludCB0byBnZXQgYSBzaWduZWQgcXVvdGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldFYyUXVvdGVzQXN5bmMocXVvdGVDb250ZXh0OiBGaXJtUXVvdGVDb250ZXh0LCBub3c6IERhdGUgPSBuZXcgRGF0ZSgpKTogUHJvbWlzZTxSZnF0VjJRdW90ZVtdPiB7XHJcbiAgICAgICAgY29uc3QgeyBmZWVXaXRoRGV0YWlsczogZmVlIH0gPSBhd2FpdCB0aGlzLl9mZWVTZXJ2aWNlLmNhbGN1bGF0ZUZlZUFzeW5jKHF1b3RlQ29udGV4dCk7XHJcbiAgICAgICAgY29uc3Qgc3RvcmVkRmVlOiBTdG9yZWRGZWUgPSBmZWVUb1N0b3JlZEZlZShmZWUpO1xyXG5cclxuICAgICAgICAvLyBUT0RPIChyaGlub2RhdmlkKTogcHV0IGEgbWV0ZXIgb24gdGhpcyByZXNwb25zZSB0aW1lXHJcbiAgICAgICAgY29uc3QgcHJpY2VzID0gYXdhaXQgdGhpcy5fZ2V0VjJQcmljZXNJbnRlcm5hbEFzeW5jKHF1b3RlQ29udGV4dCwgZmVlLCBub3cpO1xyXG5cclxuICAgICAgICAvLyBJZiBtdWx0aXBsZSBxdW90ZXMgYXJlIGFnZ3JlZ2F0ZWQgaW50byB0aGUgZmluYWwgb3JkZXIsIHRoZXkgbXVzdFxyXG4gICAgICAgIC8vIGFsbCBoYXZlIHVuaXF1ZSBub25jZXMuIE90aGVyd2lzZSB0aGV5J2xsIGJlIHJlamVjdGVkIGJ5IHRoZSBzbWFydCBjb250cmFjdC5cclxuICAgICAgICBjb25zdCBiYXNlTm9uY2UgPSBuZXcgQmlnTnVtYmVyKE1hdGguZmxvb3Iobm93LmdldFRpbWUoKSAvIE9ORV9TRUNPTkRfTVMpKTtcclxuICAgICAgICBjb25zdCBwcmljZXNBbmRPcmRlcnMgPSBwcmljZXMubWFwKChwcmljZSwgaSkgPT4gKHtcclxuICAgICAgICAgICAgb3JkZXI6IHRoaXMuX3YycHJpY2VUb09yZGVyKHByaWNlLCBxdW90ZUNvbnRleHQudHhPcmlnaW4sIGJhc2VOb25jZS5wbHVzKGkpKSxcclxuICAgICAgICAgICAgcHJpY2UsXHJcbiAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICBjb25zdCBwcmljZXNBbmRPcmRlcnNBbmRTaWduYXR1cmVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgICAgICAgIHByaWNlc0FuZE9yZGVycy5tYXAoYXN5bmMgKHsgcHJpY2UsIG9yZGVyIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBzaWduYXR1cmU6IFNpZ25hdHVyZSB8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJIYXNoID0gb3JkZXIuZ2V0SGFzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuX3F1b3RlU2VydmVyQ2xpZW50LnNpZ25WMkFzeW5jKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZS5tYWtlclVyaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGVDb250ZXh0LmludGVncmF0b3IuaW50ZWdyYXRvcklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG9yZGVyLCBvcmRlckhhc2gsIGV4cGlyeTogcHJpY2UuZXhwaXJ5LCBmZWUgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHU6IHN0cmluZykgPT4gYCR7dX0vcmZxdC92Mi9zaWduYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogcmVxdWlyZVByb2NlZWRXaXRoRmlsbCAqLyBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbmF0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENlcnRhaW4gbWFya2V0IG1ha2VycyBhcmUgcmV0dXJuaW5nIHNpZ25hdHVyZSBjb21wb25lbnRzIHdoaWNoIGFyZSBtaXNzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlYWRpbmcgYnl0ZXMuIEFkZCB0aGVtIGlmIHRoZXkgZG9uJ3QgZXhpc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRlZFNpZ25hdHVyZSA9IHBhZFNpZ25hdHVyZShzaWduYXR1cmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFkZGVkU2lnbmF0dXJlLnIgIT09IHNpZ25hdHVyZS5yIHx8IHBhZGRlZFNpZ25hdHVyZS5zICE9PSBzaWduYXR1cmUucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBvcmRlckhhc2gsIHI6IHBhZGRlZFNpZ25hdHVyZS5yLCBzOiBwYWRkZWRTaWduYXR1cmUucyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdHb3QgbWFya2V0IG1ha2VyIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgYnl0ZXMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSA9IHBhZGRlZFNpZ25hdHVyZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoZSBzaWduZXIgd2FzIHRoZSBtYWtlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduZXJBZGRyZXNzID0gZ2V0U2lnbmVyRnJvbUhhc2gob3JkZXJIYXNoLCBzaWduYXR1cmUpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ha2VyQWRkcmVzcyA9IG9yZGVyLm1ha2VyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWduZXJBZGRyZXNzICE9PSBtYWtlckFkZHJlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRTaWduZXIgPSBhd2FpdCB0aGlzLl9ibG9ja2NoYWluVXRpbHMuaXNWYWxpZE9yZGVyU2lnbmVyQXN5bmMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lckFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkU2lnbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc2lnbmVyQWRkcmVzcywgbWFrZXJBZGRyZXNzLCBvcmRlckhhc2gsIG1ha2VyVXJpOiBwcmljZS5tYWtlclVyaSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBtYWtlciBzaWduYXR1cmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFF1b3RlcyB3aXRoIGB1bmRlZmluZWRgIHNpZ25hdHVyZSB3aWxsIGJlIGZpbHRlcmVkIG91dCBsYXRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBvcmRlckhhc2g6IG9yZGVyLmdldEhhc2goKSwgbWFrZXJJZDogcHJpY2UubWFrZXJJZCB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIHRyeWluZyB0byBnZXQgcmZxdCBzaWduYXR1cmUgZnJvbSBtYXJrZXQgbWFrZXInLFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHByaWNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlID8/IG51bGwsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyAoTWFrZXIgQmFsYW5jZSBDYWNoZSkgRmV0Y2ggbWFrZXIgYmFsYW5jZXMgdG8gY2FsY3VsYXRlIGZpbGxhYmxlIGFtb3VudHNcclxuICAgICAgICBsZXQgcXVvdGVkTWFrZXJCYWxhbmNlczogQmlnTnVtYmVyW10gfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgcXVvdGVkRVJDMjBPd25lcnMgPSBwcmljZXMubWFwKChwcmljZSkgPT4gKHtcclxuICAgICAgICAgICAgb3duZXI6IHByaWNlLm1ha2VyQWRkcmVzcyxcclxuICAgICAgICAgICAgdG9rZW46IHByaWNlLm1ha2VyVG9rZW4sXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHF1b3RlZE1ha2VyQmFsYW5jZXMgPSBhd2FpdCB0aGlzLl9yZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UuZ2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmMoXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbklkLFxyXG4gICAgICAgICAgICAgICAgcXVvdGVkRVJDMjBPd25lcnMsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICB7IGNoYWluSWQ6IHRoaXMuX2NoYWluSWQsIHF1b3RlZEVSQzIwT3duZXJzLCBlcnJvck1lc3NhZ2U6IGUubWVzc2FnZSB9LFxyXG4gICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBmZXRjaCBtYWtlciBiYWxhbmNlcyB0byBjYWxjdWxhdGUgZmlsbGFibGUgYW1vdW50cycsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBmaWxsYWJsZUFtb3VudHMgPSBnZXRSZnF0VjJGaWxsYWJsZUFtb3VudHMocHJpY2VzLCB0aGlzLl9jaGFpbklkLCBxdW90ZWRNYWtlckJhbGFuY2VzKTtcclxuXHJcbiAgICAgICAgY29uc3QgcXVvdGVzID0gcHJpY2VzQW5kT3JkZXJzQW5kU2lnbmF0dXJlc1xyXG4gICAgICAgICAgICAuZmlsdGVyKChwb3MpID0+IHBvcy5zaWduYXR1cmUpXHJcbiAgICAgICAgICAgIC5tYXAoKHsgcHJpY2UsIG9yZGVyLCBzaWduYXR1cmUgfSwgaSkgPT4gKHtcclxuICAgICAgICAgICAgICAgIC4uLmZpbGxhYmxlQW1vdW50c1tpXSxcclxuICAgICAgICAgICAgICAgIGZpbGxhYmxlVGFrZXJGZWVBbW91bnQ6IG5ldyBCaWdOdW1iZXIoMCksXHJcbiAgICAgICAgICAgICAgICBtYWtlcklkOiBwcmljZS5tYWtlcklkLFxyXG4gICAgICAgICAgICAgICAgbWFrZXJVcmk6IHByaWNlLm1ha2VyVXJpLFxyXG4gICAgICAgICAgICAgICAgb3JkZXIsXHJcbiAgICAgICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUhLCAvLyBgbnVsbGAgc2lnbmF0dXJlcyBhbHJlYWR5IGZpbHRlcmVkIG91dFxyXG4gICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIC8vIFdyaXRlIHRvIEZlZSBFdmVudCBSZXBvcnRcclxuICAgICAgICBpZiAodGhpcy5fa2Fma2FQcm9kdWNlcikge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgcXVvdGVSZXBvcnRVdGlscy5wdWJsaXNoUmZxdFYyRmVlRXZlbnQoXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRCdXlBbW91bnQ6IHF1b3RlQ29udGV4dC5tYWtlckFtb3VudCA/PyBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRTZWxsQW1vdW50OiBxdW90ZUNvbnRleHQudGFrZXJBbW91bnQgPz8gbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkVGFrZXJBZGRyZXNzOiBxdW90ZUNvbnRleHQudGFrZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidXlUb2tlbkFkZHJlc3M6IHF1b3RlQ29udGV4dC5tYWtlclRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxsVG9rZW5BZGRyZXNzOiBxdW90ZUNvbnRleHQudGFrZXJUb2tlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZWdyYXRvcklkOiBxdW90ZUNvbnRleHQuaW50ZWdyYXRvci5pbnRlZ3JhdG9ySWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVlOiBzdG9yZWRGZWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rYWZrYVByb2R1Y2VyLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZlZUV2ZW50VG9waWMsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiB0aGlzLl9jaGFpbklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRCdXlBbW91bnQ6IHF1b3RlQ29udGV4dC5tYWtlckFtb3VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkU2VsbEFtb3VudDogcXVvdGVDb250ZXh0LnRha2VyQW1vdW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRUYWtlckFkZHJlc3M6IHF1b3RlQ29udGV4dC50YWtlckFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1eVRva2VuQWRkcmVzczogcXVvdGVDb250ZXh0Lm1ha2VyVG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGxUb2tlbkFkZHJlc3M6IHF1b3RlQ29udGV4dC50YWtlclRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhdG9ySWQ6IHF1b3RlQ29udGV4dC5pbnRlZ3JhdG9yLmludGVncmF0b3JJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBlLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIHB1Ymxpc2ggUkZRdCBxdW90ZSB0byBGZWUgRXZlbnQgUmVwb3J0JyxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBxdW90ZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBmZWVNb2RlbFZlcnNpb24oKTogRmVlTW9kZWxWZXJzaW9uIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmVlTW9kZWxWZXJzaW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFzc3Rocm91Z2ggdG8gVG9rZW5NZXRhZGF0YU1hbmFnZXIncyBgZ2V0VG9rZW5EZWNpbWFsc0FzeW5jYCBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldFRva2VuRGVjaW1hbHNBc3luYyh0b2tlbkFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuTWV0YWRhdGFNYW5hZ2VyLmdldFRva2VuRGVjaW1hbHNBc3luYyh0b2tlbkFkZHJlc3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHByaWNlcyBmcm9tIE1NcyBmb3IgZ2l2ZW4gcXVvdGUgY29udGV4dCBhbmQgZmVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgX2dldFYyUHJpY2VzSW50ZXJuYWxBc3luYyhcclxuICAgICAgICBxdW90ZUNvbnRleHQ6IFF1b3RlQ29udGV4dCxcclxuICAgICAgICBmZWU6IEZlZSxcclxuICAgICAgICBub3c6IERhdGUgPSBuZXcgRGF0ZSgpLFxyXG4gICAgKTogUHJvbWlzZTxSZnF0VjJQcmljZVtdPiB7XHJcbiAgICAgICAgY29uc3QgeyBpbnRlZ3JhdG9yLCBtYWtlclRva2VuLCB0YWtlclRva2VuIH0gPSBxdW90ZUNvbnRleHQ7XHJcbiAgICAgICAgLy8gRmV0Y2ggdGhlIG1ha2VycyBhY3RpdmUgb24gdGhpcyBwYWlyXHJcbiAgICAgICAgY29uc3QgbWFrZXJzID0gdGhpcy5fcmZxTWFrZXJNYW5hZ2VyLmdldFJmcXRWMk1ha2Vyc0ZvclBhaXIobWFrZXJUb2tlbiwgdGFrZXJUb2tlbikuZmlsdGVyKChtKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtLnJmcXRVcmkgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaW50ZWdyYXRvci53aGl0ZWxpc3RNYWtlcklkcyAmJiAhaW50ZWdyYXRvci53aGl0ZWxpc3RNYWtlcklkcy5pbmNsdWRlcyhtLm1ha2VySWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgbm8gbWFrZXJzIGFyZSBhY3RpdmVcclxuICAgICAgICBpZiAoIW1ha2Vycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVE9ETyAoaGFvemh1byk6IGNoZWNrIHRvIHNlZSBpZiBNTSBwYXNzZXMgY2lyY3VpdCBicmVha2VyXHJcblxyXG4gICAgICAgIGNvbnN0IHByaWNlcyA9IChcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcXVvdGVTZXJ2ZXJDbGllbnQuYmF0Y2hHZXRQcmljZVYyQXN5bmMoXHJcbiAgICAgICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgICAgICAgICAgICAgbWFrZXJzLm1hcCgobSkgPT4gLyogd29uJ3QgYmUgbnVsbCBiZWNhdXNlIG9mIHByZXZpb3VzIGBmaWx0ZXJgIG9wZXJhdGlvbiAqLyBtLnJmcXRVcmkhKSxcclxuICAgICAgICAgICAgICAgIGludGVncmF0b3IsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1SZnF0VjJQcmljZXNQYXJhbWV0ZXJzKHF1b3RlQ29udGV4dCwgZmVlLCB0aGlzLl9jaGFpbklkKSxcclxuICAgICAgICAgICAgICAgICh1cmwpID0+IGAke3VybH0vcmZxdC92Mi9wcmljZWAsXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICApLm1hcCgocHJpY2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWFrZXIgPSBtYWtlcnMuZmluZCgobSkgPT4gbS5yZnF0VXJpID09PSBwcmljZS5tYWtlclVyaSk7XHJcbiAgICAgICAgICAgIGlmICghbWFrZXIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgbWFrZXIgd2l0aCBVUkkgJHtwcmljZS5tYWtlclVyaX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZXhwaXJ5OiBwcmljZS5leHBpcnksXHJcbiAgICAgICAgICAgICAgICBtYWtlckFkZHJlc3M6IHByaWNlLm1ha2VyLFxyXG4gICAgICAgICAgICAgICAgbWFrZXJBbW91bnQ6IHByaWNlLm1ha2VyQW1vdW50LFxyXG4gICAgICAgICAgICAgICAgbWFrZXJJZDogbWFrZXIubWFrZXJJZCxcclxuICAgICAgICAgICAgICAgIG1ha2VyVG9rZW46IHByaWNlLm1ha2VyVG9rZW4sXHJcbiAgICAgICAgICAgICAgICBtYWtlclVyaTogcHJpY2UubWFrZXJVcmksXHJcbiAgICAgICAgICAgICAgICB0YWtlckFtb3VudDogcHJpY2UudGFrZXJBbW91bnQsXHJcbiAgICAgICAgICAgICAgICB0YWtlclRva2VuOiBwcmljZS50YWtlclRva2VuLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBGaWx0ZXIgb3V0IGludmFsaWQgcHJpY2VzXHJcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkUHJpY2VzID0gdmFsaWRhdGVWMlByaWNlcyhwcmljZXMsIHF1b3RlQ29udGV4dCwgdGhpcy5fbWluRXhwaXJ5RHVyYXRpb25Ncywgbm93KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZFByaWNlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgcHJpY2UgcmV0dXJuZWQgZnJvbSB0aGUgbWFya2V0IG1ha2VyJ3MgYHByaWNlYCBlbmRwb2ludFxyXG4gICAgICogaW50byBhbiB2MiBvcmRlclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF92MnByaWNlVG9PcmRlcihcclxuICAgICAgICBwcmljZTogUmZxdFYyUHJpY2UsXHJcbiAgICAgICAgdHhPcmlnaW46IHN0cmluZyxcclxuICAgICAgICBub25jZTogQmlnTnVtYmVyLFxyXG4gICAgICAgIG5vbmNlQnVja2V0OiBCaWdOdW1iZXIgPSBuZXcgQmlnTnVtYmVyKDApLFxyXG4gICAgKTogT3RjT3JkZXIge1xyXG4gICAgICAgIHJldHVybiBuZXcgT3RjT3JkZXIoe1xyXG4gICAgICAgICAgICBjaGFpbklkOiB0aGlzLl9jaGFpbklkLFxyXG4gICAgICAgICAgICBleHBpcnlBbmROb25jZTogT3RjT3JkZXIuZW5jb2RlRXhwaXJ5QW5kTm9uY2UocHJpY2UuZXhwaXJ5LCBub25jZUJ1Y2tldCwgbm9uY2UpLFxyXG4gICAgICAgICAgICBtYWtlcjogcHJpY2UubWFrZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICBtYWtlckFtb3VudDogcHJpY2UubWFrZXJBbW91bnQsXHJcbiAgICAgICAgICAgIG1ha2VyVG9rZW46IHByaWNlLm1ha2VyVG9rZW4sXHJcbiAgICAgICAgICAgIHRha2VyOiBOVUxMX0FERFJFU1MsXHJcbiAgICAgICAgICAgIHRha2VyQW1vdW50OiBwcmljZS50YWtlckFtb3VudCxcclxuICAgICAgICAgICAgdGFrZXJUb2tlbjogcHJpY2UudGFrZXJUb2tlbixcclxuICAgICAgICAgICAgdHhPcmlnaW4sXHJcbiAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiB0aGlzLl9jb250cmFjdEFkZHJlc3Nlcy5leGNoYW5nZVByb3h5LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbiJdLCJ2ZXJzaW9uIjozfQ==