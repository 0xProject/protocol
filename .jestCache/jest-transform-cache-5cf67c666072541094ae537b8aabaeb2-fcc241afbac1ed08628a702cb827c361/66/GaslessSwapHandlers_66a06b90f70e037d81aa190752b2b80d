5a1b2ec7b751987bd15aba8b66bb6b9c
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GaslessSwapHandlers = void 0;
// tslint:disable:max-file-line-count
const api_utils_1 = require("@0x/api-utils");
const protocol_utils_1 = require("@0x/protocol-utils");
const token_metadata_1 = require("@0x/token-metadata");
const utils_1 = require("@0x/utils");
const HttpStatus = require("http-status-codes");
const prom_client_1 = require("prom-client");
const schemas_1 = require("../core/schemas");
const types_1 = require("../core/types");
const rfqm_health_check_1 = require("../utils/rfqm_health_check");
const rfqm_request_utils_1 = require("../utils/rfqm_request_utils");
const schema_utils_1 = require("../core/schema_utils");
const constants_1 = require("../core/constants");
// Minimum slippage allowed. This value should be kept consistent with the value set in 0x-api
const MIN_ALLOWED_SLIPPAGE = 0.001; // 0.1%
// If the cache is more milliseconds old than the value specified here, it will be refreshed.
const HEALTH_CHECK_RESULT_CACHE_DURATION_MS = 30000;
const ZEROG_GASLESS_SWAP_REQUEST = new prom_client_1.Counter({
    name: 'zerog_gasless_swap_request_total',
    help: 'Number of requests of a gasless swap endpoint',
    labelNames: ['chainId', 'integratorLabel', 'endpoint'],
});
const ZEROG_GASLESS_SWAP_REQUEST_ERROR = new prom_client_1.Counter({
    name: 'zerog_gasless_swap_request_error',
    help: 'Number of request errors of a gasless swap endpoint',
    labelNames: ['chainId', 'integratorLabel', 'endpoint'],
});
/**
 * Logic to bridge Gasless Swap API requests to the `GaslessSwapService` and translate
 * results from the `GaslessSwapService` back to API responses.
 */
class GaslessSwapHandlers {
    constructor(_gaslessSwapServices, _configManager) {
        this._gaslessSwapServices = _gaslessSwapServices;
        this._configManager = _configManager;
        this._cachedHealthCheckResultByChainId = new Map();
    }
    /**
     * Handler for the /price endpoint
     */
    async getPriceAsync(req, res) {
        const metaTransactionType = getMetaTransactionType(req.baseUrl);
        const { chainId, params } = await this._parsePriceParamsAsync(req, metaTransactionType);
        // Consistent with `rfqm_handlers`: not all requests are emitted if they fail parsing
        ZEROG_GASLESS_SWAP_REQUEST.inc({
            chainId,
            integratorLabel: params.integrator.label,
            endpoint: '/price',
        });
        let price;
        try {
            price = await this._getServiceForChain(chainId).fetchPriceAsync(params);
        }
        catch (err) {
            ZEROG_GASLESS_SWAP_REQUEST_ERROR.inc({
                chainId,
                integratorLabel: params.integrator.label,
                endpoint: '/price',
            });
            throw err;
        }
        // Result
        res.status(HttpStatus.OK).send({
            liquidityAvailable: price !== null,
            ...price,
        });
    }
    /**
     * Handler for the /quote endpoint
     */
    async getQuoteAsync(req, res) {
        const metaTransactionType = getMetaTransactionType(req.baseUrl);
        // Parse request
        const { chainId, params } = await this._parseFetchFirmQuoteParamsAsync(req, metaTransactionType);
        // Consistent with `rfqm_handlers`: not all requests are emitted if they fail parsing
        ZEROG_GASLESS_SWAP_REQUEST.inc({
            chainId,
            integratorLabel: params.integrator.label,
            endpoint: '/quote',
        });
        let quote;
        try {
            quote = await this._getServiceForChain(chainId).fetchQuoteAsync(params);
        }
        catch (err) {
            ZEROG_GASLESS_SWAP_REQUEST_ERROR.inc({
                chainId,
                integratorLabel: params.integrator.label,
                endpoint: '/quote',
            });
            throw err;
        }
        // Result
        res.status(HttpStatus.OK).send({
            liquidityAvailable: quote !== null,
            ...quote,
        });
    }
    /**
     * Handler for the `/healthz` endpoint.
     */
    async getHealthAsync(req, res) {
        const chainId = extractChainId(req, this._gaslessSwapServices);
        const cachedResult = this._cachedHealthCheckResultByChainId.get(chainId);
        let result;
        if (!cachedResult) {
            result = await this._getServiceForChain(chainId).runHealthCheckAsync();
            this._cachedHealthCheckResultByChainId.set(chainId, [result, new Date()]);
        }
        else {
            const cacheAgeMs = Date.now() - cachedResult[1].getTime();
            if (cacheAgeMs >= HEALTH_CHECK_RESULT_CACHE_DURATION_MS) {
                result = await this._getServiceForChain(chainId).runHealthCheckAsync();
                this._cachedHealthCheckResultByChainId.set(chainId, [result, new Date()]);
            }
            else {
                result = cachedResult[0];
            }
        }
        const response = (0, rfqm_health_check_1.transformResultToShortResponse)(result);
        res.status(HttpStatus.OK).send(response);
    }
    /**
     * Handler for the /status/:hash endpoint
     */
    async getStatusAsync(req, res) {
        const chainId = extractChainId(req, this._gaslessSwapServices);
        const { hash } = req.params;
        const status = await this._getServiceForChain(chainId).getStatusAsync(hash);
        status ? res.status(HttpStatus.OK).send(status) : res.status(HttpStatus.NOT_FOUND).send();
    }
    /**
     * Handler for the /submit endpoint
     */
    async processSubmitAsync(req, res) {
        const { chainId, integrator, params } = this._parseSubmitParams(req);
        // Consistent with `rfqm_handlers`: not all requests are emitted if they fail parsing
        ZEROG_GASLESS_SWAP_REQUEST.inc({
            chainId,
            integratorLabel: integrator.label,
            endpoint: '/submit',
        });
        try {
            const response = await this._getServiceForChain(chainId).processSubmitAsync(params, integrator.integratorId);
            res.status(HttpStatus.CREATED).send(response);
        }
        catch (err) {
            ZEROG_GASLESS_SWAP_REQUEST_ERROR.inc({
                chainId,
                integratorLabel: integrator.label,
                endpoint: '/submit',
            });
            req.log.error(err, 'Encountered an error while queuing a signed quote');
            if ((0, api_utils_1.isAPIError)(err)) {
                throw err;
            }
            else {
                throw new api_utils_1.InternalServerError(`An unexpected error occurred`);
            }
        }
    }
    async _parseFetchFirmQuoteParamsAsync(req, metaTransactionType) {
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        schema_utils_1.schemaUtils.validateSchema(req.query, schemas_1.schemas.firmQuoteRequestSchema);
        const takerAddress = req.query.takerAddress;
        const shouldCheckApproval = req.query.checkApproval === 'true' ? true : false;
        const { chainId, params } = await this._parseIndicativeAndFirmQuoteSharedParamsAsync(req, metaTransactionType);
        if (!utils_1.addressUtils.isAddress(takerAddress)) {
            throw new api_utils_1.ValidationError([
                {
                    field: 'takerAddress',
                    code: api_utils_1.ValidationErrorCodes.InvalidAddress,
                    reason: `Must provide a valid takerAddress`,
                },
            ]);
        }
        return {
            chainId,
            params: {
                ...params,
                takerAddress: takerAddress,
                checkApproval: shouldCheckApproval,
            },
        };
    }
    _getServiceForChain(chainId) {
        const service = this._gaslessSwapServices.get(chainId);
        if (!service) {
            throw new Error('No configuration exists for chain');
        }
        return service;
    }
    /**
     * Examines the API key provided in the request, ensures it is valid for RFQM, and fetches the associated
     * integrator ID.
     */
    _validateApiKey(apiKey, chainId) {
        if (apiKey === undefined) {
            throw new api_utils_1.InvalidAPIKeyError('Must access with an API key');
        }
        if (!this._configManager.getRfqmApiKeyWhitelist().has(apiKey)) {
            throw new api_utils_1.InvalidAPIKeyError('API key not authorized for RFQM access');
        }
        const integratorId = this._configManager.getIntegratorIdForApiKey(apiKey);
        if (!integratorId) {
            // With a valid configuration this should never happen
            throw new api_utils_1.InvalidAPIKeyError('API key has no associated Integrator ID');
        }
        const integrator = this._configManager.getIntegratorByIdOrThrow(integratorId);
        if (!integrator.allowedChainIds.includes(chainId)) {
            throw new api_utils_1.InvalidAPIKeyError(`API Key not authorized to access chain ${chainId}`);
        }
        return { apiKey, integrator };
    }
    async _parsePriceParamsAsync(req, metaTransactionType) {
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        schema_utils_1.schemaUtils.validateSchema(req.query, schemas_1.schemas.indicativeQuoteRequestSchema);
        const { takerAddress } = req.query;
        const { chainId, params } = await this._parseIndicativeAndFirmQuoteSharedParamsAsync(req, metaTransactionType);
        return {
            chainId,
            params: {
                ...params,
                takerAddress: takerAddress,
            },
        };
    }
    /**
     * Parse shared params of indicative and firm quotes
     */
    async _parseIndicativeAndFirmQuoteSharedParamsAsync(req, metaTransactionType) {
        const chainId = extractChainId(req, this._gaslessSwapServices);
        const { integrator } = this._validateApiKey(req.header('0x-api-key'), chainId);
        const { affiliateAddress } = req.query;
        // Parse tokens
        const sellTokenRaw = req.query.sellToken;
        const buyTokenRaw = req.query.buyToken;
        validateNotNativeTokenOrThrow(sellTokenRaw, chainId, 'sellToken');
        let buyTokenDecimals;
        let sellTokenDecimals;
        let buyTokenContractAddress;
        let sellTokenContractAddress;
        try {
            buyTokenContractAddress = buyTokenRaw.toLocaleLowerCase().startsWith('0x')
                ? buyTokenRaw
                : contractAddressForSymbol(buyTokenRaw, chainId);
            buyTokenDecimals = await this._getServiceForChain(chainId).getTokenDecimalsAsync(buyTokenRaw);
        }
        catch (e) {
            throw new api_utils_1.ValidationError([
                {
                    field: 'buyToken',
                    code: api_utils_1.ValidationErrorCodes.AddressNotSupported,
                    reason: `Token ${buyTokenRaw} is currently unsupported`,
                },
            ]);
        }
        try {
            sellTokenContractAddress = sellTokenRaw.toLocaleLowerCase().startsWith('0x')
                ? sellTokenRaw
                : contractAddressForSymbol(sellTokenRaw, chainId);
            sellTokenDecimals = await this._getServiceForChain(chainId).getTokenDecimalsAsync(sellTokenRaw);
        }
        catch {
            throw new api_utils_1.ValidationError([
                {
                    field: 'sellToken',
                    code: api_utils_1.ValidationErrorCodes.AddressNotSupported,
                    reason: `Token ${sellTokenRaw} is currently unsupported`,
                },
            ]);
        }
        // Parse number params
        const sellAmount = req.query.sellAmount === undefined ? undefined : new utils_1.BigNumber(req.query.sellAmount);
        const buyAmount = req.query.buyAmount === undefined ? undefined : new utils_1.BigNumber(req.query.buyAmount);
        const slippagePercentage = req.query.slippagePercentage === undefined
            ? undefined
            : new utils_1.BigNumber(req.query.slippagePercentage);
        let feeType;
        let feeSellTokenPercentage;
        let feeRecipient;
        if (metaTransactionType === types_1.GaslessTypes.MetaTransaction) {
            if ((slippagePercentage === null || slippagePercentage === void 0 ? void 0 : slippagePercentage.lt(MIN_ALLOWED_SLIPPAGE)) || (slippagePercentage === null || slippagePercentage === void 0 ? void 0 : slippagePercentage.gt(1))) {
                throw new api_utils_1.ValidationError([
                    {
                        field: 'slippagePercentage',
                        code: api_utils_1.ValidationErrorCodes.ValueOutOfRange,
                        reason: `slippagePercentage ${slippagePercentage} is out of range`,
                    },
                ]);
            }
        }
        else if (metaTransactionType === types_1.GaslessTypes.MetaTransactionV2) {
            // slippage percentage of gasless v1 is on scale of 100 which is what percentage means (a fix from zero-g)
            if ((slippagePercentage === null || slippagePercentage === void 0 ? void 0 : slippagePercentage.lt(MIN_ALLOWED_SLIPPAGE * 100)) || (slippagePercentage === null || slippagePercentage === void 0 ? void 0 : slippagePercentage.gt(100))) {
                throw new api_utils_1.ValidationError([
                    {
                        field: 'slippagePercentage',
                        code: api_utils_1.ValidationErrorCodes.ValueOutOfRange,
                        reason: `slippagePercentage ${slippagePercentage} is out of range`,
                    },
                ]);
            }
            if (req.query.feeType) {
                if (req.query.feeType !== 'volume') {
                    throw new api_utils_1.ValidationError([
                        {
                            field: 'feeType',
                            code: api_utils_1.ValidationErrorCodes.IncorrectFormat,
                            reason: `feeType ${req.query.feeType} is of wrong format`,
                        },
                    ]);
                }
                feeType = 'volume';
                if (req.query.feeSellTokenPercentage === undefined) {
                    throw new api_utils_1.ValidationError([
                        {
                            field: 'feeSellTokenPercentage',
                            code: api_utils_1.ValidationErrorCodes.RequiredField,
                            reason: `feeSellTokenPercentage is a required field when feeType ${feeType} is specified`,
                        },
                    ]);
                }
                feeSellTokenPercentage = new utils_1.BigNumber(req.query.feeSellTokenPercentage);
                if (feeSellTokenPercentage.lt(0) || feeSellTokenPercentage.gte(100)) {
                    throw new api_utils_1.ValidationError([
                        {
                            field: 'feeSellTokenPercentage',
                            code: api_utils_1.ValidationErrorCodes.ValueOutOfRange,
                            reason: `feeSellTokenPercentage ${feeSellTokenPercentage} is out of range`,
                        },
                    ]);
                }
                if (req.query.feeRecipient === undefined) {
                    throw new api_utils_1.ValidationError([
                        {
                            field: 'feeRecipient',
                            code: api_utils_1.ValidationErrorCodes.RequiredField,
                            reason: `feeRecipient is a required field when feeType ${feeType} is specified`,
                        },
                    ]);
                }
                feeRecipient = req.query.feeRecipient;
            }
        }
        return {
            chainId,
            params: {
                buyAmount,
                buyToken: buyTokenContractAddress,
                buyTokenDecimals,
                integrator,
                sellAmount,
                sellToken: sellTokenContractAddress,
                sellTokenDecimals,
                affiliateAddress: affiliateAddress,
                slippagePercentage,
                feeType,
                feeSellTokenPercentage,
                feeRecipient,
            },
        };
    }
    _parseSubmitParams(req) {
        const chainId = extractChainId(req, this._gaslessSwapServices);
        const { integrator } = this._validateApiKey(req.header('0x-api-key'), chainId);
        const { approval, trade } = req.body;
        const parsedParams = {};
        // Parse approval params
        if (approval) {
            if (approval.type === types_1.GaslessApprovalTypes.ExecuteMetaTransaction ||
                approval.type === types_1.GaslessApprovalTypes.Permit) {
                const eip712 = (0, rfqm_request_utils_1.stringsToEIP712Context)(approval.eip712);
                const signature = (0, rfqm_request_utils_1.stringsToSignature)(approval.signature);
                parsedParams.approval = {
                    type: approval.type,
                    eip712,
                    signature,
                };
            }
            else {
                throw new api_utils_1.ValidationError([
                    {
                        field: 'approval',
                        code: api_utils_1.ValidationErrorCodes.FieldInvalid,
                        reason: `${approval.type} is an invalid value for Approval 'type'`,
                    },
                ]);
            }
        }
        // Parse trade params
        if (trade.type === types_1.GaslessTypes.OtcOrder) {
            const order = new protocol_utils_1.OtcOrder((0, rfqm_request_utils_1.stringsToOtcOrderFields)(trade.order));
            const signature = (0, rfqm_request_utils_1.stringsToSignature)(trade.signature);
            parsedParams.trade = {
                type: trade.type,
                order,
                signature,
            };
        }
        else if (trade.type === types_1.GaslessTypes.MetaTransaction) {
            const metaTransaction = new protocol_utils_1.MetaTransaction((0, rfqm_request_utils_1.stringsToMetaTransactionFields)(trade.metaTransaction));
            const signature = (0, rfqm_request_utils_1.stringsToSignature)(trade.signature);
            parsedParams.trade = {
                type: trade.type,
                metaTransaction,
                signature,
            };
        }
        else {
            throw new api_utils_1.ValidationError([
                {
                    field: 'type',
                    code: api_utils_1.ValidationErrorCodes.FieldInvalid,
                    reason: `${trade.type} is an invalid value for Trade 'type'`,
                },
            ]);
        }
        parsedParams.kind = trade.type;
        return {
            chainId,
            integrator,
            params: parsedParams,
        };
    }
}
exports.GaslessSwapHandlers = GaslessSwapHandlers;
/**
 * Extracts the Chain Id from the request.
 *
 * Note that legacy RFQm defaulted to a chain ID of "1",
 * but that default has been removed for Gasless Swap.
 */
function extractChainId(req, services) {
    const chainIdFromHeader = req.header('0x-chain-id');
    if (chainIdFromHeader === undefined) {
        throw new api_utils_1.ValidationError([
            {
                field: '0x-chain-id',
                code: api_utils_1.ValidationErrorCodes.FieldInvalid,
                reason: 'Request must include a chain ID header',
            },
        ]);
    }
    const chainId = parseInt(chainIdFromHeader, 10);
    if (Number.isNaN(chainId)) {
        throw new api_utils_1.ValidationError([
            {
                field: '0x-chain-id',
                code: api_utils_1.ValidationErrorCodes.FieldInvalid,
                reason: 'Invalid chain id',
            },
        ]);
    }
    if (!services.has(chainId)) {
        throw new api_utils_1.ValidationError([
            {
                field: '0x-chain-id',
                code: api_utils_1.ValidationErrorCodes.FieldInvalid,
                reason: 'Service unavailable on specified chain',
            },
        ]);
    }
    return chainId;
}
/**
 * Gets the token address for a given symbol.
 *
 * Throws if the symbol is not present in @0x/token-metadata
 */
function contractAddressForSymbol(symbol, chainId) {
    var _a;
    const address = (_a = (0, token_metadata_1.getTokenMetadataIfExists)(symbol, chainId)) === null || _a === void 0 ? void 0 : _a.tokenAddress;
    if (!address) {
        throw new Error('Unsupported token');
    }
    return address;
}
function validateNotNativeTokenOrThrow(token, chainId, field) {
    if ((0, token_metadata_1.isNativeSymbolOrAddress)(token, chainId)) {
        const symbol = (0, token_metadata_1.nativeWrappedTokenSymbol)(chainId);
        throw new api_utils_1.ValidationError([
            {
                field,
                code: api_utils_1.ValidationErrorCodes.TokenNotSupported,
                reason: `Unwrapped Native Asset is not supported. Use ${symbol} instead`,
            },
        ]);
    }
    return true;
}
/**
 * Get the meta-transaction type to pass to service.
 */
function getMetaTransactionType(baseURL) {
    if (constants_1.ZERO_G_PATH.includes(baseURL) || constants_1.ZERO_G_ALIAS_PATH.includes(baseURL)) {
        return types_1.GaslessTypes.MetaTransaction;
    }
    if (constants_1.GASLESS_V1_PATH.includes(baseURL)) {
        return types_1.GaslessTypes.MetaTransactionV2;
    }
    // This should never happen
    throw new Error('Unknown gasless base URL');
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9oYW5kbGVycy9HYXNsZXNzU3dhcEhhbmRsZXJzLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUFxQztBQUNyQyw2Q0FNdUI7QUFDdkIsdURBQStEO0FBQy9ELHVEQUFpSDtBQUNqSCxxQ0FBb0Q7QUFFcEQsZ0RBQWdEO0FBQ2hELDZDQUFzQztBQUd0Qyw2Q0FBMEM7QUFTMUMseUNBS3VCO0FBRXZCLGtFQUErRjtBQUMvRixvRUFRcUM7QUFDckMsdURBQW1EO0FBQ25ELGlEQUFvRjtBQUVwRiw4RkFBOEY7QUFDOUYsTUFBTSxvQkFBb0IsR0FBRyxLQUFLLENBQUMsQ0FBQyxPQUFPO0FBRTNDLDZGQUE2RjtBQUM3RixNQUFNLHFDQUFxQyxHQUFHLEtBQUssQ0FBQztBQUVwRCxNQUFNLDBCQUEwQixHQUFHLElBQUkscUJBQU8sQ0FBQztJQUMzQyxJQUFJLEVBQUUsa0NBQWtDO0lBQ3hDLElBQUksRUFBRSwrQ0FBK0M7SUFDckQsVUFBVSxFQUFFLENBQUMsU0FBUyxFQUFFLGlCQUFpQixFQUFFLFVBQVUsQ0FBQztDQUN6RCxDQUFDLENBQUM7QUFDSCxNQUFNLGdDQUFnQyxHQUFHLElBQUkscUJBQU8sQ0FBQztJQUNqRCxJQUFJLEVBQUUsa0NBQWtDO0lBQ3hDLElBQUksRUFBRSxxREFBcUQ7SUFDM0QsVUFBVSxFQUFFLENBQUMsU0FBUyxFQUFFLGlCQUFpQixFQUFFLFVBQVUsQ0FBQztDQUN6RCxDQUFDLENBQUM7QUFJSDs7O0dBR0c7QUFDSCxNQUFhLG1CQUFtQjtJQUU1QixZQUNxQixvQkFBcUQsRUFDckQsY0FBNkI7UUFEN0IseUJBQW9CLEdBQXBCLG9CQUFvQixDQUFpQztRQUNyRCxtQkFBYyxHQUFkLGNBQWMsQ0FBZTtRQUhqQyxzQ0FBaUMsR0FBRyxJQUFJLEdBQUcsRUFBa0MsQ0FBQztJQUk1RixDQUFDO0lBRUo7O09BRUc7SUFDSSxLQUFLLENBQUMsYUFBYSxDQUFDLEdBQW9CLEVBQUUsR0FBcUI7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SUFBSSw2QkFBaUIsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDdEUsT0FBTyxvQkFBWSxDQUFDLGVBQWUsQ0FBQztLQUN2QztJQUNELElBQUksMkJBQWUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDbkMsT0FBTyxvQkFBWSxDQUFDLGlCQUFpQixDQUFDO0tBQ3pDO0lBRUQsMkJBQTJCO0lBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQztBQUNoRCxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXZpZHdhbHNoL2NvZGUtbG9jYWwvMHgtcmZxLWFwaS9zcmMvaGFuZGxlcnMvR2FzbGVzc1N3YXBIYW5kbGVycy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZTptYXgtZmlsZS1saW5lLWNvdW50XHJcbmltcG9ydCB7XHJcbiAgICBJbnRlcm5hbFNlcnZlckVycm9yLFxyXG4gICAgSW52YWxpZEFQSUtleUVycm9yLFxyXG4gICAgaXNBUElFcnJvcixcclxuICAgIFZhbGlkYXRpb25FcnJvcixcclxuICAgIFZhbGlkYXRpb25FcnJvckNvZGVzLFxyXG59IGZyb20gJ0AweC9hcGktdXRpbHMnO1xyXG5pbXBvcnQgeyBNZXRhVHJhbnNhY3Rpb24sIE90Y09yZGVyIH0gZnJvbSAnQDB4L3Byb3RvY29sLXV0aWxzJztcclxuaW1wb3J0IHsgZ2V0VG9rZW5NZXRhZGF0YUlmRXhpc3RzLCBpc05hdGl2ZVN5bWJvbE9yQWRkcmVzcywgbmF0aXZlV3JhcHBlZFRva2VuU3ltYm9sIH0gZnJvbSAnQDB4L3Rva2VuLW1ldGFkYXRhJztcclxuaW1wb3J0IHsgYWRkcmVzc1V0aWxzLCBCaWdOdW1iZXIgfSBmcm9tICdAMHgvdXRpbHMnO1xyXG5pbXBvcnQgKiBhcyBleHByZXNzIGZyb20gJ2V4cHJlc3MnO1xyXG5pbXBvcnQgKiBhcyBIdHRwU3RhdHVzIGZyb20gJ2h0dHAtc3RhdHVzLWNvZGVzJztcclxuaW1wb3J0IHsgQ291bnRlciB9IGZyb20gJ3Byb20tY2xpZW50JztcclxuXHJcbmltcG9ydCB7IEludGVncmF0b3IgfSBmcm9tICcuLi9jb25maWcnO1xyXG5pbXBvcnQgeyBzY2hlbWFzIH0gZnJvbSAnLi4vY29yZS9zY2hlbWFzJztcclxuaW1wb3J0IHsgR2FzbGVzc1N3YXBTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvR2FzbGVzc1N3YXBTZXJ2aWNlJztcclxuaW1wb3J0IHtcclxuICAgIEZldGNoRmlybVF1b3RlUGFyYW1zLFxyXG4gICAgRmV0Y2hJbmRpY2F0aXZlUXVvdGVQYXJhbXMsXHJcbiAgICBGZXRjaFF1b3RlUGFyYW1zQmFzZSxcclxuICAgIFN1Ym1pdE1ldGFUcmFuc2FjdGlvblNpZ25lZFF1b3RlUGFyYW1zLFxyXG4gICAgU3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUGFyYW1zLFxyXG59IGZyb20gJy4uL3NlcnZpY2VzL3R5cGVzJztcclxuaW1wb3J0IHtcclxuICAgIEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0LFxyXG4gICAgR2FzbGVzc0FwcHJvdmFsVHlwZXMsXHJcbiAgICBHYXNsZXNzVHlwZXMsXHJcbiAgICBQZXJtaXRFaXA3MTJDb250ZXh0LFxyXG59IGZyb20gJy4uL2NvcmUvdHlwZXMnO1xyXG5pbXBvcnQgeyBDb25maWdNYW5hZ2VyIH0gZnJvbSAnLi4vdXRpbHMvY29uZmlnX21hbmFnZXInO1xyXG5pbXBvcnQgeyBIZWFsdGhDaGVja1Jlc3VsdCwgdHJhbnNmb3JtUmVzdWx0VG9TaG9ydFJlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMvcmZxbV9oZWFsdGhfY2hlY2snO1xyXG5pbXBvcnQge1xyXG4gICAgUmF3TWV0YVRyYW5zYWN0aW9uRmllbGRzLFxyXG4gICAgUmF3T3RjT3JkZXJGaWVsZHMsXHJcbiAgICBTdHJpbmdTaWduYXR1cmVGaWVsZHMsXHJcbiAgICBzdHJpbmdzVG9FSVA3MTJDb250ZXh0LFxyXG4gICAgc3RyaW5nc1RvTWV0YVRyYW5zYWN0aW9uRmllbGRzLFxyXG4gICAgc3RyaW5nc1RvT3RjT3JkZXJGaWVsZHMsXHJcbiAgICBzdHJpbmdzVG9TaWduYXR1cmUsXHJcbn0gZnJvbSAnLi4vdXRpbHMvcmZxbV9yZXF1ZXN0X3V0aWxzJztcclxuaW1wb3J0IHsgc2NoZW1hVXRpbHMgfSBmcm9tICcuLi9jb3JlL3NjaGVtYV91dGlscyc7XHJcbmltcG9ydCB7IEdBU0xFU1NfVjFfUEFUSCwgWkVST19HX1BBVEgsIFpFUk9fR19BTElBU19QQVRIIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMnO1xyXG5cclxuLy8gTWluaW11bSBzbGlwcGFnZSBhbGxvd2VkLiBUaGlzIHZhbHVlIHNob3VsZCBiZSBrZXB0IGNvbnNpc3RlbnQgd2l0aCB0aGUgdmFsdWUgc2V0IGluIDB4LWFwaVxyXG5jb25zdCBNSU5fQUxMT1dFRF9TTElQUEFHRSA9IDAuMDAxOyAvLyAwLjElXHJcblxyXG4vLyBJZiB0aGUgY2FjaGUgaXMgbW9yZSBtaWxsaXNlY29uZHMgb2xkIHRoYW4gdGhlIHZhbHVlIHNwZWNpZmllZCBoZXJlLCBpdCB3aWxsIGJlIHJlZnJlc2hlZC5cclxuY29uc3QgSEVBTFRIX0NIRUNLX1JFU1VMVF9DQUNIRV9EVVJBVElPTl9NUyA9IDMwMDAwO1xyXG5cclxuY29uc3QgWkVST0dfR0FTTEVTU19TV0FQX1JFUVVFU1QgPSBuZXcgQ291bnRlcih7XHJcbiAgICBuYW1lOiAnemVyb2dfZ2FzbGVzc19zd2FwX3JlcXVlc3RfdG90YWwnLFxyXG4gICAgaGVscDogJ051bWJlciBvZiByZXF1ZXN0cyBvZiBhIGdhc2xlc3Mgc3dhcCBlbmRwb2ludCcsXHJcbiAgICBsYWJlbE5hbWVzOiBbJ2NoYWluSWQnLCAnaW50ZWdyYXRvckxhYmVsJywgJ2VuZHBvaW50J10sXHJcbn0pO1xyXG5jb25zdCBaRVJPR19HQVNMRVNTX1NXQVBfUkVRVUVTVF9FUlJPUiA9IG5ldyBDb3VudGVyKHtcclxuICAgIG5hbWU6ICd6ZXJvZ19nYXNsZXNzX3N3YXBfcmVxdWVzdF9lcnJvcicsXHJcbiAgICBoZWxwOiAnTnVtYmVyIG9mIHJlcXVlc3QgZXJyb3JzIG9mIGEgZ2FzbGVzcyBzd2FwIGVuZHBvaW50JyxcclxuICAgIGxhYmVsTmFtZXM6IFsnY2hhaW5JZCcsICdpbnRlZ3JhdG9yTGFiZWwnLCAnZW5kcG9pbnQnXSxcclxufSk7XHJcblxyXG50eXBlIEhlYWx0aENoZWNrUmVzdWx0Q2FjaGUgPSBbSGVhbHRoQ2hlY2tSZXN1bHQsIERhdGVdO1xyXG5cclxuLyoqXHJcbiAqIExvZ2ljIHRvIGJyaWRnZSBHYXNsZXNzIFN3YXAgQVBJIHJlcXVlc3RzIHRvIHRoZSBgR2FzbGVzc1N3YXBTZXJ2aWNlYCBhbmQgdHJhbnNsYXRlXHJcbiAqIHJlc3VsdHMgZnJvbSB0aGUgYEdhc2xlc3NTd2FwU2VydmljZWAgYmFjayB0byBBUEkgcmVzcG9uc2VzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdhc2xlc3NTd2FwSGFuZGxlcnMge1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfY2FjaGVkSGVhbHRoQ2hlY2tSZXN1bHRCeUNoYWluSWQgPSBuZXcgTWFwPG51bWJlciwgSGVhbHRoQ2hlY2tSZXN1bHRDYWNoZT4oKTtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX2dhc2xlc3NTd2FwU2VydmljZXM6IE1hcDxudW1iZXIsIEdhc2xlc3NTd2FwU2VydmljZT4sXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfY29uZmlnTWFuYWdlcjogQ29uZmlnTWFuYWdlcixcclxuICAgICkge31cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yIHRoZSAvcHJpY2UgZW5kcG9pbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldFByaWNlQXN5bmMocmVxOiBleHByZXNzLlJlcXVlc3QsIHJlczogZXhwcmVzcy5SZXNwb25zZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IG1ldGFUcmFuc2FjdGlvblR5cGUgPSBnZXRNZXRhVHJhbnNhY3Rpb25UeXBlKHJlcS5iYXNlVXJsKTtcclxuICAgICAgICBjb25zdCB7IGNoYWluSWQsIHBhcmFtcyB9ID0gYXdhaXQgdGhpcy5fcGFyc2VQcmljZVBhcmFtc0FzeW5jKHJlcSwgbWV0YVRyYW5zYWN0aW9uVHlwZSk7XHJcbiAgICAgICAgLy8gQ29uc2lzdGVudCB3aXRoIGByZnFtX2hhbmRsZXJzYDogbm90IGFsbCByZXF1ZXN0cyBhcmUgZW1pdHRlZCBpZiB0aGV5IGZhaWwgcGFyc2luZ1xyXG4gICAgICAgIFpFUk9HX0dBU0xFU1NfU1dBUF9SRVFVRVNULmluYyh7XHJcbiAgICAgICAgICAgIGNoYWluSWQsXHJcbiAgICAgICAgICAgIGludGVncmF0b3JMYWJlbDogcGFyYW1zLmludGVncmF0b3IubGFiZWwsXHJcbiAgICAgICAgICAgIGVuZHBvaW50OiAnL3ByaWNlJyxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IHByaWNlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHByaWNlID0gYXdhaXQgdGhpcy5fZ2V0U2VydmljZUZvckNoYWluKGNoYWluSWQpLmZldGNoUHJpY2VBc3luYyhwYXJhbXMpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBaRVJPR19HQVNMRVNTX1NXQVBfUkVRVUVTVF9FUlJPUi5pbmMoe1xyXG4gICAgICAgICAgICAgICAgY2hhaW5JZCxcclxuICAgICAgICAgICAgICAgIGludGVncmF0b3JMYWJlbDogcGFyYW1zLmludGVncmF0b3IubGFiZWwsXHJcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogJy9wcmljZScsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXN1bHRcclxuICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuT0spLnNlbmQoe1xyXG4gICAgICAgICAgICBsaXF1aWRpdHlBdmFpbGFibGU6IHByaWNlICE9PSBudWxsLFxyXG4gICAgICAgICAgICAuLi5wcmljZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yIHRoZSAvcXVvdGUgZW5kcG9pbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldFF1b3RlQXN5bmMocmVxOiBleHByZXNzLlJlcXVlc3QsIHJlczogZXhwcmVzcy5SZXNwb25zZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IG1ldGFUcmFuc2FjdGlvblR5cGUgPSBnZXRNZXRhVHJhbnNhY3Rpb25UeXBlKHJlcS5iYXNlVXJsKTtcclxuICAgICAgICAvLyBQYXJzZSByZXF1ZXN0XHJcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBwYXJhbXMgfSA9IGF3YWl0IHRoaXMuX3BhcnNlRmV0Y2hGaXJtUXVvdGVQYXJhbXNBc3luYyhyZXEsIG1ldGFUcmFuc2FjdGlvblR5cGUpO1xyXG4gICAgICAgIC8vIENvbnNpc3RlbnQgd2l0aCBgcmZxbV9oYW5kbGVyc2A6IG5vdCBhbGwgcmVxdWVzdHMgYXJlIGVtaXR0ZWQgaWYgdGhleSBmYWlsIHBhcnNpbmdcclxuICAgICAgICBaRVJPR19HQVNMRVNTX1NXQVBfUkVRVUVTVC5pbmMoe1xyXG4gICAgICAgICAgICBjaGFpbklkLFxyXG4gICAgICAgICAgICBpbnRlZ3JhdG9yTGFiZWw6IHBhcmFtcy5pbnRlZ3JhdG9yLmxhYmVsLFxyXG4gICAgICAgICAgICBlbmRwb2ludDogJy9xdW90ZScsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCBxdW90ZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBxdW90ZSA9IGF3YWl0IHRoaXMuX2dldFNlcnZpY2VGb3JDaGFpbihjaGFpbklkKS5mZXRjaFF1b3RlQXN5bmMocGFyYW1zKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgWkVST0dfR0FTTEVTU19TV0FQX1JFUVVFU1RfRVJST1IuaW5jKHtcclxuICAgICAgICAgICAgICAgIGNoYWluSWQsXHJcbiAgICAgICAgICAgICAgICBpbnRlZ3JhdG9yTGFiZWw6IHBhcmFtcy5pbnRlZ3JhdG9yLmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6ICcvcXVvdGUnLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXN1bHRcclxuICAgICAgICByZXMuc3RhdHVzKEh0dHBTdGF0dXMuT0spLnNlbmQoe1xyXG4gICAgICAgICAgICBsaXF1aWRpdHlBdmFpbGFibGU6IHF1b3RlICE9PSBudWxsLFxyXG4gICAgICAgICAgICAuLi5xdW90ZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yIHRoZSBgL2hlYWx0aHpgIGVuZHBvaW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0SGVhbHRoQXN5bmMocmVxOiBleHByZXNzLlJlcXVlc3QsIHJlczogZXhwcmVzcy5SZXNwb25zZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSBleHRyYWN0Q2hhaW5JZChyZXEsIHRoaXMuX2dhc2xlc3NTd2FwU2VydmljZXMpO1xyXG4gICAgICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IHRoaXMuX2NhY2hlZEhlYWx0aENoZWNrUmVzdWx0QnlDaGFpbklkLmdldChjaGFpbklkKTtcclxuICAgICAgICBsZXQgcmVzdWx0OiBIZWFsdGhDaGVja1Jlc3VsdDtcclxuICAgICAgICBpZiAoIWNhY2hlZFJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLl9nZXRTZXJ2aWNlRm9yQ2hhaW4oY2hhaW5JZCkucnVuSGVhbHRoQ2hlY2tBc3luYygpO1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRIZWFsdGhDaGVja1Jlc3VsdEJ5Q2hhaW5JZC5zZXQoY2hhaW5JZCwgW3Jlc3VsdCwgbmV3IERhdGUoKV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlQWdlTXMgPSBEYXRlLm5vdygpIC0gY2FjaGVkUmVzdWx0WzFdLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlQWdlTXMgPj0gSEVBTFRIX0NIRUNLX1JFU1VMVF9DQUNIRV9EVVJBVElPTl9NUykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZ2V0U2VydmljZUZvckNoYWluKGNoYWluSWQpLnJ1bkhlYWx0aENoZWNrQXN5bmMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZEhlYWx0aENoZWNrUmVzdWx0QnlDaGFpbklkLnNldChjaGFpbklkLCBbcmVzdWx0LCBuZXcgRGF0ZSgpXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWNoZWRSZXN1bHRbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdHJhbnNmb3JtUmVzdWx0VG9TaG9ydFJlc3BvbnNlKHJlc3VsdCk7XHJcbiAgICAgICAgcmVzLnN0YXR1cyhIdHRwU3RhdHVzLk9LKS5zZW5kKHJlc3BvbnNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yIHRoZSAvc3RhdHVzLzpoYXNoIGVuZHBvaW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRTdGF0dXNBc3luYyhyZXE6IGV4cHJlc3MuUmVxdWVzdCwgcmVzOiBleHByZXNzLlJlc3BvbnNlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IGV4dHJhY3RDaGFpbklkKHJlcSwgdGhpcy5fZ2FzbGVzc1N3YXBTZXJ2aWNlcyk7XHJcbiAgICAgICAgY29uc3QgeyBoYXNoIH0gPSByZXEucGFyYW1zO1xyXG5cclxuICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCB0aGlzLl9nZXRTZXJ2aWNlRm9yQ2hhaW4oY2hhaW5JZCkuZ2V0U3RhdHVzQXN5bmMoaGFzaCk7XHJcblxyXG4gICAgICAgIHN0YXR1cyA/IHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5PSykuc2VuZChzdGF0dXMpIDogcmVzLnN0YXR1cyhIdHRwU3RhdHVzLk5PVF9GT1VORCkuc2VuZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlciBmb3IgdGhlIC9zdWJtaXQgZW5kcG9pbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIHByb2Nlc3NTdWJtaXRBc3luYyhyZXE6IGV4cHJlc3MuUmVxdWVzdCwgcmVzOiBleHByZXNzLlJlc3BvbnNlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBpbnRlZ3JhdG9yLCBwYXJhbXMgfSA9IHRoaXMuX3BhcnNlU3VibWl0UGFyYW1zKHJlcSk7XHJcbiAgICAgICAgLy8gQ29uc2lzdGVudCB3aXRoIGByZnFtX2hhbmRsZXJzYDogbm90IGFsbCByZXF1ZXN0cyBhcmUgZW1pdHRlZCBpZiB0aGV5IGZhaWwgcGFyc2luZ1xyXG4gICAgICAgIFpFUk9HX0dBU0xFU1NfU1dBUF9SRVFVRVNULmluYyh7XHJcbiAgICAgICAgICAgIGNoYWluSWQsXHJcbiAgICAgICAgICAgIGludGVncmF0b3JMYWJlbDogaW50ZWdyYXRvci5sYWJlbCxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6ICcvc3VibWl0JyxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXRTZXJ2aWNlRm9yQ2hhaW4oY2hhaW5JZCkucHJvY2Vzc1N1Ym1pdEFzeW5jKFxyXG4gICAgICAgICAgICAgICAgcGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgaW50ZWdyYXRvci5pbnRlZ3JhdG9ySWQsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHJlcy5zdGF0dXMoSHR0cFN0YXR1cy5DUkVBVEVEKS5zZW5kKHJlc3BvbnNlKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgWkVST0dfR0FTTEVTU19TV0FQX1JFUVVFU1RfRVJST1IuaW5jKHtcclxuICAgICAgICAgICAgICAgIGNoYWluSWQsXHJcbiAgICAgICAgICAgICAgICBpbnRlZ3JhdG9yTGFiZWw6IGludGVncmF0b3IubGFiZWwsXHJcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogJy9zdWJtaXQnLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmVxLmxvZy5lcnJvcihlcnIsICdFbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBxdWV1aW5nIGEgc2lnbmVkIHF1b3RlJyk7XHJcbiAgICAgICAgICAgIGlmIChpc0FQSUVycm9yKGVycikpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnRlcm5hbFNlcnZlckVycm9yKGBBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBfcGFyc2VGZXRjaEZpcm1RdW90ZVBhcmFtc0FzeW5jKFxyXG4gICAgICAgIHJlcTogZXhwcmVzcy5SZXF1ZXN0LFxyXG4gICAgICAgIG1ldGFUcmFuc2FjdGlvblR5cGU6IEdhc2xlc3NUeXBlcyxcclxuICAgICk6IFByb21pc2U8eyBjaGFpbklkOiBudW1iZXI7IHBhcmFtczogRmV0Y2hGaXJtUXVvdGVQYXJhbXMgfT4ge1xyXG4gICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHNjaGVtYVV0aWxzLnZhbGlkYXRlU2NoZW1hKHJlcS5xdWVyeSwgc2NoZW1hcy5maXJtUXVvdGVSZXF1ZXN0U2NoZW1hIGFzIGFueSk7XHJcbiAgICAgICAgY29uc3QgdGFrZXJBZGRyZXNzID0gcmVxLnF1ZXJ5LnRha2VyQWRkcmVzcztcclxuICAgICAgICBjb25zdCBzaG91bGRDaGVja0FwcHJvdmFsID0gcmVxLnF1ZXJ5LmNoZWNrQXBwcm92YWwgPT09ICd0cnVlJyA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICBjb25zdCB7IGNoYWluSWQsIHBhcmFtcyB9ID0gYXdhaXQgdGhpcy5fcGFyc2VJbmRpY2F0aXZlQW5kRmlybVF1b3RlU2hhcmVkUGFyYW1zQXN5bmMocmVxLCBtZXRhVHJhbnNhY3Rpb25UeXBlKTtcclxuICAgICAgICBpZiAoIWFkZHJlc3NVdGlscy5pc0FkZHJlc3ModGFrZXJBZGRyZXNzIGFzIHN0cmluZykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICd0YWtlckFkZHJlc3MnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFZhbGlkYXRpb25FcnJvckNvZGVzLkludmFsaWRBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogYE11c3QgcHJvdmlkZSBhIHZhbGlkIHRha2VyQWRkcmVzc2AsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2hhaW5JZCxcclxuICAgICAgICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5wYXJhbXMsXHJcbiAgICAgICAgICAgICAgICB0YWtlckFkZHJlc3M6IHRha2VyQWRkcmVzcyBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBjaGVja0FwcHJvdmFsOiBzaG91bGRDaGVja0FwcHJvdmFsLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfZ2V0U2VydmljZUZvckNoYWluKGNoYWluSWQ6IG51bWJlcik6IEdhc2xlc3NTd2FwU2VydmljZSB7XHJcbiAgICAgICAgY29uc3Qgc2VydmljZSA9IHRoaXMuX2dhc2xlc3NTd2FwU2VydmljZXMuZ2V0KGNoYWluSWQpO1xyXG5cclxuICAgICAgICBpZiAoIXNlcnZpY2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb25maWd1cmF0aW9uIGV4aXN0cyBmb3IgY2hhaW4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlcnZpY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGFtaW5lcyB0aGUgQVBJIGtleSBwcm92aWRlZCBpbiB0aGUgcmVxdWVzdCwgZW5zdXJlcyBpdCBpcyB2YWxpZCBmb3IgUkZRTSwgYW5kIGZldGNoZXMgdGhlIGFzc29jaWF0ZWRcclxuICAgICAqIGludGVncmF0b3IgSUQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3ZhbGlkYXRlQXBpS2V5KGFwaUtleTogc3RyaW5nIHwgdW5kZWZpbmVkLCBjaGFpbklkOiBudW1iZXIpOiB7IGFwaUtleTogc3RyaW5nOyBpbnRlZ3JhdG9yOiBJbnRlZ3JhdG9yIH0ge1xyXG4gICAgICAgIGlmIChhcGlLZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFQSUtleUVycm9yKCdNdXN0IGFjY2VzcyB3aXRoIGFuIEFQSSBrZXknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWdNYW5hZ2VyLmdldFJmcW1BcGlLZXlXaGl0ZWxpc3QoKS5oYXMoYXBpS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFQSUtleUVycm9yKCdBUEkga2V5IG5vdCBhdXRob3JpemVkIGZvciBSRlFNIGFjY2VzcycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnRlZ3JhdG9ySWQgPSB0aGlzLl9jb25maWdNYW5hZ2VyLmdldEludGVncmF0b3JJZEZvckFwaUtleShhcGlLZXkpO1xyXG4gICAgICAgIGlmICghaW50ZWdyYXRvcklkKSB7XHJcbiAgICAgICAgICAgIC8vIFdpdGggYSB2YWxpZCBjb25maWd1cmF0aW9uIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFQSUtleUVycm9yKCdBUEkga2V5IGhhcyBubyBhc3NvY2lhdGVkIEludGVncmF0b3IgSUQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW50ZWdyYXRvciA9IHRoaXMuX2NvbmZpZ01hbmFnZXIuZ2V0SW50ZWdyYXRvckJ5SWRPclRocm93KGludGVncmF0b3JJZCk7XHJcbiAgICAgICAgaWYgKCFpbnRlZ3JhdG9yLmFsbG93ZWRDaGFpbklkcy5pbmNsdWRlcyhjaGFpbklkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFQSUtleUVycm9yKGBBUEkgS2V5IG5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyBjaGFpbiAke2NoYWluSWR9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGFwaUtleSwgaW50ZWdyYXRvciB9O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgX3BhcnNlUHJpY2VQYXJhbXNBc3luYyhcclxuICAgICAgICByZXE6IGV4cHJlc3MuUmVxdWVzdCxcclxuICAgICAgICBtZXRhVHJhbnNhY3Rpb25UeXBlOiBHYXNsZXNzVHlwZXMsXHJcbiAgICApOiBQcm9taXNlPHsgY2hhaW5JZDogbnVtYmVyOyBwYXJhbXM6IEZldGNoSW5kaWNhdGl2ZVF1b3RlUGFyYW1zIH0+IHtcclxuICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICBzY2hlbWFVdGlscy52YWxpZGF0ZVNjaGVtYShyZXEucXVlcnksIHNjaGVtYXMuaW5kaWNhdGl2ZVF1b3RlUmVxdWVzdFNjaGVtYSBhcyBhbnkpO1xyXG4gICAgICAgIGNvbnN0IHsgdGFrZXJBZGRyZXNzIH0gPSByZXEucXVlcnk7XHJcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBwYXJhbXMgfSA9IGF3YWl0IHRoaXMuX3BhcnNlSW5kaWNhdGl2ZUFuZEZpcm1RdW90ZVNoYXJlZFBhcmFtc0FzeW5jKHJlcSwgbWV0YVRyYW5zYWN0aW9uVHlwZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNoYWluSWQsXHJcbiAgICAgICAgICAgIHBhcmFtczoge1xyXG4gICAgICAgICAgICAgICAgLi4ucGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgdGFrZXJBZGRyZXNzOiB0YWtlckFkZHJlc3MgYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSBzaGFyZWQgcGFyYW1zIG9mIGluZGljYXRpdmUgYW5kIGZpcm0gcXVvdGVzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgX3BhcnNlSW5kaWNhdGl2ZUFuZEZpcm1RdW90ZVNoYXJlZFBhcmFtc0FzeW5jKFxyXG4gICAgICAgIHJlcTogZXhwcmVzcy5SZXF1ZXN0LFxyXG4gICAgICAgIG1ldGFUcmFuc2FjdGlvblR5cGU6IEdhc2xlc3NUeXBlcyxcclxuICAgICk6IFByb21pc2U8eyBjaGFpbklkOiBudW1iZXI7IHBhcmFtczogRmV0Y2hRdW90ZVBhcmFtc0Jhc2UgfT4ge1xyXG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSBleHRyYWN0Q2hhaW5JZChyZXEsIHRoaXMuX2dhc2xlc3NTd2FwU2VydmljZXMpO1xyXG4gICAgICAgIGNvbnN0IHsgaW50ZWdyYXRvciB9ID0gdGhpcy5fdmFsaWRhdGVBcGlLZXkocmVxLmhlYWRlcignMHgtYXBpLWtleScpLCBjaGFpbklkKTtcclxuICAgICAgICBjb25zdCB7IGFmZmlsaWF0ZUFkZHJlc3MgfSA9IHJlcS5xdWVyeTtcclxuXHJcbiAgICAgICAgLy8gUGFyc2UgdG9rZW5zXHJcbiAgICAgICAgY29uc3Qgc2VsbFRva2VuUmF3ID0gcmVxLnF1ZXJ5LnNlbGxUb2tlbiBhcyBzdHJpbmc7XHJcbiAgICAgICAgY29uc3QgYnV5VG9rZW5SYXcgPSByZXEucXVlcnkuYnV5VG9rZW4gYXMgc3RyaW5nO1xyXG4gICAgICAgIHZhbGlkYXRlTm90TmF0aXZlVG9rZW5PclRocm93KHNlbGxUb2tlblJhdywgY2hhaW5JZCwgJ3NlbGxUb2tlbicpO1xyXG5cclxuICAgICAgICBsZXQgYnV5VG9rZW5EZWNpbWFsczogbnVtYmVyO1xyXG4gICAgICAgIGxldCBzZWxsVG9rZW5EZWNpbWFsczogbnVtYmVyO1xyXG4gICAgICAgIGxldCBidXlUb2tlbkNvbnRyYWN0QWRkcmVzczogc3RyaW5nO1xyXG4gICAgICAgIGxldCBzZWxsVG9rZW5Db250cmFjdEFkZHJlc3M6IHN0cmluZztcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYnV5VG9rZW5Db250cmFjdEFkZHJlc3MgPSBidXlUb2tlblJhdy50b0xvY2FsZUxvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJzB4JylcclxuICAgICAgICAgICAgICAgID8gYnV5VG9rZW5SYXdcclxuICAgICAgICAgICAgICAgIDogY29udHJhY3RBZGRyZXNzRm9yU3ltYm9sKGJ1eVRva2VuUmF3LCBjaGFpbklkKTtcclxuICAgICAgICAgICAgYnV5VG9rZW5EZWNpbWFscyA9IGF3YWl0IHRoaXMuX2dldFNlcnZpY2VGb3JDaGFpbihjaGFpbklkKS5nZXRUb2tlbkRlY2ltYWxzQXN5bmMoYnV5VG9rZW5SYXcpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdidXlUb2tlbicsXHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogVmFsaWRhdGlvbkVycm9yQ29kZXMuQWRkcmVzc05vdFN1cHBvcnRlZCxcclxuICAgICAgICAgICAgICAgICAgICByZWFzb246IGBUb2tlbiAke2J1eVRva2VuUmF3fSBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWRgLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzZWxsVG9rZW5Db250cmFjdEFkZHJlc3MgPSBzZWxsVG9rZW5SYXcudG9Mb2NhbGVMb3dlckNhc2UoKS5zdGFydHNXaXRoKCcweCcpXHJcbiAgICAgICAgICAgICAgICA/IHNlbGxUb2tlblJhd1xyXG4gICAgICAgICAgICAgICAgOiBjb250cmFjdEFkZHJlc3NGb3JTeW1ib2woc2VsbFRva2VuUmF3LCBjaGFpbklkKTtcclxuICAgICAgICAgICAgc2VsbFRva2VuRGVjaW1hbHMgPSBhd2FpdCB0aGlzLl9nZXRTZXJ2aWNlRm9yQ2hhaW4oY2hhaW5JZCkuZ2V0VG9rZW5EZWNpbWFsc0FzeW5jKHNlbGxUb2tlblJhdyk7XHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnc2VsbFRva2VuJyxcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBWYWxpZGF0aW9uRXJyb3JDb2Rlcy5BZGRyZXNzTm90U3VwcG9ydGVkLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogYFRva2VuICR7c2VsbFRva2VuUmF3fSBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWRgLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQYXJzZSBudW1iZXIgcGFyYW1zXHJcbiAgICAgICAgY29uc3Qgc2VsbEFtb3VudCA9XHJcbiAgICAgICAgICAgIHJlcS5xdWVyeS5zZWxsQW1vdW50ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBuZXcgQmlnTnVtYmVyKHJlcS5xdWVyeS5zZWxsQW1vdW50IGFzIHN0cmluZyk7XHJcbiAgICAgICAgY29uc3QgYnV5QW1vdW50ID0gcmVxLnF1ZXJ5LmJ1eUFtb3VudCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbmV3IEJpZ051bWJlcihyZXEucXVlcnkuYnV5QW1vdW50IGFzIHN0cmluZyk7XHJcbiAgICAgICAgY29uc3Qgc2xpcHBhZ2VQZXJjZW50YWdlID1cclxuICAgICAgICAgICAgcmVxLnF1ZXJ5LnNsaXBwYWdlUGVyY2VudGFnZSA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgOiBuZXcgQmlnTnVtYmVyKHJlcS5xdWVyeS5zbGlwcGFnZVBlcmNlbnRhZ2UgYXMgc3RyaW5nKTtcclxuXHJcbiAgICAgICAgbGV0IGZlZVR5cGU6ICd2b2x1bWUnIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGxldCBmZWVTZWxsVG9rZW5QZXJjZW50YWdlOiBCaWdOdW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IGZlZVJlY2lwaWVudDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBpZiAobWV0YVRyYW5zYWN0aW9uVHlwZSA9PT0gR2FzbGVzc1R5cGVzLk1ldGFUcmFuc2FjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoc2xpcHBhZ2VQZXJjZW50YWdlPy5sdChNSU5fQUxMT1dFRF9TTElQUEFHRSkgfHwgc2xpcHBhZ2VQZXJjZW50YWdlPy5ndCgxKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ3NsaXBwYWdlUGVyY2VudGFnZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFZhbGlkYXRpb25FcnJvckNvZGVzLlZhbHVlT3V0T2ZSYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBgc2xpcHBhZ2VQZXJjZW50YWdlICR7c2xpcHBhZ2VQZXJjZW50YWdlfSBpcyBvdXQgb2YgcmFuZ2VgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAobWV0YVRyYW5zYWN0aW9uVHlwZSA9PT0gR2FzbGVzc1R5cGVzLk1ldGFUcmFuc2FjdGlvblYyKSB7XHJcbiAgICAgICAgICAgIC8vIHNsaXBwYWdlIHBlcmNlbnRhZ2Ugb2YgZ2FzbGVzcyB2MSBpcyBvbiBzY2FsZSBvZiAxMDAgd2hpY2ggaXMgd2hhdCBwZXJjZW50YWdlIG1lYW5zIChhIGZpeCBmcm9tIHplcm8tZylcclxuICAgICAgICAgICAgaWYgKHNsaXBwYWdlUGVyY2VudGFnZT8ubHQoTUlOX0FMTE9XRURfU0xJUFBBR0UgKiAxMDApIHx8IHNsaXBwYWdlUGVyY2VudGFnZT8uZ3QoMTAwKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ3NsaXBwYWdlUGVyY2VudGFnZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFZhbGlkYXRpb25FcnJvckNvZGVzLlZhbHVlT3V0T2ZSYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBgc2xpcHBhZ2VQZXJjZW50YWdlICR7c2xpcHBhZ2VQZXJjZW50YWdlfSBpcyBvdXQgb2YgcmFuZ2VgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlcS5xdWVyeS5mZWVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVxLnF1ZXJ5LmZlZVR5cGUgIT09ICd2b2x1bWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnZmVlVHlwZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBWYWxpZGF0aW9uRXJyb3JDb2Rlcy5JbmNvcnJlY3RGb3JtYXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IGBmZWVUeXBlICR7cmVxLnF1ZXJ5LmZlZVR5cGV9IGlzIG9mIHdyb25nIGZvcm1hdGAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZmVlVHlwZSA9ICd2b2x1bWUnO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcS5xdWVyeS5mZWVTZWxsVG9rZW5QZXJjZW50YWdlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdmZWVTZWxsVG9rZW5QZXJjZW50YWdlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFZhbGlkYXRpb25FcnJvckNvZGVzLlJlcXVpcmVkRmllbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IGBmZWVTZWxsVG9rZW5QZXJjZW50YWdlIGlzIGEgcmVxdWlyZWQgZmllbGQgd2hlbiBmZWVUeXBlICR7ZmVlVHlwZX0gaXMgc3BlY2lmaWVkYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZlZVNlbGxUb2tlblBlcmNlbnRhZ2UgPSBuZXcgQmlnTnVtYmVyKHJlcS5xdWVyeS5mZWVTZWxsVG9rZW5QZXJjZW50YWdlIGFzIHN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmVlU2VsbFRva2VuUGVyY2VudGFnZS5sdCgwKSB8fCBmZWVTZWxsVG9rZW5QZXJjZW50YWdlLmd0ZSgxMDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnZmVlU2VsbFRva2VuUGVyY2VudGFnZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBWYWxpZGF0aW9uRXJyb3JDb2Rlcy5WYWx1ZU91dE9mUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IGBmZWVTZWxsVG9rZW5QZXJjZW50YWdlICR7ZmVlU2VsbFRva2VuUGVyY2VudGFnZX0gaXMgb3V0IG9mIHJhbmdlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVxLnF1ZXJ5LmZlZVJlY2lwaWVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnZmVlUmVjaXBpZW50JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFZhbGlkYXRpb25FcnJvckNvZGVzLlJlcXVpcmVkRmllbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IGBmZWVSZWNpcGllbnQgaXMgYSByZXF1aXJlZCBmaWVsZCB3aGVuIGZlZVR5cGUgJHtmZWVUeXBlfSBpcyBzcGVjaWZpZWRgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmVlUmVjaXBpZW50ID0gcmVxLnF1ZXJ5LmZlZVJlY2lwaWVudCBhcyBzdHJpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNoYWluSWQsXHJcbiAgICAgICAgICAgIHBhcmFtczoge1xyXG4gICAgICAgICAgICAgICAgYnV5QW1vdW50LFxyXG4gICAgICAgICAgICAgICAgYnV5VG9rZW46IGJ1eVRva2VuQ29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgYnV5VG9rZW5EZWNpbWFscyxcclxuICAgICAgICAgICAgICAgIGludGVncmF0b3IsXHJcbiAgICAgICAgICAgICAgICBzZWxsQW1vdW50LFxyXG4gICAgICAgICAgICAgICAgc2VsbFRva2VuOiBzZWxsVG9rZW5Db250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICBzZWxsVG9rZW5EZWNpbWFscyxcclxuICAgICAgICAgICAgICAgIGFmZmlsaWF0ZUFkZHJlc3M6IGFmZmlsaWF0ZUFkZHJlc3MgYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgc2xpcHBhZ2VQZXJjZW50YWdlLFxyXG4gICAgICAgICAgICAgICAgZmVlVHlwZSxcclxuICAgICAgICAgICAgICAgIGZlZVNlbGxUb2tlblBlcmNlbnRhZ2UsXHJcbiAgICAgICAgICAgICAgICBmZWVSZWNpcGllbnQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9wYXJzZVN1Ym1pdFBhcmFtczxUIGV4dGVuZHMgRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkVpcDcxMkNvbnRleHQgfCBQZXJtaXRFaXA3MTJDb250ZXh0PihcclxuICAgICAgICByZXE6IGV4cHJlc3MuUmVxdWVzdCxcclxuICAgICk6IHtcclxuICAgICAgICBjaGFpbklkOiBudW1iZXI7XHJcbiAgICAgICAgaW50ZWdyYXRvcjogSW50ZWdyYXRvcjtcclxuICAgICAgICBwYXJhbXM6IFN1Ym1pdFJmcW1TaWduZWRRdW90ZVdpdGhBcHByb3ZhbFBhcmFtczxUPiB8IFN1Ym1pdE1ldGFUcmFuc2FjdGlvblNpZ25lZFF1b3RlUGFyYW1zPFQ+O1xyXG4gICAgfSB7XHJcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IGV4dHJhY3RDaGFpbklkKHJlcSwgdGhpcy5fZ2FzbGVzc1N3YXBTZXJ2aWNlcyk7XHJcbiAgICAgICAgY29uc3QgeyBpbnRlZ3JhdG9yIH0gPSB0aGlzLl92YWxpZGF0ZUFwaUtleShyZXEuaGVhZGVyKCcweC1hcGkta2V5JyksIGNoYWluSWQpO1xyXG5cclxuICAgICAgICBjb25zdCB7IGFwcHJvdmFsLCB0cmFkZSB9ID0gcmVxLmJvZHk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBhcnNlZFBhcmFtczogUGFydGlhbDxcclxuICAgICAgICAgICAgU3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUGFyYW1zPFQ+IHwgU3VibWl0TWV0YVRyYW5zYWN0aW9uU2lnbmVkUXVvdGVQYXJhbXM8VD5cclxuICAgICAgICA+ID0ge307XHJcblxyXG4gICAgICAgIC8vIFBhcnNlIGFwcHJvdmFsIHBhcmFtc1xyXG4gICAgICAgIGlmIChhcHByb3ZhbCkge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBhcHByb3ZhbC50eXBlID09PSBHYXNsZXNzQXBwcm92YWxUeXBlcy5FeGVjdXRlTWV0YVRyYW5zYWN0aW9uIHx8XHJcbiAgICAgICAgICAgICAgICBhcHByb3ZhbC50eXBlID09PSBHYXNsZXNzQXBwcm92YWxUeXBlcy5QZXJtaXRcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlaXA3MTIgPSBzdHJpbmdzVG9FSVA3MTJDb250ZXh0KGFwcHJvdmFsLmVpcDcxMikgYXMgVDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHN0cmluZ3NUb1NpZ25hdHVyZShhcHByb3ZhbC5zaWduYXR1cmUgYXMgU3RyaW5nU2lnbmF0dXJlRmllbGRzKTtcclxuICAgICAgICAgICAgICAgIHBhcnNlZFBhcmFtcy5hcHByb3ZhbCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBhcHByb3ZhbC50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGVpcDcxMixcclxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ2FwcHJvdmFsJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogVmFsaWRhdGlvbkVycm9yQ29kZXMuRmllbGRJbnZhbGlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IGAke2FwcHJvdmFsLnR5cGV9IGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIEFwcHJvdmFsICd0eXBlJ2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQYXJzZSB0cmFkZSBwYXJhbXNcclxuICAgICAgICBpZiAodHJhZGUudHlwZSA9PT0gR2FzbGVzc1R5cGVzLk90Y09yZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyID0gbmV3IE90Y09yZGVyKHN0cmluZ3NUb090Y09yZGVyRmllbGRzKHRyYWRlLm9yZGVyIGFzIFJhd090Y09yZGVyRmllbGRzKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHN0cmluZ3NUb1NpZ25hdHVyZSh0cmFkZS5zaWduYXR1cmUgYXMgU3RyaW5nU2lnbmF0dXJlRmllbGRzKTtcclxuICAgICAgICAgICAgcGFyc2VkUGFyYW1zLnRyYWRlID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogdHJhZGUudHlwZSxcclxuICAgICAgICAgICAgICAgIG9yZGVyLFxyXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHJhZGUudHlwZSA9PT0gR2FzbGVzc1R5cGVzLk1ldGFUcmFuc2FjdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhVHJhbnNhY3Rpb24gPSBuZXcgTWV0YVRyYW5zYWN0aW9uKFxyXG4gICAgICAgICAgICAgICAgc3RyaW5nc1RvTWV0YVRyYW5zYWN0aW9uRmllbGRzKHRyYWRlLm1ldGFUcmFuc2FjdGlvbiBhcyBSYXdNZXRhVHJhbnNhY3Rpb25GaWVsZHMpLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBzdHJpbmdzVG9TaWduYXR1cmUodHJhZGUuc2lnbmF0dXJlIGFzIFN0cmluZ1NpZ25hdHVyZUZpZWxkcyk7XHJcbiAgICAgICAgICAgIHBhcnNlZFBhcmFtcy50cmFkZSA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IHRyYWRlLnR5cGUsXHJcbiAgICAgICAgICAgICAgICBtZXRhVHJhbnNhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBzaWduYXR1cmUsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICd0eXBlJyxcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBWYWxpZGF0aW9uRXJyb3JDb2Rlcy5GaWVsZEludmFsaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBgJHt0cmFkZS50eXBlfSBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciBUcmFkZSAndHlwZSdgLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXJzZWRQYXJhbXMua2luZCA9IHRyYWRlLnR5cGU7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNoYWluSWQsXHJcbiAgICAgICAgICAgIGludGVncmF0b3IsXHJcbiAgICAgICAgICAgIHBhcmFtczogcGFyc2VkUGFyYW1zIGFzXHJcbiAgICAgICAgICAgICAgICB8IFN1Ym1pdFJmcW1TaWduZWRRdW90ZVdpdGhBcHByb3ZhbFBhcmFtczxUPlxyXG4gICAgICAgICAgICAgICAgfCBTdWJtaXRNZXRhVHJhbnNhY3Rpb25TaWduZWRRdW90ZVBhcmFtczxUPixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRXh0cmFjdHMgdGhlIENoYWluIElkIGZyb20gdGhlIHJlcXVlc3QuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBsZWdhY3kgUkZRbSBkZWZhdWx0ZWQgdG8gYSBjaGFpbiBJRCBvZiBcIjFcIixcclxuICogYnV0IHRoYXQgZGVmYXVsdCBoYXMgYmVlbiByZW1vdmVkIGZvciBHYXNsZXNzIFN3YXAuXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0Q2hhaW5JZChyZXE6IGV4cHJlc3MuUmVxdWVzdCwgc2VydmljZXM6IE1hcDxudW1iZXIsIEdhc2xlc3NTd2FwU2VydmljZT4pOiBudW1iZXIge1xyXG4gICAgY29uc3QgY2hhaW5JZEZyb21IZWFkZXIgPSByZXEuaGVhZGVyKCcweC1jaGFpbi1pZCcpO1xyXG4gICAgaWYgKGNoYWluSWRGcm9tSGVhZGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmllbGQ6ICcweC1jaGFpbi1pZCcsXHJcbiAgICAgICAgICAgICAgICBjb2RlOiBWYWxpZGF0aW9uRXJyb3JDb2Rlcy5GaWVsZEludmFsaWQsXHJcbiAgICAgICAgICAgICAgICByZWFzb246ICdSZXF1ZXN0IG11c3QgaW5jbHVkZSBhIGNoYWluIElEIGhlYWRlcicsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZEZyb21IZWFkZXIsIDEwKTtcclxuICAgIGlmIChOdW1iZXIuaXNOYU4oY2hhaW5JZCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmllbGQ6ICcweC1jaGFpbi1pZCcsXHJcbiAgICAgICAgICAgICAgICBjb2RlOiBWYWxpZGF0aW9uRXJyb3JDb2Rlcy5GaWVsZEludmFsaWQsXHJcbiAgICAgICAgICAgICAgICByZWFzb246ICdJbnZhbGlkIGNoYWluIGlkJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXNlcnZpY2VzLmhhcyhjaGFpbklkKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmaWVsZDogJzB4LWNoYWluLWlkJyxcclxuICAgICAgICAgICAgICAgIGNvZGU6IFZhbGlkYXRpb25FcnJvckNvZGVzLkZpZWxkSW52YWxpZCxcclxuICAgICAgICAgICAgICAgIHJlYXNvbjogJ1NlcnZpY2UgdW5hdmFpbGFibGUgb24gc3BlY2lmaWVkIGNoYWluJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGFpbklkO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgdG9rZW4gYWRkcmVzcyBmb3IgYSBnaXZlbiBzeW1ib2wuXHJcbiAqXHJcbiAqIFRocm93cyBpZiB0aGUgc3ltYm9sIGlzIG5vdCBwcmVzZW50IGluIEAweC90b2tlbi1tZXRhZGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gY29udHJhY3RBZGRyZXNzRm9yU3ltYm9sKHN5bWJvbDogc3RyaW5nLCBjaGFpbklkOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgYWRkcmVzcyA9IGdldFRva2VuTWV0YWRhdGFJZkV4aXN0cyhzeW1ib2wsIGNoYWluSWQpPy50b2tlbkFkZHJlc3M7XHJcbiAgICBpZiAoIWFkZHJlc3MpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRva2VuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWRkcmVzcztcclxufVxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVOb3ROYXRpdmVUb2tlbk9yVGhyb3codG9rZW46IHN0cmluZywgY2hhaW5JZDogbnVtYmVyLCBmaWVsZDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBpZiAoaXNOYXRpdmVTeW1ib2xPckFkZHJlc3ModG9rZW4sIGNoYWluSWQpKSB7XHJcbiAgICAgICAgY29uc3Qgc3ltYm9sID0gbmF0aXZlV3JhcHBlZFRva2VuU3ltYm9sKGNoYWluSWQpO1xyXG4gICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmaWVsZCxcclxuICAgICAgICAgICAgICAgIGNvZGU6IFZhbGlkYXRpb25FcnJvckNvZGVzLlRva2VuTm90U3VwcG9ydGVkLFxyXG4gICAgICAgICAgICAgICAgcmVhc29uOiBgVW53cmFwcGVkIE5hdGl2ZSBBc3NldCBpcyBub3Qgc3VwcG9ydGVkLiBVc2UgJHtzeW1ib2x9IGluc3RlYWRgLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBtZXRhLXRyYW5zYWN0aW9uIHR5cGUgdG8gcGFzcyB0byBzZXJ2aWNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWV0YVRyYW5zYWN0aW9uVHlwZShiYXNlVVJMOiBzdHJpbmcpOiBHYXNsZXNzVHlwZXMge1xyXG4gICAgaWYgKFpFUk9fR19QQVRILmluY2x1ZGVzKGJhc2VVUkwpIHx8IFpFUk9fR19BTElBU19QQVRILmluY2x1ZGVzKGJhc2VVUkwpKSB7XHJcbiAgICAgICAgcmV0dXJuIEdhc2xlc3NUeXBlcy5NZXRhVHJhbnNhY3Rpb247XHJcbiAgICB9XHJcbiAgICBpZiAoR0FTTEVTU19WMV9QQVRILmluY2x1ZGVzKGJhc2VVUkwpKSB7XHJcbiAgICAgICAgcmV0dXJuIEdhc2xlc3NUeXBlcy5NZXRhVHJhbnNhY3Rpb25WMjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW5cclxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBnYXNsZXNzIGJhc2UgVVJMJyk7XHJcbn1cclxuIl0sInZlcnNpb24iOjN9