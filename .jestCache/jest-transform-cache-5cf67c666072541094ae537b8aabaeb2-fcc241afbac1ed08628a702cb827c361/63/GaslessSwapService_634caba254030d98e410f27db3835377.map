{"file":"/Users/davidwalsh/code-local/0x-rfq-api/src/services/GaslessSwapService.ts","mappings":"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","names":[],"sources":["/Users/davidwalsh/code-local/0x-rfq-api/src/services/GaslessSwapService.ts"],"sourcesContent":["// tslint:disable:max-file-line-count\r\nimport { InternalServerError, TooManyRequestsError, ValidationError, ValidationErrorCodes } from '@0x/api-utils';\r\nimport { ITransformERC20Contract } from '@0x/contract-wrappers';\r\nimport { BigNumber, NULL_ADDRESS } from '@0x/utils';\r\nimport { AxiosInstance } from 'axios';\r\nimport { utils as ethersUtils } from 'ethers';\r\nimport Redis from 'ioredis';\r\nimport { Counter, Summary } from 'prom-client';\r\nimport { Producer } from 'sqs-producer';\r\n\r\nimport { ONE_MINUTE_S, ONE_SECOND_MS } from '../core/constants';\r\nimport { MetaTransactionJobConstructorOpts } from '../entities/MetaTransactionJobEntity';\r\nimport { RfqmJobStatus } from '../entities/types';\r\nimport { logger } from '../logger';\r\nimport { ExecuteMetaTransactionEip712Context, GaslessTypes, PermitEip712Context } from '../core/types';\r\nimport { getV1QuoteAsync } from '../utils/MetaTransactionClient';\r\nimport { RfqmDbUtils } from '../utils/rfqm_db_utils';\r\nimport { HealthCheckResult } from '../utils/rfqm_health_check';\r\nimport { RfqBlockchainUtils } from '../utils/rfq_blockchain_utils';\r\nimport { getSignerFromHash } from '../utils/signature_utils';\r\n\r\nimport { RfqmService } from './rfqm_service';\r\nimport {\r\n    FetchFirmQuoteParams,\r\n    FetchIndicativeQuoteParams,\r\n    FetchIndicativeQuoteResponse,\r\n    MetaTransactionQuoteResponse,\r\n    OtcOrderRfqmQuoteResponse,\r\n    StatusResponse,\r\n    SubmitMetaTransactionSignedQuoteParams,\r\n    SubmitMetaTransactionSignedQuoteResponse,\r\n    SubmitRfqmSignedQuoteWithApprovalParams,\r\n    SubmitRfqmSignedQuoteWithApprovalResponse,\r\n} from './types';\r\n\r\n/**\r\n * When a metatransaction quote is issued, the hash\r\n * is stored in Redis. When a quote is submitted, it\r\n * is only accepted if the metatransaction hash is in\r\n * Redis. This prevents a malicious user submitting\r\n * a quote which was not issued by 0x.\r\n *\r\n * The length of time the quote metatransaction hash\r\n * is stored in Redis.\r\n */\r\nconst META_TRANSACTION_HASH_TTL_S = 15 * ONE_MINUTE_S; // tslint:disable-line binary-expression-operand-order custom-no-magic-numbers\r\n\r\nenum GaslessSwapServiceErrorReason {\r\n    MetaTransactionAboutToExpire = 'meta_transaction_about_to_expire', // meta-transaction is about to expire\r\n    MetaTransactionPendingJobAlreadyExist = 'meta_transaction_pending_job_already_exist', // a pendingmeta-transaction job already exists for a taker-takerToken\r\n    MetaTransactionTakerBalanceCheckFailed = 'meta_transaction_taker_balance_check_failed', // taker balance check failed when submitting a meta-transaction\r\n    MetaTransactionHashNotExist = 'meta_transaction_hash_does_not_exist', // meta-transaction hash does not exist\r\n    MetaTransactionInvalidSigner = 'meta_transaction_invalid_signer', // invalid signer for the mta-transaction\r\n    MetaTransactionFailedToQueue = 'meta_transaction_failed_to_queue', // failed to queue meta-transaction\r\n    RfqPriceError = 'rfq_price_error', // encountered error when fetching rfq price\r\n    AmmPriceError = 'amm_price_error', // encountered error when fetching amm price\r\n    RfqQuoteError = 'rfq_quote_error', // encountered error when fetching rfq quote\r\n    AmmQuoteError = 'amm_quote_error', // encountered error when fetching amm quote\r\n}\r\n\r\n/**\r\n * Produces a key for Redis using the MetaTransaction hash\r\n */\r\nfunction metaTransactionHashRedisKey(hash: string): string {\r\n    return `metaTransactionHash.${hash}`;\r\n}\r\n\r\n/**\r\n * Accepts calldata for a transformErc20 call and extracts\r\n * arguments from the calldata.\r\n */\r\nfunction decodeTransformErc20Calldata(calldata: string): {\r\n    inputToken: string;\r\n    outputToken: string;\r\n    inputTokenAmount: BigNumber;\r\n    minOutputTokenAmount: BigNumber;\r\n} {\r\n    const transformErc20Interface = new ethersUtils.Interface(ITransformERC20Contract.ABI());\r\n\r\n    const result = transformErc20Interface.parseTransaction({ data: calldata });\r\n\r\n    const {\r\n        args: [inputToken, outputToken, inputTokenAmount, minOutputTokenAmount],\r\n    } = result;\r\n\r\n    return {\r\n        inputToken: inputToken as string,\r\n        outputToken: outputToken as string,\r\n        // Use `toString` because these are actually Ethers BigNumbers\r\n        inputTokenAmount: new BigNumber(inputTokenAmount.toString()),\r\n        minOutputTokenAmount: new BigNumber(minOutputTokenAmount.toString()),\r\n    };\r\n}\r\n\r\nconst ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS = new Summary({\r\n    name: 'zerog_meta_transaction_quote_request_duration_seconds',\r\n    help: 'Histogram of request duration of gasless swap',\r\n    // tslint:disable-next-line: custom-no-magic-numbers\r\n    percentiles: [0.5, 0.9, 0.95, 0.99, 0.999],\r\n    labelNames: ['chainId', 'success'],\r\n    maxAgeSeconds: 60,\r\n    ageBuckets: 5,\r\n});\r\nconst ZEROG_GASLESSS_SWAP_SERVICE_ERRORS = new Counter({\r\n    name: 'zerog_gasless_swap_service_errors_total',\r\n    labelNames: ['chainId', 'reason'],\r\n    help: 'Number of errors (with specific reason) encountered in galess swap service',\r\n});\r\n\r\n/**\r\n * Contains logic to fetch RFQm quotes, but with a fallback to\r\n * a MetaTransaction-wrapped AMM trade in the case no RFQm\r\n * liquidity is available.\r\n */\r\nexport class GaslessSwapService {\r\n    constructor(\r\n        private readonly _chainId: number,\r\n        private readonly _rfqmService: RfqmService,\r\n        private readonly _metaTransactionServiceBaseUrl: URL,\r\n        private readonly _axiosInstance: AxiosInstance,\r\n        private readonly _redis: Redis,\r\n        private readonly _dbUtils: RfqmDbUtils,\r\n        private readonly _blockchainUtils: RfqBlockchainUtils,\r\n        private readonly _sqsProducer: Producer,\r\n    ) {}\r\n\r\n    /**\r\n     * Fetches a \"price\" (aka \"Indicative Quote\").\r\n     *\r\n     * The request is first sent to market maker servers and then to the metatransaction\r\n     * service if the market makers don't provide liquidity or errors out.\r\n     *\r\n     * If RFQ liquidity exists, then it is used to compute the price.\r\n     * If AMM liquidity exists but RFQ liquidity is unavailable then\r\n     * AMM liquidity is used to compute the price.\r\n     *\r\n     * Returns `null` if neither AMM or RFQ liquidity exists.\r\n     */\r\n    public async fetchPriceAsync(\r\n        params: FetchIndicativeQuoteParams,\r\n    ): Promise<(FetchIndicativeQuoteResponse & { liquiditySource: 'rfq' | 'amm' }) | null> {\r\n        try {\r\n            const rfqPrice = await this._rfqmService.fetchIndicativeQuoteAsync(params, 'gaslessSwapRfq');\r\n\r\n            if (rfqPrice) {\r\n                return { ...rfqPrice, liquiditySource: 'rfq' };\r\n            }\r\n        } catch (e) {\r\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\r\n                this._chainId.toString(),\r\n                GaslessSwapServiceErrorReason.RfqPriceError,\r\n            ).inc();\r\n            logger.error(\r\n                { params, errorMessage: e.message, stack: e.stack },\r\n                'Encountered error when fetching RFQ price in `GaslessSwapService`',\r\n            );\r\n        }\r\n\r\n        try {\r\n            const ammPrice = await getV1QuoteAsync(\r\n                this._axiosInstance,\r\n                new URL(`${this._metaTransactionServiceBaseUrl.toString()}/quote`),\r\n                {\r\n                    ...params,\r\n                    chainId: this._chainId,\r\n                    integratorId: params.integrator.integratorId,\r\n                    // Can use the null address here since we won't be returning\r\n                    // the actual metatransaction\r\n                    takerAddress: params.takerAddress ?? NULL_ADDRESS,\r\n                },\r\n                {\r\n                    requestDurationSummary: ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS,\r\n                    chainId: this._chainId,\r\n                },\r\n                logger.warn.bind(logger),\r\n            ).then((r) => r?.price);\r\n\r\n            if (ammPrice) {\r\n                return {\r\n                    ...ammPrice,\r\n                    allowanceTarget: this._blockchainUtils.getExchangeProxyAddress(),\r\n                    liquiditySource: 'amm',\r\n                };\r\n            }\r\n        } catch (e) {\r\n            if (e instanceof ValidationError) {\r\n                throw e;\r\n            }\r\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\r\n                this._chainId.toString(),\r\n                GaslessSwapServiceErrorReason.AmmPriceError,\r\n            ).inc();\r\n            logger.error(\r\n                { params, errorMessage: e.message, stack: e.stack },\r\n                'Encountered error when fetching AMM price in `GaslessSwapService`',\r\n            );\r\n\r\n            // Throw here as it means RFQ throws / does not liquidity and AMM throws\r\n            throw new Error(`Error fetching price for ${params}`);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Fetches a \"quote\" (aka \"Firm Quote\").\r\n     *\r\n     * Liquidity selection logic is the same as with `fetchPriceAsync`.\r\n     *\r\n     * If an AMM metatransaction is selected as the liquidity source,\r\n     * its metatransaction hash is stored in Redis to be verified upon\r\n     * submit.\r\n     */\r\n    public async fetchQuoteAsync(\r\n        params: FetchFirmQuoteParams,\r\n    ): Promise<\r\n        ((OtcOrderRfqmQuoteResponse | MetaTransactionQuoteResponse) & { liquiditySource: 'rfq' | 'amm' }) | null\r\n    > {\r\n        let rfqQuoteReportId: string | null = null;\r\n        try {\r\n            const { quote: rfqQuote, quoteReportId } = await this._rfqmService.fetchFirmQuoteAsync(\r\n                params,\r\n                'gaslessSwapRfq',\r\n            );\r\n            rfqQuoteReportId = quoteReportId;\r\n            if (rfqQuote) {\r\n                return { ...rfqQuote, liquiditySource: 'rfq' };\r\n            }\r\n        } catch (e) {\r\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\r\n                this._chainId.toString(),\r\n                GaslessSwapServiceErrorReason.RfqQuoteError,\r\n            ).inc();\r\n            logger.error(\r\n                { params, errorMessage: e.message, stack: e.stack },\r\n                'Encountered error when fetching RFQ quote in `GaslessSwapService`',\r\n            );\r\n        }\r\n\r\n        try {\r\n            const ammQuote = await getV1QuoteAsync(\r\n                this._axiosInstance,\r\n                new URL(`${this._metaTransactionServiceBaseUrl.toString()}/quote`),\r\n                {\r\n                    ...params,\r\n                    chainId: this._chainId,\r\n                    affiliateAddress: params.affiliateAddress ?? params.integrator.affiliateAddress,\r\n                    integratorId: params.integrator.integratorId,\r\n                    quoteUniqueId: rfqQuoteReportId ?? undefined,\r\n                },\r\n                {\r\n                    requestDurationSummary: ZEROG_META_TRANSACTION_QUOTE_REQUEST_DURATION_SECONDS,\r\n                    chainId: this._chainId,\r\n                },\r\n                logger.warn.bind(logger),\r\n            );\r\n\r\n            if (ammQuote) {\r\n                const approval = params.checkApproval\r\n                    ? await this._rfqmService.getGaslessApprovalResponseAsync(\r\n                          params.takerAddress,\r\n                          params.sellToken,\r\n                          ammQuote.price.sellAmount,\r\n                      )\r\n                    : null;\r\n                await this._storeMetaTransactionHashAsync(ammQuote.metaTransaction.getHash());\r\n                return {\r\n                    ...ammQuote.price,\r\n                    approval: approval ?? undefined,\r\n                    metaTransaction: ammQuote.metaTransaction,\r\n                    metaTransactionHash: ammQuote.metaTransaction.getHash(),\r\n                    type: GaslessTypes.MetaTransaction,\r\n                    allowanceTarget: this._blockchainUtils.getExchangeProxyAddress(),\r\n                    liquiditySource: 'amm',\r\n                };\r\n            }\r\n        } catch (e) {\r\n            if (e instanceof ValidationError) {\r\n                throw e;\r\n            }\r\n\r\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\r\n                this._chainId.toString(),\r\n                GaslessSwapServiceErrorReason.AmmQuoteError,\r\n            ).inc();\r\n            logger.error(\r\n                { params, errorMessage: e.message, stack: e.stack },\r\n                'Encountered error when fetching AMM quote in `GaslessSwapService`',\r\n            );\r\n\r\n            // Throw here as it means RFQ throws / does not liquidity and AMM throws\r\n            throw new Error(`Error fetching quote for ${params}`);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Accepts a taker-signed MetaTransaction or OtcOrder trade, and optionally,\r\n     * a signed permit transaction, and produces the appropriate Job and sends\r\n     * a message to SQS.\r\n     *\r\n     * For lots of discussion on why the type assertions are needed, see:\r\n     * https://github.com/microsoft/TypeScript/issues/33912\r\n     */\r\n    public async processSubmitAsync<\r\n        T extends\r\n            | SubmitRfqmSignedQuoteWithApprovalParams<ExecuteMetaTransactionEip712Context | PermitEip712Context>\r\n            | SubmitMetaTransactionSignedQuoteParams<ExecuteMetaTransactionEip712Context | PermitEip712Context>,\r\n    >(\r\n        params: T,\r\n        integratorId: string,\r\n    ): Promise<\r\n        T extends SubmitRfqmSignedQuoteWithApprovalParams<ExecuteMetaTransactionEip712Context | PermitEip712Context>\r\n            ? SubmitRfqmSignedQuoteWithApprovalResponse\r\n            : SubmitMetaTransactionSignedQuoteResponse\r\n    > {\r\n        // OtcOrder\r\n        if (params.kind === GaslessTypes.OtcOrder) {\r\n            const otcOrderResult = await this._rfqmService.submitTakerSignedOtcOrderWithApprovalAsync(params);\r\n            return otcOrderResult as T extends SubmitRfqmSignedQuoteWithApprovalParams<\r\n                ExecuteMetaTransactionEip712Context | PermitEip712Context\r\n            >\r\n                ? SubmitRfqmSignedQuoteWithApprovalResponse\r\n                : SubmitMetaTransactionSignedQuoteResponse;\r\n        }\r\n\r\n        // MetaTransaction\r\n        const {\r\n            trade: { metaTransaction },\r\n        } = params;\r\n        const { inputToken, inputTokenAmount, outputToken, minOutputTokenAmount } = decodeTransformErc20Calldata(\r\n            metaTransaction.callData,\r\n        );\r\n\r\n        // Verify that the metatransaction is not expired\r\n        const currentTimeMs = new Date().getTime();\r\n        const bufferS = 30;\r\n        if (\r\n            metaTransaction.expirationTimeSeconds.minus(bufferS).times(ONE_SECOND_MS).isLessThanOrEqualTo(currentTimeMs)\r\n        ) {\r\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\r\n                this._chainId.toString(),\r\n                GaslessSwapServiceErrorReason.MetaTransactionAboutToExpire,\r\n            ).inc();\r\n            logger.warn(\r\n                { metaTransactionHash: metaTransaction.getHash() },\r\n                'Received metatransaction submission which is about to expire',\r\n            );\r\n\r\n            throw new ValidationError([\r\n                {\r\n                    field: 'expirationTimeSeconds',\r\n                    code: ValidationErrorCodes.FieldInvalid,\r\n                    reason: `trade will expire too soon`,\r\n                },\r\n            ]);\r\n        }\r\n\r\n        // Verify that the metatransaction was created by 0x API\r\n        const doesMetaTransactionHashExist = await this._doesMetaTransactionHashExistAsync(metaTransaction.getHash());\r\n        if (!doesMetaTransactionHashExist) {\r\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\r\n                this._chainId.toString(),\r\n                GaslessSwapServiceErrorReason.MetaTransactionHashNotExist,\r\n            ).inc();\r\n            logger.warn(\r\n                { metaTransactionHash: metaTransaction.getHash() },\r\n                'Received metatransaction submission not created by 0x API',\r\n            );\r\n            throw new Error('MetaTransaction hash not found');\r\n        }\r\n\r\n        // Verify that there is not a pending transaction for this taker and taker token\r\n\r\n        // TODO (rhinodavid): optimize this query by adding the taker & takerToken instead\r\n        // of filtering it out in the next step\r\n        const pendingJobs = await this._dbUtils.findMetaTransactionJobsWithStatusesAsync([\r\n            RfqmJobStatus.PendingEnqueued,\r\n            RfqmJobStatus.PendingProcessing,\r\n            RfqmJobStatus.PendingLastLookAccepted,\r\n            RfqmJobStatus.PendingSubmitted,\r\n        ]);\r\n\r\n        if (\r\n            pendingJobs.some(\r\n                (job) =>\r\n                    job.takerAddress.toLowerCase() === metaTransaction.signer.toLowerCase() &&\r\n                    job.inputToken.toLowerCase() === inputToken.toLowerCase() &&\r\n                    // Other logic handles the case where the same order is submitted twice\r\n                    job.metaTransactionHash !== metaTransaction.getHash(),\r\n            )\r\n        ) {\r\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\r\n                this._chainId.toString(),\r\n                GaslessSwapServiceErrorReason.MetaTransactionPendingJobAlreadyExist,\r\n            ).inc();\r\n            logger.warn(\r\n                {\r\n                    metaTransactionHash: metaTransaction.getHash(),\r\n                    takerToken: inputToken,\r\n                    takerAddress: metaTransaction.signer.toLowerCase(),\r\n                },\r\n                'Metatransaction submission rejected because a job is pending with the same taker and taker token',\r\n            );\r\n            throw new TooManyRequestsError('a pending trade for this taker and takertoken already exists');\r\n        }\r\n\r\n        // validate that the given taker signature is valid\r\n        const signerAddress = getSignerFromHash(metaTransaction.getHash(), params.trade.signature).toLowerCase();\r\n        if (signerAddress !== metaTransaction.signer) {\r\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\r\n                this._chainId.toString(),\r\n                GaslessSwapServiceErrorReason.MetaTransactionInvalidSigner,\r\n            ).inc();\r\n            logger.warn(\r\n                {\r\n                    metaTransactionHash: metaTransaction.getHash(),\r\n                    metaTransactionSigner: metaTransaction.signer,\r\n                    transactionSigner: signerAddress,\r\n                },\r\n                'Received submission with signer mismatch',\r\n            );\r\n            throw new ValidationError([\r\n                {\r\n                    field: 'signature',\r\n                    code: ValidationErrorCodes.InvalidSignatureOrHash,\r\n                    reason: `signature is not valid`,\r\n                },\r\n            ]);\r\n        }\r\n\r\n        // Validate that order is fillable according to balance and/or allowance.\r\n        const [takerBalance] = params.approval\r\n            ? await this._blockchainUtils.getTokenBalancesAsync([{ owner: metaTransaction.signer, token: inputToken }])\r\n            : await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync([\r\n                  { owner: metaTransaction.signer, token: inputToken },\r\n              ]);\r\n\r\n        if (takerBalance.isLessThan(inputTokenAmount)) {\r\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\r\n                this._chainId.toString(),\r\n                GaslessSwapServiceErrorReason.MetaTransactionTakerBalanceCheckFailed,\r\n            ).inc();\r\n            logger.warn(\r\n                {\r\n                    takerBalance,\r\n                    takerAddress: metaTransaction.signer,\r\n                    metaTransactionHash: metaTransaction.getHash(),\r\n                },\r\n                'Balance check failed while user was submitting',\r\n            );\r\n            throw new ValidationError([\r\n                {\r\n                    field: 'n/a',\r\n                    code: ValidationErrorCodes.InvalidOrder,\r\n                    reason: `order is not fillable`,\r\n                },\r\n            ]);\r\n        }\r\n\r\n        const rfqmApprovalOpts = params.approval\r\n            ? await this._rfqmService.createApprovalAsync(params.approval, metaTransaction.getHash(), inputToken)\r\n            : undefined;\r\n\r\n        const jobOptions: MetaTransactionJobConstructorOpts = {\r\n            chainId: this._chainId,\r\n            expiry: metaTransaction.expirationTimeSeconds,\r\n            fee: { token: metaTransaction.feeToken, amount: metaTransaction.feeAmount, type: 'fixed' },\r\n            inputToken,\r\n            inputTokenAmount,\r\n            integratorId,\r\n            metaTransaction,\r\n            metaTransactionHash: metaTransaction.getHash(),\r\n            minOutputTokenAmount,\r\n            outputToken,\r\n            takerAddress: metaTransaction.signer,\r\n            takerSignature: params.trade.signature,\r\n            ...rfqmApprovalOpts,\r\n        };\r\n\r\n        try {\r\n            const { id } = await this._dbUtils.writeMetaTransactionJobAsync(jobOptions);\r\n            await this._enqueueJobAsync(id, GaslessTypes.MetaTransaction);\r\n        } catch (error) {\r\n            ZEROG_GASLESSS_SWAP_SERVICE_ERRORS.labels(\r\n                this._chainId.toString(),\r\n                GaslessSwapServiceErrorReason.MetaTransactionFailedToQueue,\r\n            ).inc();\r\n            logger.error({ errorMessage: error.message }, 'Failed to queue the quote for submission.');\r\n            throw new InternalServerError(\r\n                `failed to queue the quote for submission, it may have already been submitted`,\r\n            );\r\n        }\r\n\r\n        const result: SubmitMetaTransactionSignedQuoteResponse = {\r\n            metaTransactionHash: metaTransaction.getHash(),\r\n            type: GaslessTypes.MetaTransaction,\r\n        };\r\n\r\n        return result as T extends SubmitRfqmSignedQuoteWithApprovalParams<\r\n            ExecuteMetaTransactionEip712Context | PermitEip712Context\r\n        >\r\n            ? SubmitRfqmSignedQuoteWithApprovalResponse\r\n            : SubmitMetaTransactionSignedQuoteResponse;\r\n    }\r\n\r\n    public async getStatusAsync(hash: string): Promise<StatusResponse | null> {\r\n        return this._rfqmService.getStatusAsync(hash);\r\n    }\r\n\r\n    /**\r\n     * Passthrough to RFQm Service's `runHealthCheckAsync` method\r\n     */\r\n    public async runHealthCheckAsync(): Promise<HealthCheckResult> {\r\n        return this._rfqmService.runHealthCheckAsync();\r\n    }\r\n\r\n    /**\r\n     * Passthrough to RFQm Service's `getTokenDecimalsAsync` method\r\n     */\r\n    public async getTokenDecimalsAsync(tokenAddress: string): Promise<number> {\r\n        return this._rfqmService.getTokenDecimalsAsync(tokenAddress);\r\n    }\r\n\r\n    private async _enqueueJobAsync(id: string, type: GaslessTypes): Promise<void> {\r\n        await this._sqsProducer.send({\r\n            groupId: id,\r\n            id,\r\n            body: JSON.stringify({ id, type }),\r\n            deduplicationId: id,\r\n        });\r\n    }\r\n\r\n    private async _doesMetaTransactionHashExistAsync(hash: string): Promise<boolean> {\r\n        return this._redis.get(metaTransactionHashRedisKey(hash)).then((r) => !!r);\r\n    }\r\n\r\n    private async _storeMetaTransactionHashAsync(hash: string): Promise<void> {\r\n        await this._redis.set(metaTransactionHashRedisKey(hash), /* value */ 0, 'EX', META_TRANSACTION_HASH_TTL_S);\r\n    }\r\n}\r\n"],"version":3}