2dafa48bb82d085d6c4ca2c1d392f7f4
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitAddresses = exports.findTokenAddressOrThrowApiError = exports.objectETHAddressNormalizer = void 0;
const api_utils_1 = require("@0x/api-utils");
const token_metadata_1 = require("@0x/token-metadata");
const utils_1 = require("@0x/utils");
/**
 * Checks top level attributes of an object for values matching an ETH address
 * and normalizes the address by turning it to lowercase
 */
const objectETHAddressNormalizer = (obj) => {
    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const normalized = {};
    for (const [key, value] of Object.entries(obj)) {
        if (value && utils_1.addressUtils.isAddress(value)) {
            normalized[key] = value.toLowerCase();
        }
    }
    return {
        ...obj,
        ...normalized,
    };
};
exports.objectETHAddressNormalizer = objectETHAddressNormalizer;
/**
 * Attempts to find the address of the token and throws if not found
 *
 * @param address the uppercase symbol of the token (ex. `REP`) or the address of the contract
 * @param chainId the Network where the address should be hosted on.
 */
function findTokenAddressOrThrowApiError(address, field, chainId) {
    try {
        return (0, token_metadata_1.findTokenAddressOrThrow)(address, chainId);
    }
    catch (e) {
        throw new api_utils_1.ValidationError([
            {
                field,
                code: api_utils_1.ValidationErrorCodes.ValueOutOfRange,
                reason: e.message,
            },
        ]);
    }
}
exports.findTokenAddressOrThrowApiError = findTokenAddressOrThrowApiError;
/**
 * Splits an array of ERC20Owner objects into string arrays of owner and token addresses.
 * This serves as an intermediate step before passing the objects to the Balance Checker contract.
 */
function splitAddresses(erc20Owners) {
    const splitAddrs = { owners: [], tokens: [] };
    if (Array.isArray(erc20Owners)) {
        return erc20Owners.reduce(({ owners, tokens }, erc20Owner) => {
            return {
                owners: owners.concat(erc20Owner.owner),
                tokens: tokens.concat(erc20Owner.token),
            };
        }, splitAddrs);
    }
    else {
        return {
            owners: [erc20Owners.owner],
            tokens: [erc20Owners.token],
        };
    }
}
exports.splitAddresses = splitAddresses;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy91dGlscy9hZGRyZXNzX3V0aWxzLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLDZDQUFzRTtBQUV0RSx1REFBNkQ7QUFDN0QscUNBQXlDO0FBSXpDOzs7R0FHRztBQUNJLE1BQU0sMEJBQTBCLEdBQUcsQ0FBSSxHQUFNLEVBQUUsRUFBRTtJQUNwRCw2REFBNkQ7SUFDN0QsOERBQThEO0lBQzlELE1BQU0sVUFBVSxHQUEyQixFQUFFLENBQUM7SUFDOUMsS0FBSyxNQUFNLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDNUMsSUFBSSxLQUFLLElBQUksb0JBQVksQ0FBQyxTQUFTLENBQUMsS0FBZSxDQUFDLEVBQUU7WUFDbEQsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFJLEtBQWdCLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDckQ7S0FDSjtJQUVELE9BQU87UUFDSCxHQUFHLEdBQUc7UUFDTixHQUFHLFVBQVU7S0FDaEIsQ0FBQztBQUNOLENBQUMsQ0FBQztBQWRXLFFBQUEsMEJBQTBCLDhCQWNyQztBQUVGOzs7OztHQUtHO0FBQ0gsU0FBZ0IsK0JBQStCLENBQUMsT0FBZSxFQUFFLEtBQWEsRUFBRSxPQUFnQjtJQUM1RixJQUFJO1FBQ0EsT0FBTyxJQUFBLHdDQUF1QixFQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztLQUNwRDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1IsTUFBTSxJQUFJLDJCQUFlLENBQUM7WUFDdEI7Z0JBQ0ksS0FBSztnQkFDTCxJQUFJLEVBQUUsZ0NBQW9CLENBQUMsZUFBZTtnQkFDMUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxPQUFPO2FBQ3BCO1NBQ0osQ0FBQyxDQUFDO0tBQ047QUFDTCxDQUFDO0FBWkQsMEVBWUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFnQixjQUFjLENBQUMsV0FBc0M7SUFDakUsTUFBTSxVQUFVLEdBQTJDLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLENBQUM7SUFDdEYsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFO1FBQzVCLE9BQU8sV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxFQUFFLFVBQVUsRUFBRSxFQUFFO1lBQ3pELE9BQU87Z0JBQ0gsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQztnQkFDdkMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQzthQUMxQyxDQUFDO1FBQ04sQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0tBQ2xCO1NBQU07UUFDSCxPQUFPO1lBQ0gsTUFBTSxFQUFFLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQztZQUMzQixNQUFNLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDO1NBQzlCLENBQUM7S0FDTDtBQUNMLENBQUM7QUFmRCx3Q0FlQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvZGF2aWR3YWxzaC9jb2RlLWxvY2FsLzB4LXJmcS1hcGkvc3JjL3V0aWxzL2FkZHJlc3NfdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9yLCBWYWxpZGF0aW9uRXJyb3JDb2RlcyB9IGZyb20gJ0AweC9hcGktdXRpbHMnO1xuaW1wb3J0IHsgQ2hhaW5JZCB9IGZyb20gJ0AweC9jb250cmFjdC1hZGRyZXNzZXMnO1xuaW1wb3J0IHsgZmluZFRva2VuQWRkcmVzc09yVGhyb3cgfSBmcm9tICdAMHgvdG9rZW4tbWV0YWRhdGEnO1xuaW1wb3J0IHsgYWRkcmVzc1V0aWxzIH0gZnJvbSAnQDB4L3V0aWxzJztcblxuaW1wb3J0IHsgRVJDMjBPd25lciB9IGZyb20gJy4uL2NvcmUvdHlwZXMnO1xuXG4vKipcbiAqIENoZWNrcyB0b3AgbGV2ZWwgYXR0cmlidXRlcyBvZiBhbiBvYmplY3QgZm9yIHZhbHVlcyBtYXRjaGluZyBhbiBFVEggYWRkcmVzc1xuICogYW5kIG5vcm1hbGl6ZXMgdGhlIGFkZHJlc3MgYnkgdHVybmluZyBpdCB0byBsb3dlcmNhc2VcbiAqL1xuZXhwb3J0IGNvbnN0IG9iamVjdEVUSEFkZHJlc3NOb3JtYWxpemVyID0gPFQ+KG9iajogVCkgPT4ge1xuICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IG5vcm1hbGl6ZWQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiBhZGRyZXNzVXRpbHMuaXNBZGRyZXNzKHZhbHVlIGFzIHN0cmluZykpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRba2V5XSA9ICh2YWx1ZSBhcyBzdHJpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5vYmosXG4gICAgICAgIC4uLm5vcm1hbGl6ZWQsXG4gICAgfTtcbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZmluZCB0aGUgYWRkcmVzcyBvZiB0aGUgdG9rZW4gYW5kIHRocm93cyBpZiBub3QgZm91bmRcbiAqXG4gKiBAcGFyYW0gYWRkcmVzcyB0aGUgdXBwZXJjYXNlIHN5bWJvbCBvZiB0aGUgdG9rZW4gKGV4LiBgUkVQYCkgb3IgdGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0XG4gKiBAcGFyYW0gY2hhaW5JZCB0aGUgTmV0d29yayB3aGVyZSB0aGUgYWRkcmVzcyBzaG91bGQgYmUgaG9zdGVkIG9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFRva2VuQWRkcmVzc09yVGhyb3dBcGlFcnJvcihhZGRyZXNzOiBzdHJpbmcsIGZpZWxkOiBzdHJpbmcsIGNoYWluSWQ6IENoYWluSWQpOiBzdHJpbmcge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmaW5kVG9rZW5BZGRyZXNzT3JUaHJvdyhhZGRyZXNzLCBjaGFpbklkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgICAgICAgIGNvZGU6IFZhbGlkYXRpb25FcnJvckNvZGVzLlZhbHVlT3V0T2ZSYW5nZSxcbiAgICAgICAgICAgICAgICByZWFzb246IGUubWVzc2FnZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTcGxpdHMgYW4gYXJyYXkgb2YgRVJDMjBPd25lciBvYmplY3RzIGludG8gc3RyaW5nIGFycmF5cyBvZiBvd25lciBhbmQgdG9rZW4gYWRkcmVzc2VzLlxuICogVGhpcyBzZXJ2ZXMgYXMgYW4gaW50ZXJtZWRpYXRlIHN0ZXAgYmVmb3JlIHBhc3NpbmcgdGhlIG9iamVjdHMgdG8gdGhlIEJhbGFuY2UgQ2hlY2tlciBjb250cmFjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0QWRkcmVzc2VzKGVyYzIwT3duZXJzOiBFUkMyME93bmVyIHwgRVJDMjBPd25lcltdKTogeyBvd25lcnM6IHN0cmluZ1tdOyB0b2tlbnM6IHN0cmluZ1tdIH0ge1xuICAgIGNvbnN0IHNwbGl0QWRkcnM6IHsgb3duZXJzOiBzdHJpbmdbXTsgdG9rZW5zOiBzdHJpbmdbXSB9ID0geyBvd25lcnM6IFtdLCB0b2tlbnM6IFtdIH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXJjMjBPd25lcnMpKSB7XG4gICAgICAgIHJldHVybiBlcmMyME93bmVycy5yZWR1Y2UoKHsgb3duZXJzLCB0b2tlbnMgfSwgZXJjMjBPd25lcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvd25lcnM6IG93bmVycy5jb25jYXQoZXJjMjBPd25lci5vd25lciksXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0b2tlbnMuY29uY2F0KGVyYzIwT3duZXIudG9rZW4pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgc3BsaXRBZGRycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG93bmVyczogW2VyYzIwT3duZXJzLm93bmVyXSxcbiAgICAgICAgICAgIHRva2VuczogW2VyYzIwT3duZXJzLnRva2VuXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4iXSwidmVyc2lvbiI6M30=