{"file":"/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_admin_service.ts","mappings":";;;AAAA,qCAAsC;AAEtC,iDAAkD;AAClD,6CAA6E;AAC7E,sCAAmC;AAKnC;;;;GAIG;AACH,MAAa,eAAe;IACxB,YAA6B,QAAqB;QAArB,aAAQ,GAAR,QAAQ,CAAa;IAAG,CAAC;IAEtD;;;OAGG;IACI,KAAK,CAAC,gBAAgB,CAAC,WAAqB,EAAE,MAAY,IAAI,IAAI,EAAE;QACvE,MAAM,YAAY,GAAa,EAAE,CAAC;QAClC,MAAM,cAAc,GAAa,EAAE,CAAC;QAEpC,MAAM,SAAS,GAAG,KAAK,EAAE,SAAiB,EAAiB,EAAE;YACzD,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,yBAAyB,CAAC,SAAS,CAAC,CAAC;YAErE,IAAI,CAAC,GAAG,EAAE;gBACN,eAAM,CAAC,KAAK,CAAC,EAAE,SAAS,EAAE,EAAE,6BAA6B,CAAC,CAAC;gBAC3D,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBAC/B,OAAO;aACV;YAED,IAAI,CAAC,iCAAyB,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;gBACjD,eAAM,CAAC,KAAK,CAAC,EAAE,SAAS,EAAE,MAAM,EAAE,GAAG,CAAC,MAAM,EAAE,EAAE,kCAAkC,CAAC,CAAC;gBACpF,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBAC/B,OAAO;aACV;YAED,IAAI;gBACA,MAAM,EAAE,MAAM,EAAE,GAAG,GAAG,CAAC;gBACvB,MAAM,uBAAuB,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,iBAAS,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC/D,MAAM,UAAU,GAAG,IAAI,iBAAS,CAAC,GAAG,CAAC,OAAO,EAAE,GAAG,yBAAa,CAAC,CAAC;gBAEhE,IAAI,UAAU,CAAC,aAAa,CAAC,uBAAuB,CAAC,EAAE;oBACnD,GAAG,CAAC,MAAM,GAAG,qBAAa,CAAC,aAAa,CAAC;oBACzC,MAAM,IAAI,CAAC,QAAQ,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC;oBAC5C,eAAM,CAAC,IAAI,CAAC,EAAE,SAAS,EAAE,EAAE,wCAAwC,CAAC,CAAC;oBACrE,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;iBAChC;qBAAM;oBACH,eAAM,CAAC,KAAK,CAAC,EAAE,SAAS,EAAE,EAAE,oCAAoC,CAAC,CAAC;oBAClE,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;iBAClC;aACJ;YAAC,OAAO,KAAK,EAAE;gBACZ,eAAM,CAAC,KAAK,CAAC,EAAE,SAAS,EAAE,EAAE,4BAA4B,CAAC,CAAC;gBAC1D,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;aAClC;QACL,CAAC,CAAC;QAEF,MAAM,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAExD,OAAO;YACH,YAAY;YACZ,cAAc;SACjB,CAAC;IACN,CAAC;CACJ;AArDD,0CAqDC","names":[],"sources":["/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_admin_service.ts"],"sourcesContent":["import { BigNumber } from '@0x/utils';\n\nimport { ONE_SECOND_MS } from '../core/constants';\nimport { RfqmJobStatus, UnresolvedRfqmJobStatuses } from '../entities/types';\nimport { logger } from '../logger';\nimport { RfqmDbUtils } from '../utils/rfqm_db_utils';\n\nimport { CleanupJobsResponse } from './types';\n\n/**\n * RfqAdminService is the coordination layer for admin HTTP services.\n * It currently uses the admin API key for authentication, but\n * this can be replaced with a more sophisticated means of authentication.\n */\nexport class RfqAdminService {\n    constructor(private readonly _dbUtils: RfqmDbUtils) {}\n\n    /**\n     * Cleans up pending jobs by manually setting the status to `FailedExpired`.\n     * Ignores jobs not in a pending status.\n     */\n    public async cleanupJobsAsync(orderHashes: string[], now: Date = new Date()): Promise<CleanupJobsResponse> {\n        const modifiedJobs: string[] = [];\n        const unmodifiedJobs: string[] = [];\n\n        const handleJob = async (orderHash: string): Promise<void> => {\n            const job = await this._dbUtils.findV2JobByOrderHashAsync(orderHash);\n\n            if (!job) {\n                logger.error({ orderHash }, `No job found for order hash`);\n                unmodifiedJobs.push(orderHash);\n                return;\n            }\n\n            if (!UnresolvedRfqmJobStatuses.includes(job.status)) {\n                logger.error({ orderHash, status: job.status }, 'Tried to clean up a resolved job');\n                unmodifiedJobs.push(orderHash);\n                return;\n            }\n\n            try {\n                const { expiry } = job;\n                const thirtySecondsPastExpiry = expiry.plus(new BigNumber(30));\n                const nowSeconds = new BigNumber(now.getTime() / ONE_SECOND_MS);\n\n                if (nowSeconds.isGreaterThan(thirtySecondsPastExpiry)) {\n                    job.status = RfqmJobStatus.FailedExpired;\n                    await this._dbUtils.updateRfqmJobAsync(job);\n                    logger.info({ orderHash }, 'Job status manually updated to failure');\n                    modifiedJobs.push(orderHash);\n                } else {\n                    logger.error({ orderHash }, 'Tried to clean up an unexpired job');\n                    unmodifiedJobs.push(orderHash);\n                }\n            } catch (error) {\n                logger.error({ orderHash }, 'Failed to clean up the job');\n                unmodifiedJobs.push(orderHash);\n            }\n        };\n\n        await Promise.all(orderHashes.map((h) => handleJob(h)));\n\n        return {\n            modifiedJobs,\n            unmodifiedJobs,\n        };\n    }\n}\n"],"version":3}