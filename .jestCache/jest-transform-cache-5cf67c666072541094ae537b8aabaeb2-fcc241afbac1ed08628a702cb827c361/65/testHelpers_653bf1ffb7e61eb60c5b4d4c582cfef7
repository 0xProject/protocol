76f0cb99e577bcc20df3f1cedc9d2b69
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.testHelpers = exports.RfqQuoteEndpoint = void 0;
const asset_swapper_1 = require("@0x/asset-swapper");
const axios_1 = require("axios");
const axios_mock_adapter_1 = require("axios-mock-adapter");
const _ = require("lodash");
var RfqQuoteEndpoint;
(function (RfqQuoteEndpoint) {
    RfqQuoteEndpoint["Indicative"] = "price";
    RfqQuoteEndpoint["Firm"] = "quote";
})(RfqQuoteEndpoint = exports.RfqQuoteEndpoint || (exports.RfqQuoteEndpoint = {}));
exports.testHelpers = {
    expectInsufficientLiquidityErrorAsync: async (expect, functionWhichTriggersErrorAsync, expectedAmountAvailableToFill) => {
        let wasErrorThrown = false;
        try {
            await functionWhichTriggersErrorAsync();
        }
        catch (e) {
            wasErrorThrown = true;
            expect(e).to.be.instanceOf(asset_swapper_1.InsufficientAssetLiquidityError);
            if (expectedAmountAvailableToFill) {
                expect(e.amountAvailableToFill).to.be.bignumber.equal(expectedAmountAvailableToFill);
            }
            else {
                expect(e.amountAvailableToFill).to.equal(undefined);
            }
        }
        expect(wasErrorThrown).to.equal(true);
    },
    /**
     * A helper utility for testing which mocks out
     * requests to RFQ-T/M providers
     */
    withMockedRfqQuotes: async (standardMockedResponses, altMockedResponses, quoteType, afterResponseCallback, axiosClient = axios_1.default) => {
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const mockedAxios = new axios_mock_adapter_1.default(axiosClient, { onNoMatch: 'throwException' });
        try {
            // Mock out Standard RFQ-T/M responses
            for (const mockedResponse of standardMockedResponses) {
                const { endpoint, requestApiKey, requestParams, responseData, responseCode } = mockedResponse;
                const requestHeaders = {
                    Accept: 'application/json, text/plain, */*',
                    '0x-api-key': requestApiKey,
                    '0x-integrator-id': requestApiKey,
                };
                if (mockedResponse.callback !== undefined) {
                    mockedAxios
                        .onGet(`${endpoint}/${quoteType}`, { params: requestParams }, requestHeaders)
                        .reply(mockedResponse.callback);
                }
                else {
                    mockedAxios
                        .onGet(`${endpoint}/${quoteType}`, { params: requestParams }, requestHeaders)
                        .replyOnce(responseCode, responseData);
                }
            }
            // Mock out Alt RFQ-T/M responses
            for (const mockedResponse of altMockedResponses) {
                const { endpoint, /* mmApiKey, */ requestData, responseData, responseCode } = mockedResponse;
                // Commented out during copy-paste
                // const requestHeaders = {
                //     Accept: 'application/json, text/plain, */*',
                //     'Content-Type': 'application/json;charset=utf-8',
                //     Authorization: `Bearer ${mmApiKey}`,
                // };
                mockedAxios
                    .onPost(`${endpoint}/quotes`, 
                // hack to get AxiosMockAdapter to recognize the match
                // b/t the mock data and the request data
                {
                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    asymmetricMatch: (x) => {
                        return _.isEqual(requestData, x);
                    },
                })
                    .replyOnce(responseCode, responseData);
            }
            // Perform the callback function, e.g. a test validation
            await afterResponseCallback();
        }
        finally {
            // Ensure we always restore axios afterwards
            mockedAxios.restore();
        }
    },
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9xdW90ZVJlcXVlc3Rvci9fX3Rlc3RzX18vdGVzdEhlbHBlcnMudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEscURBQTRGO0FBRzVGLGlDQUE2QztBQUM3QywyREFBa0Q7QUFDbEQsNEJBQTRCO0FBRTVCLElBQVksZ0JBR1g7QUFIRCxXQUFZLGdCQUFnQjtJQUN4Qix3Q0FBb0IsQ0FBQTtJQUNwQixrQ0FBYyxDQUFBO0FBQ2xCLENBQUMsRUFIVyxnQkFBZ0IsR0FBaEIsd0JBQWdCLEtBQWhCLHdCQUFnQixRQUczQjtBQUVZLFFBQUEsV0FBVyxHQUFHO0lBQ3ZCLHFDQUFxQyxFQUFFLEtBQUssRUFDeEMsTUFBeUIsRUFDekIsK0JBQW9ELEVBQ3BELDZCQUF3QyxFQUMzQixFQUFFO1FBQ2YsSUFBSSxjQUFjLEdBQUcsS0FBSyxDQUFDO1FBQzNCLElBQUk7WUFDQSxNQUFNLCtCQUErQixFQUFFLENBQUM7U0FDM0M7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNSLGNBQWMsR0FBRyxJQUFJLENBQUM7WUFDdEIsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLCtDQUErQixDQUFDLENBQUM7WUFDNUQsSUFBSSw2QkFBNkIsRUFBRTtnQkFDL0IsTUFBTSxDQUFDLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO2FBQ3hGO2lCQUFNO2dCQUNILE1BQU0sQ0FBQyxDQUFDLENBQUMscUJBQXFCLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQ3ZEO1NBQ0o7UUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBQ0Q7OztPQUdHO0lBQ0gsbUJBQW1CLEVBQUUsS0FBSyxFQUN0Qix1QkFBaUQsRUFDakQsa0JBQStDLEVBQy9DLFNBQTJCLEVBQzNCLHFCQUEwQyxFQUMxQyxjQUE2QixlQUFLLEVBQ3JCLEVBQUU7UUFDZiw2REFBNkQ7UUFDN0QsOERBQThEO1FBQzlELE1BQU0sV0FBVyxHQUFHLElBQUksNEJBQWdCLENBQUMsV0FBVyxFQUFFLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFTLENBQUMsQ0FBQztRQUM5RixJQUFJO1lBQ0Esc0NBQXNDO1lBQ3RDLEtBQUssTUFBTSxjQUFjLElBQUksdUJBQXVCLEVBQUU7Z0JBQ2xELE1BQU0sRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLEdBQUcsY0FBYyxDQUFDO2dCQUM5RixNQUFNLGNBQWMsR0FBRztvQkFDbkIsTUFBTSxFQUFFLG1DQUFtQztvQkFDM0MsWUFBWSxFQUFFLGFBQWE7b0JBQzNCLGtCQUFrQixFQUFFLGFBQWE7aUJBQ3BDLENBQUM7Z0JBQ0YsSUFBSSxjQUFjLENBQUMsUUFBUSxLQUFLLFNBQVMsRUFBRTtvQkFDdkMsV0FBVzt5QkFDTixLQUFLLENBQUMsR0FBRyxRQUFRLElBQUksU0FBUyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsYUFBYSxFQUFFLEVBQUUsY0FBYyxDQUFDO3lCQUM1RSxLQUFLLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2lCQUN2QztxQkFBTTtvQkFDSCxXQUFXO3lCQUNOLEtBQUssQ0FBQyxHQUFHLFFBQVEsSUFBSSxTQUFTLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxhQUFhLEVBQUUsRUFBRSxjQUFjLENBQUM7eUJBQzVFLFNBQVMsQ0FBQyxZQUFZLEVBQUUsWUFBWSxDQUFDLENBQUM7aUJBQzlDO2FBQ0o7WUFDRCxpQ0FBaUM7WUFDakMsS0FBSyxNQUFNLGNBQWMsSUFBSSxrQkFBa0IsRUFBRTtnQkFDN0MsTUFBTSxFQUFFLFFBQVEsRUFBRSxlQUFlLENBQUMsV0FBVyxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsR0FBRyxjQUFjLENBQUM7Z0JBQzdGLGtDQUFrQztnQkFDbEMsMkJBQTJCO2dCQUMzQixtREFBbUQ7Z0JBQ25ELHdEQUF3RDtnQkFDeEQsMkNBQTJDO2dCQUMzQyxLQUFLO2dCQUNMLFdBQVc7cUJBQ04sTUFBTSxDQUNILEdBQUcsUUFBUSxTQUFTO2dCQUNwQixzREFBc0Q7Z0JBQ3RELHlDQUF5QztnQkFDekM7b0JBQ0ksNkRBQTZEO29CQUM3RCw4REFBOEQ7b0JBQzlELGVBQWUsRUFBRSxDQUFDLENBQU0sRUFBRSxFQUFFO3dCQUN4QixPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUNyQyxDQUFDO2lCQUNKLENBR0o7cUJBQ0EsU0FBUyxDQUFDLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQzthQUM5QztZQUNELHdEQUF3RDtZQUN4RCxNQUFNLHFCQUFxQixFQUFFLENBQUM7U0FDakM7Z0JBQVM7WUFDTiw0Q0FBNEM7WUFDNUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQ3pCO0lBQ0wsQ0FBQztDQUNKLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9xdW90ZVJlcXVlc3Rvci9fX3Rlc3RzX18vdGVzdEhlbHBlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5zdWZmaWNpZW50QXNzZXRMaXF1aWRpdHlFcnJvciwgTW9ja2VkUmZxUXVvdGVSZXNwb25zZSB9IGZyb20gJ0AweC9hc3NldC1zd2FwcGVyJztcbmltcG9ydCB7IEFsdE1vY2tlZFJmcVF1b3RlUmVzcG9uc2UgfSBmcm9tICdAMHgvYXNzZXQtc3dhcHBlci9saWIvc3JjL3R5cGVzJztcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ0AweC91dGlscyc7XG5pbXBvcnQgYXhpb3MsIHsgQXhpb3NJbnN0YW5jZSB9IGZyb20gJ2F4aW9zJztcbmltcG9ydCBBeGlvc01vY2tBZGFwdGVyIGZyb20gJ2F4aW9zLW1vY2stYWRhcHRlcic7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5cbmV4cG9ydCBlbnVtIFJmcVF1b3RlRW5kcG9pbnQge1xuICAgIEluZGljYXRpdmUgPSAncHJpY2UnLFxuICAgIEZpcm0gPSAncXVvdGUnLFxufVxuXG5leHBvcnQgY29uc3QgdGVzdEhlbHBlcnMgPSB7XG4gICAgZXhwZWN0SW5zdWZmaWNpZW50TGlxdWlkaXR5RXJyb3JBc3luYzogYXN5bmMgKFxuICAgICAgICBleHBlY3Q6IENoYWkuRXhwZWN0U3RhdGljLFxuICAgICAgICBmdW5jdGlvbldoaWNoVHJpZ2dlcnNFcnJvckFzeW5jOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICBleHBlY3RlZEFtb3VudEF2YWlsYWJsZVRvRmlsbDogQmlnTnVtYmVyLFxuICAgICk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgICBsZXQgd2FzRXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGZ1bmN0aW9uV2hpY2hUcmlnZ2Vyc0Vycm9yQXN5bmMoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgd2FzRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgZXhwZWN0KGUpLnRvLmJlLmluc3RhbmNlT2YoSW5zdWZmaWNpZW50QXNzZXRMaXF1aWRpdHlFcnJvcik7XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRBbW91bnRBdmFpbGFibGVUb0ZpbGwpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoZS5hbW91bnRBdmFpbGFibGVUb0ZpbGwpLnRvLmJlLmJpZ251bWJlci5lcXVhbChleHBlY3RlZEFtb3VudEF2YWlsYWJsZVRvRmlsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cGVjdChlLmFtb3VudEF2YWlsYWJsZVRvRmlsbCkudG8uZXF1YWwodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCh3YXNFcnJvclRocm93bikudG8uZXF1YWwodHJ1ZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciB1dGlsaXR5IGZvciB0ZXN0aW5nIHdoaWNoIG1vY2tzIG91dFxuICAgICAqIHJlcXVlc3RzIHRvIFJGUS1UL00gcHJvdmlkZXJzXG4gICAgICovXG4gICAgd2l0aE1vY2tlZFJmcVF1b3RlczogYXN5bmMgKFxuICAgICAgICBzdGFuZGFyZE1vY2tlZFJlc3BvbnNlczogTW9ja2VkUmZxUXVvdGVSZXNwb25zZVtdLFxuICAgICAgICBhbHRNb2NrZWRSZXNwb25zZXM6IEFsdE1vY2tlZFJmcVF1b3RlUmVzcG9uc2VbXSxcbiAgICAgICAgcXVvdGVUeXBlOiBSZnFRdW90ZUVuZHBvaW50LFxuICAgICAgICBhZnRlclJlc3BvbnNlQ2FsbGJhY2s6ICgpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgIGF4aW9zQ2xpZW50OiBBeGlvc0luc3RhbmNlID0gYXhpb3MsXG4gICAgKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgbW9ja2VkQXhpb3MgPSBuZXcgQXhpb3NNb2NrQWRhcHRlcihheGlvc0NsaWVudCwgeyBvbk5vTWF0Y2g6ICd0aHJvd0V4Y2VwdGlvbicgfSBhcyBhbnkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTW9jayBvdXQgU3RhbmRhcmQgUkZRLVQvTSByZXNwb25zZXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgbW9ja2VkUmVzcG9uc2Ugb2Ygc3RhbmRhcmRNb2NrZWRSZXNwb25zZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVuZHBvaW50LCByZXF1ZXN0QXBpS2V5LCByZXF1ZXN0UGFyYW1zLCByZXNwb25zZURhdGEsIHJlc3BvbnNlQ29kZSB9ID0gbW9ja2VkUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKicsXG4gICAgICAgICAgICAgICAgICAgICcweC1hcGkta2V5JzogcmVxdWVzdEFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgJzB4LWludGVncmF0b3ItaWQnOiByZXF1ZXN0QXBpS2V5LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKG1vY2tlZFJlc3BvbnNlLmNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9ja2VkQXhpb3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkdldChgJHtlbmRwb2ludH0vJHtxdW90ZVR5cGV9YCwgeyBwYXJhbXM6IHJlcXVlc3RQYXJhbXMgfSwgcmVxdWVzdEhlYWRlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbHkobW9ja2VkUmVzcG9uc2UuY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vY2tlZEF4aW9zXG4gICAgICAgICAgICAgICAgICAgICAgICAub25HZXQoYCR7ZW5kcG9pbnR9LyR7cXVvdGVUeXBlfWAsIHsgcGFyYW1zOiByZXF1ZXN0UGFyYW1zIH0sIHJlcXVlc3RIZWFkZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGx5T25jZShyZXNwb25zZUNvZGUsIHJlc3BvbnNlRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTW9jayBvdXQgQWx0IFJGUS1UL00gcmVzcG9uc2VzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1vY2tlZFJlc3BvbnNlIG9mIGFsdE1vY2tlZFJlc3BvbnNlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW5kcG9pbnQsIC8qIG1tQXBpS2V5LCAqLyByZXF1ZXN0RGF0YSwgcmVzcG9uc2VEYXRhLCByZXNwb25zZUNvZGUgfSA9IG1vY2tlZFJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIC8vIENvbW1lbnRlZCBvdXQgZHVyaW5nIGNvcHktcGFzdGVcbiAgICAgICAgICAgICAgICAvLyBjb25zdCByZXF1ZXN0SGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJyxcbiAgICAgICAgICAgICAgICAvLyAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnLFxuICAgICAgICAgICAgICAgIC8vICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7bW1BcGlLZXl9YCxcbiAgICAgICAgICAgICAgICAvLyB9O1xuICAgICAgICAgICAgICAgIG1vY2tlZEF4aW9zXG4gICAgICAgICAgICAgICAgICAgIC5vblBvc3QoXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtlbmRwb2ludH0vcXVvdGVzYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhY2sgdG8gZ2V0IEF4aW9zTW9ja0FkYXB0ZXIgdG8gcmVjb2duaXplIHRoZSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYi90IHRoZSBtb2NrIGRhdGEgYW5kIHRoZSByZXF1ZXN0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3ltbWV0cmljTWF0Y2g6ICh4OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uaXNFcXVhbChyZXF1ZXN0RGF0YSwgeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21tZW50ZWQgb3V0IHRvIGF2b2lkIG92ZXItc3BlY2lmeWluZyB3aGF0IHRoZSBtb2NrIHdpbGwgbWF0Y2ggb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAucmVwbHlPbmNlKHJlc3BvbnNlQ29kZSwgcmVzcG9uc2VEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLCBlLmcuIGEgdGVzdCB2YWxpZGF0aW9uXG4gICAgICAgICAgICBhd2FpdCBhZnRlclJlc3BvbnNlQ2FsbGJhY2soKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgcmVzdG9yZSBheGlvcyBhZnRlcndhcmRzXG4gICAgICAgICAgICBtb2NrZWRBeGlvcy5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbiJdLCJ2ZXJzaW9uIjozfQ==