{"file":"/Users/davidwalsh/code-local/0x-rfq-api/src/services/WorkerService.ts","mappings":"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","names":[],"sources":["/Users/davidwalsh/code-local/0x-rfq-api/src/services/WorkerService.ts"],"sourcesContent":["// tslint:disable:max-file-line-count\nimport { OtcOrder, Signature } from '@0x/protocol-utils';\nimport { MarketOperation } from '@0x/types';\nimport { BigNumber } from '@0x/utils';\nimport { Web3Wrapper } from '@0x/web3-wrapper';\nimport { retry } from '@lifeomic/attempt';\nimport delay from 'delay';\nimport { Counter, Gauge, Summary } from 'prom-client';\n\nimport {\n    ENABLE_LLR_COOLDOWN,\n    Integrator,\n    LLR_COOLDOWN_DURATION_SECONDS,\n    TAKER_SPECIFIED_SIDE_ENABLED,\n} from '../config';\nimport {\n    ETH_DECIMALS,\n    GAS_ESTIMATE_BUFFER,\n    GWEI_DECIMALS,\n    LLR_COOLDOWN_WINDOW_SECONDS,\n    ONE_MINUTE_S,\n    ONE_SECOND_MS,\n} from '../core/constants';\nimport { storedFeeToFee } from '../core/fee_utils';\nimport { Approval } from '../core/types';\nimport {\n    MetaTransactionJobEntity,\n    MetaTransactionSubmissionEntity,\n    RfqmV2JobEntity,\n    RfqmV2TransactionSubmissionEntity,\n} from '../entities';\nimport {\n    RfqmJobStatus,\n    RfqmTransactionSubmissionStatus,\n    RfqmTransactionSubmissionType,\n    SubmissionContextStatus,\n} from '../entities/types';\nimport { logger } from '../logger';\nimport { SignRequest } from '../quote-server/types';\nimport { CacheClient } from '../utils/cache_client';\nimport { GasStationAttendant } from '../utils/GasStationAttendant';\nimport { QuoteServerClient } from '../utils/quote_server_client';\nimport { RfqmDbUtils, storedOtcOrderToOtcOrder } from '../utils/rfqm_db_utils';\nimport { RfqBlockchainUtils } from '../utils/rfq_blockchain_utils';\nimport { RfqMakerManager } from '../utils/rfq_maker_manager';\nimport { getSignerFromHash, padSignature } from '../utils/signature_utils';\nimport { SubmissionContext } from '../utils/SubmissionContext';\n\nimport { RfqMakerBalanceCacheService } from './rfq_maker_balance_cache_service';\n\ninterface GasFees {\n    maxFeePerGas: BigNumber;\n    maxPriorityFeePerGas: BigNumber;\n}\n\n// https://stackoverflow.com/questions/47632622/typescript-and-filter-boolean\nfunction isDefined<T>(value: T): value is NonNullable<T> {\n    return value !== null && value !== undefined;\n}\n\nconst RFQM_WORKER_BALANCE = new Gauge({\n    name: 'rfqm_worker_balance',\n    labelNames: ['address', 'chain_id'],\n    help: 'Worker balance for RFQM',\n});\n\nconst RFQM_WORKER_READY = new Counter({\n    name: 'rfqm_worker_ready',\n    labelNames: ['address', 'chain_id'],\n    help: 'A worker passed the readiness check, and is ready to pick up work',\n});\n\nconst RFQM_WORKER_NOT_READY = new Counter({\n    name: 'rfqm_worker_not_ready',\n    labelNames: ['address', 'chain_id'],\n    help: 'A worker did not pass the readiness check, and was not able to pick up work',\n});\n\nconst RFQM_JOB_REPAIR = new Gauge({\n    name: 'rfqm_job_to_repair',\n    labelNames: ['address', 'chain_id'],\n    help: 'A submitted job failed and started repair mode',\n});\n\nconst RFQM_JOB_FAILED_MM_SIGNATURE_FAILED = new Counter({\n    name: 'rfqm_job_failed_mm_signature_failed',\n    help: 'A job failed because the market maker signature process failed. NOT triggered when the MM declines to sign.',\n    labelNames: ['makerUri', 'chain_id'],\n});\nconst RFQM_JOB_MM_REJECTED_LAST_LOOK = new Counter({\n    name: 'rfqm_job_mm_rejected_last_look',\n    help: 'A job rejected by market maker on last look',\n    labelNames: ['makerUri', 'chain_id'],\n});\n\nconst RFQM_PROCESS_JOB_LATENCY = new Summary({\n    name: 'rfqm_process_job_latency',\n    labelNames: ['chain_id', 'job_kind'],\n    help: 'Latency for the worker processing the job',\n});\n\nconst RFQM_JOB_COMPLETED = new Counter({\n    name: 'rfqm_job_completed',\n    help: 'An Rfqm Job completed with no errors',\n    labelNames: ['address', 'chain_id', 'job_kind'],\n});\n\nconst RFQM_JOB_COMPLETED_WITH_ERROR = new Counter({\n    name: 'rfqm_job_completed_with_error',\n    help: 'An Rfqm Job completed with an error',\n    labelNames: ['address', 'chain_id', 'job_kind'],\n});\n\nconst RFQM_CREATE_ACCESS_LIST_REQUEST = new Counter({\n    name: 'rfqm_create_access_list_request_total',\n    help: 'Number of requests for eth_createAccessList call',\n    labelNames: ['chain_id', 'status'],\n});\n\nconst RFQM_GAS_ESTIMATE_ACCESS_LIST = new Gauge({\n    name: 'rfqm_gas_estimate_acess_list',\n    help: 'Gas estimate of transaction with access list',\n    labelNames: ['chain_id'],\n});\n\nconst RFQM_GAS_ESTIMATE_NO_ACCESS_LIST = new Gauge({\n    name: 'rfqm_gas_estimate_no_access_list',\n    help: 'Gas estimate of transaction without access list',\n    labelNames: ['chain_id'],\n});\n\nconst RFQM_SIGNED_QUOTE_EXPIRY_TOO_SOON = new Counter({\n    name: 'rfqm_signed_quote_expiry_too_soon',\n    labelNames: ['chain_id'],\n    help: 'A signed quote was not queued because it would expire too soon',\n});\n\nconst RFQM_MINING_LATENCY = new Summary({\n    name: 'rfqm_mining_latency',\n    labelNames: ['chain_id'],\n    help: 'The time in seconds between when the first transaction for a job is sent and when a transaction for the job is mined',\n});\n\nconst PRICE_DECIMAL_PLACES = 6;\n\nconst MIN_GAS_PRICE_INCREASE = 0.1;\n\n// Retrying an EIP 1559 transaction: https://docs.alchemy.com/alchemy/guides/eip-1559/retry-eip-1559-tx\nconst MAX_PRIORITY_FEE_PER_GAS_MULTIPLIER = 1.5; // Increase multiplier for tip with each resubmission cycle\nconst MAX_FEE_PER_GAS_MULTIPLIER = 1.1; // Increase multiplier in max fee per gas with each cycle; limitation of geth node\n// During recovery, we may not be able to successfully execute\n// `estimateGasForAsync`. In this case we use this value.\nconst MAX_GAS_ESTIMATE = 500_000;\nconst SIMULATION_MAX_GAS_MULTIPLIER = 2; // Multiplier of configured max fee when performing transaction simulation\n\n// How often the worker should publish a heartbeat\nconst WORKER_HEARTBEAT_FREQUENCY_MS = ONE_SECOND_MS * 30; // tslint:disable-line: custom-no-magic-numbers\n\n/**\n * The service layer for Gasless Workers.\n *\n * Workers are bots with their own EOAs which pull\n * messages off an SQS queue, retrieve the related\n * job, and submit that job to the blockchain.\n */\nexport class WorkerService {\n    private _lastHeartbeatTime: Date | null = null;\n    private _maxFeePerGasCapWei: BigNumber;\n\n    public static shouldResubmitTransaction(gasFees: GasFees, gasPriceEstimate: BigNumber): boolean {\n        // Geth only allows replacement of transactions if the replacement gas price\n        // is at least 10% higher than the gas price of the transaction being replaced\n        return gasPriceEstimate.gte(gasFees.maxFeePerGas.multipliedBy(MIN_GAS_PRICE_INCREASE + 1));\n    }\n\n    // Returns a failure status for an invalid rfqm v2 job or null if job is valid.\n    public static validateRfqmV2Job(job: RfqmV2JobEntity, now: Date = new Date()): RfqmJobStatus | null {\n        const { makerUri, order, fee } = job;\n\n        if (makerUri === undefined) {\n            return RfqmJobStatus.FailedValidationNoMakerUri;\n        }\n\n        if (order === null) {\n            return RfqmJobStatus.FailedValidationNoOrder;\n        }\n\n        if (fee === null) {\n            return RfqmJobStatus.FailedValidationNoFee;\n        }\n\n        // Orders can expire if any of the following happen:\n        // 1) workers are backed up\n        // 2) an RFQM order broke during submission and the order is stuck in the queue for a long time.\n        const otcOrderStringFields = job.order.order;\n        const { expiry } = OtcOrder.parseExpiryAndNonce(new BigNumber(otcOrderStringFields.expiryAndNonce));\n        const expiryTimeMs = expiry.times(ONE_SECOND_MS);\n        if (expiryTimeMs.isNaN() || expiryTimeMs.lte(now.getTime())) {\n            return RfqmJobStatus.FailedExpired;\n        }\n        if (!job.takerSignature) {\n            return RfqmJobStatus.FailedValidationNoTakerSignature;\n        }\n\n        return null;\n    }\n\n    // Returns a failure status for an invalid meta-transaction job or null if job is valid.\n    public static validateMetaTransactionJob(\n        job: MetaTransactionJobEntity,\n        now: Date = new Date(),\n    ): RfqmJobStatus | null {\n        const { expiry, fee, metaTransaction, takerSignature } = job;\n\n        if (metaTransaction === null) {\n            return RfqmJobStatus.FailedValidationNoOrder;\n        }\n\n        if (fee === null) {\n            return RfqmJobStatus.FailedValidationNoFee;\n        }\n\n        // Orders can expire if any of the following happen:\n        // 1) workers are backed up\n        // 2) an order broke during submission and the order is stuck in the queue for a long time.\n        const expiryTimeMs = expiry.times(ONE_SECOND_MS);\n        if (expiryTimeMs.isNaN() || expiryTimeMs.lte(now.getTime())) {\n            return RfqmJobStatus.FailedExpired;\n        }\n        if (!takerSignature) {\n            return RfqmJobStatus.FailedValidationNoTakerSignature;\n        }\n\n        return null;\n    }\n\n    constructor(\n        private readonly _chainId: number,\n        private readonly _gasStationAttendant: GasStationAttendant,\n        private readonly _registryAddress: string,\n        private readonly _blockchainUtils: RfqBlockchainUtils,\n        private readonly _dbUtils: RfqmDbUtils,\n        private readonly _quoteServerClient: QuoteServerClient,\n        private readonly _transactionWatcherSleepTimeMs: number,\n        private readonly _cacheClient: CacheClient,\n        private readonly _rfqMakerBalanceCacheService: RfqMakerBalanceCacheService,\n        private readonly _rfqMakerManager: RfqMakerManager,\n        private readonly _initialMaxPriorityFeePerGasGwei: number,\n        maxFeePerGasCapGwei: number,\n        private readonly _enableAccessList?: boolean,\n    ) {\n        this._maxFeePerGasCapWei = new BigNumber(maxFeePerGasCapGwei).times(Math.pow(10, GWEI_DECIMALS));\n    }\n\n    public async workerBeforeLogicAsync(workerIndex: number, workerAddress: string): Promise<boolean> {\n        let gasPrice;\n        try {\n            gasPrice = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();\n        } catch (error) {\n            logger.error(\n                { errorMessage: error.message },\n                'Current gas price is unable to be fetched, marking worker as not ready.',\n            );\n            RFQM_WORKER_NOT_READY.labels(workerAddress, this._chainId.toString()).inc();\n            return false;\n        }\n\n        const balance = await this._blockchainUtils.getAccountBalanceAsync(workerAddress);\n        const balanceUnitAmount = Web3Wrapper.toUnitAmount(balance, ETH_DECIMALS).decimalPlaces(PRICE_DECIMAL_PLACES);\n        RFQM_WORKER_BALANCE.labels(workerAddress, this._chainId.toString()).set(balanceUnitAmount.toNumber());\n\n        // check for outstanding jobs from the worker and resolve them\n        const unresolvedJobs = await Promise.all([\n            this._dbUtils.findV2UnresolvedJobsAsync(workerAddress, this._chainId),\n            this._dbUtils.findUnresolvedMetaTransactionJobsAsync(workerAddress, this._chainId),\n        ]).then((x) => x.flat());\n\n        RFQM_JOB_REPAIR.labels(workerAddress, this._chainId.toString()).inc(unresolvedJobs.length);\n        for (const job of unresolvedJobs) {\n            const { kind } = job;\n            let jobIdentifier;\n\n            switch (kind) {\n                case 'rfqm_v2_job':\n                    jobIdentifier = job.orderHash;\n                    break;\n                case 'meta_transaction_job':\n                    jobIdentifier = job.id;\n                    break;\n                default:\n                    ((_x: never): never => {\n                        throw new Error('Unreachable');\n                    })(kind);\n            }\n\n            logger.info({ kind, jobIdentifier, workerAddress }, `Unresolved job found, attempting to reprocess`);\n            await this.processJobAsync(jobIdentifier, workerAddress, kind);\n        }\n\n        const isWorkerReady = await this._blockchainUtils.isWorkerReadyAsync(\n            this._chainId,\n            workerAddress,\n            balance,\n            BigNumber.min(gasPrice, this._maxFeePerGasCapWei),\n        );\n        if (!isWorkerReady) {\n            RFQM_WORKER_NOT_READY.labels(workerAddress, this._chainId.toString()).inc();\n            return false;\n        }\n\n        if (this._lastHeartbeatTime && Date.now() - this._lastHeartbeatTime.getTime() < WORKER_HEARTBEAT_FREQUENCY_MS) {\n            return true;\n        }\n\n        // Publish a heartbeat if the worker is ready to go\n        try {\n            if (workerIndex === undefined) {\n                throw new Error('Worker index is undefined');\n            }\n            // NOTE: when merging with `feature/multichain`, update this line with\n            // `const chainId = this._chain.chainId.\n            const chainId = this._chainId;\n            await this._dbUtils.upsertRfqmWorkerHeartbeatToDbAsync(workerAddress, workerIndex, balance, chainId);\n            this._lastHeartbeatTime = new Date();\n        } catch (error) {\n            logger.error(\n                { workerAddress, balance, errorMessage: error.message },\n                'Worker failed to write a heartbeat to storage',\n            );\n        }\n\n        RFQM_WORKER_READY.labels(workerAddress, this._chainId.toString()).inc();\n        return true;\n    }\n\n    /**\n     * Top-level logic the worker uses to take a v2 job or meta-transaction job to completion.\n     * The identifier (orderHash for v2 job and jod id for meta-transaction job) can come from\n     * either an unfinished job found during the worker before logic or from an SQS message.\n     *\n     * Big picture steps:\n     * 1. Fetch the job from the database\n     * 2. Prepare the job by validating it (and getting the market maker signature for v2 job).\n     *    This step is different for v2 and meta-transaction jobs.\n     * 3. Submit a transaction if none exist, wait for mining + confirmation,\n     *    and submit new transactions if gas prices rise\n     * 4. Finalize the job status\n     *\n     * This function is the error boundary for job processing; errors will be caught, logged\n     * and swallowed. The worker will continue along its lifecycle.\n     *\n     * This function handles processing latency metrics & job success/fail counters.\n     */\n    public async processJobAsync(\n        identifier: string,\n        workerAddress: string,\n        kind: (RfqmV2JobEntity | MetaTransactionJobEntity)['kind'] = 'rfqm_v2_job',\n    ): Promise<void> {\n        logger.info({ kind, identifier, workerAddress }, 'Start process job');\n        const timerStopFunction = RFQM_PROCESS_JOB_LATENCY.labels(this._chainId.toString(), kind).startTimer();\n\n        try {\n            // Step 1: Find the job\n            let job;\n            switch (kind) {\n                case 'rfqm_v2_job':\n                    job = await this._dbUtils.findV2JobByOrderHashAsync(identifier);\n                    break;\n                case 'meta_transaction_job':\n                    job = await this._dbUtils.findMetaTransactionJobByIdAsync(identifier);\n                    break;\n                default:\n                    ((_x: never) => {\n                        throw new Error('unreachable');\n                    })(kind);\n            }\n\n            if (!job) {\n                throw new Error('No job found for identifier');\n            }\n\n            // Step 2: Prepare the job for submission\n\n            // Claim job for worker\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-extra-non-null-assertion\n            if (job.workerAddress!! && job.workerAddress !== workerAddress) {\n                throw new Error('Worker was sent a job claimed by a different worker');\n            }\n            job.workerAddress = workerAddress;\n            await this._dbUtils.updateRfqmJobAsync(job);\n            if (job.approval) {\n                // approval and trade workflow\n                await this.processApprovalAndTradeAsync(job, workerAddress);\n            } else {\n                // trade only workflow\n                await this.processTradeAsync(job, workerAddress);\n            }\n            logger.info({ kind, identifier, workerAddress }, 'Job completed without errors');\n            RFQM_JOB_COMPLETED.labels(workerAddress, this._chainId.toString(), kind).inc();\n        } catch (error) {\n            logger.error({ kind, workerAddress, identifier, errorMessage: error.message }, 'Job completed with error');\n            RFQM_JOB_COMPLETED_WITH_ERROR.labels(workerAddress, this._chainId.toString(), kind).inc();\n        } finally {\n            timerStopFunction();\n        }\n    }\n\n    /**\n     * Process approval (gasless approval) and trade (swap with the 0x exchange proxy) submissions. For the first version,\n     * they will be processed SEQUENTIALLY. In the future, we want to send the two transaction in parallel.\n     * The reason we can't parallelize the submissions is both function would modify job.status.\n     *\n     * The method would:\n     * 1. Perform preliminary check on the job object (and updates job status to `PendingProcessing`)\n     * 2. Getting the market maker signature\n     * 3. Prepare approval\n     * 4. Submit approval\n     * 5. Wait until the approval transaction is successfully confirmed\n     * 6. Prepare trade (since the method has already got the market maker signature, it's not performed here)\n     * 7. Submit trade\n     */\n    public async processApprovalAndTradeAsync(\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\n        workerAddress: string,\n    ): Promise<void> {\n        const { approval, approvalSignature, kind } = job;\n        if (!approval || !approvalSignature) {\n            throw new Error('Non-approval job should not be processed by `processApprovalAndTradeAsync`');\n        }\n\n        // Perform preliminary check\n        await this.checkJobPreprocessingAsync(job);\n        if (kind === 'rfqm_v2_job') {\n            // Perform last look for rfqm v2 job\n            await this.checkLastLookAsync(job, workerAddress, false);\n        }\n\n        let tokenToApprove;\n        let identifier;\n        switch (kind) {\n            case 'rfqm_v2_job':\n                tokenToApprove = job.order.order.takerToken;\n                identifier = job.orderHash;\n                break;\n            case 'meta_transaction_job':\n                tokenToApprove = job.inputToken;\n                identifier = job.id;\n                break;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n\n        const approvalCalldata = await this.prepareApprovalAsync(job, tokenToApprove, approval, approvalSignature);\n        const approvalStatus = await this.submitToChainAsync({\n            kind: job.kind,\n            to: tokenToApprove,\n            from: workerAddress,\n            calldata: approvalCalldata,\n            expiry: job.expiry,\n            identifier,\n            submissionType: RfqmTransactionSubmissionType.Approval,\n            onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(\n                job,\n                RfqmTransactionSubmissionType.Approval,\n            ),\n        });\n\n        // Prepare and submit trade only if approval transaction is successful\n        if (approvalStatus === SubmissionContextStatus.SucceededConfirmed) {\n            let tradeCalldata;\n            switch (kind) {\n                case 'rfqm_v2_job':\n                    tradeCalldata = await this.preparerfqmV2TradeAsync(job, workerAddress, false);\n                    break;\n                case 'meta_transaction_job':\n                    tradeCalldata = await this.prepareMetaTransactionTradeAsync(job, workerAddress, false);\n                    break;\n                default:\n                    ((_x: never) => {\n                        throw new Error('unreachable');\n                    })(kind);\n            }\n\n            await this.submitToChainAsync({\n                kind: job.kind,\n                to: this._blockchainUtils.getExchangeProxyAddress(),\n                from: workerAddress,\n                calldata: tradeCalldata,\n                expiry: job.expiry,\n                identifier,\n                submissionType: RfqmTransactionSubmissionType.Trade,\n                onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(\n                    job,\n                    RfqmTransactionSubmissionType.Trade,\n                ),\n            });\n        }\n    }\n\n    /**\n     * Process trade (swap with the 0x exchange proxy) submissions. The method would prepare trade calldata\n     * and submit the trade to the blockchain. Note that job status would be updated to the corresponding state.\n     */\n    public async processTradeAsync(\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\n        workerAddress: string,\n    ): Promise<void> {\n        const { kind } = job;\n\n        let calldata;\n        let identifier;\n        switch (kind) {\n            case 'rfqm_v2_job':\n                identifier = job.orderHash;\n                calldata = await this.preparerfqmV2TradeAsync(job, workerAddress);\n                break;\n            case 'meta_transaction_job':\n                identifier = job.id;\n                calldata = await this.prepareMetaTransactionTradeAsync(job, workerAddress);\n                break;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n\n        await this.submitToChainAsync({\n            kind: job.kind,\n            to: this._blockchainUtils.getExchangeProxyAddress(),\n            from: workerAddress,\n            calldata,\n            expiry: job.expiry,\n            identifier,\n            submissionType: RfqmTransactionSubmissionType.Trade,\n            onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(\n                job,\n                RfqmTransactionSubmissionType.Trade,\n            ),\n        });\n    }\n\n    /**\n     * Perform preliminary checks on a job before processing.\n     *\n     * The method would:\n     * 1. Call `RfqmService.validateRfqmV2Job` / `RfqmService.validateMetaTransactionJob` and check result. If there is an error, update the job status and throw exception\n     * 2. Make sure job.takerSignature is present or throw exception\n     * 3. Update job status to `PendingProcessing` if current status is `PendingEnqueued`\n     */\n    public async checkJobPreprocessingAsync(\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\n        now: Date = new Date(),\n    ): Promise<void> {\n        const { kind, takerSignature } = job;\n        let identifier;\n        let errorStatus;\n\n        switch (kind) {\n            case 'rfqm_v2_job':\n                identifier = job.orderHash;\n                errorStatus = WorkerService.validateRfqmV2Job(job, now);\n                break;\n            case 'meta_transaction_job':\n                identifier = job.id;\n                errorStatus = WorkerService.validateMetaTransactionJob(job, now);\n                break;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n\n        if (errorStatus !== null) {\n            job.status = errorStatus;\n            await this._dbUtils.updateRfqmJobAsync(job);\n\n            if (errorStatus === RfqmJobStatus.FailedExpired) {\n                RFQM_SIGNED_QUOTE_EXPIRY_TOO_SOON.labels(this._chainId.toString()).inc();\n            }\n            logger.error({ kind, identifier, errorStatus }, 'Job failed validation');\n            throw new Error('Job failed validation');\n        }\n\n        // Existence of taker signature has already been checked by\n        // `RfqmService.validateJob(job)`. Refine the type.\n        if (!takerSignature) {\n            throw new Error('No taker signature present');\n        }\n\n        if (job.status === RfqmJobStatus.PendingEnqueued) {\n            job.status = RfqmJobStatus.PendingProcessing;\n            await this._dbUtils.updateRfqmJobAsync(job);\n        }\n    }\n\n    /**\n     * Prepares a rfqm v2 / meta-transaction job for approval submission by validatidating the job and constructing\n     * the calldata.\n     *\n     * Note that `job.status` would be modified to `FailedEthCallFailed` if transaction simulation failed.\n     *\n     * Handles retries of retryable errors. Throws for unretriable errors. Updates job in database.\n     *\n     * @returns The generated calldata for approval submission type.\n     * @throws If the approval cannot be submitted (e.g. it is expired).\n     */\n    public async prepareApprovalAsync(\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\n        tokenToApprove: string,\n        approval: Approval,\n        siganature: Signature,\n    ): Promise<string> {\n        const { kind } = job;\n        const calldata = await this._blockchainUtils.generateApprovalCalldataAsync(\n            tokenToApprove,\n            approval,\n            siganature,\n        );\n\n        let identifier;\n        let transactionSubmissions;\n        // Check to see if we have already submitted an approval transaction for this job. If we have, the job has already\n        // been checked and we can skip `eth_call` validation.\n        switch (kind) {\n            case 'rfqm_v2_job':\n                identifier = job.orderHash;\n                transactionSubmissions = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                    identifier,\n                    RfqmTransactionSubmissionType.Approval,\n                );\n                break;\n            case 'meta_transaction_job':\n                identifier = job.id;\n                transactionSubmissions = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(\n                    identifier,\n                    RfqmTransactionSubmissionType.Approval,\n                );\n                break;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n\n        if (transactionSubmissions.length) {\n            if (!job.takerSignature) {\n                // This shouldn't happen\n                throw new Error('Encountered a job with submissions but no taker signature');\n            }\n            if (job.kind === 'rfqm_v2_job' && !job.makerSignature) {\n                // This shouldn't happen\n                throw new Error('Encountered a job with submissions but no maker signature');\n            }\n\n            return calldata;\n        }\n\n        // Simulate the transaction\n        try {\n            await retry(\n                async () => {\n                    // Use `estimateGasForAsync` to simulate the transaction. In ethers.js, provider.call and\n                    // provider.send('eth_call', ...) might not throw exception and the behavior might be dependent\n                    // on providers. Revisit this later\n                    return this._blockchainUtils.estimateGasForAsync({ to: tokenToApprove, data: calldata });\n                },\n                {\n                    delay: ONE_SECOND_MS,\n                    factor: 1,\n                    maxAttempts: 3,\n                    handleError: (error, context, _options) => {\n                        const { attemptNum: attemptNumber, attemptsRemaining } = context;\n                        logger.warn(\n                            { kind, attemptNumber, attemptsRemaining, errorMessage: error.message, stack: error.stack },\n                            'Error during eth_call approval validation. Retrying.',\n                        );\n                    },\n                },\n            );\n        } catch (error) {\n            job.status = RfqmJobStatus.FailedEthCallFailed;\n            await this._dbUtils.updateRfqmJobAsync(job);\n\n            logger.error(\n                { kind, identifier, errorMessage: error.message, stack: error.stack },\n                'eth_call approval validation failed',\n            );\n            throw new Error('Eth call approval validation failed');\n        }\n\n        return calldata;\n    }\n\n    /**\n     * Prepares an RfqmV2 Job for trade submission by validatidating the job, obtaining the\n     * market maker signature, and constructing the calldata.\n     *\n     * Note that `job.status` would be modified to corresponding status. For example, if maker signature\n     * is not valid, `job.status` would be set to `FailedSignFailed`.\n     *\n     * `shouldCheckLastLook` determines if the preliminary job check and getting market maker sigature\n     * would be performed and is default to `true`.\n     *\n     * Handles retries of retryable errors. Throws for unretriable errors, and logs\n     * ONLY IF the log needs more information than the orderHash and workerAddress,\n     * which are logged by the `processJobAsync` routine.\n     * Updates job in database.\n     *\n     * @returns The generated calldata for trade submission type.\n     * @throws If the trade cannot be submitted (e.g. it is expired).\n     */\n    public async preparerfqmV2TradeAsync(\n        job: RfqmV2JobEntity,\n        workerAddress: string,\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-inferrable-types\n        shouldCheckLastLook: boolean = true,\n        now: Date = new Date(),\n    ): Promise<string> {\n        /**\n         * Ask: This is the probably the only change I made to the old trade only workflow. To change from making a copy of parameter\n         * and then returning the copied value to change parameter value directly. The rationale behind is to make the style consistent\n         * with the new generalized `submitToChainAsync` (it has to use changing parameter value paradigm in order to work). Let me know\n         * if you don't like this change.\n         */\n        const { makerUri, order, orderHash } = job;\n        const otcOrder = storedOtcOrderToOtcOrder(order);\n\n        // Check to see if we have already submitted a transaction for this job.\n        // If we have, the job is already prepared and we can skip ahead.\n        const transactionSubmissions = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(job.orderHash);\n        if (transactionSubmissions.length) {\n            if (!job.makerSignature) {\n                // This shouldn't happen\n                throw new Error('Encountered a job with submissions but no maker signature');\n            }\n            if (!job.takerSignature) {\n                // This shouldn't happen\n                throw new Error('Encountered a job with submissions but no taker signature');\n            }\n            const existingSubmissionCalldata = this._blockchainUtils.generateTakerSignedOtcOrderCallData(\n                otcOrder,\n                job.makerSignature,\n                job.takerSignature,\n                job.isUnwrap,\n                job.affiliateAddress,\n            );\n            return existingSubmissionCalldata;\n        }\n\n        if (shouldCheckLastLook) {\n            // Perform the preliminary job check and getting market maker sigature\n            await this.checkJobPreprocessingAsync(job, now);\n            await this.checkLastLookAsync(job, workerAddress, true);\n        }\n\n        // Maker signature must already be defined here -- refine the type\n        if (!job.makerSignature) {\n            throw new Error('Maker signature does not exist');\n        }\n        // Taker signature must already be defined here -- refine the type\n        if (!job.takerSignature) {\n            throw new Error('Taker signature does not exist');\n        }\n\n        // Verify the signer was the maker\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const signerAddress = getSignerFromHash(orderHash, job.makerSignature!).toLowerCase();\n        const makerAddress = order.order.maker.toLowerCase();\n        if (signerAddress !== makerAddress) {\n            logger.info({ signerAddress, makerAddress, orderHash, makerUri }, 'Possible use of smart contract wallet');\n            const isValidSigner = await this._blockchainUtils.isValidOrderSignerAsync(makerAddress, signerAddress);\n            if (!isValidSigner) {\n                job.status = RfqmJobStatus.FailedSignFailed;\n                await this._dbUtils.updateRfqmJobAsync(job);\n                throw new Error('Invalid order signer address');\n            }\n        }\n\n        // Generate the calldata\n        const calldata = this._blockchainUtils.generateTakerSignedOtcOrderCallData(\n            otcOrder,\n            job.makerSignature,\n            job.takerSignature,\n            job.isUnwrap,\n            job.affiliateAddress,\n        );\n\n        // With the Market Maker signature, execute a full eth_call to validate the\n        // transaction via `estimateGasForFillTakerSignedOtcOrderAsync`\n        try {\n            await retry(\n                async () => {\n                    // Maker signature must already be defined here -- refine the type\n                    if (!job.makerSignature) {\n                        throw new Error('Maker signature does not exist');\n                    }\n                    // Taker signature must already be defined here -- refine the type\n                    if (!job.takerSignature) {\n                        throw new Error('Taker signature does not exist');\n                    }\n\n                    return this._blockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(\n                        otcOrder,\n                        job.makerSignature,\n                        job.takerSignature,\n                        workerAddress,\n                        job.isUnwrap,\n                    );\n                },\n                {\n                    delay: ONE_SECOND_MS,\n                    factor: 1,\n                    maxAttempts: 3,\n                    handleError: (error, context, _options) => {\n                        const { attemptNum: attemptNumber, attemptsRemaining } = context;\n                        logger.warn(\n                            { orderHash, makerUri, attemptNumber, attemptsRemaining, error: error.message },\n                            'Error during eth_call validation when preparing otc order trade. Retrying',\n                        );\n                    },\n                },\n            );\n        } catch (error) {\n            job.status = RfqmJobStatus.FailedEthCallFailed;\n            await this._dbUtils.updateRfqmJobAsync(job);\n\n            logger.error(\n                { orderHash, error: error.message },\n                'eth_call validation failed when preparing otc order trade',\n            );\n\n            // Attempt to gather extra context upon eth_call failure\n            try {\n                const [makerBalance] = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(\n                    this._chainId,\n                    { owner: otcOrder.maker, token: otcOrder.makerToken },\n                );\n                const [takerBalance] = await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync({\n                    owner: otcOrder.taker,\n                    token: otcOrder.takerToken,\n                });\n                const blockNumber = await this._blockchainUtils.getCurrentBlockAsync();\n                logger.info(\n                    {\n                        makerBalance,\n                        takerBalance,\n                        calldata,\n                        blockNumber,\n                        orderHash,\n                        order: otcOrder,\n                        bucket: otcOrder.nonceBucket,\n                        nonce: otcOrder.nonce,\n                    },\n                    'Extra context after eth_call validation failed when preparing otc order trade',\n                );\n            } catch (error) {\n                logger.warn(\n                    { orderHash },\n                    'Failed to get extra context after eth_call validation failed when preparing otc order trade',\n                );\n            }\n            throw new Error('Eth call validation failed when preparing otc order trade');\n        }\n\n        return calldata;\n    }\n\n    /**\n     * Prepares a meta-transaction job for trade submission by validatidating the job and constructing the calldata.\n     *\n     * Note that `job.status` would be modified to corresponding status. For example, if the meta-transaction expires,\n     * `job.status` would be set to `FailedFailedExpired`.\n     *\n     * Handles retries of retryable errors. Throws for unretriable errors, and logs\n     * ONLY IF the log needs more information than the orderHash and workerAddress,\n     * which are logged by the `processJobAsync` routine.\n     * Updates job in database.\n     *\n     * @returns The generated calldata for trade submission type.\n     * @throws If the trade cannot be submitted (e.g. it is expired).\n     */\n    public async prepareMetaTransactionTradeAsync(\n        job: MetaTransactionJobEntity,\n        workerAddress: string,\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-inferrable-types\n        shouldValidateJob: boolean = true,\n        now: Date = new Date(),\n    ): Promise<string> {\n        // ASK: What's the difference bewtween `metaTransaction.signer` vs `metaTransaction.sender`?\n        //      Which one is the taker address?\n        const { affiliateAddress, id: jobId, inputToken, metaTransaction, takerAddress, takerSignature } = job;\n\n        // Check to see if we have already submitted a transaction for this job.\n        // If we have, the job is already prepared and we can skip ahead.\n        const transactionSubmissions = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId);\n        if (transactionSubmissions.length) {\n            if (!takerSignature) {\n                // This shouldn't happen\n                throw new Error('Encountered a job with submissions but no taker signature');\n            }\n            const existingSubmissionCalldata = this._blockchainUtils.generateMetaTransactionCallData(\n                metaTransaction,\n                takerSignature,\n                affiliateAddress,\n            );\n            return existingSubmissionCalldata;\n        }\n\n        if (shouldValidateJob) {\n            // Perform the preliminary job check\n            await this.checkJobPreprocessingAsync(job, now);\n        }\n\n        // Taker signature must already be defined here -- refine the type\n        if (!takerSignature) {\n            throw new Error('Taker signature does not exist');\n        }\n\n        // Generate the calldata\n        const calldata = this._blockchainUtils.generateMetaTransactionCallData(\n            metaTransaction,\n            takerSignature,\n            affiliateAddress,\n        );\n\n        // execute a full eth_call to validate the\n        // transaction via `estimateGasForAsync`\n        try {\n            await retry(\n                async () => {\n                    // The following gas fee operations are added because `executeMetaTransaction` in 0x Exchange Proxy\n                    // would check whether the gas price of the transaction is within a window. If left empty, it will\n                    // fail the simulation. The gas fee estimation below is the same as the first gas fee estimation\n                    // used in `submitToChain`.\n                    const gasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();\n                    const initialMaxPriorityFeePerGas = new BigNumber(this._initialMaxPriorityFeePerGasGwei).times(\n                        Math.pow(10, GWEI_DECIMALS),\n                    );\n                    const gasFees: GasFees = {\n                        maxFeePerGas: BigNumber.min(\n                            gasPriceEstimate.multipliedBy(2).plus(initialMaxPriorityFeePerGas),\n                            // If the max fee is less than the base fee, simulations will fail (unlike submissions, which may sit in the mempool).\n                            // An extra multiplier mitigates, but does not solve, the issue.\n                            this._maxFeePerGasCapWei.multipliedBy(SIMULATION_MAX_GAS_MULTIPLIER),\n                        ),\n                        maxPriorityFeePerGas: initialMaxPriorityFeePerGas,\n                    };\n\n                    return this._blockchainUtils.estimateGasForAsync({\n                        from: workerAddress,\n                        to: this._blockchainUtils.getExchangeProxyAddress(),\n                        data: calldata,\n                        maxFeePerGas: gasFees.maxFeePerGas.toString(),\n                        maxPriorityFeePerGas: gasFees.maxPriorityFeePerGas.toString(),\n                    });\n                },\n                {\n                    delay: ONE_SECOND_MS,\n                    factor: 1,\n                    maxAttempts: 3,\n                    handleError: (error, context, _options) => {\n                        const { attemptNum: attemptNumber, attemptsRemaining } = context;\n                        logger.warn(\n                            { jobId, attemptNumber, attemptsRemaining, error: error.message },\n                            'Error during eth_call validation when preparing meta-transaction trade. Retrying',\n                        );\n                    },\n                },\n            );\n        } catch (error) {\n            job.status = RfqmJobStatus.FailedEthCallFailed;\n            await this._dbUtils.updateRfqmJobAsync(job);\n\n            logger.error(\n                { jobId, error: error.message },\n                'eth_call validation failed when preparing meta-transaction trade',\n            );\n\n            // Attempt to gather extra context upon eth_call failure\n            try {\n                const [takerBalance] = await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync([\n                    { owner: takerAddress, token: inputToken },\n                ]);\n                const blockNumber = await this._blockchainUtils.getCurrentBlockAsync();\n                logger.info(\n                    {\n                        calldata,\n                        blockNumber,\n                        jobId,\n                        metaTransaction,\n                        takerBalance,\n                    },\n                    'Extra context after eth_call validation failed when preparing meta-transaction trade',\n                );\n            } catch (error) {\n                logger.warn(\n                    { jobId },\n                    'Failed to get extra context after eth_call validation failed when preparing meta-transaction trade ',\n                );\n            }\n            throw new Error('Eth call validation failed when preparing meta-transaction trade');\n        }\n\n        return calldata;\n    }\n\n    /**\n     * Check last look by getting market maker signature. Handles retries when making request to market maker servers.\n     *\n     * When verifying the order is fillable by both the maker and the taker:\n     * - If `shouldCheckAllowance` is false, the method would only check balances but not the allowances the maker and\n     *   the taker set for 0x exchange proxy because the taker allowance will not be set when `checkLastLookAsync` is called as we\n     *   want to call this method as soon as possible to mitigate the latency brought by sequential submissions\n     *   (which would lead to higher decline to sign rate).\n     * - Otherwise, both balances and allowances would be checked.\n     */\n    public async checkLastLookAsync(\n        job: RfqmV2JobEntity,\n        workerAddress: string,\n        shouldCheckAllowance: boolean,\n    ): Promise<void> {\n        const { makerUri, order, orderHash, takerSignature } = job;\n        const otcOrder = storedOtcOrderToOtcOrder(order);\n        let { makerSignature } = job;\n\n        if (makerSignature) {\n            // Market Maker had already signed order\n            logger.info({ workerAddress, orderHash }, 'Order already signed');\n        } else {\n            // validate that order is fillable by both the maker and the taker according to balances (and allowances\n            // when `shouldCheckAllowance` is true)\n            const [makerBalance] = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(this._chainId, {\n                owner: otcOrder.maker,\n                token: otcOrder.makerToken,\n            });\n            const [takerBalance] = shouldCheckAllowance\n                ? await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync({\n                      owner: otcOrder.taker,\n                      token: otcOrder.takerToken,\n                  })\n                : await this._blockchainUtils.getTokenBalancesAsync({\n                      owner: otcOrder.taker,\n                      token: otcOrder.takerToken,\n                  });\n\n            if (makerBalance.lt(otcOrder.makerAmount) || takerBalance.lt(otcOrder.takerAmount)) {\n                logger.error(\n                    {\n                        orderHash,\n                        makerBalance,\n                        takerBalance,\n                        makerAmount: otcOrder.makerAmount,\n                        takerAmount: otcOrder.takerAmount,\n                    },\n                    'Order failed pre-sign validation',\n                );\n                job.status = RfqmJobStatus.FailedPresignValidationFailed;\n                await this._dbUtils.updateRfqmJobAsync(job);\n                throw new Error('Order failed pre-sign validation');\n            }\n\n            if (!takerSignature) {\n                logger.error('Order failed pre-sign validation due to empty takerSignature');\n                job.status = RfqmJobStatus.FailedPresignValidationFailed;\n                await this._dbUtils.updateRfqmJobAsync(job);\n                throw new Error('Order failed pre-sign validation due to empty takerSignature');\n            }\n\n            const trader = getSignerFromHash(orderHash, takerSignature);\n\n            const signRequest: SignRequest = {\n                expiry: job.expiry,\n                fee: storedFeeToFee(job.fee),\n                order: otcOrder,\n                orderHash,\n                takerSignature,\n                workflow: 'rfqm',\n                trader: trader,\n                ...(job.takerSpecifiedSide &&\n                    TAKER_SPECIFIED_SIDE_ENABLED && { takerSpecifiedSide: job.takerSpecifiedSide }),\n            };\n\n            // \"Last Look\" in v1 is replaced by market maker order signing in v2.\n            const signAttemptTimeMs = Date.now();\n            try {\n                makerSignature = await retry(\n                    async () =>\n                        this._quoteServerClient\n                            .signV2Async(makerUri, job.integratorId ?? '', signRequest)\n                            .then((s) => s ?? null),\n                    {\n                        delay: ONE_SECOND_MS,\n                        factor: 2,\n                        maxAttempts: 3,\n                        handleError: (error, context, _options) => {\n                            const { attemptNum: attemptNumber, attemptsRemaining } = context;\n                            logger.warn(\n                                { orderHash, makerUri, attemptNumber, attemptsRemaining, error: error.message },\n                                'Error encountered while attempting to get market maker signature',\n                            );\n                        },\n                    },\n                );\n            } catch (error) {\n                // The sign process has failed after retries\n                RFQM_JOB_FAILED_MM_SIGNATURE_FAILED.labels(makerUri, this._chainId.toString()).inc();\n                logger.error(\n                    { orderHash, makerUri, error: error.message },\n                    'RFQM v2 job failed due to market maker sign failure',\n                );\n                job.status = RfqmJobStatus.FailedSignFailed;\n                await this._dbUtils.updateRfqmJobAsync(job);\n                throw new Error('Job failed during market maker sign attempt');\n            }\n\n            logger.info({ makerUri, signed: !!makerSignature, orderHash }, 'Got signature response from market maker');\n            if (!makerSignature) {\n                // Market Maker has declined to sign the transaction\n                RFQM_JOB_MM_REJECTED_LAST_LOOK.labels(makerUri, this._chainId.toString()).inc();\n                job.lastLookResult = false;\n                job.status = RfqmJobStatus.FailedLastLookDeclined;\n                await this._dbUtils.updateRfqmJobAsync(job);\n\n                if (ENABLE_LLR_COOLDOWN) {\n                    try {\n                        const quote = await this._dbUtils.findV2QuoteByOrderHashAsync(orderHash);\n                        if (quote === null) {\n                            throw new Error(`Failed to find quote with order hash ${orderHash}`);\n                        }\n\n                        // `bad` last look rejection, rejected within the cooldown window\n                        if (\n                            signAttemptTimeMs - quote.createdAt.valueOf() <\n                            LLR_COOLDOWN_WINDOW_SECONDS * ONE_SECOND_MS\n                        ) {\n                            const makerId = this._rfqMakerManager.findMakerIdWithRfqmUri(makerUri);\n                            if (makerId === null) {\n                                throw new Error(`Failed to find maker ID with RFQm URI ${makerUri}`);\n                            }\n\n                            const cooldownEndTimeMs = signAttemptTimeMs + LLR_COOLDOWN_DURATION_SECONDS * ONE_SECOND_MS;\n\n                            // schedule cooldown\n                            const isScheduleUpdated = await this._cacheClient.addMakerToCooldownAsync(\n                                makerId,\n                                cooldownEndTimeMs,\n                                this._chainId,\n                                otcOrder.makerToken,\n                                otcOrder.takerToken,\n                            );\n\n                            logger.info(\n                                {\n                                    makerId,\n                                    chainId: this._chainId,\n                                    makerToken: otcOrder.makerToken,\n                                    takerToken: otcOrder.takerToken,\n                                    startTime: signAttemptTimeMs,\n                                    endTime: cooldownEndTimeMs,\n                                    orderHash,\n                                    isScheduleUpdated,\n                                },\n                                'LLR cooldown scheduled',\n                            );\n\n                            try {\n                                // insert cooldown entry to db for record keeping\n                                await this._dbUtils.writeV2LastLookRejectionCooldownAsync(\n                                    makerId,\n                                    this._chainId,\n                                    otcOrder.makerToken,\n                                    otcOrder.takerToken,\n                                    new Date(signAttemptTimeMs), // startTime\n                                    new Date(cooldownEndTimeMs), // endTime\n                                    orderHash,\n                                );\n                            } catch (e) {\n                                logger.warn({ orderHash, errorMessage: e.message }, 'Saving LLR cooldown failed');\n                            }\n                        }\n                    } catch (error) {\n                        logger.warn(\n                            { errorMessage: error.message },\n                            'Encountered error when detecting bad LLR and scheduling cooldown',\n                        );\n                    }\n                }\n\n                // We'd like some data on how much the price the market maker is offering\n                // has changed. We query the market maker's price endpoint with the same\n                // trade they've just declined to sign and log the result.\n                try {\n                    const declineToSignPriceCheckTimeMs = Date.now();\n                    const otcOrderParams = QuoteServerClient.makeQueryParameters({\n                        chainId: this._chainId,\n                        txOrigin: this._registryAddress,\n                        takerAddress: otcOrder.taker,\n                        marketOperation: MarketOperation.Sell,\n                        buyTokenAddress: otcOrder.makerToken,\n                        sellTokenAddress: otcOrder.takerToken,\n                        assetFillAmount: otcOrder.takerAmount,\n                        isLastLook: true,\n                        fee: storedFeeToFee(job.fee),\n                    });\n                    // Instead of adding a dependency to `ConfigManager` to get the actual integrator\n                    // (we only have the ID at this point), just create a stand-in.\n                    // This will send the same integrator ID to the market maker; they will not be\n                    // able to tell the difference.\n                    // `logRfqMakerNetworkInteraction` does use the `label`, however, but I think the\n                    // tradeoff is reasonable.\n                    const integrator: Integrator = {\n                        apiKeys: [],\n                        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        integratorId: job.integratorId!,\n                        allowedChainIds: [this._chainId],\n                        label: 'decline-to-sign-price-check',\n                        plp: true,\n                        rfqm: true,\n                        rfqt: true,\n                    };\n                    const priceResponse = await this._quoteServerClient.getPriceV2Async(\n                        job.makerUri,\n                        integrator,\n                        otcOrderParams,\n                        (u: string) => `${u}/rfqm/v2/price`,\n                    );\n                    if (!priceResponse) {\n                        throw new Error('Failed to get a price response');\n                    }\n                    const { makerAmount: priceCheckMakerAmount, takerAmount: priceCheckTakerAmount } = priceResponse;\n                    const originalPrice = otcOrder.makerAmount.dividedBy(priceCheckTakerAmount);\n                    const priceAfterReject = priceCheckMakerAmount.dividedBy(priceCheckTakerAmount);\n                    const bipsFactor = 10000;\n                    const priceDifferenceBips = originalPrice\n                        .minus(priceAfterReject)\n                        .dividedBy(originalPrice)\n                        .absoluteValue()\n                        .times(bipsFactor)\n                        .toPrecision(1);\n                    // The time, in seconds, between when we initiated the sign attempt and when we\n                    // initiated the price check after the maker declined to sign.\n                    const priceCheckDelayS = (declineToSignPriceCheckTimeMs - signAttemptTimeMs) / ONE_SECOND_MS;\n                    logger.info(\n                        {\n                            orderHash,\n                            originalPrice: originalPrice.toNumber(),\n                            priceAfterReject: priceAfterReject.toNumber(),\n                            priceCheckDelayS,\n                            priceDifferenceBips,\n                        },\n                        'Decline to sign price check',\n                    );\n                    try {\n                        job.llRejectPriceDifferenceBps = parseInt(priceDifferenceBips, 10);\n                        await this._dbUtils.updateRfqmJobAsync(job);\n                    } catch (e) {\n                        logger.warn({ orderHash, errorMessage: e.message }, 'Saving LL reject price difference failed');\n                    }\n                } catch (error) {\n                    logger.warn(\n                        { errorMessage: error.message },\n                        'Encountered error during decline to sign price check',\n                    );\n                }\n                throw new Error('Market Maker declined to sign');\n            }\n\n            // Certain market makers are returning signature components which are missing\n            // leading bytes. Add them if they don't exist.\n            const paddedSignature = padSignature(makerSignature);\n            if (paddedSignature.r !== makerSignature.r || paddedSignature.s !== makerSignature.s) {\n                logger.warn(\n                    { orderHash, r: paddedSignature.r, s: paddedSignature.s },\n                    'Got market maker signature with missing bytes',\n                );\n                makerSignature = paddedSignature;\n            }\n\n            job.makerSignature = paddedSignature;\n            job.lastLookResult = true;\n            job.status = RfqmJobStatus.PendingLastLookAccepted;\n            await this._dbUtils.updateRfqmJobAsync(job);\n        }\n\n        // Maker signature must already be defined here -- refine the type\n        if (!makerSignature) {\n            throw new Error('Maker signature does not exist');\n        }\n\n        // Verify the signer was the maker\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const signerAddress = getSignerFromHash(orderHash, makerSignature!).toLowerCase();\n        const makerAddress = order.order.maker.toLowerCase();\n        if (signerAddress !== makerAddress) {\n            logger.info({ signerAddress, makerAddress, orderHash, makerUri }, 'Possible use of smart contract wallet');\n            const isValidSigner = await this._blockchainUtils.isValidOrderSignerAsync(makerAddress, signerAddress);\n            if (!isValidSigner) {\n                job.status = RfqmJobStatus.FailedSignFailed;\n                await this._dbUtils.updateRfqmJobAsync(job);\n                throw new Error('Invalid order signer address');\n            }\n        }\n    }\n\n    /**\n     * Submits a specific type of submission to the blockchain.\n     *\n     * First checks to see if there are previous transactions with the submission type and enters the\n     * watch loop; if not, submits an initial transaction and enters the watch loop.\n     *\n     * During the watch loop, waits for a transaction to be mined and confirmed;\n     * replaces the transaction if gas prices rise while a transactions are in the mempool.\n     *\n     * @param opts Options object that contains:\n     *        - `to`: The address to send to.\n     *        - `from`: The address submitting the transaction (usually the worker address).\n     *        - `calldata`: Calldata to submit.\n     *        - `expiry`: Exiry before the submission is considered invalid.\n     *        - `identifier`: The job identifier. For rfqm_v2_job, it should be order hash; for meta-transaction, it should be job id.\n     *        - `submissionType`: The type of submission.\n     *        - `onSubmissionContextStatusUpdate`: Callback to perform appropriate actions when the submission context statuses change.\n     *        - `now`: The current time.\n     * @returns FailedRevertedConfirmed or SucceededConfirmed.\n     * @throws Submission context status is FailedExpired or unhandled exceptions.\n     */\n    public async submitToChainAsync(opts: {\n        kind: (RfqmV2JobEntity | MetaTransactionJobEntity)['kind'];\n        to: string;\n        from: string;\n        calldata: string;\n        expiry: BigNumber;\n        identifier: string;\n        submissionType: RfqmTransactionSubmissionType;\n        onSubmissionContextStatusUpdate: (\n            newSubmissionContextStatus: SubmissionContextStatus,\n            oldSubmissionContextStatus?: SubmissionContextStatus,\n        ) => Promise<void>;\n    }): Promise<SubmissionContextStatus.FailedRevertedConfirmed | SubmissionContextStatus.SucceededConfirmed> {\n        const { kind, to, from, calldata, expiry, identifier, submissionType, onSubmissionContextStatusUpdate } = opts;\n\n        let previousSubmissionsWithPresubmits;\n        switch (kind) {\n            case 'rfqm_v2_job':\n                previousSubmissionsWithPresubmits = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(\n                    identifier,\n                    submissionType,\n                );\n                break;\n            case 'meta_transaction_job':\n                previousSubmissionsWithPresubmits = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(\n                    identifier,\n                    submissionType,\n                );\n                break;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n\n        const previousSubmissions = await this._recoverPresubmitTransactionsAsync(previousSubmissionsWithPresubmits);\n\n        const gasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();\n\n        // For the first submission, we use the \"fast\" gas estimate to approximate the base fee.\n        // We use the strategy outlined in https://www.blocknative.com/blog/eip-1559-fees --\n        // The `maxFeePerGas` is 2x the base fee (plus priority tip). Since we don't have a\n        // handy oracle for the en vogue priorty fee we start with 2 gwei and work up from there.\n        const initialMaxPriorityFeePerGas = new BigNumber(this._initialMaxPriorityFeePerGasGwei).times(\n            Math.pow(10, GWEI_DECIMALS),\n        );\n\n        let gasFees: GasFees = {\n            maxFeePerGas: BigNumber.min(\n                gasPriceEstimate.multipliedBy(2).plus(initialMaxPriorityFeePerGas),\n                this._maxFeePerGasCapWei,\n            ),\n            maxPriorityFeePerGas: initialMaxPriorityFeePerGas,\n        };\n\n        let submissionContext;\n        let nonce;\n        let gasEstimate;\n\n        if (!previousSubmissions.length) {\n            // There's an edge case here where there are previous submissions but they're all in `PRESUBMIT`.\n            // Those are filtered out if they can't be found on the blockchain so we end up here.\n            // If this occurs we need to check if the transaction is expired.\n            const nowSeconds = new BigNumber(new Date().getTime() / ONE_SECOND_MS);\n\n            if (expiry.isLessThan(nowSeconds)) {\n                await onSubmissionContextStatusUpdate(SubmissionContextStatus.FailedExpired);\n                throw new Error(`Exceed expiry ${expiry} for kind ${kind} and submission type ${submissionType}`);\n            }\n\n            logger.info({ kind, identifier, from }, 'Attempting to submit first transaction');\n            await onSubmissionContextStatusUpdate(SubmissionContextStatus.PendingSubmitted);\n\n            logger.info(\n                {\n                    kind,\n                    gasFees,\n                    gasPriceEstimate,\n                    identifier,\n                    submissionCount: 1,\n                    from,\n                    submissionType,\n                },\n                'Submitting transaction',\n            );\n\n            nonce = await this._blockchainUtils.getNonceAsync(from);\n            const gasEstimateWithoutBuffer = await this._blockchainUtils.estimateGasForAsync({\n                to,\n                from,\n                data: calldata,\n                // The following gas fee properties are added because `executeMetaTransaction` in 0x Exchange Proxy\n                // would check whether the gas price of the transaction is within a window. If left empty, it will\n                // fail the simulation.\n                maxFeePerGas: gasFees.maxFeePerGas.toString(),\n                maxPriorityFeePerGas: gasFees.maxPriorityFeePerGas.toString(),\n            });\n            // Add buffer to gas estimate returned by `eth_estimateGas` as the RPC method\n            // tends to under estimate gas usage\n            gasEstimate = Math.ceil((GAS_ESTIMATE_BUFFER + 1) * gasEstimateWithoutBuffer);\n            let accessListWithGas;\n\n            if (this._enableAccessList) {\n                try {\n                    accessListWithGas = await this._blockchainUtils.createAccessListForAsync({\n                        to,\n                        from,\n                        data: calldata,\n                    });\n                    RFQM_CREATE_ACCESS_LIST_REQUEST.labels(this._chainId.toString(), 'success').inc();\n                } catch (error) {\n                    RFQM_CREATE_ACCESS_LIST_REQUEST.labels(this._chainId.toString(), 'failure').inc();\n                    logger.warn({ kind, calldata, from }, 'Failed to create access list');\n                }\n\n                if (accessListWithGas !== undefined && accessListWithGas.gasEstimate) {\n                    // Add buffer to gas estimate returned by `eth_estimateGas` as the RPC method\n                    // tends to under estimate gas usage\n                    accessListWithGas.gasEstimate = Math.ceil(\n                        (GAS_ESTIMATE_BUFFER + 1) * accessListWithGas.gasEstimate,\n                    );\n\n                    logger.info(\n                        { gasEstimate, accessListGasEstimate: accessListWithGas.gasEstimate },\n                        'Regular gas estimate vs access list gas estimate',\n                    );\n                    RFQM_GAS_ESTIMATE_NO_ACCESS_LIST.labels(this._chainId.toString()).set(gasEstimate);\n                    RFQM_GAS_ESTIMATE_ACCESS_LIST.labels(this._chainId.toString()).set(accessListWithGas.gasEstimate);\n                }\n            }\n\n            const firstSubmission = await this._submitTransactionAsync(\n                kind,\n                identifier,\n                from,\n                calldata,\n                gasFees,\n                nonce,\n                gasEstimate,\n                submissionType,\n                to,\n            );\n\n            logger.info(\n                { kind, from, identifier, submissionType, transactionHash: firstSubmission.transactionHash },\n                'Successfully submitted transaction',\n            );\n\n            submissionContext = new SubmissionContext(this._blockchainUtils, [firstSubmission] as\n                | RfqmV2TransactionSubmissionEntity[]\n                | MetaTransactionSubmissionEntity[]);\n        } else {\n            logger.info({ kind, from, identifier, submissionType }, `Previous submissions found, recovering context`);\n            submissionContext = new SubmissionContext(this._blockchainUtils, previousSubmissions);\n            nonce = submissionContext.nonce;\n\n            // If we've already submitted a transaction and it has been mined,\n            // using `_blockchainUtils.estimateGasForAsync` will throw\n            // given the same calldata. In the edge case where a transaction has been sent\n            // but not mined, we would ideally pull the gas estimate from the previous\n            // transaction. Unfortunately, we currently do not store it on the\n            // `RfqmV2TransactionSubmissionEntity`. As a workaround, we'll just use an\n            // overestimate..\n            gasEstimate = MAX_GAS_ESTIMATE;\n        }\n\n        // The \"Watch Loop\"\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            // We've already submitted the transaction once at this point, so we first need to wait before checking the status.\n            await delay(this._transactionWatcherSleepTimeMs);\n            const oldSubmissionContextStatus = submissionContext.submissionContextStatus;\n            const newSubmissionContextStatus = await this._checkSubmissionReceiptsAndUpdateDbAsync(\n                identifier,\n                submissionContext,\n            );\n            logger.info(\n                { kind, submissionType, oldSubmissionContextStatus, newSubmissionContextStatus },\n                'Old and new submission context statuses',\n            );\n            await onSubmissionContextStatusUpdate(newSubmissionContextStatus, oldSubmissionContextStatus);\n\n            switch (newSubmissionContextStatus) {\n                case SubmissionContextStatus.PendingSubmitted:\n                    // We've put in at least one transaction but none have been mined yet.\n                    // Check to make sure we haven't passed the expiry window.\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line no-case-declarations\n                    const nowSeconds = new BigNumber(new Date().getTime() / ONE_SECOND_MS);\n\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line no-case-declarations\n                    const secondsPastExpiration = nowSeconds.minus(expiry);\n\n                    // If we're more than 120 seconds past expiration, give up.\n                    // See https://github.com/rolandkofler/blocktime for some\n                    // analysis of expected block times. Two minutes was selected\n                    // to cover most cases without locking up the worker for too long.\n                    if (secondsPastExpiration.isGreaterThan(ONE_MINUTE_S * 2)) {\n                        await onSubmissionContextStatusUpdate(\n                            SubmissionContextStatus.FailedExpired,\n                            oldSubmissionContextStatus,\n                        );\n                        throw new Error(\n                            `Exceed expiry ${expiry} for kind ${kind} and submission type ${submissionType}`,\n                        );\n                    }\n                    // If we're past expiration by less than a minute, don't put in any new transactions\n                    // but keep watching in case a receipt shows up\n                    if (secondsPastExpiration.isGreaterThan(0)) {\n                        continue;\n                    }\n\n                    // \"Fast\" gas price estimation; used to approximate the base fee\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line no-case-declarations\n                    const newGasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();\n\n                    if (submissionContext.transactionType === 0) {\n                        throw new Error('Non-EIP-1559 transactions are not implemented');\n                    }\n\n                    // We don't wait for gas conditions to change. Rather, we increase the gas\n                    // based bid based onthe knowledge that time (and therefore blocks, theoretically)\n                    // has passed without a transaction being mined.\n\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line no-case-declarations\n                    const { maxFeePerGas: oldMaxFeePerGas, maxPriorityFeePerGas: oldMaxPriorityFeePerGas } =\n                        submissionContext.maxGasFees;\n\n                    if (oldMaxFeePerGas.isGreaterThanOrEqualTo(this._maxFeePerGasCapWei)) {\n                        // If we've reached the max fee per gas we'd like to pay, just\n                        // continue watching the transactions to see if one gets mined.\n                        logger.info(\n                            { kind, submissionType, oldMaxFeePerGas, maxFeePerGasCap: this._maxFeePerGasCapWei },\n                            'Exceeds max fee per gas',\n                        );\n                        continue;\n                    }\n\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line no-case-declarations\n                    const newMaxPriorityFeePerGas = oldMaxPriorityFeePerGas\n                        .multipliedBy(MAX_PRIORITY_FEE_PER_GAS_MULTIPLIER)\n                        .integerValue(BigNumber.ROUND_CEIL);\n\n                    // The RPC nodes still need at least a 0.1 increase in both values to accept the new transaction.\n                    // For the new max fee per gas, we'll take the maximum of a 0.1 increase from the last value\n                    // or the value from an increase in the base fee.\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line no-case-declarations\n                    const newMaxFeePerGas = BigNumber.max(\n                        oldMaxFeePerGas.multipliedBy(MAX_FEE_PER_GAS_MULTIPLIER).integerValue(BigNumber.ROUND_CEIL),\n                        newGasPriceEstimate.multipliedBy(2).plus(newMaxPriorityFeePerGas),\n                    );\n\n                    gasFees = {\n                        maxFeePerGas: newMaxFeePerGas,\n                        maxPriorityFeePerGas: newMaxPriorityFeePerGas,\n                    };\n\n                    logger.info(\n                        {\n                            kind,\n                            gasFees,\n                            gasPriceEstimate,\n                            identifier,\n                            submissionCount: submissionContext.transactions.length + 1,\n                            from,\n                            submissionType,\n                        },\n                        'Submitting transaction',\n                    );\n\n                    try {\n                        const newTransaction = await this._submitTransactionAsync(\n                            kind,\n                            identifier,\n                            from,\n                            calldata,\n                            gasFees,\n                            nonce,\n                            gasEstimate,\n                            submissionType,\n                            to,\n                        );\n                        logger.info(\n                            {\n                                kind,\n                                from,\n                                identifier,\n                                transactionHash: newTransaction.transactionHash,\n                                submissionType,\n                            },\n                            'Successfully resubmited tx with higher gas price',\n                        );\n                        submissionContext.addTransaction(newTransaction);\n                    } catch (err) {\n                        const errorMessage = err.message;\n                        const isNonceTooLow = /nonce too low/.test(errorMessage);\n                        logger.warn(\n                            { from, kind, identifier, submissionType, errorMessage: err.message, isNonceTooLow },\n                            'Encountered an error re-submitting a tx',\n                        );\n                        if (isNonceTooLow) {\n                            logger.info(\n                                { from, kind, identifier, submissionType },\n                                'Ignore nonce too low error on re-submission. A previous submission was successful',\n                            );\n                            break;\n                        }\n\n                        // Rethrow on all other types of errors\n                        throw err;\n                    }\n                    break;\n\n                case SubmissionContextStatus.FailedRevertedUnconfirmed:\n                case SubmissionContextStatus.SucceededUnconfirmed:\n                    break;\n                case SubmissionContextStatus.FailedRevertedConfirmed:\n                case SubmissionContextStatus.SucceededConfirmed:\n                    return newSubmissionContextStatus;\n                default:\n                    ((_x: never) => {\n                        throw new Error('unreachable');\n                    })(newSubmissionContextStatus);\n            }\n        }\n    }\n\n    /**\n     * Get the callback function to supply to `submitToChainAsync`.\n     *\n     * Note that `job.status` would be updated to appropriate state by  the callback function according to old & new\n     * submission context status and submission type. There would be job status update ONLY IF the new and old submission\n     * context statuses differ.\n     *\n     * This function also \"closes over\" `job` so that it's accessible in the callback function. Refer the docstring of\n     * `RfqmTransactionSubmissionContextStatus` for more details on submission context.\n     *\n     * @param job A rfqm v2 job or a meta transactino job object.\n     * @param submissionType Type of submission.\n     * @returns Function would make appropriate update to job status according to submission context statuses and submission type.\n     */\n    private _getOnSubmissionContextStatusUpdateCallback(\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\n        submissionType: RfqmTransactionSubmissionType,\n    ): (\n        newSubmissionContextStatus: SubmissionContextStatus,\n        oldSubmissionContextStatus?: SubmissionContextStatus,\n    ) => Promise<void> {\n        return async (\n            newSubmissionContextStatus: SubmissionContextStatus,\n            oldSubmissionContextStatus?: SubmissionContextStatus,\n        ): Promise<void> => {\n            if (newSubmissionContextStatus !== oldSubmissionContextStatus) {\n                let newJobStatus: RfqmJobStatus;\n                switch (submissionType) {\n                    case RfqmTransactionSubmissionType.Approval:\n                        newJobStatus =\n                            SubmissionContext.approvalSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\n                        break;\n                    case RfqmTransactionSubmissionType.Trade:\n                        newJobStatus =\n                            SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\n                        break;\n                    default:\n                        ((_x: never) => {\n                            throw new Error('unreachable');\n                        })(submissionType);\n                }\n\n                job.status = newJobStatus;\n                await this._dbUtils.updateRfqmJobAsync(job);\n            }\n        };\n    }\n\n    /**\n     * Takes an array of Transaction Submissions, which may include transactions with the\n     * \"Presbumit\" status, and resolves or removes the \"Presubmit\" transactions.\n     *\n     * If there are previous submissions in the \"Presubmit\" state,\n     *\n     * For \"Presubmit\" transactions, we check to see if the transaction was actually sent to\n     * the mempool or not, as that is indeterminate. Depending on the result of the check, we\n     * update the status to \"Submitted\" or remove them from the submissions in memory.\n     * Note that we leave the transaction record present in the database so that if the worker\n     * dies again and the submission actually went through but was not found at the time of\n     * this check we can potentially recover it later.\n     */\n    private async _recoverPresubmitTransactionsAsync<\n        T extends RfqmV2TransactionSubmissionEntity[] | MetaTransactionSubmissionEntity[],\n    >(transactionSubmissions: T): Promise<T> {\n        // Any is so nasty -- https://dev.to/shadow1349/typescript-tip-of-the-week-generics-170g\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const result: any = await Promise.all(\n            transactionSubmissions.map(async (transactionSubmission) => {\n                // If the transaction is any status other than \"Presubmit\" then we'll leave it\n                if (transactionSubmission.status !== RfqmTransactionSubmissionStatus.Presubmit) {\n                    return transactionSubmission;\n                }\n                // For transactions in presubmit, check the mempool and chain to see if they exist\n                const transactionResponse = await this._blockchainUtils.getTransactionAsync(\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    transactionSubmission.transactionHash!,\n                );\n                if (transactionResponse) {\n                    // If it does exist, update the status. If not, remove it.\n                    transactionSubmission.status = RfqmTransactionSubmissionStatus.Submitted;\n                    await this._dbUtils.updateRfqmTransactionSubmissionsAsync([transactionSubmission] as T);\n                    return transactionSubmission;\n                } else {\n                    return null;\n                }\n            }),\n        ).then((x) => x.filter(isDefined));\n        return result;\n    }\n\n    /**\n     * Check for receipts from the tx hashes and update databases with status of all tx's.\n     */\n    private async _checkSubmissionReceiptsAndUpdateDbAsync(\n        identifier: string,\n        submissionContext: SubmissionContext<RfqmV2TransactionSubmissionEntity[] | MetaTransactionSubmissionEntity[]>,\n    ): Promise<\n        | SubmissionContextStatus.PendingSubmitted\n        | SubmissionContextStatus.FailedRevertedConfirmed\n        | SubmissionContextStatus.FailedRevertedUnconfirmed\n        | SubmissionContextStatus.SucceededConfirmed\n        | SubmissionContextStatus.SucceededUnconfirmed\n    > {\n        // At most one tx can be mined, since they all have the same nonce.\n        const minedReceipt = await submissionContext.getReceiptAsync();\n\n        // If the tx hasn't been mined yet, there're no database updates to do.\n        if (!minedReceipt) {\n            return SubmissionContextStatus.PendingSubmitted;\n        }\n\n        // Attempt to publish the mining latency\n        try {\n            const { timestamp: minedBlockTimestampS } = await this._blockchainUtils.getBlockAsync(\n                minedReceipt.blockHash,\n            );\n            const firstSubmissionTimestampS = submissionContext.firstSubmissionTimestampS;\n            RFQM_MINING_LATENCY.labels(this._chainId.toString()).observe(\n                minedBlockTimestampS - firstSubmissionTimestampS,\n            );\n        } catch (e) {\n            logger.warn(\n                { orderHash: identifier, errorMessage: e.message, stack: e.stack },\n                'Failed to meter the mining latency',\n            );\n        }\n\n        await submissionContext.updateForReceiptAsync(minedReceipt);\n        await this._dbUtils.updateRfqmTransactionSubmissionsAsync(submissionContext.transactions);\n        return submissionContext.submissionContextStatus;\n    }\n\n    /**\n     * Determine transaction properties and submit a transaction\n     */\n    private async _submitTransactionAsync(\n        kind: (RfqmV2JobEntity | MetaTransactionJobEntity)['kind'],\n        identifier: string,\n        workerAddress: string,\n        callData: string,\n        gasFees: GasFees,\n        nonce: number,\n        gasEstimate: number,\n        submissionType: RfqmTransactionSubmissionType = RfqmTransactionSubmissionType.Trade,\n        to: string = this._blockchainUtils.getExchangeProxyAddress(),\n    ): Promise<RfqmV2TransactionSubmissionEntity | MetaTransactionSubmissionEntity> {\n        const txOptions = {\n            ...gasFees,\n            from: workerAddress,\n            to,\n            gas: gasEstimate,\n            nonce,\n            value: 0,\n        };\n\n        const transactionRequest = this._blockchainUtils.transformTxDataToTransactionRequest(\n            txOptions,\n            this._chainId,\n            callData,\n        );\n        const { signedTransaction, transactionHash } = await this._blockchainUtils.signTransactionAsync(\n            transactionRequest,\n        );\n\n        let partialEntity;\n        let transactionSubmissionEntity;\n        switch (kind) {\n            case 'rfqm_v2_job':\n                partialEntity = {\n                    ...gasFees,\n                    transactionHash,\n                    orderHash: identifier,\n                    createdAt: new Date(),\n                    from: workerAddress,\n                    to,\n                    nonce,\n                    status: RfqmTransactionSubmissionStatus.Presubmit,\n                    type: submissionType,\n                };\n                transactionSubmissionEntity = await this._dbUtils.writeV2RfqmTransactionSubmissionToDbAsync(\n                    partialEntity,\n                );\n                break;\n            case 'meta_transaction_job':\n                partialEntity = {\n                    ...gasFees,\n                    transactionHash,\n                    metaTransactionJobId: identifier,\n                    createdAt: new Date(),\n                    from: workerAddress,\n                    to,\n                    nonce,\n                    status: RfqmTransactionSubmissionStatus.Presubmit,\n                    type: submissionType,\n                };\n                transactionSubmissionEntity = await this._dbUtils.writeMetaTransactionSubmissionAsync(partialEntity);\n                break;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n\n        const transactionHashFromSubmit = await this._blockchainUtils.submitSignedTransactionAsync(signedTransaction);\n\n        if (transactionHash !== transactionHashFromSubmit) {\n            // This should never ever happen\n            logger.error(\n                { kind, submissionType, identifier, transactionHashFromSubmit, transactionHash },\n                'Mismatch between transaction hash calculated before submit and after submit',\n            );\n            throw new Error('Mismatch between transaction hash calculated before submit and after submit');\n        }\n\n        logger.info(\n            { kind, submissionType, identifier, workerAddress, transactionHash },\n            'Transaction calldata submitted to exchange proxy',\n        );\n\n        const updatedTransactionSubmission = [\n            {\n                ...transactionSubmissionEntity,\n                status: RfqmTransactionSubmissionStatus.Submitted,\n            },\n        ] as RfqmV2TransactionSubmissionEntity[] | MetaTransactionSubmissionEntity[];\n\n        await this._dbUtils.updateRfqmTransactionSubmissionsAsync(updatedTransactionSubmission);\n\n        let updatedEntity;\n        switch (kind) {\n            case 'rfqm_v2_job':\n                updatedEntity = await this._dbUtils.findV2TransactionSubmissionByTransactionHashAsync(\n                    transactionHashFromSubmit,\n                );\n                break;\n            case 'meta_transaction_job':\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\n                // eslint-disable-next-line no-case-declarations\n                const updatedSubmissionEntities =\n                    await this._dbUtils.findMetaTransactionSubmissionsByTransactionHashAsync(\n                        transactionHashFromSubmit,\n                        submissionType,\n                    );\n                if (updatedSubmissionEntities.length !== 1) {\n                    // A transaction hash should never be submitted twice in our system. However, RFQ-562 mentioned cases like this could\n                    // happen in our system. Add more log and throw the error to surface it.\n                    logger.error(\n                        { kind, submissionType, transactionHash },\n                        'Transaction hash have been submitted not exactly once',\n                    );\n                    throw new Error('Transaction hash have been submitted not exactly once');\n                }\n\n                updatedEntity = updatedSubmissionEntities[0];\n                break;\n            default:\n                ((_x: never) => {\n                    throw new Error('unreachable');\n                })(kind);\n        }\n\n        if (!updatedEntity) {\n            // This should never happen -- we just saved it\n            throw new Error(\n                `Could not find updated entity with transaction hash ${transactionHashFromSubmit} of kind ${kind} and submission type ${submissionType}`,\n            );\n        }\n\n        return updatedEntity;\n    }\n}\n"],"version":3}