0d2a7bca82fdb4b5723493d754628590
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerService = void 0;
// tslint:disable:max-file-line-count
const protocol_utils_1 = require("@0x/protocol-utils");
const types_1 = require("@0x/types");
const utils_1 = require("@0x/utils");
const web3_wrapper_1 = require("@0x/web3-wrapper");
const attempt_1 = require("@lifeomic/attempt");
const delay_1 = require("delay");
const prom_client_1 = require("prom-client");
const config_1 = require("../config");
const constants_1 = require("../core/constants");
const fee_utils_1 = require("../core/fee_utils");
const types_2 = require("../entities/types");
const logger_1 = require("../logger");
const quote_server_client_1 = require("../utils/quote_server_client");
const rfqm_db_utils_1 = require("../utils/rfqm_db_utils");
const signature_utils_1 = require("../utils/signature_utils");
const SubmissionContext_1 = require("../utils/SubmissionContext");
// https://stackoverflow.com/questions/47632622/typescript-and-filter-boolean
function isDefined(value) {
    return value !== null && value !== undefined;
}
const RFQM_WORKER_BALANCE = new prom_client_1.Gauge({
    name: 'rfqm_worker_balance',
    labelNames: ['address', 'chain_id'],
    help: 'Worker balance for RFQM',
});
const RFQM_WORKER_READY = new prom_client_1.Counter({
    name: 'rfqm_worker_ready',
    labelNames: ['address', 'chain_id'],
    help: 'A worker passed the readiness check, and is ready to pick up work',
});
const RFQM_WORKER_NOT_READY = new prom_client_1.Counter({
    name: 'rfqm_worker_not_ready',
    labelNames: ['address', 'chain_id'],
    help: 'A worker did not pass the readiness check, and was not able to pick up work',
});
const RFQM_JOB_REPAIR = new prom_client_1.Gauge({
    name: 'rfqm_job_to_repair',
    labelNames: ['address', 'chain_id'],
    help: 'A submitted job failed and started repair mode',
});
const RFQM_JOB_FAILED_MM_SIGNATURE_FAILED = new prom_client_1.Counter({
    name: 'rfqm_job_failed_mm_signature_failed',
    help: 'A job failed because the market maker signature process failed. NOT triggered when the MM declines to sign.',
    labelNames: ['makerUri', 'chain_id'],
});
const RFQM_JOB_MM_REJECTED_LAST_LOOK = new prom_client_1.Counter({
    name: 'rfqm_job_mm_rejected_last_look',
    help: 'A job rejected by market maker on last look',
    labelNames: ['makerUri', 'chain_id'],
});
const RFQM_PROCESS_JOB_LATENCY = new prom_client_1.Summary({
    name: 'rfqm_process_job_latency',
    labelNames: ['chain_id', 'job_kind'],
    help: 'Latency for the worker processing the job',
});
const RFQM_JOB_COMPLETED = new prom_client_1.Counter({
    name: 'rfqm_job_completed',
    help: 'An Rfqm Job completed with no errors',
    labelNames: ['address', 'chain_id', 'job_kind'],
});
const RFQM_JOB_COMPLETED_WITH_ERROR = new prom_client_1.Counter({
    name: 'rfqm_job_completed_with_error',
    help: 'An Rfqm Job completed with an error',
    labelNames: ['address', 'chain_id', 'job_kind'],
});
const RFQM_CREATE_ACCESS_LIST_REQUEST = new prom_client_1.Counter({
    name: 'rfqm_create_access_list_request_total',
    help: 'Number of requests for eth_createAccessList call',
    labelNames: ['chain_id', 'status'],
});
const RFQM_GAS_ESTIMATE_ACCESS_LIST = new prom_client_1.Gauge({
    name: 'rfqm_gas_estimate_acess_list',
    help: 'Gas estimate of transaction with access list',
    labelNames: ['chain_id'],
});
const RFQM_GAS_ESTIMATE_NO_ACCESS_LIST = new prom_client_1.Gauge({
    name: 'rfqm_gas_estimate_no_access_list',
    help: 'Gas estimate of transaction without access list',
    labelNames: ['chain_id'],
});
const RFQM_SIGNED_QUOTE_EXPIRY_TOO_SOON = new prom_client_1.Counter({
    name: 'rfqm_signed_quote_expiry_too_soon',
    labelNames: ['chain_id'],
    help: 'A signed quote was not queued because it would expire too soon',
});
const RFQM_MINING_LATENCY = new prom_client_1.Summary({
    name: 'rfqm_mining_latency',
    labelNames: ['chain_id'],
    help: 'The time in seconds between when the first transaction for a job is sent and when a transaction for the job is mined',
});
const PRICE_DECIMAL_PLACES = 6;
const MIN_GAS_PRICE_INCREASE = 0.1;
// Retrying an EIP 1559 transaction: https://docs.alchemy.com/alchemy/guides/eip-1559/retry-eip-1559-tx
const MAX_PRIORITY_FEE_PER_GAS_MULTIPLIER = 1.5; // Increase multiplier for tip with each resubmission cycle
const MAX_FEE_PER_GAS_MULTIPLIER = 1.1; // Increase multiplier in max fee per gas with each cycle; limitation of geth node
// During recovery, we may not be able to successfully execute
// `estimateGasForAsync`. In this case we use this value.
const MAX_GAS_ESTIMATE = 500000;
const SIMULATION_MAX_GAS_MULTIPLIER = 2; // Multiplier of configured max fee when performing transaction simulation
// How often the worker should publish a heartbeat
const WORKER_HEARTBEAT_FREQUENCY_MS = constants_1.ONE_SECOND_MS * 30; // tslint:disable-line: custom-no-magic-numbers
/**
 * The service layer for Gasless Workers.
 *
 * Workers are bots with their own EOAs which pull
 * messages off an SQS queue, retrieve the related
 * job, and submit that job to the blockchain.
 */
class WorkerService {
    constructor(_chainId, _gasStationAttendant, _registryAddress, _blockchainUtils, _dbUtils, _quoteServerClient, _transactionWatcherSleepTimeMs, _cacheClient, _rfqMakerBalanceCacheService, _rfqMakerManager, _initialMaxPriorityFeePerGasGwei, maxFeePerGasCapGwei, _enableAccessList) {
        this._chainId = _chainId;
        this._gasStationAttendant = _gasStationAttendant;
        this._registryAddress = _registryAddress;
        this._blockchainUtils = _blockchainUtils;
        this._dbUtils = _dbUtils;
        this._quoteServerClient = _quoteServerClient;
        this._transactionWatcherSleepTimeMs = _transactionWatcherSleepTimeMs;
        this._cacheClient = _cacheClient;
        this._rfqMakerBalanceCacheService = _rfqMakerBalanceCacheService;
        this._rfqMakerManager = _rfqMakerManager;
        this._initialMaxPriorityFeePerGasGwei = _initialMaxPriorityFeePerGasGwei;
        this._enableAccessList = _enableAccessList;
        this._lastHeartbeatTime = null;
        this._maxFeePerGasCapWei = new utils_1.BigNumber(maxFeePerGasCapGwei).times(Math.pow(10, constants_1.GWEI_DECIMALS));
    }
    static shouldResubmitTransaction(gasFees, gasPriceEstimate) {
        // Geth only allows replacement of transactions if the replacement gas price
        // is at least 10% higher than the gas price of the transaction being replaced
        return gasPriceEstimate.gte(gasFees.maxFeePerGas.multipliedBy(MIN_GAS_PRICE_INCREASE + 1));
    }
    // Returns a failure status for an invalid rfqm v2 job or null if job is valid.
    static validateRfqmV2Job(job, now = new Date()) {
        const { makerUri, order, fee } = job;
        if (makerUri === undefined) {
            return types_2.RfqmJobStatus.FailedValidationNoMakerUri;
        }
        if (order === null) {
            return types_2.RfqmJobStatus.FailedValidationNoOrder;
        }
        if (fee === null) {
            return types_2.RfqmJobStatus.FailedValidationNoFee;
        }
        // Orders can expire if any of the following happen:
        // 1) workers are backed up
        // 2) an RFQM order broke during submission and the order is stuck in the queue for a long time.
        const otcOrderStringFields = job.order.order;
        const { expiry } = protocol_utils_1.OtcOrder.parseExpiryAndNonce(new utils_1.BigNumber(otcOrderStringFields.expiryAndNonce));
        const expiryTimeMs = expiry.times(constants_1.ONE_SECOND_MS);
        if (expiryTimeMs.isNaN() || expiryTimeMs.lte(now.getTime())) {
            return types_2.RfqmJobStatus.FailedExpired;
        }
        if (!job.takerSignature) {
            return types_2.RfqmJobStatus.FailedValidationNoTakerSignature;
        }
        return null;
    }
    // Returns a failure status for an invalid meta-transaction job or null if job is valid.
    static validateMetaTransactionJob(job, now = new Date()) {
        const { expiry, fee, metaTransaction, takerSignature } = job;
        if (metaTransaction === null) {
            return types_2.RfqmJobStatus.FailedValidationNoOrder;
        }
        if (fee === null) {
            return types_2.RfqmJobStatus.FailedValidationNoFee;
        }
        // Orders can expire if any of the following happen:
        // 1) workers are backed up
        // 2) an order broke during submission and the order is stuck in the queue for a long time.
        const expiryTimeMs = expiry.times(constants_1.ONE_SECOND_MS);
        if (expiryTimeMs.isNaN() || expiryTimeMs.lte(now.getTime())) {
            return types_2.RfqmJobStatus.FailedExpired;
        }
        if (!takerSignature) {
            return types_2.RfqmJobStatus.FailedValidationNoTakerSignature;
        }
        return null;
    }
    async workerBeforeLogicAsync(workerIndex, workerAddress) {
        let gasPrice;
        try {
            gasPrice = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();
        }
        catch (error) {
            logger_1.logger.error({ errorMessage: error.message }, 'Current gas price is unable to be fetched, marking worker as not ready.');
            RFQM_WORKER_NOT_READY.labels(workerAddress, this._chainId.toString()).inc();
            return false;
        }
        const balance = await this._blockchainUtils.getAccountBalanceAsync(workerAddress);
        const balanceUnitAmount = web3_wrapper_1.Web3Wrapper.toUnitAmount(balance, constants_1.ETH_DECIMALS).decimalPlaces(PRICE_DECIMAL_PLACES);
        RFQM_WORKER_BALANCE.labels(workerAddress, this._chainId.toString()).set(balanceUnitAmount.toNumber());
        // check for outstanding jobs from the worker and resolve them
        const unresolvedJobs = await Promise.all([
            this._dbUtils.findV2UnresolvedJobsAsync(workerAddress, this._chainId),
            this._dbUtils.findUnresolvedMetaTransactionJobsAsync(workerAddress, this._chainId),
        ]).then((x) => x.flat());
        RFQM_JOB_REPAIR.labels(workerAddress, this._chainId.toString()).inc(unresolvedJobs.length);
        for (const job of unresolvedJobs) {
            const { kind } = job;
            let jobIdentifier;
            switch (kind) {
                case 'rfqm_v2_job':
                    jobIdentifier = job.orderHash;
                    break;
                case 'meta_transaction_job':
                    jobIdentifier = job.id;
                    break;
                default:
                    ((_x) => {
                        throw new Error('Unreachable');
                    })(kind);
            }
            logger_1.logger.info({ kind, jobIdentifier, workerAddress }, `Unresolved job found, attempting to reprocess`);
            await this.processJobAsync(jobIdentifier, workerAddress, kind);
        }
        const isWorkerReady = await this._blockchainUtils.isWorkerReadyAsync(this._chainId, workerAddress, balance, utils_1.BigNumber.min(gasPrice, this._maxFeePerGasCapWei));
        if (!isWorkerReady) {
            RFQM_WORKER_NOT_READY.labels(workerAddress, this._chainId.toString()).inc();
            return false;
        }
        if (this._lastHeartbeatTime && Date.now() - this._lastHeartbeatTime.getTime() < WORKER_HEARTBEAT_FREQUENCY_MS) {
            return true;
        }
        // Publish a heartbeat if the worker is ready to go
        try {
            if (workerIndex === undefined) {
                throw new Error('Worker index is undefined');
            }
            // NOTE: when merging with `feature/multichain`, update this line with
            // `const chainId = this._chain.chainId.
            const chainId = this._chainId;
            await this._dbUtils.upsertRfqmWorkerHeartbeatToDbAsync(workerAddress, workerIndex, balance, chainId);
            this._lastHeartbeatTime = new Date();
        }
        catch (error) {
            logger_1.logger.error({ workerAddress, balance, errorMessage: error.message }, 'Worker failed to write a heartbeat to storage');
        }
        RFQM_WORKER_READY.labels(workerAddress, this._chainId.toString()).inc();
        return true;
    }
    /**
     * Top-level logic the worker uses to take a v2 job or meta-transaction job to completion.
     * The identifier (orderHash for v2 job and jod id for meta-transaction job) can come from
     * either an unfinished job found during the worker before logic or from an SQS message.
     *
     * Big picture steps:
     * 1. Fetch the job from the database
     * 2. Prepare the job by validating it (and getting the market maker signature for v2 job).
     *    This step is different for v2 and meta-transaction jobs.
     * 3. Submit a transaction if none exist, wait for mining + confirmation,
     *    and submit new transactions if gas prices rise
     * 4. Finalize the job status
     *
     * This function is the error boundary for job processing; errors will be caught, logged
     * and swallowed. The worker will continue along its lifecycle.
     *
     * This function handles processing latency metrics & job success/fail counters.
     */
    async processJobAsync(identifier, workerAddress, kind = 'rfqm_v2_job') {
        logger_1.logger.info({ kind, identifier, workerAddress }, 'Start process job');
        const timerStopFunction = RFQM_PROCESS_JOB_LATENCY.labels(this._chainId.toString(), kind).startTimer();
        try {
            // Step 1: Find the job
            let job;
            switch (kind) {
                case 'rfqm_v2_job':
                    job = await this._dbUtils.findV2JobByOrderHashAsync(identifier);
                    break;
                case 'meta_transaction_job':
                    job = await this._dbUtils.findMetaTransactionJobByIdAsync(identifier);
                    break;
                default:
                    ((_x) => {
                        throw new Error('unreachable');
                    })(kind);
            }
            if (!job) {
                throw new Error('No job found for identifier');
            }
            // Step 2: Prepare the job for submission
            // Claim job for worker
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-extra-non-null-assertion
            if (job.workerAddress && job.workerAddress !== workerAddress) {
                throw new Error('Worker was sent a job claimed by a different worker');
            }
            job.workerAddress = workerAddress;
            await this._dbUtils.updateRfqmJobAsync(job);
            if (job.approval) {
                // approval and trade workflow
                await this.processApprovalAndTradeAsync(job, workerAddress);
            }
            else {
                // trade only workflow
                await this.processTradeAsync(job, workerAddress);
            }
            logger_1.logger.info({ kind, identifier, workerAddress }, 'Job completed without errors');
            RFQM_JOB_COMPLETED.labels(workerAddress, this._chainId.toString(), kind).inc();
        }
        catch (error) {
            logger_1.logger.error({ kind, workerAddress, identifier, errorMessage: error.message }, 'Job completed with error');
            RFQM_JOB_COMPLETED_WITH_ERROR.labels(workerAddress, this._chainId.toString(), kind).inc();
        }
        finally {
            timerStopFunction();
        }
    }
    /**
     * Process approval (gasless approval) and trade (swap with the 0x exchange proxy) submissions. For the first version,
     * they will be processed SEQUENTIALLY. In the future, we want to send the two transaction in parallel.
     * The reason we can't parallelize the submissions is both function would modify job.status.
     *
     * The method would:
     * 1. Perform preliminary check on the job object (and updates job status to `PendingProcessing`)
     * 2. Getting the market maker signature
     * 3. Prepare approval
     * 4. Submit approval
     * 5. Wait until the approval transaction is successfully confirmed
     * 6. Prepare trade (since the method has already got the market maker signature, it's not performed here)
     * 7. Submit trade
     */
    async processApprovalAndTradeAsync(job, workerAddress) {
        const { approval, approvalSignature, kind } = job;
        if (!approval || !approvalSignature) {
            throw new Error('Non-approval job should not be processed by `processApprovalAndTradeAsync`');
        }
        // Perform preliminary check
        await this.checkJobPreprocessingAsync(job);
        if (kind === 'rfqm_v2_job') {
            // Perform last look for rfqm v2 job
            await this.checkLastLookAsync(job, workerAddress, false);
        }
        let tokenToApprove;
        let identifier;
        switch (kind) {
            case 'rfqm_v2_job':
                tokenToApprove = job.order.order.takerToken;
                identifier = job.orderHash;
                break;
            case 'meta_transaction_job':
                tokenToApprove = job.inputToken;
                identifier = job.id;
                break;
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(kind);
        }
        const approvalCalldata = await this.prepareApprovalAsync(job, tokenToApprove, approval, approvalSignature);
        const approvalStatus = await this.submitToChainAsync({
            kind: job.kind,
            to: tokenToApprove,
            from: workerAddress,
            calldata: approvalCalldata,
            expiry: job.expiry,
            identifier,
            submissionType: types_2.RfqmTransactionSubmissionType.Approval,
            onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(job, types_2.RfqmTransactionSubmissionType.Approval),
        });
        // Prepare and submit trade only if approval transaction is successful
        if (approvalStatus === types_2.SubmissionContextStatus.SucceededConfirmed) {
            let tradeCalldata;
            switch (kind) {
                case 'rfqm_v2_job':
                    tradeCalldata = await this.preparerfqmV2TradeAsync(job, workerAddress, false);
                    break;
                case 'meta_transaction_job':
                    tradeCalldata = await this.prepareMetaTransactionTradeAsync(job, workerAddress, false);
                    break;
                default:
                    ((_x) => {
                        throw new Error('unreachable');
                    })(kind);
            }
            await this.submitToChainAsync({
                kind: job.kind,
                to: this._blockchainUtils.getExchangeProxyAddress(),
                from: workerAddress,
                calldata: tradeCalldata,
                expiry: job.expiry,
                identifier,
                submissionType: types_2.RfqmTransactionSubmissionType.Trade,
                onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(job, types_2.RfqmTransactionSubmissionType.Trade),
            });
        }
    }
    /**
     * Process trade (swap with the 0x exchange proxy) submissions. The method would prepare trade calldata
     * and submit the trade to the blockchain. Note that job status would be updated to the corresponding state.
     */
    async processTradeAsync(job, workerAddress) {
        const { kind } = job;
        let calldata;
        let identifier;
        switch (kind) {
            case 'rfqm_v2_job':
                identifier = job.orderHash;
                calldata = await this.preparerfqmV2TradeAsync(job, workerAddress);
                break;
            case 'meta_transaction_job':
                identifier = job.id;
                calldata = await this.prepareMetaTransactionTradeAsync(job, workerAddress);
                break;
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(kind);
        }
        await this.submitToChainAsync({
            kind: job.kind,
            to: this._blockchainUtils.getExchangeProxyAddress(),
            from: workerAddress,
            calldata,
            expiry: job.expiry,
            identifier,
            submissionType: types_2.RfqmTransactionSubmissionType.Trade,
            onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(job, types_2.RfqmTransactionSubmissionType.Trade),
        });
    }
    /**
     * Perform preliminary checks on a job before processing.
     *
     * The method would:
     * 1. Call `RfqmService.validateRfqmV2Job` / `RfqmService.validateMetaTransactionJob` and check result. If there is an error, update the job status and throw exception
     * 2. Make sure job.takerSignature is present or throw exception
     * 3. Update job status to `PendingProcessing` if current status is `PendingEnqueued`
     */
    async checkJobPreprocessingAsync(job, now = new Date()) {
        const { kind, takerSignature } = job;
        let identifier;
        let errorStatus;
        switch (kind) {
            case 'rfqm_v2_job':
                identifier = job.orderHash;
                errorStatus = WorkerService.validateRfqmV2Job(job, now);
                break;
            case 'meta_transaction_job':
                identifier = job.id;
                errorStatus = WorkerService.validateMetaTransactionJob(job, now);
                break;
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(kind);
        }
        if (errorStatus !== null) {
            job.status = errorStatus;
            await this._dbUtils.updateRfqmJobAsync(job);
            if (errorStatus === types_2.RfqmJobStatus.FailedExpired) {
                RFQM_SIGNED_QUOTE_EXPIRY_TOO_SOON.labels(this._chainId.toString()).inc();
            }
            logger_1.logger.error({ kind, identifier, errorStatus }, 'Job failed validation');
            throw new Error('Job failed validation');
        }
        // Existence of taker signature has already been checked by
        // `RfqmService.validateJob(job)`. Refine the type.
        if (!takerSignature) {
            throw new Error('No taker signature present');
        }
        if (job.status === types_2.RfqmJobStatus.PendingEnqueued) {
            job.status = types_2.RfqmJobStatus.PendingProcessing;
            await this._dbUtils.updateRfqmJobAsync(job);
        }
    }
    /**
     * Prepares a rfqm v2 / meta-transaction job for approval submission by validatidating the job and constructing
     * the calldata.
     *
     * Note that `job.status` would be modified to `FailedEthCallFailed` if transaction simulation failed.
     *
     * Handles retries of retryable errors. Throws for unretriable errors. Updates job in database.
     *
     * @returns The generated calldata for approval submission type.
     * @throws If the approval cannot be submitted (e.g. it is expired).
     */
    async prepareApprovalAsync(job, tokenToApprove, approval, siganature) {
        const { kind } = job;
        const calldata = await this._blockchainUtils.generateApprovalCalldataAsync(tokenToApprove, approval, siganature);
        let identifier;
        let transactionSubmissions;
        // Check to see if we have already submitted an approval transaction for this job. If we have, the job has already
        // been checked and we can skip `eth_call` validation.
        switch (kind) {
            case 'rfqm_v2_job':
                identifier = job.orderHash;
                transactionSubmissions = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(identifier, types_2.RfqmTransactionSubmissionType.Approval);
                break;
            case 'meta_transaction_job':
                identifier = job.id;
                transactionSubmissions = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(identifier, types_2.RfqmTransactionSubmissionType.Approval);
                break;
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(kind);
        }
        if (transactionSubmissions.length) {
            if (!job.takerSignature) {
                // This shouldn't happen
                throw new Error('Encountered a job with submissions but no taker signature');
            }
            if (job.kind === 'rfqm_v2_job' && !job.makerSignature) {
                // This shouldn't happen
                throw new Error('Encountered a job with submissions but no maker signature');
            }
            return calldata;
        }
        // Simulate the transaction
        try {
            await (0, attempt_1.retry)(async () => {
                // Use `estimateGasForAsync` to simulate the transaction. In ethers.js, provider.call and
                // provider.send('eth_call', ...) might not throw exception and the behavior might be dependent
                // on providers. Revisit this later
                return this._blockchainUtils.estimateGasForAsync({ to: tokenToApprove, data: calldata });
            }, {
                delay: constants_1.ONE_SECOND_MS,
                factor: 1,
                maxAttempts: 3,
                handleError: (error, context, _options) => {
                    const { attemptNum: attemptNumber, attemptsRemaining } = context;
                    logger_1.logger.warn({ kind, attemptNumber, attemptsRemaining, errorMessage: error.message, stack: error.stack }, 'Error during eth_call approval validation. Retrying.');
                },
            });
        }
        catch (error) {
            job.status = types_2.RfqmJobStatus.FailedEthCallFailed;
            await this._dbUtils.updateRfqmJobAsync(job);
            logger_1.logger.error({ kind, identifier, errorMessage: error.message, stack: error.stack }, 'eth_call approval validation failed');
            throw new Error('Eth call approval validation failed');
        }
        return calldata;
    }
    /**
     * Prepares an RfqmV2 Job for trade submission by validatidating the job, obtaining the
     * market maker signature, and constructing the calldata.
     *
     * Note that `job.status` would be modified to corresponding status. For example, if maker signature
     * is not valid, `job.status` would be set to `FailedSignFailed`.
     *
     * `shouldCheckLastLook` determines if the preliminary job check and getting market maker sigature
     * would be performed and is default to `true`.
     *
     * Handles retries of retryable errors. Throws for unretriable errors, and logs
     * ONLY IF the log needs more information than the orderHash and workerAddress,
     * which are logged by the `processJobAsync` routine.
     * Updates job in database.
     *
     * @returns The generated calldata for trade submission type.
     * @throws If the trade cannot be submitted (e.g. it is expired).
     */
    async preparerfqmV2TradeAsync(job, workerAddress, 
    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
    // eslint-disable-next-line @typescript-eslint/no-inferrable-types
    shouldCheckLastLook = true, now = new Date()) {
        /**
         * Ask: This is the probably the only change I made to the old trade only workflow. To change from making a copy of parameter
         * and then returning the copied value to change parameter value directly. The rationale behind is to make the style consistent
         * with the new generalized `submitToChainAsync` (it has to use changing parameter value paradigm in order to work). Let me know
         * if you don't like this change.
         */
        const { makerUri, order, orderHash } = job;
        const otcOrder = (0, rfqm_db_utils_1.storedOtcOrderToOtcOrder)(order);
        // Check to see if we have already submitted a transaction for this job.
        // If we have, the job is already prepared and we can skip ahead.
        const transactionSubmissions = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(job.orderHash);
        if (transactionSubmissions.length) {
            if (!job.makerSignature) {
                // This shouldn't happen
                throw new Error('Encountered a job with submissions but no maker signature');
            }
            if (!job.takerSignature) {
                // This shouldn't happen
                throw new Error('Encountered a job with submissions but no taker signature');
            }
            const existingSubmissionCalldata = this._blockchainUtils.generateTakerSignedOtcOrderCallData(otcOrder, job.makerSignature, job.takerSignature, job.isUnwrap, job.affiliateAddress);
            return existingSubmissionCalldata;
        }
        if (shouldCheckLastLook) {
            // Perform the preliminary job check and getting market maker sigature
            await this.checkJobPreprocessingAsync(job, now);
            await this.checkLastLookAsync(job, workerAddress, true);
        }
        // Maker signature must already be defined here -- refine the type
        if (!job.makerSignature) {
            throw new Error('Maker signature does not exist');
        }
        // Taker signature must already be defined here -- refine the type
        if (!job.takerSignature) {
            throw new Error('Taker signature does not exist');
        }
        // Verify the signer was the maker
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const signerAddress = (0, signature_utils_1.getSignerFromHash)(orderHash, job.makerSignature).toLowerCase();
        const makerAddress = order.order.maker.toLowerCase();
        if (signerAddress !== makerAddress) {
            logger_1.logger.info({ signerAddress, makerAddress, orderHash, makerUri }, 'Possible use of smart contract wallet');
            const isValidSigner = await this._blockchainUtils.isValidOrderSignerAsync(makerAddress, signerAddress);
            if (!isValidSigner) {
                job.status = types_2.RfqmJobStatus.FailedSignFailed;
                await this._dbUtils.updateRfqmJobAsync(job);
                throw new Error('Invalid order signer address');
            }
        }
        // Generate the calldata
        const calldata = this._blockchainUtils.generateTakerSignedOtcOrderCallData(otcOrder, job.makerSignature, job.takerSignature, job.isUnwrap, job.affiliateAddress);
        // With the Market Maker signature, execute a full eth_call to validate the
        // transaction via `estimateGasForFillTakerSignedOtcOrderAsync`
        try {
            await (0, attempt_1.retry)(async () => {
                // Maker signature must already be defined here -- refine the type
                if (!job.makerSignature) {
                    throw new Error('Maker signature does not exist');
                }
                // Taker signature must already be defined here -- refine the type
                if (!job.takerSignature) {
                    throw new Error('Taker signature does not exist');
                }
                return this._blockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(otcOrder, job.makerSignature, job.takerSignature, workerAddress, job.isUnwrap);
            }, {
                delay: constants_1.ONE_SECOND_MS,
                factor: 1,
                maxAttempts: 3,
                handleError: (error, context, _options) => {
                    const { attemptNum: attemptNumber, attemptsRemaining } = context;
                    logger_1.logger.warn({ orderHash, makerUri, attemptNumber, attemptsRemaining, error: error.message }, 'Error during eth_call validation when preparing otc order trade. Retrying');
                },
            });
        }
        catch (error) {
            job.status = types_2.RfqmJobStatus.FailedEthCallFailed;
            await this._dbUtils.updateRfqmJobAsync(job);
            logger_1.logger.error({ orderHash, error: error.message }, 'eth_call validation failed when preparing otc order trade');
            // Attempt to gather extra context upon eth_call failure
            try {
                const [makerBalance] = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(this._chainId, { owner: otcOrder.maker, token: otcOrder.makerToken });
                const [takerBalance] = await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync({
                    owner: otcOrder.taker,
                    token: otcOrder.takerToken,
                });
                const blockNumber = await this._blockchainUtils.getCurrentBlockAsync();
                logger_1.logger.info({
                    makerBalance,
                    takerBalance,
                    calldata,
                    blockNumber,
                    orderHash,
                    order: otcOrder,
                    bucket: otcOrder.nonceBucket,
                    nonce: otcOrder.nonce,
                }, 'Extra context after eth_call validation failed when preparing otc order trade');
            }
            catch (error) {
                logger_1.logger.warn({ orderHash }, 'Failed to get extra context after eth_call validation failed when preparing otc order trade');
            }
            throw new Error('Eth call validation failed when preparing otc order trade');
        }
        return calldata;
    }
    /**
     * Prepares a meta-transaction job for trade submission by validatidating the job and constructing the calldata.
     *
     * Note that `job.status` would be modified to corresponding status. For example, if the meta-transaction expires,
     * `job.status` would be set to `FailedFailedExpired`.
     *
     * Handles retries of retryable errors. Throws for unretriable errors, and logs
     * ONLY IF the log needs more information than the orderHash and workerAddress,
     * which are logged by the `processJobAsync` routine.
     * Updates job in database.
     *
     * @returns The generated calldata for trade submission type.
     * @throws If the trade cannot be submitted (e.g. it is expired).
     */
    async prepareMetaTransactionTradeAsync(job, workerAddress, 
    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
    // eslint-disable-next-line @typescript-eslint/no-inferrable-types
    shouldValidateJob = true, now = new Date()) {
        // ASK: What's the difference bewtween `metaTransaction.signer` vs `metaTransaction.sender`?
        //      Which one is the taker address?
        const { affiliateAddress, id: jobId, inputToken, metaTransaction, takerAddress, takerSignature } = job;
        // Check to see if we have already submitted a transaction for this job.
        // If we have, the job is already prepared and we can skip ahead.
        const transactionSubmissions = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId);
        if (transactionSubmissions.length) {
            if (!takerSignature) {
                // This shouldn't happen
                throw new Error('Encountered a job with submissions but no taker signature');
            }
            const existingSubmissionCalldata = this._blockchainUtils.generateMetaTransactionCallData(metaTransaction, takerSignature, affiliateAddress);
            return existingSubmissionCalldata;
        }
        if (shouldValidateJob) {
            // Perform the preliminary job check
            await this.checkJobPreprocessingAsync(job, now);
        }
        // Taker signature must already be defined here -- refine the type
        if (!takerSignature) {
            throw new Error('Taker signature does not exist');
        }
        // Generate the calldata
        const calldata = this._blockchainUtils.generateMetaTransactionCallData(metaTransaction, takerSignature, affiliateAddress);
        // execute a full eth_call to validate the
        // transaction via `estimateGasForAsync`
        try {
            await (0, attempt_1.retry)(async () => {
                // The following gas fee operations are added because `executeMetaTransaction` in 0x Exchange Proxy
                // would check whether the gas price of the transaction is within a window. If left empty, it will
                // fail the simulation. The gas fee estimation below is the same as the first gas fee estimation
                // used in `submitToChain`.
                const gasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();
                const initialMaxPriorityFeePerGas = new utils_1.BigNumber(this._initialMaxPriorityFeePerGasGwei).times(Math.pow(10, constants_1.GWEI_DECIMALS));
                const gasFees = {
                    maxFeePerGas: utils_1.BigNumber.min(gasPriceEstimate.multipliedBy(2).plus(initialMaxPriorityFeePerGas), 
                    // If the max fee is less than the base fee, simulations will fail (unlike submissions, which may sit in the mempool).
                    // An extra multiplier mitigates, but does not solve, the issue.
                    this._maxFeePerGasCapWei.multipliedBy(SIMULATION_MAX_GAS_MULTIPLIER)),
                    maxPriorityFeePerGas: initialMaxPriorityFeePerGas,
                };
                return this._blockchainUtils.estimateGasForAsync({
                    from: workerAddress,
                    to: this._blockchainUtils.getExchangeProxyAddress(),
                    data: calldata,
                    maxFeePerGas: gasFees.maxFeePerGas.toString(),
                    maxPriorityFeePerGas: gasFees.maxPriorityFeePerGas.toString(),
                });
            }, {
                delay: constants_1.ONE_SECOND_MS,
                factor: 1,
                maxAttempts: 3,
                handleError: (error, context, _options) => {
                    const { attemptNum: attemptNumber, attemptsRemaining } = context;
                    logger_1.logger.warn({ jobId, attemptNumber, attemptsRemaining, error: error.message }, 'Error during eth_call validation when preparing meta-transaction trade. Retrying');
                },
            });
        }
        catch (error) {
            job.status = types_2.RfqmJobStatus.FailedEthCallFailed;
            await this._dbUtils.updateRfqmJobAsync(job);
            logger_1.logger.error({ jobId, error: error.message }, 'eth_call validation failed when preparing meta-transaction trade');
            // Attempt to gather extra context upon eth_call failure
            try {
                const [takerBalance] = await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync([
                    { owner: takerAddress, token: inputToken },
                ]);
                const blockNumber = await this._blockchainUtils.getCurrentBlockAsync();
                logger_1.logger.info({
                    calldata,
                    blockNumber,
                    jobId,
                    metaTransaction,
                    takerBalance,
                }, 'Extra context after eth_call validation failed when preparing meta-transaction trade');
            }
            catch (error) {
                logger_1.logger.warn({ jobId }, 'Failed to get extra context after eth_call validation failed when preparing meta-transaction trade ');
            }
            throw new Error('Eth call validation failed when preparing meta-transaction trade');
        }
        return calldata;
    }
    /**
     * Check last look by getting market maker signature. Handles retries when making request to market maker servers.
     *
     * When verifying the order is fillable by both the maker and the taker:
     * - If `shouldCheckAllowance` is false, the method would only check balances but not the allowances the maker and
     *   the taker set for 0x exchange proxy because the taker allowance will not be set when `checkLastLookAsync` is called as we
     *   want to call this method as soon as possible to mitigate the latency brought by sequential submissions
     *   (which would lead to higher decline to sign rate).
     * - Otherwise, both balances and allowances would be checked.
     */
    async checkLastLookAsync(job, workerAddress, shouldCheckAllowance) {
        const { makerUri, order, orderHash, takerSignature } = job;
        const otcOrder = (0, rfqm_db_utils_1.storedOtcOrderToOtcOrder)(order);
        let { makerSignature } = job;
        if (makerSignature) {
            // Market Maker had already signed order
            logger_1.logger.info({ workerAddress, orderHash }, 'Order already signed');
        }
        else {
            // validate that order is fillable by both the maker and the taker according to balances (and allowances
            // when `shouldCheckAllowance` is true)
            const [makerBalance] = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(this._chainId, {
                owner: otcOrder.maker,
                token: otcOrder.makerToken,
            });
            const [takerBalance] = shouldCheckAllowance
                ? await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync({
                    owner: otcOrder.taker,
                    token: otcOrder.takerToken,
                })
                : await this._blockchainUtils.getTokenBalancesAsync({
                    owner: otcOrder.taker,
                    token: otcOrder.takerToken,
                });
            if (makerBalance.lt(otcOrder.makerAmount) || takerBalance.lt(otcOrder.takerAmount)) {
                logger_1.logger.error({
                    orderHash,
                    makerBalance,
                    takerBalance,
                    makerAmount: otcOrder.makerAmount,
                    takerAmount: otcOrder.takerAmount,
                }, 'Order failed pre-sign validation');
                job.status = types_2.RfqmJobStatus.FailedPresignValidationFailed;
                await this._dbUtils.updateRfqmJobAsync(job);
                throw new Error('Order failed pre-sign validation');
            }
            if (!takerSignature) {
                logger_1.logger.error('Order failed pre-sign validation due to empty takerSignature');
                job.status = types_2.RfqmJobStatus.FailedPresignValidationFailed;
                await this._dbUtils.updateRfqmJobAsync(job);
                throw new Error('Order failed pre-sign validation due to empty takerSignature');
            }
            const trader = (0, signature_utils_1.getSignerFromHash)(orderHash, takerSignature);
            const signRequest = {
                expiry: job.expiry,
                fee: (0, fee_utils_1.storedFeeToFee)(job.fee),
                order: otcOrder,
                orderHash,
                takerSignature,
                workflow: 'rfqm',
                trader: trader,
                ...(job.takerSpecifiedSide &&
                    config_1.TAKER_SPECIFIED_SIDE_ENABLED && { takerSpecifiedSide: job.takerSpecifiedSide }),
            };
            // "Last Look" in v1 is replaced by market maker order signing in v2.
            const signAttemptTimeMs = Date.now();
            try {
                makerSignature = await (0, attempt_1.retry)(async () => {
                    var _a;
                    return this._quoteServerClient
                        .signV2Async(makerUri, (_a = job.integratorId) !== null && _a !== void 0 ? _a : '', signRequest)
                        .then((s) => s !== null && s !== void 0 ? s : null);
                }, {
                    delay: constants_1.ONE_SECOND_MS,
                    factor: 2,
                    maxAttempts: 3,
                    handleError: (error, context, _options) => {
                        const { attemptNum: attemptNumber, attemptsRemaining } = context;
                        logger_1.logger.warn({ orderHash, makerUri, attemptNumber, attemptsRemaining, error: error.message }, 'Error encountered while attempting to get market maker signature');
                    },
                });
            }
            catch (error) {
                // The sign process has failed after retries
                RFQM_JOB_FAILED_MM_SIGNATURE_FAILED.labels(makerUri, this._chainId.toString()).inc();
                logger_1.logger.error({ orderHash, makerUri, error: error.message }, 'RFQM v2 job failed due to market maker sign failure');
                job.status = types_2.RfqmJobStatus.FailedSignFailed;
                await this._dbUtils.updateRfqmJobAsync(job);
                throw new Error('Job failed during market maker sign attempt');
            }
            logger_1.logger.info({ makerUri, signed: !!makerSignature, orderHash }, 'Got signature response from market maker');
            if (!makerSignature) {
                // Market Maker has declined to sign the transaction
                RFQM_JOB_MM_REJECTED_LAST_LOOK.labels(makerUri, this._chainId.toString()).inc();
                job.lastLookResult = false;
                job.status = types_2.RfqmJobStatus.FailedLastLookDeclined;
                await this._dbUtils.updateRfqmJobAsync(job);
                if (config_1.ENABLE_LLR_COOLDOWN) {
                    try {
                        const quote = await this._dbUtils.findV2QuoteByOrderHashAsync(orderHash);
                        if (quote === null) {
                            throw new Error(`Failed to find quote with order hash ${orderHash}`);
                        }
                        // `bad` last look rejection, rejected within the cooldown window
                        if (signAttemptTimeMs - quote.createdAt.valueOf() <
                            constants_1.LLR_COOLDOWN_WINDOW_SECONDS * constants_1.ONE_SECOND_MS) {
                            const makerId = this._rfqMakerManager.findMakerIdWithRfqmUri(makerUri);
                            if (makerId === null) {
                                throw new Error(`Failed to find maker ID with RFQm URI ${makerUri}`);
                            }
                            const cooldownEndTimeMs = signAttemptTimeMs + config_1.LLR_COOLDOWN_DURATION_SECONDS * constants_1.ONE_SECOND_MS;
                            // schedule cooldown
                            const isScheduleUpdated = await this._cacheClient.addMakerToCooldownAsync(makerId, cooldownEndTimeMs, this._chainId, otcOrder.makerToken, otcOrder.takerToken);
                            logger_1.logger.info({
                                makerId,
                                chainId: this._chainId,
                                makerToken: otcOrder.makerToken,
                                takerToken: otcOrder.takerToken,
                                startTime: signAttemptTimeMs,
                                endTime: cooldownEndTimeMs,
                                orderHash,
                                isScheduleUpdated,
                            }, 'LLR cooldown scheduled');
                            try {
                                // insert cooldown entry to db for record keeping
                                await this._dbUtils.writeV2LastLookRejectionCooldownAsync(makerId, this._chainId, otcOrder.makerToken, otcOrder.takerToken, new Date(signAttemptTimeMs), // startTime
                                new Date(cooldownEndTimeMs), // endTime
                                orderHash);
                            }
                            catch (e) {
                                logger_1.logger.warn({ orderHash, errorMessage: e.message }, 'Saving LLR cooldown failed');
                            }
                        }
                    }
                    catch (error) {
                        logger_1.logger.warn({ errorMessage: error.message }, 'Encountered error when detecting bad LLR and scheduling cooldown');
                    }
                }
                // We'd like some data on how much the price the market maker is offering
                // has changed. We query the market maker's price endpoint with the same
                // trade they've just declined to sign and log the result.
                try {
                    const declineToSignPriceCheckTimeMs = Date.now();
                    const otcOrderParams = quote_server_client_1.QuoteServerClient.makeQueryParameters({
                        chainId: this._chainId,
                        txOrigin: this._registryAddress,
                        takerAddress: otcOrder.taker,
                        marketOperation: types_1.MarketOperation.Sell,
                        buyTokenAddress: otcOrder.makerToken,
                        sellTokenAddress: otcOrder.takerToken,
                        assetFillAmount: otcOrder.takerAmount,
                        isLastLook: true,
                        fee: (0, fee_utils_1.storedFeeToFee)(job.fee),
                    });
                    // Instead of adding a dependency to `ConfigManager` to get the actual integrator
                    // (we only have the ID at this point), just create a stand-in.
                    // This will send the same integrator ID to the market maker; they will not be
                    // able to tell the difference.
                    // `logRfqMakerNetworkInteraction` does use the `label`, however, but I think the
                    // tradeoff is reasonable.
                    const integrator = {
                        apiKeys: [],
                        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        integratorId: job.integratorId,
                        allowedChainIds: [this._chainId],
                        label: 'decline-to-sign-price-check',
                        plp: true,
                        rfqm: true,
                        rfqt: true,
                    };
                    const priceResponse = await this._quoteServerClient.getPriceV2Async(job.makerUri, integrator, otcOrderParams, (u) => `${u}/rfqm/v2/price`);
                    if (!priceResponse) {
                        throw new Error('Failed to get a price response');
                    }
                    const { makerAmount: priceCheckMakerAmount, takerAmount: priceCheckTakerAmount } = priceResponse;
                    const originalPrice = otcOrder.makerAmount.dividedBy(priceCheckTakerAmount);
                    const priceAfterReject = priceCheckMakerAmount.dividedBy(priceCheckTakerAmount);
                    const bipsFactor = 10000;
                    const priceDifferenceBips = originalPrice
                        .minus(priceAfterReject)
                        .dividedBy(originalPrice)
                        .absoluteValue()
                        .times(bipsFactor)
                        .toPrecision(1);
                    // The time, in seconds, between when we initiated the sign attempt and when we
                    // initiated the price check after the maker declined to sign.
                    const priceCheckDelayS = (declineToSignPriceCheckTimeMs - signAttemptTimeMs) / constants_1.ONE_SECOND_MS;
                    logger_1.logger.info({
                        orderHash,
                        originalPrice: originalPrice.toNumber(),
                        priceAfterReject: priceAfterReject.toNumber(),
                        priceCheckDelayS,
                        priceDifferenceBips,
                    }, 'Decline to sign price check');
                    try {
                        job.llRejectPriceDifferenceBps = parseInt(priceDifferenceBips, 10);
                        await this._dbUtils.updateRfqmJobAsync(job);
                    }
                    catch (e) {
                        logger_1.logger.warn({ orderHash, errorMessage: e.message }, 'Saving LL reject price difference failed');
                    }
                }
                catch (error) {
                    logger_1.logger.warn({ errorMessage: error.message }, 'Encountered error during decline to sign price check');
                }
                throw new Error('Market Maker declined to sign');
            }
            // Certain market makers are returning signature components which are missing
            // leading bytes. Add them if they don't exist.
            const paddedSignature = (0, signature_utils_1.padSignature)(makerSignature);
            if (paddedSignature.r !== makerSignature.r || paddedSignature.s !== makerSignature.s) {
                logger_1.logger.warn({ orderHash, r: paddedSignature.r, s: paddedSignature.s }, 'Got market maker signature with missing bytes');
                makerSignature = paddedSignature;
            }
            job.makerSignature = paddedSignature;
            job.lastLookResult = true;
            job.status = types_2.RfqmJobStatus.PendingLastLookAccepted;
            await this._dbUtils.updateRfqmJobAsync(job);
        }
        // Maker signature must already be defined here -- refine the type
        if (!makerSignature) {
            throw new Error('Maker signature does not exist');
        }
        // Verify the signer was the maker
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const signerAddress = (0, signature_utils_1.getSignerFromHash)(orderHash, makerSignature).toLowerCase();
        const makerAddress = order.order.maker.toLowerCase();
        if (signerAddress !== makerAddress) {
            logger_1.logger.info({ signerAddress, makerAddress, orderHash, makerUri }, 'Possible use of smart contract wallet');
            const isValidSigner = await this._blockchainUtils.isValidOrderSignerAsync(makerAddress, signerAddress);
            if (!isValidSigner) {
                job.status = types_2.RfqmJobStatus.FailedSignFailed;
                await this._dbUtils.updateRfqmJobAsync(job);
                throw new Error('Invalid order signer address');
            }
        }
    }
    /**
     * Submits a specific type of submission to the blockchain.
     *
     * First checks to see if there are previous transactions with the submission type and enters the
     * watch loop; if not, submits an initial transaction and enters the watch loop.
     *
     * During the watch loop, waits for a transaction to be mined and confirmed;
     * replaces the transaction if gas prices rise while a transactions are in the mempool.
     *
     * @param opts Options object that contains:
     *        - `to`: The address to send to.
     *        - `from`: The address submitting the transaction (usually the worker address).
     *        - `calldata`: Calldata to submit.
     *        - `expiry`: Exiry before the submission is considered invalid.
     *        - `identifier`: The job identifier. For rfqm_v2_job, it should be order hash; for meta-transaction, it should be job id.
     *        - `submissionType`: The type of submission.
     *        - `onSubmissionContextStatusUpdate`: Callback to perform appropriate actions when the submission context statuses change.
     *        - `now`: The current time.
     * @returns FailedRevertedConfirmed or SucceededConfirmed.
     * @throws Submission context status is FailedExpired or unhandled exceptions.
     */
    async submitToChainAsync(opts) {
        const { kind, to, from, calldata, expiry, identifier, submissionType, onSubmissionContextStatusUpdate } = opts;
        let previousSubmissionsWithPresubmits;
        switch (kind) {
            case 'rfqm_v2_job':
                previousSubmissionsWithPresubmits = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(identifier, submissionType);
                break;
            case 'meta_transaction_job':
                previousSubmissionsWithPresubmits = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(identifier, submissionType);
                break;
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(kind);
        }
        const previousSubmissions = await this._recoverPresubmitTransactionsAsync(previousSubmissionsWithPresubmits);
        const gasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();
        // For the first submission, we use the "fast" gas estimate to approximate the base fee.
        // We use the strategy outlined in https://www.blocknative.com/blog/eip-1559-fees --
        // The `maxFeePerGas` is 2x the base fee (plus priority tip). Since we don't have a
        // handy oracle for the en vogue priorty fee we start with 2 gwei and work up from there.
        const initialMaxPriorityFeePerGas = new utils_1.BigNumber(this._initialMaxPriorityFeePerGasGwei).times(Math.pow(10, constants_1.GWEI_DECIMALS));
        let gasFees = {
            maxFeePerGas: utils_1.BigNumber.min(gasPriceEstimate.multipliedBy(2).plus(initialMaxPriorityFeePerGas), this._maxFeePerGasCapWei),
            maxPriorityFeePerGas: initialMaxPriorityFeePerGas,
        };
        let submissionContext;
        let nonce;
        let gasEstimate;
        if (!previousSubmissions.length) {
            // There's an edge case here where there are previous submissions but they're all in `PRESUBMIT`.
            // Those are filtered out if they can't be found on the blockchain so we end up here.
            // If this occurs we need to check if the transaction is expired.
            const nowSeconds = new utils_1.BigNumber(new Date().getTime() / constants_1.ONE_SECOND_MS);
            if (expiry.isLessThan(nowSeconds)) {
                await onSubmissionContextStatusUpdate(types_2.SubmissionContextStatus.FailedExpired);
                throw new Error(`Exceed expiry ${expiry} for kind ${kind} and submission type ${submissionType}`);
            }
            logger_1.logger.info({ kind, identifier, from }, 'Attempting to submit first transaction');
            await onSubmissionContextStatusUpdate(types_2.SubmissionContextStatus.PendingSubmitted);
            logger_1.logger.info({
                kind,
                gasFees,
                gasPriceEstimate,
                identifier,
                submissionCount: 1,
                from,
                submissionType,
            }, 'Submitting transaction');
            nonce = await this._blockchainUtils.getNonceAsync(from);
            const gasEstimateWithoutBuffer = await this._blockchainUtils.estimateGasForAsync({
                to,
                from,
                data: calldata,
                // The following gas fee properties are added because `executeMetaTransaction` in 0x Exchange Proxy
                // would check whether the gas price of the transaction is within a window. If left empty, it will
                // fail the simulation.
                maxFeePerGas: gasFees.maxFeePerGas.toString(),
                maxPriorityFeePerGas: gasFees.maxPriorityFeePerGas.toString(),
            });
            // Add buffer to gas estimate returned by `eth_estimateGas` as the RPC method
            // tends to under estimate gas usage
            gasEstimate = Math.ceil((constants_1.GAS_ESTIMATE_BUFFER + 1) * gasEstimateWithoutBuffer);
            let accessListWithGas;
            if (this._enableAccessList) {
                try {
                    accessListWithGas = await this._blockchainUtils.createAccessListForAsync({
                        to,
                        from,
                        data: calldata,
                    });
                    RFQM_CREATE_ACCESS_LIST_REQUEST.labels(this._chainId.toString(), 'success').inc();
                }
                catch (error) {
                    RFQM_CREATE_ACCESS_LIST_REQUEST.labels(this._chainId.toString(), 'failure').inc();
                    logger_1.logger.warn({ kind, calldata, from }, 'Failed to create access list');
                }
                if (accessListWithGas !== undefined && accessListWithGas.gasEstimate) {
                    // Add buffer to gas estimate returned by `eth_estimateGas` as the RPC method
                    // tends to under estimate gas usage
                    accessListWithGas.gasEstimate = Math.ceil((constants_1.GAS_ESTIMATE_BUFFER + 1) * accessListWithGas.gasEstimate);
                    logger_1.logger.info({ gasEstimate, accessListGasEstimate: accessListWithGas.gasEstimate }, 'Regular gas estimate vs access list gas estimate');
                    RFQM_GAS_ESTIMATE_NO_ACCESS_LIST.labels(this._chainId.toString()).set(gasEstimate);
                    RFQM_GAS_ESTIMATE_ACCESS_LIST.labels(this._chainId.toString()).set(accessListWithGas.gasEstimate);
                }
            }
            const firstSubmission = await this._submitTransactionAsync(kind, identifier, from, calldata, gasFees, nonce, gasEstimate, submissionType, to);
            logger_1.logger.info({ kind, from, identifier, submissionType, transactionHash: firstSubmission.transactionHash }, 'Successfully submitted transaction');
            submissionContext = new SubmissionContext_1.SubmissionContext(this._blockchainUtils, [firstSubmission]);
        }
        else {
            logger_1.logger.info({ kind, from, identifier, submissionType }, `Previous submissions found, recovering context`);
            submissionContext = new SubmissionContext_1.SubmissionContext(this._blockchainUtils, previousSubmissions);
            nonce = submissionContext.nonce;
            // If we've already submitted a transaction and it has been mined,
            // using `_blockchainUtils.estimateGasForAsync` will throw
            // given the same calldata. In the edge case where a transaction has been sent
            // but not mined, we would ideally pull the gas estimate from the previous
            // transaction. Unfortunately, we currently do not store it on the
            // `RfqmV2TransactionSubmissionEntity`. As a workaround, we'll just use an
            // overestimate..
            gasEstimate = MAX_GAS_ESTIMATE;
        }
        // The "Watch Loop"
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line no-constant-condition
        while (true) {
            // We've already submitted the transaction once at this point, so we first need to wait before checking the status.
            await (0, delay_1.default)(this._transactionWatcherSleepTimeMs);
            const oldSubmissionContextStatus = submissionContext.submissionContextStatus;
            const newSubmissionContextStatus = await this._checkSubmissionReceiptsAndUpdateDbAsync(identifier, submissionContext);
            logger_1.logger.info({ kind, submissionType, oldSubmissionContextStatus, newSubmissionContextStatus }, 'Old and new submission context statuses');
            await onSubmissionContextStatusUpdate(newSubmissionContextStatus, oldSubmissionContextStatus);
            switch (newSubmissionContextStatus) {
                case types_2.SubmissionContextStatus.PendingSubmitted:
                    // We've put in at least one transaction but none have been mined yet.
                    // Check to make sure we haven't passed the expiry window.
                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                    // eslint-disable-next-line no-case-declarations
                    const nowSeconds = new utils_1.BigNumber(new Date().getTime() / constants_1.ONE_SECOND_MS);
                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                    // eslint-disable-next-line no-case-declarations
                    const secondsPastExpiration = nowSeconds.minus(expiry);
                    // If we're more than 120 seconds past expiration, give up.
                    // See https://github.com/rolandkofler/blocktime for some
                    // analysis of expected block times. Two minutes was selected
                    // to cover most cases without locking up the worker for too long.
                    if (secondsPastExpiration.isGreaterThan(constants_1.ONE_MINUTE_S * 2)) {
                        await onSubmissionContextStatusUpdate(types_2.SubmissionContextStatus.FailedExpired, oldSubmissionContextStatus);
                        throw new Error(`Exceed expiry ${expiry} for kind ${kind} and submission type ${submissionType}`);
                    }
                    // If we're past expiration by less than a minute, don't put in any new transactions
                    // but keep watching in case a receipt shows up
                    if (secondsPastExpiration.isGreaterThan(0)) {
                        continue;
                    }
                    // "Fast" gas price estimation; used to approximate the base fee
                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                    // eslint-disable-next-line no-case-declarations
                    const newGasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();
                    if (submissionContext.transactionType === 0) {
                        throw new Error('Non-EIP-1559 transactions are not implemented');
                    }
                    // We don't wait for gas conditions to change. Rather, we increase the gas
                    // based bid based onthe knowledge that time (and therefore blocks, theoretically)
                    // has passed without a transaction being mined.
                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                    // eslint-disable-next-line no-case-declarations
                    const { maxFeePerGas: oldMaxFeePerGas, maxPriorityFeePerGas: oldMaxPriorityFeePerGas } = submissionContext.maxGasFees;
                    if (oldMaxFeePerGas.isGreaterThanOrEqualTo(this._maxFeePerGasCapWei)) {
                        // If we've reached the max fee per gas we'd like to pay, just
                        // continue watching the transactions to see if one gets mined.
                        logger_1.logger.info({ kind, submissionType, oldMaxFeePerGas, maxFeePerGasCap: this._maxFeePerGasCapWei }, 'Exceeds max fee per gas');
                        continue;
                    }
                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                    // eslint-disable-next-line no-case-declarations
                    const newMaxPriorityFeePerGas = oldMaxPriorityFeePerGas
                        .multipliedBy(MAX_PRIORITY_FEE_PER_GAS_MULTIPLIER)
                        .integerValue(utils_1.BigNumber.ROUND_CEIL);
                    // The RPC nodes still need at least a 0.1 increase in both values to accept the new transaction.
                    // For the new max fee per gas, we'll take the maximum of a 0.1 increase from the last value
                    // or the value from an increase in the base fee.
                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                    // eslint-disable-next-line no-case-declarations
                    const newMaxFeePerGas = utils_1.BigNumber.max(oldMaxFeePerGas.multipliedBy(MAX_FEE_PER_GAS_MULTIPLIER).integerValue(utils_1.BigNumber.ROUND_CEIL), newGasPriceEstimate.multipliedBy(2).plus(newMaxPriorityFeePerGas));
                    gasFees = {
                        maxFeePerGas: newMaxFeePerGas,
                        maxPriorityFeePerGas: newMaxPriorityFeePerGas,
                    };
                    logger_1.logger.info({
                        kind,
                        gasFees,
                        gasPriceEstimate,
                        identifier,
                        submissionCount: submissionContext.transactions.length + 1,
                        from,
                        submissionType,
                    }, 'Submitting transaction');
                    try {
                        const newTransaction = await this._submitTransactionAsync(kind, identifier, from, calldata, gasFees, nonce, gasEstimate, submissionType, to);
                        logger_1.logger.info({
                            kind,
                            from,
                            identifier,
                            transactionHash: newTransaction.transactionHash,
                            submissionType,
                        }, 'Successfully resubmited tx with higher gas price');
                        submissionContext.addTransaction(newTransaction);
                    }
                    catch (err) {
                        const errorMessage = err.message;
                        const isNonceTooLow = /nonce too low/.test(errorMessage);
                        logger_1.logger.warn({ from, kind, identifier, submissionType, errorMessage: err.message, isNonceTooLow }, 'Encountered an error re-submitting a tx');
                        if (isNonceTooLow) {
                            logger_1.logger.info({ from, kind, identifier, submissionType }, 'Ignore nonce too low error on re-submission. A previous submission was successful');
                            break;
                        }
                        // Rethrow on all other types of errors
                        throw err;
                    }
                    break;
                case types_2.SubmissionContextStatus.FailedRevertedUnconfirmed:
                case types_2.SubmissionContextStatus.SucceededUnconfirmed:
                    break;
                case types_2.SubmissionContextStatus.FailedRevertedConfirmed:
                case types_2.SubmissionContextStatus.SucceededConfirmed:
                    return newSubmissionContextStatus;
                default:
                    ((_x) => {
                        throw new Error('unreachable');
                    })(newSubmissionContextStatus);
            }
        }
    }
    /**
     * Get the callback function to supply to `submitToChainAsync`.
     *
     * Note that `job.status` would be updated to appropriate state by  the callback function according to old & new
     * submission context status and submission type. There would be job status update ONLY IF the new and old submission
     * context statuses differ.
     *
     * This function also "closes over" `job` so that it's accessible in the callback function. Refer the docstring of
     * `RfqmTransactionSubmissionContextStatus` for more details on submission context.
     *
     * @param job A rfqm v2 job or a meta transactino job object.
     * @param submissionType Type of submission.
     * @returns Function would make appropriate update to job status according to submission context statuses and submission type.
     */
    _getOnSubmissionContextStatusUpdateCallback(job, submissionType) {
        return async (newSubmissionContextStatus, oldSubmissionContextStatus) => {
            if (newSubmissionContextStatus !== oldSubmissionContextStatus) {
                let newJobStatus;
                switch (submissionType) {
                    case types_2.RfqmTransactionSubmissionType.Approval:
                        newJobStatus =
                            SubmissionContext_1.SubmissionContext.approvalSubmissionContextStatusToJobStatus(newSubmissionContextStatus);
                        break;
                    case types_2.RfqmTransactionSubmissionType.Trade:
                        newJobStatus =
                            SubmissionContext_1.SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);
                        break;
                    default:
                        ((_x) => {
                            throw new Error('unreachable');
                        })(submissionType);
                }
                job.status = newJobStatus;
                await this._dbUtils.updateRfqmJobAsync(job);
            }
        };
    }
    /**
     * Takes an array of Transaction Submissions, which may include transactions with the
     * "Presbumit" status, and resolves or removes the "Presubmit" transactions.
     *
     * If there are previous submissions in the "Presubmit" state,
     *
     * For "Presubmit" transactions, we check to see if the transaction was actually sent to
     * the mempool or not, as that is indeterminate. Depending on the result of the check, we
     * update the status to "Submitted" or remove them from the submissions in memory.
     * Note that we leave the transaction record present in the database so that if the worker
     * dies again and the submission actually went through but was not found at the time of
     * this check we can potentially recover it later.
     */
    async _recoverPresubmitTransactionsAsync(transactionSubmissions) {
        // Any is so nasty -- https://dev.to/shadow1349/typescript-tip-of-the-week-generics-170g
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = await Promise.all(transactionSubmissions.map(async (transactionSubmission) => {
            // If the transaction is any status other than "Presubmit" then we'll leave it
            if (transactionSubmission.status !== types_2.RfqmTransactionSubmissionStatus.Presubmit) {
                return transactionSubmission;
            }
            // For transactions in presubmit, check the mempool and chain to see if they exist
            const transactionResponse = await this._blockchainUtils.getTransactionAsync(
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            transactionSubmission.transactionHash);
            if (transactionResponse) {
                // If it does exist, update the status. If not, remove it.
                transactionSubmission.status = types_2.RfqmTransactionSubmissionStatus.Submitted;
                await this._dbUtils.updateRfqmTransactionSubmissionsAsync([transactionSubmission]);
                return transactionSubmission;
            }
            else {
                return null;
            }
        })).then((x) => x.filter(isDefined));
        return result;
    }
    /**
     * Check for receipts from the tx hashes and update databases with status of all tx's.
     */
    async _checkSubmissionReceiptsAndUpdateDbAsync(identifier, submissionContext) {
        // At most one tx can be mined, since they all have the same nonce.
        const minedReceipt = await submissionContext.getReceiptAsync();
        // If the tx hasn't been mined yet, there're no database updates to do.
        if (!minedReceipt) {
            return types_2.SubmissionContextStatus.PendingSubmitted;
        }
        // Attempt to publish the mining latency
        try {
            const { timestamp: minedBlockTimestampS } = await this._blockchainUtils.getBlockAsync(minedReceipt.blockHash);
            const firstSubmissionTimestampS = submissionContext.firstSubmissionTimestampS;
            RFQM_MINING_LATENCY.labels(this._chainId.toString()).observe(minedBlockTimestampS - firstSubmissionTimestampS);
        }
        catch (e) {
            logger_1.logger.warn({ orderHash: identifier, errorMessage: e.message, stack: e.stack }, 'Failed to meter the mining latency');
        }
        await submissionContext.updateForReceiptAsync(minedReceipt);
        await this._dbUtils.updateRfqmTransactionSubmissionsAsync(submissionContext.transactions);
        return submissionContext.submissionContextStatus;
    }
    /**
     * Determine transaction properties and submit a transaction
     */
    async _submitTransactionAsync(kind, identifier, workerAddress, callData, gasFees, nonce, gasEstimate, submissionType = types_2.RfqmTransactionSubmissionType.Trade, to = this._blockchainUtils.getExchangeProxyAddress()) {
        const txOptions = {
            ...gasFees,
            from: workerAddress,
            to,
            gas: gasEstimate,
            nonce,
            value: 0,
        };
        const transactionRequest = this._blockchainUtils.transformTxDataToTransactionRequest(txOptions, this._chainId, callData);
        const { signedTransaction, transactionHash } = await this._blockchainUtils.signTransactionAsync(transactionRequest);
        let partialEntity;
        let transactionSubmissionEntity;
        switch (kind) {
            case 'rfqm_v2_job':
                partialEntity = {
                    ...gasFees,
                    transactionHash,
                    orderHash: identifier,
                    createdAt: new Date(),
                    from: workerAddress,
                    to,
                    nonce,
                    status: types_2.RfqmTransactionSubmissionStatus.Presubmit,
                    type: submissionType,
                };
                transactionSubmissionEntity = await this._dbUtils.writeV2RfqmTransactionSubmissionToDbAsync(partialEntity);
                break;
            case 'meta_transaction_job':
                partialEntity = {
                    ...gasFees,
                    transactionHash,
                    metaTransactionJobId: identifier,
                    createdAt: new Date(),
                    from: workerAddress,
                    to,
                    nonce,
                    status: types_2.RfqmTransactionSubmissionStatus.Presubmit,
                    type: submissionType,
                };
                transactionSubmissionEntity = await this._dbUtils.writeMetaTransactionSubmissionAsync(partialEntity);
                break;
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(kind);
        }
        const transactionHashFromSubmit = await this._blockchainUtils.submitSignedTransactionAsync(signedTransaction);
        if (transactionHash !== transactionHashFromSubmit) {
            // This should never ever happen
            logger_1.logger.error({ kind, submissionType, identifier, transactionHashFromSubmit, transactionHash }, 'Mismatch between transaction hash calculated before submit and after submit');
            throw new Error('Mismatch between transaction hash calculated before submit and after submit');
        }
        logger_1.logger.info({ kind, submissionType, identifier, workerAddress, transactionHash }, 'Transaction calldata submitted to exchange proxy');
        const updatedTransactionSubmission = [
            {
                ...transactionSubmissionEntity,
                status: types_2.RfqmTransactionSubmissionStatus.Submitted,
            },
        ];
        await this._dbUtils.updateRfqmTransactionSubmissionsAsync(updatedTransactionSubmission);
        let updatedEntity;
        switch (kind) {
            case 'rfqm_v2_job':
                updatedEntity = await this._dbUtils.findV2TransactionSubmissionByTransactionHashAsync(transactionHashFromSubmit);
                break;
            case 'meta_transaction_job':
                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                // eslint-disable-next-line no-case-declarations
                const updatedSubmissionEntities = await this._dbUtils.findMetaTransactionSubmissionsByTransactionHashAsync(transactionHashFromSubmit, submissionType);
                if (updatedSubmissionEntities.length !== 1) {
                    // A transaction hash should never be submitted twice in our system. However, RFQ-562 mentioned cases like this could
                    // happen in our system. Add more log and throw the error to surface it.
                    logger_1.logger.error({ kind, submissionType, transactionHash }, 'Transaction hash have been submitted not exactly once');
                    throw new Error('Transaction hash have been submitted not exactly once');
                }
                updatedEntity = updatedSubmissionEntities[0];
                break;
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(kind);
        }
        if (!updatedEntity) {
            // This should never happen -- we just saved it
            throw new Error(`Could not find updated entity with transaction hash ${transactionHashFromSubmit} of kind ${kind} and submission type ${submissionType}`);
        }
        return updatedEntity;
    }
}
exports.WorkerService = WorkerService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9zZXJ2aWNlcy9Xb3JrZXJTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUFxQztBQUNyQyx1REFBeUQ7QUFDekQscUNBQTRDO0FBQzVDLHFDQUFzQztBQUN0QyxtREFBK0M7QUFDL0MsK0NBQTBDO0FBQzFDLGlDQUEwQjtBQUMxQiw2Q0FBc0Q7QUFFdEQsc0NBS21CO0FBQ25CLGlEQU8yQjtBQUMzQixpREFBbUQ7QUFRbkQsNkNBSzJCO0FBQzNCLHNDQUFtQztBQUluQyxzRUFBaUU7QUFDakUsMERBQStFO0FBRy9FLDhEQUEyRTtBQUMzRSxrRUFBK0Q7QUFTL0QsNkVBQTZFO0FBQzdFLFNBQVMsU0FBUyxDQUFJLEtBQVE7SUFDMUIsT0FBTyxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxTQUFTLENBQUM7QUFDakQsQ0FBQztBQUVELE1BQU0sbUJBQW1CLEdBQUcsSUFBSSxtQkFBSyxDQUFDO0lBQ2xDLElBQUksRUFBRSxxQkFBcUI7SUFDM0IsVUFBVSxFQUFFLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQztJQUNuQyxJQUFJLEVBQUUseUJBQXlCO0NBQ2xDLENBQUMsQ0FBQztBQUVILE1BQU0saUJBQWlCLEdBQUcsSUFBSSxxQkFBTyxDQUFDO0lBQ2xDLElBQUksRUFBRSxtQkFBbUI7SUFDekIsVUFBVSxFQUFFLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQztJQUNuQyxJQUFJLEVBQUUsbUVBQW1FO0NBQzVFLENBQUMsQ0FBQztBQUVILE1BQU0scUJBQXFCLEdBQUcsSUFBSSxxQkFBTyxDQUFDO0lBQ3RDLElBQUksRUFBRSx1QkFBdUI7SUFDN0IsVUFBVSxFQUFFLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQztJQUNuQyxJQUFJLEVBQUUsNkVBQTZFO0NBQ3RGLENBQUMsQ0FBQztBQUVILE1BQU0sZUFBZSxHQUFHLElBQUksbUJBQUssQ0FBQztJQUM5QixJQUFJLEVBQUUsb0JBQW9CO0lB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Y0FBYyxDQUNqQixDQUFDO2dCQUNOLElBQUkseUJBQXlCLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtvQkFDeEMscUhBQXFIO29CQUNySCx3RUFBd0U7b0JBQ3hFLGVBQU0sQ0FBQyxLQUFLLENBQ1IsRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxFQUN6Qyx1REFBdUQsQ0FDMUQsQ0FBQztvQkFDRixNQUFNLElBQUksS0FBSyxDQUFDLHVEQUF1RCxDQUFDLENBQUM7aUJBQzVFO2dCQUVELGFBQWEsR0FBRyx5QkFBeUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDN0MsTUFBTTtZQUNWO2dCQUNJLENBQUMsQ0FBQyxFQUFTLEVBQUUsRUFBRTtvQkFDWCxNQUFNLElBQUksS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO2dCQUNuQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNoQjtRQUVELElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDaEIsK0NBQStDO1lBQy9DLE1BQU0sSUFBSSxLQUFLLENBQ1gsdURBQXVELHlCQUF5QixZQUFZLElBQUksd0JBQXdCLGNBQWMsRUFBRSxDQUMzSSxDQUFDO1NBQ0w7UUFFRCxPQUFPLGFBQWEsQ0FBQztJQUN6QixDQUFDO0NBQ0o7QUE3dURELHNDQTZ1REMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9zZXJ2aWNlcy9Xb3JrZXJTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRzbGludDpkaXNhYmxlOm1heC1maWxlLWxpbmUtY291bnRcbmltcG9ydCB7IE90Y09yZGVyLCBTaWduYXR1cmUgfSBmcm9tICdAMHgvcHJvdG9jb2wtdXRpbHMnO1xuaW1wb3J0IHsgTWFya2V0T3BlcmF0aW9uIH0gZnJvbSAnQDB4L3R5cGVzJztcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ0AweC91dGlscyc7XG5pbXBvcnQgeyBXZWIzV3JhcHBlciB9IGZyb20gJ0AweC93ZWIzLXdyYXBwZXInO1xuaW1wb3J0IHsgcmV0cnkgfSBmcm9tICdAbGlmZW9taWMvYXR0ZW1wdCc7XG5pbXBvcnQgZGVsYXkgZnJvbSAnZGVsYXknO1xuaW1wb3J0IHsgQ291bnRlciwgR2F1Z2UsIFN1bW1hcnkgfSBmcm9tICdwcm9tLWNsaWVudCc7XG5cbmltcG9ydCB7XG4gICAgRU5BQkxFX0xMUl9DT09MRE9XTixcbiAgICBJbnRlZ3JhdG9yLFxuICAgIExMUl9DT09MRE9XTl9EVVJBVElPTl9TRUNPTkRTLFxuICAgIFRBS0VSX1NQRUNJRklFRF9TSURFX0VOQUJMRUQsXG59IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQge1xuICAgIEVUSF9ERUNJTUFMUyxcbiAgICBHQVNfRVNUSU1BVEVfQlVGRkVSLFxuICAgIEdXRUlfREVDSU1BTFMsXG4gICAgTExSX0NPT0xET1dOX1dJTkRPV19TRUNPTkRTLFxuICAgIE9ORV9NSU5VVEVfUyxcbiAgICBPTkVfU0VDT05EX01TLFxufSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBzdG9yZWRGZWVUb0ZlZSB9IGZyb20gJy4uL2NvcmUvZmVlX3V0aWxzJztcbmltcG9ydCB7IEFwcHJvdmFsIH0gZnJvbSAnLi4vY29yZS90eXBlcyc7XG5pbXBvcnQge1xuICAgIE1ldGFUcmFuc2FjdGlvbkpvYkVudGl0eSxcbiAgICBNZXRhVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5LFxuICAgIFJmcW1WMkpvYkVudGl0eSxcbiAgICBSZnFtVjJUcmFuc2FjdGlvblN1Ym1pc3Npb25FbnRpdHksXG59IGZyb20gJy4uL2VudGl0aWVzJztcbmltcG9ydCB7XG4gICAgUmZxbUpvYlN0YXR1cyxcbiAgICBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uU3RhdHVzLFxuICAgIFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25UeXBlLFxuICAgIFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLFxufSBmcm9tICcuLi9lbnRpdGllcy90eXBlcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgU2lnblJlcXVlc3QgfSBmcm9tICcuLi9xdW90ZS1zZXJ2ZXIvdHlwZXMnO1xuaW1wb3J0IHsgQ2FjaGVDbGllbnQgfSBmcm9tICcuLi91dGlscy9jYWNoZV9jbGllbnQnO1xuaW1wb3J0IHsgR2FzU3RhdGlvbkF0dGVuZGFudCB9IGZyb20gJy4uL3V0aWxzL0dhc1N0YXRpb25BdHRlbmRhbnQnO1xuaW1wb3J0IHsgUXVvdGVTZXJ2ZXJDbGllbnQgfSBmcm9tICcuLi91dGlscy9xdW90ZV9zZXJ2ZXJfY2xpZW50JztcbmltcG9ydCB7IFJmcW1EYlV0aWxzLCBzdG9yZWRPdGNPcmRlclRvT3RjT3JkZXIgfSBmcm9tICcuLi91dGlscy9yZnFtX2RiX3V0aWxzJztcbmltcG9ydCB7IFJmcUJsb2NrY2hhaW5VdGlscyB9IGZyb20gJy4uL3V0aWxzL3JmcV9ibG9ja2NoYWluX3V0aWxzJztcbmltcG9ydCB7IFJmcU1ha2VyTWFuYWdlciB9IGZyb20gJy4uL3V0aWxzL3JmcV9tYWtlcl9tYW5hZ2VyJztcbmltcG9ydCB7IGdldFNpZ25lckZyb21IYXNoLCBwYWRTaWduYXR1cmUgfSBmcm9tICcuLi91dGlscy9zaWduYXR1cmVfdXRpbHMnO1xuaW1wb3J0IHsgU3VibWlzc2lvbkNvbnRleHQgfSBmcm9tICcuLi91dGlscy9TdWJtaXNzaW9uQ29udGV4dCc7XG5cbmltcG9ydCB7IFJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSB9IGZyb20gJy4vcmZxX21ha2VyX2JhbGFuY2VfY2FjaGVfc2VydmljZSc7XG5cbmludGVyZmFjZSBHYXNGZWVzIHtcbiAgICBtYXhGZWVQZXJHYXM6IEJpZ051bWJlcjtcbiAgICBtYXhQcmlvcml0eUZlZVBlckdhczogQmlnTnVtYmVyO1xufVxuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NzYzMjYyMi90eXBlc2NyaXB0LWFuZC1maWx0ZXItYm9vbGVhblxuZnVuY3Rpb24gaXNEZWZpbmVkPFQ+KHZhbHVlOiBUKTogdmFsdWUgaXMgTm9uTnVsbGFibGU8VD4ge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuXG5jb25zdCBSRlFNX1dPUktFUl9CQUxBTkNFID0gbmV3IEdhdWdlKHtcbiAgICBuYW1lOiAncmZxbV93b3JrZXJfYmFsYW5jZScsXG4gICAgbGFiZWxOYW1lczogWydhZGRyZXNzJywgJ2NoYWluX2lkJ10sXG4gICAgaGVscDogJ1dvcmtlciBiYWxhbmNlIGZvciBSRlFNJyxcbn0pO1xuXG5jb25zdCBSRlFNX1dPUktFUl9SRUFEWSA9IG5ldyBDb3VudGVyKHtcbiAgICBuYW1lOiAncmZxbV93b3JrZXJfcmVhZHknLFxuICAgIGxhYmVsTmFtZXM6IFsnYWRkcmVzcycsICdjaGFpbl9pZCddLFxuICAgIGhlbHA6ICdBIHdvcmtlciBwYXNzZWQgdGhlIHJlYWRpbmVzcyBjaGVjaywgYW5kIGlzIHJlYWR5IHRvIHBpY2sgdXAgd29yaycsXG59KTtcblxuY29uc3QgUkZRTV9XT1JLRVJfTk9UX1JFQURZID0gbmV3IENvdW50ZXIoe1xuICAgIG5hbWU6ICdyZnFtX3dvcmtlcl9ub3RfcmVhZHknLFxuICAgIGxhYmVsTmFtZXM6IFsnYWRkcmVzcycsICdjaGFpbl9pZCddLFxuICAgIGhlbHA6ICdBIHdvcmtlciBkaWQgbm90IHBhc3MgdGhlIHJlYWRpbmVzcyBjaGVjaywgYW5kIHdhcyBub3QgYWJsZSB0byBwaWNrIHVwIHdvcmsnLFxufSk7XG5cbmNvbnN0IFJGUU1fSk9CX1JFUEFJUiA9IG5ldyBHYXVnZSh7XG4gICAgbmFtZTogJ3JmcW1fam9iX3RvX3JlcGFpcicsXG4gICAgbGFiZWxOYW1lczogWydhZGRyZXNzJywgJ2NoYWluX2lkJ10sXG4gICAgaGVscDogJ0Egc3VibWl0dGVkIGpvYiBmYWlsZWQgYW5kIHN0YXJ0ZWQgcmVwYWlyIG1vZGUnLFxufSk7XG5cbmNvbnN0IFJGUU1fSk9CX0ZBSUxFRF9NTV9TSUdOQVRVUkVfRkFJTEVEID0gbmV3IENvdW50ZXIoe1xuICAgIG5hbWU6ICdyZnFtX2pvYl9mYWlsZWRfbW1fc2lnbmF0dXJlX2ZhaWxlZCcsXG4gICAgaGVscDogJ0Egam9iIGZhaWxlZCBiZWNhdXNlIHRoZSBtYXJrZXQgbWFrZXIgc2lnbmF0dXJlIHByb2Nlc3MgZmFpbGVkLiBOT1QgdHJpZ2dlcmVkIHdoZW4gdGhlIE1NIGRlY2xpbmVzIHRvIHNpZ24uJyxcbiAgICBsYWJlbE5hbWVzOiBbJ21ha2VyVXJpJywgJ2NoYWluX2lkJ10sXG59KTtcbmNvbnN0IFJGUU1fSk9CX01NX1JFSkVDVEVEX0xBU1RfTE9PSyA9IG5ldyBDb3VudGVyKHtcbiAgICBuYW1lOiAncmZxbV9qb2JfbW1fcmVqZWN0ZWRfbGFzdF9sb29rJyxcbiAgICBoZWxwOiAnQSBqb2IgcmVqZWN0ZWQgYnkgbWFya2V0IG1ha2VyIG9uIGxhc3QgbG9vaycsXG4gICAgbGFiZWxOYW1lczogWydtYWtlclVyaScsICdjaGFpbl9pZCddLFxufSk7XG5cbmNvbnN0IFJGUU1fUFJPQ0VTU19KT0JfTEFURU5DWSA9IG5ldyBTdW1tYXJ5KHtcbiAgICBuYW1lOiAncmZxbV9wcm9jZXNzX2pvYl9sYXRlbmN5JyxcbiAgICBsYWJlbE5hbWVzOiBbJ2NoYWluX2lkJywgJ2pvYl9raW5kJ10sXG4gICAgaGVscDogJ0xhdGVuY3kgZm9yIHRoZSB3b3JrZXIgcHJvY2Vzc2luZyB0aGUgam9iJyxcbn0pO1xuXG5jb25zdCBSRlFNX0pPQl9DT01QTEVURUQgPSBuZXcgQ291bnRlcih7XG4gICAgbmFtZTogJ3JmcW1fam9iX2NvbXBsZXRlZCcsXG4gICAgaGVscDogJ0FuIFJmcW0gSm9iIGNvbXBsZXRlZCB3aXRoIG5vIGVycm9ycycsXG4gICAgbGFiZWxOYW1lczogWydhZGRyZXNzJywgJ2NoYWluX2lkJywgJ2pvYl9raW5kJ10sXG59KTtcblxuY29uc3QgUkZRTV9KT0JfQ09NUExFVEVEX1dJVEhfRVJST1IgPSBuZXcgQ291bnRlcih7XG4gICAgbmFtZTogJ3JmcW1fam9iX2NvbXBsZXRlZF93aXRoX2Vycm9yJyxcbiAgICBoZWxwOiAnQW4gUmZxbSBKb2IgY29tcGxldGVkIHdpdGggYW4gZXJyb3InLFxuICAgIGxhYmVsTmFtZXM6IFsnYWRkcmVzcycsICdjaGFpbl9pZCcsICdqb2Jfa2luZCddLFxufSk7XG5cbmNvbnN0IFJGUU1fQ1JFQVRFX0FDQ0VTU19MSVNUX1JFUVVFU1QgPSBuZXcgQ291bnRlcih7XG4gICAgbmFtZTogJ3JmcW1fY3JlYXRlX2FjY2Vzc19saXN0X3JlcXVlc3RfdG90YWwnLFxuICAgIGhlbHA6ICdOdW1iZXIgb2YgcmVxdWVzdHMgZm9yIGV0aF9jcmVhdGVBY2Nlc3NMaXN0IGNhbGwnLFxuICAgIGxhYmVsTmFtZXM6IFsnY2hhaW5faWQnLCAnc3RhdHVzJ10sXG59KTtcblxuY29uc3QgUkZRTV9HQVNfRVNUSU1BVEVfQUNDRVNTX0xJU1QgPSBuZXcgR2F1Z2Uoe1xuICAgIG5hbWU6ICdyZnFtX2dhc19lc3RpbWF0ZV9hY2Vzc19saXN0JyxcbiAgICBoZWxwOiAnR2FzIGVzdGltYXRlIG9mIHRyYW5zYWN0aW9uIHdpdGggYWNjZXNzIGxpc3QnLFxuICAgIGxhYmVsTmFtZXM6IFsnY2hhaW5faWQnXSxcbn0pO1xuXG5jb25zdCBSRlFNX0dBU19FU1RJTUFURV9OT19BQ0NFU1NfTElTVCA9IG5ldyBHYXVnZSh7XG4gICAgbmFtZTogJ3JmcW1fZ2FzX2VzdGltYXRlX25vX2FjY2Vzc19saXN0JyxcbiAgICBoZWxwOiAnR2FzIGVzdGltYXRlIG9mIHRyYW5zYWN0aW9uIHdpdGhvdXQgYWNjZXNzIGxpc3QnLFxuICAgIGxhYmVsTmFtZXM6IFsnY2hhaW5faWQnXSxcbn0pO1xuXG5jb25zdCBSRlFNX1NJR05FRF9RVU9URV9FWFBJUllfVE9PX1NPT04gPSBuZXcgQ291bnRlcih7XG4gICAgbmFtZTogJ3JmcW1fc2lnbmVkX3F1b3RlX2V4cGlyeV90b29fc29vbicsXG4gICAgbGFiZWxOYW1lczogWydjaGFpbl9pZCddLFxuICAgIGhlbHA6ICdBIHNpZ25lZCBxdW90ZSB3YXMgbm90IHF1ZXVlZCBiZWNhdXNlIGl0IHdvdWxkIGV4cGlyZSB0b28gc29vbicsXG59KTtcblxuY29uc3QgUkZRTV9NSU5JTkdfTEFURU5DWSA9IG5ldyBTdW1tYXJ5KHtcbiAgICBuYW1lOiAncmZxbV9taW5pbmdfbGF0ZW5jeScsXG4gICAgbGFiZWxOYW1lczogWydjaGFpbl9pZCddLFxuICAgIGhlbHA6ICdUaGUgdGltZSBpbiBzZWNvbmRzIGJldHdlZW4gd2hlbiB0aGUgZmlyc3QgdHJhbnNhY3Rpb24gZm9yIGEgam9iIGlzIHNlbnQgYW5kIHdoZW4gYSB0cmFuc2FjdGlvbiBmb3IgdGhlIGpvYiBpcyBtaW5lZCcsXG59KTtcblxuY29uc3QgUFJJQ0VfREVDSU1BTF9QTEFDRVMgPSA2O1xuXG5jb25zdCBNSU5fR0FTX1BSSUNFX0lOQ1JFQVNFID0gMC4xO1xuXG4vLyBSZXRyeWluZyBhbiBFSVAgMTU1OSB0cmFuc2FjdGlvbjogaHR0cHM6Ly9kb2NzLmFsY2hlbXkuY29tL2FsY2hlbXkvZ3VpZGVzL2VpcC0xNTU5L3JldHJ5LWVpcC0xNTU5LXR4XG5jb25zdCBNQVhfUFJJT1JJVFlfRkVFX1BFUl9HQVNfTVVMVElQTElFUiA9IDEuNTsgLy8gSW5jcmVhc2UgbXVsdGlwbGllciBmb3IgdGlwIHdpdGggZWFjaCByZXN1Ym1pc3Npb24gY3ljbGVcbmNvbnN0IE1BWF9GRUVfUEVSX0dBU19NVUxUSVBMSUVSID0gMS4xOyAvLyBJbmNyZWFzZSBtdWx0aXBsaWVyIGluIG1heCBmZWUgcGVyIGdhcyB3aXRoIGVhY2ggY3ljbGU7IGxpbWl0YXRpb24gb2YgZ2V0aCBub2RlXG4vLyBEdXJpbmcgcmVjb3ZlcnksIHdlIG1heSBub3QgYmUgYWJsZSB0byBzdWNjZXNzZnVsbHkgZXhlY3V0ZVxuLy8gYGVzdGltYXRlR2FzRm9yQXN5bmNgLiBJbiB0aGlzIGNhc2Ugd2UgdXNlIHRoaXMgdmFsdWUuXG5jb25zdCBNQVhfR0FTX0VTVElNQVRFID0gNTAwXzAwMDtcbmNvbnN0IFNJTVVMQVRJT05fTUFYX0dBU19NVUxUSVBMSUVSID0gMjsgLy8gTXVsdGlwbGllciBvZiBjb25maWd1cmVkIG1heCBmZWUgd2hlbiBwZXJmb3JtaW5nIHRyYW5zYWN0aW9uIHNpbXVsYXRpb25cblxuLy8gSG93IG9mdGVuIHRoZSB3b3JrZXIgc2hvdWxkIHB1Ymxpc2ggYSBoZWFydGJlYXRcbmNvbnN0IFdPUktFUl9IRUFSVEJFQVRfRlJFUVVFTkNZX01TID0gT05FX1NFQ09ORF9NUyAqIDMwOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOiBjdXN0b20tbm8tbWFnaWMtbnVtYmVyc1xuXG4vKipcbiAqIFRoZSBzZXJ2aWNlIGxheWVyIGZvciBHYXNsZXNzIFdvcmtlcnMuXG4gKlxuICogV29ya2VycyBhcmUgYm90cyB3aXRoIHRoZWlyIG93biBFT0FzIHdoaWNoIHB1bGxcbiAqIG1lc3NhZ2VzIG9mZiBhbiBTUVMgcXVldWUsIHJldHJpZXZlIHRoZSByZWxhdGVkXG4gKiBqb2IsIGFuZCBzdWJtaXQgdGhhdCBqb2IgdG8gdGhlIGJsb2NrY2hhaW4uXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3JrZXJTZXJ2aWNlIHtcbiAgICBwcml2YXRlIF9sYXN0SGVhcnRiZWF0VGltZTogRGF0ZSB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgX21heEZlZVBlckdhc0NhcFdlaTogQmlnTnVtYmVyO1xuXG4gICAgcHVibGljIHN0YXRpYyBzaG91bGRSZXN1Ym1pdFRyYW5zYWN0aW9uKGdhc0ZlZXM6IEdhc0ZlZXMsIGdhc1ByaWNlRXN0aW1hdGU6IEJpZ051bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICAvLyBHZXRoIG9ubHkgYWxsb3dzIHJlcGxhY2VtZW50IG9mIHRyYW5zYWN0aW9ucyBpZiB0aGUgcmVwbGFjZW1lbnQgZ2FzIHByaWNlXG4gICAgICAgIC8vIGlzIGF0IGxlYXN0IDEwJSBoaWdoZXIgdGhhbiB0aGUgZ2FzIHByaWNlIG9mIHRoZSB0cmFuc2FjdGlvbiBiZWluZyByZXBsYWNlZFxuICAgICAgICByZXR1cm4gZ2FzUHJpY2VFc3RpbWF0ZS5ndGUoZ2FzRmVlcy5tYXhGZWVQZXJHYXMubXVsdGlwbGllZEJ5KE1JTl9HQVNfUFJJQ0VfSU5DUkVBU0UgKyAxKSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIGZhaWx1cmUgc3RhdHVzIGZvciBhbiBpbnZhbGlkIHJmcW0gdjIgam9iIG9yIG51bGwgaWYgam9iIGlzIHZhbGlkLlxuICAgIHB1YmxpYyBzdGF0aWMgdmFsaWRhdGVSZnFtVjJKb2Ioam9iOiBSZnFtVjJKb2JFbnRpdHksIG5vdzogRGF0ZSA9IG5ldyBEYXRlKCkpOiBSZnFtSm9iU3RhdHVzIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHsgbWFrZXJVcmksIG9yZGVyLCBmZWUgfSA9IGpvYjtcblxuICAgICAgICBpZiAobWFrZXJVcmkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFJmcW1Kb2JTdGF0dXMuRmFpbGVkVmFsaWRhdGlvbk5vTWFrZXJVcmk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3JkZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBSZnFtSm9iU3RhdHVzLkZhaWxlZFZhbGlkYXRpb25Ob09yZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZlZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFJmcW1Kb2JTdGF0dXMuRmFpbGVkVmFsaWRhdGlvbk5vRmVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3JkZXJzIGNhbiBleHBpcmUgaWYgYW55IG9mIHRoZSBmb2xsb3dpbmcgaGFwcGVuOlxuICAgICAgICAvLyAxKSB3b3JrZXJzIGFyZSBiYWNrZWQgdXBcbiAgICAgICAgLy8gMikgYW4gUkZRTSBvcmRlciBicm9rZSBkdXJpbmcgc3VibWlzc2lvbiBhbmQgdGhlIG9yZGVyIGlzIHN0dWNrIGluIHRoZSBxdWV1ZSBmb3IgYSBsb25nIHRpbWUuXG4gICAgICAgIGNvbnN0IG90Y09yZGVyU3RyaW5nRmllbGRzID0gam9iLm9yZGVyLm9yZGVyO1xuICAgICAgICBjb25zdCB7IGV4cGlyeSB9ID0gT3RjT3JkZXIucGFyc2VFeHBpcnlBbmROb25jZShuZXcgQmlnTnVtYmVyKG90Y09yZGVyU3RyaW5nRmllbGRzLmV4cGlyeUFuZE5vbmNlKSk7XG4gICAgICAgIGNvbnN0IGV4cGlyeVRpbWVNcyA9IGV4cGlyeS50aW1lcyhPTkVfU0VDT05EX01TKTtcbiAgICAgICAgaWYgKGV4cGlyeVRpbWVNcy5pc05hTigpIHx8IGV4cGlyeVRpbWVNcy5sdGUobm93LmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBSZnFtSm9iU3RhdHVzLkZhaWxlZEV4cGlyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqb2IudGFrZXJTaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBSZnFtSm9iU3RhdHVzLkZhaWxlZFZhbGlkYXRpb25Ob1Rha2VyU2lnbmF0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIGZhaWx1cmUgc3RhdHVzIGZvciBhbiBpbnZhbGlkIG1ldGEtdHJhbnNhY3Rpb24gam9iIG9yIG51bGwgaWYgam9iIGlzIHZhbGlkLlxuICAgIHB1YmxpYyBzdGF0aWMgdmFsaWRhdGVNZXRhVHJhbnNhY3Rpb25Kb2IoXG4gICAgICAgIGpvYjogTWV0YVRyYW5zYWN0aW9uSm9iRW50aXR5LFxuICAgICAgICBub3c6IERhdGUgPSBuZXcgRGF0ZSgpLFxuICAgICk6IFJmcW1Kb2JTdGF0dXMgfCBudWxsIHtcbiAgICAgICAgY29uc3QgeyBleHBpcnksIGZlZSwgbWV0YVRyYW5zYWN0aW9uLCB0YWtlclNpZ25hdHVyZSB9ID0gam9iO1xuXG4gICAgICAgIGlmIChtZXRhVHJhbnNhY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBSZnFtSm9iU3RhdHVzLkZhaWxlZFZhbGlkYXRpb25Ob09yZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZlZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFJmcW1Kb2JTdGF0dXMuRmFpbGVkVmFsaWRhdGlvbk5vRmVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3JkZXJzIGNhbiBleHBpcmUgaWYgYW55IG9mIHRoZSBmb2xsb3dpbmcgaGFwcGVuOlxuICAgICAgICAvLyAxKSB3b3JrZXJzIGFyZSBiYWNrZWQgdXBcbiAgICAgICAgLy8gMikgYW4gb3JkZXIgYnJva2UgZHVyaW5nIHN1Ym1pc3Npb24gYW5kIHRoZSBvcmRlciBpcyBzdHVjayBpbiB0aGUgcXVldWUgZm9yIGEgbG9uZyB0aW1lLlxuICAgICAgICBjb25zdCBleHBpcnlUaW1lTXMgPSBleHBpcnkudGltZXMoT05FX1NFQ09ORF9NUyk7XG4gICAgICAgIGlmIChleHBpcnlUaW1lTXMuaXNOYU4oKSB8fCBleHBpcnlUaW1lTXMubHRlKG5vdy5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gUmZxbUpvYlN0YXR1cy5GYWlsZWRFeHBpcmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFrZXJTaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBSZnFtSm9iU3RhdHVzLkZhaWxlZFZhbGlkYXRpb25Ob1Rha2VyU2lnbmF0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX2NoYWluSWQ6IG51bWJlcixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfZ2FzU3RhdGlvbkF0dGVuZGFudDogR2FzU3RhdGlvbkF0dGVuZGFudCxcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfcmVnaXN0cnlBZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX2Jsb2NrY2hhaW5VdGlsczogUmZxQmxvY2tjaGFpblV0aWxzLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9kYlV0aWxzOiBSZnFtRGJVdGlscyxcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfcXVvdGVTZXJ2ZXJDbGllbnQ6IFF1b3RlU2VydmVyQ2xpZW50LFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF90cmFuc2FjdGlvbldhdGNoZXJTbGVlcFRpbWVNczogbnVtYmVyLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9jYWNoZUNsaWVudDogQ2FjaGVDbGllbnQsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX3JmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZTogUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9yZnFNYWtlck1hbmFnZXI6IFJmcU1ha2VyTWFuYWdlcixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfaW5pdGlhbE1heFByaW9yaXR5RmVlUGVyR2FzR3dlaTogbnVtYmVyLFxuICAgICAgICBtYXhGZWVQZXJHYXNDYXBHd2VpOiBudW1iZXIsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX2VuYWJsZUFjY2Vzc0xpc3Q/OiBib29sZWFuLFxuICAgICkge1xuICAgICAgICB0aGlzLl9tYXhGZWVQZXJHYXNDYXBXZWkgPSBuZXcgQmlnTnVtYmVyKG1heEZlZVBlckdhc0NhcEd3ZWkpLnRpbWVzKE1hdGgucG93KDEwLCBHV0VJX0RFQ0lNQUxTKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHdvcmtlckJlZm9yZUxvZ2ljQXN5bmMod29ya2VySW5kZXg6IG51bWJlciwgd29ya2VyQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGxldCBnYXNQcmljZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdhc1ByaWNlID0gYXdhaXQgdGhpcy5fZ2FzU3RhdGlvbkF0dGVuZGFudC5nZXRFeHBlY3RlZFRyYW5zYWN0aW9uR2FzUmF0ZUFzeW5jKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgeyBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfSxcbiAgICAgICAgICAgICAgICAnQ3VycmVudCBnYXMgcHJpY2UgaXMgdW5hYmxlIHRvIGJlIGZldGNoZWQsIG1hcmtpbmcgd29ya2VyIGFzIG5vdCByZWFkeS4nLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFJGUU1fV09SS0VSX05PVF9SRUFEWS5sYWJlbHMod29ya2VyQWRkcmVzcywgdGhpcy5fY2hhaW5JZC50b1N0cmluZygpKS5pbmMoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZ2V0QWNjb3VudEJhbGFuY2VBc3luYyh3b3JrZXJBZGRyZXNzKTtcbiAgICAgICAgY29uc3QgYmFsYW5jZVVuaXRBbW91bnQgPSBXZWIzV3JhcHBlci50b1VuaXRBbW91bnQoYmFsYW5jZSwgRVRIX0RFQ0lNQUxTKS5kZWNpbWFsUGxhY2VzKFBSSUNFX0RFQ0lNQUxfUExBQ0VTKTtcbiAgICAgICAgUkZRTV9XT1JLRVJfQkFMQU5DRS5sYWJlbHMod29ya2VyQWRkcmVzcywgdGhpcy5fY2hhaW5JZC50b1N0cmluZygpKS5zZXQoYmFsYW5jZVVuaXRBbW91bnQudG9OdW1iZXIoKSk7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG91dHN0YW5kaW5nIGpvYnMgZnJvbSB0aGUgd29ya2VyIGFuZCByZXNvbHZlIHRoZW1cbiAgICAgICAgY29uc3QgdW5yZXNvbHZlZEpvYnMgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLl9kYlV0aWxzLmZpbmRWMlVucmVzb2x2ZWRKb2JzQXN5bmMod29ya2VyQWRkcmVzcywgdGhpcy5fY2hhaW5JZCksXG4gICAgICAgICAgICB0aGlzLl9kYlV0aWxzLmZpbmRVbnJlc29sdmVkTWV0YVRyYW5zYWN0aW9uSm9ic0FzeW5jKHdvcmtlckFkZHJlc3MsIHRoaXMuX2NoYWluSWQpLFxuICAgICAgICBdKS50aGVuKCh4KSA9PiB4LmZsYXQoKSk7XG5cbiAgICAgICAgUkZRTV9KT0JfUkVQQUlSLmxhYmVscyh3b3JrZXJBZGRyZXNzLCB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLmluYyh1bnJlc29sdmVkSm9icy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGNvbnN0IGpvYiBvZiB1bnJlc29sdmVkSm9icykge1xuICAgICAgICAgICAgY29uc3QgeyBraW5kIH0gPSBqb2I7XG4gICAgICAgICAgICBsZXQgam9iSWRlbnRpZmllcjtcblxuICAgICAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmZxbV92Ml9qb2InOlxuICAgICAgICAgICAgICAgICAgICBqb2JJZGVudGlmaWVyID0gam9iLm9yZGVySGFzaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWV0YV90cmFuc2FjdGlvbl9qb2InOlxuICAgICAgICAgICAgICAgICAgICBqb2JJZGVudGlmaWVyID0gam9iLmlkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAoKF94OiBuZXZlcik6IG5ldmVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWFjaGFibGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoa2luZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKHsga2luZCwgam9iSWRlbnRpZmllciwgd29ya2VyQWRkcmVzcyB9LCBgVW5yZXNvbHZlZCBqb2IgZm91bmQsIGF0dGVtcHRpbmcgdG8gcmVwcm9jZXNzYCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NKb2JBc3luYyhqb2JJZGVudGlmaWVyLCB3b3JrZXJBZGRyZXNzLCBraW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzV29ya2VyUmVhZHkgPSBhd2FpdCB0aGlzLl9ibG9ja2NoYWluVXRpbHMuaXNXb3JrZXJSZWFkeUFzeW5jKFxuICAgICAgICAgICAgdGhpcy5fY2hhaW5JZCxcbiAgICAgICAgICAgIHdvcmtlckFkZHJlc3MsXG4gICAgICAgICAgICBiYWxhbmNlLFxuICAgICAgICAgICAgQmlnTnVtYmVyLm1pbihnYXNQcmljZSwgdGhpcy5fbWF4RmVlUGVyR2FzQ2FwV2VpKSxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFpc1dvcmtlclJlYWR5KSB7XG4gICAgICAgICAgICBSRlFNX1dPUktFUl9OT1RfUkVBRFkubGFiZWxzKHdvcmtlckFkZHJlc3MsIHRoaXMuX2NoYWluSWQudG9TdHJpbmcoKSkuaW5jKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbGFzdEhlYXJ0YmVhdFRpbWUgJiYgRGF0ZS5ub3coKSAtIHRoaXMuX2xhc3RIZWFydGJlYXRUaW1lLmdldFRpbWUoKSA8IFdPUktFUl9IRUFSVEJFQVRfRlJFUVVFTkNZX01TKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1Ymxpc2ggYSBoZWFydGJlYXQgaWYgdGhlIHdvcmtlciBpcyByZWFkeSB0byBnb1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHdvcmtlckluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtlciBpbmRleCBpcyB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEU6IHdoZW4gbWVyZ2luZyB3aXRoIGBmZWF0dXJlL211bHRpY2hhaW5gLCB1cGRhdGUgdGhpcyBsaW5lIHdpdGhcbiAgICAgICAgICAgIC8vIGBjb25zdCBjaGFpbklkID0gdGhpcy5fY2hhaW4uY2hhaW5JZC5cbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLl9jaGFpbklkO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGJVdGlscy51cHNlcnRSZnFtV29ya2VySGVhcnRiZWF0VG9EYkFzeW5jKHdvcmtlckFkZHJlc3MsIHdvcmtlckluZGV4LCBiYWxhbmNlLCBjaGFpbklkKTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RIZWFydGJlYXRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICB7IHdvcmtlckFkZHJlc3MsIGJhbGFuY2UsIGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSB9LFxuICAgICAgICAgICAgICAgICdXb3JrZXIgZmFpbGVkIHRvIHdyaXRlIGEgaGVhcnRiZWF0IHRvIHN0b3JhZ2UnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFJGUU1fV09SS0VSX1JFQURZLmxhYmVscyh3b3JrZXJBZGRyZXNzLCB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLmluYygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb3AtbGV2ZWwgbG9naWMgdGhlIHdvcmtlciB1c2VzIHRvIHRha2UgYSB2MiBqb2Igb3IgbWV0YS10cmFuc2FjdGlvbiBqb2IgdG8gY29tcGxldGlvbi5cbiAgICAgKiBUaGUgaWRlbnRpZmllciAob3JkZXJIYXNoIGZvciB2MiBqb2IgYW5kIGpvZCBpZCBmb3IgbWV0YS10cmFuc2FjdGlvbiBqb2IpIGNhbiBjb21lIGZyb21cbiAgICAgKiBlaXRoZXIgYW4gdW5maW5pc2hlZCBqb2IgZm91bmQgZHVyaW5nIHRoZSB3b3JrZXIgYmVmb3JlIGxvZ2ljIG9yIGZyb20gYW4gU1FTIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBCaWcgcGljdHVyZSBzdGVwczpcbiAgICAgKiAxLiBGZXRjaCB0aGUgam9iIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICogMi4gUHJlcGFyZSB0aGUgam9iIGJ5IHZhbGlkYXRpbmcgaXQgKGFuZCBnZXR0aW5nIHRoZSBtYXJrZXQgbWFrZXIgc2lnbmF0dXJlIGZvciB2MiBqb2IpLlxuICAgICAqICAgIFRoaXMgc3RlcCBpcyBkaWZmZXJlbnQgZm9yIHYyIGFuZCBtZXRhLXRyYW5zYWN0aW9uIGpvYnMuXG4gICAgICogMy4gU3VibWl0IGEgdHJhbnNhY3Rpb24gaWYgbm9uZSBleGlzdCwgd2FpdCBmb3IgbWluaW5nICsgY29uZmlybWF0aW9uLFxuICAgICAqICAgIGFuZCBzdWJtaXQgbmV3IHRyYW5zYWN0aW9ucyBpZiBnYXMgcHJpY2VzIHJpc2VcbiAgICAgKiA0LiBGaW5hbGl6ZSB0aGUgam9iIHN0YXR1c1xuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgZXJyb3IgYm91bmRhcnkgZm9yIGpvYiBwcm9jZXNzaW5nOyBlcnJvcnMgd2lsbCBiZSBjYXVnaHQsIGxvZ2dlZFxuICAgICAqIGFuZCBzd2FsbG93ZWQuIFRoZSB3b3JrZXIgd2lsbCBjb250aW51ZSBhbG9uZyBpdHMgbGlmZWN5Y2xlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHByb2Nlc3NpbmcgbGF0ZW5jeSBtZXRyaWNzICYgam9iIHN1Y2Nlc3MvZmFpbCBjb3VudGVycy5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgcHJvY2Vzc0pvYkFzeW5jKFxuICAgICAgICBpZGVudGlmaWVyOiBzdHJpbmcsXG4gICAgICAgIHdvcmtlckFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAga2luZDogKFJmcW1WMkpvYkVudGl0eSB8IE1ldGFUcmFuc2FjdGlvbkpvYkVudGl0eSlbJ2tpbmQnXSA9ICdyZnFtX3YyX2pvYicsXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGxvZ2dlci5pbmZvKHsga2luZCwgaWRlbnRpZmllciwgd29ya2VyQWRkcmVzcyB9LCAnU3RhcnQgcHJvY2VzcyBqb2InKTtcbiAgICAgICAgY29uc3QgdGltZXJTdG9wRnVuY3Rpb24gPSBSRlFNX1BST0NFU1NfSk9CX0xBVEVOQ1kubGFiZWxzKHRoaXMuX2NoYWluSWQudG9TdHJpbmcoKSwga2luZCkuc3RhcnRUaW1lcigpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTdGVwIDE6IEZpbmQgdGhlIGpvYlxuICAgICAgICAgICAgbGV0IGpvYjtcbiAgICAgICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JmcW1fdjJfam9iJzpcbiAgICAgICAgICAgICAgICAgICAgam9iID0gYXdhaXQgdGhpcy5fZGJVdGlscy5maW5kVjJKb2JCeU9yZGVySGFzaEFzeW5jKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtZXRhX3RyYW5zYWN0aW9uX2pvYic6XG4gICAgICAgICAgICAgICAgICAgIGpvYiA9IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZE1ldGFUcmFuc2FjdGlvbkpvYkJ5SWRBc3luYyhpZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgKChfeDogbmV2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoa2luZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgham9iKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBqb2IgZm91bmQgZm9yIGlkZW50aWZpZXInKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RlcCAyOiBQcmVwYXJlIHRoZSBqb2IgZm9yIHN1Ym1pc3Npb25cblxuICAgICAgICAgICAgLy8gQ2xhaW0gam9iIGZvciB3b3JrZXJcbiAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uLEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGlmIChqb2Iud29ya2VyQWRkcmVzcyEhICYmIGpvYi53b3JrZXJBZGRyZXNzICE9PSB3b3JrZXJBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXIgd2FzIHNlbnQgYSBqb2IgY2xhaW1lZCBieSBhIGRpZmZlcmVudCB3b3JrZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpvYi53b3JrZXJBZGRyZXNzID0gd29ya2VyQWRkcmVzcztcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbUpvYkFzeW5jKGpvYik7XG4gICAgICAgICAgICBpZiAoam9iLmFwcHJvdmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gYXBwcm92YWwgYW5kIHRyYWRlIHdvcmtmbG93XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzQXBwcm92YWxBbmRUcmFkZUFzeW5jKGpvYiwgd29ya2VyQWRkcmVzcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRyYWRlIG9ubHkgd29ya2Zsb3dcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NUcmFkZUFzeW5jKGpvYiwgd29ya2VyQWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyh7IGtpbmQsIGlkZW50aWZpZXIsIHdvcmtlckFkZHJlc3MgfSwgJ0pvYiBjb21wbGV0ZWQgd2l0aG91dCBlcnJvcnMnKTtcbiAgICAgICAgICAgIFJGUU1fSk9CX0NPTVBMRVRFRC5sYWJlbHMod29ya2VyQWRkcmVzcywgdGhpcy5fY2hhaW5JZC50b1N0cmluZygpLCBraW5kKS5pbmMoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcih7IGtpbmQsIHdvcmtlckFkZHJlc3MsIGlkZW50aWZpZXIsIGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSB9LCAnSm9iIGNvbXBsZXRlZCB3aXRoIGVycm9yJyk7XG4gICAgICAgICAgICBSRlFNX0pPQl9DT01QTEVURURfV0lUSF9FUlJPUi5sYWJlbHMod29ya2VyQWRkcmVzcywgdGhpcy5fY2hhaW5JZC50b1N0cmluZygpLCBraW5kKS5pbmMoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRpbWVyU3RvcEZ1bmN0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFwcHJvdmFsIChnYXNsZXNzIGFwcHJvdmFsKSBhbmQgdHJhZGUgKHN3YXAgd2l0aCB0aGUgMHggZXhjaGFuZ2UgcHJveHkpIHN1Ym1pc3Npb25zLiBGb3IgdGhlIGZpcnN0IHZlcnNpb24sXG4gICAgICogdGhleSB3aWxsIGJlIHByb2Nlc3NlZCBTRVFVRU5USUFMTFkuIEluIHRoZSBmdXR1cmUsIHdlIHdhbnQgdG8gc2VuZCB0aGUgdHdvIHRyYW5zYWN0aW9uIGluIHBhcmFsbGVsLlxuICAgICAqIFRoZSByZWFzb24gd2UgY2FuJ3QgcGFyYWxsZWxpemUgdGhlIHN1Ym1pc3Npb25zIGlzIGJvdGggZnVuY3Rpb24gd291bGQgbW9kaWZ5IGpvYi5zdGF0dXMuXG4gICAgICpcbiAgICAgKiBUaGUgbWV0aG9kIHdvdWxkOlxuICAgICAqIDEuIFBlcmZvcm0gcHJlbGltaW5hcnkgY2hlY2sgb24gdGhlIGpvYiBvYmplY3QgKGFuZCB1cGRhdGVzIGpvYiBzdGF0dXMgdG8gYFBlbmRpbmdQcm9jZXNzaW5nYClcbiAgICAgKiAyLiBHZXR0aW5nIHRoZSBtYXJrZXQgbWFrZXIgc2lnbmF0dXJlXG4gICAgICogMy4gUHJlcGFyZSBhcHByb3ZhbFxuICAgICAqIDQuIFN1Ym1pdCBhcHByb3ZhbFxuICAgICAqIDUuIFdhaXQgdW50aWwgdGhlIGFwcHJvdmFsIHRyYW5zYWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBjb25maXJtZWRcbiAgICAgKiA2LiBQcmVwYXJlIHRyYWRlIChzaW5jZSB0aGUgbWV0aG9kIGhhcyBhbHJlYWR5IGdvdCB0aGUgbWFya2V0IG1ha2VyIHNpZ25hdHVyZSwgaXQncyBub3QgcGVyZm9ybWVkIGhlcmUpXG4gICAgICogNy4gU3VibWl0IHRyYWRlXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIHByb2Nlc3NBcHByb3ZhbEFuZFRyYWRlQXN5bmMoXG4gICAgICAgIGpvYjogUmZxbVYySm9iRW50aXR5IHwgTWV0YVRyYW5zYWN0aW9uSm9iRW50aXR5LFxuICAgICAgICB3b3JrZXJBZGRyZXNzOiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHsgYXBwcm92YWwsIGFwcHJvdmFsU2lnbmF0dXJlLCBraW5kIH0gPSBqb2I7XG4gICAgICAgIGlmICghYXBwcm92YWwgfHwgIWFwcHJvdmFsU2lnbmF0dXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1hcHByb3ZhbCBqb2Igc2hvdWxkIG5vdCBiZSBwcm9jZXNzZWQgYnkgYHByb2Nlc3NBcHByb3ZhbEFuZFRyYWRlQXN5bmNgJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQZXJmb3JtIHByZWxpbWluYXJ5IGNoZWNrXG4gICAgICAgIGF3YWl0IHRoaXMuY2hlY2tKb2JQcmVwcm9jZXNzaW5nQXN5bmMoam9iKTtcbiAgICAgICAgaWYgKGtpbmQgPT09ICdyZnFtX3YyX2pvYicpIHtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gbGFzdCBsb29rIGZvciByZnFtIHYyIGpvYlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGVja0xhc3RMb29rQXN5bmMoam9iLCB3b3JrZXJBZGRyZXNzLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG9rZW5Ub0FwcHJvdmU7XG4gICAgICAgIGxldCBpZGVudGlmaWVyO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JmcW1fdjJfam9iJzpcbiAgICAgICAgICAgICAgICB0b2tlblRvQXBwcm92ZSA9IGpvYi5vcmRlci5vcmRlci50YWtlclRva2VuO1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBqb2Iub3JkZXJIYXNoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWV0YV90cmFuc2FjdGlvbl9qb2InOlxuICAgICAgICAgICAgICAgIHRva2VuVG9BcHByb3ZlID0gam9iLmlucHV0VG9rZW47XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IGpvYi5pZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgKChfeDogbmV2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xuICAgICAgICAgICAgICAgIH0pKGtpbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXBwcm92YWxDYWxsZGF0YSA9IGF3YWl0IHRoaXMucHJlcGFyZUFwcHJvdmFsQXN5bmMoam9iLCB0b2tlblRvQXBwcm92ZSwgYXBwcm92YWwsIGFwcHJvdmFsU2lnbmF0dXJlKTtcbiAgICAgICAgY29uc3QgYXBwcm92YWxTdGF0dXMgPSBhd2FpdCB0aGlzLnN1Ym1pdFRvQ2hhaW5Bc3luYyh7XG4gICAgICAgICAgICBraW5kOiBqb2Iua2luZCxcbiAgICAgICAgICAgIHRvOiB0b2tlblRvQXBwcm92ZSxcbiAgICAgICAgICAgIGZyb206IHdvcmtlckFkZHJlc3MsXG4gICAgICAgICAgICBjYWxsZGF0YTogYXBwcm92YWxDYWxsZGF0YSxcbiAgICAgICAgICAgIGV4cGlyeTogam9iLmV4cGlyeSxcbiAgICAgICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgICBzdWJtaXNzaW9uVHlwZTogUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblR5cGUuQXBwcm92YWwsXG4gICAgICAgICAgICBvblN1Ym1pc3Npb25Db250ZXh0U3RhdHVzVXBkYXRlOiB0aGlzLl9nZXRPblN1Ym1pc3Npb25Db250ZXh0U3RhdHVzVXBkYXRlQ2FsbGJhY2soXG4gICAgICAgICAgICAgICAgam9iLFxuICAgICAgICAgICAgICAgIFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25UeXBlLkFwcHJvdmFsLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUHJlcGFyZSBhbmQgc3VibWl0IHRyYWRlIG9ubHkgaWYgYXBwcm92YWwgdHJhbnNhY3Rpb24gaXMgc3VjY2Vzc2Z1bFxuICAgICAgICBpZiAoYXBwcm92YWxTdGF0dXMgPT09IFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLlN1Y2NlZWRlZENvbmZpcm1lZCkge1xuICAgICAgICAgICAgbGV0IHRyYWRlQ2FsbGRhdGE7XG4gICAgICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyZnFtX3YyX2pvYic6XG4gICAgICAgICAgICAgICAgICAgIHRyYWRlQ2FsbGRhdGEgPSBhd2FpdCB0aGlzLnByZXBhcmVyZnFtVjJUcmFkZUFzeW5jKGpvYiwgd29ya2VyQWRkcmVzcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtZXRhX3RyYW5zYWN0aW9uX2pvYic6XG4gICAgICAgICAgICAgICAgICAgIHRyYWRlQ2FsbGRhdGEgPSBhd2FpdCB0aGlzLnByZXBhcmVNZXRhVHJhbnNhY3Rpb25UcmFkZUFzeW5jKGpvYiwgd29ya2VyQWRkcmVzcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAoKF94OiBuZXZlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xuICAgICAgICAgICAgICAgICAgICB9KShraW5kKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdWJtaXRUb0NoYWluQXN5bmMoe1xuICAgICAgICAgICAgICAgIGtpbmQ6IGpvYi5raW5kLFxuICAgICAgICAgICAgICAgIHRvOiB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZ2V0RXhjaGFuZ2VQcm94eUFkZHJlc3MoKSxcbiAgICAgICAgICAgICAgICBmcm9tOiB3b3JrZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGNhbGxkYXRhOiB0cmFkZUNhbGxkYXRhLFxuICAgICAgICAgICAgICAgIGV4cGlyeTogam9iLmV4cGlyeSxcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25UeXBlOiBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZS5UcmFkZSxcbiAgICAgICAgICAgICAgICBvblN1Ym1pc3Npb25Db250ZXh0U3RhdHVzVXBkYXRlOiB0aGlzLl9nZXRPblN1Ym1pc3Npb25Db250ZXh0U3RhdHVzVXBkYXRlQ2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgIGpvYixcbiAgICAgICAgICAgICAgICAgICAgUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblR5cGUuVHJhZGUsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0cmFkZSAoc3dhcCB3aXRoIHRoZSAweCBleGNoYW5nZSBwcm94eSkgc3VibWlzc2lvbnMuIFRoZSBtZXRob2Qgd291bGQgcHJlcGFyZSB0cmFkZSBjYWxsZGF0YVxuICAgICAqIGFuZCBzdWJtaXQgdGhlIHRyYWRlIHRvIHRoZSBibG9ja2NoYWluLiBOb3RlIHRoYXQgam9iIHN0YXR1cyB3b3VsZCBiZSB1cGRhdGVkIHRvIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRlLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBwcm9jZXNzVHJhZGVBc3luYyhcbiAgICAgICAgam9iOiBSZnFtVjJKb2JFbnRpdHkgfCBNZXRhVHJhbnNhY3Rpb25Kb2JFbnRpdHksXG4gICAgICAgIHdvcmtlckFkZHJlc3M6IHN0cmluZyxcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgeyBraW5kIH0gPSBqb2I7XG5cbiAgICAgICAgbGV0IGNhbGxkYXRhO1xuICAgICAgICBsZXQgaWRlbnRpZmllcjtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlICdyZnFtX3YyX2pvYic6XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IGpvYi5vcmRlckhhc2g7XG4gICAgICAgICAgICAgICAgY2FsbGRhdGEgPSBhd2FpdCB0aGlzLnByZXBhcmVyZnFtVjJUcmFkZUFzeW5jKGpvYiwgd29ya2VyQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZXRhX3RyYW5zYWN0aW9uX2pvYic6XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IGpvYi5pZDtcbiAgICAgICAgICAgICAgICBjYWxsZGF0YSA9IGF3YWl0IHRoaXMucHJlcGFyZU1ldGFUcmFuc2FjdGlvblRyYWRlQXN5bmMoam9iLCB3b3JrZXJBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgKChfeDogbmV2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xuICAgICAgICAgICAgICAgIH0pKGtpbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgdGhpcy5zdWJtaXRUb0NoYWluQXN5bmMoe1xuICAgICAgICAgICAga2luZDogam9iLmtpbmQsXG4gICAgICAgICAgICB0bzogdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldEV4Y2hhbmdlUHJveHlBZGRyZXNzKCksXG4gICAgICAgICAgICBmcm9tOiB3b3JrZXJBZGRyZXNzLFxuICAgICAgICAgICAgY2FsbGRhdGEsXG4gICAgICAgICAgICBleHBpcnk6IGpvYi5leHBpcnksXG4gICAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgICAgc3VibWlzc2lvblR5cGU6IFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25UeXBlLlRyYWRlLFxuICAgICAgICAgICAgb25TdWJtaXNzaW9uQ29udGV4dFN0YXR1c1VwZGF0ZTogdGhpcy5fZ2V0T25TdWJtaXNzaW9uQ29udGV4dFN0YXR1c1VwZGF0ZUNhbGxiYWNrKFxuICAgICAgICAgICAgICAgIGpvYixcbiAgICAgICAgICAgICAgICBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZS5UcmFkZSxcbiAgICAgICAgICAgICksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gcHJlbGltaW5hcnkgY2hlY2tzIG9uIGEgam9iIGJlZm9yZSBwcm9jZXNzaW5nLlxuICAgICAqXG4gICAgICogVGhlIG1ldGhvZCB3b3VsZDpcbiAgICAgKiAxLiBDYWxsIGBSZnFtU2VydmljZS52YWxpZGF0ZVJmcW1WMkpvYmAgLyBgUmZxbVNlcnZpY2UudmFsaWRhdGVNZXRhVHJhbnNhY3Rpb25Kb2JgIGFuZCBjaGVjayByZXN1bHQuIElmIHRoZXJlIGlzIGFuIGVycm9yLCB1cGRhdGUgdGhlIGpvYiBzdGF0dXMgYW5kIHRocm93IGV4Y2VwdGlvblxuICAgICAqIDIuIE1ha2Ugc3VyZSBqb2IudGFrZXJTaWduYXR1cmUgaXMgcHJlc2VudCBvciB0aHJvdyBleGNlcHRpb25cbiAgICAgKiAzLiBVcGRhdGUgam9iIHN0YXR1cyB0byBgUGVuZGluZ1Byb2Nlc3NpbmdgIGlmIGN1cnJlbnQgc3RhdHVzIGlzIGBQZW5kaW5nRW5xdWV1ZWRgXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGNoZWNrSm9iUHJlcHJvY2Vzc2luZ0FzeW5jKFxuICAgICAgICBqb2I6IFJmcW1WMkpvYkVudGl0eSB8IE1ldGFUcmFuc2FjdGlvbkpvYkVudGl0eSxcbiAgICAgICAgbm93OiBEYXRlID0gbmV3IERhdGUoKSxcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgeyBraW5kLCB0YWtlclNpZ25hdHVyZSB9ID0gam9iO1xuICAgICAgICBsZXQgaWRlbnRpZmllcjtcbiAgICAgICAgbGV0IGVycm9yU3RhdHVzO1xuXG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAncmZxbV92Ml9qb2InOlxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBqb2Iub3JkZXJIYXNoO1xuICAgICAgICAgICAgICAgIGVycm9yU3RhdHVzID0gV29ya2VyU2VydmljZS52YWxpZGF0ZVJmcW1WMkpvYihqb2IsIG5vdyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZXRhX3RyYW5zYWN0aW9uX2pvYic6XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IGpvYi5pZDtcbiAgICAgICAgICAgICAgICBlcnJvclN0YXR1cyA9IFdvcmtlclNlcnZpY2UudmFsaWRhdGVNZXRhVHJhbnNhY3Rpb25Kb2Ioam9iLCBub3cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAoKF94OiBuZXZlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG4gICAgICAgICAgICAgICAgfSkoa2luZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3JTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGpvYi5zdGF0dXMgPSBlcnJvclN0YXR1cztcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbUpvYkFzeW5jKGpvYik7XG5cbiAgICAgICAgICAgIGlmIChlcnJvclN0YXR1cyA9PT0gUmZxbUpvYlN0YXR1cy5GYWlsZWRFeHBpcmVkKSB7XG4gICAgICAgICAgICAgICAgUkZRTV9TSUdORURfUVVPVEVfRVhQSVJZX1RPT19TT09OLmxhYmVscyh0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLmluYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKHsga2luZCwgaWRlbnRpZmllciwgZXJyb3JTdGF0dXMgfSwgJ0pvYiBmYWlsZWQgdmFsaWRhdGlvbicpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKb2IgZmFpbGVkIHZhbGlkYXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4aXN0ZW5jZSBvZiB0YWtlciBzaWduYXR1cmUgaGFzIGFscmVhZHkgYmVlbiBjaGVja2VkIGJ5XG4gICAgICAgIC8vIGBSZnFtU2VydmljZS52YWxpZGF0ZUpvYihqb2IpYC4gUmVmaW5lIHRoZSB0eXBlLlxuICAgICAgICBpZiAoIXRha2VyU2lnbmF0dXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRha2VyIHNpZ25hdHVyZSBwcmVzZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoam9iLnN0YXR1cyA9PT0gUmZxbUpvYlN0YXR1cy5QZW5kaW5nRW5xdWV1ZWQpIHtcbiAgICAgICAgICAgIGpvYi5zdGF0dXMgPSBSZnFtSm9iU3RhdHVzLlBlbmRpbmdQcm9jZXNzaW5nO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGJVdGlscy51cGRhdGVSZnFtSm9iQXN5bmMoam9iKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGEgcmZxbSB2MiAvIG1ldGEtdHJhbnNhY3Rpb24gam9iIGZvciBhcHByb3ZhbCBzdWJtaXNzaW9uIGJ5IHZhbGlkYXRpZGF0aW5nIHRoZSBqb2IgYW5kIGNvbnN0cnVjdGluZ1xuICAgICAqIHRoZSBjYWxsZGF0YS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBgam9iLnN0YXR1c2Agd291bGQgYmUgbW9kaWZpZWQgdG8gYEZhaWxlZEV0aENhbGxGYWlsZWRgIGlmIHRyYW5zYWN0aW9uIHNpbXVsYXRpb24gZmFpbGVkLlxuICAgICAqXG4gICAgICogSGFuZGxlcyByZXRyaWVzIG9mIHJldHJ5YWJsZSBlcnJvcnMuIFRocm93cyBmb3IgdW5yZXRyaWFibGUgZXJyb3JzLiBVcGRhdGVzIGpvYiBpbiBkYXRhYmFzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgY2FsbGRhdGEgZm9yIGFwcHJvdmFsIHN1Ym1pc3Npb24gdHlwZS5cbiAgICAgKiBAdGhyb3dzIElmIHRoZSBhcHByb3ZhbCBjYW5ub3QgYmUgc3VibWl0dGVkIChlLmcuIGl0IGlzIGV4cGlyZWQpLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBwcmVwYXJlQXBwcm92YWxBc3luYyhcbiAgICAgICAgam9iOiBSZnFtVjJKb2JFbnRpdHkgfCBNZXRhVHJhbnNhY3Rpb25Kb2JFbnRpdHksXG4gICAgICAgIHRva2VuVG9BcHByb3ZlOiBzdHJpbmcsXG4gICAgICAgIGFwcHJvdmFsOiBBcHByb3ZhbCxcbiAgICAgICAgc2lnYW5hdHVyZTogU2lnbmF0dXJlLFxuICAgICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHsga2luZCB9ID0gam9iO1xuICAgICAgICBjb25zdCBjYWxsZGF0YSA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZW5lcmF0ZUFwcHJvdmFsQ2FsbGRhdGFBc3luYyhcbiAgICAgICAgICAgIHRva2VuVG9BcHByb3ZlLFxuICAgICAgICAgICAgYXBwcm92YWwsXG4gICAgICAgICAgICBzaWdhbmF0dXJlLFxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBpZGVudGlmaWVyO1xuICAgICAgICBsZXQgdHJhbnNhY3Rpb25TdWJtaXNzaW9ucztcbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYWxyZWFkeSBzdWJtaXR0ZWQgYW4gYXBwcm92YWwgdHJhbnNhY3Rpb24gZm9yIHRoaXMgam9iLiBJZiB3ZSBoYXZlLCB0aGUgam9iIGhhcyBhbHJlYWR5XG4gICAgICAgIC8vIGJlZW4gY2hlY2tlZCBhbmQgd2UgY2FuIHNraXAgYGV0aF9jYWxsYCB2YWxpZGF0aW9uLlxuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JmcW1fdjJfam9iJzpcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gam9iLm9yZGVySGFzaDtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblN1Ym1pc3Npb25zID0gYXdhaXQgdGhpcy5fZGJVdGlscy5maW5kVjJUcmFuc2FjdGlvblN1Ym1pc3Npb25zQnlPcmRlckhhc2hBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblR5cGUuQXBwcm92YWwsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21ldGFfdHJhbnNhY3Rpb25fam9iJzpcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gam9iLmlkO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3VibWlzc2lvbnMgPSBhd2FpdCB0aGlzLl9kYlV0aWxzLmZpbmRNZXRhVHJhbnNhY3Rpb25TdWJtaXNzaW9uc0J5Sm9iSWRBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblR5cGUuQXBwcm92YWwsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgKChfeDogbmV2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xuICAgICAgICAgICAgICAgIH0pKGtpbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uU3VibWlzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWpvYi50YWtlclNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb3VudGVyZWQgYSBqb2Igd2l0aCBzdWJtaXNzaW9ucyBidXQgbm8gdGFrZXIgc2lnbmF0dXJlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoam9iLmtpbmQgPT09ICdyZnFtX3YyX2pvYicgJiYgIWpvYi5tYWtlclNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb3VudGVyZWQgYSBqb2Igd2l0aCBzdWJtaXNzaW9ucyBidXQgbm8gbWFrZXIgc2lnbmF0dXJlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYWxsZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbXVsYXRlIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgcmV0cnkoXG4gICAgICAgICAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYGVzdGltYXRlR2FzRm9yQXN5bmNgIHRvIHNpbXVsYXRlIHRoZSB0cmFuc2FjdGlvbi4gSW4gZXRoZXJzLmpzLCBwcm92aWRlci5jYWxsIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBwcm92aWRlci5zZW5kKCdldGhfY2FsbCcsIC4uLikgbWlnaHQgbm90IHRocm93IGV4Y2VwdGlvbiBhbmQgdGhlIGJlaGF2aW9yIG1pZ2h0IGJlIGRlcGVuZGVudFxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBwcm92aWRlcnMuIFJldmlzaXQgdGhpcyBsYXRlclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2tjaGFpblV0aWxzLmVzdGltYXRlR2FzRm9yQXN5bmMoeyB0bzogdG9rZW5Ub0FwcHJvdmUsIGRhdGE6IGNhbGxkYXRhIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkZWxheTogT05FX1NFQ09ORF9NUyxcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yOiAxLFxuICAgICAgICAgICAgICAgICAgICBtYXhBdHRlbXB0czogMyxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3I6IChlcnJvciwgY29udGV4dCwgX29wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYXR0ZW1wdE51bTogYXR0ZW1wdE51bWJlciwgYXR0ZW1wdHNSZW1haW5pbmcgfSA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGtpbmQsIGF0dGVtcHROdW1iZXIsIGF0dGVtcHRzUmVtYWluaW5nLCBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsIHN0YWNrOiBlcnJvci5zdGFjayB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdFcnJvciBkdXJpbmcgZXRoX2NhbGwgYXBwcm92YWwgdmFsaWRhdGlvbi4gUmV0cnlpbmcuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBqb2Iuc3RhdHVzID0gUmZxbUpvYlN0YXR1cy5GYWlsZWRFdGhDYWxsRmFpbGVkO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGJVdGlscy51cGRhdGVSZnFtSm9iQXN5bmMoam9iKTtcblxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgIHsga2luZCwgaWRlbnRpZmllciwgZXJyb3JNZXNzYWdlOiBlcnJvci5tZXNzYWdlLCBzdGFjazogZXJyb3Iuc3RhY2sgfSxcbiAgICAgICAgICAgICAgICAnZXRoX2NhbGwgYXBwcm92YWwgdmFsaWRhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXRoIGNhbGwgYXBwcm92YWwgdmFsaWRhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyBhbiBSZnFtVjIgSm9iIGZvciB0cmFkZSBzdWJtaXNzaW9uIGJ5IHZhbGlkYXRpZGF0aW5nIHRoZSBqb2IsIG9idGFpbmluZyB0aGVcbiAgICAgKiBtYXJrZXQgbWFrZXIgc2lnbmF0dXJlLCBhbmQgY29uc3RydWN0aW5nIHRoZSBjYWxsZGF0YS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBgam9iLnN0YXR1c2Agd291bGQgYmUgbW9kaWZpZWQgdG8gY29ycmVzcG9uZGluZyBzdGF0dXMuIEZvciBleGFtcGxlLCBpZiBtYWtlciBzaWduYXR1cmVcbiAgICAgKiBpcyBub3QgdmFsaWQsIGBqb2Iuc3RhdHVzYCB3b3VsZCBiZSBzZXQgdG8gYEZhaWxlZFNpZ25GYWlsZWRgLlxuICAgICAqXG4gICAgICogYHNob3VsZENoZWNrTGFzdExvb2tgIGRldGVybWluZXMgaWYgdGhlIHByZWxpbWluYXJ5IGpvYiBjaGVjayBhbmQgZ2V0dGluZyBtYXJrZXQgbWFrZXIgc2lnYXR1cmVcbiAgICAgKiB3b3VsZCBiZSBwZXJmb3JtZWQgYW5kIGlzIGRlZmF1bHQgdG8gYHRydWVgLlxuICAgICAqXG4gICAgICogSGFuZGxlcyByZXRyaWVzIG9mIHJldHJ5YWJsZSBlcnJvcnMuIFRocm93cyBmb3IgdW5yZXRyaWFibGUgZXJyb3JzLCBhbmQgbG9nc1xuICAgICAqIE9OTFkgSUYgdGhlIGxvZyBuZWVkcyBtb3JlIGluZm9ybWF0aW9uIHRoYW4gdGhlIG9yZGVySGFzaCBhbmQgd29ya2VyQWRkcmVzcyxcbiAgICAgKiB3aGljaCBhcmUgbG9nZ2VkIGJ5IHRoZSBgcHJvY2Vzc0pvYkFzeW5jYCByb3V0aW5lLlxuICAgICAqIFVwZGF0ZXMgam9iIGluIGRhdGFiYXNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBjYWxsZGF0YSBmb3IgdHJhZGUgc3VibWlzc2lvbiB0eXBlLlxuICAgICAqIEB0aHJvd3MgSWYgdGhlIHRyYWRlIGNhbm5vdCBiZSBzdWJtaXR0ZWQgKGUuZy4gaXQgaXMgZXhwaXJlZCkuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIHByZXBhcmVyZnFtVjJUcmFkZUFzeW5jKFxuICAgICAgICBqb2I6IFJmcW1WMkpvYkVudGl0eSxcbiAgICAgICAgd29ya2VyQWRkcmVzczogc3RyaW5nLFxuICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8taW5mZXJyYWJsZS10eXBlc1xuICAgICAgICBzaG91bGRDaGVja0xhc3RMb29rOiBib29sZWFuID0gdHJ1ZSxcbiAgICAgICAgbm93OiBEYXRlID0gbmV3IERhdGUoKSxcbiAgICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQXNrOiBUaGlzIGlzIHRoZSBwcm9iYWJseSB0aGUgb25seSBjaGFuZ2UgSSBtYWRlIHRvIHRoZSBvbGQgdHJhZGUgb25seSB3b3JrZmxvdy4gVG8gY2hhbmdlIGZyb20gbWFraW5nIGEgY29weSBvZiBwYXJhbWV0ZXJcbiAgICAgICAgICogYW5kIHRoZW4gcmV0dXJuaW5nIHRoZSBjb3BpZWQgdmFsdWUgdG8gY2hhbmdlIHBhcmFtZXRlciB2YWx1ZSBkaXJlY3RseS4gVGhlIHJhdGlvbmFsZSBiZWhpbmQgaXMgdG8gbWFrZSB0aGUgc3R5bGUgY29uc2lzdGVudFxuICAgICAgICAgKiB3aXRoIHRoZSBuZXcgZ2VuZXJhbGl6ZWQgYHN1Ym1pdFRvQ2hhaW5Bc3luY2AgKGl0IGhhcyB0byB1c2UgY2hhbmdpbmcgcGFyYW1ldGVyIHZhbHVlIHBhcmFkaWdtIGluIG9yZGVyIHRvIHdvcmspLiBMZXQgbWUga25vd1xuICAgICAgICAgKiBpZiB5b3UgZG9uJ3QgbGlrZSB0aGlzIGNoYW5nZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHsgbWFrZXJVcmksIG9yZGVyLCBvcmRlckhhc2ggfSA9IGpvYjtcbiAgICAgICAgY29uc3Qgb3RjT3JkZXIgPSBzdG9yZWRPdGNPcmRlclRvT3RjT3JkZXIob3JkZXIpO1xuXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGFscmVhZHkgc3VibWl0dGVkIGEgdHJhbnNhY3Rpb24gZm9yIHRoaXMgam9iLlxuICAgICAgICAvLyBJZiB3ZSBoYXZlLCB0aGUgam9iIGlzIGFscmVhZHkgcHJlcGFyZWQgYW5kIHdlIGNhbiBza2lwIGFoZWFkLlxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvblN1Ym1pc3Npb25zID0gYXdhaXQgdGhpcy5fZGJVdGlscy5maW5kVjJUcmFuc2FjdGlvblN1Ym1pc3Npb25zQnlPcmRlckhhc2hBc3luYyhqb2Iub3JkZXJIYXNoKTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uU3VibWlzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWpvYi5tYWtlclNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb3VudGVyZWQgYSBqb2Igd2l0aCBzdWJtaXNzaW9ucyBidXQgbm8gbWFrZXIgc2lnbmF0dXJlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWpvYi50YWtlclNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb3VudGVyZWQgYSBqb2Igd2l0aCBzdWJtaXNzaW9ucyBidXQgbm8gdGFrZXIgc2lnbmF0dXJlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1N1Ym1pc3Npb25DYWxsZGF0YSA9IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZW5lcmF0ZVRha2VyU2lnbmVkT3RjT3JkZXJDYWxsRGF0YShcbiAgICAgICAgICAgICAgICBvdGNPcmRlcixcbiAgICAgICAgICAgICAgICBqb2IubWFrZXJTaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgam9iLnRha2VyU2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIGpvYi5pc1Vud3JhcCxcbiAgICAgICAgICAgICAgICBqb2IuYWZmaWxpYXRlQWRkcmVzcyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdTdWJtaXNzaW9uQ2FsbGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkQ2hlY2tMYXN0TG9vaykge1xuICAgICAgICAgICAgLy8gUGVyZm9ybSB0aGUgcHJlbGltaW5hcnkgam9iIGNoZWNrIGFuZCBnZXR0aW5nIG1hcmtldCBtYWtlciBzaWdhdHVyZVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGVja0pvYlByZXByb2Nlc3NpbmdBc3luYyhqb2IsIG5vdyk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNoZWNrTGFzdExvb2tBc3luYyhqb2IsIHdvcmtlckFkZHJlc3MsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZXIgc2lnbmF0dXJlIG11c3QgYWxyZWFkeSBiZSBkZWZpbmVkIGhlcmUgLS0gcmVmaW5lIHRoZSB0eXBlXG4gICAgICAgIGlmICgham9iLm1ha2VyU2lnbmF0dXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ha2VyIHNpZ25hdHVyZSBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRha2VyIHNpZ25hdHVyZSBtdXN0IGFscmVhZHkgYmUgZGVmaW5lZCBoZXJlIC0tIHJlZmluZSB0aGUgdHlwZVxuICAgICAgICBpZiAoIWpvYi50YWtlclNpZ25hdHVyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWtlciBzaWduYXR1cmUgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcmlmeSB0aGUgc2lnbmVyIHdhcyB0aGUgbWFrZXJcbiAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCBzaWduZXJBZGRyZXNzID0gZ2V0U2lnbmVyRnJvbUhhc2gob3JkZXJIYXNoLCBqb2IubWFrZXJTaWduYXR1cmUhKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBtYWtlckFkZHJlc3MgPSBvcmRlci5vcmRlci5tYWtlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc2lnbmVyQWRkcmVzcyAhPT0gbWFrZXJBZGRyZXNzKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyh7IHNpZ25lckFkZHJlc3MsIG1ha2VyQWRkcmVzcywgb3JkZXJIYXNoLCBtYWtlclVyaSB9LCAnUG9zc2libGUgdXNlIG9mIHNtYXJ0IGNvbnRyYWN0IHdhbGxldCcpO1xuICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNpZ25lciA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5pc1ZhbGlkT3JkZXJTaWduZXJBc3luYyhtYWtlckFkZHJlc3MsIHNpZ25lckFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkU2lnbmVyKSB7XG4gICAgICAgICAgICAgICAgam9iLnN0YXR1cyA9IFJmcW1Kb2JTdGF0dXMuRmFpbGVkU2lnbkZhaWxlZDtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9kYlV0aWxzLnVwZGF0ZVJmcW1Kb2JBc3luYyhqb2IpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvcmRlciBzaWduZXIgYWRkcmVzcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIGNhbGxkYXRhXG4gICAgICAgIGNvbnN0IGNhbGxkYXRhID0gdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdlbmVyYXRlVGFrZXJTaWduZWRPdGNPcmRlckNhbGxEYXRhKFxuICAgICAgICAgICAgb3RjT3JkZXIsXG4gICAgICAgICAgICBqb2IubWFrZXJTaWduYXR1cmUsXG4gICAgICAgICAgICBqb2IudGFrZXJTaWduYXR1cmUsXG4gICAgICAgICAgICBqb2IuaXNVbndyYXAsXG4gICAgICAgICAgICBqb2IuYWZmaWxpYXRlQWRkcmVzcyxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBXaXRoIHRoZSBNYXJrZXQgTWFrZXIgc2lnbmF0dXJlLCBleGVjdXRlIGEgZnVsbCBldGhfY2FsbCB0byB2YWxpZGF0ZSB0aGVcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gdmlhIGBlc3RpbWF0ZUdhc0ZvckZpbGxUYWtlclNpZ25lZE90Y09yZGVyQXN5bmNgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2VyIHNpZ25hdHVyZSBtdXN0IGFscmVhZHkgYmUgZGVmaW5lZCBoZXJlIC0tIHJlZmluZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWpvYi5tYWtlclNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWtlciBzaWduYXR1cmUgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUYWtlciBzaWduYXR1cmUgbXVzdCBhbHJlYWR5IGJlIGRlZmluZWQgaGVyZSAtLSByZWZpbmUgdGhlIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqb2IudGFrZXJTaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFrZXIgc2lnbmF0dXJlIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2tjaGFpblV0aWxzLmVzdGltYXRlR2FzRm9yRmlsbFRha2VyU2lnbmVkT3RjT3JkZXJBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIG90Y09yZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgam9iLm1ha2VyU2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgam9iLnRha2VyU2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvYi5pc1Vud3JhcCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXk6IE9ORV9TRUNPTkRfTVMsXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcjogMSxcbiAgICAgICAgICAgICAgICAgICAgbWF4QXR0ZW1wdHM6IDMsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yOiAoZXJyb3IsIGNvbnRleHQsIF9vcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGF0dGVtcHROdW06IGF0dGVtcHROdW1iZXIsIGF0dGVtcHRzUmVtYWluaW5nIH0gPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBvcmRlckhhc2gsIG1ha2VyVXJpLCBhdHRlbXB0TnVtYmVyLCBhdHRlbXB0c1JlbWFpbmluZywgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRXJyb3IgZHVyaW5nIGV0aF9jYWxsIHZhbGlkYXRpb24gd2hlbiBwcmVwYXJpbmcgb3RjIG9yZGVyIHRyYWRlLiBSZXRyeWluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgam9iLnN0YXR1cyA9IFJmcW1Kb2JTdGF0dXMuRmFpbGVkRXRoQ2FsbEZhaWxlZDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbUpvYkFzeW5jKGpvYik7XG5cbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICB7IG9yZGVySGFzaCwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSxcbiAgICAgICAgICAgICAgICAnZXRoX2NhbGwgdmFsaWRhdGlvbiBmYWlsZWQgd2hlbiBwcmVwYXJpbmcgb3RjIG9yZGVyIHRyYWRlJyxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ2F0aGVyIGV4dHJhIGNvbnRleHQgdXBvbiBldGhfY2FsbCBmYWlsdXJlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFttYWtlckJhbGFuY2VdID0gYXdhaXQgdGhpcy5fcmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlLmdldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICB7IG93bmVyOiBvdGNPcmRlci5tYWtlciwgdG9rZW46IG90Y09yZGVyLm1ha2VyVG9rZW4gfSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt0YWtlckJhbGFuY2VdID0gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBvd25lcjogb3RjT3JkZXIudGFrZXIsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBvdGNPcmRlci50YWtlclRva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldEN1cnJlbnRCbG9ja0FzeW5jKCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VyQmFsYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRha2VyQmFsYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlckhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogb3RjT3JkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBidWNrZXQ6IG90Y09yZGVyLm5vbmNlQnVja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9uY2U6IG90Y09yZGVyLm5vbmNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnRXh0cmEgY29udGV4dCBhZnRlciBldGhfY2FsbCB2YWxpZGF0aW9uIGZhaWxlZCB3aGVuIHByZXBhcmluZyBvdGMgb3JkZXIgdHJhZGUnLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICAgICAgICB7IG9yZGVySGFzaCB9LFxuICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIGdldCBleHRyYSBjb250ZXh0IGFmdGVyIGV0aF9jYWxsIHZhbGlkYXRpb24gZmFpbGVkIHdoZW4gcHJlcGFyaW5nIG90YyBvcmRlciB0cmFkZScsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXRoIGNhbGwgdmFsaWRhdGlvbiBmYWlsZWQgd2hlbiBwcmVwYXJpbmcgb3RjIG9yZGVyIHRyYWRlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgYSBtZXRhLXRyYW5zYWN0aW9uIGpvYiBmb3IgdHJhZGUgc3VibWlzc2lvbiBieSB2YWxpZGF0aWRhdGluZyB0aGUgam9iIGFuZCBjb25zdHJ1Y3RpbmcgdGhlIGNhbGxkYXRhLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGBqb2Iuc3RhdHVzYCB3b3VsZCBiZSBtb2RpZmllZCB0byBjb3JyZXNwb25kaW5nIHN0YXR1cy4gRm9yIGV4YW1wbGUsIGlmIHRoZSBtZXRhLXRyYW5zYWN0aW9uIGV4cGlyZXMsXG4gICAgICogYGpvYi5zdGF0dXNgIHdvdWxkIGJlIHNldCB0byBgRmFpbGVkRmFpbGVkRXhwaXJlZGAuXG4gICAgICpcbiAgICAgKiBIYW5kbGVzIHJldHJpZXMgb2YgcmV0cnlhYmxlIGVycm9ycy4gVGhyb3dzIGZvciB1bnJldHJpYWJsZSBlcnJvcnMsIGFuZCBsb2dzXG4gICAgICogT05MWSBJRiB0aGUgbG9nIG5lZWRzIG1vcmUgaW5mb3JtYXRpb24gdGhhbiB0aGUgb3JkZXJIYXNoIGFuZCB3b3JrZXJBZGRyZXNzLFxuICAgICAqIHdoaWNoIGFyZSBsb2dnZWQgYnkgdGhlIGBwcm9jZXNzSm9iQXN5bmNgIHJvdXRpbmUuXG4gICAgICogVXBkYXRlcyBqb2IgaW4gZGF0YWJhc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIGNhbGxkYXRhIGZvciB0cmFkZSBzdWJtaXNzaW9uIHR5cGUuXG4gICAgICogQHRocm93cyBJZiB0aGUgdHJhZGUgY2Fubm90IGJlIHN1Ym1pdHRlZCAoZS5nLiBpdCBpcyBleHBpcmVkKS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgcHJlcGFyZU1ldGFUcmFuc2FjdGlvblRyYWRlQXN5bmMoXG4gICAgICAgIGpvYjogTWV0YVRyYW5zYWN0aW9uSm9iRW50aXR5LFxuICAgICAgICB3b3JrZXJBZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1pbmZlcnJhYmxlLXR5cGVzXG4gICAgICAgIHNob3VsZFZhbGlkYXRlSm9iOiBib29sZWFuID0gdHJ1ZSxcbiAgICAgICAgbm93OiBEYXRlID0gbmV3IERhdGUoKSxcbiAgICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICAvLyBBU0s6IFdoYXQncyB0aGUgZGlmZmVyZW5jZSBiZXd0d2VlbiBgbWV0YVRyYW5zYWN0aW9uLnNpZ25lcmAgdnMgYG1ldGFUcmFuc2FjdGlvbi5zZW5kZXJgP1xuICAgICAgICAvLyAgICAgIFdoaWNoIG9uZSBpcyB0aGUgdGFrZXIgYWRkcmVzcz9cbiAgICAgICAgY29uc3QgeyBhZmZpbGlhdGVBZGRyZXNzLCBpZDogam9iSWQsIGlucHV0VG9rZW4sIG1ldGFUcmFuc2FjdGlvbiwgdGFrZXJBZGRyZXNzLCB0YWtlclNpZ25hdHVyZSB9ID0gam9iO1xuXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGFscmVhZHkgc3VibWl0dGVkIGEgdHJhbnNhY3Rpb24gZm9yIHRoaXMgam9iLlxuICAgICAgICAvLyBJZiB3ZSBoYXZlLCB0aGUgam9iIGlzIGFscmVhZHkgcHJlcGFyZWQgYW5kIHdlIGNhbiBza2lwIGFoZWFkLlxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvblN1Ym1pc3Npb25zID0gYXdhaXQgdGhpcy5fZGJVdGlscy5maW5kTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbnNCeUpvYklkQXN5bmMoam9iSWQpO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25TdWJtaXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghdGFrZXJTaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIGEgam9iIHdpdGggc3VibWlzc2lvbnMgYnV0IG5vIHRha2VyIHNpZ25hdHVyZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTdWJtaXNzaW9uQ2FsbGRhdGEgPSB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb25DYWxsRGF0YShcbiAgICAgICAgICAgICAgICBtZXRhVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgdGFrZXJTaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgYWZmaWxpYXRlQWRkcmVzcyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdTdWJtaXNzaW9uQ2FsbGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkVmFsaWRhdGVKb2IpIHtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIHByZWxpbWluYXJ5IGpvYiBjaGVja1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGVja0pvYlByZXByb2Nlc3NpbmdBc3luYyhqb2IsIG5vdyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUYWtlciBzaWduYXR1cmUgbXVzdCBhbHJlYWR5IGJlIGRlZmluZWQgaGVyZSAtLSByZWZpbmUgdGhlIHR5cGVcbiAgICAgICAgaWYgKCF0YWtlclNpZ25hdHVyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWtlciBzaWduYXR1cmUgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSBjYWxsZGF0YVxuICAgICAgICBjb25zdCBjYWxsZGF0YSA9IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZW5lcmF0ZU1ldGFUcmFuc2FjdGlvbkNhbGxEYXRhKFxuICAgICAgICAgICAgbWV0YVRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgdGFrZXJTaWduYXR1cmUsXG4gICAgICAgICAgICBhZmZpbGlhdGVBZGRyZXNzLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGV4ZWN1dGUgYSBmdWxsIGV0aF9jYWxsIHRvIHZhbGlkYXRlIHRoZVxuICAgICAgICAvLyB0cmFuc2FjdGlvbiB2aWEgYGVzdGltYXRlR2FzRm9yQXN5bmNgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZ2FzIGZlZSBvcGVyYXRpb25zIGFyZSBhZGRlZCBiZWNhdXNlIGBleGVjdXRlTWV0YVRyYW5zYWN0aW9uYCBpbiAweCBFeGNoYW5nZSBQcm94eVxuICAgICAgICAgICAgICAgICAgICAvLyB3b3VsZCBjaGVjayB3aGV0aGVyIHRoZSBnYXMgcHJpY2Ugb2YgdGhlIHRyYW5zYWN0aW9uIGlzIHdpdGhpbiBhIHdpbmRvdy4gSWYgbGVmdCBlbXB0eSwgaXQgd2lsbFxuICAgICAgICAgICAgICAgICAgICAvLyBmYWlsIHRoZSBzaW11bGF0aW9uLiBUaGUgZ2FzIGZlZSBlc3RpbWF0aW9uIGJlbG93IGlzIHRoZSBzYW1lIGFzIHRoZSBmaXJzdCBnYXMgZmVlIGVzdGltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBpbiBgc3VibWl0VG9DaGFpbmAuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLl9nYXNTdGF0aW9uQXR0ZW5kYW50LmdldEV4cGVjdGVkVHJhbnNhY3Rpb25HYXNSYXRlQXN5bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbE1heFByaW9yaXR5RmVlUGVyR2FzID0gbmV3IEJpZ051bWJlcih0aGlzLl9pbml0aWFsTWF4UHJpb3JpdHlGZWVQZXJHYXNHd2VpKS50aW1lcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucG93KDEwLCBHV0VJX0RFQ0lNQUxTKSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2FzRmVlczogR2FzRmVlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEZlZVBlckdhczogQmlnTnVtYmVyLm1pbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXNQcmljZUVzdGltYXRlLm11bHRpcGxpZWRCeSgyKS5wbHVzKGluaXRpYWxNYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG1heCBmZWUgaXMgbGVzcyB0aGFuIHRoZSBiYXNlIGZlZSwgc2ltdWxhdGlvbnMgd2lsbCBmYWlsICh1bmxpa2Ugc3VibWlzc2lvbnMsIHdoaWNoIG1heSBzaXQgaW4gdGhlIG1lbXBvb2wpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIGV4dHJhIG11bHRpcGxpZXIgbWl0aWdhdGVzLCBidXQgZG9lcyBub3Qgc29sdmUsIHRoZSBpc3N1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXhGZWVQZXJHYXNDYXBXZWkubXVsdGlwbGllZEJ5KFNJTVVMQVRJT05fTUFYX0dBU19NVUxUSVBMSUVSKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogaW5pdGlhbE1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZXN0aW1hdGVHYXNGb3JBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB3b3JrZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZXRFeGNoYW5nZVByb3h5QWRkcmVzcygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY2FsbGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXM6IGdhc0ZlZXMubWF4RmVlUGVyR2FzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogZ2FzRmVlcy5tYXhQcmlvcml0eUZlZVBlckdhcy50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXk6IE9ORV9TRUNPTkRfTVMsXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcjogMSxcbiAgICAgICAgICAgICAgICAgICAgbWF4QXR0ZW1wdHM6IDMsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yOiAoZXJyb3IsIGNvbnRleHQsIF9vcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGF0dGVtcHROdW06IGF0dGVtcHROdW1iZXIsIGF0dGVtcHRzUmVtYWluaW5nIH0gPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBqb2JJZCwgYXR0ZW1wdE51bWJlciwgYXR0ZW1wdHNSZW1haW5pbmcsIGVycm9yOiBlcnJvci5tZXNzYWdlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Vycm9yIGR1cmluZyBldGhfY2FsbCB2YWxpZGF0aW9uIHdoZW4gcHJlcGFyaW5nIG1ldGEtdHJhbnNhY3Rpb24gdHJhZGUuIFJldHJ5aW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBqb2Iuc3RhdHVzID0gUmZxbUpvYlN0YXR1cy5GYWlsZWRFdGhDYWxsRmFpbGVkO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGJVdGlscy51cGRhdGVSZnFtSm9iQXN5bmMoam9iKTtcblxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgIHsgam9iSWQsIGVycm9yOiBlcnJvci5tZXNzYWdlIH0sXG4gICAgICAgICAgICAgICAgJ2V0aF9jYWxsIHZhbGlkYXRpb24gZmFpbGVkIHdoZW4gcHJlcGFyaW5nIG1ldGEtdHJhbnNhY3Rpb24gdHJhZGUnLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBnYXRoZXIgZXh0cmEgY29udGV4dCB1cG9uIGV0aF9jYWxsIGZhaWx1cmVcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3Rha2VyQmFsYW5jZV0gPSBhd2FpdCB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZ2V0TWluT2ZCYWxhbmNlc0FuZEFsbG93YW5jZXNBc3luYyhbXG4gICAgICAgICAgICAgICAgICAgIHsgb3duZXI6IHRha2VyQWRkcmVzcywgdG9rZW46IGlucHV0VG9rZW4gfSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZXRDdXJyZW50QmxvY2tBc3luYygpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWtlckJhbGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdFeHRyYSBjb250ZXh0IGFmdGVyIGV0aF9jYWxsIHZhbGlkYXRpb24gZmFpbGVkIHdoZW4gcHJlcGFyaW5nIG1ldGEtdHJhbnNhY3Rpb24gdHJhZGUnLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICAgICAgICB7IGpvYklkIH0sXG4gICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZ2V0IGV4dHJhIGNvbnRleHQgYWZ0ZXIgZXRoX2NhbGwgdmFsaWRhdGlvbiBmYWlsZWQgd2hlbiBwcmVwYXJpbmcgbWV0YS10cmFuc2FjdGlvbiB0cmFkZSAnLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aCBjYWxsIHZhbGlkYXRpb24gZmFpbGVkIHdoZW4gcHJlcGFyaW5nIG1ldGEtdHJhbnNhY3Rpb24gdHJhZGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBsYXN0IGxvb2sgYnkgZ2V0dGluZyBtYXJrZXQgbWFrZXIgc2lnbmF0dXJlLiBIYW5kbGVzIHJldHJpZXMgd2hlbiBtYWtpbmcgcmVxdWVzdCB0byBtYXJrZXQgbWFrZXIgc2VydmVycy5cbiAgICAgKlxuICAgICAqIFdoZW4gdmVyaWZ5aW5nIHRoZSBvcmRlciBpcyBmaWxsYWJsZSBieSBib3RoIHRoZSBtYWtlciBhbmQgdGhlIHRha2VyOlxuICAgICAqIC0gSWYgYHNob3VsZENoZWNrQWxsb3dhbmNlYCBpcyBmYWxzZSwgdGhlIG1ldGhvZCB3b3VsZCBvbmx5IGNoZWNrIGJhbGFuY2VzIGJ1dCBub3QgdGhlIGFsbG93YW5jZXMgdGhlIG1ha2VyIGFuZFxuICAgICAqICAgdGhlIHRha2VyIHNldCBmb3IgMHggZXhjaGFuZ2UgcHJveHkgYmVjYXVzZSB0aGUgdGFrZXIgYWxsb3dhbmNlIHdpbGwgbm90IGJlIHNldCB3aGVuIGBjaGVja0xhc3RMb29rQXN5bmNgIGlzIGNhbGxlZCBhcyB3ZVxuICAgICAqICAgd2FudCB0byBjYWxsIHRoaXMgbWV0aG9kIGFzIHNvb24gYXMgcG9zc2libGUgdG8gbWl0aWdhdGUgdGhlIGxhdGVuY3kgYnJvdWdodCBieSBzZXF1ZW50aWFsIHN1Ym1pc3Npb25zXG4gICAgICogICAod2hpY2ggd291bGQgbGVhZCB0byBoaWdoZXIgZGVjbGluZSB0byBzaWduIHJhdGUpLlxuICAgICAqIC0gT3RoZXJ3aXNlLCBib3RoIGJhbGFuY2VzIGFuZCBhbGxvd2FuY2VzIHdvdWxkIGJlIGNoZWNrZWQuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGNoZWNrTGFzdExvb2tBc3luYyhcbiAgICAgICAgam9iOiBSZnFtVjJKb2JFbnRpdHksXG4gICAgICAgIHdvcmtlckFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgc2hvdWxkQ2hlY2tBbGxvd2FuY2U6IGJvb2xlYW4sXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHsgbWFrZXJVcmksIG9yZGVyLCBvcmRlckhhc2gsIHRha2VyU2lnbmF0dXJlIH0gPSBqb2I7XG4gICAgICAgIGNvbnN0IG90Y09yZGVyID0gc3RvcmVkT3RjT3JkZXJUb090Y09yZGVyKG9yZGVyKTtcbiAgICAgICAgbGV0IHsgbWFrZXJTaWduYXR1cmUgfSA9IGpvYjtcblxuICAgICAgICBpZiAobWFrZXJTaWduYXR1cmUpIHtcbiAgICAgICAgICAgIC8vIE1hcmtldCBNYWtlciBoYWQgYWxyZWFkeSBzaWduZWQgb3JkZXJcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKHsgd29ya2VyQWRkcmVzcywgb3JkZXJIYXNoIH0sICdPcmRlciBhbHJlYWR5IHNpZ25lZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdmFsaWRhdGUgdGhhdCBvcmRlciBpcyBmaWxsYWJsZSBieSBib3RoIHRoZSBtYWtlciBhbmQgdGhlIHRha2VyIGFjY29yZGluZyB0byBiYWxhbmNlcyAoYW5kIGFsbG93YW5jZXNcbiAgICAgICAgICAgIC8vIHdoZW4gYHNob3VsZENoZWNrQWxsb3dhbmNlYCBpcyB0cnVlKVxuICAgICAgICAgICAgY29uc3QgW21ha2VyQmFsYW5jZV0gPSBhd2FpdCB0aGlzLl9yZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UuZ2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmModGhpcy5fY2hhaW5JZCwge1xuICAgICAgICAgICAgICAgIG93bmVyOiBvdGNPcmRlci5tYWtlcixcbiAgICAgICAgICAgICAgICB0b2tlbjogb3RjT3JkZXIubWFrZXJUb2tlbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgW3Rha2VyQmFsYW5jZV0gPSBzaG91bGRDaGVja0FsbG93YW5jZVxuICAgICAgICAgICAgICAgID8gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiBvdGNPcmRlci50YWtlcixcbiAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogb3RjT3JkZXIudGFrZXJUb2tlbixcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBhd2FpdCB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZ2V0VG9rZW5CYWxhbmNlc0FzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICBvd25lcjogb3RjT3JkZXIudGFrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW46IG90Y09yZGVyLnRha2VyVG9rZW4sXG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1ha2VyQmFsYW5jZS5sdChvdGNPcmRlci5tYWtlckFtb3VudCkgfHwgdGFrZXJCYWxhbmNlLmx0KG90Y09yZGVyLnRha2VyQW1vdW50KSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJIYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZXJCYWxhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFrZXJCYWxhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZXJBbW91bnQ6IG90Y09yZGVyLm1ha2VyQW1vdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFrZXJBbW91bnQ6IG90Y09yZGVyLnRha2VyQW1vdW50LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnT3JkZXIgZmFpbGVkIHByZS1zaWduIHZhbGlkYXRpb24nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgam9iLnN0YXR1cyA9IFJmcW1Kb2JTdGF0dXMuRmFpbGVkUHJlc2lnblZhbGlkYXRpb25GYWlsZWQ7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGJVdGlscy51cGRhdGVSZnFtSm9iQXN5bmMoam9iKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09yZGVyIGZhaWxlZCBwcmUtc2lnbiB2YWxpZGF0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGFrZXJTaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ09yZGVyIGZhaWxlZCBwcmUtc2lnbiB2YWxpZGF0aW9uIGR1ZSB0byBlbXB0eSB0YWtlclNpZ25hdHVyZScpO1xuICAgICAgICAgICAgICAgIGpvYi5zdGF0dXMgPSBSZnFtSm9iU3RhdHVzLkZhaWxlZFByZXNpZ25WYWxpZGF0aW9uRmFpbGVkO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbUpvYkFzeW5jKGpvYik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcmRlciBmYWlsZWQgcHJlLXNpZ24gdmFsaWRhdGlvbiBkdWUgdG8gZW1wdHkgdGFrZXJTaWduYXR1cmUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdHJhZGVyID0gZ2V0U2lnbmVyRnJvbUhhc2gob3JkZXJIYXNoLCB0YWtlclNpZ25hdHVyZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNpZ25SZXF1ZXN0OiBTaWduUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBleHBpcnk6IGpvYi5leHBpcnksXG4gICAgICAgICAgICAgICAgZmVlOiBzdG9yZWRGZWVUb0ZlZShqb2IuZmVlKSxcbiAgICAgICAgICAgICAgICBvcmRlcjogb3RjT3JkZXIsXG4gICAgICAgICAgICAgICAgb3JkZXJIYXNoLFxuICAgICAgICAgICAgICAgIHRha2VyU2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIHdvcmtmbG93OiAncmZxbScsXG4gICAgICAgICAgICAgICAgdHJhZGVyOiB0cmFkZXIsXG4gICAgICAgICAgICAgICAgLi4uKGpvYi50YWtlclNwZWNpZmllZFNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgVEFLRVJfU1BFQ0lGSUVEX1NJREVfRU5BQkxFRCAmJiB7IHRha2VyU3BlY2lmaWVkU2lkZTogam9iLnRha2VyU3BlY2lmaWVkU2lkZSB9KSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFwiTGFzdCBMb29rXCIgaW4gdjEgaXMgcmVwbGFjZWQgYnkgbWFya2V0IG1ha2VyIG9yZGVyIHNpZ25pbmcgaW4gdjIuXG4gICAgICAgICAgICBjb25zdCBzaWduQXR0ZW1wdFRpbWVNcyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1ha2VyU2lnbmF0dXJlID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jICgpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdW90ZVNlcnZlckNsaWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zaWduVjJBc3luYyhtYWtlclVyaSwgam9iLmludGVncmF0b3JJZCA/PyAnJywgc2lnblJlcXVlc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHMpID0+IHMgPz8gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiBPTkVfU0VDT05EX01TLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4QXR0ZW1wdHM6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcjogKGVycm9yLCBjb250ZXh0LCBfb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYXR0ZW1wdE51bTogYXR0ZW1wdE51bWJlciwgYXR0ZW1wdHNSZW1haW5pbmcgfSA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgb3JkZXJIYXNoLCBtYWtlclVyaSwgYXR0ZW1wdE51bWJlciwgYXR0ZW1wdHNSZW1haW5pbmcsIGVycm9yOiBlcnJvci5tZXNzYWdlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdFcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBhdHRlbXB0aW5nIHRvIGdldCBtYXJrZXQgbWFrZXIgc2lnbmF0dXJlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2lnbiBwcm9jZXNzIGhhcyBmYWlsZWQgYWZ0ZXIgcmV0cmllc1xuICAgICAgICAgICAgICAgIFJGUU1fSk9CX0ZBSUxFRF9NTV9TSUdOQVRVUkVfRkFJTEVELmxhYmVscyhtYWtlclVyaSwgdGhpcy5fY2hhaW5JZC50b1N0cmluZygpKS5pbmMoKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHsgb3JkZXJIYXNoLCBtYWtlclVyaSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSxcbiAgICAgICAgICAgICAgICAgICAgJ1JGUU0gdjIgam9iIGZhaWxlZCBkdWUgdG8gbWFya2V0IG1ha2VyIHNpZ24gZmFpbHVyZScsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBqb2Iuc3RhdHVzID0gUmZxbUpvYlN0YXR1cy5GYWlsZWRTaWduRmFpbGVkO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbUpvYkFzeW5jKGpvYik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKb2IgZmFpbGVkIGR1cmluZyBtYXJrZXQgbWFrZXIgc2lnbiBhdHRlbXB0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKHsgbWFrZXJVcmksIHNpZ25lZDogISFtYWtlclNpZ25hdHVyZSwgb3JkZXJIYXNoIH0sICdHb3Qgc2lnbmF0dXJlIHJlc3BvbnNlIGZyb20gbWFya2V0IG1ha2VyJyk7XG4gICAgICAgICAgICBpZiAoIW1ha2VyU2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFya2V0IE1ha2VyIGhhcyBkZWNsaW5lZCB0byBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIFJGUU1fSk9CX01NX1JFSkVDVEVEX0xBU1RfTE9PSy5sYWJlbHMobWFrZXJVcmksIHRoaXMuX2NoYWluSWQudG9TdHJpbmcoKSkuaW5jKCk7XG4gICAgICAgICAgICAgICAgam9iLmxhc3RMb29rUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgam9iLnN0YXR1cyA9IFJmcW1Kb2JTdGF0dXMuRmFpbGVkTGFzdExvb2tEZWNsaW5lZDtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9kYlV0aWxzLnVwZGF0ZVJmcW1Kb2JBc3luYyhqb2IpO1xuXG4gICAgICAgICAgICAgICAgaWYgKEVOQUJMRV9MTFJfQ09PTERPV04pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHF1b3RlID0gYXdhaXQgdGhpcy5fZGJVdGlscy5maW5kVjJRdW90ZUJ5T3JkZXJIYXNoQXN5bmMob3JkZXJIYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdW90ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgcXVvdGUgd2l0aCBvcmRlciBoYXNoICR7b3JkZXJIYXNofWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgYmFkYCBsYXN0IGxvb2sgcmVqZWN0aW9uLCByZWplY3RlZCB3aXRoaW4gdGhlIGNvb2xkb3duIHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25BdHRlbXB0VGltZU1zIC0gcXVvdGUuY3JlYXRlZEF0LnZhbHVlT2YoKSA8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTExSX0NPT0xET1dOX1dJTkRPV19TRUNPTkRTICogT05FX1NFQ09ORF9NU1xuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFrZXJJZCA9IHRoaXMuX3JmcU1ha2VyTWFuYWdlci5maW5kTWFrZXJJZFdpdGhSZnFtVXJpKG1ha2VyVXJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFrZXJJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIG1ha2VyIElEIHdpdGggUkZRbSBVUkkgJHttYWtlclVyaX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb29sZG93bkVuZFRpbWVNcyA9IHNpZ25BdHRlbXB0VGltZU1zICsgTExSX0NPT0xET1dOX0RVUkFUSU9OX1NFQ09ORFMgKiBPTkVfU0VDT05EX01TO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2NoZWR1bGUgY29vbGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1NjaGVkdWxlVXBkYXRlZCA9IGF3YWl0IHRoaXMuX2NhY2hlQ2xpZW50LmFkZE1ha2VyVG9Db29sZG93bkFzeW5jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29sZG93bkVuZFRpbWVNcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RjT3JkZXIubWFrZXJUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RjT3JkZXIudGFrZXJUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiB0aGlzLl9jaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZXJUb2tlbjogb3RjT3JkZXIubWFrZXJUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRha2VyVG9rZW46IG90Y09yZGVyLnRha2VyVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHNpZ25BdHRlbXB0VGltZU1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kVGltZTogY29vbGRvd25FbmRUaW1lTXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlckhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NjaGVkdWxlVXBkYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0xMUiBjb29sZG93biBzY2hlZHVsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgY29vbGRvd24gZW50cnkgdG8gZGIgZm9yIHJlY29yZCBrZWVwaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMud3JpdGVWMkxhc3RMb29rUmVqZWN0aW9uQ29vbGRvd25Bc3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RjT3JkZXIubWFrZXJUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90Y09yZGVyLnRha2VyVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShzaWduQXR0ZW1wdFRpbWVNcyksIC8vIHN0YXJ0VGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoY29vbGRvd25FbmRUaW1lTXMpLCAvLyBlbmRUaW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlckhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2Fybih7IG9yZGVySGFzaCwgZXJyb3JNZXNzYWdlOiBlLm1lc3NhZ2UgfSwgJ1NhdmluZyBMTFIgY29vbGRvd24gZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRW5jb3VudGVyZWQgZXJyb3Igd2hlbiBkZXRlY3RpbmcgYmFkIExMUiBhbmQgc2NoZWR1bGluZyBjb29sZG93bicsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UnZCBsaWtlIHNvbWUgZGF0YSBvbiBob3cgbXVjaCB0aGUgcHJpY2UgdGhlIG1hcmtldCBtYWtlciBpcyBvZmZlcmluZ1xuICAgICAgICAgICAgICAgIC8vIGhhcyBjaGFuZ2VkLiBXZSBxdWVyeSB0aGUgbWFya2V0IG1ha2VyJ3MgcHJpY2UgZW5kcG9pbnQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vIHRyYWRlIHRoZXkndmUganVzdCBkZWNsaW5lZCB0byBzaWduIGFuZCBsb2cgdGhlIHJlc3VsdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNsaW5lVG9TaWduUHJpY2VDaGVja1RpbWVNcyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG90Y09yZGVyUGFyYW1zID0gUXVvdGVTZXJ2ZXJDbGllbnQubWFrZVF1ZXJ5UGFyYW1ldGVycyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiB0aGlzLl9jaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHhPcmlnaW46IHRoaXMuX3JlZ2lzdHJ5QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRha2VyQWRkcmVzczogb3RjT3JkZXIudGFrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXRPcGVyYXRpb246IE1hcmtldE9wZXJhdGlvbi5TZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV5VG9rZW5BZGRyZXNzOiBvdGNPcmRlci5tYWtlclRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsbFRva2VuQWRkcmVzczogb3RjT3JkZXIudGFrZXJUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2V0RmlsbEFtb3VudDogb3RjT3JkZXIudGFrZXJBbW91bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0xhc3RMb29rOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmVlOiBzdG9yZWRGZWVUb0ZlZShqb2IuZmVlKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgYWRkaW5nIGEgZGVwZW5kZW5jeSB0byBgQ29uZmlnTWFuYWdlcmAgdG8gZ2V0IHRoZSBhY3R1YWwgaW50ZWdyYXRvclxuICAgICAgICAgICAgICAgICAgICAvLyAod2Ugb25seSBoYXZlIHRoZSBJRCBhdCB0aGlzIHBvaW50KSwganVzdCBjcmVhdGUgYSBzdGFuZC1pbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHNlbmQgdGhlIHNhbWUgaW50ZWdyYXRvciBJRCB0byB0aGUgbWFya2V0IG1ha2VyOyB0aGV5IHdpbGwgbm90IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFibGUgdG8gdGVsbCB0aGUgZGlmZmVyZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gYGxvZ1JmcU1ha2VyTmV0d29ya0ludGVyYWN0aW9uYCBkb2VzIHVzZSB0aGUgYGxhYmVsYCwgaG93ZXZlciwgYnV0IEkgdGhpbmsgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYWRlb2ZmIGlzIHJlYXNvbmFibGUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVncmF0b3I6IEludGVncmF0b3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlLZXlzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhdG9ySWQ6IGpvYi5pbnRlZ3JhdG9ySWQhLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZENoYWluSWRzOiBbdGhpcy5fY2hhaW5JZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ2RlY2xpbmUtdG8tc2lnbi1wcmljZS1jaGVjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbHA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZnFtOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmZxdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJpY2VSZXNwb25zZSA9IGF3YWl0IHRoaXMuX3F1b3RlU2VydmVyQ2xpZW50LmdldFByaWNlVjJBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvYi5tYWtlclVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVncmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGNPcmRlclBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICh1OiBzdHJpbmcpID0+IGAke3V9L3JmcW0vdjIvcHJpY2VgLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByaWNlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBhIHByaWNlIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBtYWtlckFtb3VudDogcHJpY2VDaGVja01ha2VyQW1vdW50LCB0YWtlckFtb3VudDogcHJpY2VDaGVja1Rha2VyQW1vdW50IH0gPSBwcmljZVJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFByaWNlID0gb3RjT3JkZXIubWFrZXJBbW91bnQuZGl2aWRlZEJ5KHByaWNlQ2hlY2tUYWtlckFtb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByaWNlQWZ0ZXJSZWplY3QgPSBwcmljZUNoZWNrTWFrZXJBbW91bnQuZGl2aWRlZEJ5KHByaWNlQ2hlY2tUYWtlckFtb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpcHNGYWN0b3IgPSAxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJpY2VEaWZmZXJlbmNlQmlwcyA9IG9yaWdpbmFsUHJpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5taW51cyhwcmljZUFmdGVyUmVqZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRpdmlkZWRCeShvcmlnaW5hbFByaWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFic29sdXRlVmFsdWUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRpbWVzKGJpcHNGYWN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9QcmVjaXNpb24oMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0aW1lLCBpbiBzZWNvbmRzLCBiZXR3ZWVuIHdoZW4gd2UgaW5pdGlhdGVkIHRoZSBzaWduIGF0dGVtcHQgYW5kIHdoZW4gd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhdGVkIHRoZSBwcmljZSBjaGVjayBhZnRlciB0aGUgbWFrZXIgZGVjbGluZWQgdG8gc2lnbi5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJpY2VDaGVja0RlbGF5UyA9IChkZWNsaW5lVG9TaWduUHJpY2VDaGVja1RpbWVNcyAtIHNpZ25BdHRlbXB0VGltZU1zKSAvIE9ORV9TRUNPTkRfTVM7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVySGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFByaWNlOiBvcmlnaW5hbFByaWNlLnRvTnVtYmVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2VBZnRlclJlamVjdDogcHJpY2VBZnRlclJlamVjdC50b051bWJlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlQ2hlY2tEZWxheVMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2VEaWZmZXJlbmNlQmlwcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnRGVjbGluZSB0byBzaWduIHByaWNlIGNoZWNrJyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvYi5sbFJlamVjdFByaWNlRGlmZmVyZW5jZUJwcyA9IHBhcnNlSW50KHByaWNlRGlmZmVyZW5jZUJpcHMsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbUpvYkFzeW5jKGpvYik7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKHsgb3JkZXJIYXNoLCBlcnJvck1lc3NhZ2U6IGUubWVzc2FnZSB9LCAnU2F2aW5nIExMIHJlamVjdCBwcmljZSBkaWZmZXJlbmNlIGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VuY291bnRlcmVkIGVycm9yIGR1cmluZyBkZWNsaW5lIHRvIHNpZ24gcHJpY2UgY2hlY2snLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hcmtldCBNYWtlciBkZWNsaW5lZCB0byBzaWduJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENlcnRhaW4gbWFya2V0IG1ha2VycyBhcmUgcmV0dXJuaW5nIHNpZ25hdHVyZSBjb21wb25lbnRzIHdoaWNoIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAvLyBsZWFkaW5nIGJ5dGVzLiBBZGQgdGhlbSBpZiB0aGV5IGRvbid0IGV4aXN0LlxuICAgICAgICAgICAgY29uc3QgcGFkZGVkU2lnbmF0dXJlID0gcGFkU2lnbmF0dXJlKG1ha2VyU2lnbmF0dXJlKTtcbiAgICAgICAgICAgIGlmIChwYWRkZWRTaWduYXR1cmUuciAhPT0gbWFrZXJTaWduYXR1cmUuciB8fCBwYWRkZWRTaWduYXR1cmUucyAhPT0gbWFrZXJTaWduYXR1cmUucykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICAgICAgICB7IG9yZGVySGFzaCwgcjogcGFkZGVkU2lnbmF0dXJlLnIsIHM6IHBhZGRlZFNpZ25hdHVyZS5zIH0sXG4gICAgICAgICAgICAgICAgICAgICdHb3QgbWFya2V0IG1ha2VyIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgYnl0ZXMnLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbWFrZXJTaWduYXR1cmUgPSBwYWRkZWRTaWduYXR1cmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGpvYi5tYWtlclNpZ25hdHVyZSA9IHBhZGRlZFNpZ25hdHVyZTtcbiAgICAgICAgICAgIGpvYi5sYXN0TG9va1Jlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICBqb2Iuc3RhdHVzID0gUmZxbUpvYlN0YXR1cy5QZW5kaW5nTGFzdExvb2tBY2NlcHRlZDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbUpvYkFzeW5jKGpvYik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlciBzaWduYXR1cmUgbXVzdCBhbHJlYWR5IGJlIGRlZmluZWQgaGVyZSAtLSByZWZpbmUgdGhlIHR5cGVcbiAgICAgICAgaWYgKCFtYWtlclNpZ25hdHVyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWtlciBzaWduYXR1cmUgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcmlmeSB0aGUgc2lnbmVyIHdhcyB0aGUgbWFrZXJcbiAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCBzaWduZXJBZGRyZXNzID0gZ2V0U2lnbmVyRnJvbUhhc2gob3JkZXJIYXNoLCBtYWtlclNpZ25hdHVyZSEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IG1ha2VyQWRkcmVzcyA9IG9yZGVyLm9yZGVyLm1ha2VyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzaWduZXJBZGRyZXNzICE9PSBtYWtlckFkZHJlc3MpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKHsgc2lnbmVyQWRkcmVzcywgbWFrZXJBZGRyZXNzLCBvcmRlckhhc2gsIG1ha2VyVXJpIH0sICdQb3NzaWJsZSB1c2Ugb2Ygc21hcnQgY29udHJhY3Qgd2FsbGV0Jyk7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkU2lnbmVyID0gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmlzVmFsaWRPcmRlclNpZ25lckFzeW5jKG1ha2VyQWRkcmVzcywgc2lnbmVyQWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRTaWduZXIpIHtcbiAgICAgICAgICAgICAgICBqb2Iuc3RhdHVzID0gUmZxbUpvYlN0YXR1cy5GYWlsZWRTaWduRmFpbGVkO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbUpvYkFzeW5jKGpvYik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9yZGVyIHNpZ25lciBhZGRyZXNzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJtaXRzIGEgc3BlY2lmaWMgdHlwZSBvZiBzdWJtaXNzaW9uIHRvIHRoZSBibG9ja2NoYWluLlxuICAgICAqXG4gICAgICogRmlyc3QgY2hlY2tzIHRvIHNlZSBpZiB0aGVyZSBhcmUgcHJldmlvdXMgdHJhbnNhY3Rpb25zIHdpdGggdGhlIHN1Ym1pc3Npb24gdHlwZSBhbmQgZW50ZXJzIHRoZVxuICAgICAqIHdhdGNoIGxvb3A7IGlmIG5vdCwgc3VibWl0cyBhbiBpbml0aWFsIHRyYW5zYWN0aW9uIGFuZCBlbnRlcnMgdGhlIHdhdGNoIGxvb3AuXG4gICAgICpcbiAgICAgKiBEdXJpbmcgdGhlIHdhdGNoIGxvb3AsIHdhaXRzIGZvciBhIHRyYW5zYWN0aW9uIHRvIGJlIG1pbmVkIGFuZCBjb25maXJtZWQ7XG4gICAgICogcmVwbGFjZXMgdGhlIHRyYW5zYWN0aW9uIGlmIGdhcyBwcmljZXMgcmlzZSB3aGlsZSBhIHRyYW5zYWN0aW9ucyBhcmUgaW4gdGhlIG1lbXBvb2wuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBPcHRpb25zIG9iamVjdCB0aGF0IGNvbnRhaW5zOlxuICAgICAqICAgICAgICAtIGB0b2A6IFRoZSBhZGRyZXNzIHRvIHNlbmQgdG8uXG4gICAgICogICAgICAgIC0gYGZyb21gOiBUaGUgYWRkcmVzcyBzdWJtaXR0aW5nIHRoZSB0cmFuc2FjdGlvbiAodXN1YWxseSB0aGUgd29ya2VyIGFkZHJlc3MpLlxuICAgICAqICAgICAgICAtIGBjYWxsZGF0YWA6IENhbGxkYXRhIHRvIHN1Ym1pdC5cbiAgICAgKiAgICAgICAgLSBgZXhwaXJ5YDogRXhpcnkgYmVmb3JlIHRoZSBzdWJtaXNzaW9uIGlzIGNvbnNpZGVyZWQgaW52YWxpZC5cbiAgICAgKiAgICAgICAgLSBgaWRlbnRpZmllcmA6IFRoZSBqb2IgaWRlbnRpZmllci4gRm9yIHJmcW1fdjJfam9iLCBpdCBzaG91bGQgYmUgb3JkZXIgaGFzaDsgZm9yIG1ldGEtdHJhbnNhY3Rpb24sIGl0IHNob3VsZCBiZSBqb2IgaWQuXG4gICAgICogICAgICAgIC0gYHN1Ym1pc3Npb25UeXBlYDogVGhlIHR5cGUgb2Ygc3VibWlzc2lvbi5cbiAgICAgKiAgICAgICAgLSBgb25TdWJtaXNzaW9uQ29udGV4dFN0YXR1c1VwZGF0ZWA6IENhbGxiYWNrIHRvIHBlcmZvcm0gYXBwcm9wcmlhdGUgYWN0aW9ucyB3aGVuIHRoZSBzdWJtaXNzaW9uIGNvbnRleHQgc3RhdHVzZXMgY2hhbmdlLlxuICAgICAqICAgICAgICAtIGBub3dgOiBUaGUgY3VycmVudCB0aW1lLlxuICAgICAqIEByZXR1cm5zIEZhaWxlZFJldmVydGVkQ29uZmlybWVkIG9yIFN1Y2NlZWRlZENvbmZpcm1lZC5cbiAgICAgKiBAdGhyb3dzIFN1Ym1pc3Npb24gY29udGV4dCBzdGF0dXMgaXMgRmFpbGVkRXhwaXJlZCBvciB1bmhhbmRsZWQgZXhjZXB0aW9ucy5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgc3VibWl0VG9DaGFpbkFzeW5jKG9wdHM6IHtcbiAgICAgICAga2luZDogKFJmcW1WMkpvYkVudGl0eSB8IE1ldGFUcmFuc2FjdGlvbkpvYkVudGl0eSlbJ2tpbmQnXTtcbiAgICAgICAgdG86IHN0cmluZztcbiAgICAgICAgZnJvbTogc3RyaW5nO1xuICAgICAgICBjYWxsZGF0YTogc3RyaW5nO1xuICAgICAgICBleHBpcnk6IEJpZ051bWJlcjtcbiAgICAgICAgaWRlbnRpZmllcjogc3RyaW5nO1xuICAgICAgICBzdWJtaXNzaW9uVHlwZTogUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblR5cGU7XG4gICAgICAgIG9uU3VibWlzc2lvbkNvbnRleHRTdGF0dXNVcGRhdGU6IChcbiAgICAgICAgICAgIG5ld1N1Ym1pc3Npb25Db250ZXh0U3RhdHVzOiBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cyxcbiAgICAgICAgICAgIG9sZFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzPzogU3VibWlzc2lvbkNvbnRleHRTdGF0dXMsXG4gICAgICAgICkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgICB9KTogUHJvbWlzZTxTdWJtaXNzaW9uQ29udGV4dFN0YXR1cy5GYWlsZWRSZXZlcnRlZENvbmZpcm1lZCB8IFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLlN1Y2NlZWRlZENvbmZpcm1lZD4ge1xuICAgICAgICBjb25zdCB7IGtpbmQsIHRvLCBmcm9tLCBjYWxsZGF0YSwgZXhwaXJ5LCBpZGVudGlmaWVyLCBzdWJtaXNzaW9uVHlwZSwgb25TdWJtaXNzaW9uQ29udGV4dFN0YXR1c1VwZGF0ZSB9ID0gb3B0cztcblxuICAgICAgICBsZXQgcHJldmlvdXNTdWJtaXNzaW9uc1dpdGhQcmVzdWJtaXRzO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JmcW1fdjJfam9iJzpcbiAgICAgICAgICAgICAgICBwcmV2aW91c1N1Ym1pc3Npb25zV2l0aFByZXN1Ym1pdHMgPSBhd2FpdCB0aGlzLl9kYlV0aWxzLmZpbmRWMlRyYW5zYWN0aW9uU3VibWlzc2lvbnNCeU9yZGVySGFzaEFzeW5jKFxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uVHlwZSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWV0YV90cmFuc2FjdGlvbl9qb2InOlxuICAgICAgICAgICAgICAgIHByZXZpb3VzU3VibWlzc2lvbnNXaXRoUHJlc3VibWl0cyA9IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZE1ldGFUcmFuc2FjdGlvblN1Ym1pc3Npb25zQnlKb2JJZEFzeW5jKFxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uVHlwZSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAoKF94OiBuZXZlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG4gICAgICAgICAgICAgICAgfSkoa2luZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcmV2aW91c1N1Ym1pc3Npb25zID0gYXdhaXQgdGhpcy5fcmVjb3ZlclByZXN1Ym1pdFRyYW5zYWN0aW9uc0FzeW5jKHByZXZpb3VzU3VibWlzc2lvbnNXaXRoUHJlc3VibWl0cyk7XG5cbiAgICAgICAgY29uc3QgZ2FzUHJpY2VFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuX2dhc1N0YXRpb25BdHRlbmRhbnQuZ2V0RXhwZWN0ZWRUcmFuc2FjdGlvbkdhc1JhdGVBc3luYygpO1xuXG4gICAgICAgIC8vIEZvciB0aGUgZmlyc3Qgc3VibWlzc2lvbiwgd2UgdXNlIHRoZSBcImZhc3RcIiBnYXMgZXN0aW1hdGUgdG8gYXBwcm94aW1hdGUgdGhlIGJhc2UgZmVlLlxuICAgICAgICAvLyBXZSB1c2UgdGhlIHN0cmF0ZWd5IG91dGxpbmVkIGluIGh0dHBzOi8vd3d3LmJsb2NrbmF0aXZlLmNvbS9ibG9nL2VpcC0xNTU5LWZlZXMgLS1cbiAgICAgICAgLy8gVGhlIGBtYXhGZWVQZXJHYXNgIGlzIDJ4IHRoZSBiYXNlIGZlZSAocGx1cyBwcmlvcml0eSB0aXApLiBTaW5jZSB3ZSBkb24ndCBoYXZlIGFcbiAgICAgICAgLy8gaGFuZHkgb3JhY2xlIGZvciB0aGUgZW4gdm9ndWUgcHJpb3J0eSBmZWUgd2Ugc3RhcnQgd2l0aCAyIGd3ZWkgYW5kIHdvcmsgdXAgZnJvbSB0aGVyZS5cbiAgICAgICAgY29uc3QgaW5pdGlhbE1heFByaW9yaXR5RmVlUGVyR2FzID0gbmV3IEJpZ051bWJlcih0aGlzLl9pbml0aWFsTWF4UHJpb3JpdHlGZWVQZXJHYXNHd2VpKS50aW1lcyhcbiAgICAgICAgICAgIE1hdGgucG93KDEwLCBHV0VJX0RFQ0lNQUxTKSxcbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgZ2FzRmVlczogR2FzRmVlcyA9IHtcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogQmlnTnVtYmVyLm1pbihcbiAgICAgICAgICAgICAgICBnYXNQcmljZUVzdGltYXRlLm11bHRpcGxpZWRCeSgyKS5wbHVzKGluaXRpYWxNYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4RmVlUGVyR2FzQ2FwV2VpLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBpbml0aWFsTWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHN1Ym1pc3Npb25Db250ZXh0O1xuICAgICAgICBsZXQgbm9uY2U7XG4gICAgICAgIGxldCBnYXNFc3RpbWF0ZTtcblxuICAgICAgICBpZiAoIXByZXZpb3VzU3VibWlzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIGFuIGVkZ2UgY2FzZSBoZXJlIHdoZXJlIHRoZXJlIGFyZSBwcmV2aW91cyBzdWJtaXNzaW9ucyBidXQgdGhleSdyZSBhbGwgaW4gYFBSRVNVQk1JVGAuXG4gICAgICAgICAgICAvLyBUaG9zZSBhcmUgZmlsdGVyZWQgb3V0IGlmIHRoZXkgY2FuJ3QgYmUgZm91bmQgb24gdGhlIGJsb2NrY2hhaW4gc28gd2UgZW5kIHVwIGhlcmUuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIG9jY3VycyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBleHBpcmVkLlxuICAgICAgICAgICAgY29uc3Qgbm93U2Vjb25kcyA9IG5ldyBCaWdOdW1iZXIobmV3IERhdGUoKS5nZXRUaW1lKCkgLyBPTkVfU0VDT05EX01TKTtcblxuICAgICAgICAgICAgaWYgKGV4cGlyeS5pc0xlc3NUaGFuKG5vd1NlY29uZHMpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25TdWJtaXNzaW9uQ29udGV4dFN0YXR1c1VwZGF0ZShTdWJtaXNzaW9uQ29udGV4dFN0YXR1cy5GYWlsZWRFeHBpcmVkKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4Y2VlZCBleHBpcnkgJHtleHBpcnl9IGZvciBraW5kICR7a2luZH0gYW5kIHN1Ym1pc3Npb24gdHlwZSAke3N1Ym1pc3Npb25UeXBlfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2dnZXIuaW5mbyh7IGtpbmQsIGlkZW50aWZpZXIsIGZyb20gfSwgJ0F0dGVtcHRpbmcgdG8gc3VibWl0IGZpcnN0IHRyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgICBhd2FpdCBvblN1Ym1pc3Npb25Db250ZXh0U3RhdHVzVXBkYXRlKFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLlBlbmRpbmdTdWJtaXR0ZWQpO1xuXG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIGdhc0ZlZXMsXG4gICAgICAgICAgICAgICAgICAgIGdhc1ByaWNlRXN0aW1hdGUsXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25Db3VudDogMSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgc3VibWlzc2lvblR5cGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnU3VibWl0dGluZyB0cmFuc2FjdGlvbicsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBub25jZSA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZXROb25jZUFzeW5jKGZyb20pO1xuICAgICAgICAgICAgY29uc3QgZ2FzRXN0aW1hdGVXaXRob3V0QnVmZmVyID0gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmVzdGltYXRlR2FzRm9yQXN5bmMoe1xuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgZGF0YTogY2FsbGRhdGEsXG4gICAgICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBnYXMgZmVlIHByb3BlcnRpZXMgYXJlIGFkZGVkIGJlY2F1c2UgYGV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25gIGluIDB4IEV4Y2hhbmdlIFByb3h5XG4gICAgICAgICAgICAgICAgLy8gd291bGQgY2hlY2sgd2hldGhlciB0aGUgZ2FzIHByaWNlIG9mIHRoZSB0cmFuc2FjdGlvbiBpcyB3aXRoaW4gYSB3aW5kb3cuIElmIGxlZnQgZW1wdHksIGl0IHdpbGxcbiAgICAgICAgICAgICAgICAvLyBmYWlsIHRoZSBzaW11bGF0aW9uLlxuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhczogZ2FzRmVlcy5tYXhGZWVQZXJHYXMudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogZ2FzRmVlcy5tYXhQcmlvcml0eUZlZVBlckdhcy50b1N0cmluZygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBZGQgYnVmZmVyIHRvIGdhcyBlc3RpbWF0ZSByZXR1cm5lZCBieSBgZXRoX2VzdGltYXRlR2FzYCBhcyB0aGUgUlBDIG1ldGhvZFxuICAgICAgICAgICAgLy8gdGVuZHMgdG8gdW5kZXIgZXN0aW1hdGUgZ2FzIHVzYWdlXG4gICAgICAgICAgICBnYXNFc3RpbWF0ZSA9IE1hdGguY2VpbCgoR0FTX0VTVElNQVRFX0JVRkZFUiArIDEpICogZ2FzRXN0aW1hdGVXaXRob3V0QnVmZmVyKTtcbiAgICAgICAgICAgIGxldCBhY2Nlc3NMaXN0V2l0aEdhcztcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZUFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NMaXN0V2l0aEdhcyA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5jcmVhdGVBY2Nlc3NMaXN0Rm9yQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY2FsbGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBSRlFNX0NSRUFURV9BQ0NFU1NfTElTVF9SRVFVRVNULmxhYmVscyh0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCksICdzdWNjZXNzJykuaW5jKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgUkZRTV9DUkVBVEVfQUNDRVNTX0xJU1RfUkVRVUVTVC5sYWJlbHModGhpcy5fY2hhaW5JZC50b1N0cmluZygpLCAnZmFpbHVyZScpLmluYygpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2Fybih7IGtpbmQsIGNhbGxkYXRhLCBmcm9tIH0sICdGYWlsZWQgdG8gY3JlYXRlIGFjY2VzcyBsaXN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFjY2Vzc0xpc3RXaXRoR2FzICE9PSB1bmRlZmluZWQgJiYgYWNjZXNzTGlzdFdpdGhHYXMuZ2FzRXN0aW1hdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGJ1ZmZlciB0byBnYXMgZXN0aW1hdGUgcmV0dXJuZWQgYnkgYGV0aF9lc3RpbWF0ZUdhc2AgYXMgdGhlIFJQQyBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgLy8gdGVuZHMgdG8gdW5kZXIgZXN0aW1hdGUgZ2FzIHVzYWdlXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc0xpc3RXaXRoR2FzLmdhc0VzdGltYXRlID0gTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICAgICAgICAgKEdBU19FU1RJTUFURV9CVUZGRVIgKyAxKSAqIGFjY2Vzc0xpc3RXaXRoR2FzLmdhc0VzdGltYXRlLFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBnYXNFc3RpbWF0ZSwgYWNjZXNzTGlzdEdhc0VzdGltYXRlOiBhY2Nlc3NMaXN0V2l0aEdhcy5nYXNFc3RpbWF0ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZ3VsYXIgZ2FzIGVzdGltYXRlIHZzIGFjY2VzcyBsaXN0IGdhcyBlc3RpbWF0ZScsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIFJGUU1fR0FTX0VTVElNQVRFX05PX0FDQ0VTU19MSVNULmxhYmVscyh0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLnNldChnYXNFc3RpbWF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIFJGUU1fR0FTX0VTVElNQVRFX0FDQ0VTU19MSVNULmxhYmVscyh0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLnNldChhY2Nlc3NMaXN0V2l0aEdhcy5nYXNFc3RpbWF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBmaXJzdFN1Ym1pc3Npb24gPSBhd2FpdCB0aGlzLl9zdWJtaXRUcmFuc2FjdGlvbkFzeW5jKFxuICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgIGNhbGxkYXRhLFxuICAgICAgICAgICAgICAgIGdhc0ZlZXMsXG4gICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgZ2FzRXN0aW1hdGUsXG4gICAgICAgICAgICAgICAgc3VibWlzc2lvblR5cGUsXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICB7IGtpbmQsIGZyb20sIGlkZW50aWZpZXIsIHN1Ym1pc3Npb25UeXBlLCB0cmFuc2FjdGlvbkhhc2g6IGZpcnN0U3VibWlzc2lvbi50cmFuc2FjdGlvbkhhc2ggfSxcbiAgICAgICAgICAgICAgICAnU3VjY2Vzc2Z1bGx5IHN1Ym1pdHRlZCB0cmFuc2FjdGlvbicsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBzdWJtaXNzaW9uQ29udGV4dCA9IG5ldyBTdWJtaXNzaW9uQ29udGV4dCh0aGlzLl9ibG9ja2NoYWluVXRpbHMsIFtmaXJzdFN1Ym1pc3Npb25dIGFzXG4gICAgICAgICAgICAgICAgfCBSZnFtVjJUcmFuc2FjdGlvblN1Ym1pc3Npb25FbnRpdHlbXVxuICAgICAgICAgICAgICAgIHwgTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eVtdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKHsga2luZCwgZnJvbSwgaWRlbnRpZmllciwgc3VibWlzc2lvblR5cGUgfSwgYFByZXZpb3VzIHN1Ym1pc3Npb25zIGZvdW5kLCByZWNvdmVyaW5nIGNvbnRleHRgKTtcbiAgICAgICAgICAgIHN1Ym1pc3Npb25Db250ZXh0ID0gbmV3IFN1Ym1pc3Npb25Db250ZXh0KHRoaXMuX2Jsb2NrY2hhaW5VdGlscywgcHJldmlvdXNTdWJtaXNzaW9ucyk7XG4gICAgICAgICAgICBub25jZSA9IHN1Ym1pc3Npb25Db250ZXh0Lm5vbmNlO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHN1Ym1pdHRlZCBhIHRyYW5zYWN0aW9uIGFuZCBpdCBoYXMgYmVlbiBtaW5lZCxcbiAgICAgICAgICAgIC8vIHVzaW5nIGBfYmxvY2tjaGFpblV0aWxzLmVzdGltYXRlR2FzRm9yQXN5bmNgIHdpbGwgdGhyb3dcbiAgICAgICAgICAgIC8vIGdpdmVuIHRoZSBzYW1lIGNhbGxkYXRhLiBJbiB0aGUgZWRnZSBjYXNlIHdoZXJlIGEgdHJhbnNhY3Rpb24gaGFzIGJlZW4gc2VudFxuICAgICAgICAgICAgLy8gYnV0IG5vdCBtaW5lZCwgd2Ugd291bGQgaWRlYWxseSBwdWxsIHRoZSBnYXMgZXN0aW1hdGUgZnJvbSB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uLiBVbmZvcnR1bmF0ZWx5LCB3ZSBjdXJyZW50bHkgZG8gbm90IHN0b3JlIGl0IG9uIHRoZVxuICAgICAgICAgICAgLy8gYFJmcW1WMlRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eWAuIEFzIGEgd29ya2Fyb3VuZCwgd2UnbGwganVzdCB1c2UgYW5cbiAgICAgICAgICAgIC8vIG92ZXJlc3RpbWF0ZS4uXG4gICAgICAgICAgICBnYXNFc3RpbWF0ZSA9IE1BWF9HQVNfRVNUSU1BVEU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgXCJXYXRjaCBMb29wXCJcbiAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IHN1Ym1pdHRlZCB0aGUgdHJhbnNhY3Rpb24gb25jZSBhdCB0aGlzIHBvaW50LCBzbyB3ZSBmaXJzdCBuZWVkIHRvIHdhaXQgYmVmb3JlIGNoZWNraW5nIHRoZSBzdGF0dXMuXG4gICAgICAgICAgICBhd2FpdCBkZWxheSh0aGlzLl90cmFuc2FjdGlvbldhdGNoZXJTbGVlcFRpbWVNcyk7XG4gICAgICAgICAgICBjb25zdCBvbGRTdWJtaXNzaW9uQ29udGV4dFN0YXR1cyA9IHN1Ym1pc3Npb25Db250ZXh0LnN1Ym1pc3Npb25Db250ZXh0U3RhdHVzO1xuICAgICAgICAgICAgY29uc3QgbmV3U3VibWlzc2lvbkNvbnRleHRTdGF0dXMgPSBhd2FpdCB0aGlzLl9jaGVja1N1Ym1pc3Npb25SZWNlaXB0c0FuZFVwZGF0ZURiQXN5bmMoXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBzdWJtaXNzaW9uQ29udGV4dCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICB7IGtpbmQsIHN1Ym1pc3Npb25UeXBlLCBvbGRTdWJtaXNzaW9uQ29udGV4dFN0YXR1cywgbmV3U3VibWlzc2lvbkNvbnRleHRTdGF0dXMgfSxcbiAgICAgICAgICAgICAgICAnT2xkIGFuZCBuZXcgc3VibWlzc2lvbiBjb250ZXh0IHN0YXR1c2VzJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhd2FpdCBvblN1Ym1pc3Npb25Db250ZXh0U3RhdHVzVXBkYXRlKG5ld1N1Ym1pc3Npb25Db250ZXh0U3RhdHVzLCBvbGRTdWJtaXNzaW9uQ29udGV4dFN0YXR1cyk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAobmV3U3VibWlzc2lvbkNvbnRleHRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLlBlbmRpbmdTdWJtaXR0ZWQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIHB1dCBpbiBhdCBsZWFzdCBvbmUgdHJhbnNhY3Rpb24gYnV0IG5vbmUgaGF2ZSBiZWVuIG1pbmVkIHlldC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gbWFrZSBzdXJlIHdlIGhhdmVuJ3QgcGFzc2VkIHRoZSBleHBpcnkgd2luZG93LlxuICAgICAgICAgICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jYXNlLWRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub3dTZWNvbmRzID0gbmV3IEJpZ051bWJlcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIE9ORV9TRUNPTkRfTVMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNhc2UtZGVjbGFyYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlY29uZHNQYXN0RXhwaXJhdGlvbiA9IG5vd1NlY29uZHMubWludXMoZXhwaXJ5KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBtb3JlIHRoYW4gMTIwIHNlY29uZHMgcGFzdCBleHBpcmF0aW9uLCBnaXZlIHVwLlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JvbGFuZGtvZmxlci9ibG9ja3RpbWUgZm9yIHNvbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5hbHlzaXMgb2YgZXhwZWN0ZWQgYmxvY2sgdGltZXMuIFR3byBtaW51dGVzIHdhcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBjb3ZlciBtb3N0IGNhc2VzIHdpdGhvdXQgbG9ja2luZyB1cCB0aGUgd29ya2VyIGZvciB0b28gbG9uZy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY29uZHNQYXN0RXhwaXJhdGlvbi5pc0dyZWF0ZXJUaGFuKE9ORV9NSU5VVEVfUyAqIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBvblN1Ym1pc3Npb25Db250ZXh0U3RhdHVzVXBkYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLkZhaWxlZEV4cGlyZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkU3VibWlzc2lvbkNvbnRleHRTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBFeGNlZWQgZXhwaXJ5ICR7ZXhwaXJ5fSBmb3Iga2luZCAke2tpbmR9IGFuZCBzdWJtaXNzaW9uIHR5cGUgJHtzdWJtaXNzaW9uVHlwZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBwYXN0IGV4cGlyYXRpb24gYnkgbGVzcyB0aGFuIGEgbWludXRlLCBkb24ndCBwdXQgaW4gYW55IG5ldyB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGtlZXAgd2F0Y2hpbmcgaW4gY2FzZSBhIHJlY2VpcHQgc2hvd3MgdXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY29uZHNQYXN0RXhwaXJhdGlvbi5pc0dyZWF0ZXJUaGFuKDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFwiRmFzdFwiIGdhcyBwcmljZSBlc3RpbWF0aW9uOyB1c2VkIHRvIGFwcHJveGltYXRlIHRoZSBiYXNlIGZlZVxuICAgICAgICAgICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jYXNlLWRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdHYXNQcmljZUVzdGltYXRlID0gYXdhaXQgdGhpcy5fZ2FzU3RhdGlvbkF0dGVuZGFudC5nZXRFeHBlY3RlZFRyYW5zYWN0aW9uR2FzUmF0ZUFzeW5jKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Ym1pc3Npb25Db250ZXh0LnRyYW5zYWN0aW9uVHlwZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24tRUlQLTE1NTkgdHJhbnNhY3Rpb25zIGFyZSBub3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhaXQgZm9yIGdhcyBjb25kaXRpb25zIHRvIGNoYW5nZS4gUmF0aGVyLCB3ZSBpbmNyZWFzZSB0aGUgZ2FzXG4gICAgICAgICAgICAgICAgICAgIC8vIGJhc2VkIGJpZCBiYXNlZCBvbnRoZSBrbm93bGVkZ2UgdGhhdCB0aW1lIChhbmQgdGhlcmVmb3JlIGJsb2NrcywgdGhlb3JldGljYWxseSlcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIHBhc3NlZCB3aXRob3V0IGEgdHJhbnNhY3Rpb24gYmVpbmcgbWluZWQuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY2FzZS1kZWNsYXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBtYXhGZWVQZXJHYXM6IG9sZE1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IG9sZE1heFByaW9yaXR5RmVlUGVyR2FzIH0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgc3VibWlzc2lvbkNvbnRleHQubWF4R2FzRmVlcztcblxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkTWF4RmVlUGVyR2FzLmlzR3JlYXRlclRoYW5PckVxdWFsVG8odGhpcy5fbWF4RmVlUGVyR2FzQ2FwV2VpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCB0aGUgbWF4IGZlZSBwZXIgZ2FzIHdlJ2QgbGlrZSB0byBwYXksIGp1c3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIHdhdGNoaW5nIHRoZSB0cmFuc2FjdGlvbnMgdG8gc2VlIGlmIG9uZSBnZXRzIG1pbmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBraW5kLCBzdWJtaXNzaW9uVHlwZSwgb2xkTWF4RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXNDYXA6IHRoaXMuX21heEZlZVBlckdhc0NhcFdlaSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdFeGNlZWRzIG1heCBmZWUgcGVyIGdhcycsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jYXNlLWRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdNYXhQcmlvcml0eUZlZVBlckdhcyA9IG9sZE1heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgICAgICAgICAgICAgICAgICAgICAubXVsdGlwbGllZEJ5KE1BWF9QUklPUklUWV9GRUVfUEVSX0dBU19NVUxUSVBMSUVSKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVnZXJWYWx1ZShCaWdOdW1iZXIuUk9VTkRfQ0VJTCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIFJQQyBub2RlcyBzdGlsbCBuZWVkIGF0IGxlYXN0IGEgMC4xIGluY3JlYXNlIGluIGJvdGggdmFsdWVzIHRvIGFjY2VwdCB0aGUgbmV3IHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdGhlIG5ldyBtYXggZmVlIHBlciBnYXMsIHdlJ2xsIHRha2UgdGhlIG1heGltdW0gb2YgYSAwLjEgaW5jcmVhc2UgZnJvbSB0aGUgbGFzdCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBvciB0aGUgdmFsdWUgZnJvbSBhbiBpbmNyZWFzZSBpbiB0aGUgYmFzZSBmZWUuXG4gICAgICAgICAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNhc2UtZGVjbGFyYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld01heEZlZVBlckdhcyA9IEJpZ051bWJlci5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRNYXhGZWVQZXJHYXMubXVsdGlwbGllZEJ5KE1BWF9GRUVfUEVSX0dBU19NVUxUSVBMSUVSKS5pbnRlZ2VyVmFsdWUoQmlnTnVtYmVyLlJPVU5EX0NFSUwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3R2FzUHJpY2VFc3RpbWF0ZS5tdWx0aXBsaWVkQnkoMikucGx1cyhuZXdNYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ2FzRmVlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEZlZVBlckdhczogbmV3TWF4RmVlUGVyR2FzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IG5ld01heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FzRmVlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXNQcmljZUVzdGltYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VibWlzc2lvbkNvdW50OiBzdWJtaXNzaW9uQ29udGV4dC50cmFuc2FjdGlvbnMubGVuZ3RoICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTdWJtaXR0aW5nIHRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLl9zdWJtaXRUcmFuc2FjdGlvbkFzeW5jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhc0ZlZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FzRXN0aW1hdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VibWlzc2lvblR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IG5ld1RyYW5zYWN0aW9uLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VibWlzc2lvblR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnU3VjY2Vzc2Z1bGx5IHJlc3VibWl0ZWQgdHggd2l0aCBoaWdoZXIgZ2FzIHByaWNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uQ29udGV4dC5hZGRUcmFuc2FjdGlvbihuZXdUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc05vbmNlVG9vTG93ID0gL25vbmNlIHRvbyBsb3cvLnRlc3QoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZnJvbSwga2luZCwgaWRlbnRpZmllciwgc3VibWlzc2lvblR5cGUsIGVycm9yTWVzc2FnZTogZXJyLm1lc3NhZ2UsIGlzTm9uY2VUb29Mb3cgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRW5jb3VudGVyZWQgYW4gZXJyb3IgcmUtc3VibWl0dGluZyBhIHR4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb25jZVRvb0xvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGZyb20sIGtpbmQsIGlkZW50aWZpZXIsIHN1Ym1pc3Npb25UeXBlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJZ25vcmUgbm9uY2UgdG9vIGxvdyBlcnJvciBvbiByZS1zdWJtaXNzaW9uLiBBIHByZXZpb3VzIHN1Ym1pc3Npb24gd2FzIHN1Y2Nlc3NmdWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldGhyb3cgb24gYWxsIG90aGVyIHR5cGVzIG9mIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cy5GYWlsZWRSZXZlcnRlZFVuY29uZmlybWVkOlxuICAgICAgICAgICAgICAgIGNhc2UgU3VibWlzc2lvbkNvbnRleHRTdGF0dXMuU3VjY2VlZGVkVW5jb25maXJtZWQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3VibWlzc2lvbkNvbnRleHRTdGF0dXMuRmFpbGVkUmV2ZXJ0ZWRDb25maXJtZWQ6XG4gICAgICAgICAgICAgICAgY2FzZSBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cy5TdWNjZWVkZWRDb25maXJtZWQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdTdWJtaXNzaW9uQ29udGV4dFN0YXR1cztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAoKF94OiBuZXZlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xuICAgICAgICAgICAgICAgICAgICB9KShuZXdTdWJtaXNzaW9uQ29udGV4dFN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHN1cHBseSB0byBgc3VibWl0VG9DaGFpbkFzeW5jYC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBgam9iLnN0YXR1c2Agd291bGQgYmUgdXBkYXRlZCB0byBhcHByb3ByaWF0ZSBzdGF0ZSBieSAgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGFjY29yZGluZyB0byBvbGQgJiBuZXdcbiAgICAgKiBzdWJtaXNzaW9uIGNvbnRleHQgc3RhdHVzIGFuZCBzdWJtaXNzaW9uIHR5cGUuIFRoZXJlIHdvdWxkIGJlIGpvYiBzdGF0dXMgdXBkYXRlIE9OTFkgSUYgdGhlIG5ldyBhbmQgb2xkIHN1Ym1pc3Npb25cbiAgICAgKiBjb250ZXh0IHN0YXR1c2VzIGRpZmZlci5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWxzbyBcImNsb3NlcyBvdmVyXCIgYGpvYmAgc28gdGhhdCBpdCdzIGFjY2Vzc2libGUgaW4gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLiBSZWZlciB0aGUgZG9jc3RyaW5nIG9mXG4gICAgICogYFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25Db250ZXh0U3RhdHVzYCBmb3IgbW9yZSBkZXRhaWxzIG9uIHN1Ym1pc3Npb24gY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqb2IgQSByZnFtIHYyIGpvYiBvciBhIG1ldGEgdHJhbnNhY3Rpbm8gam9iIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gc3VibWlzc2lvblR5cGUgVHlwZSBvZiBzdWJtaXNzaW9uLlxuICAgICAqIEByZXR1cm5zIEZ1bmN0aW9uIHdvdWxkIG1ha2UgYXBwcm9wcmlhdGUgdXBkYXRlIHRvIGpvYiBzdGF0dXMgYWNjb3JkaW5nIHRvIHN1Ym1pc3Npb24gY29udGV4dCBzdGF0dXNlcyBhbmQgc3VibWlzc2lvbiB0eXBlLlxuICAgICAqL1xuICAgIHByaXZhdGUgX2dldE9uU3VibWlzc2lvbkNvbnRleHRTdGF0dXNVcGRhdGVDYWxsYmFjayhcbiAgICAgICAgam9iOiBSZnFtVjJKb2JFbnRpdHkgfCBNZXRhVHJhbnNhY3Rpb25Kb2JFbnRpdHksXG4gICAgICAgIHN1Ym1pc3Npb25UeXBlOiBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZSxcbiAgICApOiAoXG4gICAgICAgIG5ld1N1Ym1pc3Npb25Db250ZXh0U3RhdHVzOiBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cyxcbiAgICAgICAgb2xkU3VibWlzc2lvbkNvbnRleHRTdGF0dXM/OiBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cyxcbiAgICApID0+IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gYXN5bmMgKFxuICAgICAgICAgICAgbmV3U3VibWlzc2lvbkNvbnRleHRTdGF0dXM6IFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLFxuICAgICAgICAgICAgb2xkU3VibWlzc2lvbkNvbnRleHRTdGF0dXM/OiBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cyxcbiAgICAgICAgKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICAgICAgICBpZiAobmV3U3VibWlzc2lvbkNvbnRleHRTdGF0dXMgIT09IG9sZFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0pvYlN0YXR1czogUmZxbUpvYlN0YXR1cztcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1Ym1pc3Npb25UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblR5cGUuQXBwcm92YWw6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdKb2JTdGF0dXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN1Ym1pc3Npb25Db250ZXh0LmFwcHJvdmFsU3VibWlzc2lvbkNvbnRleHRTdGF0dXNUb0pvYlN0YXR1cyhuZXdTdWJtaXNzaW9uQ29udGV4dFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZS5UcmFkZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0pvYlN0YXR1cyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3VibWlzc2lvbkNvbnRleHQudHJhZGVTdWJtaXNzaW9uQ29udGV4dFN0YXR1c1RvSm9iU3RhdHVzKG5ld1N1Ym1pc3Npb25Db250ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgKChfeDogbmV2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KShzdWJtaXNzaW9uVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgam9iLnN0YXR1cyA9IG5ld0pvYlN0YXR1cztcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9kYlV0aWxzLnVwZGF0ZVJmcW1Kb2JBc3luYyhqb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRha2VzIGFuIGFycmF5IG9mIFRyYW5zYWN0aW9uIFN1Ym1pc3Npb25zLCB3aGljaCBtYXkgaW5jbHVkZSB0cmFuc2FjdGlvbnMgd2l0aCB0aGVcbiAgICAgKiBcIlByZXNidW1pdFwiIHN0YXR1cywgYW5kIHJlc29sdmVzIG9yIHJlbW92ZXMgdGhlIFwiUHJlc3VibWl0XCIgdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogSWYgdGhlcmUgYXJlIHByZXZpb3VzIHN1Ym1pc3Npb25zIGluIHRoZSBcIlByZXN1Ym1pdFwiIHN0YXRlLFxuICAgICAqXG4gICAgICogRm9yIFwiUHJlc3VibWl0XCIgdHJhbnNhY3Rpb25zLCB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBhY3R1YWxseSBzZW50IHRvXG4gICAgICogdGhlIG1lbXBvb2wgb3Igbm90LCBhcyB0aGF0IGlzIGluZGV0ZXJtaW5hdGUuIERlcGVuZGluZyBvbiB0aGUgcmVzdWx0IG9mIHRoZSBjaGVjaywgd2VcbiAgICAgKiB1cGRhdGUgdGhlIHN0YXR1cyB0byBcIlN1Ym1pdHRlZFwiIG9yIHJlbW92ZSB0aGVtIGZyb20gdGhlIHN1Ym1pc3Npb25zIGluIG1lbW9yeS5cbiAgICAgKiBOb3RlIHRoYXQgd2UgbGVhdmUgdGhlIHRyYW5zYWN0aW9uIHJlY29yZCBwcmVzZW50IGluIHRoZSBkYXRhYmFzZSBzbyB0aGF0IGlmIHRoZSB3b3JrZXJcbiAgICAgKiBkaWVzIGFnYWluIGFuZCB0aGUgc3VibWlzc2lvbiBhY3R1YWxseSB3ZW50IHRocm91Z2ggYnV0IHdhcyBub3QgZm91bmQgYXQgdGhlIHRpbWUgb2ZcbiAgICAgKiB0aGlzIGNoZWNrIHdlIGNhbiBwb3RlbnRpYWxseSByZWNvdmVyIGl0IGxhdGVyLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgX3JlY292ZXJQcmVzdWJtaXRUcmFuc2FjdGlvbnNBc3luYzxcbiAgICAgICAgVCBleHRlbmRzIFJmcW1WMlRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eVtdIHwgTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eVtdLFxuICAgID4odHJhbnNhY3Rpb25TdWJtaXNzaW9uczogVCk6IFByb21pc2U8VD4ge1xuICAgICAgICAvLyBBbnkgaXMgc28gbmFzdHkgLS0gaHR0cHM6Ly9kZXYudG8vc2hhZG93MTM0OS90eXBlc2NyaXB0LXRpcC1vZi10aGUtd2Vlay1nZW5lcmljcy0xNzBnXG4gICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgcmVzdWx0OiBhbnkgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uU3VibWlzc2lvbnMubWFwKGFzeW5jICh0cmFuc2FjdGlvblN1Ym1pc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdHJhbnNhY3Rpb24gaXMgYW55IHN0YXR1cyBvdGhlciB0aGFuIFwiUHJlc3VibWl0XCIgdGhlbiB3ZSdsbCBsZWF2ZSBpdFxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvblN1Ym1pc3Npb24uc3RhdHVzICE9PSBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uU3RhdHVzLlByZXN1Ym1pdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25TdWJtaXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGb3IgdHJhbnNhY3Rpb25zIGluIHByZXN1Ym1pdCwgY2hlY2sgdGhlIG1lbXBvb2wgYW5kIGNoYWluIHRvIHNlZSBpZiB0aGV5IGV4aXN0XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25SZXNwb25zZSA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZXRUcmFuc2FjdGlvbkFzeW5jKFxuICAgICAgICAgICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3VibWlzc2lvbi50cmFuc2FjdGlvbkhhc2ghLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgZG9lcyBleGlzdCwgdXBkYXRlIHRoZSBzdGF0dXMuIElmIG5vdCwgcmVtb3ZlIGl0LlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblN1Ym1pc3Npb24uc3RhdHVzID0gUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblN0YXR1cy5TdWJtaXR0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvbnNBc3luYyhbdHJhbnNhY3Rpb25TdWJtaXNzaW9uXSBhcyBUKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uU3VibWlzc2lvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgKS50aGVuKCh4KSA9PiB4LmZpbHRlcihpc0RlZmluZWQpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3IgcmVjZWlwdHMgZnJvbSB0aGUgdHggaGFzaGVzIGFuZCB1cGRhdGUgZGF0YWJhc2VzIHdpdGggc3RhdHVzIG9mIGFsbCB0eCdzLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgX2NoZWNrU3VibWlzc2lvblJlY2VpcHRzQW5kVXBkYXRlRGJBc3luYyhcbiAgICAgICAgaWRlbnRpZmllcjogc3RyaW5nLFxuICAgICAgICBzdWJtaXNzaW9uQ29udGV4dDogU3VibWlzc2lvbkNvbnRleHQ8UmZxbVYyVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5W10gfCBNZXRhVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5W10+LFxuICAgICk6IFByb21pc2U8XG4gICAgICAgIHwgU3VibWlzc2lvbkNvbnRleHRTdGF0dXMuUGVuZGluZ1N1Ym1pdHRlZFxuICAgICAgICB8IFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLkZhaWxlZFJldmVydGVkQ29uZmlybWVkXG4gICAgICAgIHwgU3VibWlzc2lvbkNvbnRleHRTdGF0dXMuRmFpbGVkUmV2ZXJ0ZWRVbmNvbmZpcm1lZFxuICAgICAgICB8IFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLlN1Y2NlZWRlZENvbmZpcm1lZFxuICAgICAgICB8IFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLlN1Y2NlZWRlZFVuY29uZmlybWVkXG4gICAgPiB7XG4gICAgICAgIC8vIEF0IG1vc3Qgb25lIHR4IGNhbiBiZSBtaW5lZCwgc2luY2UgdGhleSBhbGwgaGF2ZSB0aGUgc2FtZSBub25jZS5cbiAgICAgICAgY29uc3QgbWluZWRSZWNlaXB0ID0gYXdhaXQgc3VibWlzc2lvbkNvbnRleHQuZ2V0UmVjZWlwdEFzeW5jKCk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHR4IGhhc24ndCBiZWVuIG1pbmVkIHlldCwgdGhlcmUncmUgbm8gZGF0YWJhc2UgdXBkYXRlcyB0byBkby5cbiAgICAgICAgaWYgKCFtaW5lZFJlY2VpcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cy5QZW5kaW5nU3VibWl0dGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXR0ZW1wdCB0byBwdWJsaXNoIHRoZSBtaW5pbmcgbGF0ZW5jeVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyB0aW1lc3RhbXA6IG1pbmVkQmxvY2tUaW1lc3RhbXBTIH0gPSBhd2FpdCB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZ2V0QmxvY2tBc3luYyhcbiAgICAgICAgICAgICAgICBtaW5lZFJlY2VpcHQuYmxvY2tIYXNoLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0U3VibWlzc2lvblRpbWVzdGFtcFMgPSBzdWJtaXNzaW9uQ29udGV4dC5maXJzdFN1Ym1pc3Npb25UaW1lc3RhbXBTO1xuICAgICAgICAgICAgUkZRTV9NSU5JTkdfTEFURU5DWS5sYWJlbHModGhpcy5fY2hhaW5JZC50b1N0cmluZygpKS5vYnNlcnZlKFxuICAgICAgICAgICAgICAgIG1pbmVkQmxvY2tUaW1lc3RhbXBTIC0gZmlyc3RTdWJtaXNzaW9uVGltZXN0YW1wUyxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICAgIHsgb3JkZXJIYXNoOiBpZGVudGlmaWVyLCBlcnJvck1lc3NhZ2U6IGUubWVzc2FnZSwgc3RhY2s6IGUuc3RhY2sgfSxcbiAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIG1ldGVyIHRoZSBtaW5pbmcgbGF0ZW5jeScsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc3VibWlzc2lvbkNvbnRleHQudXBkYXRlRm9yUmVjZWlwdEFzeW5jKG1pbmVkUmVjZWlwdCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvbnNBc3luYyhzdWJtaXNzaW9uQ29udGV4dC50cmFuc2FjdGlvbnMpO1xuICAgICAgICByZXR1cm4gc3VibWlzc2lvbkNvbnRleHQuc3VibWlzc2lvbkNvbnRleHRTdGF0dXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRyYW5zYWN0aW9uIHByb3BlcnRpZXMgYW5kIHN1Ym1pdCBhIHRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfc3VibWl0VHJhbnNhY3Rpb25Bc3luYyhcbiAgICAgICAga2luZDogKFJmcW1WMkpvYkVudGl0eSB8IE1ldGFUcmFuc2FjdGlvbkpvYkVudGl0eSlbJ2tpbmQnXSxcbiAgICAgICAgaWRlbnRpZmllcjogc3RyaW5nLFxuICAgICAgICB3b3JrZXJBZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgIGNhbGxEYXRhOiBzdHJpbmcsXG4gICAgICAgIGdhc0ZlZXM6IEdhc0ZlZXMsXG4gICAgICAgIG5vbmNlOiBudW1iZXIsXG4gICAgICAgIGdhc0VzdGltYXRlOiBudW1iZXIsXG4gICAgICAgIHN1Ym1pc3Npb25UeXBlOiBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZSA9IFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25UeXBlLlRyYWRlLFxuICAgICAgICB0bzogc3RyaW5nID0gdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldEV4Y2hhbmdlUHJveHlBZGRyZXNzKCksXG4gICAgKTogUHJvbWlzZTxSZnFtVjJUcmFuc2FjdGlvblN1Ym1pc3Npb25FbnRpdHkgfCBNZXRhVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5PiB7XG4gICAgICAgIGNvbnN0IHR4T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLmdhc0ZlZXMsXG4gICAgICAgICAgICBmcm9tOiB3b3JrZXJBZGRyZXNzLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBnYXM6IGdhc0VzdGltYXRlLFxuICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvblJlcXVlc3QgPSB0aGlzLl9ibG9ja2NoYWluVXRpbHMudHJhbnNmb3JtVHhEYXRhVG9UcmFuc2FjdGlvblJlcXVlc3QoXG4gICAgICAgICAgICB0eE9wdGlvbnMsXG4gICAgICAgICAgICB0aGlzLl9jaGFpbklkLFxuICAgICAgICAgICAgY2FsbERhdGEsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHsgc2lnbmVkVHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uSGFzaCB9ID0gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLnNpZ25UcmFuc2FjdGlvbkFzeW5jKFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25SZXF1ZXN0LFxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBwYXJ0aWFsRW50aXR5O1xuICAgICAgICBsZXQgdHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5O1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JmcW1fdjJfam9iJzpcbiAgICAgICAgICAgICAgICBwYXJ0aWFsRW50aXR5ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5nYXNGZWVzLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgICAgIG9yZGVySGFzaDogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiB3b3JrZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblN0YXR1cy5QcmVzdWJtaXQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHN1Ym1pc3Npb25UeXBlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5ID0gYXdhaXQgdGhpcy5fZGJVdGlscy53cml0ZVYyUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblRvRGJBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbEVudGl0eSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWV0YV90cmFuc2FjdGlvbl9qb2InOlxuICAgICAgICAgICAgICAgIHBhcnRpYWxFbnRpdHkgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmdhc0ZlZXMsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YVRyYW5zYWN0aW9uSm9iSWQ6IGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogd29ya2VyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25TdGF0dXMuUHJlc3VibWl0LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBzdWJtaXNzaW9uVHlwZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eSA9IGF3YWl0IHRoaXMuX2RiVXRpbHMud3JpdGVNZXRhVHJhbnNhY3Rpb25TdWJtaXNzaW9uQXN5bmMocGFydGlhbEVudGl0eSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICgoX3g6IG5ldmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcbiAgICAgICAgICAgICAgICB9KShraW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaEZyb21TdWJtaXQgPSBhd2FpdCB0aGlzLl9ibG9ja2NoYWluVXRpbHMuc3VibWl0U2lnbmVkVHJhbnNhY3Rpb25Bc3luYyhzaWduZWRUcmFuc2FjdGlvbik7XG5cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uSGFzaCAhPT0gdHJhbnNhY3Rpb25IYXNoRnJvbVN1Ym1pdCkge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgZXZlciBoYXBwZW5cbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICB7IGtpbmQsIHN1Ym1pc3Npb25UeXBlLCBpZGVudGlmaWVyLCB0cmFuc2FjdGlvbkhhc2hGcm9tU3VibWl0LCB0cmFuc2FjdGlvbkhhc2ggfSxcbiAgICAgICAgICAgICAgICAnTWlzbWF0Y2ggYmV0d2VlbiB0cmFuc2FjdGlvbiBoYXNoIGNhbGN1bGF0ZWQgYmVmb3JlIHN1Ym1pdCBhbmQgYWZ0ZXIgc3VibWl0JyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc21hdGNoIGJldHdlZW4gdHJhbnNhY3Rpb24gaGFzaCBjYWxjdWxhdGVkIGJlZm9yZSBzdWJtaXQgYW5kIGFmdGVyIHN1Ym1pdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICB7IGtpbmQsIHN1Ym1pc3Npb25UeXBlLCBpZGVudGlmaWVyLCB3b3JrZXJBZGRyZXNzLCB0cmFuc2FjdGlvbkhhc2ggfSxcbiAgICAgICAgICAgICdUcmFuc2FjdGlvbiBjYWxsZGF0YSBzdWJtaXR0ZWQgdG8gZXhjaGFuZ2UgcHJveHknLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRUcmFuc2FjdGlvblN1Ym1pc3Npb24gPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLi4udHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5LFxuICAgICAgICAgICAgICAgIHN0YXR1czogUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblN0YXR1cy5TdWJtaXR0ZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdIGFzIFJmcW1WMlRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eVtdIHwgTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eVtdO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvbnNBc3luYyh1cGRhdGVkVHJhbnNhY3Rpb25TdWJtaXNzaW9uKTtcblxuICAgICAgICBsZXQgdXBkYXRlZEVudGl0eTtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlICdyZnFtX3YyX2pvYic6XG4gICAgICAgICAgICAgICAgdXBkYXRlZEVudGl0eSA9IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZFYyVHJhbnNhY3Rpb25TdWJtaXNzaW9uQnlUcmFuc2FjdGlvbkhhc2hBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoRnJvbVN1Ym1pdCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWV0YV90cmFuc2FjdGlvbl9qb2InOlxuICAgICAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY2FzZS1kZWNsYXJhdGlvbnNcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkU3VibWlzc2lvbkVudGl0aWVzID1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGJVdGlscy5maW5kTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbnNCeVRyYW5zYWN0aW9uSGFzaEFzeW5jKFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoRnJvbVN1Ym1pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkU3VibWlzc2lvbkVudGl0aWVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHRyYW5zYWN0aW9uIGhhc2ggc2hvdWxkIG5ldmVyIGJlIHN1Ym1pdHRlZCB0d2ljZSBpbiBvdXIgc3lzdGVtLiBIb3dldmVyLCBSRlEtNTYyIG1lbnRpb25lZCBjYXNlcyBsaWtlIHRoaXMgY291bGRcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFwcGVuIGluIG91ciBzeXN0ZW0uIEFkZCBtb3JlIGxvZyBhbmQgdGhyb3cgdGhlIGVycm9yIHRvIHN1cmZhY2UgaXQuXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHsga2luZCwgc3VibWlzc2lvblR5cGUsIHRyYW5zYWN0aW9uSGFzaCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYW5zYWN0aW9uIGhhc2ggaGF2ZSBiZWVuIHN1Ym1pdHRlZCBub3QgZXhhY3RseSBvbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBoYXNoIGhhdmUgYmVlbiBzdWJtaXR0ZWQgbm90IGV4YWN0bHkgb25jZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHVwZGF0ZWRFbnRpdHkgPSB1cGRhdGVkU3VibWlzc2lvbkVudGl0aWVzWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAoKF94OiBuZXZlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG4gICAgICAgICAgICAgICAgfSkoa2luZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVwZGF0ZWRFbnRpdHkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiAtLSB3ZSBqdXN0IHNhdmVkIGl0XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYENvdWxkIG5vdCBmaW5kIHVwZGF0ZWQgZW50aXR5IHdpdGggdHJhbnNhY3Rpb24gaGFzaCAke3RyYW5zYWN0aW9uSGFzaEZyb21TdWJtaXR9IG9mIGtpbmQgJHtraW5kfSBhbmQgc3VibWlzc2lvbiB0eXBlICR7c3VibWlzc2lvblR5cGV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXBkYXRlZEVudGl0eTtcbiAgICB9XG59XG4iXSwidmVyc2lvbiI6M30=