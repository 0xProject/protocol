{"file":"/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts","mappings":";;;AACA,mDAAmD;AAGnD,sCAAmC;AAEnC,MAAM,8BAA8B,GAAG,CAAC,CAAC;AAEzC;;;;;;;;;;;;;GAaG;AACI,KAAK,UAAU,yBAAyB,CAC3C,QAA4B,EAC5B,cAAsB,EACtB,cAAyB,EACzB,iBAA4B,EAC5B,gBAAwB;IAExB,kDAAkD;IAClD,MAAM,kBAAkB,GAAG,iBAAiB,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC,KAAK,CAAC,8BAA8B,CAAC,CAAC;IAC3G,MAAM,gBAAgB,GAAG,cAAc,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC;IAChE,IAAI,CAAC,gBAAgB,EAAE;QACnB,eAAM,CAAC,KAAK,CACR;YACI,cAAc;YACd,cAAc,EAAE,cAAc,CAAC,QAAQ,EAAE;YACzC,kBAAkB,EAAE,kBAAkB,CAAC,QAAQ,EAAE;YACjD,iBAAiB,EAAE,iBAAiB,CAAC,QAAQ,EAAE;SAClD,EACD,+CAA+C,CAClD,CAAC;KACL;IACD,IAAI,CAAC,gBAAgB,EAAE;QACnB,OAAO,KAAK,CAAC;KAChB;IAED,2CAA2C;IAC3C,MAAM,gBAAgB,GAAG,MAAM,QAAQ,CAAC,mBAAmB,CAAC,cAAc,CAAC,CAAC;IAC5E,MAAM,gBAAgB,GAAG,MAAM,QAAQ,CAAC,mBAAmB,CAAC,cAAc,EAAE,kCAAiB,CAAC,OAAO,CAAC,CAAC;IACvG,MAAM,wBAAwB,GAAG,gBAAgB,CAAC,QAAQ,EAAE,KAAK,gBAAgB,CAAC,QAAQ,EAAE,CAAC;IAC7F,IAAI,CAAC,wBAAwB,EAAE;QAC3B,eAAM,CAAC,KAAK,CACR;YACI,cAAc;YACd,gBAAgB,EAAE,gBAAgB,CAAC,QAAQ,EAAE;YAC7C,gBAAgB,EAAE,gBAAgB,CAAC,QAAQ,EAAE;SAChD,EACD,mDAAmD,CACtD,CAAC;KACL;IAED,OAAO,wBAAwB,CAAC;AACpC,CAAC;AAzCD,8DAyCC","names":[],"sources":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/rfqm_worker_balance_utils.ts"],"sourcesContent":["import { BigNumber } from '@0x/utils';\nimport { BlockParamLiteral } from 'ethereum-types';\nimport { providers } from 'ethers';\n\nimport { logger } from '../logger';\n\nconst MIN_NUM_TRADES_FOR_HEALTHCHECK = 3;\n\n/**\n * Returns true if a metatransaction worker is able to pick up new work, i.e. the\n * worker has enough balance to trade and has no pending transactions.\n *\n * The function will also emit logs if it was to find issues.\n *\n * @param wrapper the Web3Wrapper instance\n * @param accountAddress the EOA address of the worker\n * @param accountBalance the balance of the worker\n * @param gasPriceBaseUnits the current gas price\n * @param gasEstimatePerTx the gas estimate for a transaction. If a chain supports different types of trades (for example, RFQm and metatxn),\n *                        this value should be the max gas estimate among different types.\n * @returns true if the metatransaction worker can pick up work.\n */\nexport async function isWorkerReadyAndAbleAsync(\n    provider: providers.Provider,\n    accountAddress: string,\n    accountBalance: BigNumber,\n    gasPriceBaseUnits: BigNumber,\n    gasEstimatePerTx: number,\n): Promise<boolean> {\n    // Check worker has enough ETH to support 3 trades\n    const minimumCostToTrade = gasPriceBaseUnits.times(gasEstimatePerTx).times(MIN_NUM_TRADES_FOR_HEALTHCHECK);\n    const hasEnoughBalance = accountBalance.gte(minimumCostToTrade);\n    if (!hasEnoughBalance) {\n        logger.error(\n            {\n                accountAddress,\n                accountBalance: accountBalance.toString(),\n                minimumCostToTrade: minimumCostToTrade.toString(),\n                gasPriceBaseUnits: gasPriceBaseUnits.toString(),\n            },\n            'Worker does not have enough balance to trade.',\n        );\n    }\n    if (!hasEnoughBalance) {\n        return false;\n    }\n\n    // check worker has no pending transactions\n    const lastNonceOnChain = await provider.getTransactionCount(accountAddress);\n    const lastNoncePending = await provider.getTransactionCount(accountAddress, BlockParamLiteral.Pending);\n    const hasNoPendingTransactions = lastNonceOnChain.toString() === lastNoncePending.toString();\n    if (!hasNoPendingTransactions) {\n        logger.error(\n            {\n                accountAddress,\n                lastNonceOnChain: lastNonceOnChain.toString(),\n                lastNoncePending: lastNoncePending.toString(),\n            },\n            'Worker has pending transactions and cannot trade.',\n        );\n    }\n\n    return hasNoPendingTransactions;\n}\n"],"version":3}