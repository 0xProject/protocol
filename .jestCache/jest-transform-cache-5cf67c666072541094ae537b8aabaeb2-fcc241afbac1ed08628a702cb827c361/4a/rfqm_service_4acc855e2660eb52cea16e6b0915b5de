adde9f5e5295d27a1176b2f7909b968c
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RfqmService = void 0;
// tslint:disable:max-file-line-count
const api_utils_1 = require("@0x/api-utils");
const protocol_utils_1 = require("@0x/protocol-utils");
const token_metadata_1 = require("@0x/token-metadata");
const utils_1 = require("@0x/utils");
const web3_wrapper_1 = require("@0x/web3-wrapper");
const attempt_1 = require("@lifeomic/attempt");
const _ = require("lodash");
const prom_client_1 = require("prom-client");
const config_1 = require("../config");
const constants_1 = require("../core/constants");
const types_1 = require("../entities/types");
const config_2 = require("../config");
const errors_1 = require("../core/errors");
const logger_1 = require("../logger");
const fee_utils_1 = require("../core/fee_utils");
const pair_utils_1 = require("../core/pair_utils");
const types_2 = require("../core/types");
const quote_comparison_utils_1 = require("../utils/quote_comparison_utils");
const quote_report_utils_1 = require("../utils/quote_report_utils");
const quote_server_client_1 = require("../utils/quote_server_client");
const rfqm_db_utils_1 = require("../utils/rfqm_db_utils");
const rfqm_health_check_1 = require("../utils/rfqm_health_check");
const signature_utils_1 = require("../utils/signature_utils");
const types_3 = require("@0x/types");
const RFQM_QUOTE_INSERTED = new prom_client_1.Counter({
    name: 'rfqm_quote_inserted',
    help: 'An RfqmQuote was inserted in the DB',
    labelNames: ['apiKey', 'integratorId', 'makerUri'],
});
const RFQM_SIGNED_QUOTE_NOT_FOUND = new prom_client_1.Counter({
    name: 'rfqm_signed_quote_not_found',
    labelNames: ['chain_id'],
    help: 'A submitted quote did not match any stored quotes',
});
const RFQM_TAKER_AND_TAKERTOKEN_TRADE_EXISTS = new prom_client_1.Counter({
    name: 'rfqm_signed_quote_taker_and_takertoken_trade_exists',
    labelNames: ['chain_id'],
    help: 'A trade was submitted when the system already had a pending trade for the same taker and takertoken',
});
const RFQM_SUBMIT_BALANCE_CHECK_FAILED = new prom_client_1.Counter({
    name: 'rfqm_submit_balance_check_failed',
    labelNames: ['makerAddress', 'chain_id'],
    help: 'A trade was submitted but our on-chain balance check failed',
});
const RFQM_MAKER_BLOCKED_FOR_LLR_COOLDOWN = new prom_client_1.Counter({
    name: 'rfqm_maker_blocked_for_llr_cooldown',
    help: 'A maker get blocked because of LLR cooldown',
    labelNames: ['maker_id', 'chain_id', 'pair_key'],
});
const RFQM_MM_RETURNED_DIFFERENT_AMOUNT = new prom_client_1.Counter({
    name: 'rfqm_mm_returned_different_amount_total',
    help: 'A maker responded a quote with different amount than requested',
    labelNames: ['maker_uri', 'chain_id', 'modification_type'],
});
const PRICE_DECIMAL_PLACES = 6;
const getTokenAddressFromSymbol = (symbol, chainId) => {
    return (0, token_metadata_1.getTokenMetadataIfExists)(symbol, chainId).tokenAddress;
};
/**
 * RfqmService is the coordination layer for HTTP based RFQM flows.
 */
class RfqmService {
    constructor(_chainId, _feeService, _feeModelVersion, _contractAddresses, _registryAddress, _blockchainUtils, _dbUtils, _sqsProducer, _quoteServerClient, _minExpiryDurationMs, _cacheClient, _rfqMakerBalanceCacheService, _rfqMakerManager, _tokenMetadataManager, _kafkaProducer, _quoteReportTopic) {
        this._chainId = _chainId;
        this._feeService = _feeService;
        this._feeModelVersion = _feeModelVersion;
        this._contractAddresses = _contractAddresses;
        this._registryAddress = _registryAddress;
        this._blockchainUtils = _blockchainUtils;
        this._dbUtils = _dbUtils;
        this._sqsProducer = _sqsProducer;
        this._quoteServerClient = _quoteServerClient;
        this._minExpiryDurationMs = _minExpiryDurationMs;
        this._cacheClient = _cacheClient;
        this._rfqMakerBalanceCacheService = _rfqMakerBalanceCacheService;
        this._rfqMakerManager = _rfqMakerManager;
        this._tokenMetadataManager = _tokenMetadataManager;
        this._kafkaProducer = _kafkaProducer;
        this._quoteReportTopic = _quoteReportTopic;
        this._nativeTokenSymbol = (0, token_metadata_1.nativeTokenSymbol)(this._chainId);
        this._nativeTokenAddress = getTokenAddressFromSymbol(this._nativeTokenSymbol, this._chainId);
        this._nativeWrappedTokenSymbol = (0, token_metadata_1.nativeWrappedTokenSymbol)(this._chainId);
        this._nativeWrappedTokenAddress = getTokenAddressFromSymbol(this._nativeWrappedTokenSymbol, this._chainId);
    }
    static _getSellAmountGivenBuyAmountAndQuote(buyAmount, quotedTakerAmount, quotedMakerAmount) {
        // Solving for x given the following proportion:
        // x / buyAmount = quotedTakerAmount / quotedMakerAmount
        return quotedTakerAmount.div(quotedMakerAmount).times(buyAmount).decimalPlaces(0);
    }
    static _getBuyAmountGivenSellAmountAndQuote(sellAmount, quotedTakerAmount, quotedMakerAmount) {
        // Solving for y given the following proportion:
        // y / sellAmount =  quotedMakerAmount / quotedTakerAmount
        return quotedMakerAmount.div(quotedTakerAmount).times(sellAmount).decimalPlaces(0);
    }
    /**
     * Transform a transaction submission to type `TransactionDetails`.
     *
     * @returns Corresponding `TransactionDetails` or null if transaction hash is not available.
     */
    static _transformTransactionSubmission(transactionSubmission) {
        const { transactionHash: hash, createdAt } = transactionSubmission;
        return hash ? { hash, timestamp: createdAt.getTime() } : null;
    }
    /**
     * Get details of the successful transaction submission (there will only be one).
     *
     * @param opts Options object that contains:
     *             - `hash`: The hash of the order or metatransaction.
     *             - `type`: The type of the transaction submissions.
     *             - `transactionSubmssions`: List of transaction submissions to filter.
     * @returns The details (hash and timestamp) of the successful transaction submission.
     * @throws - When the number of the successful transaction submission is not 1
     *         - The successful transaction submission does not have transaction hash
     */
    static _getSuccessfulTransactionSubmissionDetails(opts) {
        const { hash, type, transactionSubmssions } = opts;
        const successfulTransactionSubmissions = transactionSubmssions.filter((s) => s.status === types_1.RfqmTransactionSubmissionStatus.SucceededUnconfirmed ||
            s.status === types_1.RfqmTransactionSubmissionStatus.SucceededConfirmed);
        if (successfulTransactionSubmissions.length !== 1) {
            throw new Error(`Expected exactly one successful transaction submission of type ${type} for hash ${hash}; found ${successfulTransactionSubmissions.length}`);
        }
        const successfulTransactionSubmission = successfulTransactionSubmissions[0];
        const successfulTransactionSubmissionDetails = this._transformTransactionSubmission(successfulTransactionSubmission);
        if (!successfulTransactionSubmissionDetails) {
            throw new Error(`Successful transaction of type ${type} does not have a hash ${hash}`);
        }
        return successfulTransactionSubmissionDetails;
    }
    static _jobFailureStatusToReason(failureStatus) {
        switch (failureStatus) {
            case types_1.RfqmJobStatus.FailedEthCallFailed:
                return types_1.JobFailureReason.TransactionSimulationFailed;
            case types_1.RfqmJobStatus.FailedExpired:
                return types_1.JobFailureReason.OrderExpired;
            case types_1.RfqmJobStatus.FailedLastLookDeclined:
                return types_1.JobFailureReason.LastLookDeclined;
            case types_1.RfqmJobStatus.FailedSignFailed:
                return types_1.JobFailureReason.MarketMakerSignatureError;
            case types_1.RfqmJobStatus.FailedRevertedConfirmed:
            case types_1.RfqmJobStatus.FailedRevertedUnconfirmed:
                return types_1.JobFailureReason.TransactionReverted;
            default:
                return types_1.JobFailureReason.InternalError;
        }
    }
    /**
     * Passthrough to TokenMetadataManager's `getTokenDecimalsAsync` method
     */
    async getTokenDecimalsAsync(tokenAddress) {
        return this._tokenMetadataManager.getTokenDecimalsAsync(tokenAddress);
    }
    /**
     * Fetch the best indicative quote available. Returns null if no valid quotes found
     */
    async fetchIndicativeQuoteAsync(params, extendedQuoteReportSubmissionBy = 'rfqm') {
        var _a;
        const affiliateAddress = (_a = params.affiliateAddress) !== null && _a !== void 0 ? _a : params.integrator.affiliateAddress;
        // Retrieve quote context
        const quoteContext = this._retrieveQuoteContext({ ...params, affiliateAddress }, /* isFirm */ false);
        const { isFirm, takerAmount, makerAmount, takerToken, makerToken, originalMakerToken, takerTokenDecimals, makerTokenDecimals, takerAddress, isSelling, assetFillAmount, integrator, } = quoteContext;
        // (Optimization) When `quotesWithGasFee` is returned, we can use this value and revise it, to avoid another fetch to MMs
        const { feeWithDetails, quotesWithGasFee, ammQuoteUniqueId } = await this._feeService.calculateFeeAsync(quoteContext, this._fetchIndicativeQuotesAsync.bind(this));
        // Calculate fees (other than gas fee) to charge MMs
        const otherFeesAmount = feeWithDetails.amount.minus(feeWithDetails.details.gasFeeAmount);
        const finalQuotes = quotesWithGasFee
            ? await this._feeService.reviseQuotesAsync(quotesWithGasFee, otherFeesAmount, quoteContext)
            : await this._fetchIndicativeQuotesAsync(quoteContext, feeWithDetails);
        // (Quote Report) If otherFees > 0, then we "revised" the quotes from MMs. We want to save both the original quotes (aka intermediateQuotes) and the revised (finalQuotes)
        const intermediateQuotes = quotesWithGasFee && otherFeesAmount.gt(protocol_utils_1.ZERO) ? quotesWithGasFee : [];
        // Get the best quote
        const bestQuote = (0, quote_comparison_utils_1.getBestQuote)(finalQuotes, isSelling, takerToken, makerToken, assetFillAmount, this._minExpiryDurationMs);
        const isLiquidityAvailable = bestQuote !== null;
        // Quote Report
        if (this._kafkaProducer) {
            await quote_report_utils_1.quoteReportUtils.publishRFQMQuoteReportAsync({
                isFirmQuote: isFirm,
                taker: takerAddress,
                buyTokenAddress: originalMakerToken,
                sellTokenAddress: takerToken,
                buyAmount: makerAmount,
                sellAmount: takerAmount,
                integratorId: integrator === null || integrator === void 0 ? void 0 : integrator.integratorId,
                finalQuotes,
                intermediateQuotes,
                bestQuote,
                fee: (0, fee_utils_1.feeToStoredFee)(feeWithDetails),
                ammQuoteUniqueId,
                isLiquidityAvailable,
            }, this._kafkaProducer, this._quoteReportTopic, extendedQuoteReportSubmissionBy);
        }
        // No quotes found
        if (!isLiquidityAvailable) {
            return null;
        }
        // Prepare the price
        const makerAmountInUnit = web3_wrapper_1.Web3Wrapper.toUnitAmount(bestQuote.makerAmount, makerTokenDecimals);
        const takerAmountInUnit = web3_wrapper_1.Web3Wrapper.toUnitAmount(bestQuote.takerAmount, takerTokenDecimals);
        const price = isSelling ? makerAmountInUnit.div(takerAmountInUnit) : takerAmountInUnit.div(makerAmountInUnit);
        // The way the BigNumber round down behavior (https://mikemcl.github.io/bignumber.js/#dp) works requires us
        // to add 1 to PRICE_DECIMAL_PLACES in order to actually come out with the decimal places specified.
        const roundedPrice = price.decimalPlaces(PRICE_DECIMAL_PLACES + 1, utils_1.BigNumber.ROUND_DOWN);
        // Prepare response
        return {
            price: roundedPrice,
            gas: feeWithDetails.details.gasPrice,
            buyAmount: bestQuote.makerAmount,
            buyTokenAddress: originalMakerToken,
            sellAmount: bestQuote.takerAmount,
            sellTokenAddress: bestQuote.takerToken,
            allowanceTarget: this._contractAddresses.exchangeProxy,
        };
    }
    /**
     * Fetch the best firm quote available, including a metatransaction. Returns null if no valid quotes found
     */
    async fetchFirmQuoteAsync(params, extendedQuoteReportSubmissionBy = 'rfqm') {
        var _a;
        const affiliateAddress = (_a = params.affiliateAddress) !== null && _a !== void 0 ? _a : params.integrator.affiliateAddress;
        // Retrieve quote context
        const quoteContext = this._retrieveQuoteContext({ ...params, affiliateAddress }, /* isFirm */ true);
        const { isFirm, takerAmount, makerAmount, takerToken, makerToken, originalMakerToken, takerTokenDecimals, makerTokenDecimals, takerAddress, integrator, isUnwrap, isSelling, assetFillAmount, } = quoteContext;
        // (Optimization) When `quotesWithGasFee` is returned, we can sometimes reuse it, to avoid another fetch to MMs
        // NOTE: this optimization differs from the optimization for indicative quotes because we do NOT revise firm quotes
        const { feeWithDetails, quotesWithGasFee, ammQuoteUniqueId } = await this._feeService.calculateFeeAsync(quoteContext, this._fetchIndicativeQuotesAsync.bind(this));
        // Calculate fees (other than gas fee) to charge MMs. If there are other fees, we don't reuse `quotesWithGasFee`
        const otherFeesAmount = feeWithDetails.amount.minus(feeWithDetails.details.gasFeeAmount);
        // If `quotesWithGasFee` have been obtained and there are no other fees, reuse the quotes. Otherwise call MMs with full fee to get new quotes.
        const finalQuotes = quotesWithGasFee && otherFeesAmount.eq(protocol_utils_1.ZERO)
            ? await this._convertToFirmQuotesAsync(quotesWithGasFee, quoteContext)
            : await this._fetchFirmQuotesAsync(quoteContext, feeWithDetails);
        // (Quote Report) If `quotesWithGasFee` have not been reused, save them as intermediate quotes
        const intermediateQuotes = quotesWithGasFee && otherFeesAmount.gt(protocol_utils_1.ZERO) ? quotesWithGasFee : [];
        // (Maker Balance Cache) Fetch maker balances to validate whether quotes are fully fillable
        let quotedMakerBalances;
        const quotedERC20Owners = finalQuotes.map((quote) => {
            return {
                owner: quote.order.maker,
                token: makerToken,
            };
        });
        try {
            quotedMakerBalances = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(this._chainId, quotedERC20Owners);
        }
        catch (e) {
            logger_1.logger.error({ chainId: this._chainId, quotedERC20Owners, errorMessage: e.message }, 'Failed to fetch maker balances to validate firm quotes');
        }
        // Get the best quote
        const bestQuote = (0, quote_comparison_utils_1.getBestQuote)(finalQuotes, isSelling, takerToken, makerToken, assetFillAmount, this._minExpiryDurationMs, quotedMakerBalances);
        const isLiquidityAvailable = bestQuote !== null;
        const storedFeeWithDetails = (0, fee_utils_1.feeToStoredFee)(feeWithDetails);
        let quoteReportId = null;
        // Quote Report
        if (this._kafkaProducer) {
            quoteReportId = await quote_report_utils_1.quoteReportUtils.publishRFQMQuoteReportAsync({
                isFirmQuote: isFirm,
                taker: takerAddress,
                buyTokenAddress: originalMakerToken,
                sellTokenAddress: takerToken,
                buyAmount: makerAmount,
                sellAmount: takerAmount,
                integratorId: integrator === null || integrator === void 0 ? void 0 : integrator.integratorId,
                finalQuotes,
                intermediateQuotes,
                bestQuote,
                fee: storedFeeWithDetails,
                ammQuoteUniqueId,
                isLiquidityAvailable,
            }, this._kafkaProducer, this._quoteReportTopic, extendedQuoteReportSubmissionBy);
        }
        // No quote found
        if (!isLiquidityAvailable) {
            return { quote: null, quoteReportId };
        }
        // Get the makerUri
        const makerUri = bestQuote.makerUri;
        if (makerUri === undefined) {
            logger_1.logger.error({ makerAddress: bestQuote.order.maker }, 'makerUri unknown for maker address');
            throw new Error(`makerUri unknown for maker address ${bestQuote.order.maker}`);
        }
        // Prepare the price
        const makerAmountInUnit = web3_wrapper_1.Web3Wrapper.toUnitAmount(bestQuote.order.makerAmount, makerTokenDecimals);
        const takerAmountInUnit = web3_wrapper_1.Web3Wrapper.toUnitAmount(bestQuote.order.takerAmount, takerTokenDecimals);
        const price = isSelling ? makerAmountInUnit.div(takerAmountInUnit) : takerAmountInUnit.div(makerAmountInUnit);
        // The way the BigNumber round down behavior (https://mikemcl.github.io/bignumber.js/#dp) works requires us
        // to add 1 to PRICE_DECIMAL_PLACES in order to actually come out with the decimal places specified.
        const roundedPrice = price.decimalPlaces(PRICE_DECIMAL_PLACES + 1, utils_1.BigNumber.ROUND_DOWN);
        // Prepare the final takerAmount and makerAmount
        const sellAmount = isSelling
            ? // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                takerAmount
            : RfqmService._getSellAmountGivenBuyAmountAndQuote(
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            makerAmount, bestQuote.order.takerAmount, bestQuote.order.makerAmount);
        const buyAmount = isSelling
            ? RfqmService._getBuyAmountGivenSellAmountAndQuote(
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            takerAmount, bestQuote.order.takerAmount, bestQuote.order.makerAmount)
            : // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                makerAmount;
        // Get the Order and its hash
        const orderHash = bestQuote.order.getHash();
        const otcOrder = bestQuote.order;
        await this._dbUtils.writeV2QuoteAsync({
            orderHash,
            chainId: this._chainId,
            fee: storedFeeWithDetails,
            order: (0, rfqm_db_utils_1.otcOrderToStoredOtcOrder)(otcOrder),
            makerUri,
            affiliateAddress,
            integratorId: integrator.integratorId,
            isUnwrap,
            takerSpecifiedSide: params.sellAmount ? 'takerToken' : 'makerToken',
        });
        const approval = params.checkApproval
            ? // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                await this.getGaslessApprovalResponseAsync(takerAddress, takerToken, sellAmount)
            : null;
        RFQM_QUOTE_INSERTED.labels(integrator.integratorId, integrator.integratorId, makerUri).inc();
        return {
            quote: {
                type: types_2.GaslessTypes.OtcOrder,
                price: roundedPrice,
                gas: feeWithDetails.details.gasPrice,
                buyAmount,
                buyTokenAddress: originalMakerToken,
                sellAmount,
                sellTokenAddress: bestQuote.order.takerToken,
                allowanceTarget: this._contractAddresses.exchangeProxy,
                order: bestQuote.order,
                orderHash,
                // use approval variable directly is not ideal as we don't want to include approval field if `approval` is null
                ...(approval && { approval }),
            },
            quoteReportId,
        };
    }
    /**
     * Get the value of the approval response in firm quote responses. The approval response contains whether an approval is required, is gasless approval
     * is available for the token (optional), the type of the gasless approval (optional) and the EIP712 context (optional).
     *
     * @param takerAddress The address of the taker.
     * @param tokenToApprove Token address to be approved.
     * @param sellAmount Amount of token to sell in base unit.
     * @returns The approval response.
     */
    async getGaslessApprovalResponseAsync(takerAddress, tokenToApprove, sellAmount) {
        const allowance = await this._blockchainUtils.getAllowanceAsync(tokenToApprove, takerAddress, this._blockchainUtils.getExchangeProxyAddress());
        const isRequired = allowance.lte(sellAmount);
        if (!isRequired) {
            return {
                isRequired,
            };
        }
        const gaslessApproval = await this._blockchainUtils.getGaslessApprovalAsync(this._chainId, tokenToApprove, takerAddress);
        const isGaslessAvailable = gaslessApproval !== null;
        if (!isGaslessAvailable) {
            return {
                isRequired,
                isGaslessAvailable,
            };
        }
        return {
            isRequired,
            isGaslessAvailable,
            type: gaslessApproval.kind,
            eip712: gaslessApproval.eip712,
        };
    }
    async getStatusAsync(tradeHash) {
        const transformSubmissions = (submissions) => {
            // `_transformTransactionSubmission` is a static method so no-unbound-method does not apply here
            // tslint:disable-next-line:no-unbound-method
            return submissions.map(RfqmService._transformTransactionSubmission).flatMap((s) => (s ? s : []));
        };
        const job = await Promise.all([
            this._dbUtils.findV2JobByOrderHashAsync(tradeHash),
            this._dbUtils.findMetaTransactionJobByMetaTransactionHashAsync(tradeHash),
        ]).then((jobs) => jobs.find((x) => x));
        if (!job) {
            return null;
        }
        const { status, expiry } = job;
        if (status === types_1.RfqmJobStatus.PendingEnqueued && expiry.multipliedBy(constants_1.ONE_SECOND_MS).lt(Date.now())) {
            // the workers are dead/on vacation and the expiration time has passed
            return {
                status: 'failed',
                transactions: [],
                ...(config_2.REASON_ON_STATUS_ERROR_RESPONSE_ENABLED && {
                    reason: types_1.JobFailureReason.OrderExpired,
                }),
            };
        }
        const tradeTransactionSubmissions = job.kind === 'rfqm_v2_job'
            ? await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(job.orderHash, types_1.RfqmTransactionSubmissionType.Trade)
            : await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(job.id, types_1.RfqmTransactionSubmissionType.Trade);
        const shouldIncludeApproval = !!job.approval;
        let approvalTransactionSubmissions = [];
        if (shouldIncludeApproval) {
            approvalTransactionSubmissions =
                job.kind === 'rfqm_v2_job'
                    ? await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(job.orderHash, types_1.RfqmTransactionSubmissionType.Approval)
                    : await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(job.id, types_1.RfqmTransactionSubmissionType.Approval);
        }
        switch (status) {
            case types_1.RfqmJobStatus.PendingEnqueued:
            case types_1.RfqmJobStatus.PendingProcessing:
            case types_1.RfqmJobStatus.PendingLastLookAccepted:
                return { status: 'pending', transactions: [] };
            case types_1.RfqmJobStatus.PendingSubmitted:
                return {
                    status: 'submitted',
                    transactions: transformSubmissions(tradeTransactionSubmissions),
                    ...(shouldIncludeApproval && {
                        approvalTransactions: transformSubmissions(approvalTransactionSubmissions),
                    }),
                };
            case types_1.RfqmJobStatus.FailedEthCallFailed:
            case types_1.RfqmJobStatus.FailedExpired:
            case types_1.RfqmJobStatus.FailedLastLookDeclined:
            case types_1.RfqmJobStatus.FailedPresignValidationFailed:
            case types_1.RfqmJobStatus.FailedRevertedConfirmed:
            case types_1.RfqmJobStatus.FailedRevertedUnconfirmed:
            case types_1.RfqmJobStatus.FailedSignFailed:
            case types_1.RfqmJobStatus.FailedSubmitFailed:
            case types_1.RfqmJobStatus.FailedValidationNoCallData:
            case types_1.RfqmJobStatus.FailedValidationNoFee:
            case types_1.RfqmJobStatus.FailedValidationNoMakerUri:
            case types_1.RfqmJobStatus.FailedValidationNoOrder:
            case types_1.RfqmJobStatus.FailedValidationNoTakerSignature:
                return {
                    status: 'failed',
                    transactions: transformSubmissions(tradeTransactionSubmissions),
                    ...(shouldIncludeApproval && {
                        approvalTransactions: transformSubmissions(approvalTransactionSubmissions),
                    }),
                    ...(config_2.REASON_ON_STATUS_ERROR_RESPONSE_ENABLED && {
                        reason: RfqmService._jobFailureStatusToReason(status),
                    }),
                };
            case types_1.RfqmJobStatus.SucceededConfirmed:
            case types_1.RfqmJobStatus.SucceededUnconfirmed:
                return {
                    status: status === types_1.RfqmJobStatus.SucceededUnconfirmed ? 'succeeded' : 'confirmed',
                    transactions: [
                        RfqmService._getSuccessfulTransactionSubmissionDetails({
                            hash: job.getHash(),
                            type: types_1.RfqmTransactionSubmissionType.Trade,
                            transactionSubmssions: tradeTransactionSubmissions,
                        }),
                    ],
                    ...(shouldIncludeApproval && {
                        approvalTransactions: [
                            RfqmService._getSuccessfulTransactionSubmissionDetails({
                                hash: job.getHash(),
                                type: types_1.RfqmTransactionSubmissionType.Approval,
                                transactionSubmssions: approvalTransactionSubmissions,
                            }),
                        ],
                    }),
                };
            default:
                ((_x) => {
                    throw new Error('Unreachable');
                })(status);
        }
    }
    /**
     * Runs checks to determine the health of the RFQm system. The results may be distilled to a format needed by integrators.
     */
    async runHealthCheckAsync() {
        const heartbeats = await this._dbUtils.findRfqmWorkerHeartbeatsAsync(this._chainId);
        let gasPrice;
        try {
            gasPrice = await this._feeService.getGasPriceEstimationAsync();
        }
        catch (error) {
            logger_1.logger.warn({ errorMessage: error.message }, 'Failed to get gas price for health check');
        }
        return (0, rfqm_health_check_1.computeHealthCheckAsync)(config_1.RFQM_MAINTENANCE_MODE, this._rfqMakerManager.getRfqmV2MakerOfferings(), this._sqsProducer, heartbeats, this._chainId, gasPrice);
    }
    /**
     * Validates and enqueues the Taker Signed Otc Order with approval for submission.
     * Can also be used to submit order without approval if approval params are not supplied.
     */
    async submitTakerSignedOtcOrderWithApprovalAsync(params) {
        let submitRfqmSignedQuoteWithApprovalRes;
        const { approval, trade } = params;
        const rfqmApprovalOpts = approval
            ? await this.createApprovalAsync(approval, trade.order.getHash(), trade.order.takerToken)
            : undefined;
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line prefer-const
        submitRfqmSignedQuoteWithApprovalRes = await this.submitTakerSignedOtcOrderAsync(trade, rfqmApprovalOpts);
        return submitRfqmSignedQuoteWithApprovalRes;
    }
    /**
     * Processes a signed approval sent to the submission endpoint in order to
     * create the approval data needed by the job.
     */
    async createApprovalAsync(approval, tradeHash, takerToken) {
        let { signature } = approval;
        // validate and convert EIP712 context to corresponding Approval object
        const parsedApproval = this._convertEIP712ContextToApproval(approval.eip712, tradeHash);
        // pad approval signature if there are missing bytes
        const paddedSignature = (0, signature_utils_1.padSignature)(signature);
        if (paddedSignature.r !== signature.r || paddedSignature.s !== signature.s) {
            logger_1.logger.warn({ tradeHash, r: paddedSignature.r, s: paddedSignature.s }, 'Got approval signature with missing bytes');
            signature = paddedSignature;
        }
        // perform an eth_call on the approval object and signature
        try {
            const approvalCalldata = await this._blockchainUtils.generateApprovalCalldataAsync(takerToken, parsedApproval, signature);
            await (0, attempt_1.retry)(async () => {
                // Use `estimateGasForAsync` to simulate the transaction. In ethers.js, provider.call and
                // provider.send('eth_call', ...) might not throw exception and the behavior might be dependent
                // on providers. Revisit this later
                return this._blockchainUtils.estimateGasForAsync({ to: takerToken, data: approvalCalldata });
            }, {
                delay: constants_1.ONE_SECOND_MS,
                factor: 1,
                maxAttempts: 3,
                handleError: (error, context, _options) => {
                    const { attemptNum: attemptNumber, attemptsRemaining } = context;
                    logger_1.logger.warn({
                        attemptNumber,
                        attemptsRemaining,
                        errorMessage: error.message,
                        stack: error.stack,
                        tradeHash,
                    }, 'Error during eth_call approval validation. Retrying.');
                },
            });
        }
        catch (error) {
            logger_1.logger.error({ errorMessage: error.message }, 'Eth call approval validation failed');
            throw new Error('Eth call approval validation failed');
        }
        return {
            approval: parsedApproval,
            approvalSignature: signature,
        };
    }
    /**
     * Validates and enqueues the Taker Signed Otc Order for submission
     */
    async submitTakerSignedOtcOrderAsync(params, rfqmApprovalOpts) {
        const { order } = params;
        let { signature: takerSignature } = params;
        const orderHash = order.getHash();
        const takerAddress = order.taker.toLowerCase();
        const makerAddress = order.maker.toLowerCase();
        const takerToken = order.takerToken.toLowerCase();
        const makerToken = order.makerToken.toLowerCase();
        // check that the orderHash is indeed a recognized quote
        const quote = await this._dbUtils.findV2QuoteByOrderHashAsync(orderHash);
        if (!quote) {
            RFQM_SIGNED_QUOTE_NOT_FOUND.inc();
            throw new errors_1.NotFoundError('quote not found');
        }
        // validate that the expiration window is long enough to fill quote
        const currentTimeMs = new Date().getTime();
        if (!order.expiry.times(constants_1.ONE_SECOND_MS).isGreaterThan(currentTimeMs + this._minExpiryDurationMs)) {
            throw new errors_1.ValidationError([
                {
                    field: 'expiryAndNonce',
                    code: errors_1.ValidationErrorCodes.FieldInvalid,
                    reason: `order will expire too soon`,
                },
            ]);
        }
        // validate that there is not a pending transaction for this taker and taker token
        const pendingJobs = await this._dbUtils.findV2JobsWithStatusesAsync([
            types_1.RfqmJobStatus.PendingEnqueued,
            types_1.RfqmJobStatus.PendingProcessing,
            types_1.RfqmJobStatus.PendingLastLookAccepted,
            types_1.RfqmJobStatus.PendingSubmitted,
        ]);
        if (pendingJobs.some((job) => {
            var _a, _b, _c, _d;
            return ((_a = job.order) === null || _a === void 0 ? void 0 : _a.order.taker.toLowerCase()) === ((_b = quote.order) === null || _b === void 0 ? void 0 : _b.order.taker.toLowerCase()) &&
                ((_c = job.order) === null || _c === void 0 ? void 0 : _c.order.takerToken.toLowerCase()) === ((_d = quote.order) === null || _d === void 0 ? void 0 : _d.order.takerToken.toLowerCase()) &&
                // Other logic handles the case where the same order is submitted twice
                job.orderHash !== quote.orderHash;
        })) {
            RFQM_TAKER_AND_TAKERTOKEN_TRADE_EXISTS.labels(this._chainId.toString()).inc();
            throw new api_utils_1.TooManyRequestsError('a pending trade for this taker and takertoken already exists');
        }
        // In the unlikely event that takers submit a signature with a missing byte, pad the signature.
        const paddedSignature = (0, signature_utils_1.padSignature)(takerSignature);
        if (paddedSignature.r !== takerSignature.r || paddedSignature.s !== takerSignature.s) {
            logger_1.logger.warn({ orderHash, r: paddedSignature.r, s: paddedSignature.s }, 'Got taker signature with missing bytes');
            takerSignature = paddedSignature;
        }
        // validate that the given taker signature is valid
        const signerAddress = (0, signature_utils_1.getSignerFromHash)(orderHash, takerSignature).toLowerCase();
        if (signerAddress !== takerAddress) {
            logger_1.logger.warn({ signerAddress, takerAddress, orderHash }, 'Signature is invalid');
            throw new errors_1.ValidationError([
                {
                    field: 'signature',
                    code: errors_1.ValidationErrorCodes.InvalidSignatureOrHash,
                    reason: `signature is not valid`,
                },
            ]);
        }
        // Validate that order is fillable by both the maker and the taker according to balances and/or allowances.
        // If rfqmApprovalOpts is not passed, allowances are not checked at this stage since gasless approval has not been done yet.
        const [makerBalance] = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(this._chainId, [
            {
                owner: makerAddress,
                token: makerToken,
            },
        ]);
        const [takerBalance] = rfqmApprovalOpts
            ? await this._blockchainUtils.getTokenBalancesAsync({ owner: takerAddress, token: takerToken })
            : await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync({
                owner: takerAddress,
                token: takerToken,
            });
        if (makerBalance.lt(order.makerAmount) || takerBalance.lt(order.takerAmount)) {
            RFQM_SUBMIT_BALANCE_CHECK_FAILED.labels(makerAddress, this._chainId.toString()).inc();
            logger_1.logger.warn({
                makerBalance,
                takerBalance,
                makerAddress,
                takerAddress,
                orderHash,
                order,
            }, 'Balance check failed while user was submitting');
            throw new errors_1.ValidationError([
                {
                    field: 'n/a',
                    code: errors_1.ValidationErrorCodes.InvalidOrder,
                    reason: `order is not fillable`,
                },
            ]);
        }
        // prepare the job
        let rfqmJobOpts = {
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            orderHash: quote.orderHash,
            createdAt: new Date(),
            expiry: order.expiry,
            chainId: this._chainId,
            integratorId: quote.integratorId ? quote.integratorId : null,
            makerUri: quote.makerUri,
            status: types_1.RfqmJobStatus.PendingEnqueued,
            fee: quote.fee,
            order: quote.order,
            takerSignature,
            affiliateAddress: quote.affiliateAddress,
            isUnwrap: quote.isUnwrap,
            takerSpecifiedSide: quote.takerSpecifiedSide,
        };
        // if approval opts are supplied, add params to job table
        if (rfqmApprovalOpts) {
            rfqmJobOpts = {
                ...rfqmJobOpts,
                ...rfqmApprovalOpts,
            };
        }
        // this insert will fail if a job has already been created, ensuring
        // that a signed quote cannot be queued twice
        try {
            // make sure job data is persisted to Postgres before queueing task
            await this._dbUtils.writeV2JobAsync(rfqmJobOpts);
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            await this._enqueueJobAsync(quote.orderHash, types_2.GaslessTypes.OtcOrder);
        }
        catch (error) {
            logger_1.logger.error({ errorMessage: error.message }, 'Failed to queue the quote for submission.');
            throw new errors_1.InternalServerError(`failed to queue the quote for submission, it may have already been submitted`);
        }
        return {
            type: types_2.GaslessTypes.OtcOrder,
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            orderHash: quote.orderHash,
        };
    }
    /**
     * Internal method to retrieve quote context, based on either indicative or firm quote parameters
     */
    _retrieveQuoteContext(params, isFirm) {
        const { sellAmount: takerAmount, buyAmount: makerAmount, sellToken: takerToken, buyToken: originalMakerToken, takerAddress, sellTokenDecimals: takerTokenDecimals, buyTokenDecimals: makerTokenDecimals, integrator, affiliateAddress, } = params;
        const isUnwrap = originalMakerToken === this._nativeTokenAddress;
        const isSelling = takerAmount !== undefined;
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const assetFillAmount = isSelling ? takerAmount : makerAmount;
        let makerToken = originalMakerToken;
        // If the originalMakerToken is the native token, we will trade the wrapped version and unwrap at the end
        if (isUnwrap) {
            makerToken = this._nativeWrappedTokenAddress;
        }
        return {
            workflow: 'rfqm',
            chainId: this._chainId,
            isFirm,
            takerAmount,
            makerAmount,
            takerToken,
            makerToken,
            originalMakerToken,
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            takerAddress: takerAddress,
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            trader: takerAddress,
            txOrigin: this._registryAddress,
            takerTokenDecimals,
            makerTokenDecimals,
            integrator,
            affiliateAddress,
            isUnwrap,
            isSelling,
            assetFillAmount,
            feeModelVersion: this._feeModelVersion,
        };
    }
    /**
     * Internal method to fetch indicative quotes.
     */
    async _fetchIndicativeQuotesAsync(quoteContext, fee) {
        // Extract quote context
        const { isSelling, assetFillAmount, takerToken, makerToken, integrator } = quoteContext;
        // Create Otc Order request options
        const otcOrderParams = quote_server_client_1.QuoteServerClient.makeQueryParameters({
            chainId: this._chainId,
            txOrigin: this._registryAddress,
            takerAddress: constants_1.NULL_ADDRESS,
            marketOperation: isSelling ? types_3.MarketOperation.Sell : types_3.MarketOperation.Buy,
            buyTokenAddress: makerToken,
            sellTokenAddress: takerToken,
            assetFillAmount,
            isLastLook: true,
            fee,
        });
        // If LLR Cooldown is enabled, filter out makers in cooldown before querying the quote server
        let makerIdsInCooldown;
        if (config_1.ENABLE_LLR_COOLDOWN) {
            try {
                makerIdsInCooldown = await this._cacheClient.getMakersInCooldownForPairAsync(this._chainId, makerToken, takerToken);
                // log blocked maker ids
                makerIdsInCooldown.map((makerId) => {
                    RFQM_MAKER_BLOCKED_FOR_LLR_COOLDOWN.labels(makerId, this._chainId.toString(), (0, pair_utils_1.toPairString)(makerToken, takerToken)).inc();
                    logger_1.logger.warn({
                        makerId,
                        makerToken,
                        takerToken,
                        timestamp: Date.now(),
                    }, 'Maker is on cooldown due to a bad last look reject');
                });
            }
            catch (e) {
                logger_1.logger.error({ chainId: this._chainId, makerToken, takerToken, errorMessage: e.message }, 'Encountered an error while filtering makers on LLR cooldown');
            }
        }
        const otcOrderMakerUris = this._rfqMakerManager.getRfqmV2MakerUrisForPair(makerToken, takerToken, integrator.whitelistMakerIds || null, makerIdsInCooldown || null);
        logger_1.logger.info({
            otcOrderParams,
        }, 'otcOrderParams for `batchGetPriceV2Async`');
        const quotes = await this._quoteServerClient.batchGetPriceV2Async(otcOrderMakerUris, integrator, otcOrderParams);
        // Log any quotes that are for the incorrect amount
        quotes.forEach((quote) => {
            const quotedAmount = isSelling ? quote.takerAmount : quote.makerAmount;
            if (quotedAmount.eq(assetFillAmount)) {
                return;
            }
            const modificationType = quotedAmount.gt(assetFillAmount) ? 'overfill' : 'underfill';
            logger_1.logger.warn({
                isSelling,
                overOrUnder: modificationType,
                requestedAmount: assetFillAmount,
                quotedAmount,
                quote,
            }, 'Maker returned an incorrect amount');
            RFQM_MM_RETURNED_DIFFERENT_AMOUNT.labels(quote.makerUri, this._chainId.toString(), modificationType).inc();
        });
        return quotes;
    }
    /**
     * Internal method to fetch firm quotes.
     */
    async _fetchFirmQuotesAsync(quoteContext, fee) {
        const quotes = await this._fetchIndicativeQuotesAsync(quoteContext, fee);
        return this._convertToFirmQuotesAsync(quotes, quoteContext);
    }
    /**
     * Internal method to convert indicative quotes to firm quotes.
     */
    async _convertToFirmQuotesAsync(quotes, quoteContext) {
        const { takerAddress } = quoteContext;
        const currentBucket = (await this._cacheClient.getNextOtcOrderBucketAsync(this._chainId)) % constants_1.GASLESS_OTC_ORDER_NUM_BUCKETS;
        const nowSeconds = Math.floor(Date.now() / constants_1.ONE_SECOND_MS);
        const otcQuotes = quotes.map((q) => this._mapIndicativeQuoteToFirmOtcQuote(q, 
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        takerAddress, new utils_1.BigNumber(currentBucket), new utils_1.BigNumber(nowSeconds)));
        const firmQuotesWithCorrectChainId = otcQuotes.filter((quote) => {
            if (quote.order.chainId !== this._chainId) {
                logger_1.logger.error({ quote }, 'Received a quote with incorrect chain id');
                return false;
            }
            return true;
        });
        return firmQuotesWithCorrectChainId;
    }
    async _enqueueJobAsync(orderHash, type) {
        await this._sqsProducer.send({
            // wait, it's all order hash?
            // always has been.
            groupId: orderHash,
            id: orderHash,
            body: JSON.stringify({ orderHash, type }),
            deduplicationId: orderHash,
        });
    }
    /**
     * Maps an IndicativeQuote to a FirmOtcQuote. Handles txOrigin, chainId, expiryAndNonce, etc
     */
    _mapIndicativeQuoteToFirmOtcQuote(q, takerAddress, nonceBucket, nonce) {
        return {
            kind: 'otc',
            makerUri: q.makerUri,
            order: new protocol_utils_1.OtcOrder({
                txOrigin: this._registryAddress,
                expiryAndNonce: protocol_utils_1.OtcOrder.encodeExpiryAndNonce(q.expiry, nonceBucket, nonce),
                maker: q.maker,
                taker: takerAddress,
                makerToken: q.makerToken,
                takerToken: q.takerToken,
                makerAmount: q.makerAmount,
                takerAmount: q.takerAmount,
                chainId: this._chainId,
                verifyingContract: this._contractAddresses.exchangeProxy,
            }),
        };
    }
    /**
     * Validates and converts EIP-712 context to an Approval object.
     * @param kind Type of gasless approval
     * @param eip712 EIP-712 context parsed from the handler
     * @param tradeHash The order hash or metatransaction hash,
     *  only used for logging in case of validation error
     * @returns The Approval object
     */
    // tslint:disable-next-line: prefer-function-over-method
    _convertEIP712ContextToApproval(eip712, tradeHash) {
        const { types, primaryType, domain, message } = eip712;
        switch (primaryType) {
            case 'MetaTransaction': {
                if (!_.isEqual(_.keys(message).sort(), types.MetaTransaction.map((dataField) => dataField.name).sort())) {
                    logger_1.logger.warn({ primaryType, tradeHash }, 'Invalid message field provided for Approval');
                    throw new errors_1.ValidationError([
                        {
                            field: 'message',
                            code: errors_1.ValidationErrorCodes.FieldInvalid,
                            reason: `Invalid message field provided for Approval of primaryType ${primaryType}`,
                        },
                    ]);
                }
                const executeMetaTransactionApproval = {
                    kind: types_2.GaslessApprovalTypes.ExecuteMetaTransaction,
                    eip712: {
                        types,
                        primaryType,
                        domain,
                        message: {
                            nonce: message.nonce,
                            from: message.from,
                            functionSignature: message.functionSignature,
                        },
                    },
                };
                return executeMetaTransactionApproval;
            }
            case 'Permit': {
                if (!_.isEqual(_.keys(message).sort(), types.Permit.map((dataField) => dataField.name).sort())) {
                    logger_1.logger.warn({ primaryType, tradeHash }, 'Invalid message field provided for Approval');
                    throw new errors_1.ValidationError([
                        {
                            field: 'message',
                            code: errors_1.ValidationErrorCodes.FieldInvalid,
                            reason: `Invalid message field provided for Approval of primaryType ${primaryType}`,
                        },
                    ]);
                }
                const permitApproval = {
                    kind: types_2.GaslessApprovalTypes.Permit,
                    eip712: {
                        types,
                        primaryType,
                        domain,
                        message: {
                            owner: message.owner,
                            spender: message.spender,
                            value: message.value,
                            nonce: message.nonce,
                            deadline: message.deadline,
                        },
                    },
                };
                return permitApproval;
            }
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(primaryType);
        }
    }
}
exports.RfqmService = RfqmService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9zZXJ2aWNlcy9yZnFtX3NlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEscUNBQXFDO0FBQ3JDLDZDQUFxRDtBQUVyRCx1REFBb0Q7QUFDcEQsdURBSzRCO0FBQzVCLHFDQUFzQztBQUN0QyxtREFBK0M7QUFDL0MsK0NBQTBDO0FBRTFDLDRCQUE0QjtBQUM1Qiw2Q0FBc0M7QUFHdEMsc0NBQXVFO0FBQ3ZFLGlEQUErRjtBQUcvRiw2Q0FLMkI7QUFDM0Isc0NBQW9FO0FBQ3BFLDJDQUEyRztBQUMzRyxzQ0FBbUM7QUFDbkMsaURBQW1EO0FBQ25ELG1EQUFrRDtBQUNsRCx5Q0FZdUI7QUFFdkIsNEVBQStEO0FBQy9ELG9FQUFvRjtBQUNwRixzRUFBaUU7QUFDakUsMERBQStFO0FBQy9FLGtFQUF3RjtBQUd4Riw4REFBMkU7QUFvQjNFLHFDQUE0QztBQUU1QyxNQUFNLG1CQUFtQixHQUFHLElBQUkscUJBQU8sQ0FBQztJQUNwQyxJQUFJLEVBQUUscUJBQXFCO0lBQzNCLElBQUksRUFBRSxxQ0FBcUM7SUFDM0MsVUFBVSxFQUFFLENBQUMsUUFBUSxFQUFFLGNBQWMsRUFBRSxVQUFVLENBQUM7Q0FDckQsQ0FBQyxDQUFDO0FBRUgsTUFBTSwyQkFBMkIsR0FBRyxJQUFJLHFCQUFPLENBQUM7SUFDNUMsSUFBSSxFQUFFLDZCQUE2QjtJQUNuQyxVQUFVLEVBQUUsQ0FBQyxVQUFVLENBQUM7SUFDeEIsSUFBSSxFQUFFLG1EQUFtRDtDQUM1RCxDQUFDLENBQUM7QUFDSCxNQUFNLHNDQUFzQyxHQUFHLElBQUkscUJBQU8sQ0FBQztJQUN2RCxJQUFJLEVBQUUscURBQXFEO0lBQzNELFVBQVUsRUFBRSxDQUFDLFVBQVUsQ0FBQztJQUN4QixJQUFJLEVBQUUscUdBQXFHO0NBQzlHLENBQUMsQ0FBQztBQUNILE1BQU0sZ0NBQWdDLEdBQUcsSUFBSSxxQkFBTyxDQUFDO0lBQ2pELElBQUksRUFBRSxrQ0FBa0M7SUFDeEMs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QkFDRCxNQUFNLGNBQWMsR0FBbUI7b0JBQ25DLElBQUksRUFBRSw0QkFBb0IsQ0FBQyxNQUFNO29CQUNqQyxNQUFNLEVBQUU7d0JBQ0osS0FBSzt3QkFDTCxXQUFXO3dCQUNYLE1BQU07d0JBQ04sT0FBTyxFQUFFOzRCQUNMLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSzs0QkFDcEIsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPOzRCQUN4QixLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUs7NEJBQ3BCLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSzs0QkFDcEIsUUFBUSxFQUFFLE9BQU8sQ0FBQyxRQUFRO3lCQUM3QjtxQkFDSjtpQkFDSixDQUFDO2dCQUVGLE9BQU8sY0FFYSxDQUFDO2FBQ3hCO1lBQ0Q7Z0JBQ0ksQ0FBQyxDQUFDLEVBQVMsRUFBRSxFQUFFO29CQUNYLE1BQU0sSUFBSSxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBQ25DLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBQ3ZCO0lBQ0wsQ0FBQztDQUNKO0FBdnFDRCxrQ0F1cUNDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXZpZHdhbHNoL2NvZGUtbG9jYWwvMHgtcmZxLWFwaS9zcmMvc2VydmljZXMvcmZxbV9zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRzbGludDpkaXNhYmxlOm1heC1maWxlLWxpbmUtY291bnRcbmltcG9ydCB7IFRvb01hbnlSZXF1ZXN0c0Vycm9yIH0gZnJvbSAnQDB4L2FwaS11dGlscyc7XG5pbXBvcnQgeyBBc3NldFN3YXBwZXJDb250cmFjdEFkZHJlc3NlcyB9IGZyb20gJ0AweC9hc3NldC1zd2FwcGVyJztcbmltcG9ydCB7IE90Y09yZGVyLCBaRVJPIH0gZnJvbSAnQDB4L3Byb3RvY29sLXV0aWxzJztcbmltcG9ydCB7XG4gICAgZ2V0VG9rZW5NZXRhZGF0YUlmRXhpc3RzLFxuICAgIG5hdGl2ZVRva2VuU3ltYm9sLFxuICAgIG5hdGl2ZVdyYXBwZWRUb2tlblN5bWJvbCxcbiAgICBUb2tlbk1ldGFkYXRhLFxufSBmcm9tICdAMHgvdG9rZW4tbWV0YWRhdGEnO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnQDB4L3V0aWxzJztcbmltcG9ydCB7IFdlYjNXcmFwcGVyIH0gZnJvbSAnQDB4L3dlYjMtd3JhcHBlcic7XG5pbXBvcnQgeyByZXRyeSB9IGZyb20gJ0BsaWZlb21pYy9hdHRlbXB0JztcbmltcG9ydCB7IFByb2R1Y2VyIGFzIEthZmthUHJvZHVjZXIgfSBmcm9tICdrYWZrYWpzJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IENvdW50ZXIgfSBmcm9tICdwcm9tLWNsaWVudCc7XG5pbXBvcnQgeyBQcm9kdWNlciB9IGZyb20gJ3Nxcy1wcm9kdWNlcic7XG5cbmltcG9ydCB7IEVOQUJMRV9MTFJfQ09PTERPV04sIFJGUU1fTUFJTlRFTkFOQ0VfTU9ERSB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgeyBHQVNMRVNTX09UQ19PUkRFUl9OVU1fQlVDS0VUUywgTlVMTF9BRERSRVNTLCBPTkVfU0VDT05EX01TIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMnO1xuaW1wb3J0IHsgTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eSwgUmZxbVYyVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5IH0gZnJvbSAnLi4vZW50aXRpZXMnO1xuaW1wb3J0IHsgUmZxbVYySm9iQXBwcm92YWxPcHRzLCBSZnFtVjJKb2JDb25zdHJ1Y3Rvck9wdHMgfSBmcm9tICcuLi9lbnRpdGllcy9SZnFtVjJKb2JFbnRpdHknO1xuaW1wb3J0IHtcbiAgICBKb2JGYWlsdXJlUmVhc29uLFxuICAgIFJmcW1Kb2JTdGF0dXMsXG4gICAgUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblN0YXR1cyxcbiAgICBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZSxcbn0gZnJvbSAnLi4vZW50aXRpZXMvdHlwZXMnO1xuaW1wb3J0IHsgUkVBU09OX09OX1NUQVRVU19FUlJPUl9SRVNQT05TRV9FTkFCTEVEIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB7IEludGVybmFsU2VydmVyRXJyb3IsIE5vdEZvdW5kRXJyb3IsIFZhbGlkYXRpb25FcnJvciwgVmFsaWRhdGlvbkVycm9yQ29kZXMgfSBmcm9tICcuLi9jb3JlL2Vycm9ycyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgZmVlVG9TdG9yZWRGZWUgfSBmcm9tICcuLi9jb3JlL2ZlZV91dGlscyc7XG5pbXBvcnQgeyB0b1BhaXJTdHJpbmcgfSBmcm9tICcuLi9jb3JlL3BhaXJfdXRpbHMnO1xuaW1wb3J0IHtcbiAgICBFaXA3MTJEYXRhRmllbGQsXG4gICAgRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkFwcHJvdmFsLFxuICAgIEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0LFxuICAgIEZlZSxcbiAgICBGZWVNb2RlbFZlcnNpb24sXG4gICAgRmlybU90Y1F1b3RlLFxuICAgIEdhc2xlc3NBcHByb3ZhbFR5cGVzLFxuICAgIEdhc2xlc3NUeXBlcyxcbiAgICBJbmRpY2F0aXZlUXVvdGUsXG4gICAgUGVybWl0QXBwcm92YWwsXG4gICAgUGVybWl0RWlwNzEyQ29udGV4dCxcbn0gZnJvbSAnLi4vY29yZS90eXBlcyc7XG5pbXBvcnQgeyBDYWNoZUNsaWVudCB9IGZyb20gJy4uL3V0aWxzL2NhY2hlX2NsaWVudCc7XG5pbXBvcnQgeyBnZXRCZXN0UXVvdGUgfSBmcm9tICcuLi91dGlscy9xdW90ZV9jb21wYXJpc29uX3V0aWxzJztcbmltcG9ydCB7IEV4dGVuZGVkUXVvdGVSZXBvcnQsIHF1b3RlUmVwb3J0VXRpbHMgfSBmcm9tICcuLi91dGlscy9xdW90ZV9yZXBvcnRfdXRpbHMnO1xuaW1wb3J0IHsgUXVvdGVTZXJ2ZXJDbGllbnQgfSBmcm9tICcuLi91dGlscy9xdW90ZV9zZXJ2ZXJfY2xpZW50JztcbmltcG9ydCB7IG90Y09yZGVyVG9TdG9yZWRPdGNPcmRlciwgUmZxbURiVXRpbHMgfSBmcm9tICcuLi91dGlscy9yZnFtX2RiX3V0aWxzJztcbmltcG9ydCB7IGNvbXB1dGVIZWFsdGhDaGVja0FzeW5jLCBIZWFsdGhDaGVja1Jlc3VsdCB9IGZyb20gJy4uL3V0aWxzL3JmcW1faGVhbHRoX2NoZWNrJztcbmltcG9ydCB7IFJmcUJsb2NrY2hhaW5VdGlscyB9IGZyb20gJy4uL3V0aWxzL3JmcV9ibG9ja2NoYWluX3V0aWxzJztcbmltcG9ydCB7IFJmcU1ha2VyTWFuYWdlciB9IGZyb20gJy4uL3V0aWxzL3JmcV9tYWtlcl9tYW5hZ2VyJztcbmltcG9ydCB7IGdldFNpZ25lckZyb21IYXNoLCBwYWRTaWduYXR1cmUgfSBmcm9tICcuLi91dGlscy9zaWduYXR1cmVfdXRpbHMnO1xuaW1wb3J0IHsgVG9rZW5NZXRhZGF0YU1hbmFnZXIgfSBmcm9tICcuLi91dGlscy9Ub2tlbk1ldGFkYXRhTWFuYWdlcic7XG5cbmltcG9ydCB7IEZlZVNlcnZpY2UgfSBmcm9tICcuL2ZlZV9zZXJ2aWNlJztcbmltcG9ydCB7IFJmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZSB9IGZyb20gJy4vcmZxX21ha2VyX2JhbGFuY2VfY2FjaGVfc2VydmljZSc7XG5pbXBvcnQge1xuICAgIEFwcHJvdmFsUmVzcG9uc2UsXG4gICAgRmV0Y2hGaXJtUXVvdGVQYXJhbXMsXG4gICAgRmV0Y2hJbmRpY2F0aXZlUXVvdGVQYXJhbXMsXG4gICAgRmV0Y2hJbmRpY2F0aXZlUXVvdGVSZXNwb25zZSxcbiAgICBPdGNPcmRlclJmcW1RdW90ZVJlc3BvbnNlLFxuICAgIE90Y09yZGVyU3VibWl0UmZxbVNpZ25lZFF1b3RlUGFyYW1zLFxuICAgIE90Y09yZGVyU3VibWl0UmZxbVNpZ25lZFF1b3RlUmVzcG9uc2UsXG4gICAgUXVvdGVDb250ZXh0LFxuICAgIFN0YXR1c1Jlc3BvbnNlLFxuICAgIFN1Ym1pdEFwcHJvdmFsUGFyYW1zLFxuICAgIFN1Ym1pdFJmcW1TaWduZWRRdW90ZVdpdGhBcHByb3ZhbFBhcmFtcyxcbiAgICBTdWJtaXRSZnFtU2lnbmVkUXVvdGVXaXRoQXBwcm92YWxSZXNwb25zZSxcbiAgICBUcmFuc2FjdGlvbkRldGFpbHMsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgTWFya2V0T3BlcmF0aW9uIH0gZnJvbSAnQDB4L3R5cGVzJztcblxuY29uc3QgUkZRTV9RVU9URV9JTlNFUlRFRCA9IG5ldyBDb3VudGVyKHtcbiAgICBuYW1lOiAncmZxbV9xdW90ZV9pbnNlcnRlZCcsXG4gICAgaGVscDogJ0FuIFJmcW1RdW90ZSB3YXMgaW5zZXJ0ZWQgaW4gdGhlIERCJyxcbiAgICBsYWJlbE5hbWVzOiBbJ2FwaUtleScsICdpbnRlZ3JhdG9ySWQnLCAnbWFrZXJVcmknXSxcbn0pO1xuXG5jb25zdCBSRlFNX1NJR05FRF9RVU9URV9OT1RfRk9VTkQgPSBuZXcgQ291bnRlcih7XG4gICAgbmFtZTogJ3JmcW1fc2lnbmVkX3F1b3RlX25vdF9mb3VuZCcsXG4gICAgbGFiZWxOYW1lczogWydjaGFpbl9pZCddLFxuICAgIGhlbHA6ICdBIHN1Ym1pdHRlZCBxdW90ZSBkaWQgbm90IG1hdGNoIGFueSBzdG9yZWQgcXVvdGVzJyxcbn0pO1xuY29uc3QgUkZRTV9UQUtFUl9BTkRfVEFLRVJUT0tFTl9UUkFERV9FWElTVFMgPSBuZXcgQ291bnRlcih7XG4gICAgbmFtZTogJ3JmcW1fc2lnbmVkX3F1b3RlX3Rha2VyX2FuZF90YWtlcnRva2VuX3RyYWRlX2V4aXN0cycsXG4gICAgbGFiZWxOYW1lczogWydjaGFpbl9pZCddLFxuICAgIGhlbHA6ICdBIHRyYWRlIHdhcyBzdWJtaXR0ZWQgd2hlbiB0aGUgc3lzdGVtIGFscmVhZHkgaGFkIGEgcGVuZGluZyB0cmFkZSBmb3IgdGhlIHNhbWUgdGFrZXIgYW5kIHRha2VydG9rZW4nLFxufSk7XG5jb25zdCBSRlFNX1NVQk1JVF9CQUxBTkNFX0NIRUNLX0ZBSUxFRCA9IG5ldyBDb3VudGVyKHtcbiAgICBuYW1lOiAncmZxbV9zdWJtaXRfYmFsYW5jZV9jaGVja19mYWlsZWQnLFxuICAgIGxhYmVsTmFtZXM6IFsnbWFrZXJBZGRyZXNzJywgJ2NoYWluX2lkJ10sXG4gICAgaGVscDogJ0EgdHJhZGUgd2FzIHN1Ym1pdHRlZCBidXQgb3VyIG9uLWNoYWluIGJhbGFuY2UgY2hlY2sgZmFpbGVkJyxcbn0pO1xuXG5jb25zdCBSRlFNX01BS0VSX0JMT0NLRURfRk9SX0xMUl9DT09MRE9XTiA9IG5ldyBDb3VudGVyKHtcbiAgICBuYW1lOiAncmZxbV9tYWtlcl9ibG9ja2VkX2Zvcl9sbHJfY29vbGRvd24nLFxuICAgIGhlbHA6ICdBIG1ha2VyIGdldCBibG9ja2VkIGJlY2F1c2Ugb2YgTExSIGNvb2xkb3duJyxcbiAgICBsYWJlbE5hbWVzOiBbJ21ha2VyX2lkJywgJ2NoYWluX2lkJywgJ3BhaXJfa2V5J10sXG59KTtcblxuY29uc3QgUkZRTV9NTV9SRVRVUk5FRF9ESUZGRVJFTlRfQU1PVU5UID0gbmV3IENvdW50ZXIoe1xuICAgIG5hbWU6ICdyZnFtX21tX3JldHVybmVkX2RpZmZlcmVudF9hbW91bnRfdG90YWwnLFxuICAgIGhlbHA6ICdBIG1ha2VyIHJlc3BvbmRlZCBhIHF1b3RlIHdpdGggZGlmZmVyZW50IGFtb3VudCB0aGFuIHJlcXVlc3RlZCcsXG4gICAgbGFiZWxOYW1lczogWydtYWtlcl91cmknLCAnY2hhaW5faWQnLCAnbW9kaWZpY2F0aW9uX3R5cGUnXSxcbn0pO1xuXG5jb25zdCBQUklDRV9ERUNJTUFMX1BMQUNFUyA9IDY7XG5cbmNvbnN0IGdldFRva2VuQWRkcmVzc0Zyb21TeW1ib2wgPSAoc3ltYm9sOiBzdHJpbmcsIGNoYWluSWQ6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIChnZXRUb2tlbk1ldGFkYXRhSWZFeGlzdHMoc3ltYm9sLCBjaGFpbklkKSBhcyBUb2tlbk1ldGFkYXRhKS50b2tlbkFkZHJlc3M7XG59O1xuXG4vKipcbiAqIFJmcW1TZXJ2aWNlIGlzIHRoZSBjb29yZGluYXRpb24gbGF5ZXIgZm9yIEhUVFAgYmFzZWQgUkZRTSBmbG93cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJmcW1TZXJ2aWNlIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9uYXRpdmVUb2tlbkFkZHJlc3M6IHN0cmluZztcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9uYXRpdmVUb2tlblN5bWJvbDogc3RyaW5nO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX25hdGl2ZVdyYXBwZWRUb2tlblN5bWJvbDogc3RyaW5nO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX25hdGl2ZVdyYXBwZWRUb2tlbkFkZHJlc3M6IHN0cmluZztcblxuICAgIHByaXZhdGUgc3RhdGljIF9nZXRTZWxsQW1vdW50R2l2ZW5CdXlBbW91bnRBbmRRdW90ZShcbiAgICAgICAgYnV5QW1vdW50OiBCaWdOdW1iZXIsXG4gICAgICAgIHF1b3RlZFRha2VyQW1vdW50OiBCaWdOdW1iZXIsXG4gICAgICAgIHF1b3RlZE1ha2VyQW1vdW50OiBCaWdOdW1iZXIsXG4gICAgKTogQmlnTnVtYmVyIHtcbiAgICAgICAgLy8gU29sdmluZyBmb3IgeCBnaXZlbiB0aGUgZm9sbG93aW5nIHByb3BvcnRpb246XG4gICAgICAgIC8vIHggLyBidXlBbW91bnQgPSBxdW90ZWRUYWtlckFtb3VudCAvIHF1b3RlZE1ha2VyQW1vdW50XG4gICAgICAgIHJldHVybiBxdW90ZWRUYWtlckFtb3VudC5kaXYocXVvdGVkTWFrZXJBbW91bnQpLnRpbWVzKGJ1eUFtb3VudCkuZGVjaW1hbFBsYWNlcygwKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBfZ2V0QnV5QW1vdW50R2l2ZW5TZWxsQW1vdW50QW5kUXVvdGUoXG4gICAgICAgIHNlbGxBbW91bnQ6IEJpZ051bWJlcixcbiAgICAgICAgcXVvdGVkVGFrZXJBbW91bnQ6IEJpZ051bWJlcixcbiAgICAgICAgcXVvdGVkTWFrZXJBbW91bnQ6IEJpZ051bWJlcixcbiAgICApOiBCaWdOdW1iZXIge1xuICAgICAgICAvLyBTb2x2aW5nIGZvciB5IGdpdmVuIHRoZSBmb2xsb3dpbmcgcHJvcG9ydGlvbjpcbiAgICAgICAgLy8geSAvIHNlbGxBbW91bnQgPSAgcXVvdGVkTWFrZXJBbW91bnQgLyBxdW90ZWRUYWtlckFtb3VudFxuICAgICAgICByZXR1cm4gcXVvdGVkTWFrZXJBbW91bnQuZGl2KHF1b3RlZFRha2VyQW1vdW50KS50aW1lcyhzZWxsQW1vdW50KS5kZWNpbWFsUGxhY2VzKDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhIHRyYW5zYWN0aW9uIHN1Ym1pc3Npb24gdG8gdHlwZSBgVHJhbnNhY3Rpb25EZXRhaWxzYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIENvcnJlc3BvbmRpbmcgYFRyYW5zYWN0aW9uRGV0YWlsc2Agb3IgbnVsbCBpZiB0cmFuc2FjdGlvbiBoYXNoIGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3RyYW5zZm9ybVRyYW5zYWN0aW9uU3VibWlzc2lvbihcbiAgICAgICAgdHJhbnNhY3Rpb25TdWJtaXNzaW9uOiBQaWNrPFxuICAgICAgICAgICAgUmZxbVYyVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5IHwgTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eSxcbiAgICAgICAgICAgICdjcmVhdGVkQXQnIHwgJ3RyYW5zYWN0aW9uSGFzaCdcbiAgICAgICAgPixcbiAgICApOiBUcmFuc2FjdGlvbkRldGFpbHMgfCBudWxsIHtcbiAgICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsIGNyZWF0ZWRBdCB9ID0gdHJhbnNhY3Rpb25TdWJtaXNzaW9uO1xuICAgICAgICByZXR1cm4gaGFzaCA/IHsgaGFzaCwgdGltZXN0YW1wOiBjcmVhdGVkQXQuZ2V0VGltZSgpIH0gOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBkZXRhaWxzIG9mIHRoZSBzdWNjZXNzZnVsIHRyYW5zYWN0aW9uIHN1Ym1pc3Npb24gKHRoZXJlIHdpbGwgb25seSBiZSBvbmUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgT3B0aW9ucyBvYmplY3QgdGhhdCBjb250YWluczpcbiAgICAgKiAgICAgICAgICAgICAtIGBoYXNoYDogVGhlIGhhc2ggb2YgdGhlIG9yZGVyIG9yIG1ldGF0cmFuc2FjdGlvbi5cbiAgICAgKiAgICAgICAgICAgICAtIGB0eXBlYDogVGhlIHR5cGUgb2YgdGhlIHRyYW5zYWN0aW9uIHN1Ym1pc3Npb25zLlxuICAgICAqICAgICAgICAgICAgIC0gYHRyYW5zYWN0aW9uU3VibXNzaW9uc2A6IExpc3Qgb2YgdHJhbnNhY3Rpb24gc3VibWlzc2lvbnMgdG8gZmlsdGVyLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZXRhaWxzIChoYXNoIGFuZCB0aW1lc3RhbXApIG9mIHRoZSBzdWNjZXNzZnVsIHRyYW5zYWN0aW9uIHN1Ym1pc3Npb24uXG4gICAgICogQHRocm93cyAtIFdoZW4gdGhlIG51bWJlciBvZiB0aGUgc3VjY2Vzc2Z1bCB0cmFuc2FjdGlvbiBzdWJtaXNzaW9uIGlzIG5vdCAxXG4gICAgICogICAgICAgICAtIFRoZSBzdWNjZXNzZnVsIHRyYW5zYWN0aW9uIHN1Ym1pc3Npb24gZG9lcyBub3QgaGF2ZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2dldFN1Y2Nlc3NmdWxUcmFuc2FjdGlvblN1Ym1pc3Npb25EZXRhaWxzKG9wdHM6IHtcbiAgICAgICAgaGFzaDogc3RyaW5nO1xuICAgICAgICB0eXBlOiBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZTtcbiAgICAgICAgdHJhbnNhY3Rpb25TdWJtc3Npb25zOiBQaWNrPFxuICAgICAgICAgICAgUmZxbVYyVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5IHwgTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eSxcbiAgICAgICAgICAgICdjcmVhdGVkQXQnIHwgJ3N0YXR1cycgfCAndHJhbnNhY3Rpb25IYXNoJ1xuICAgICAgICA+W107XG4gICAgfSk6IFRyYW5zYWN0aW9uRGV0YWlscyB7XG4gICAgICAgIGNvbnN0IHsgaGFzaCwgdHlwZSwgdHJhbnNhY3Rpb25TdWJtc3Npb25zIH0gPSBvcHRzO1xuICAgICAgICBjb25zdCBzdWNjZXNzZnVsVHJhbnNhY3Rpb25TdWJtaXNzaW9ucyA9IHRyYW5zYWN0aW9uU3VibXNzaW9ucy5maWx0ZXIoXG4gICAgICAgICAgICAocykgPT5cbiAgICAgICAgICAgICAgICBzLnN0YXR1cyA9PT0gUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblN0YXR1cy5TdWNjZWVkZWRVbmNvbmZpcm1lZCB8fFxuICAgICAgICAgICAgICAgIHMuc3RhdHVzID09PSBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uU3RhdHVzLlN1Y2NlZWRlZENvbmZpcm1lZCxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3NmdWxUcmFuc2FjdGlvblN1Ym1pc3Npb25zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBleGFjdGx5IG9uZSBzdWNjZXNzZnVsIHRyYW5zYWN0aW9uIHN1Ym1pc3Npb24gb2YgdHlwZSAke3R5cGV9IGZvciBoYXNoICR7aGFzaH07IGZvdW5kICR7c3VjY2Vzc2Z1bFRyYW5zYWN0aW9uU3VibWlzc2lvbnMubGVuZ3RofWAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NmdWxUcmFuc2FjdGlvblN1Ym1pc3Npb24gPSBzdWNjZXNzZnVsVHJhbnNhY3Rpb25TdWJtaXNzaW9uc1swXTtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc2Z1bFRyYW5zYWN0aW9uU3VibWlzc2lvbkRldGFpbHMgPSB0aGlzLl90cmFuc2Zvcm1UcmFuc2FjdGlvblN1Ym1pc3Npb24oXG4gICAgICAgICAgICBzdWNjZXNzZnVsVHJhbnNhY3Rpb25TdWJtaXNzaW9uLFxuICAgICAgICApO1xuICAgICAgICBpZiAoIXN1Y2Nlc3NmdWxUcmFuc2FjdGlvblN1Ym1pc3Npb25EZXRhaWxzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1Y2Nlc3NmdWwgdHJhbnNhY3Rpb24gb2YgdHlwZSAke3R5cGV9IGRvZXMgbm90IGhhdmUgYSBoYXNoICR7aGFzaH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWNjZXNzZnVsVHJhbnNhY3Rpb25TdWJtaXNzaW9uRGV0YWlscztcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBfam9iRmFpbHVyZVN0YXR1c1RvUmVhc29uKGZhaWx1cmVTdGF0dXM6IFJmcW1Kb2JTdGF0dXMpOiBKb2JGYWlsdXJlUmVhc29uIHtcbiAgICAgICAgc3dpdGNoIChmYWlsdXJlU3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuRmFpbGVkRXRoQ2FsbEZhaWxlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gSm9iRmFpbHVyZVJlYXNvbi5UcmFuc2FjdGlvblNpbXVsYXRpb25GYWlsZWQ7XG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuRmFpbGVkRXhwaXJlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gSm9iRmFpbHVyZVJlYXNvbi5PcmRlckV4cGlyZWQ7XG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuRmFpbGVkTGFzdExvb2tEZWNsaW5lZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gSm9iRmFpbHVyZVJlYXNvbi5MYXN0TG9va0RlY2xpbmVkO1xuICAgICAgICAgICAgY2FzZSBSZnFtSm9iU3RhdHVzLkZhaWxlZFNpZ25GYWlsZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpvYkZhaWx1cmVSZWFzb24uTWFya2V0TWFrZXJTaWduYXR1cmVFcnJvcjtcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRSZXZlcnRlZENvbmZpcm1lZDpcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRSZXZlcnRlZFVuY29uZmlybWVkOlxuICAgICAgICAgICAgICAgIHJldHVybiBKb2JGYWlsdXJlUmVhc29uLlRyYW5zYWN0aW9uUmV2ZXJ0ZWQ7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBKb2JGYWlsdXJlUmVhc29uLkludGVybmFsRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfY2hhaW5JZDogbnVtYmVyLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9mZWVTZXJ2aWNlOiBGZWVTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9mZWVNb2RlbFZlcnNpb246IEZlZU1vZGVsVmVyc2lvbixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfY29udHJhY3RBZGRyZXNzZXM6IEFzc2V0U3dhcHBlckNvbnRyYWN0QWRkcmVzc2VzLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9yZWdpc3RyeUFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfYmxvY2tjaGFpblV0aWxzOiBSZnFCbG9ja2NoYWluVXRpbHMsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX2RiVXRpbHM6IFJmcW1EYlV0aWxzLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9zcXNQcm9kdWNlcjogUHJvZHVjZXIsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX3F1b3RlU2VydmVyQ2xpZW50OiBRdW90ZVNlcnZlckNsaWVudCxcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfbWluRXhwaXJ5RHVyYXRpb25NczogbnVtYmVyLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9jYWNoZUNsaWVudDogQ2FjaGVDbGllbnQsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX3JmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZTogUmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9yZnFNYWtlck1hbmFnZXI6IFJmcU1ha2VyTWFuYWdlcixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfdG9rZW5NZXRhZGF0YU1hbmFnZXI6IFRva2VuTWV0YWRhdGFNYW5hZ2VyLFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9rYWZrYVByb2R1Y2VyPzogS2Fma2FQcm9kdWNlcixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfcXVvdGVSZXBvcnRUb3BpYz86IHN0cmluZyxcbiAgICApIHtcbiAgICAgICAgdGhpcy5fbmF0aXZlVG9rZW5TeW1ib2wgPSBuYXRpdmVUb2tlblN5bWJvbCh0aGlzLl9jaGFpbklkKTtcbiAgICAgICAgdGhpcy5fbmF0aXZlVG9rZW5BZGRyZXNzID0gZ2V0VG9rZW5BZGRyZXNzRnJvbVN5bWJvbCh0aGlzLl9uYXRpdmVUb2tlblN5bWJvbCwgdGhpcy5fY2hhaW5JZCk7XG4gICAgICAgIHRoaXMuX25hdGl2ZVdyYXBwZWRUb2tlblN5bWJvbCA9IG5hdGl2ZVdyYXBwZWRUb2tlblN5bWJvbCh0aGlzLl9jaGFpbklkKTtcbiAgICAgICAgdGhpcy5fbmF0aXZlV3JhcHBlZFRva2VuQWRkcmVzcyA9IGdldFRva2VuQWRkcmVzc0Zyb21TeW1ib2wodGhpcy5fbmF0aXZlV3JhcHBlZFRva2VuU3ltYm9sLCB0aGlzLl9jaGFpbklkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzdGhyb3VnaCB0byBUb2tlbk1ldGFkYXRhTWFuYWdlcidzIGBnZXRUb2tlbkRlY2ltYWxzQXN5bmNgIG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRUb2tlbkRlY2ltYWxzQXN5bmModG9rZW5BZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5NZXRhZGF0YU1hbmFnZXIuZ2V0VG9rZW5EZWNpbWFsc0FzeW5jKHRva2VuQWRkcmVzcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIGJlc3QgaW5kaWNhdGl2ZSBxdW90ZSBhdmFpbGFibGUuIFJldHVybnMgbnVsbCBpZiBubyB2YWxpZCBxdW90ZXMgZm91bmRcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZmV0Y2hJbmRpY2F0aXZlUXVvdGVBc3luYyhcbiAgICAgICAgcGFyYW1zOiBGZXRjaEluZGljYXRpdmVRdW90ZVBhcmFtcyxcbiAgICAgICAgZXh0ZW5kZWRRdW90ZVJlcG9ydFN1Ym1pc3Npb25CeTogRXh0ZW5kZWRRdW90ZVJlcG9ydFsnc3VibWlzc2lvbkJ5J10gPSAncmZxbScsXG4gICAgKTogUHJvbWlzZTxGZXRjaEluZGljYXRpdmVRdW90ZVJlc3BvbnNlIHwgbnVsbD4ge1xuICAgICAgICBjb25zdCBhZmZpbGlhdGVBZGRyZXNzID0gcGFyYW1zLmFmZmlsaWF0ZUFkZHJlc3MgPz8gcGFyYW1zLmludGVncmF0b3IuYWZmaWxpYXRlQWRkcmVzcztcblxuICAgICAgICAvLyBSZXRyaWV2ZSBxdW90ZSBjb250ZXh0XG4gICAgICAgIGNvbnN0IHF1b3RlQ29udGV4dCA9IHRoaXMuX3JldHJpZXZlUXVvdGVDb250ZXh0KHsgLi4ucGFyYW1zLCBhZmZpbGlhdGVBZGRyZXNzIH0sIC8qIGlzRmlybSAqLyBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGlzRmlybSxcbiAgICAgICAgICAgIHRha2VyQW1vdW50LFxuICAgICAgICAgICAgbWFrZXJBbW91bnQsXG4gICAgICAgICAgICB0YWtlclRva2VuLFxuICAgICAgICAgICAgbWFrZXJUb2tlbixcbiAgICAgICAgICAgIG9yaWdpbmFsTWFrZXJUb2tlbixcbiAgICAgICAgICAgIHRha2VyVG9rZW5EZWNpbWFscyxcbiAgICAgICAgICAgIG1ha2VyVG9rZW5EZWNpbWFscyxcbiAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcbiAgICAgICAgICAgIGlzU2VsbGluZyxcbiAgICAgICAgICAgIGFzc2V0RmlsbEFtb3VudCxcbiAgICAgICAgICAgIGludGVncmF0b3IsXG4gICAgICAgIH0gPSBxdW90ZUNvbnRleHQ7XG5cbiAgICAgICAgLy8gKE9wdGltaXphdGlvbikgV2hlbiBgcXVvdGVzV2l0aEdhc0ZlZWAgaXMgcmV0dXJuZWQsIHdlIGNhbiB1c2UgdGhpcyB2YWx1ZSBhbmQgcmV2aXNlIGl0LCB0byBhdm9pZCBhbm90aGVyIGZldGNoIHRvIE1Nc1xuICAgICAgICBjb25zdCB7IGZlZVdpdGhEZXRhaWxzLCBxdW90ZXNXaXRoR2FzRmVlLCBhbW1RdW90ZVVuaXF1ZUlkIH0gPSBhd2FpdCB0aGlzLl9mZWVTZXJ2aWNlLmNhbGN1bGF0ZUZlZUFzeW5jKFxuICAgICAgICAgICAgcXVvdGVDb250ZXh0LFxuICAgICAgICAgICAgdGhpcy5fZmV0Y2hJbmRpY2F0aXZlUXVvdGVzQXN5bmMuYmluZCh0aGlzKSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgZmVlcyAob3RoZXIgdGhhbiBnYXMgZmVlKSB0byBjaGFyZ2UgTU1zXG4gICAgICAgIGNvbnN0IG90aGVyRmVlc0Ftb3VudCA9IGZlZVdpdGhEZXRhaWxzLmFtb3VudC5taW51cyhmZWVXaXRoRGV0YWlscy5kZXRhaWxzLmdhc0ZlZUFtb3VudCk7XG5cbiAgICAgICAgY29uc3QgZmluYWxRdW90ZXMgPSBxdW90ZXNXaXRoR2FzRmVlXG4gICAgICAgICAgICA/IGF3YWl0IHRoaXMuX2ZlZVNlcnZpY2UucmV2aXNlUXVvdGVzQXN5bmMocXVvdGVzV2l0aEdhc0ZlZSwgb3RoZXJGZWVzQW1vdW50LCBxdW90ZUNvbnRleHQpXG4gICAgICAgICAgICA6IGF3YWl0IHRoaXMuX2ZldGNoSW5kaWNhdGl2ZVF1b3Rlc0FzeW5jKHF1b3RlQ29udGV4dCwgZmVlV2l0aERldGFpbHMpO1xuXG4gICAgICAgIC8vIChRdW90ZSBSZXBvcnQpIElmIG90aGVyRmVlcyA+IDAsIHRoZW4gd2UgXCJyZXZpc2VkXCIgdGhlIHF1b3RlcyBmcm9tIE1Ncy4gV2Ugd2FudCB0byBzYXZlIGJvdGggdGhlIG9yaWdpbmFsIHF1b3RlcyAoYWthIGludGVybWVkaWF0ZVF1b3RlcykgYW5kIHRoZSByZXZpc2VkIChmaW5hbFF1b3RlcylcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlUXVvdGVzID0gcXVvdGVzV2l0aEdhc0ZlZSAmJiBvdGhlckZlZXNBbW91bnQuZ3QoWkVSTykgPyBxdW90ZXNXaXRoR2FzRmVlIDogW107XG5cbiAgICAgICAgLy8gR2V0IHRoZSBiZXN0IHF1b3RlXG4gICAgICAgIGNvbnN0IGJlc3RRdW90ZSA9IGdldEJlc3RRdW90ZShcbiAgICAgICAgICAgIGZpbmFsUXVvdGVzLFxuICAgICAgICAgICAgaXNTZWxsaW5nLFxuICAgICAgICAgICAgdGFrZXJUb2tlbixcbiAgICAgICAgICAgIG1ha2VyVG9rZW4sXG4gICAgICAgICAgICBhc3NldEZpbGxBbW91bnQsXG4gICAgICAgICAgICB0aGlzLl9taW5FeHBpcnlEdXJhdGlvbk1zLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGlzTGlxdWlkaXR5QXZhaWxhYmxlID0gYmVzdFF1b3RlICE9PSBudWxsO1xuXG4gICAgICAgIC8vIFF1b3RlIFJlcG9ydFxuICAgICAgICBpZiAodGhpcy5fa2Fma2FQcm9kdWNlcikge1xuICAgICAgICAgICAgYXdhaXQgcXVvdGVSZXBvcnRVdGlscy5wdWJsaXNoUkZRTVF1b3RlUmVwb3J0QXN5bmMoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpc0Zpcm1RdW90ZTogaXNGaXJtLFxuICAgICAgICAgICAgICAgICAgICB0YWtlcjogdGFrZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBidXlUb2tlbkFkZHJlc3M6IG9yaWdpbmFsTWFrZXJUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgc2VsbFRva2VuQWRkcmVzczogdGFrZXJUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgYnV5QW1vdW50OiBtYWtlckFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgc2VsbEFtb3VudDogdGFrZXJBbW91bnQsXG4gICAgICAgICAgICAgICAgICAgIGludGVncmF0b3JJZDogaW50ZWdyYXRvcj8uaW50ZWdyYXRvcklkLFxuICAgICAgICAgICAgICAgICAgICBmaW5hbFF1b3RlcyxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlUXVvdGVzLFxuICAgICAgICAgICAgICAgICAgICBiZXN0UXVvdGUsXG4gICAgICAgICAgICAgICAgICAgIGZlZTogZmVlVG9TdG9yZWRGZWUoZmVlV2l0aERldGFpbHMpLFxuICAgICAgICAgICAgICAgICAgICBhbW1RdW90ZVVuaXF1ZUlkLFxuICAgICAgICAgICAgICAgICAgICBpc0xpcXVpZGl0eUF2YWlsYWJsZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXMuX2thZmthUHJvZHVjZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVvdGVSZXBvcnRUb3BpYyxcbiAgICAgICAgICAgICAgICBleHRlbmRlZFF1b3RlUmVwb3J0U3VibWlzc2lvbkJ5LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vIHF1b3RlcyBmb3VuZFxuICAgICAgICBpZiAoIWlzTGlxdWlkaXR5QXZhaWxhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXBhcmUgdGhlIHByaWNlXG4gICAgICAgIGNvbnN0IG1ha2VyQW1vdW50SW5Vbml0ID0gV2ViM1dyYXBwZXIudG9Vbml0QW1vdW50KGJlc3RRdW90ZS5tYWtlckFtb3VudCwgbWFrZXJUb2tlbkRlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgdGFrZXJBbW91bnRJblVuaXQgPSBXZWIzV3JhcHBlci50b1VuaXRBbW91bnQoYmVzdFF1b3RlLnRha2VyQW1vdW50LCB0YWtlclRva2VuRGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBwcmljZSA9IGlzU2VsbGluZyA/IG1ha2VyQW1vdW50SW5Vbml0LmRpdih0YWtlckFtb3VudEluVW5pdCkgOiB0YWtlckFtb3VudEluVW5pdC5kaXYobWFrZXJBbW91bnRJblVuaXQpO1xuICAgICAgICAvLyBUaGUgd2F5IHRoZSBCaWdOdW1iZXIgcm91bmQgZG93biBiZWhhdmlvciAoaHR0cHM6Ly9taWtlbWNsLmdpdGh1Yi5pby9iaWdudW1iZXIuanMvI2RwKSB3b3JrcyByZXF1aXJlcyB1c1xuICAgICAgICAvLyB0byBhZGQgMSB0byBQUklDRV9ERUNJTUFMX1BMQUNFUyBpbiBvcmRlciB0byBhY3R1YWxseSBjb21lIG91dCB3aXRoIHRoZSBkZWNpbWFsIHBsYWNlcyBzcGVjaWZpZWQuXG4gICAgICAgIGNvbnN0IHJvdW5kZWRQcmljZSA9IHByaWNlLmRlY2ltYWxQbGFjZXMoUFJJQ0VfREVDSU1BTF9QTEFDRVMgKyAxLCBCaWdOdW1iZXIuUk9VTkRfRE9XTik7XG5cbiAgICAgICAgLy8gUHJlcGFyZSByZXNwb25zZVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJpY2U6IHJvdW5kZWRQcmljZSxcbiAgICAgICAgICAgIGdhczogZmVlV2l0aERldGFpbHMuZGV0YWlscy5nYXNQcmljZSxcbiAgICAgICAgICAgIGJ1eUFtb3VudDogYmVzdFF1b3RlLm1ha2VyQW1vdW50LFxuICAgICAgICAgICAgYnV5VG9rZW5BZGRyZXNzOiBvcmlnaW5hbE1ha2VyVG9rZW4sXG4gICAgICAgICAgICBzZWxsQW1vdW50OiBiZXN0UXVvdGUudGFrZXJBbW91bnQsXG4gICAgICAgICAgICBzZWxsVG9rZW5BZGRyZXNzOiBiZXN0UXVvdGUudGFrZXJUb2tlbixcbiAgICAgICAgICAgIGFsbG93YW5jZVRhcmdldDogdGhpcy5fY29udHJhY3RBZGRyZXNzZXMuZXhjaGFuZ2VQcm94eSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgYmVzdCBmaXJtIHF1b3RlIGF2YWlsYWJsZSwgaW5jbHVkaW5nIGEgbWV0YXRyYW5zYWN0aW9uLiBSZXR1cm5zIG51bGwgaWYgbm8gdmFsaWQgcXVvdGVzIGZvdW5kXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGZldGNoRmlybVF1b3RlQXN5bmMoXG4gICAgICAgIHBhcmFtczogRmV0Y2hGaXJtUXVvdGVQYXJhbXMsXG4gICAgICAgIGV4dGVuZGVkUXVvdGVSZXBvcnRTdWJtaXNzaW9uQnk6IEV4dGVuZGVkUXVvdGVSZXBvcnRbJ3N1Ym1pc3Npb25CeSddID0gJ3JmcW0nLFxuICAgICk6IFByb21pc2U8eyBxdW90ZTogT3RjT3JkZXJSZnFtUXVvdGVSZXNwb25zZSB8IG51bGw7IHF1b3RlUmVwb3J0SWQ6IHN0cmluZyB8IG51bGwgfT4ge1xuICAgICAgICBjb25zdCBhZmZpbGlhdGVBZGRyZXNzID0gcGFyYW1zLmFmZmlsaWF0ZUFkZHJlc3MgPz8gcGFyYW1zLmludGVncmF0b3IuYWZmaWxpYXRlQWRkcmVzcztcbiAgICAgICAgLy8gUmV0cmlldmUgcXVvdGUgY29udGV4dFxuICAgICAgICBjb25zdCBxdW90ZUNvbnRleHQgPSB0aGlzLl9yZXRyaWV2ZVF1b3RlQ29udGV4dCh7IC4uLnBhcmFtcywgYWZmaWxpYXRlQWRkcmVzcyB9LCAvKiBpc0Zpcm0gKi8gdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGlzRmlybSxcbiAgICAgICAgICAgIHRha2VyQW1vdW50LFxuICAgICAgICAgICAgbWFrZXJBbW91bnQsXG4gICAgICAgICAgICB0YWtlclRva2VuLFxuICAgICAgICAgICAgbWFrZXJUb2tlbixcbiAgICAgICAgICAgIG9yaWdpbmFsTWFrZXJUb2tlbixcbiAgICAgICAgICAgIHRha2VyVG9rZW5EZWNpbWFscyxcbiAgICAgICAgICAgIG1ha2VyVG9rZW5EZWNpbWFscyxcbiAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcbiAgICAgICAgICAgIGludGVncmF0b3IsXG4gICAgICAgICAgICBpc1Vud3JhcCxcbiAgICAgICAgICAgIGlzU2VsbGluZyxcbiAgICAgICAgICAgIGFzc2V0RmlsbEFtb3VudCxcbiAgICAgICAgfSA9IHF1b3RlQ29udGV4dDtcblxuICAgICAgICAvLyAoT3B0aW1pemF0aW9uKSBXaGVuIGBxdW90ZXNXaXRoR2FzRmVlYCBpcyByZXR1cm5lZCwgd2UgY2FuIHNvbWV0aW1lcyByZXVzZSBpdCwgdG8gYXZvaWQgYW5vdGhlciBmZXRjaCB0byBNTXNcbiAgICAgICAgLy8gTk9URTogdGhpcyBvcHRpbWl6YXRpb24gZGlmZmVycyBmcm9tIHRoZSBvcHRpbWl6YXRpb24gZm9yIGluZGljYXRpdmUgcXVvdGVzIGJlY2F1c2Ugd2UgZG8gTk9UIHJldmlzZSBmaXJtIHF1b3Rlc1xuICAgICAgICBjb25zdCB7IGZlZVdpdGhEZXRhaWxzLCBxdW90ZXNXaXRoR2FzRmVlLCBhbW1RdW90ZVVuaXF1ZUlkIH0gPSBhd2FpdCB0aGlzLl9mZWVTZXJ2aWNlLmNhbGN1bGF0ZUZlZUFzeW5jKFxuICAgICAgICAgICAgcXVvdGVDb250ZXh0LFxuICAgICAgICAgICAgdGhpcy5fZmV0Y2hJbmRpY2F0aXZlUXVvdGVzQXN5bmMuYmluZCh0aGlzKSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgZmVlcyAob3RoZXIgdGhhbiBnYXMgZmVlKSB0byBjaGFyZ2UgTU1zLiBJZiB0aGVyZSBhcmUgb3RoZXIgZmVlcywgd2UgZG9uJ3QgcmV1c2UgYHF1b3Rlc1dpdGhHYXNGZWVgXG4gICAgICAgIGNvbnN0IG90aGVyRmVlc0Ftb3VudCA9IGZlZVdpdGhEZXRhaWxzLmFtb3VudC5taW51cyhmZWVXaXRoRGV0YWlscy5kZXRhaWxzLmdhc0ZlZUFtb3VudCk7XG5cbiAgICAgICAgLy8gSWYgYHF1b3Rlc1dpdGhHYXNGZWVgIGhhdmUgYmVlbiBvYnRhaW5lZCBhbmQgdGhlcmUgYXJlIG5vIG90aGVyIGZlZXMsIHJldXNlIHRoZSBxdW90ZXMuIE90aGVyd2lzZSBjYWxsIE1NcyB3aXRoIGZ1bGwgZmVlIHRvIGdldCBuZXcgcXVvdGVzLlxuICAgICAgICBjb25zdCBmaW5hbFF1b3RlcyA9XG4gICAgICAgICAgICBxdW90ZXNXaXRoR2FzRmVlICYmIG90aGVyRmVlc0Ftb3VudC5lcShaRVJPKVxuICAgICAgICAgICAgICAgID8gYXdhaXQgdGhpcy5fY29udmVydFRvRmlybVF1b3Rlc0FzeW5jKHF1b3Rlc1dpdGhHYXNGZWUsIHF1b3RlQ29udGV4dClcbiAgICAgICAgICAgICAgICA6IGF3YWl0IHRoaXMuX2ZldGNoRmlybVF1b3Rlc0FzeW5jKHF1b3RlQ29udGV4dCwgZmVlV2l0aERldGFpbHMpO1xuXG4gICAgICAgIC8vIChRdW90ZSBSZXBvcnQpIElmIGBxdW90ZXNXaXRoR2FzRmVlYCBoYXZlIG5vdCBiZWVuIHJldXNlZCwgc2F2ZSB0aGVtIGFzIGludGVybWVkaWF0ZSBxdW90ZXNcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlUXVvdGVzID0gcXVvdGVzV2l0aEdhc0ZlZSAmJiBvdGhlckZlZXNBbW91bnQuZ3QoWkVSTykgPyBxdW90ZXNXaXRoR2FzRmVlIDogW107XG5cbiAgICAgICAgLy8gKE1ha2VyIEJhbGFuY2UgQ2FjaGUpIEZldGNoIG1ha2VyIGJhbGFuY2VzIHRvIHZhbGlkYXRlIHdoZXRoZXIgcXVvdGVzIGFyZSBmdWxseSBmaWxsYWJsZVxuICAgICAgICBsZXQgcXVvdGVkTWFrZXJCYWxhbmNlczogQmlnTnVtYmVyW10gfCB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHF1b3RlZEVSQzIwT3duZXJzID0gZmluYWxRdW90ZXMubWFwKChxdW90ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvd25lcjogcXVvdGUub3JkZXIubWFrZXIsXG4gICAgICAgICAgICAgICAgdG9rZW46IG1ha2VyVG9rZW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHF1b3RlZE1ha2VyQmFsYW5jZXMgPSBhd2FpdCB0aGlzLl9yZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UuZ2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmMoXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhaW5JZCxcbiAgICAgICAgICAgICAgICBxdW90ZWRFUkMyME93bmVycyxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICB7IGNoYWluSWQ6IHRoaXMuX2NoYWluSWQsIHF1b3RlZEVSQzIwT3duZXJzLCBlcnJvck1lc3NhZ2U6IGUubWVzc2FnZSB9LFxuICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZmV0Y2ggbWFrZXIgYmFsYW5jZXMgdG8gdmFsaWRhdGUgZmlybSBxdW90ZXMnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0aGUgYmVzdCBxdW90ZVxuICAgICAgICBjb25zdCBiZXN0UXVvdGUgPSBnZXRCZXN0UXVvdGUoXG4gICAgICAgICAgICBmaW5hbFF1b3RlcyxcbiAgICAgICAgICAgIGlzU2VsbGluZyxcbiAgICAgICAgICAgIHRha2VyVG9rZW4sXG4gICAgICAgICAgICBtYWtlclRva2VuLFxuICAgICAgICAgICAgYXNzZXRGaWxsQW1vdW50LFxuICAgICAgICAgICAgdGhpcy5fbWluRXhwaXJ5RHVyYXRpb25NcyxcbiAgICAgICAgICAgIHF1b3RlZE1ha2VyQmFsYW5jZXMsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgaXNMaXF1aWRpdHlBdmFpbGFibGUgPSBiZXN0UXVvdGUgIT09IG51bGw7XG5cbiAgICAgICAgY29uc3Qgc3RvcmVkRmVlV2l0aERldGFpbHMgPSBmZWVUb1N0b3JlZEZlZShmZWVXaXRoRGV0YWlscyk7XG5cbiAgICAgICAgbGV0IHF1b3RlUmVwb3J0SWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICAvLyBRdW90ZSBSZXBvcnRcbiAgICAgICAgaWYgKHRoaXMuX2thZmthUHJvZHVjZXIpIHtcbiAgICAgICAgICAgIHF1b3RlUmVwb3J0SWQgPSBhd2FpdCBxdW90ZVJlcG9ydFV0aWxzLnB1Ymxpc2hSRlFNUXVvdGVSZXBvcnRBc3luYyhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlzRmlybVF1b3RlOiBpc0Zpcm0sXG4gICAgICAgICAgICAgICAgICAgIHRha2VyOiB0YWtlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGJ1eVRva2VuQWRkcmVzczogb3JpZ2luYWxNYWtlclRva2VuLFxuICAgICAgICAgICAgICAgICAgICBzZWxsVG9rZW5BZGRyZXNzOiB0YWtlclRva2VuLFxuICAgICAgICAgICAgICAgICAgICBidXlBbW91bnQ6IG1ha2VyQW1vdW50LFxuICAgICAgICAgICAgICAgICAgICBzZWxsQW1vdW50OiB0YWtlckFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyYXRvcklkOiBpbnRlZ3JhdG9yPy5pbnRlZ3JhdG9ySWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsUXVvdGVzLFxuICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVRdW90ZXMsXG4gICAgICAgICAgICAgICAgICAgIGJlc3RRdW90ZSxcbiAgICAgICAgICAgICAgICAgICAgZmVlOiBzdG9yZWRGZWVXaXRoRGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgYW1tUXVvdGVVbmlxdWVJZCxcbiAgICAgICAgICAgICAgICAgICAgaXNMaXF1aWRpdHlBdmFpbGFibGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzLl9rYWZrYVByb2R1Y2VyLFxuICAgICAgICAgICAgICAgIHRoaXMuX3F1b3RlUmVwb3J0VG9waWMsXG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRRdW90ZVJlcG9ydFN1Ym1pc3Npb25CeSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyBxdW90ZSBmb3VuZFxuICAgICAgICBpZiAoIWlzTGlxdWlkaXR5QXZhaWxhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBxdW90ZTogbnVsbCwgcXVvdGVSZXBvcnRJZCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHRoZSBtYWtlclVyaVxuICAgICAgICBjb25zdCBtYWtlclVyaSA9IGJlc3RRdW90ZS5tYWtlclVyaTtcbiAgICAgICAgaWYgKG1ha2VyVXJpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcih7IG1ha2VyQWRkcmVzczogYmVzdFF1b3RlLm9yZGVyLm1ha2VyIH0sICdtYWtlclVyaSB1bmtub3duIGZvciBtYWtlciBhZGRyZXNzJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1ha2VyVXJpIHVua25vd24gZm9yIG1ha2VyIGFkZHJlc3MgJHtiZXN0UXVvdGUub3JkZXIubWFrZXJ9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmVwYXJlIHRoZSBwcmljZVxuICAgICAgICBjb25zdCBtYWtlckFtb3VudEluVW5pdCA9IFdlYjNXcmFwcGVyLnRvVW5pdEFtb3VudChiZXN0UXVvdGUub3JkZXIubWFrZXJBbW91bnQsIG1ha2VyVG9rZW5EZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IHRha2VyQW1vdW50SW5Vbml0ID0gV2ViM1dyYXBwZXIudG9Vbml0QW1vdW50KGJlc3RRdW90ZS5vcmRlci50YWtlckFtb3VudCwgdGFrZXJUb2tlbkRlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgcHJpY2UgPSBpc1NlbGxpbmcgPyBtYWtlckFtb3VudEluVW5pdC5kaXYodGFrZXJBbW91bnRJblVuaXQpIDogdGFrZXJBbW91bnRJblVuaXQuZGl2KG1ha2VyQW1vdW50SW5Vbml0KTtcbiAgICAgICAgLy8gVGhlIHdheSB0aGUgQmlnTnVtYmVyIHJvdW5kIGRvd24gYmVoYXZpb3IgKGh0dHBzOi8vbWlrZW1jbC5naXRodWIuaW8vYmlnbnVtYmVyLmpzLyNkcCkgd29ya3MgcmVxdWlyZXMgdXNcbiAgICAgICAgLy8gdG8gYWRkIDEgdG8gUFJJQ0VfREVDSU1BTF9QTEFDRVMgaW4gb3JkZXIgdG8gYWN0dWFsbHkgY29tZSBvdXQgd2l0aCB0aGUgZGVjaW1hbCBwbGFjZXMgc3BlY2lmaWVkLlxuICAgICAgICBjb25zdCByb3VuZGVkUHJpY2UgPSBwcmljZS5kZWNpbWFsUGxhY2VzKFBSSUNFX0RFQ0lNQUxfUExBQ0VTICsgMSwgQmlnTnVtYmVyLlJPVU5EX0RPV04pO1xuXG4gICAgICAgIC8vIFByZXBhcmUgdGhlIGZpbmFsIHRha2VyQW1vdW50IGFuZCBtYWtlckFtb3VudFxuICAgICAgICBjb25zdCBzZWxsQW1vdW50ID0gaXNTZWxsaW5nXG4gICAgICAgICAgICA/IC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgdGFrZXJBbW91bnQhXG4gICAgICAgICAgICA6IFJmcW1TZXJ2aWNlLl9nZXRTZWxsQW1vdW50R2l2ZW5CdXlBbW91bnRBbmRRdW90ZShcbiAgICAgICAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICBtYWtlckFtb3VudCEsXG4gICAgICAgICAgICAgICAgICBiZXN0UXVvdGUub3JkZXIudGFrZXJBbW91bnQsXG4gICAgICAgICAgICAgICAgICBiZXN0UXVvdGUub3JkZXIubWFrZXJBbW91bnQsXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgYnV5QW1vdW50ID0gaXNTZWxsaW5nXG4gICAgICAgICAgICA/IFJmcW1TZXJ2aWNlLl9nZXRCdXlBbW91bnRHaXZlblNlbGxBbW91bnRBbmRRdW90ZShcbiAgICAgICAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICB0YWtlckFtb3VudCEsXG4gICAgICAgICAgICAgICAgICBiZXN0UXVvdGUub3JkZXIudGFrZXJBbW91bnQsXG4gICAgICAgICAgICAgICAgICBiZXN0UXVvdGUub3JkZXIubWFrZXJBbW91bnQsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICBtYWtlckFtb3VudCE7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBPcmRlciBhbmQgaXRzIGhhc2hcbiAgICAgICAgY29uc3Qgb3JkZXJIYXNoID0gYmVzdFF1b3RlLm9yZGVyLmdldEhhc2goKTtcblxuICAgICAgICBjb25zdCBvdGNPcmRlciA9IGJlc3RRdW90ZS5vcmRlcjtcbiAgICAgICAgYXdhaXQgdGhpcy5fZGJVdGlscy53cml0ZVYyUXVvdGVBc3luYyh7XG4gICAgICAgICAgICBvcmRlckhhc2gsXG4gICAgICAgICAgICBjaGFpbklkOiB0aGlzLl9jaGFpbklkLFxuICAgICAgICAgICAgZmVlOiBzdG9yZWRGZWVXaXRoRGV0YWlscyxcbiAgICAgICAgICAgIG9yZGVyOiBvdGNPcmRlclRvU3RvcmVkT3RjT3JkZXIob3RjT3JkZXIpLFxuICAgICAgICAgICAgbWFrZXJVcmksXG4gICAgICAgICAgICBhZmZpbGlhdGVBZGRyZXNzLFxuICAgICAgICAgICAgaW50ZWdyYXRvcklkOiBpbnRlZ3JhdG9yLmludGVncmF0b3JJZCxcbiAgICAgICAgICAgIGlzVW53cmFwLFxuICAgICAgICAgICAgdGFrZXJTcGVjaWZpZWRTaWRlOiBwYXJhbXMuc2VsbEFtb3VudCA/ICd0YWtlclRva2VuJyA6ICdtYWtlclRva2VuJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYXBwcm92YWwgPSBwYXJhbXMuY2hlY2tBcHByb3ZhbFxuICAgICAgICAgICAgPyAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0R2FzbGVzc0FwcHJvdmFsUmVzcG9uc2VBc3luYyh0YWtlckFkZHJlc3MhLCB0YWtlclRva2VuLCBzZWxsQW1vdW50KVxuICAgICAgICAgICAgOiBudWxsO1xuXG4gICAgICAgIFJGUU1fUVVPVEVfSU5TRVJURUQubGFiZWxzKGludGVncmF0b3IuaW50ZWdyYXRvcklkLCBpbnRlZ3JhdG9yLmludGVncmF0b3JJZCwgbWFrZXJVcmkpLmluYygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVvdGU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBHYXNsZXNzVHlwZXMuT3RjT3JkZXIsXG4gICAgICAgICAgICAgICAgcHJpY2U6IHJvdW5kZWRQcmljZSxcbiAgICAgICAgICAgICAgICBnYXM6IGZlZVdpdGhEZXRhaWxzLmRldGFpbHMuZ2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgYnV5QW1vdW50LFxuICAgICAgICAgICAgICAgIGJ1eVRva2VuQWRkcmVzczogb3JpZ2luYWxNYWtlclRva2VuLFxuICAgICAgICAgICAgICAgIHNlbGxBbW91bnQsXG4gICAgICAgICAgICAgICAgc2VsbFRva2VuQWRkcmVzczogYmVzdFF1b3RlLm9yZGVyLnRha2VyVG9rZW4sXG4gICAgICAgICAgICAgICAgYWxsb3dhbmNlVGFyZ2V0OiB0aGlzLl9jb250cmFjdEFkZHJlc3Nlcy5leGNoYW5nZVByb3h5LFxuICAgICAgICAgICAgICAgIG9yZGVyOiBiZXN0UXVvdGUub3JkZXIsXG4gICAgICAgICAgICAgICAgb3JkZXJIYXNoLFxuICAgICAgICAgICAgICAgIC8vIHVzZSBhcHByb3ZhbCB2YXJpYWJsZSBkaXJlY3RseSBpcyBub3QgaWRlYWwgYXMgd2UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlIGFwcHJvdmFsIGZpZWxkIGlmIGBhcHByb3ZhbGAgaXMgbnVsbFxuICAgICAgICAgICAgICAgIC4uLihhcHByb3ZhbCAmJiB7IGFwcHJvdmFsIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHF1b3RlUmVwb3J0SWQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgYXBwcm92YWwgcmVzcG9uc2UgaW4gZmlybSBxdW90ZSByZXNwb25zZXMuIFRoZSBhcHByb3ZhbCByZXNwb25zZSBjb250YWlucyB3aGV0aGVyIGFuIGFwcHJvdmFsIGlzIHJlcXVpcmVkLCBpcyBnYXNsZXNzIGFwcHJvdmFsXG4gICAgICogaXMgYXZhaWxhYmxlIGZvciB0aGUgdG9rZW4gKG9wdGlvbmFsKSwgdGhlIHR5cGUgb2YgdGhlIGdhc2xlc3MgYXBwcm92YWwgKG9wdGlvbmFsKSBhbmQgdGhlIEVJUDcxMiBjb250ZXh0IChvcHRpb25hbCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFrZXJBZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoZSB0YWtlci5cbiAgICAgKiBAcGFyYW0gdG9rZW5Ub0FwcHJvdmUgVG9rZW4gYWRkcmVzcyB0byBiZSBhcHByb3ZlZC5cbiAgICAgKiBAcGFyYW0gc2VsbEFtb3VudCBBbW91bnQgb2YgdG9rZW4gdG8gc2VsbCBpbiBiYXNlIHVuaXQuXG4gICAgICogQHJldHVybnMgVGhlIGFwcHJvdmFsIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRHYXNsZXNzQXBwcm92YWxSZXNwb25zZUFzeW5jKFxuICAgICAgICB0YWtlckFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgdG9rZW5Ub0FwcHJvdmU6IHN0cmluZyxcbiAgICAgICAgc2VsbEFtb3VudDogQmlnTnVtYmVyLFxuICAgICk6IFByb21pc2U8QXBwcm92YWxSZXNwb25zZT4ge1xuICAgICAgICBjb25zdCBhbGxvd2FuY2UgPSBhd2FpdCB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZ2V0QWxsb3dhbmNlQXN5bmMoXG4gICAgICAgICAgICB0b2tlblRvQXBwcm92ZSxcbiAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZXRFeGNoYW5nZVByb3h5QWRkcmVzcygpLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpc1JlcXVpcmVkID0gYWxsb3dhbmNlLmx0ZShzZWxsQW1vdW50KTtcbiAgICAgICAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzUmVxdWlyZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ2FzbGVzc0FwcHJvdmFsID0gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldEdhc2xlc3NBcHByb3ZhbEFzeW5jKFxuICAgICAgICAgICAgdGhpcy5fY2hhaW5JZCxcbiAgICAgICAgICAgIHRva2VuVG9BcHByb3ZlLFxuICAgICAgICAgICAgdGFrZXJBZGRyZXNzLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpc0dhc2xlc3NBdmFpbGFibGUgPSBnYXNsZXNzQXBwcm92YWwgIT09IG51bGw7XG4gICAgICAgIGlmICghaXNHYXNsZXNzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzUmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgaXNHYXNsZXNzQXZhaWxhYmxlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1JlcXVpcmVkLFxuICAgICAgICAgICAgaXNHYXNsZXNzQXZhaWxhYmxlLFxuICAgICAgICAgICAgdHlwZTogZ2FzbGVzc0FwcHJvdmFsLmtpbmQsXG4gICAgICAgICAgICBlaXA3MTI6IGdhc2xlc3NBcHByb3ZhbC5laXA3MTIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGdldFN0YXR1c0FzeW5jKHRyYWRlSGFzaDogc3RyaW5nKTogUHJvbWlzZTxTdGF0dXNSZXNwb25zZSB8IG51bGw+IHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtU3VibWlzc2lvbnMgPSAoXG4gICAgICAgICAgICBzdWJtaXNzaW9uczogUmZxbVYyVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5W10gfCBNZXRhVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5W10sXG4gICAgICAgICkgPT4ge1xuICAgICAgICAgICAgLy8gYF90cmFuc2Zvcm1UcmFuc2FjdGlvblN1Ym1pc3Npb25gIGlzIGEgc3RhdGljIG1ldGhvZCBzbyBuby11bmJvdW5kLW1ldGhvZCBkb2VzIG5vdCBhcHBseSBoZXJlXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW5ib3VuZC1tZXRob2RcbiAgICAgICAgICAgIHJldHVybiBzdWJtaXNzaW9ucy5tYXAoUmZxbVNlcnZpY2UuX3RyYW5zZm9ybVRyYW5zYWN0aW9uU3VibWlzc2lvbikuZmxhdE1hcCgocykgPT4gKHMgPyBzIDogW10pKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBqb2IgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLl9kYlV0aWxzLmZpbmRWMkpvYkJ5T3JkZXJIYXNoQXN5bmModHJhZGVIYXNoKSxcbiAgICAgICAgICAgIHRoaXMuX2RiVXRpbHMuZmluZE1ldGFUcmFuc2FjdGlvbkpvYkJ5TWV0YVRyYW5zYWN0aW9uSGFzaEFzeW5jKHRyYWRlSGFzaCksXG4gICAgICAgIF0pLnRoZW4oKGpvYnMpID0+IGpvYnMuZmluZCgoeCkgPT4geCkpO1xuXG4gICAgICAgIGlmICgham9iKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBleHBpcnkgfSA9IGpvYjtcblxuICAgICAgICBpZiAoc3RhdHVzID09PSBSZnFtSm9iU3RhdHVzLlBlbmRpbmdFbnF1ZXVlZCAmJiBleHBpcnkubXVsdGlwbGllZEJ5KE9ORV9TRUNPTkRfTVMpLmx0KERhdGUubm93KCkpKSB7XG4gICAgICAgICAgICAvLyB0aGUgd29ya2VycyBhcmUgZGVhZC9vbiB2YWNhdGlvbiBhbmQgdGhlIGV4cGlyYXRpb24gdGltZSBoYXMgcGFzc2VkXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogJ2ZhaWxlZCcsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBbXSxcbiAgICAgICAgICAgICAgICAuLi4oUkVBU09OX09OX1NUQVRVU19FUlJPUl9SRVNQT05TRV9FTkFCTEVEICYmIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBKb2JGYWlsdXJlUmVhc29uLk9yZGVyRXhwaXJlZCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0cmFkZVRyYW5zYWN0aW9uU3VibWlzc2lvbnMgPVxuICAgICAgICAgICAgam9iLmtpbmQgPT09ICdyZnFtX3YyX2pvYidcbiAgICAgICAgICAgICAgICA/IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZFYyVHJhbnNhY3Rpb25TdWJtaXNzaW9uc0J5T3JkZXJIYXNoQXN5bmMoXG4gICAgICAgICAgICAgICAgICAgICAgam9iLm9yZGVySGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZS5UcmFkZSxcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZE1ldGFUcmFuc2FjdGlvblN1Ym1pc3Npb25zQnlKb2JJZEFzeW5jKFxuICAgICAgICAgICAgICAgICAgICAgIGpvYi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZS5UcmFkZSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgIGNvbnN0IHNob3VsZEluY2x1ZGVBcHByb3ZhbCA9ICEham9iLmFwcHJvdmFsO1xuICAgICAgICBsZXQgYXBwcm92YWxUcmFuc2FjdGlvblN1Ym1pc3Npb25zOiBSZnFtVjJUcmFuc2FjdGlvblN1Ym1pc3Npb25FbnRpdHlbXSB8IE1ldGFUcmFuc2FjdGlvblN1Ym1pc3Npb25FbnRpdHlbXSA9XG4gICAgICAgICAgICBbXTtcbiAgICAgICAgaWYgKHNob3VsZEluY2x1ZGVBcHByb3ZhbCkge1xuICAgICAgICAgICAgYXBwcm92YWxUcmFuc2FjdGlvblN1Ym1pc3Npb25zID1cbiAgICAgICAgICAgICAgICBqb2Iua2luZCA9PT0gJ3JmcW1fdjJfam9iJ1xuICAgICAgICAgICAgICAgICAgICA/IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZFYyVHJhbnNhY3Rpb25TdWJtaXNzaW9uc0J5T3JkZXJIYXNoQXN5bmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGpvYi5vcmRlckhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25UeXBlLkFwcHJvdmFsLFxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiBhd2FpdCB0aGlzLl9kYlV0aWxzLmZpbmRNZXRhVHJhbnNhY3Rpb25TdWJtaXNzaW9uc0J5Sm9iSWRBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgam9iLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZS5BcHByb3ZhbCxcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5QZW5kaW5nRW5xdWV1ZWQ6XG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuUGVuZGluZ1Byb2Nlc3Npbmc6XG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuUGVuZGluZ0xhc3RMb29rQWNjZXB0ZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAncGVuZGluZycsIHRyYW5zYWN0aW9uczogW10gfTtcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5QZW5kaW5nU3VibWl0dGVkOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ3N1Ym1pdHRlZCcsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uczogdHJhbnNmb3JtU3VibWlzc2lvbnModHJhZGVUcmFuc2FjdGlvblN1Ym1pc3Npb25zKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKHNob3VsZEluY2x1ZGVBcHByb3ZhbCAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHByb3ZhbFRyYW5zYWN0aW9uczogdHJhbnNmb3JtU3VibWlzc2lvbnMoYXBwcm92YWxUcmFuc2FjdGlvblN1Ym1pc3Npb25zKSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRFdGhDYWxsRmFpbGVkOlxuICAgICAgICAgICAgY2FzZSBSZnFtSm9iU3RhdHVzLkZhaWxlZEV4cGlyZWQ6XG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuRmFpbGVkTGFzdExvb2tEZWNsaW5lZDpcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRQcmVzaWduVmFsaWRhdGlvbkZhaWxlZDpcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRSZXZlcnRlZENvbmZpcm1lZDpcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRSZXZlcnRlZFVuY29uZmlybWVkOlxuICAgICAgICAgICAgY2FzZSBSZnFtSm9iU3RhdHVzLkZhaWxlZFNpZ25GYWlsZWQ6XG4gICAgICAgICAgICBjYXNlIFJmcW1Kb2JTdGF0dXMuRmFpbGVkU3VibWl0RmFpbGVkOlxuICAgICAgICAgICAgY2FzZSBSZnFtSm9iU3RhdHVzLkZhaWxlZFZhbGlkYXRpb25Ob0NhbGxEYXRhOlxuICAgICAgICAgICAgY2FzZSBSZnFtSm9iU3RhdHVzLkZhaWxlZFZhbGlkYXRpb25Ob0ZlZTpcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRWYWxpZGF0aW9uTm9NYWtlclVyaTpcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRWYWxpZGF0aW9uTm9PcmRlcjpcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5GYWlsZWRWYWxpZGF0aW9uTm9UYWtlclNpZ25hdHVyZTpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6ICdmYWlsZWQnLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IHRyYW5zZm9ybVN1Ym1pc3Npb25zKHRyYWRlVHJhbnNhY3Rpb25TdWJtaXNzaW9ucyksXG4gICAgICAgICAgICAgICAgICAgIC4uLihzaG91bGRJbmNsdWRlQXBwcm92YWwgJiYge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwcm92YWxUcmFuc2FjdGlvbnM6IHRyYW5zZm9ybVN1Ym1pc3Npb25zKGFwcHJvdmFsVHJhbnNhY3Rpb25TdWJtaXNzaW9ucyksXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAuLi4oUkVBU09OX09OX1NUQVRVU19FUlJPUl9SRVNQT05TRV9FTkFCTEVEICYmIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogUmZxbVNlcnZpY2UuX2pvYkZhaWx1cmVTdGF0dXNUb1JlYXNvbihzdGF0dXMpLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBSZnFtSm9iU3RhdHVzLlN1Y2NlZWRlZENvbmZpcm1lZDpcbiAgICAgICAgICAgIGNhc2UgUmZxbUpvYlN0YXR1cy5TdWNjZWVkZWRVbmNvbmZpcm1lZDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyA9PT0gUmZxbUpvYlN0YXR1cy5TdWNjZWVkZWRVbmNvbmZpcm1lZCA/ICdzdWNjZWVkZWQnIDogJ2NvbmZpcm1lZCcsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgUmZxbVNlcnZpY2UuX2dldFN1Y2Nlc3NmdWxUcmFuc2FjdGlvblN1Ym1pc3Npb25EZXRhaWxzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBqb2IuZ2V0SGFzaCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25UeXBlLlRyYWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3VibXNzaW9uczogdHJhZGVUcmFuc2FjdGlvblN1Ym1pc3Npb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIC4uLihzaG91bGRJbmNsdWRlQXBwcm92YWwgJiYge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwcm92YWxUcmFuc2FjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZnFtU2VydmljZS5fZ2V0U3VjY2Vzc2Z1bFRyYW5zYWN0aW9uU3VibWlzc2lvbkRldGFpbHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBqb2IuZ2V0SGFzaCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZS5BcHByb3ZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TdWJtc3Npb25zOiBhcHByb3ZhbFRyYW5zYWN0aW9uU3VibWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAoKF94OiBuZXZlcik6IG5ldmVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlYWNoYWJsZScpO1xuICAgICAgICAgICAgICAgIH0pKHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGNoZWNrcyB0byBkZXRlcm1pbmUgdGhlIGhlYWx0aCBvZiB0aGUgUkZRbSBzeXN0ZW0uIFRoZSByZXN1bHRzIG1heSBiZSBkaXN0aWxsZWQgdG8gYSBmb3JtYXQgbmVlZGVkIGJ5IGludGVncmF0b3JzLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBydW5IZWFsdGhDaGVja0FzeW5jKCk6IFByb21pc2U8SGVhbHRoQ2hlY2tSZXN1bHQ+IHtcbiAgICAgICAgY29uc3QgaGVhcnRiZWF0cyA9IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZFJmcW1Xb3JrZXJIZWFydGJlYXRzQXN5bmModGhpcy5fY2hhaW5JZCk7XG4gICAgICAgIGxldCBnYXNQcmljZTogQmlnTnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ2FzUHJpY2UgPSBhd2FpdCB0aGlzLl9mZWVTZXJ2aWNlLmdldEdhc1ByaWNlRXN0aW1hdGlvbkFzeW5jKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIud2Fybih7IGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSB9LCAnRmFpbGVkIHRvIGdldCBnYXMgcHJpY2UgZm9yIGhlYWx0aCBjaGVjaycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wdXRlSGVhbHRoQ2hlY2tBc3luYyhcbiAgICAgICAgICAgIFJGUU1fTUFJTlRFTkFOQ0VfTU9ERSxcbiAgICAgICAgICAgIHRoaXMuX3JmcU1ha2VyTWFuYWdlci5nZXRSZnFtVjJNYWtlck9mZmVyaW5ncygpLFxuICAgICAgICAgICAgdGhpcy5fc3FzUHJvZHVjZXIsXG4gICAgICAgICAgICBoZWFydGJlYXRzLFxuICAgICAgICAgICAgdGhpcy5fY2hhaW5JZCxcbiAgICAgICAgICAgIGdhc1ByaWNlLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBhbmQgZW5xdWV1ZXMgdGhlIFRha2VyIFNpZ25lZCBPdGMgT3JkZXIgd2l0aCBhcHByb3ZhbCBmb3Igc3VibWlzc2lvbi5cbiAgICAgKiBDYW4gYWxzbyBiZSB1c2VkIHRvIHN1Ym1pdCBvcmRlciB3aXRob3V0IGFwcHJvdmFsIGlmIGFwcHJvdmFsIHBhcmFtcyBhcmUgbm90IHN1cHBsaWVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBzdWJtaXRUYWtlclNpZ25lZE90Y09yZGVyV2l0aEFwcHJvdmFsQXN5bmM8XG4gICAgICAgIFQgZXh0ZW5kcyBFeGVjdXRlTWV0YVRyYW5zYWN0aW9uRWlwNzEyQ29udGV4dCB8IFBlcm1pdEVpcDcxMkNvbnRleHQsXG4gICAgPihwYXJhbXM6IFN1Ym1pdFJmcW1TaWduZWRRdW90ZVdpdGhBcHByb3ZhbFBhcmFtczxUPik6IFByb21pc2U8U3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUmVzcG9uc2U+IHtcbiAgICAgICAgbGV0IHN1Ym1pdFJmcW1TaWduZWRRdW90ZVdpdGhBcHByb3ZhbFJlczogU3VibWl0UmZxbVNpZ25lZFF1b3RlV2l0aEFwcHJvdmFsUmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IHsgYXBwcm92YWwsIHRyYWRlIH0gPSBwYXJhbXM7XG5cbiAgICAgICAgY29uc3QgcmZxbUFwcHJvdmFsT3B0cyA9IGFwcHJvdmFsXG4gICAgICAgICAgICA/IGF3YWl0IHRoaXMuY3JlYXRlQXBwcm92YWxBc3luYyhhcHByb3ZhbCwgdHJhZGUub3JkZXIuZ2V0SGFzaCgpLCB0cmFkZS5vcmRlci50YWtlclRva2VuKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgICAgICBzdWJtaXRSZnFtU2lnbmVkUXVvdGVXaXRoQXBwcm92YWxSZXMgPSBhd2FpdCB0aGlzLnN1Ym1pdFRha2VyU2lnbmVkT3RjT3JkZXJBc3luYyh0cmFkZSwgcmZxbUFwcHJvdmFsT3B0cyk7XG5cbiAgICAgICAgcmV0dXJuIHN1Ym1pdFJmcW1TaWduZWRRdW90ZVdpdGhBcHByb3ZhbFJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYSBzaWduZWQgYXBwcm92YWwgc2VudCB0byB0aGUgc3VibWlzc2lvbiBlbmRwb2ludCBpbiBvcmRlciB0b1xuICAgICAqIGNyZWF0ZSB0aGUgYXBwcm92YWwgZGF0YSBuZWVkZWQgYnkgdGhlIGpvYi5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgY3JlYXRlQXBwcm92YWxBc3luYzxUIGV4dGVuZHMgRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkVpcDcxMkNvbnRleHQgfCBQZXJtaXRFaXA3MTJDb250ZXh0PihcbiAgICAgICAgYXBwcm92YWw6IFN1Ym1pdEFwcHJvdmFsUGFyYW1zPFQ+LFxuICAgICAgICB0cmFkZUhhc2g6IHN0cmluZyxcbiAgICAgICAgdGFrZXJUb2tlbjogc3RyaW5nLFxuICAgICk6IFByb21pc2U8UmZxbVYySm9iQXBwcm92YWxPcHRzPiB7XG4gICAgICAgIGxldCB7IHNpZ25hdHVyZSB9ID0gYXBwcm92YWw7XG5cbiAgICAgICAgLy8gdmFsaWRhdGUgYW5kIGNvbnZlcnQgRUlQNzEyIGNvbnRleHQgdG8gY29ycmVzcG9uZGluZyBBcHByb3ZhbCBvYmplY3RcbiAgICAgICAgY29uc3QgcGFyc2VkQXBwcm92YWwgPSB0aGlzLl9jb252ZXJ0RUlQNzEyQ29udGV4dFRvQXBwcm92YWwoYXBwcm92YWwuZWlwNzEyLCB0cmFkZUhhc2gpO1xuXG4gICAgICAgIC8vIHBhZCBhcHByb3ZhbCBzaWduYXR1cmUgaWYgdGhlcmUgYXJlIG1pc3NpbmcgYnl0ZXNcbiAgICAgICAgY29uc3QgcGFkZGVkU2lnbmF0dXJlID0gcGFkU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChwYWRkZWRTaWduYXR1cmUuciAhPT0gc2lnbmF0dXJlLnIgfHwgcGFkZGVkU2lnbmF0dXJlLnMgIT09IHNpZ25hdHVyZS5zKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgICB7IHRyYWRlSGFzaCwgcjogcGFkZGVkU2lnbmF0dXJlLnIsIHM6IHBhZGRlZFNpZ25hdHVyZS5zIH0sXG4gICAgICAgICAgICAgICAgJ0dvdCBhcHByb3ZhbCBzaWduYXR1cmUgd2l0aCBtaXNzaW5nIGJ5dGVzJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSBwYWRkZWRTaWduYXR1cmU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwZXJmb3JtIGFuIGV0aF9jYWxsIG9uIHRoZSBhcHByb3ZhbCBvYmplY3QgYW5kIHNpZ25hdHVyZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXBwcm92YWxDYWxsZGF0YSA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZW5lcmF0ZUFwcHJvdmFsQ2FsbGRhdGFBc3luYyhcbiAgICAgICAgICAgICAgICB0YWtlclRva2VuLFxuICAgICAgICAgICAgICAgIHBhcnNlZEFwcHJvdmFsLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBgZXN0aW1hdGVHYXNGb3JBc3luY2AgdG8gc2ltdWxhdGUgdGhlIHRyYW5zYWN0aW9uLiBJbiBldGhlcnMuanMsIHByb3ZpZGVyLmNhbGwgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3ZpZGVyLnNlbmQoJ2V0aF9jYWxsJywgLi4uKSBtaWdodCBub3QgdGhyb3cgZXhjZXB0aW9uIGFuZCB0aGUgYmVoYXZpb3IgbWlnaHQgYmUgZGVwZW5kZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIHByb3ZpZGVycy4gUmV2aXNpdCB0aGlzIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZXN0aW1hdGVHYXNGb3JBc3luYyh7IHRvOiB0YWtlclRva2VuLCBkYXRhOiBhcHByb3ZhbENhbGxkYXRhIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkZWxheTogT05FX1NFQ09ORF9NUyxcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yOiAxLFxuICAgICAgICAgICAgICAgICAgICBtYXhBdHRlbXB0czogMyxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3I6IChlcnJvciwgY29udGV4dCwgX29wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYXR0ZW1wdE51bTogYXR0ZW1wdE51bWJlciwgYXR0ZW1wdHNSZW1haW5pbmcgfSA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVtcHROdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzUmVtYWluaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhZGVIYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Vycm9yIGR1cmluZyBldGhfY2FsbCBhcHByb3ZhbCB2YWxpZGF0aW9uLiBSZXRyeWluZy4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcih7IGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSB9LCAnRXRoIGNhbGwgYXBwcm92YWwgdmFsaWRhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXRoIGNhbGwgYXBwcm92YWwgdmFsaWRhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcHByb3ZhbDogcGFyc2VkQXBwcm92YWwsXG4gICAgICAgICAgICBhcHByb3ZhbFNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBhbmQgZW5xdWV1ZXMgdGhlIFRha2VyIFNpZ25lZCBPdGMgT3JkZXIgZm9yIHN1Ym1pc3Npb25cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgc3VibWl0VGFrZXJTaWduZWRPdGNPcmRlckFzeW5jKFxuICAgICAgICBwYXJhbXM6IE90Y09yZGVyU3VibWl0UmZxbVNpZ25lZFF1b3RlUGFyYW1zLFxuICAgICAgICByZnFtQXBwcm92YWxPcHRzPzogUmZxbVYySm9iQXBwcm92YWxPcHRzLFxuICAgICk6IFByb21pc2U8T3RjT3JkZXJTdWJtaXRSZnFtU2lnbmVkUXVvdGVSZXNwb25zZT4ge1xuICAgICAgICBjb25zdCB7IG9yZGVyIH0gPSBwYXJhbXM7XG4gICAgICAgIGxldCB7IHNpZ25hdHVyZTogdGFrZXJTaWduYXR1cmUgfSA9IHBhcmFtcztcbiAgICAgICAgY29uc3Qgb3JkZXJIYXNoID0gb3JkZXIuZ2V0SGFzaCgpO1xuICAgICAgICBjb25zdCB0YWtlckFkZHJlc3MgPSBvcmRlci50YWtlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBtYWtlckFkZHJlc3MgPSBvcmRlci5tYWtlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB0YWtlclRva2VuID0gb3JkZXIudGFrZXJUb2tlbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBtYWtlclRva2VuID0gb3JkZXIubWFrZXJUb2tlbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBjaGVjayB0aGF0IHRoZSBvcmRlckhhc2ggaXMgaW5kZWVkIGEgcmVjb2duaXplZCBxdW90ZVxuICAgICAgICBjb25zdCBxdW90ZSA9IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZFYyUXVvdGVCeU9yZGVySGFzaEFzeW5jKG9yZGVySGFzaCk7XG4gICAgICAgIGlmICghcXVvdGUpIHtcbiAgICAgICAgICAgIFJGUU1fU0lHTkVEX1FVT1RFX05PVF9GT1VORC5pbmMoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKCdxdW90ZSBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkYXRlIHRoYXQgdGhlIGV4cGlyYXRpb24gd2luZG93IGlzIGxvbmcgZW5vdWdoIHRvIGZpbGwgcXVvdGVcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWVNcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBpZiAoIW9yZGVyLmV4cGlyeS50aW1lcyhPTkVfU0VDT05EX01TKS5pc0dyZWF0ZXJUaGFuKGN1cnJlbnRUaW1lTXMgKyB0aGlzLl9taW5FeHBpcnlEdXJhdGlvbk1zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ2V4cGlyeUFuZE5vbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogVmFsaWRhdGlvbkVycm9yQ29kZXMuRmllbGRJbnZhbGlkLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IGBvcmRlciB3aWxsIGV4cGlyZSB0b28gc29vbmAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWRhdGUgdGhhdCB0aGVyZSBpcyBub3QgYSBwZW5kaW5nIHRyYW5zYWN0aW9uIGZvciB0aGlzIHRha2VyIGFuZCB0YWtlciB0b2tlblxuICAgICAgICBjb25zdCBwZW5kaW5nSm9icyA9IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZFYySm9ic1dpdGhTdGF0dXNlc0FzeW5jKFtcbiAgICAgICAgICAgIFJmcW1Kb2JTdGF0dXMuUGVuZGluZ0VucXVldWVkLFxuICAgICAgICAgICAgUmZxbUpvYlN0YXR1cy5QZW5kaW5nUHJvY2Vzc2luZyxcbiAgICAgICAgICAgIFJmcW1Kb2JTdGF0dXMuUGVuZGluZ0xhc3RMb29rQWNjZXB0ZWQsXG4gICAgICAgICAgICBSZnFtSm9iU3RhdHVzLlBlbmRpbmdTdWJtaXR0ZWQsXG4gICAgICAgIF0pO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHBlbmRpbmdKb2JzLnNvbWUoXG4gICAgICAgICAgICAgICAgKGpvYikgPT5cbiAgICAgICAgICAgICAgICAgICAgam9iLm9yZGVyPy5vcmRlci50YWtlci50b0xvd2VyQ2FzZSgpID09PSBxdW90ZS5vcmRlcj8ub3JkZXIudGFrZXIudG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAgICAgICAgICAgICBqb2Iub3JkZXI/Lm9yZGVyLnRha2VyVG9rZW4udG9Mb3dlckNhc2UoKSA9PT0gcXVvdGUub3JkZXI/Lm9yZGVyLnRha2VyVG9rZW4udG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlciBsb2dpYyBoYW5kbGVzIHRoZSBjYXNlIHdoZXJlIHRoZSBzYW1lIG9yZGVyIGlzIHN1Ym1pdHRlZCB0d2ljZVxuICAgICAgICAgICAgICAgICAgICBqb2Iub3JkZXJIYXNoICE9PSBxdW90ZS5vcmRlckhhc2gsXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgUkZRTV9UQUtFUl9BTkRfVEFLRVJUT0tFTl9UUkFERV9FWElTVFMubGFiZWxzKHRoaXMuX2NoYWluSWQudG9TdHJpbmcoKSkuaW5jKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9vTWFueVJlcXVlc3RzRXJyb3IoJ2EgcGVuZGluZyB0cmFkZSBmb3IgdGhpcyB0YWtlciBhbmQgdGFrZXJ0b2tlbiBhbHJlYWR5IGV4aXN0cycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW4gdGhlIHVubGlrZWx5IGV2ZW50IHRoYXQgdGFrZXJzIHN1Ym1pdCBhIHNpZ25hdHVyZSB3aXRoIGEgbWlzc2luZyBieXRlLCBwYWQgdGhlIHNpZ25hdHVyZS5cbiAgICAgICAgY29uc3QgcGFkZGVkU2lnbmF0dXJlID0gcGFkU2lnbmF0dXJlKHRha2VyU2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKHBhZGRlZFNpZ25hdHVyZS5yICE9PSB0YWtlclNpZ25hdHVyZS5yIHx8IHBhZGRlZFNpZ25hdHVyZS5zICE9PSB0YWtlclNpZ25hdHVyZS5zKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgICB7IG9yZGVySGFzaCwgcjogcGFkZGVkU2lnbmF0dXJlLnIsIHM6IHBhZGRlZFNpZ25hdHVyZS5zIH0sXG4gICAgICAgICAgICAgICAgJ0dvdCB0YWtlciBzaWduYXR1cmUgd2l0aCBtaXNzaW5nIGJ5dGVzJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0YWtlclNpZ25hdHVyZSA9IHBhZGRlZFNpZ25hdHVyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkYXRlIHRoYXQgdGhlIGdpdmVuIHRha2VyIHNpZ25hdHVyZSBpcyB2YWxpZFxuICAgICAgICBjb25zdCBzaWduZXJBZGRyZXNzID0gZ2V0U2lnbmVyRnJvbUhhc2gob3JkZXJIYXNoLCB0YWtlclNpZ25hdHVyZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHNpZ25lckFkZHJlc3MgIT09IHRha2VyQWRkcmVzcykge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oeyBzaWduZXJBZGRyZXNzLCB0YWtlckFkZHJlc3MsIG9yZGVySGFzaCB9LCAnU2lnbmF0dXJlIGlzIGludmFsaWQnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdzaWduYXR1cmUnLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBWYWxpZGF0aW9uRXJyb3JDb2Rlcy5JbnZhbGlkU2lnbmF0dXJlT3JIYXNoLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IGBzaWduYXR1cmUgaXMgbm90IHZhbGlkYCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IG9yZGVyIGlzIGZpbGxhYmxlIGJ5IGJvdGggdGhlIG1ha2VyIGFuZCB0aGUgdGFrZXIgYWNjb3JkaW5nIHRvIGJhbGFuY2VzIGFuZC9vciBhbGxvd2FuY2VzLlxuICAgICAgICAvLyBJZiByZnFtQXBwcm92YWxPcHRzIGlzIG5vdCBwYXNzZWQsIGFsbG93YW5jZXMgYXJlIG5vdCBjaGVja2VkIGF0IHRoaXMgc3RhZ2Ugc2luY2UgZ2FzbGVzcyBhcHByb3ZhbCBoYXMgbm90IGJlZW4gZG9uZSB5ZXQuXG4gICAgICAgIGNvbnN0IFttYWtlckJhbGFuY2VdID0gYXdhaXQgdGhpcy5fcmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlLmdldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKHRoaXMuX2NoYWluSWQsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvd25lcjogbWFrZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgIHRva2VuOiBtYWtlclRva2VuLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IFt0YWtlckJhbGFuY2VdID0gcmZxbUFwcHJvdmFsT3B0c1xuICAgICAgICAgICAgPyBhd2FpdCB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZ2V0VG9rZW5CYWxhbmNlc0FzeW5jKHsgb3duZXI6IHRha2VyQWRkcmVzcywgdG9rZW46IHRha2VyVG9rZW4gfSlcbiAgICAgICAgICAgIDogYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgb3duZXI6IHRha2VyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIHRva2VuOiB0YWtlclRva2VuLFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWFrZXJCYWxhbmNlLmx0KG9yZGVyLm1ha2VyQW1vdW50KSB8fCB0YWtlckJhbGFuY2UubHQob3JkZXIudGFrZXJBbW91bnQpKSB7XG4gICAgICAgICAgICBSRlFNX1NVQk1JVF9CQUxBTkNFX0NIRUNLX0ZBSUxFRC5sYWJlbHMobWFrZXJBZGRyZXNzLCB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLmluYygpO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBtYWtlckJhbGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIHRha2VyQmFsYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgbWFrZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB0YWtlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIG9yZGVySGFzaCxcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnQmFsYW5jZSBjaGVjayBmYWlsZWQgd2hpbGUgdXNlciB3YXMgc3VibWl0dGluZycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ24vYScsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFZhbGlkYXRpb25FcnJvckNvZGVzLkludmFsaWRPcmRlcixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBgb3JkZXIgaXMgbm90IGZpbGxhYmxlYCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmVwYXJlIHRoZSBqb2JcbiAgICAgICAgbGV0IHJmcW1Kb2JPcHRzOiBSZnFtVjJKb2JDb25zdHJ1Y3Rvck9wdHMgPSB7XG4gICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgb3JkZXJIYXNoOiBxdW90ZS5vcmRlckhhc2ghLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgZXhwaXJ5OiBvcmRlci5leHBpcnksXG4gICAgICAgICAgICBjaGFpbklkOiB0aGlzLl9jaGFpbklkLFxuICAgICAgICAgICAgaW50ZWdyYXRvcklkOiBxdW90ZS5pbnRlZ3JhdG9ySWQgPyBxdW90ZS5pbnRlZ3JhdG9ySWQgOiBudWxsLFxuICAgICAgICAgICAgbWFrZXJVcmk6IHF1b3RlLm1ha2VyVXJpLFxuICAgICAgICAgICAgc3RhdHVzOiBSZnFtSm9iU3RhdHVzLlBlbmRpbmdFbnF1ZXVlZCxcbiAgICAgICAgICAgIGZlZTogcXVvdGUuZmVlLFxuICAgICAgICAgICAgb3JkZXI6IHF1b3RlLm9yZGVyLFxuICAgICAgICAgICAgdGFrZXJTaWduYXR1cmUsXG4gICAgICAgICAgICBhZmZpbGlhdGVBZGRyZXNzOiBxdW90ZS5hZmZpbGlhdGVBZGRyZXNzLFxuICAgICAgICAgICAgaXNVbndyYXA6IHF1b3RlLmlzVW53cmFwLFxuICAgICAgICAgICAgdGFrZXJTcGVjaWZpZWRTaWRlOiBxdW90ZS50YWtlclNwZWNpZmllZFNpZGUsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgYXBwcm92YWwgb3B0cyBhcmUgc3VwcGxpZWQsIGFkZCBwYXJhbXMgdG8gam9iIHRhYmxlXG4gICAgICAgIGlmIChyZnFtQXBwcm92YWxPcHRzKSB7XG4gICAgICAgICAgICByZnFtSm9iT3B0cyA9IHtcbiAgICAgICAgICAgICAgICAuLi5yZnFtSm9iT3B0cyxcbiAgICAgICAgICAgICAgICAuLi5yZnFtQXBwcm92YWxPcHRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMgaW5zZXJ0IHdpbGwgZmFpbCBpZiBhIGpvYiBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQsIGVuc3VyaW5nXG4gICAgICAgIC8vIHRoYXQgYSBzaWduZWQgcXVvdGUgY2Fubm90IGJlIHF1ZXVlZCB0d2ljZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGpvYiBkYXRhIGlzIHBlcnNpc3RlZCB0byBQb3N0Z3JlcyBiZWZvcmUgcXVldWVpbmcgdGFza1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGJVdGlscy53cml0ZVYySm9iQXN5bmMocmZxbUpvYk9wdHMpO1xuICAgICAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2VucXVldWVKb2JBc3luYyhxdW90ZS5vcmRlckhhc2ghLCBHYXNsZXNzVHlwZXMuT3RjT3JkZXIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKHsgZXJyb3JNZXNzYWdlOiBlcnJvci5tZXNzYWdlIH0sICdGYWlsZWQgdG8gcXVldWUgdGhlIHF1b3RlIGZvciBzdWJtaXNzaW9uLicpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludGVybmFsU2VydmVyRXJyb3IoXG4gICAgICAgICAgICAgICAgYGZhaWxlZCB0byBxdWV1ZSB0aGUgcXVvdGUgZm9yIHN1Ym1pc3Npb24sIGl0IG1heSBoYXZlIGFscmVhZHkgYmVlbiBzdWJtaXR0ZWRgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBHYXNsZXNzVHlwZXMuT3RjT3JkZXIsXG4gICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgb3JkZXJIYXNoOiBxdW90ZS5vcmRlckhhc2ghLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byByZXRyaWV2ZSBxdW90ZSBjb250ZXh0LCBiYXNlZCBvbiBlaXRoZXIgaW5kaWNhdGl2ZSBvciBmaXJtIHF1b3RlIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBwcml2YXRlIF9yZXRyaWV2ZVF1b3RlQ29udGV4dChcbiAgICAgICAgcGFyYW1zOiBGZXRjaEluZGljYXRpdmVRdW90ZVBhcmFtcyB8IEZldGNoRmlybVF1b3RlUGFyYW1zLFxuICAgICAgICBpc0Zpcm06IGJvb2xlYW4sXG4gICAgKTogUXVvdGVDb250ZXh0IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgc2VsbEFtb3VudDogdGFrZXJBbW91bnQsXG4gICAgICAgICAgICBidXlBbW91bnQ6IG1ha2VyQW1vdW50LFxuICAgICAgICAgICAgc2VsbFRva2VuOiB0YWtlclRva2VuLFxuICAgICAgICAgICAgYnV5VG9rZW46IG9yaWdpbmFsTWFrZXJUb2tlbixcbiAgICAgICAgICAgIHRha2VyQWRkcmVzcyxcbiAgICAgICAgICAgIHNlbGxUb2tlbkRlY2ltYWxzOiB0YWtlclRva2VuRGVjaW1hbHMsXG4gICAgICAgICAgICBidXlUb2tlbkRlY2ltYWxzOiBtYWtlclRva2VuRGVjaW1hbHMsXG4gICAgICAgICAgICBpbnRlZ3JhdG9yLFxuICAgICAgICAgICAgYWZmaWxpYXRlQWRkcmVzcyxcbiAgICAgICAgfSA9IHBhcmFtcztcblxuICAgICAgICBjb25zdCBpc1Vud3JhcCA9IG9yaWdpbmFsTWFrZXJUb2tlbiA9PT0gdGhpcy5fbmF0aXZlVG9rZW5BZGRyZXNzO1xuICAgICAgICBjb25zdCBpc1NlbGxpbmcgPSB0YWtlckFtb3VudCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IGFzc2V0RmlsbEFtb3VudCA9IGlzU2VsbGluZyA/IHRha2VyQW1vdW50ISA6IG1ha2VyQW1vdW50ITtcblxuICAgICAgICBsZXQgbWFrZXJUb2tlbiA9IG9yaWdpbmFsTWFrZXJUb2tlbjtcblxuICAgICAgICAvLyBJZiB0aGUgb3JpZ2luYWxNYWtlclRva2VuIGlzIHRoZSBuYXRpdmUgdG9rZW4sIHdlIHdpbGwgdHJhZGUgdGhlIHdyYXBwZWQgdmVyc2lvbiBhbmQgdW53cmFwIGF0IHRoZSBlbmRcbiAgICAgICAgaWYgKGlzVW53cmFwKSB7XG4gICAgICAgICAgICBtYWtlclRva2VuID0gdGhpcy5fbmF0aXZlV3JhcHBlZFRva2VuQWRkcmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3b3JrZmxvdzogJ3JmcW0nLFxuICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5fY2hhaW5JZCxcbiAgICAgICAgICAgIGlzRmlybSxcbiAgICAgICAgICAgIHRha2VyQW1vdW50LFxuICAgICAgICAgICAgbWFrZXJBbW91bnQsXG4gICAgICAgICAgICB0YWtlclRva2VuLFxuICAgICAgICAgICAgbWFrZXJUb2tlbixcbiAgICAgICAgICAgIG9yaWdpbmFsTWFrZXJUb2tlbixcbiAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICB0YWtlckFkZHJlc3M6IHRha2VyQWRkcmVzcyEsXG4gICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgdHJhZGVyOiB0YWtlckFkZHJlc3MhLFxuICAgICAgICAgICAgdHhPcmlnaW46IHRoaXMuX3JlZ2lzdHJ5QWRkcmVzcyxcbiAgICAgICAgICAgIHRha2VyVG9rZW5EZWNpbWFscyxcbiAgICAgICAgICAgIG1ha2VyVG9rZW5EZWNpbWFscyxcbiAgICAgICAgICAgIGludGVncmF0b3IsXG4gICAgICAgICAgICBhZmZpbGlhdGVBZGRyZXNzLFxuICAgICAgICAgICAgaXNVbndyYXAsXG4gICAgICAgICAgICBpc1NlbGxpbmcsXG4gICAgICAgICAgICBhc3NldEZpbGxBbW91bnQsXG4gICAgICAgICAgICBmZWVNb2RlbFZlcnNpb246IHRoaXMuX2ZlZU1vZGVsVmVyc2lvbixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gZmV0Y2ggaW5kaWNhdGl2ZSBxdW90ZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfZmV0Y2hJbmRpY2F0aXZlUXVvdGVzQXN5bmMocXVvdGVDb250ZXh0OiBRdW90ZUNvbnRleHQsIGZlZTogRmVlKTogUHJvbWlzZTxJbmRpY2F0aXZlUXVvdGVbXT4ge1xuICAgICAgICAvLyBFeHRyYWN0IHF1b3RlIGNvbnRleHRcbiAgICAgICAgY29uc3QgeyBpc1NlbGxpbmcsIGFzc2V0RmlsbEFtb3VudCwgdGFrZXJUb2tlbiwgbWFrZXJUb2tlbiwgaW50ZWdyYXRvciB9ID0gcXVvdGVDb250ZXh0O1xuXG4gICAgICAgIC8vIENyZWF0ZSBPdGMgT3JkZXIgcmVxdWVzdCBvcHRpb25zXG4gICAgICAgIGNvbnN0IG90Y09yZGVyUGFyYW1zID0gUXVvdGVTZXJ2ZXJDbGllbnQubWFrZVF1ZXJ5UGFyYW1ldGVycyh7XG4gICAgICAgICAgICBjaGFpbklkOiB0aGlzLl9jaGFpbklkLFxuICAgICAgICAgICAgdHhPcmlnaW46IHRoaXMuX3JlZ2lzdHJ5QWRkcmVzcyxcbiAgICAgICAgICAgIHRha2VyQWRkcmVzczogTlVMTF9BRERSRVNTLFxuICAgICAgICAgICAgbWFya2V0T3BlcmF0aW9uOiBpc1NlbGxpbmcgPyBNYXJrZXRPcGVyYXRpb24uU2VsbCA6IE1hcmtldE9wZXJhdGlvbi5CdXksXG4gICAgICAgICAgICBidXlUb2tlbkFkZHJlc3M6IG1ha2VyVG9rZW4sXG4gICAgICAgICAgICBzZWxsVG9rZW5BZGRyZXNzOiB0YWtlclRva2VuLFxuICAgICAgICAgICAgYXNzZXRGaWxsQW1vdW50LFxuICAgICAgICAgICAgaXNMYXN0TG9vazogdHJ1ZSxcbiAgICAgICAgICAgIGZlZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSWYgTExSIENvb2xkb3duIGlzIGVuYWJsZWQsIGZpbHRlciBvdXQgbWFrZXJzIGluIGNvb2xkb3duIGJlZm9yZSBxdWVyeWluZyB0aGUgcXVvdGUgc2VydmVyXG4gICAgICAgIGxldCBtYWtlcklkc0luQ29vbGRvd246IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xuICAgICAgICBpZiAoRU5BQkxFX0xMUl9DT09MRE9XTikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBtYWtlcklkc0luQ29vbGRvd24gPSBhd2FpdCB0aGlzLl9jYWNoZUNsaWVudC5nZXRNYWtlcnNJbkNvb2xkb3duRm9yUGFpckFzeW5jKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICBtYWtlclRva2VuLFxuICAgICAgICAgICAgICAgICAgICB0YWtlclRva2VuLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gbG9nIGJsb2NrZWQgbWFrZXIgaWRzXG4gICAgICAgICAgICAgICAgbWFrZXJJZHNJbkNvb2xkb3duLm1hcCgobWFrZXJJZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBSRlFNX01BS0VSX0JMT0NLRURfRk9SX0xMUl9DT09MRE9XTi5sYWJlbHMoXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhaW5JZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9QYWlyU3RyaW5nKG1ha2VyVG9rZW4sIHRha2VyVG9rZW4pLFxuICAgICAgICAgICAgICAgICAgICApLmluYygpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VyVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFrZXJUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01ha2VyIGlzIG9uIGNvb2xkb3duIGR1ZSB0byBhIGJhZCBsYXN0IGxvb2sgcmVqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHsgY2hhaW5JZDogdGhpcy5fY2hhaW5JZCwgbWFrZXJUb2tlbiwgdGFrZXJUb2tlbiwgZXJyb3JNZXNzYWdlOiBlLm1lc3NhZ2UgfSxcbiAgICAgICAgICAgICAgICAgICAgJ0VuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGZpbHRlcmluZyBtYWtlcnMgb24gTExSIGNvb2xkb3duJyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3RjT3JkZXJNYWtlclVyaXMgPSB0aGlzLl9yZnFNYWtlck1hbmFnZXIuZ2V0UmZxbVYyTWFrZXJVcmlzRm9yUGFpcihcbiAgICAgICAgICAgIG1ha2VyVG9rZW4sXG4gICAgICAgICAgICB0YWtlclRva2VuLFxuICAgICAgICAgICAgaW50ZWdyYXRvci53aGl0ZWxpc3RNYWtlcklkcyB8fCBudWxsLFxuICAgICAgICAgICAgbWFrZXJJZHNJbkNvb2xkb3duIHx8IG51bGwsXG4gICAgICAgICk7XG5cbiAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3RjT3JkZXJQYXJhbXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ290Y09yZGVyUGFyYW1zIGZvciBgYmF0Y2hHZXRQcmljZVYyQXN5bmNgJyxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcXVvdGVzID0gYXdhaXQgdGhpcy5fcXVvdGVTZXJ2ZXJDbGllbnQuYmF0Y2hHZXRQcmljZVYyQXN5bmMoXG4gICAgICAgICAgICBvdGNPcmRlck1ha2VyVXJpcyxcbiAgICAgICAgICAgIGludGVncmF0b3IsXG4gICAgICAgICAgICBvdGNPcmRlclBhcmFtcyxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBMb2cgYW55IHF1b3RlcyB0aGF0IGFyZSBmb3IgdGhlIGluY29ycmVjdCBhbW91bnRcbiAgICAgICAgcXVvdGVzLmZvckVhY2goKHF1b3RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxdW90ZWRBbW91bnQgPSBpc1NlbGxpbmcgPyBxdW90ZS50YWtlckFtb3VudCA6IHF1b3RlLm1ha2VyQW1vdW50O1xuICAgICAgICAgICAgaWYgKHF1b3RlZEFtb3VudC5lcShhc3NldEZpbGxBbW91bnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kaWZpY2F0aW9uVHlwZSA9IHF1b3RlZEFtb3VudC5ndChhc3NldEZpbGxBbW91bnQpID8gJ292ZXJmaWxsJyA6ICd1bmRlcmZpbGwnO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpc1NlbGxpbmcsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJPclVuZGVyOiBtb2RpZmljYXRpb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRBbW91bnQ6IGFzc2V0RmlsbEFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgcXVvdGVkQW1vdW50LFxuICAgICAgICAgICAgICAgICAgICBxdW90ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdNYWtlciByZXR1cm5lZCBhbiBpbmNvcnJlY3QgYW1vdW50JyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBSRlFNX01NX1JFVFVSTkVEX0RJRkZFUkVOVF9BTU9VTlQubGFiZWxzKHF1b3RlLm1ha2VyVXJpLCB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCksIG1vZGlmaWNhdGlvblR5cGUpLmluYygpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcXVvdGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byBmZXRjaCBmaXJtIHF1b3Rlcy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIF9mZXRjaEZpcm1RdW90ZXNBc3luYyhxdW90ZUNvbnRleHQ6IFF1b3RlQ29udGV4dCwgZmVlOiBGZWUpOiBQcm9taXNlPEZpcm1PdGNRdW90ZVtdPiB7XG4gICAgICAgIGNvbnN0IHF1b3RlcyA9IGF3YWl0IHRoaXMuX2ZldGNoSW5kaWNhdGl2ZVF1b3Rlc0FzeW5jKHF1b3RlQ29udGV4dCwgZmVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRUb0Zpcm1RdW90ZXNBc3luYyhxdW90ZXMsIHF1b3RlQ29udGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgaW5kaWNhdGl2ZSBxdW90ZXMgdG8gZmlybSBxdW90ZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfY29udmVydFRvRmlybVF1b3Rlc0FzeW5jKFxuICAgICAgICBxdW90ZXM6IEluZGljYXRpdmVRdW90ZVtdLFxuICAgICAgICBxdW90ZUNvbnRleHQ6IFF1b3RlQ29udGV4dCxcbiAgICApOiBQcm9taXNlPEZpcm1PdGNRdW90ZVtdPiB7XG4gICAgICAgIGNvbnN0IHsgdGFrZXJBZGRyZXNzIH0gPSBxdW90ZUNvbnRleHQ7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCdWNrZXQgPVxuICAgICAgICAgICAgKGF3YWl0IHRoaXMuX2NhY2hlQ2xpZW50LmdldE5leHRPdGNPcmRlckJ1Y2tldEFzeW5jKHRoaXMuX2NoYWluSWQpKSAlIEdBU0xFU1NfT1RDX09SREVSX05VTV9CVUNLRVRTO1xuICAgICAgICBjb25zdCBub3dTZWNvbmRzID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gT05FX1NFQ09ORF9NUyk7XG4gICAgICAgIGNvbnN0IG90Y1F1b3RlcyA9IHF1b3Rlcy5tYXAoKHEpID0+XG4gICAgICAgICAgICB0aGlzLl9tYXBJbmRpY2F0aXZlUXVvdGVUb0Zpcm1PdGNRdW90ZShcbiAgICAgICAgICAgICAgICBxLFxuICAgICAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIHRha2VyQWRkcmVzcyEsXG4gICAgICAgICAgICAgICAgbmV3IEJpZ051bWJlcihjdXJyZW50QnVja2V0KSxcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKG5vd1NlY29uZHMpLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBmaXJtUXVvdGVzV2l0aENvcnJlY3RDaGFpbklkID0gb3RjUXVvdGVzLmZpbHRlcigocXVvdGUpID0+IHtcbiAgICAgICAgICAgIGlmIChxdW90ZS5vcmRlci5jaGFpbklkICE9PSB0aGlzLl9jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKHsgcXVvdGUgfSwgJ1JlY2VpdmVkIGEgcXVvdGUgd2l0aCBpbmNvcnJlY3QgY2hhaW4gaWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZpcm1RdW90ZXNXaXRoQ29ycmVjdENoYWluSWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfZW5xdWV1ZUpvYkFzeW5jKG9yZGVySGFzaDogc3RyaW5nLCB0eXBlOiBHYXNsZXNzVHlwZXMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3FzUHJvZHVjZXIuc2VuZCh7XG4gICAgICAgICAgICAvLyB3YWl0LCBpdCdzIGFsbCBvcmRlciBoYXNoP1xuICAgICAgICAgICAgLy8gYWx3YXlzIGhhcyBiZWVuLlxuICAgICAgICAgICAgZ3JvdXBJZDogb3JkZXJIYXNoLFxuICAgICAgICAgICAgaWQ6IG9yZGVySGFzaCxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgb3JkZXJIYXNoLCB0eXBlIH0pLFxuICAgICAgICAgICAgZGVkdXBsaWNhdGlvbklkOiBvcmRlckhhc2gsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcHMgYW4gSW5kaWNhdGl2ZVF1b3RlIHRvIGEgRmlybU90Y1F1b3RlLiBIYW5kbGVzIHR4T3JpZ2luLCBjaGFpbklkLCBleHBpcnlBbmROb25jZSwgZXRjXG4gICAgICovXG4gICAgcHJpdmF0ZSBfbWFwSW5kaWNhdGl2ZVF1b3RlVG9GaXJtT3RjUXVvdGUoXG4gICAgICAgIHE6IEluZGljYXRpdmVRdW90ZSxcbiAgICAgICAgdGFrZXJBZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgIG5vbmNlQnVja2V0OiBCaWdOdW1iZXIsXG4gICAgICAgIG5vbmNlOiBCaWdOdW1iZXIsXG4gICAgKTogRmlybU90Y1F1b3RlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6ICdvdGMnLFxuICAgICAgICAgICAgbWFrZXJVcmk6IHEubWFrZXJVcmksXG4gICAgICAgICAgICBvcmRlcjogbmV3IE90Y09yZGVyKHtcbiAgICAgICAgICAgICAgICB0eE9yaWdpbjogdGhpcy5fcmVnaXN0cnlBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGV4cGlyeUFuZE5vbmNlOiBPdGNPcmRlci5lbmNvZGVFeHBpcnlBbmROb25jZShxLmV4cGlyeSwgbm9uY2VCdWNrZXQsIG5vbmNlKSxcbiAgICAgICAgICAgICAgICBtYWtlcjogcS5tYWtlcixcbiAgICAgICAgICAgICAgICB0YWtlcjogdGFrZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgIG1ha2VyVG9rZW46IHEubWFrZXJUb2tlbixcbiAgICAgICAgICAgICAgICB0YWtlclRva2VuOiBxLnRha2VyVG9rZW4sXG4gICAgICAgICAgICAgICAgbWFrZXJBbW91bnQ6IHEubWFrZXJBbW91bnQsXG4gICAgICAgICAgICAgICAgdGFrZXJBbW91bnQ6IHEudGFrZXJBbW91bnQsXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5fY2hhaW5JZCxcbiAgICAgICAgICAgICAgICB2ZXJpZnlpbmdDb250cmFjdDogdGhpcy5fY29udHJhY3RBZGRyZXNzZXMuZXhjaGFuZ2VQcm94eSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBhbmQgY29udmVydHMgRUlQLTcxMiBjb250ZXh0IHRvIGFuIEFwcHJvdmFsIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ga2luZCBUeXBlIG9mIGdhc2xlc3MgYXBwcm92YWxcbiAgICAgKiBAcGFyYW0gZWlwNzEyIEVJUC03MTIgY29udGV4dCBwYXJzZWQgZnJvbSB0aGUgaGFuZGxlclxuICAgICAqIEBwYXJhbSB0cmFkZUhhc2ggVGhlIG9yZGVyIGhhc2ggb3IgbWV0YXRyYW5zYWN0aW9uIGhhc2gsXG4gICAgICogIG9ubHkgdXNlZCBmb3IgbG9nZ2luZyBpbiBjYXNlIG9mIHZhbGlkYXRpb24gZXJyb3JcbiAgICAgKiBAcmV0dXJucyBUaGUgQXBwcm92YWwgb2JqZWN0XG4gICAgICovXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBwcmVmZXItZnVuY3Rpb24tb3Zlci1tZXRob2RcbiAgICBwcml2YXRlIF9jb252ZXJ0RUlQNzEyQ29udGV4dFRvQXBwcm92YWw8VCBleHRlbmRzIEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0IHwgUGVybWl0RWlwNzEyQ29udGV4dD4oXG4gICAgICAgIGVpcDcxMjogVCxcbiAgICAgICAgdHJhZGVIYXNoOiBzdHJpbmcsXG4gICAgKTogVCBleHRlbmRzIEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0ID8gRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkFwcHJvdmFsIDogUGVybWl0QXBwcm92YWwge1xuICAgICAgICBjb25zdCB7IHR5cGVzLCBwcmltYXJ5VHlwZSwgZG9tYWluLCBtZXNzYWdlIH0gPSBlaXA3MTI7XG4gICAgICAgIHN3aXRjaCAocHJpbWFyeVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ01ldGFUcmFuc2FjdGlvbic6IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFfLmlzRXF1YWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmtleXMobWVzc2FnZSkuc29ydCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMuTWV0YVRyYW5zYWN0aW9uLm1hcCgoZGF0YUZpZWxkOiBFaXA3MTJEYXRhRmllbGQpID0+IGRhdGFGaWVsZC5uYW1lKS5zb3J0KCksXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oeyBwcmltYXJ5VHlwZSwgdHJhZGVIYXNoIH0sICdJbnZhbGlkIG1lc3NhZ2UgZmllbGQgcHJvdmlkZWQgZm9yIEFwcHJvdmFsJyk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogVmFsaWRhdGlvbkVycm9yQ29kZXMuRmllbGRJbnZhbGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogYEludmFsaWQgbWVzc2FnZSBmaWVsZCBwcm92aWRlZCBmb3IgQXBwcm92YWwgb2YgcHJpbWFyeVR5cGUgJHtwcmltYXJ5VHlwZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25BcHByb3ZhbDogRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkFwcHJvdmFsID0ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHYXNsZXNzQXBwcm92YWxUeXBlcy5FeGVjdXRlTWV0YVRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBlaXA3MTI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uY2U6IG1lc3NhZ2Uubm9uY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogbWVzc2FnZS5mcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uU2lnbmF0dXJlOiBtZXNzYWdlLmZ1bmN0aW9uU2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBleGVjdXRlTWV0YVRyYW5zYWN0aW9uQXBwcm92YWwgYXMgVCBleHRlbmRzIEV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25FaXA3MTJDb250ZXh0XG4gICAgICAgICAgICAgICAgICAgID8gRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkFwcHJvdmFsXG4gICAgICAgICAgICAgICAgICAgIDogUGVybWl0QXBwcm92YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdQZXJtaXQnOiB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhXy5pc0VxdWFsKFxuICAgICAgICAgICAgICAgICAgICAgICAgXy5rZXlzKG1lc3NhZ2UpLnNvcnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzLlBlcm1pdC5tYXAoKGRhdGFGaWVsZDogRWlwNzEyRGF0YUZpZWxkKSA9PiBkYXRhRmllbGQubmFtZSkuc29ydCgpLFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKHsgcHJpbWFyeVR5cGUsIHRyYWRlSGFzaCB9LCAnSW52YWxpZCBtZXNzYWdlIGZpZWxkIHByb3ZpZGVkIGZvciBBcHByb3ZhbCcpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFZhbGlkYXRpb25FcnJvckNvZGVzLkZpZWxkSW52YWxpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IGBJbnZhbGlkIG1lc3NhZ2UgZmllbGQgcHJvdmlkZWQgZm9yIEFwcHJvdmFsIG9mIHByaW1hcnlUeXBlICR7cHJpbWFyeVR5cGV9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwZXJtaXRBcHByb3ZhbDogUGVybWl0QXBwcm92YWwgPSB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdhc2xlc3NBcHByb3ZhbFR5cGVzLlBlcm1pdCxcbiAgICAgICAgICAgICAgICAgICAgZWlwNzEyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiBtZXNzYWdlLm93bmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZW5kZXI6IG1lc3NhZ2Uuc3BlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWVzc2FnZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25jZTogbWVzc2FnZS5ub25jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWFkbGluZTogbWVzc2FnZS5kZWFkbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBwZXJtaXRBcHByb3ZhbCBhcyBUIGV4dGVuZHMgRXhlY3V0ZU1ldGFUcmFuc2FjdGlvbkVpcDcxMkNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgPyBFeGVjdXRlTWV0YVRyYW5zYWN0aW9uQXBwcm92YWxcbiAgICAgICAgICAgICAgICAgICAgOiBQZXJtaXRBcHByb3ZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgKChfeDogbmV2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xuICAgICAgICAgICAgICAgIH0pKHByaW1hcnlUeXBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==