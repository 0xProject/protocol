fb93190e20a6c4be48fc3f03b9139ffd
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable custom-no-magic-numbers
// tslint:disable await-promise
// tslint:disable max-file-line-count
const asset_swapper_1 = require("@0x/asset-swapper");
const contract_addresses_1 = require("@0x/contract-addresses");
const contracts_erc20_1 = require("@0x/contracts-erc20");
const contracts_zero_ex_1 = require("@0x/contracts-zero-ex");
const protocol_utils_1 = require("@0x/protocol-utils");
const utils_1 = require("@0x/utils");
const web3_wrapper_1 = require("@0x/web3-wrapper");
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const constants_1 = require("../src/core/constants");
const balance_checker_1 = require("../src/utils/balance_checker");
const rfq_blockchain_utils_1 = require("../src/utils/rfq_blockchain_utils");
const constants_2 = require("./constants");
const deployment_1 = require("./test_utils/deployment");
const GAS_PRICE = 1e9;
const VALID_EXPIRY = new utils_1.BigNumber(9000000000);
const CHAIN_ID = contract_addresses_1.ChainId.Ganache;
jest.setTimeout(constants_1.ONE_MINUTE_MS * 2);
let teardownDependencies;
describe('RFQ Blockchain Utils', () => {
    let provider;
    let makerToken;
    let takerToken;
    let makerAmount;
    let takerAmount;
    let invalidTakerAmount;
    let makerBalance;
    let takerBalance;
    let web3Wrapper;
    let owner;
    let maker;
    let taker;
    let signer;
    let txOrigin;
    let zeroEx;
    let rfqOrder;
    let otcOrder;
    let unfillableRfqOrder;
    let rfqBlockchainUtils;
    let orderSig;
    let sigForUnfillableOrder;
    let makerOtcOrderSig;
    let takerOtcOrderSig;
    beforeAll(async () => {
        teardownDependencies = await (0, deployment_1.setupDependenciesAsync)(['ganache']);
        provider = (0, constants_2.getProvider)();
        web3Wrapper = new web3_wrapper_1.Web3Wrapper(provider);
        [owner, maker, taker, txOrigin, signer] = await web3Wrapper.getAvailableAddressesAsync();
        // Deploy dummy tokens
        makerToken = await contracts_erc20_1.DummyERC20TokenContract.deployFrom0xArtifactAsync(contracts_erc20_1.artifacts.DummyERC20Token, provider, { from: maker, gas: 10000000 }, {}, 'The token that originally belongs to the maker', 'makerToken', new utils_1.BigNumber(18), new utils_1.BigNumber(0));
        takerToken = await contracts_erc20_1.DummyERC20TokenContract.deployFrom0xArtifactAsync(contracts_erc20_1.artifacts.DummyERC20Token, provider, { from: taker, gas: 10000000 }, {}, 'The token that originally belongs to the maker', 'takerToken', new utils_1.BigNumber(18), new utils_1.BigNumber(0));
        // Deploy Balance Checker (only necessary for Ganache because ganache doesn't have overrides)
        const balanceCheckerContract = await asset_swapper_1.BalanceCheckerContract.deployFrom0xArtifactAsync(asset_swapper_1.artifacts.BalanceChecker, provider, { from: owner, gas: 10000000 }, {});
        const balanceChecker = new balance_checker_1.BalanceChecker(provider, balanceCheckerContract);
        makerAmount = new utils_1.BigNumber(100);
        takerAmount = new utils_1.BigNumber(50);
        invalidTakerAmount = new utils_1.BigNumber(10000000);
        // Deploy ZeroEx to Ganache
        zeroEx = await (0, contracts_zero_ex_1.fullMigrateAsync)(owner, provider, { from: owner, gasPrice: GAS_PRICE }, {}, { protocolFeeMultiplier: Number(0) }, {
            nativeOrders: contracts_zero_ex_1.artifacts.NativeOrdersFeature,
            metaTransactions: contracts_zero_ex_1.artifacts.MetaTransactionsFeature,
        });
        // Prepare an RfqOrder
        rfqOrder = new protocol_utils_1.RfqOrder({
            makerToken: makerToken.address,
            takerToken: takerToken.address,
            makerAmount,
            takerAmount,
            maker,
            taker,
            txOrigin,
            expiry: VALID_EXPIRY,
            salt: new utils_1.BigNumber(1),
            verifyingContract: zeroEx.address,
            chainId: CHAIN_ID,
        });
        orderSig = await rfqOrder.getSignatureWithProviderAsync(provider);
        // Prepare an Unfillable RfqOrder
        unfillableRfqOrder = new protocol_utils_1.RfqOrder({
            makerToken: makerToken.address,
            takerToken: takerToken.address,
            makerAmount,
            takerAmount: invalidTakerAmount,
            maker,
            taker,
            txOrigin,
            expiry: VALID_EXPIRY,
            salt: new utils_1.BigNumber(1),
            verifyingContract: zeroEx.address,
            chainId: CHAIN_ID,
        });
        sigForUnfillableOrder = await unfillableRfqOrder.getSignatureWithProviderAsync(provider);
        // Prepare an OtcOrder and valid signatures
        otcOrder = new protocol_utils_1.OtcOrder({
            maker,
            taker,
            makerAmount,
            takerAmount,
            makerToken: makerToken.address,
            takerToken: takerToken.address,
            txOrigin,
            expiryAndNonce: protocol_utils_1.OtcOrder.encodeExpiryAndNonce(new utils_1.BigNumber(VALID_EXPIRY), constants_1.ZERO, new utils_1.BigNumber(VALID_EXPIRY)),
            chainId: CHAIN_ID,
            verifyingContract: zeroEx.address,
        });
        const orderHash = otcOrder.getHash();
        makerOtcOrderSig = await (0, protocol_utils_1.ethSignHashWithProviderAsync)(orderHash, maker, provider);
        takerOtcOrderSig = await (0, protocol_utils_1.ethSignHashWithProviderAsync)(orderHash, taker, provider);
        // Mint enough tokens for a few trades
        const numTrades = 2;
        makerBalance = makerAmount.times(numTrades);
        takerBalance = takerAmount.times(numTrades);
        await makerToken.mint(makerBalance).awaitTransactionSuccessAsync({ from: maker });
        await makerToken.approve(zeroEx.address, makerBalance.times(2)).awaitTransactionSuccessAsync({ from: maker });
        await takerToken.mint(takerBalance).awaitTransactionSuccessAsync({ from: taker });
        await takerToken.approve(zeroEx.address, takerBalance.times(2)).awaitTransactionSuccessAsync({ from: taker });
        const ethersProvider = new ethers_1.providers.JsonRpcProvider();
        const ethersWallet = new ethers_1.Wallet(constants_2.WORKER_TEST_PRIVATE_KEY, ethersProvider);
        rfqBlockchainUtils = new rfq_blockchain_utils_1.RfqBlockchainUtils(provider, zeroEx.address, balanceChecker, ethersProvider, ethersWallet);
    });
    afterAll(async () => {
        if (!teardownDependencies()) {
            throw new Error('Failed to tear down dependencies');
        }
    });
    describe('getMinOfBalancesAndAllowancesAsync', () => {
        it('should fetch min of token balances and allowances', async () => {
            const addresses = [
                { owner: maker, token: makerToken.address },
                { owner: maker, token: takerToken.address },
                { owner: taker, token: makerToken.address },
                { owner: taker, token: takerToken.address },
            ];
            const res = await rfqBlockchainUtils.getMinOfBalancesAndAllowancesAsync(addresses);
            (0, chai_1.expect)(res).to.deep.eq([makerBalance, constants_1.ZERO, constants_1.ZERO, takerBalance]);
        });
    });
    describe('getTokenBalancesAsync', () => {
        it('should fetch token balances', async () => {
            const addresses = [
                { owner: maker, token: makerToken.address },
                { owner: maker, token: takerToken.address },
                { owner: taker, token: makerToken.address },
                { owner: taker, token: takerToken.address },
            ];
            const res = await rfqBlockchainUtils.getTokenBalancesAsync(addresses);
            (0, chai_1.expect)(res).to.deep.eq([makerBalance, constants_1.ZERO, constants_1.ZERO, takerBalance]);
        });
    });
    describe('OtcOrder', () => {
        describe('estimateGasForFillTakerSignedOtcOrderAsync', () => {
            it('does not throw an error on valid order', async () => {
                try {
                    const gasEstimate = await rfqBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(otcOrder, makerOtcOrderSig, takerOtcOrderSig, txOrigin, false);
                    (0, chai_1.expect)(gasEstimate).to.be.greaterThan(0);
                }
                catch (err) {
                    chai_1.expect.fail('should not throw');
                }
            });
            it('throws an error if order is invalid', async () => {
                const invalidOtcOrder = new protocol_utils_1.OtcOrder({
                    maker,
                    taker,
                    makerAmount,
                    takerAmount,
                    makerToken: makerToken.address,
                    takerToken: takerToken.address,
                    txOrigin,
                    expiryAndNonce: protocol_utils_1.OtcOrder.encodeExpiryAndNonce(constants_1.ZERO, // expired
                    constants_1.ZERO, VALID_EXPIRY),
                    chainId: CHAIN_ID,
                    verifyingContract: zeroEx.address,
                });
                const orderHash = invalidOtcOrder.getHash();
                const makerSig = await (0, protocol_utils_1.ethSignHashWithProviderAsync)(orderHash, maker, provider);
                const takerSig = await (0, protocol_utils_1.ethSignHashWithProviderAsync)(orderHash, taker, provider);
                (0, chai_1.expect)(rfqBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(invalidOtcOrder, // invalid order, should be expired
                makerSig, takerSig, txOrigin, false)).to.eventually.be.rejectedWith(/revert/);
            });
            it('throws an error if signatures invalid', async () => {
                (0, chai_1.expect)(rfqBlockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(otcOrder, makerOtcOrderSig, makerOtcOrderSig, // wrong signature
                txOrigin, false)).to.eventually.be.rejectedWith('revert');
            });
        });
    });
    describe('validateMetaTransaction', () => {
        it('returns successful filled amounts for a valid metatransaction', async () => {
            const metaTx = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount, CHAIN_ID);
            const metaTxSig = await metaTx.getSignatureWithProviderAsync(provider);
            const res = await rfqBlockchainUtils.validateMetaTransactionOrThrowAsync(metaTx, metaTxSig, txOrigin);
            (0, chai_1.expect)(res[0]).to.deep.equal(takerAmount);
            (0, chai_1.expect)(res[1]).to.deep.equal(makerAmount);
        });
        it('throws for a metatransaction with an invalid signature', async () => {
            const metaTx = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount, CHAIN_ID);
            const invalidMetaTxSig = orderSig;
            (0, chai_1.expect)(rfqBlockchainUtils.validateMetaTransactionOrThrowAsync(metaTx, invalidMetaTxSig, txOrigin)).to.eventually.be.rejectedWith('SignatureValidationError');
        });
        it('throws for a metatransaction with an unfillable order', async () => {
            const metaTx = rfqBlockchainUtils.generateMetaTransaction(unfillableRfqOrder, sigForUnfillableOrder, taker, invalidTakerAmount, CHAIN_ID);
            const metaTxSig = await metaTx.getSignatureWithProviderAsync(provider);
            (0, chai_1.expect)(rfqBlockchainUtils.validateMetaTransactionOrThrowAsync(metaTx, metaTxSig, txOrigin)).to.eventually.be.rejectedWith('MetaTransactionCallFailedError');
        });
        it('returns successful filled amounts for a valid metatransaction when validating calldata', async () => {
            const metaTx = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount, CHAIN_ID);
            const metaTxSig = await metaTx.getSignatureWithProviderAsync(provider);
            const callData = rfqBlockchainUtils.generateMetaTransactionCallData(metaTx, metaTxSig, constants_2.MATCHA_AFFILIATE_ADDRESS);
            const res = await rfqBlockchainUtils.decodeMetaTransactionCallDataAndValidateAsync(callData, txOrigin);
            (0, chai_1.expect)(res[0]).to.deep.equal(takerAmount);
            (0, chai_1.expect)(res[1]).to.deep.equal(makerAmount);
        });
        it('throws for a metatransaction with an invalid signature when validating calldata', async () => {
            const metaTx = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount, CHAIN_ID);
            const invalidMetaTxSig = orderSig;
            const callData = rfqBlockchainUtils.generateMetaTransactionCallData(metaTx, invalidMetaTxSig, constants_2.MATCHA_AFFILIATE_ADDRESS);
            (0, chai_1.expect)(rfqBlockchainUtils.decodeMetaTransactionCallDataAndValidateAsync(callData, txOrigin)).to.eventually.be.rejectedWith('SignatureValidationError');
        });
        it('throws for a metatransaction with an unfillable order when validating calldata', async () => {
            const metaTx = rfqBlockchainUtils.generateMetaTransaction(unfillableRfqOrder, sigForUnfillableOrder, taker, invalidTakerAmount, CHAIN_ID);
            const metaTxSig = await metaTx.getSignatureWithProviderAsync(provider);
            const callData = rfqBlockchainUtils.generateMetaTransactionCallData(metaTx, metaTxSig, constants_2.MATCHA_AFFILIATE_ADDRESS);
            (0, chai_1.expect)(rfqBlockchainUtils.decodeMetaTransactionCallDataAndValidateAsync(callData, txOrigin)).to.eventually.be.rejectedWith('MetaTransactionCallFailedError');
        });
        it('should throw for a partially filled order', async () => {
            const metaTx1 = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount.div(2), CHAIN_ID);
            const metaTxSig1 = await metaTx1.getSignatureWithProviderAsync(provider);
            await zeroEx.executeMetaTransaction(metaTx1, metaTxSig1).awaitTransactionSuccessAsync({ from: txOrigin });
            const metaTx2 = rfqBlockchainUtils.generateMetaTransaction(rfqOrder, orderSig, taker, takerAmount, CHAIN_ID);
            const metaTxSig2 = await metaTx2.getSignatureWithProviderAsync(provider);
            (0, chai_1.expect)(rfqBlockchainUtils.validateMetaTransactionOrThrowAsync(metaTx2, metaTxSig2, txOrigin)).to.eventually.be.rejectedWith('filled amount is less than requested fill amount');
        });
    });
    describe('transformTxDataToTransactionRequest', () => {
        it('creates a TransactionRequest', () => {
            const txOptions = {
                from: '0xfromaddress',
                gas: new utils_1.BigNumber(210000000),
                maxFeePerGas: new utils_1.BigNumber(200000),
                maxPriorityFeePerGas: new utils_1.BigNumber(100000),
                nonce: 21,
                to: '0xtoaddress',
                value: 0,
            };
            const result = rfqBlockchainUtils.transformTxDataToTransactionRequest(txOptions, 
            /* chainId = */ 1337, 
            /* callData */ '0x01234');
            (0, chai_1.expect)(result.from).to.equal('0xfromaddress');
            (0, chai_1.expect)(result.gasLimit).to.equal(BigInt(210000000));
            (0, chai_1.expect)(result.maxFeePerGas).to.equal(BigInt(200000));
            (0, chai_1.expect)(result.maxPriorityFeePerGas).to.equal(BigInt(100000));
            (0, chai_1.expect)(result.nonce).to.equal(21);
            (0, chai_1.expect)(result.to).to.equal('0xtoaddress');
            (0, chai_1.expect)(result.value).to.equal(0);
        });
        it("uses the proxy address if no 'to' address is provided", () => {
            const txOptions = { from: '0xfromaddress' };
            const result = rfqBlockchainUtils.transformTxDataToTransactionRequest(txOptions);
            (0, chai_1.expect)(result.to).to.equal(zeroEx.address);
        });
    });
    describe('getDecodedRfqOrderFillEventLogFromLogs', () => {
        it('correctly parses an RfqOrderFillEvent from logs', async () => {
            const rfqOrderFilledEvent = rfqBlockchainUtils.getDecodedRfqOrderFillEventLogFromLogs([
                constants_2.TEST_RFQ_ORDER_FILLED_EVENT_LOG,
            ]);
            (0, chai_1.expect)(rfqOrderFilledEvent.args.takerTokenFilledAmount).to.deep.eq(constants_2.TEST_RFQ_ORDER_FILLED_EVENT_TAKER_AMOUNT);
            (0, chai_1.expect)(rfqOrderFilledEvent.blockNumber).to.deep.eq(constants_2.TEST_RFQ_ORDER_FILLED_EVENT_LOG.blockNumber);
        });
    });
    describe('getTokenDecimalsAsync', () => {
        it('gets the token decimals', async () => {
            const decimals = await rfqBlockchainUtils.getTokenDecimalsAsync(makerToken.address);
            (0, chai_1.expect)(decimals).to.equal(18);
        });
        it('throws if the contract does not exist', () => {
            // tslint:disable-next-line: no-unused-expression no-unbound-method
            (0, chai_1.expect)(rfqBlockchainUtils.getTokenDecimalsAsync('0x29D7d1dd5B6f9C864d9db560D72a247c178aE86B')).to.be
                .rejected;
        });
    });
    describe('isValidOrderSigner', () => {
        it('returns false if signer is not valid', async () => {
            const isValidOrderSigner = await rfqBlockchainUtils.isValidOrderSignerAsync(maker, signer);
            (0, chai_1.expect)(isValidOrderSigner).to.equal(false);
        });
        it('returns true when valid signer address is passed', async () => {
            await rfqBlockchainUtils.registerAllowedOrderSignerAsync(maker, signer, true);
            const isValidOrderSigner = await rfqBlockchainUtils.isValidOrderSignerAsync(maker, signer);
            (0, chai_1.expect)(isValidOrderSigner).to.equal(true);
        });
    });
    describe('generateApprovalCalldataAsync', () => {
        it('generates executeMetaTransaction calldata', async () => {
            const token = makerToken.address;
            const approval = constants_2.MOCK_EXECUTE_META_TRANSACTION_APPROVAL;
            const signature = {
                r: '0x0000000000000000000000000000000000000000000000000000000000000000',
                s: '0x0000000000000000000000000000000000000000000000000000000000000000',
                v: 28,
                signatureType: 2,
            };
            const calldata = await rfqBlockchainUtils.generateApprovalCalldataAsync(token, approval, signature);
            (0, chai_1.expect)(calldata).to.eq(constants_2.MOCK_EXECUTE_META_TRANSACTION_CALLDATA);
        });
        it('generates permit calldata', async () => {
            const token = makerToken.address;
            const approval = constants_2.MOCK_PERMIT_APPROVAL;
            const signature = {
                r: '0x0000000000000000000000000000000000000000000000000000000000000000',
                s: '0x0000000000000000000000000000000000000000000000000000000000000000',
                v: 28,
                signatureType: 2,
            };
            const calldata = await rfqBlockchainUtils.generateApprovalCalldataAsync(token, approval, signature);
            (0, chai_1.expect)(calldata).to.eq(constants_2.MOCK_PERMIT_CALLDATA);
        });
    });
    describe('estimateGasForAsync', () => {
        it('throws exception on invalid calldata', async () => {
            const erc20AbiDecimals = `[{
                "constant": true,
                "inputs": [],
                "name": "decimals",
                "outputs": [
                    {
                        "name": "",
                        "type": "uint8"
                    }
                ],
                "payable": false,
                "stateMutability": "view",
                "type": "function"
            }]`;
            const erc20 = new ethers_1.Contract(takerToken.address, erc20AbiDecimals);
            const { data: calldata } = await erc20.populateTransaction.decimals();
            if (!calldata) {
                throw new Error('calldata for decimals should not be undefined or empty');
            }
            const invalidCalldata = `${calldata.substring(0, calldata.length - 1)}0`;
            try {
                await rfqBlockchainUtils.estimateGasForAsync({ to: takerToken.address, data: invalidCalldata });
                chai_1.expect.fail();
            }
            catch (e) {
                (0, chai_1.expect)(e.message).to.contain('estimateGasForAsync');
            }
        });
        it('successfully estimates gas', async () => {
            const erc20AbiDecimals = `[{
                "constant": true,
                "inputs": [],
                "name": "decimals",
                "outputs": [
                    {
                        "name": "",
                        "type": "uint8"
                    }
                ],
                "payable": false,
                "stateMutability": "view",
                "type": "function"
            }]`;
            const erc20 = new ethers_1.Contract(takerToken.address, erc20AbiDecimals);
            const { data: calldata } = await erc20.populateTransaction.decimals();
            if (!calldata) {
                throw new Error('calldata for decimals should not be undefined or empty');
            }
            await rfqBlockchainUtils.estimateGasForAsync({ to: takerToken.address, data: calldata });
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3Rlc3QvcmZxX2Jsb2NrY2hhaW5fdXRpbHNfdGVzdC50cyIsIm1hcHBpbmdzIjoiOztBQUFBLHlDQUF5QztBQUN6QywrQkFBK0I7QUFDL0IscUNBQXFDO0FBQ3JDLHFEQUErRjtBQUMvRiwrREFBaUQ7QUFDakQseURBQTJGO0FBQzNGLDZEQUF3RztBQUV4Ryx1REFBaUc7QUFDakcscUNBQXNDO0FBQ3RDLG1EQUF1RDtBQUN2RCwrQkFBOEI7QUFDOUIsbUNBQXFEO0FBRXJELHFEQUE0RDtBQUM1RCxrRUFBOEQ7QUFDOUQsNEVBQXVFO0FBRXZFLDJDQVVxQjtBQUNyQix3REFBcUc7QUFFckcsTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDO0FBQ3RCLE1BQU0sWUFBWSxHQUFHLElBQUksaUJBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUMvQyxNQUFNLFFBQVEsR0FBRyw0QkFBTyxDQUFDLE9BQU8sQ0FBQztBQUVqQyxJQUFJLENBQUMsVUFBVSxDQUFDLHlCQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDbkMsSUFBSSxvQkFBd0QsQ0FBQztBQUU3RCxRQUFRLENBQUMsc0JBQXNCLEVBQUUsR0FBRyxFQUFFO0lBQ2xDLElBQUksUUFBNEIsQ0FBQztJQUNqQyxJQUFJLFVBQW1DLENBQUM7SUFDeEMsSUFBSSxVQUFtQyxDQUFDO0lBQ3hDLElBQUksV0FBc0IsQ0FBQztJQUMzQixJQUFJLFdBQXNCLENBQUM7SUFDM0IsSUFBSSxrQkFBNkIsQ0FBQztJQUNsQyxJQUFJLFlBQXVCLENBQUM7SUFDNUIsSUFBSSxZQUF1QixDQUFDO0lBQzVCLElBQUksV0FBd0IsQ0FBQztJQUM3QixJQUFJLEtBQWEsQ0FBQztJQUNsQixJQUFJLEtBQWEsQ0FBQztJQUNsQixJQUFJLEtBQWEsQ0FBQztJQUNsQixJQUFJLE1BQWMsQ0FBQztJQUNuQixJQUFJLFFBQWdCLENBQUM7SUFDckIsSUFBSSxNQUF1QixDQUFDO0lBQzVCLElBQUksUUFBa0Is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QztZQUN0RSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNYLE1BQU0sSUFBSSxLQUFLLENBQUMsd0RBQXdELENBQUMsQ0FBQzthQUM3RTtZQUVELE1BQU0sa0JBQWtCLENBQUMsbUJBQW1CLENBQUMsRUFBRSxFQUFFLEVBQUUsVUFBVSxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUM3RixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3Rlc3QvcmZxX2Jsb2NrY2hhaW5fdXRpbHNfdGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZSBjdXN0b20tbm8tbWFnaWMtbnVtYmVyc1xuLy8gdHNsaW50OmRpc2FibGUgYXdhaXQtcHJvbWlzZVxuLy8gdHNsaW50OmRpc2FibGUgbWF4LWZpbGUtbGluZS1jb3VudFxuaW1wb3J0IHsgYXJ0aWZhY3RzIGFzIGFzc2V0U3dhcHBlckFydGlmYWN0cywgQmFsYW5jZUNoZWNrZXJDb250cmFjdCB9IGZyb20gJ0AweC9hc3NldC1zd2FwcGVyJztcbmltcG9ydCB7IENoYWluSWQgfSBmcm9tICdAMHgvY29udHJhY3QtYWRkcmVzc2VzJztcbmltcG9ydCB7IGFydGlmYWN0cyBhcyBlcmMyMEFydGlmYWN0cywgRHVtbXlFUkMyMFRva2VuQ29udHJhY3QgfSBmcm9tICdAMHgvY29udHJhY3RzLWVyYzIwJztcbmltcG9ydCB7IGFydGlmYWN0cyBhcyB6ZXJvRXhBcnRpZmFjdHMsIGZ1bGxNaWdyYXRlQXN5bmMsIElaZXJvRXhDb250cmFjdCB9IGZyb20gJ0AweC9jb250cmFjdHMtemVyby1leCc7XG5pbXBvcnQgeyBXZWIzUHJvdmlkZXJFbmdpbmUgfSBmcm9tICdAMHgvZGV2LXV0aWxzJztcbmltcG9ydCB7IGV0aFNpZ25IYXNoV2l0aFByb3ZpZGVyQXN5bmMsIE90Y09yZGVyLCBSZnFPcmRlciwgU2lnbmF0dXJlIH0gZnJvbSAnQDB4L3Byb3RvY29sLXV0aWxzJztcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ0AweC91dGlscyc7XG5pbXBvcnQgeyBUeERhdGEsIFdlYjNXcmFwcGVyIH0gZnJvbSAnQDB4L3dlYjMtd3JhcHBlcic7XG5pbXBvcnQgeyBleHBlY3QgfSBmcm9tICdjaGFpJztcbmltcG9ydCB7IENvbnRyYWN0LCBwcm92aWRlcnMsIFdhbGxldCB9IGZyb20gJ2V0aGVycyc7XG5cbmltcG9ydCB7IE9ORV9NSU5VVEVfTVMsIFpFUk8gfSBmcm9tICcuLi9zcmMvY29yZS9jb25zdGFudHMnO1xuaW1wb3J0IHsgQmFsYW5jZUNoZWNrZXIgfSBmcm9tICcuLi9zcmMvdXRpbHMvYmFsYW5jZV9jaGVja2VyJztcbmltcG9ydCB7IFJmcUJsb2NrY2hhaW5VdGlscyB9IGZyb20gJy4uL3NyYy91dGlscy9yZnFfYmxvY2tjaGFpbl91dGlscyc7XG5cbmltcG9ydCB7XG4gICAgZ2V0UHJvdmlkZXIsXG4gICAgTUFUQ0hBX0FGRklMSUFURV9BRERSRVNTLFxuICAgIE1PQ0tfRVhFQ1VURV9NRVRBX1RSQU5TQUNUSU9OX0FQUFJPVkFMLFxuICAgIE1PQ0tfRVhFQ1VURV9NRVRBX1RSQU5TQUNUSU9OX0NBTExEQVRBLFxuICAgIE1PQ0tfUEVSTUlUX0FQUFJPVkFMLFxuICAgIE1PQ0tfUEVSTUlUX0NBTExEQVRBLFxuICAgIFRFU1RfUkZRX09SREVSX0ZJTExFRF9FVkVOVF9MT0csXG4gICAgVEVTVF9SRlFfT1JERVJfRklMTEVEX0VWRU5UX1RBS0VSX0FNT1VOVCxcbiAgICBXT1JLRVJfVEVTVF9QUklWQVRFX0tFWSxcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgc2V0dXBEZXBlbmRlbmNpZXNBc3luYywgVGVhcmRvd25EZXBlbmRlbmNpZXNGdW5jdGlvbkhhbmRsZSB9IGZyb20gJy4vdGVzdF91dGlscy9kZXBsb3ltZW50JztcblxuY29uc3QgR0FTX1BSSUNFID0gMWU5O1xuY29uc3QgVkFMSURfRVhQSVJZID0gbmV3IEJpZ051bWJlcig5MDAwMDAwMDAwKTtcbmNvbnN0IENIQUlOX0lEID0gQ2hhaW5JZC5HYW5hY2hlO1xuXG5qZXN0LnNldFRpbWVvdXQoT05FX01JTlVURV9NUyAqIDIpO1xubGV0IHRlYXJkb3duRGVwZW5kZW5jaWVzOiBUZWFyZG93bkRlcGVuZGVuY2llc0Z1bmN0aW9uSGFuZGxlO1xuXG5kZXNjcmliZSgnUkZRIEJsb2NrY2hhaW4gVXRpbHMnLCAoKSA9PiB7XG4gICAgbGV0IHByb3ZpZGVyOiBXZWIzUHJvdmlkZXJFbmdpbmU7XG4gICAgbGV0IG1ha2VyVG9rZW46IER1bW15RVJDMjBUb2tlbkNvbnRyYWN0O1xuICAgIGxldCB0YWtlclRva2VuOiBEdW1teUVSQzIwVG9rZW5Db250cmFjdDtcbiAgICBsZXQgbWFrZXJBbW91bnQ6IEJpZ051bWJlcjtcbiAgICBsZXQgdGFrZXJBbW91bnQ6IEJpZ051bWJlcjtcbiAgICBsZXQgaW52YWxpZFRha2VyQW1vdW50OiBCaWdOdW1iZXI7XG4gICAgbGV0IG1ha2VyQmFsYW5jZTogQmlnTnVtYmVyO1xuICAgIGxldCB0YWtlckJhbGFuY2U6IEJpZ051bWJlcjtcbiAgICBsZXQgd2ViM1dyYXBwZXI6IFdlYjNXcmFwcGVyO1xuICAgIGxldCBvd25lcjogc3RyaW5nO1xuICAgIGxldCBtYWtlcjogc3RyaW5nO1xuICAgIGxldCB0YWtlcjogc3RyaW5nO1xuICAgIGxldCBzaWduZXI6IHN0cmluZztcbiAgICBsZXQgdHhPcmlnaW46IHN0cmluZztcbiAgICBsZXQgemVyb0V4OiBJWmVyb0V4Q29udHJhY3Q7XG4gICAgbGV0IHJmcU9yZGVyOiBSZnFPcmRlcjtcbiAgICBsZXQgb3RjT3JkZXI6IE90Y09yZGVyO1xuICAgIGxldCB1bmZpbGxhYmxlUmZxT3JkZXI6IFJmcU9yZGVyO1xuICAgIGxldCByZnFCbG9ja2NoYWluVXRpbHM6IFJmcUJsb2NrY2hhaW5VdGlscztcbiAgICBsZXQgb3JkZXJTaWc6IFNpZ25hdHVyZTtcbiAgICBsZXQgc2lnRm9yVW5maWxsYWJsZU9yZGVyOiBTaWduYXR1cmU7XG4gICAgbGV0IG1ha2VyT3RjT3JkZXJTaWc6IFNpZ25hdHVyZTtcbiAgICBsZXQgdGFrZXJPdGNPcmRlclNpZzogU2lnbmF0dXJlO1xuXG4gICAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgdGVhcmRvd25EZXBlbmRlbmNpZXMgPSBhd2FpdCBzZXR1cERlcGVuZGVuY2llc0FzeW5jKFsnZ2FuYWNoZSddKTtcbiAgICAgICAgcHJvdmlkZXIgPSBnZXRQcm92aWRlcigpO1xuICAgICAgICB3ZWIzV3JhcHBlciA9IG5ldyBXZWIzV3JhcHBlcihwcm92aWRlcik7XG5cbiAgICAgICAgW293bmVyLCBtYWtlciwgdGFrZXIsIHR4T3JpZ2luLCBzaWduZXJdID0gYXdhaXQgd2ViM1dyYXBwZXIuZ2V0QXZhaWxhYmxlQWRkcmVzc2VzQXN5bmMoKTtcblxuICAgICAgICAvLyBEZXBsb3kgZHVtbXkgdG9rZW5zXG4gICAgICAgIG1ha2VyVG9rZW4gPSBhd2FpdCBEdW1teUVSQzIwVG9rZW5Db250cmFjdC5kZXBsb3lGcm9tMHhBcnRpZmFjdEFzeW5jKFxuICAgICAgICAgICAgZXJjMjBBcnRpZmFjdHMuRHVtbXlFUkMyMFRva2VuLFxuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICB7IGZyb206IG1ha2VyLCBnYXM6IDEwMDAwMDAwIH0sXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICdUaGUgdG9rZW4gdGhhdCBvcmlnaW5hbGx5IGJlbG9uZ3MgdG8gdGhlIG1ha2VyJyxcbiAgICAgICAgICAgICdtYWtlclRva2VuJyxcbiAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMTgpLFxuICAgICAgICAgICAgbmV3IEJpZ051bWJlcigwKSxcbiAgICAgICAgKTtcblxuICAgICAgICB0YWtlclRva2VuID0gYXdhaXQgRHVtbXlFUkMyMFRva2VuQ29udHJhY3QuZGVwbG95RnJvbTB4QXJ0aWZhY3RBc3luYyhcbiAgICAgICAgICAgIGVyYzIwQXJ0aWZhY3RzLkR1bW15RVJDMjBUb2tlbixcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgeyBmcm9tOiB0YWtlciwgZ2FzOiAxMDAwMDAwMCB9LFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICAnVGhlIHRva2VuIHRoYXQgb3JpZ2luYWxseSBiZWxvbmdzIHRvIHRoZSBtYWtlcicsXG4gICAgICAgICAgICAndGFrZXJUb2tlbicsXG4gICAgICAgICAgICBuZXcgQmlnTnVtYmVyKDE4KSxcbiAgICAgICAgICAgIG5ldyBCaWdOdW1iZXIoMCksXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRGVwbG95IEJhbGFuY2UgQ2hlY2tlciAob25seSBuZWNlc3NhcnkgZm9yIEdhbmFjaGUgYmVjYXVzZSBnYW5hY2hlIGRvZXNuJ3QgaGF2ZSBvdmVycmlkZXMpXG4gICAgICAgIGNvbnN0IGJhbGFuY2VDaGVja2VyQ29udHJhY3QgPSBhd2FpdCBCYWxhbmNlQ2hlY2tlckNvbnRyYWN0LmRlcGxveUZyb20weEFydGlmYWN0QXN5bmMoXG4gICAgICAgICAgICBhc3NldFN3YXBwZXJBcnRpZmFjdHMuQmFsYW5jZUNoZWNrZXIsXG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIHsgZnJvbTogb3duZXIsIGdhczogMTAwMDAwMDAgfSxcbiAgICAgICAgICAgIHt9LFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBiYWxhbmNlQ2hlY2tlciA9IG5ldyBCYWxhbmNlQ2hlY2tlcihwcm92aWRlciwgYmFsYW5jZUNoZWNrZXJDb250cmFjdCk7XG5cbiAgICAgICAgbWFrZXJBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDEwMCk7XG4gICAgICAgIHRha2VyQW1vdW50ID0gbmV3IEJpZ051bWJlcig1MCk7XG4gICAgICAgIGludmFsaWRUYWtlckFtb3VudCA9IG5ldyBCaWdOdW1iZXIoMTAwMDAwMDApO1xuXG4gICAgICAgIC8vIERlcGxveSBaZXJvRXggdG8gR2FuYWNoZVxuICAgICAgICB6ZXJvRXggPSBhd2FpdCBmdWxsTWlncmF0ZUFzeW5jKFxuICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIHsgZnJvbTogb3duZXIsIGdhc1ByaWNlOiBHQVNfUFJJQ0UgfSxcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgeyBwcm90b2NvbEZlZU11bHRpcGxpZXI6IE51bWJlcigwKSB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hdGl2ZU9yZGVyczogemVyb0V4QXJ0aWZhY3RzLk5hdGl2ZU9yZGVyc0ZlYXR1cmUsXG4gICAgICAgICAgICAgICAgbWV0YVRyYW5zYWN0aW9uczogemVyb0V4QXJ0aWZhY3RzLk1ldGFUcmFuc2FjdGlvbnNGZWF0dXJlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQcmVwYXJlIGFuIFJmcU9yZGVyXG4gICAgICAgIHJmcU9yZGVyID0gbmV3IFJmcU9yZGVyKHtcbiAgICAgICAgICAgIG1ha2VyVG9rZW46IG1ha2VyVG9rZW4uYWRkcmVzcyxcbiAgICAgICAgICAgIHRha2VyVG9rZW46IHRha2VyVG9rZW4uYWRkcmVzcyxcbiAgICAgICAgICAgIG1ha2VyQW1vdW50LFxuICAgICAgICAgICAgdGFrZXJBbW91bnQsXG4gICAgICAgICAgICBtYWtlcixcbiAgICAgICAgICAgIHRha2VyLFxuICAgICAgICAgICAgdHhPcmlnaW4sXG4gICAgICAgICAgICBleHBpcnk6IFZBTElEX0VYUElSWSxcbiAgICAgICAgICAgIHNhbHQ6IG5ldyBCaWdOdW1iZXIoMSksXG4gICAgICAgICAgICB2ZXJpZnlpbmdDb250cmFjdDogemVyb0V4LmFkZHJlc3MsXG4gICAgICAgICAgICBjaGFpbklkOiBDSEFJTl9JRCxcbiAgICAgICAgfSk7XG4gICAgICAgIG9yZGVyU2lnID0gYXdhaXQgcmZxT3JkZXIuZ2V0U2lnbmF0dXJlV2l0aFByb3ZpZGVyQXN5bmMocHJvdmlkZXIpO1xuXG4gICAgICAgIC8vIFByZXBhcmUgYW4gVW5maWxsYWJsZSBSZnFPcmRlclxuICAgICAgICB1bmZpbGxhYmxlUmZxT3JkZXIgPSBuZXcgUmZxT3JkZXIoe1xuICAgICAgICAgICAgbWFrZXJUb2tlbjogbWFrZXJUb2tlbi5hZGRyZXNzLFxuICAgICAgICAgICAgdGFrZXJUb2tlbjogdGFrZXJUb2tlbi5hZGRyZXNzLFxuICAgICAgICAgICAgbWFrZXJBbW91bnQsXG4gICAgICAgICAgICB0YWtlckFtb3VudDogaW52YWxpZFRha2VyQW1vdW50LFxuICAgICAgICAgICAgbWFrZXIsXG4gICAgICAgICAgICB0YWtlcixcbiAgICAgICAgICAgIHR4T3JpZ2luLFxuICAgICAgICAgICAgZXhwaXJ5OiBWQUxJRF9FWFBJUlksXG4gICAgICAgICAgICBzYWx0OiBuZXcgQmlnTnVtYmVyKDEpLFxuICAgICAgICAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6IHplcm9FeC5hZGRyZXNzLFxuICAgICAgICAgICAgY2hhaW5JZDogQ0hBSU5fSUQsXG4gICAgICAgIH0pO1xuICAgICAgICBzaWdGb3JVbmZpbGxhYmxlT3JkZXIgPSBhd2FpdCB1bmZpbGxhYmxlUmZxT3JkZXIuZ2V0U2lnbmF0dXJlV2l0aFByb3ZpZGVyQXN5bmMocHJvdmlkZXIpO1xuXG4gICAgICAgIC8vIFByZXBhcmUgYW4gT3RjT3JkZXIgYW5kIHZhbGlkIHNpZ25hdHVyZXNcbiAgICAgICAgb3RjT3JkZXIgPSBuZXcgT3RjT3JkZXIoe1xuICAgICAgICAgICAgbWFrZXIsXG4gICAgICAgICAgICB0YWtlcixcbiAgICAgICAgICAgIG1ha2VyQW1vdW50LFxuICAgICAgICAgICAgdGFrZXJBbW91bnQsXG4gICAgICAgICAgICBtYWtlclRva2VuOiBtYWtlclRva2VuLmFkZHJlc3MsXG4gICAgICAgICAgICB0YWtlclRva2VuOiB0YWtlclRva2VuLmFkZHJlc3MsXG4gICAgICAgICAgICB0eE9yaWdpbixcbiAgICAgICAgICAgIGV4cGlyeUFuZE5vbmNlOiBPdGNPcmRlci5lbmNvZGVFeHBpcnlBbmROb25jZShcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKFZBTElEX0VYUElSWSksXG4gICAgICAgICAgICAgICAgWkVSTyxcbiAgICAgICAgICAgICAgICBuZXcgQmlnTnVtYmVyKFZBTElEX0VYUElSWSksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY2hhaW5JZDogQ0hBSU5fSUQsXG4gICAgICAgICAgICB2ZXJpZnlpbmdDb250cmFjdDogemVyb0V4LmFkZHJlc3MsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvcmRlckhhc2ggPSBvdGNPcmRlci5nZXRIYXNoKCk7XG4gICAgICAgIG1ha2VyT3RjT3JkZXJTaWcgPSBhd2FpdCBldGhTaWduSGFzaFdpdGhQcm92aWRlckFzeW5jKG9yZGVySGFzaCwgbWFrZXIsIHByb3ZpZGVyKTtcbiAgICAgICAgdGFrZXJPdGNPcmRlclNpZyA9IGF3YWl0IGV0aFNpZ25IYXNoV2l0aFByb3ZpZGVyQXN5bmMob3JkZXJIYXNoLCB0YWtlciwgcHJvdmlkZXIpO1xuXG4gICAgICAgIC8vIE1pbnQgZW5vdWdoIHRva2VucyBmb3IgYSBmZXcgdHJhZGVzXG4gICAgICAgIGNvbnN0IG51bVRyYWRlcyA9IDI7XG4gICAgICAgIG1ha2VyQmFsYW5jZSA9IG1ha2VyQW1vdW50LnRpbWVzKG51bVRyYWRlcyk7XG4gICAgICAgIHRha2VyQmFsYW5jZSA9IHRha2VyQW1vdW50LnRpbWVzKG51bVRyYWRlcyk7XG5cbiAgICAgICAgYXdhaXQgbWFrZXJUb2tlbi5taW50KG1ha2VyQmFsYW5jZSkuYXdhaXRUcmFuc2FjdGlvblN1Y2Nlc3NBc3luYyh7IGZyb206IG1ha2VyIH0pO1xuICAgICAgICBhd2FpdCBtYWtlclRva2VuLmFwcHJvdmUoemVyb0V4LmFkZHJlc3MsIG1ha2VyQmFsYW5jZS50aW1lcygyKSkuYXdhaXRUcmFuc2FjdGlvblN1Y2Nlc3NBc3luYyh7IGZyb206IG1ha2VyIH0pO1xuICAgICAgICBhd2FpdCB0YWtlclRva2VuLm1pbnQodGFrZXJCYWxhbmNlKS5hd2FpdFRyYW5zYWN0aW9uU3VjY2Vzc0FzeW5jKHsgZnJvbTogdGFrZXIgfSk7XG4gICAgICAgIGF3YWl0IHRha2VyVG9rZW4uYXBwcm92ZSh6ZXJvRXguYWRkcmVzcywgdGFrZXJCYWxhbmNlLnRpbWVzKDIpKS5hd2FpdFRyYW5zYWN0aW9uU3VjY2Vzc0FzeW5jKHsgZnJvbTogdGFrZXIgfSk7XG5cbiAgICAgICAgY29uc3QgZXRoZXJzUHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcigpO1xuICAgICAgICBjb25zdCBldGhlcnNXYWxsZXQgPSBuZXcgV2FsbGV0KFdPUktFUl9URVNUX1BSSVZBVEVfS0VZLCBldGhlcnNQcm92aWRlcik7XG5cbiAgICAgICAgcmZxQmxvY2tjaGFpblV0aWxzID0gbmV3IFJmcUJsb2NrY2hhaW5VdGlscyhcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgemVyb0V4LmFkZHJlc3MsXG4gICAgICAgICAgICBiYWxhbmNlQ2hlY2tlcixcbiAgICAgICAgICAgIGV0aGVyc1Byb3ZpZGVyLFxuICAgICAgICAgICAgZXRoZXJzV2FsbGV0LFxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXRlYXJkb3duRGVwZW5kZW5jaWVzKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHRlYXIgZG93biBkZXBlbmRlbmNpZXMnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2dldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgZmV0Y2ggbWluIG9mIHRva2VuIGJhbGFuY2VzIGFuZCBhbGxvd2FuY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW1xuICAgICAgICAgICAgICAgIHsgb3duZXI6IG1ha2VyLCB0b2tlbjogbWFrZXJUb2tlbi5hZGRyZXNzIH0sXG4gICAgICAgICAgICAgICAgeyBvd25lcjogbWFrZXIsIHRva2VuOiB0YWtlclRva2VuLmFkZHJlc3MgfSxcbiAgICAgICAgICAgICAgICB7IG93bmVyOiB0YWtlciwgdG9rZW46IG1ha2VyVG9rZW4uYWRkcmVzcyB9LFxuICAgICAgICAgICAgICAgIHsgb3duZXI6IHRha2VyLCB0b2tlbjogdGFrZXJUb2tlbi5hZGRyZXNzIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgcmZxQmxvY2tjaGFpblV0aWxzLmdldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMoYWRkcmVzc2VzKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXMpLnRvLmRlZXAuZXEoW21ha2VyQmFsYW5jZSwgWkVSTywgWkVSTywgdGFrZXJCYWxhbmNlXSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2dldFRva2VuQmFsYW5jZXNBc3luYycsICgpID0+IHtcbiAgICAgICAgaXQoJ3Nob3VsZCBmZXRjaCB0b2tlbiBiYWxhbmNlcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IFtcbiAgICAgICAgICAgICAgICB7IG93bmVyOiBtYWtlciwgdG9rZW46IG1ha2VyVG9rZW4uYWRkcmVzcyB9LFxuICAgICAgICAgICAgICAgIHsgb3duZXI6IG1ha2VyLCB0b2tlbjogdGFrZXJUb2tlbi5hZGRyZXNzIH0sXG4gICAgICAgICAgICAgICAgeyBvd25lcjogdGFrZXIsIHRva2VuOiBtYWtlclRva2VuLmFkZHJlc3MgfSxcbiAgICAgICAgICAgICAgICB7IG93bmVyOiB0YWtlciwgdG9rZW46IHRha2VyVG9rZW4uYWRkcmVzcyB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJmcUJsb2NrY2hhaW5VdGlscy5nZXRUb2tlbkJhbGFuY2VzQXN5bmMoYWRkcmVzc2VzKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXMpLnRvLmRlZXAuZXEoW21ha2VyQmFsYW5jZSwgWkVSTywgWkVSTywgdGFrZXJCYWxhbmNlXSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ090Y09yZGVyJywgKCkgPT4ge1xuICAgICAgICBkZXNjcmliZSgnZXN0aW1hdGVHYXNGb3JGaWxsVGFrZXJTaWduZWRPdGNPcmRlckFzeW5jJywgKCkgPT4ge1xuICAgICAgICAgICAgaXQoJ2RvZXMgbm90IHRocm93IGFuIGVycm9yIG9uIHZhbGlkIG9yZGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdhc0VzdGltYXRlID0gYXdhaXQgcmZxQmxvY2tjaGFpblV0aWxzLmVzdGltYXRlR2FzRm9yRmlsbFRha2VyU2lnbmVkT3RjT3JkZXJBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIG90Y09yZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZXJPdGNPcmRlclNpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRha2VyT3RjT3JkZXJTaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eE9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoZ2FzRXN0aW1hdGUpLnRvLmJlLmdyZWF0ZXJUaGFuKDApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QuZmFpbCgnc2hvdWxkIG5vdCB0aHJvdycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgndGhyb3dzIGFuIGVycm9yIGlmIG9yZGVyIGlzIGludmFsaWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZE90Y09yZGVyID0gbmV3IE90Y09yZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbWFrZXIsXG4gICAgICAgICAgICAgICAgICAgIHRha2VyLFxuICAgICAgICAgICAgICAgICAgICBtYWtlckFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgdGFrZXJBbW91bnQsXG4gICAgICAgICAgICAgICAgICAgIG1ha2VyVG9rZW46IG1ha2VyVG9rZW4uYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgdGFrZXJUb2tlbjogdGFrZXJUb2tlbi5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB0eE9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJ5QW5kTm9uY2U6IE90Y09yZGVyLmVuY29kZUV4cGlyeUFuZE5vbmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgWkVSTywgLy8gZXhwaXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgWkVSTyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFZBTElEX0VYUElSWSxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogQ0hBSU5fSUQsXG4gICAgICAgICAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiB6ZXJvRXguYWRkcmVzcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmRlckhhc2ggPSBpbnZhbGlkT3RjT3JkZXIuZ2V0SGFzaCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWFrZXJTaWcgPSBhd2FpdCBldGhTaWduSGFzaFdpdGhQcm92aWRlckFzeW5jKG9yZGVySGFzaCwgbWFrZXIsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWtlclNpZyA9IGF3YWl0IGV0aFNpZ25IYXNoV2l0aFByb3ZpZGVyQXN5bmMob3JkZXJIYXNoLCB0YWtlciwgcHJvdmlkZXIpO1xuXG4gICAgICAgICAgICAgICAgZXhwZWN0KFxuICAgICAgICAgICAgICAgICAgICByZnFCbG9ja2NoYWluVXRpbHMuZXN0aW1hdGVHYXNGb3JGaWxsVGFrZXJTaWduZWRPdGNPcmRlckFzeW5jKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZE90Y09yZGVyLCAvLyBpbnZhbGlkIG9yZGVyLCBzaG91bGQgYmUgZXhwaXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZXJTaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWtlclNpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4T3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKS50by5ldmVudHVhbGx5LmJlLnJlamVjdGVkV2l0aCgvcmV2ZXJ0Lyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3Rocm93cyBhbiBlcnJvciBpZiBzaWduYXR1cmVzIGludmFsaWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFxuICAgICAgICAgICAgICAgICAgICByZnFCbG9ja2NoYWluVXRpbHMuZXN0aW1hdGVHYXNGb3JGaWxsVGFrZXJTaWduZWRPdGNPcmRlckFzeW5jKFxuICAgICAgICAgICAgICAgICAgICAgICAgb3RjT3JkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlck90Y09yZGVyU2lnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZXJPdGNPcmRlclNpZywgLy8gd3Jvbmcgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICB0eE9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICkudG8uZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGgoJ3JldmVydCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3ZhbGlkYXRlTWV0YVRyYW5zYWN0aW9uJywgKCkgPT4ge1xuICAgICAgICBpdCgncmV0dXJucyBzdWNjZXNzZnVsIGZpbGxlZCBhbW91bnRzIGZvciBhIHZhbGlkIG1ldGF0cmFuc2FjdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFUeCA9IHJmcUJsb2NrY2hhaW5VdGlscy5nZW5lcmF0ZU1ldGFUcmFuc2FjdGlvbihyZnFPcmRlciwgb3JkZXJTaWcsIHRha2VyLCB0YWtlckFtb3VudCwgQ0hBSU5fSUQpO1xuICAgICAgICAgICAgY29uc3QgbWV0YVR4U2lnID0gYXdhaXQgbWV0YVR4LmdldFNpZ25hdHVyZVdpdGhQcm92aWRlckFzeW5jKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJmcUJsb2NrY2hhaW5VdGlscy52YWxpZGF0ZU1ldGFUcmFuc2FjdGlvbk9yVGhyb3dBc3luYyhtZXRhVHgsIG1ldGFUeFNpZywgdHhPcmlnaW4pO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzWzBdKS50by5kZWVwLmVxdWFsKHRha2VyQW1vdW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXNbMV0pLnRvLmRlZXAuZXF1YWwobWFrZXJBbW91bnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgndGhyb3dzIGZvciBhIG1ldGF0cmFuc2FjdGlvbiB3aXRoIGFuIGludmFsaWQgc2lnbmF0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWV0YVR4ID0gcmZxQmxvY2tjaGFpblV0aWxzLmdlbmVyYXRlTWV0YVRyYW5zYWN0aW9uKHJmcU9yZGVyLCBvcmRlclNpZywgdGFrZXIsIHRha2VyQW1vdW50LCBDSEFJTl9JRCk7XG4gICAgICAgICAgICBjb25zdCBpbnZhbGlkTWV0YVR4U2lnID0gb3JkZXJTaWc7XG5cbiAgICAgICAgICAgIGV4cGVjdChcbiAgICAgICAgICAgICAgICByZnFCbG9ja2NoYWluVXRpbHMudmFsaWRhdGVNZXRhVHJhbnNhY3Rpb25PclRocm93QXN5bmMobWV0YVR4LCBpbnZhbGlkTWV0YVR4U2lnLCB0eE9yaWdpbiksXG4gICAgICAgICAgICApLnRvLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWRXaXRoKCdTaWduYXR1cmVWYWxpZGF0aW9uRXJyb3InKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Rocm93cyBmb3IgYSBtZXRhdHJhbnNhY3Rpb24gd2l0aCBhbiB1bmZpbGxhYmxlIG9yZGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWV0YVR4ID0gcmZxQmxvY2tjaGFpblV0aWxzLmdlbmVyYXRlTWV0YVRyYW5zYWN0aW9uKFxuICAgICAgICAgICAgICAgIHVuZmlsbGFibGVSZnFPcmRlcixcbiAgICAgICAgICAgICAgICBzaWdGb3JVbmZpbGxhYmxlT3JkZXIsXG4gICAgICAgICAgICAgICAgdGFrZXIsXG4gICAgICAgICAgICAgICAgaW52YWxpZFRha2VyQW1vdW50LFxuICAgICAgICAgICAgICAgIENIQUlOX0lELFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFUeFNpZyA9IGF3YWl0IG1ldGFUeC5nZXRTaWduYXR1cmVXaXRoUHJvdmlkZXJBc3luYyhwcm92aWRlcik7XG5cbiAgICAgICAgICAgIGV4cGVjdChcbiAgICAgICAgICAgICAgICByZnFCbG9ja2NoYWluVXRpbHMudmFsaWRhdGVNZXRhVHJhbnNhY3Rpb25PclRocm93QXN5bmMobWV0YVR4LCBtZXRhVHhTaWcsIHR4T3JpZ2luKSxcbiAgICAgICAgICAgICkudG8uZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGgoJ01ldGFUcmFuc2FjdGlvbkNhbGxGYWlsZWRFcnJvcicpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgncmV0dXJucyBzdWNjZXNzZnVsIGZpbGxlZCBhbW91bnRzIGZvciBhIHZhbGlkIG1ldGF0cmFuc2FjdGlvbiB3aGVuIHZhbGlkYXRpbmcgY2FsbGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXRhVHggPSByZnFCbG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb24ocmZxT3JkZXIsIG9yZGVyU2lnLCB0YWtlciwgdGFrZXJBbW91bnQsIENIQUlOX0lEKTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFUeFNpZyA9IGF3YWl0IG1ldGFUeC5nZXRTaWduYXR1cmVXaXRoUHJvdmlkZXJBc3luYyhwcm92aWRlcik7XG5cbiAgICAgICAgICAgIGNvbnN0IGNhbGxEYXRhID0gcmZxQmxvY2tjaGFpblV0aWxzLmdlbmVyYXRlTWV0YVRyYW5zYWN0aW9uQ2FsbERhdGEoXG4gICAgICAgICAgICAgICAgbWV0YVR4LFxuICAgICAgICAgICAgICAgIG1ldGFUeFNpZyxcbiAgICAgICAgICAgICAgICBNQVRDSEFfQUZGSUxJQVRFX0FERFJFU1MsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgcmZxQmxvY2tjaGFpblV0aWxzLmRlY29kZU1ldGFUcmFuc2FjdGlvbkNhbGxEYXRhQW5kVmFsaWRhdGVBc3luYyhjYWxsRGF0YSwgdHhPcmlnaW4pO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzWzBdKS50by5kZWVwLmVxdWFsKHRha2VyQW1vdW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXNbMV0pLnRvLmRlZXAuZXF1YWwobWFrZXJBbW91bnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3Rocm93cyBmb3IgYSBtZXRhdHJhbnNhY3Rpb24gd2l0aCBhbiBpbnZhbGlkIHNpZ25hdHVyZSB3aGVuIHZhbGlkYXRpbmcgY2FsbGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXRhVHggPSByZnFCbG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb24ocmZxT3JkZXIsIG9yZGVyU2lnLCB0YWtlciwgdGFrZXJBbW91bnQsIENIQUlOX0lEKTtcbiAgICAgICAgICAgIGNvbnN0IGludmFsaWRNZXRhVHhTaWcgPSBvcmRlclNpZztcblxuICAgICAgICAgICAgY29uc3QgY2FsbERhdGEgPSByZnFCbG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb25DYWxsRGF0YShcbiAgICAgICAgICAgICAgICBtZXRhVHgsXG4gICAgICAgICAgICAgICAgaW52YWxpZE1ldGFUeFNpZyxcbiAgICAgICAgICAgICAgICBNQVRDSEFfQUZGSUxJQVRFX0FERFJFU1MsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QoXG4gICAgICAgICAgICAgICAgcmZxQmxvY2tjaGFpblV0aWxzLmRlY29kZU1ldGFUcmFuc2FjdGlvbkNhbGxEYXRhQW5kVmFsaWRhdGVBc3luYyhjYWxsRGF0YSwgdHhPcmlnaW4pLFxuICAgICAgICAgICAgKS50by5ldmVudHVhbGx5LmJlLnJlamVjdGVkV2l0aCgnU2lnbmF0dXJlVmFsaWRhdGlvbkVycm9yJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCd0aHJvd3MgZm9yIGEgbWV0YXRyYW5zYWN0aW9uIHdpdGggYW4gdW5maWxsYWJsZSBvcmRlciB3aGVuIHZhbGlkYXRpbmcgY2FsbGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXRhVHggPSByZnFCbG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb24oXG4gICAgICAgICAgICAgICAgdW5maWxsYWJsZVJmcU9yZGVyLFxuICAgICAgICAgICAgICAgIHNpZ0ZvclVuZmlsbGFibGVPcmRlcixcbiAgICAgICAgICAgICAgICB0YWtlcixcbiAgICAgICAgICAgICAgICBpbnZhbGlkVGFrZXJBbW91bnQsXG4gICAgICAgICAgICAgICAgQ0hBSU5fSUQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgbWV0YVR4U2lnID0gYXdhaXQgbWV0YVR4LmdldFNpZ25hdHVyZVdpdGhQcm92aWRlckFzeW5jKHByb3ZpZGVyKTtcblxuICAgICAgICAgICAgY29uc3QgY2FsbERhdGEgPSByZnFCbG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb25DYWxsRGF0YShcbiAgICAgICAgICAgICAgICBtZXRhVHgsXG4gICAgICAgICAgICAgICAgbWV0YVR4U2lnLFxuICAgICAgICAgICAgICAgIE1BVENIQV9BRkZJTElBVEVfQUREUkVTUyxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChcbiAgICAgICAgICAgICAgICByZnFCbG9ja2NoYWluVXRpbHMuZGVjb2RlTWV0YVRyYW5zYWN0aW9uQ2FsbERhdGFBbmRWYWxpZGF0ZUFzeW5jKGNhbGxEYXRhLCB0eE9yaWdpbiksXG4gICAgICAgICAgICApLnRvLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWRXaXRoKCdNZXRhVHJhbnNhY3Rpb25DYWxsRmFpbGVkRXJyb3InKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCB0aHJvdyBmb3IgYSBwYXJ0aWFsbHkgZmlsbGVkIG9yZGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWV0YVR4MSA9IHJmcUJsb2NrY2hhaW5VdGlscy5nZW5lcmF0ZU1ldGFUcmFuc2FjdGlvbihcbiAgICAgICAgICAgICAgICByZnFPcmRlcixcbiAgICAgICAgICAgICAgICBvcmRlclNpZyxcbiAgICAgICAgICAgICAgICB0YWtlcixcbiAgICAgICAgICAgICAgICB0YWtlckFtb3VudC5kaXYoMiksXG4gICAgICAgICAgICAgICAgQ0hBSU5fSUQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgbWV0YVR4U2lnMSA9IGF3YWl0IG1ldGFUeDEuZ2V0U2lnbmF0dXJlV2l0aFByb3ZpZGVyQXN5bmMocHJvdmlkZXIpO1xuXG4gICAgICAgICAgICBhd2FpdCB6ZXJvRXguZXhlY3V0ZU1ldGFUcmFuc2FjdGlvbihtZXRhVHgxLCBtZXRhVHhTaWcxKS5hd2FpdFRyYW5zYWN0aW9uU3VjY2Vzc0FzeW5jKHsgZnJvbTogdHhPcmlnaW4gfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IG1ldGFUeDIgPSByZnFCbG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVNZXRhVHJhbnNhY3Rpb24oXG4gICAgICAgICAgICAgICAgcmZxT3JkZXIsXG4gICAgICAgICAgICAgICAgb3JkZXJTaWcsXG4gICAgICAgICAgICAgICAgdGFrZXIsXG4gICAgICAgICAgICAgICAgdGFrZXJBbW91bnQsXG4gICAgICAgICAgICAgICAgQ0hBSU5fSUQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgbWV0YVR4U2lnMiA9IGF3YWl0IG1ldGFUeDIuZ2V0U2lnbmF0dXJlV2l0aFByb3ZpZGVyQXN5bmMocHJvdmlkZXIpO1xuXG4gICAgICAgICAgICBleHBlY3QoXG4gICAgICAgICAgICAgICAgcmZxQmxvY2tjaGFpblV0aWxzLnZhbGlkYXRlTWV0YVRyYW5zYWN0aW9uT3JUaHJvd0FzeW5jKG1ldGFUeDIsIG1ldGFUeFNpZzIsIHR4T3JpZ2luKSxcbiAgICAgICAgICAgICkudG8uZXZlbnR1YWxseS5iZS5yZWplY3RlZFdpdGgoJ2ZpbGxlZCBhbW91bnQgaXMgbGVzcyB0aGFuIHJlcXVlc3RlZCBmaWxsIGFtb3VudCcpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd0cmFuc2Zvcm1UeERhdGFUb1RyYW5zYWN0aW9uUmVxdWVzdCcsICgpID0+IHtcbiAgICAgICAgaXQoJ2NyZWF0ZXMgYSBUcmFuc2FjdGlvblJlcXVlc3QnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0eE9wdGlvbnM6IFR4RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBmcm9tOiAnMHhmcm9tYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgZ2FzOiBuZXcgQmlnTnVtYmVyKDIxMDAwMDAwMCksXG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBuZXcgQmlnTnVtYmVyKDIwMDAwMCksXG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IG5ldyBCaWdOdW1iZXIoMTAwMDAwKSxcbiAgICAgICAgICAgICAgICBub25jZTogMjEsXG4gICAgICAgICAgICAgICAgdG86ICcweHRvYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZnFCbG9ja2NoYWluVXRpbHMudHJhbnNmb3JtVHhEYXRhVG9UcmFuc2FjdGlvblJlcXVlc3QoXG4gICAgICAgICAgICAgICAgdHhPcHRpb25zLFxuICAgICAgICAgICAgICAgIC8qIGNoYWluSWQgPSAqLyAxMzM3LFxuICAgICAgICAgICAgICAgIC8qIGNhbGxEYXRhICovICcweDAxMjM0JyxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZnJvbSkudG8uZXF1YWwoJzB4ZnJvbWFkZHJlc3MnKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2FzTGltaXQpLnRvLmVxdWFsKEJpZ0ludCgyMTAwMDAwMDApKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubWF4RmVlUGVyR2FzKS50by5lcXVhbChCaWdJbnQoMjAwMDAwKSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm1heFByaW9yaXR5RmVlUGVyR2FzKS50by5lcXVhbChCaWdJbnQoMTAwMDAwKSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm5vbmNlKS50by5lcXVhbCgyMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LnRvKS50by5lcXVhbCgnMHh0b2FkZHJlc3MnKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUpLnRvLmVxdWFsKDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcInVzZXMgdGhlIHByb3h5IGFkZHJlc3MgaWYgbm8gJ3RvJyBhZGRyZXNzIGlzIHByb3ZpZGVkXCIsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR4T3B0aW9uczogVHhEYXRhID0geyBmcm9tOiAnMHhmcm9tYWRkcmVzcycgfTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmZxQmxvY2tjaGFpblV0aWxzLnRyYW5zZm9ybVR4RGF0YVRvVHJhbnNhY3Rpb25SZXF1ZXN0KHR4T3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQudG8pLnRvLmVxdWFsKHplcm9FeC5hZGRyZXNzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZ2V0RGVjb2RlZFJmcU9yZGVyRmlsbEV2ZW50TG9nRnJvbUxvZ3MnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdjb3JyZWN0bHkgcGFyc2VzIGFuIFJmcU9yZGVyRmlsbEV2ZW50IGZyb20gbG9ncycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJmcU9yZGVyRmlsbGVkRXZlbnQgPSByZnFCbG9ja2NoYWluVXRpbHMuZ2V0RGVjb2RlZFJmcU9yZGVyRmlsbEV2ZW50TG9nRnJvbUxvZ3MoW1xuICAgICAgICAgICAgICAgIFRFU1RfUkZRX09SREVSX0ZJTExFRF9FVkVOVF9MT0csXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgZXhwZWN0KHJmcU9yZGVyRmlsbGVkRXZlbnQuYXJncy50YWtlclRva2VuRmlsbGVkQW1vdW50KS50by5kZWVwLmVxKFxuICAgICAgICAgICAgICAgIFRFU1RfUkZRX09SREVSX0ZJTExFRF9FVkVOVF9UQUtFUl9BTU9VTlQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXhwZWN0KHJmcU9yZGVyRmlsbGVkRXZlbnQuYmxvY2tOdW1iZXIpLnRvLmRlZXAuZXEoVEVTVF9SRlFfT1JERVJfRklMTEVEX0VWRU5UX0xPRy5ibG9ja051bWJlcik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2dldFRva2VuRGVjaW1hbHNBc3luYycsICgpID0+IHtcbiAgICAgICAgaXQoJ2dldHMgdGhlIHRva2VuIGRlY2ltYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVjaW1hbHMgPSBhd2FpdCByZnFCbG9ja2NoYWluVXRpbHMuZ2V0VG9rZW5EZWNpbWFsc0FzeW5jKG1ha2VyVG9rZW4uYWRkcmVzcyk7XG5cbiAgICAgICAgICAgIGV4cGVjdChkZWNpbWFscykudG8uZXF1YWwoMTgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgndGhyb3dzIGlmIHRoZSBjb250cmFjdCBkb2VzIG5vdCBleGlzdCcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tdW51c2VkLWV4cHJlc3Npb24gbm8tdW5ib3VuZC1tZXRob2RcbiAgICAgICAgICAgIGV4cGVjdChyZnFCbG9ja2NoYWluVXRpbHMuZ2V0VG9rZW5EZWNpbWFsc0FzeW5jKCcweDI5RDdkMWRkNUI2ZjlDODY0ZDlkYjU2MEQ3MmEyNDdjMTc4YUU4NkInKSkudG8uYmVcbiAgICAgICAgICAgICAgICAucmVqZWN0ZWQ7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2lzVmFsaWRPcmRlclNpZ25lcicsICgpID0+IHtcbiAgICAgICAgaXQoJ3JldHVybnMgZmFsc2UgaWYgc2lnbmVyIGlzIG5vdCB2YWxpZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRPcmRlclNpZ25lciA9IGF3YWl0IHJmcUJsb2NrY2hhaW5VdGlscy5pc1ZhbGlkT3JkZXJTaWduZXJBc3luYyhtYWtlciwgc2lnbmVyKTtcbiAgICAgICAgICAgIGV4cGVjdChpc1ZhbGlkT3JkZXJTaWduZXIpLnRvLmVxdWFsKGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3JldHVybnMgdHJ1ZSB3aGVuIHZhbGlkIHNpZ25lciBhZGRyZXNzIGlzIHBhc3NlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHJmcUJsb2NrY2hhaW5VdGlscy5yZWdpc3RlckFsbG93ZWRPcmRlclNpZ25lckFzeW5jKG1ha2VyLCBzaWduZXIsIHRydWUpO1xuXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkT3JkZXJTaWduZXIgPSBhd2FpdCByZnFCbG9ja2NoYWluVXRpbHMuaXNWYWxpZE9yZGVyU2lnbmVyQXN5bmMobWFrZXIsIHNpZ25lcik7XG4gICAgICAgICAgICBleHBlY3QoaXNWYWxpZE9yZGVyU2lnbmVyKS50by5lcXVhbCh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZ2VuZXJhdGVBcHByb3ZhbENhbGxkYXRhQXN5bmMnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdnZW5lcmF0ZXMgZXhlY3V0ZU1ldGFUcmFuc2FjdGlvbiBjYWxsZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gbWFrZXJUb2tlbi5hZGRyZXNzO1xuICAgICAgICAgICAgY29uc3QgYXBwcm92YWwgPSBNT0NLX0VYRUNVVEVfTUVUQV9UUkFOU0FDVElPTl9BUFBST1ZBTDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZTogU2lnbmF0dXJlID0ge1xuICAgICAgICAgICAgICAgIHI6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICAgICAgICAgICAgIHM6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICAgICAgICAgICAgIHY6IDI4LFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZVR5cGU6IDIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2FsbGRhdGEgPSBhd2FpdCByZnFCbG9ja2NoYWluVXRpbHMuZ2VuZXJhdGVBcHByb3ZhbENhbGxkYXRhQXN5bmModG9rZW4sIGFwcHJvdmFsLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgZXhwZWN0KGNhbGxkYXRhKS50by5lcShNT0NLX0VYRUNVVEVfTUVUQV9UUkFOU0FDVElPTl9DQUxMREFUQSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdnZW5lcmF0ZXMgcGVybWl0IGNhbGxkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBtYWtlclRva2VuLmFkZHJlc3M7XG4gICAgICAgICAgICBjb25zdCBhcHByb3ZhbCA9IE1PQ0tfUEVSTUlUX0FQUFJPVkFMO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlOiBTaWduYXR1cmUgPSB7XG4gICAgICAgICAgICAgICAgcjogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgICAgICAgICAgICAgczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgICAgICAgICAgICAgdjogMjgsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlVHlwZTogMixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsZGF0YSA9IGF3YWl0IHJmcUJsb2NrY2hhaW5VdGlscy5nZW5lcmF0ZUFwcHJvdmFsQ2FsbGRhdGFBc3luYyh0b2tlbiwgYXBwcm92YWwsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICBleHBlY3QoY2FsbGRhdGEpLnRvLmVxKE1PQ0tfUEVSTUlUX0NBTExEQVRBKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZXN0aW1hdGVHYXNGb3JBc3luYycsICgpID0+IHtcbiAgICAgICAgaXQoJ3Rocm93cyBleGNlcHRpb24gb24gaW52YWxpZCBjYWxsZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVyYzIwQWJpRGVjaW1hbHMgPSBgW3tcbiAgICAgICAgICAgICAgICBcImNvbnN0YW50XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJpbnB1dHNcIjogW10sXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGVjaW1hbHNcIixcbiAgICAgICAgICAgICAgICBcIm91dHB1dHNcIjogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVpbnQ4XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJwYXlhYmxlXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgIH1dYDtcbiAgICAgICAgICAgIGNvbnN0IGVyYzIwID0gbmV3IENvbnRyYWN0KHRha2VyVG9rZW4uYWRkcmVzcywgZXJjMjBBYmlEZWNpbWFscyk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGNhbGxkYXRhIH0gPSBhd2FpdCBlcmMyMC5wb3B1bGF0ZVRyYW5zYWN0aW9uLmRlY2ltYWxzKCk7XG4gICAgICAgICAgICBpZiAoIWNhbGxkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsZGF0YSBmb3IgZGVjaW1hbHMgc2hvdWxkIG5vdCBiZSB1bmRlZmluZWQgb3IgZW1wdHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGludmFsaWRDYWxsZGF0YSA9IGAke2NhbGxkYXRhLnN1YnN0cmluZygwLCBjYWxsZGF0YS5sZW5ndGggLSAxKX0wYDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZnFCbG9ja2NoYWluVXRpbHMuZXN0aW1hdGVHYXNGb3JBc3luYyh7IHRvOiB0YWtlclRva2VuLmFkZHJlc3MsIGRhdGE6IGludmFsaWRDYWxsZGF0YSB9KTtcbiAgICAgICAgICAgICAgICBleHBlY3QuZmFpbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdChlLm1lc3NhZ2UpLnRvLmNvbnRhaW4oJ2VzdGltYXRlR2FzRm9yQXN5bmMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3N1Y2Nlc3NmdWxseSBlc3RpbWF0ZXMgZ2FzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJjMjBBYmlEZWNpbWFscyA9IGBbe1xuICAgICAgICAgICAgICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImlucHV0c1wiOiBbXSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJkZWNpbWFsc1wiLFxuICAgICAgICAgICAgICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidWludDhcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJ2aWV3XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgfV1gO1xuICAgICAgICAgICAgY29uc3QgZXJjMjAgPSBuZXcgQ29udHJhY3QodGFrZXJUb2tlbi5hZGRyZXNzLCBlcmMyMEFiaURlY2ltYWxzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogY2FsbGRhdGEgfSA9IGF3YWl0IGVyYzIwLnBvcHVsYXRlVHJhbnNhY3Rpb24uZGVjaW1hbHMoKTtcbiAgICAgICAgICAgIGlmICghY2FsbGRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxkYXRhIGZvciBkZWNpbWFscyBzaG91bGQgbm90IGJlIHVuZGVmaW5lZCBvciBlbXB0eScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhd2FpdCByZnFCbG9ja2NoYWluVXRpbHMuZXN0aW1hdGVHYXNGb3JBc3luYyh7IHRvOiB0YWtlclRva2VuLmFkZHJlc3MsIGRhdGE6IGNhbGxkYXRhIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9