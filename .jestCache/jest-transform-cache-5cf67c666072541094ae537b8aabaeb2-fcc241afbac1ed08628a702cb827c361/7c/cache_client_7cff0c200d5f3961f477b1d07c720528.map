{"file":"/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","mappings":"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","names":[],"sources":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts"],"sourcesContent":["import { ZERO } from '@0x/protocol-utils';\nimport { BigNumber } from '@0x/utils';\nimport Redis from 'ioredis';\n\nimport { MAKER_TOKEN_BALANCE_EXPIRY_SECONDS } from '../core/constants';\nimport { ERC20Owner } from '../core/types';\n\nimport { splitAddresses } from './address_utils';\nimport { toPairString } from '../core/pair_utils';\n\nconst OTC_ORDER_NONCE_BUCKET_COUNTER_KEY = (chainId: number) => `otcorder.nonce.bucket.counter.chain.${chainId}`;\n// The value stored at this key is a set. The members of this set are each an ERC20_OWNER_BALANCE_KEY.\nconst ERC20_OWNERS_KEY = (chainId: number) => `erc20.owners.chain.${chainId}`;\nconst ERC20_OWNER_BALANCE_KEY = (chainId: number, ownerAddress: string, tokenAddress: string) =>\n    `erc20.owner.balance.chain.${chainId}.${ownerAddress}.${tokenAddress}`;\n// Use `chainId` and pair keys as Redis keys for sorted set entries, used for cooling down makers after bad last look rejection.\nconst LLR_COOLDOWN_SET_KEY = (chainId: number, tokenA: string, tokenB: string) =>\n    `coolingdown.makers.chain.${chainId}.pair.${toPairString(tokenA, tokenB)}`;\n\nexport class CacheClient {\n    constructor(private readonly _redis: Redis) {}\n\n    // Shut down the CacheClient safely\n    public async closeAsync(): Promise<'OK'> {\n        return this._redis.quit();\n    }\n\n    // Get the next OtcOrder Bucket\n    // NOTE: unliklely to ever hit this, but the node library we use tries to cast the response from Redis as a number.\n    // However, MAX_INT for js is lower than MAX_INT for Redis. We also need to be aware of if Redis' MAX_INT ever gets hit (error)\n    public async getNextOtcOrderBucketAsync(chainId: number): Promise<number> {\n        return this._redis.incr(OTC_ORDER_NONCE_BUCKET_COUNTER_KEY(chainId));\n    }\n\n    // Advance the current OtcOrder bucket by N buckets\n    // NOTE: unliklely to ever hit this, but the node library we use tries to cast the response from Redis as a number.\n    // However, MAX_INT for js is lower than MAX_INT for Redis. We also need to be aware of if Redis' MAX_INT ever gets hit (error)\n    public async getNextNOtcOrderBucketsAsync(chainId: number, n: number): Promise<number> {\n        return this._redis.incrby(OTC_ORDER_NONCE_BUCKET_COUNTER_KEY(chainId), n);\n    }\n\n    /**\n     * Fetches all maker token addresses to be updated.\n     * Token addresses set stores unique erc20Owners as balance cache keys.\n     */\n    public async getERC20OwnersAsync(chainId: number): Promise<ERC20Owner[]> {\n        const cacheKeys = await this._redis.smembers(ERC20_OWNERS_KEY(chainId));\n        // parse cache keys into ERC20Owner objects\n        // cache key follows the format of `prefix.${chainId}.${owner}.${token}`\n        return cacheKeys.map((cacheKey) => {\n            const addresses = cacheKey.split('.');\n            return {\n                owner: addresses[addresses.length - 2],\n                token: addresses[addresses.length - 1],\n            };\n        });\n    }\n\n    /**\n     * Adds a newly observed erc20Owner to the set of known maker tokens.\n     * The values in this set are keys used to retrieve the maker's balance.\n     * They are iterated upon in the next maker balance cache update.\n     */\n    public async addERC20OwnerAsync(chainId: number, erc20Owner: ERC20Owner): Promise<void> {\n        const { owners, tokens } = splitAddresses(erc20Owner);\n        await this._redis.sadd(ERC20_OWNERS_KEY(chainId), ERC20_OWNER_BALANCE_KEY(chainId, owners[0], tokens[0]));\n    }\n\n    /**\n     * Evicts maker token addresses with zero balances from the cache.\n     * We assume that market makers no longer supply liquidity for tokens with zero balances.\n     */\n    public async evictZeroBalancesAsync(chainId: number): Promise<number> {\n        const setKey = ERC20_OWNERS_KEY(chainId);\n        const cacheKeys = await this._redis.smembers(setKey);\n        if (cacheKeys.length === 0) {\n            return 0;\n        }\n        const balances = await this._redis.mget(cacheKeys);\n        const evictedKeys = cacheKeys.filter((_, idx) => {\n            const balance = balances[idx];\n            return balance != null && ZERO.eq(new BigNumber(balance));\n        });\n        if (evictedKeys.length === 0) {\n            return 0;\n        }\n        return this._redis.srem(setKey, evictedKeys);\n    }\n\n    /**\n     * Gets maker balances for provided erc20Owners from the cache.\n     * A cache miss will result in a null value, and otherwise a valid BigNumber.\n     * Throws an error if invalid addresses are passed.\n     * Each GET is a fast O(1) read request to the cache.\n     */\n    public async getERC20OwnerBalancesAsync(chainId: number, erc20Owners: ERC20Owner[]): Promise<(BigNumber | null)[]> {\n        const cacheKeys = this._validateAndGetBalanceCacheKeys(chainId, erc20Owners);\n        // Redis mGet only accepts non-empty arrays\n        // if erc20Owners is empty, balances should be empty as well\n        if (cacheKeys.length === 0) {\n            return [];\n        }\n        const balances = await this._redis.mget(cacheKeys);\n        return balances.map((balance) => (balance ? new BigNumber(balance) : null));\n    }\n\n    /**\n     * Sets and/or updates maker balances for provided maker and token addresses.\n     * Refreshes cache entry expiries to two minutes from now.\n     * Throws an error if invalid addresses or balances are passed.\n     * Each SET is a fast O(1) write request to the cache.\n     */\n    public async setERC20OwnerBalancesAsync(\n        chainId: number,\n        erc20Owners: ERC20Owner[],\n        balances: BigNumber[],\n    ): Promise<void> {\n        const cacheKeys = this._validateAndGetBalanceCacheKeys(chainId, erc20Owners, balances);\n        await Promise.all(\n            cacheKeys.map(async (cacheKey, i) =>\n                this._redis.set(cacheKey, balances[i].toString(), 'EX', MAKER_TOKEN_BALANCE_EXPIRY_SECONDS),\n            ),\n        );\n    }\n\n    /**\n     * Add maker to cooldown sorted set of given pair. Maker Ids in the sorted set are sorted by\n     * cooldown period endTime, so as to allow quickly filter out these with expired cooldown period.\n     *\n     * @param makerId ID of maker to be added or updated\n     * @param endTime time stamp to end the cooldown period, in millisecond\n     * @param chainId chainId of the pair\n     * @param tokenA address of one trading token\n     * @param tokenB address of the other trading token\n     * @returns whether the sorted set get updated\n     */\n    public async addMakerToCooldownAsync(\n        makerId: string,\n        endTime: number,\n        chainId: number,\n        tokenA: string,\n        tokenB: string,\n    ): Promise<boolean> {\n        const changedMemberCount = await this._redis.zadd(\n            LLR_COOLDOWN_SET_KEY(chainId, tokenA, tokenB),\n            'GT', // only update if setting a higher score\n            'CH', // return number of set members get changed (added and updated)\n            endTime, // score to be sorted by\n            makerId, // value of the entry\n        );\n        return changedMemberCount > 0;\n    }\n\n    /**\n     * Get a list of makers that are cooling down for given pair. Only includes unexpired entries.\n     *\n     * @param chainId chainId of the pair\n     * @param tokenA address of one trading token\n     * @param tokenB address of the other trading token\n     * @param now current timestamp (for testing)\n     * @returns array of maker IDs\n     */\n    public async getMakersInCooldownForPairAsync(\n        chainId: number,\n        tokenA: string,\n        tokenB: string,\n        now: number = Date.now(),\n    ): Promise<string[]> {\n        // Sorted set members use cooldown expiration time as scores, so selecting members with scores larger than `Date.now()`\n        // will give a complete list of makers in cooldown.\n        const minScore = now;\n        const maxScore = '+inf';\n        return this._redis.zrangebyscore(LLR_COOLDOWN_SET_KEY(chainId, tokenA, tokenB), minScore, maxScore);\n    }\n\n    /**\n     * Validates maker and token addresses.\n     * If balances are passed, validates that every cache key has a corresponding value.\n     * Generates a cache key for every pair through string concatenation.\n     */\n    // tslint:disable-next-line: prefer-function-over-method\n    private _validateAndGetBalanceCacheKeys(\n        chainId: number,\n        erc20Owners: ERC20Owner[],\n        balances?: BigNumber[],\n    ): string[] {\n        if (balances && erc20Owners.length !== balances.length) {\n            throw new Error('Maker addresses do not match balances');\n        }\n        const { owners, tokens } = splitAddresses(erc20Owners);\n        return owners.map((owner, i) => {\n            return ERC20_OWNER_BALANCE_KEY(chainId, owner, tokens[i]);\n        });\n    }\n}\n"],"version":3}