91c502573025eabf1b3b86ff15b57ee7
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheClient = void 0;
const protocol_utils_1 = require("@0x/protocol-utils");
const utils_1 = require("@0x/utils");
const constants_1 = require("../core/constants");
const address_utils_1 = require("./address_utils");
const pair_utils_1 = require("../core/pair_utils");
const OTC_ORDER_NONCE_BUCKET_COUNTER_KEY = (chainId) => `otcorder.nonce.bucket.counter.chain.${chainId}`;
// The value stored at this key is a set. The members of this set are each an ERC20_OWNER_BALANCE_KEY.
const ERC20_OWNERS_KEY = (chainId) => `erc20.owners.chain.${chainId}`;
const ERC20_OWNER_BALANCE_KEY = (chainId, ownerAddress, tokenAddress) => `erc20.owner.balance.chain.${chainId}.${ownerAddress}.${tokenAddress}`;
// Use `chainId` and pair keys as Redis keys for sorted set entries, used for cooling down makers after bad last look rejection.
const LLR_COOLDOWN_SET_KEY = (chainId, tokenA, tokenB) => `coolingdown.makers.chain.${chainId}.pair.${(0, pair_utils_1.toPairString)(tokenA, tokenB)}`;
class CacheClient {
    constructor(_redis) {
        this._redis = _redis;
    }
    // Shut down the CacheClient safely
    async closeAsync() {
        return this._redis.quit();
    }
    // Get the next OtcOrder Bucket
    // NOTE: unliklely to ever hit this, but the node library we use tries to cast the response from Redis as a number.
    // However, MAX_INT for js is lower than MAX_INT for Redis. We also need to be aware of if Redis' MAX_INT ever gets hit (error)
    async getNextOtcOrderBucketAsync(chainId) {
        return this._redis.incr(OTC_ORDER_NONCE_BUCKET_COUNTER_KEY(chainId));
    }
    // Advance the current OtcOrder bucket by N buckets
    // NOTE: unliklely to ever hit this, but the node library we use tries to cast the response from Redis as a number.
    // However, MAX_INT for js is lower than MAX_INT for Redis. We also need to be aware of if Redis' MAX_INT ever gets hit (error)
    async getNextNOtcOrderBucketsAsync(chainId, n) {
        return this._redis.incrby(OTC_ORDER_NONCE_BUCKET_COUNTER_KEY(chainId), n);
    }
    /**
     * Fetches all maker token addresses to be updated.
     * Token addresses set stores unique erc20Owners as balance cache keys.
     */
    async getERC20OwnersAsync(chainId) {
        const cacheKeys = await this._redis.smembers(ERC20_OWNERS_KEY(chainId));
        // parse cache keys into ERC20Owner objects
        // cache key follows the format of `prefix.${chainId}.${owner}.${token}`
        return cacheKeys.map((cacheKey) => {
            const addresses = cacheKey.split('.');
            return {
                owner: addresses[addresses.length - 2],
                token: addresses[addresses.length - 1],
            };
        });
    }
    /**
     * Adds a newly observed erc20Owner to the set of known maker tokens.
     * The values in this set are keys used to retrieve the maker's balance.
     * They are iterated upon in the next maker balance cache update.
     */
    async addERC20OwnerAsync(chainId, erc20Owner) {
        const { owners, tokens } = (0, address_utils_1.splitAddresses)(erc20Owner);
        await this._redis.sadd(ERC20_OWNERS_KEY(chainId), ERC20_OWNER_BALANCE_KEY(chainId, owners[0], tokens[0]));
    }
    /**
     * Evicts maker token addresses with zero balances from the cache.
     * We assume that market makers no longer supply liquidity for tokens with zero balances.
     */
    async evictZeroBalancesAsync(chainId) {
        const setKey = ERC20_OWNERS_KEY(chainId);
        const cacheKeys = await this._redis.smembers(setKey);
        if (cacheKeys.length === 0) {
            return 0;
        }
        const balances = await this._redis.mget(cacheKeys);
        const evictedKeys = cacheKeys.filter((_, idx) => {
            const balance = balances[idx];
            return balance != null && protocol_utils_1.ZERO.eq(new utils_1.BigNumber(balance));
        });
        if (evictedKeys.length === 0) {
            return 0;
        }
        return this._redis.srem(setKey, evictedKeys);
    }
    /**
     * Gets maker balances for provided erc20Owners from the cache.
     * A cache miss will result in a null value, and otherwise a valid BigNumber.
     * Throws an error if invalid addresses are passed.
     * Each GET is a fast O(1) read request to the cache.
     */
    async getERC20OwnerBalancesAsync(chainId, erc20Owners) {
        const cacheKeys = this._validateAndGetBalanceCacheKeys(chainId, erc20Owners);
        // Redis mGet only accepts non-empty arrays
        // if erc20Owners is empty, balances should be empty as well
        if (cacheKeys.length === 0) {
            return [];
        }
        const balances = await this._redis.mget(cacheKeys);
        return balances.map((balance) => (balance ? new utils_1.BigNumber(balance) : null));
    }
    /**
     * Sets and/or updates maker balances for provided maker and token addresses.
     * Refreshes cache entry expiries to two minutes from now.
     * Throws an error if invalid addresses or balances are passed.
     * Each SET is a fast O(1) write request to the cache.
     */
    async setERC20OwnerBalancesAsync(chainId, erc20Owners, balances) {
        const cacheKeys = this._validateAndGetBalanceCacheKeys(chainId, erc20Owners, balances);
        await Promise.all(cacheKeys.map(async (cacheKey, i) => this._redis.set(cacheKey, balances[i].toString(), 'EX', constants_1.MAKER_TOKEN_BALANCE_EXPIRY_SECONDS)));
    }
    /**
     * Add maker to cooldown sorted set of given pair. Maker Ids in the sorted set are sorted by
     * cooldown period endTime, so as to allow quickly filter out these with expired cooldown period.
     *
     * @param makerId ID of maker to be added or updated
     * @param endTime time stamp to end the cooldown period, in millisecond
     * @param chainId chainId of the pair
     * @param tokenA address of one trading token
     * @param tokenB address of the other trading token
     * @returns whether the sorted set get updated
     */
    async addMakerToCooldownAsync(makerId, endTime, chainId, tokenA, tokenB) {
        const changedMemberCount = await this._redis.zadd(LLR_COOLDOWN_SET_KEY(chainId, tokenA, tokenB), 'GT', // only update if setting a higher score
        'CH', // return number of set members get changed (added and updated)
        endTime, // score to be sorted by
        makerId);
        return changedMemberCount > 0;
    }
    /**
     * Get a list of makers that are cooling down for given pair. Only includes unexpired entries.
     *
     * @param chainId chainId of the pair
     * @param tokenA address of one trading token
     * @param tokenB address of the other trading token
     * @param now current timestamp (for testing)
     * @returns array of maker IDs
     */
    async getMakersInCooldownForPairAsync(chainId, tokenA, tokenB, now = Date.now()) {
        // Sorted set members use cooldown expiration time as scores, so selecting members with scores larger than `Date.now()`
        // will give a complete list of makers in cooldown.
        const minScore = now;
        const maxScore = '+inf';
        return this._redis.zrangebyscore(LLR_COOLDOWN_SET_KEY(chainId, tokenA, tokenB), minScore, maxScore);
    }
    /**
     * Validates maker and token addresses.
     * If balances are passed, validates that every cache key has a corresponding value.
     * Generates a cache key for every pair through string concatenation.
     */
    // tslint:disable-next-line: prefer-function-over-method
    _validateAndGetBalanceCacheKeys(chainId, erc20Owners, balances) {
        if (balances && erc20Owners.length !== balances.length) {
            throw new Error('Maker addresses do not match balances');
        }
        const { owners, tokens } = (0, address_utils_1.splitAddresses)(erc20Owners);
        return owners.map((owner, i) => {
            return ERC20_OWNER_BALANCE_KEY(chainId, owner, tokens[i]);
        });
    }
}
exports.CacheClient = CacheClient;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy91dGlscy9jYWNoZV9jbGllbnQudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEsdURBQTBDO0FBQzFDLHFDQUFzQztBQUd0QyxpREFBdUU7QUFHdkUsbURBQWlEO0FBQ2pELG1EQUFrRDtBQUVsRCxNQUFNLGtDQUFrQyxHQUFHLENBQUMsT0FBZSxFQUFFLEVBQUUsQ0FBQyx1Q0FBdUMsT0FBTyxFQUFFLENBQUM7QUFDakgsc0dBQXNHO0FBQ3RHLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxPQUFlLEVBQUUsRUFBRSxDQUFDLHNCQUFzQixPQUFPLEVBQUUsQ0FBQztBQUM5RSxNQUFNLHVCQUF1QixHQUFHLENBQUMsT0FBZSxFQUFFLFlBQW9CLEVBQUUsWUFBb0IsRUFBRSxFQUFFLENBQzVGLDZCQUE2QixPQUFPLElBQUksWUFBWSxJQUFJLFlBQVksRUFBRSxDQUFDO0FBQzNFLGdJQUFnSTtBQUNoSSxNQUFNLG9CQUFvQixHQUFHLENBQUMsT0FBZSxFQUFFLE1BQWMsRUFBRSxNQUFjLEVBQUUsRUFBRSxDQUM3RSw0QkFBNEIsT0FBTyxTQUFTLElBQUEseUJBQVksRUFBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQztBQUUvRSxNQUFhLFdBQVc7SUFDcEIsWUFBNkIsTUFBYTtRQUFiLFdBQU0sR0FBTixNQUFNLENBQU87SUFBRyxDQUFDO0lBRTlDLG1DQUFtQztJQUM1QixLQUFLLENBQUMsVUFBVTtRQUNuQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDOUIsQ0FBQztJQUVELCtCQUErQjtJQUMvQixtSEFBbUg7SUFDbkgsK0hBQStIO0lBQ3hILEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxPQUFlO1FBQ25ELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsa0NBQWtDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBRUQsbURBQW1EO0lBQ25ELG1I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QUssQ0FBQywrQkFBK0IsQ0FDeEMsT0FBZSxFQUNmLE1BQWMsRUFDZCxNQUFjLEVBQ2QsTUFBYyxJQUFJLENBQUMsR0FBRyxFQUFFO1FBRXhCLHVIQUF1SDtRQUN2SCxtREFBbUQ7UUFDbkQsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDO1FBQ3JCLE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQztRQUN4QixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLG9CQUFvQixDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3hHLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsd0RBQXdEO0lBQ2hELCtCQUErQixDQUNuQyxPQUFlLEVBQ2YsV0FBeUIsRUFDekIsUUFBc0I7UUFFdEIsSUFBSSxRQUFRLElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsTUFBTSxFQUFFO1lBQ3BELE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXVDLENBQUMsQ0FBQztTQUM1RDtRQUNELE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsSUFBQSw4QkFBYyxFQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3ZELE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMzQixPQUFPLHVCQUF1QixDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDOUQsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0NBQ0o7QUEvS0Qsa0NBK0tDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXZpZHdhbHNoL2NvZGUtbG9jYWwvMHgtcmZxLWFwaS9zcmMvdXRpbHMvY2FjaGVfY2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFpFUk8gfSBmcm9tICdAMHgvcHJvdG9jb2wtdXRpbHMnO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnQDB4L3V0aWxzJztcbmltcG9ydCBSZWRpcyBmcm9tICdpb3JlZGlzJztcblxuaW1wb3J0IHsgTUFLRVJfVE9LRU5fQkFMQU5DRV9FWFBJUllfU0VDT05EUyB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzJztcbmltcG9ydCB7IEVSQzIwT3duZXIgfSBmcm9tICcuLi9jb3JlL3R5cGVzJztcblxuaW1wb3J0IHsgc3BsaXRBZGRyZXNzZXMgfSBmcm9tICcuL2FkZHJlc3NfdXRpbHMnO1xuaW1wb3J0IHsgdG9QYWlyU3RyaW5nIH0gZnJvbSAnLi4vY29yZS9wYWlyX3V0aWxzJztcblxuY29uc3QgT1RDX09SREVSX05PTkNFX0JVQ0tFVF9DT1VOVEVSX0tFWSA9IChjaGFpbklkOiBudW1iZXIpID0+IGBvdGNvcmRlci5ub25jZS5idWNrZXQuY291bnRlci5jaGFpbi4ke2NoYWluSWR9YDtcbi8vIFRoZSB2YWx1ZSBzdG9yZWQgYXQgdGhpcyBrZXkgaXMgYSBzZXQuIFRoZSBtZW1iZXJzIG9mIHRoaXMgc2V0IGFyZSBlYWNoIGFuIEVSQzIwX09XTkVSX0JBTEFOQ0VfS0VZLlxuY29uc3QgRVJDMjBfT1dORVJTX0tFWSA9IChjaGFpbklkOiBudW1iZXIpID0+IGBlcmMyMC5vd25lcnMuY2hhaW4uJHtjaGFpbklkfWA7XG5jb25zdCBFUkMyMF9PV05FUl9CQUxBTkNFX0tFWSA9IChjaGFpbklkOiBudW1iZXIsIG93bmVyQWRkcmVzczogc3RyaW5nLCB0b2tlbkFkZHJlc3M6IHN0cmluZykgPT5cbiAgICBgZXJjMjAub3duZXIuYmFsYW5jZS5jaGFpbi4ke2NoYWluSWR9LiR7b3duZXJBZGRyZXNzfS4ke3Rva2VuQWRkcmVzc31gO1xuLy8gVXNlIGBjaGFpbklkYCBhbmQgcGFpciBrZXlzIGFzIFJlZGlzIGtleXMgZm9yIHNvcnRlZCBzZXQgZW50cmllcywgdXNlZCBmb3IgY29vbGluZyBkb3duIG1ha2VycyBhZnRlciBiYWQgbGFzdCBsb29rIHJlamVjdGlvbi5cbmNvbnN0IExMUl9DT09MRE9XTl9TRVRfS0VZID0gKGNoYWluSWQ6IG51bWJlciwgdG9rZW5BOiBzdHJpbmcsIHRva2VuQjogc3RyaW5nKSA9PlxuICAgIGBjb29saW5nZG93bi5tYWtlcnMuY2hhaW4uJHtjaGFpbklkfS5wYWlyLiR7dG9QYWlyU3RyaW5nKHRva2VuQSwgdG9rZW5CKX1gO1xuXG5leHBvcnQgY2xhc3MgQ2FjaGVDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgX3JlZGlzOiBSZWRpcykge31cblxuICAgIC8vIFNodXQgZG93biB0aGUgQ2FjaGVDbGllbnQgc2FmZWx5XG4gICAgcHVibGljIGFzeW5jIGNsb3NlQXN5bmMoKTogUHJvbWlzZTwnT0snPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWRpcy5xdWl0KCk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBuZXh0IE90Y09yZGVyIEJ1Y2tldFxuICAgIC8vIE5PVEU6IHVubGlrbGVseSB0byBldmVyIGhpdCB0aGlzLCBidXQgdGhlIG5vZGUgbGlicmFyeSB3ZSB1c2UgdHJpZXMgdG8gY2FzdCB0aGUgcmVzcG9uc2UgZnJvbSBSZWRpcyBhcyBhIG51bWJlci5cbiAgICAvLyBIb3dldmVyLCBNQVhfSU5UIGZvciBqcyBpcyBsb3dlciB0aGFuIE1BWF9JTlQgZm9yIFJlZGlzLiBXZSBhbHNvIG5lZWQgdG8gYmUgYXdhcmUgb2YgaWYgUmVkaXMnIE1BWF9JTlQgZXZlciBnZXRzIGhpdCAoZXJyb3IpXG4gICAgcHVibGljIGFzeW5jIGdldE5leHRPdGNPcmRlckJ1Y2tldEFzeW5jKGNoYWluSWQ6IG51bWJlcik6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWRpcy5pbmNyKE9UQ19PUkRFUl9OT05DRV9CVUNLRVRfQ09VTlRFUl9LRVkoY2hhaW5JZCkpO1xuICAgIH1cblxuICAgIC8vIEFkdmFuY2UgdGhlIGN1cnJlbnQgT3RjT3JkZXIgYnVja2V0IGJ5IE4gYnVja2V0c1xuICAgIC8vIE5PVEU6IHVubGlrbGVseSB0byBldmVyIGhpdCB0aGlzLCBidXQgdGhlIG5vZGUgbGlicmFyeSB3ZSB1c2UgdHJpZXMgdG8gY2FzdCB0aGUgcmVzcG9uc2UgZnJvbSBSZWRpcyBhcyBhIG51bWJlci5cbiAgICAvLyBIb3dldmVyLCBNQVhfSU5UIGZvciBqcyBpcyBsb3dlciB0aGFuIE1BWF9JTlQgZm9yIFJlZGlzLiBXZSBhbHNvIG5lZWQgdG8gYmUgYXdhcmUgb2YgaWYgUmVkaXMnIE1BWF9JTlQgZXZlciBnZXRzIGhpdCAoZXJyb3IpXG4gICAgcHVibGljIGFzeW5jIGdldE5leHROT3RjT3JkZXJCdWNrZXRzQXN5bmMoY2hhaW5JZDogbnVtYmVyLCBuOiBudW1iZXIpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkaXMuaW5jcmJ5KE9UQ19PUkRFUl9OT05DRV9CVUNLRVRfQ09VTlRFUl9LRVkoY2hhaW5JZCksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYWxsIG1ha2VyIHRva2VuIGFkZHJlc3NlcyB0byBiZSB1cGRhdGVkLlxuICAgICAqIFRva2VuIGFkZHJlc3NlcyBzZXQgc3RvcmVzIHVuaXF1ZSBlcmMyME93bmVycyBhcyBiYWxhbmNlIGNhY2hlIGtleXMuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGdldEVSQzIwT3duZXJzQXN5bmMoY2hhaW5JZDogbnVtYmVyKTogUHJvbWlzZTxFUkMyME93bmVyW10+IHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXlzID0gYXdhaXQgdGhpcy5fcmVkaXMuc21lbWJlcnMoRVJDMjBfT1dORVJTX0tFWShjaGFpbklkKSk7XG4gICAgICAgIC8vIHBhcnNlIGNhY2hlIGtleXMgaW50byBFUkMyME93bmVyIG9iamVjdHNcbiAgICAgICAgLy8gY2FjaGUga2V5IGZvbGxvd3MgdGhlIGZvcm1hdCBvZiBgcHJlZml4LiR7Y2hhaW5JZH0uJHtvd25lcn0uJHt0b2tlbn1gXG4gICAgICAgIHJldHVybiBjYWNoZUtleXMubWFwKChjYWNoZUtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gY2FjaGVLZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3duZXI6IGFkZHJlc3Nlc1thZGRyZXNzZXMubGVuZ3RoIC0gMl0sXG4gICAgICAgICAgICAgICAgdG9rZW46IGFkZHJlc3Nlc1thZGRyZXNzZXMubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3bHkgb2JzZXJ2ZWQgZXJjMjBPd25lciB0byB0aGUgc2V0IG9mIGtub3duIG1ha2VyIHRva2Vucy5cbiAgICAgKiBUaGUgdmFsdWVzIGluIHRoaXMgc2V0IGFyZSBrZXlzIHVzZWQgdG8gcmV0cmlldmUgdGhlIG1ha2VyJ3MgYmFsYW5jZS5cbiAgICAgKiBUaGV5IGFyZSBpdGVyYXRlZCB1cG9uIGluIHRoZSBuZXh0IG1ha2VyIGJhbGFuY2UgY2FjaGUgdXBkYXRlLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBhZGRFUkMyME93bmVyQXN5bmMoY2hhaW5JZDogbnVtYmVyLCBlcmMyME93bmVyOiBFUkMyME93bmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHsgb3duZXJzLCB0b2tlbnMgfSA9IHNwbGl0QWRkcmVzc2VzKGVyYzIwT3duZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9yZWRpcy5zYWRkKEVSQzIwX09XTkVSU19LRVkoY2hhaW5JZCksIEVSQzIwX09XTkVSX0JBTEFOQ0VfS0VZKGNoYWluSWQsIG93bmVyc1swXSwgdG9rZW5zWzBdKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZpY3RzIG1ha2VyIHRva2VuIGFkZHJlc3NlcyB3aXRoIHplcm8gYmFsYW5jZXMgZnJvbSB0aGUgY2FjaGUuXG4gICAgICogV2UgYXNzdW1lIHRoYXQgbWFya2V0IG1ha2VycyBubyBsb25nZXIgc3VwcGx5IGxpcXVpZGl0eSBmb3IgdG9rZW5zIHdpdGggemVybyBiYWxhbmNlcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZXZpY3RaZXJvQmFsYW5jZXNBc3luYyhjaGFpbklkOiBudW1iZXIpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgICAgICBjb25zdCBzZXRLZXkgPSBFUkMyMF9PV05FUlNfS0VZKGNoYWluSWQpO1xuICAgICAgICBjb25zdCBjYWNoZUtleXMgPSBhd2FpdCB0aGlzLl9yZWRpcy5zbWVtYmVycyhzZXRLZXkpO1xuICAgICAgICBpZiAoY2FjaGVLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLl9yZWRpcy5tZ2V0KGNhY2hlS2V5cyk7XG4gICAgICAgIGNvbnN0IGV2aWN0ZWRLZXlzID0gY2FjaGVLZXlzLmZpbHRlcigoXywgaWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYmFsYW5jZXNbaWR4XTtcbiAgICAgICAgICAgIHJldHVybiBiYWxhbmNlICE9IG51bGwgJiYgWkVSTy5lcShuZXcgQmlnTnVtYmVyKGJhbGFuY2UpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChldmljdGVkS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWRpcy5zcmVtKHNldEtleSwgZXZpY3RlZEtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWFrZXIgYmFsYW5jZXMgZm9yIHByb3ZpZGVkIGVyYzIwT3duZXJzIGZyb20gdGhlIGNhY2hlLlxuICAgICAqIEEgY2FjaGUgbWlzcyB3aWxsIHJlc3VsdCBpbiBhIG51bGwgdmFsdWUsIGFuZCBvdGhlcndpc2UgYSB2YWxpZCBCaWdOdW1iZXIuXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIGludmFsaWQgYWRkcmVzc2VzIGFyZSBwYXNzZWQuXG4gICAgICogRWFjaCBHRVQgaXMgYSBmYXN0IE8oMSkgcmVhZCByZXF1ZXN0IHRvIHRoZSBjYWNoZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmMoY2hhaW5JZDogbnVtYmVyLCBlcmMyME93bmVyczogRVJDMjBPd25lcltdKTogUHJvbWlzZTwoQmlnTnVtYmVyIHwgbnVsbClbXT4ge1xuICAgICAgICBjb25zdCBjYWNoZUtleXMgPSB0aGlzLl92YWxpZGF0ZUFuZEdldEJhbGFuY2VDYWNoZUtleXMoY2hhaW5JZCwgZXJjMjBPd25lcnMpO1xuICAgICAgICAvLyBSZWRpcyBtR2V0IG9ubHkgYWNjZXB0cyBub24tZW1wdHkgYXJyYXlzXG4gICAgICAgIC8vIGlmIGVyYzIwT3duZXJzIGlzIGVtcHR5LCBiYWxhbmNlcyBzaG91bGQgYmUgZW1wdHkgYXMgd2VsbFxuICAgICAgICBpZiAoY2FjaGVLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5fcmVkaXMubWdldChjYWNoZUtleXMpO1xuICAgICAgICByZXR1cm4gYmFsYW5jZXMubWFwKChiYWxhbmNlKSA9PiAoYmFsYW5jZSA/IG5ldyBCaWdOdW1iZXIoYmFsYW5jZSkgOiBudWxsKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhbmQvb3IgdXBkYXRlcyBtYWtlciBiYWxhbmNlcyBmb3IgcHJvdmlkZWQgbWFrZXIgYW5kIHRva2VuIGFkZHJlc3Nlcy5cbiAgICAgKiBSZWZyZXNoZXMgY2FjaGUgZW50cnkgZXhwaXJpZXMgdG8gdHdvIG1pbnV0ZXMgZnJvbSBub3cuXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIGludmFsaWQgYWRkcmVzc2VzIG9yIGJhbGFuY2VzIGFyZSBwYXNzZWQuXG4gICAgICogRWFjaCBTRVQgaXMgYSBmYXN0IE8oMSkgd3JpdGUgcmVxdWVzdCB0byB0aGUgY2FjaGUuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIHNldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKFxuICAgICAgICBjaGFpbklkOiBudW1iZXIsXG4gICAgICAgIGVyYzIwT3duZXJzOiBFUkMyME93bmVyW10sXG4gICAgICAgIGJhbGFuY2VzOiBCaWdOdW1iZXJbXSxcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXlzID0gdGhpcy5fdmFsaWRhdGVBbmRHZXRCYWxhbmNlQ2FjaGVLZXlzKGNoYWluSWQsIGVyYzIwT3duZXJzLCBiYWxhbmNlcyk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgY2FjaGVLZXlzLm1hcChhc3luYyAoY2FjaGVLZXksIGkpID0+XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVkaXMuc2V0KGNhY2hlS2V5LCBiYWxhbmNlc1tpXS50b1N0cmluZygpLCAnRVgnLCBNQUtFUl9UT0tFTl9CQUxBTkNFX0VYUElSWV9TRUNPTkRTKSxcbiAgICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIG1ha2VyIHRvIGNvb2xkb3duIHNvcnRlZCBzZXQgb2YgZ2l2ZW4gcGFpci4gTWFrZXIgSWRzIGluIHRoZSBzb3J0ZWQgc2V0IGFyZSBzb3J0ZWQgYnlcbiAgICAgKiBjb29sZG93biBwZXJpb2QgZW5kVGltZSwgc28gYXMgdG8gYWxsb3cgcXVpY2tseSBmaWx0ZXIgb3V0IHRoZXNlIHdpdGggZXhwaXJlZCBjb29sZG93biBwZXJpb2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFrZXJJZCBJRCBvZiBtYWtlciB0byBiZSBhZGRlZCBvciB1cGRhdGVkXG4gICAgICogQHBhcmFtIGVuZFRpbWUgdGltZSBzdGFtcCB0byBlbmQgdGhlIGNvb2xkb3duIHBlcmlvZCwgaW4gbWlsbGlzZWNvbmRcbiAgICAgKiBAcGFyYW0gY2hhaW5JZCBjaGFpbklkIG9mIHRoZSBwYWlyXG4gICAgICogQHBhcmFtIHRva2VuQSBhZGRyZXNzIG9mIG9uZSB0cmFkaW5nIHRva2VuXG4gICAgICogQHBhcmFtIHRva2VuQiBhZGRyZXNzIG9mIHRoZSBvdGhlciB0cmFkaW5nIHRva2VuXG4gICAgICogQHJldHVybnMgd2hldGhlciB0aGUgc29ydGVkIHNldCBnZXQgdXBkYXRlZFxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBhZGRNYWtlclRvQ29vbGRvd25Bc3luYyhcbiAgICAgICAgbWFrZXJJZDogc3RyaW5nLFxuICAgICAgICBlbmRUaW1lOiBudW1iZXIsXG4gICAgICAgIGNoYWluSWQ6IG51bWJlcixcbiAgICAgICAgdG9rZW5BOiBzdHJpbmcsXG4gICAgICAgIHRva2VuQjogc3RyaW5nLFxuICAgICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCBjaGFuZ2VkTWVtYmVyQ291bnQgPSBhd2FpdCB0aGlzLl9yZWRpcy56YWRkKFxuICAgICAgICAgICAgTExSX0NPT0xET1dOX1NFVF9LRVkoY2hhaW5JZCwgdG9rZW5BLCB0b2tlbkIpLFxuICAgICAgICAgICAgJ0dUJywgLy8gb25seSB1cGRhdGUgaWYgc2V0dGluZyBhIGhpZ2hlciBzY29yZVxuICAgICAgICAgICAgJ0NIJywgLy8gcmV0dXJuIG51bWJlciBvZiBzZXQgbWVtYmVycyBnZXQgY2hhbmdlZCAoYWRkZWQgYW5kIHVwZGF0ZWQpXG4gICAgICAgICAgICBlbmRUaW1lLCAvLyBzY29yZSB0byBiZSBzb3J0ZWQgYnlcbiAgICAgICAgICAgIG1ha2VySWQsIC8vIHZhbHVlIG9mIHRoZSBlbnRyeVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gY2hhbmdlZE1lbWJlckNvdW50ID4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsaXN0IG9mIG1ha2VycyB0aGF0IGFyZSBjb29saW5nIGRvd24gZm9yIGdpdmVuIHBhaXIuIE9ubHkgaW5jbHVkZXMgdW5leHBpcmVkIGVudHJpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhaW5JZCBjaGFpbklkIG9mIHRoZSBwYWlyXG4gICAgICogQHBhcmFtIHRva2VuQSBhZGRyZXNzIG9mIG9uZSB0cmFkaW5nIHRva2VuXG4gICAgICogQHBhcmFtIHRva2VuQiBhZGRyZXNzIG9mIHRoZSBvdGhlciB0cmFkaW5nIHRva2VuXG4gICAgICogQHBhcmFtIG5vdyBjdXJyZW50IHRpbWVzdGFtcCAoZm9yIHRlc3RpbmcpXG4gICAgICogQHJldHVybnMgYXJyYXkgb2YgbWFrZXIgSURzXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGdldE1ha2Vyc0luQ29vbGRvd25Gb3JQYWlyQXN5bmMoXG4gICAgICAgIGNoYWluSWQ6IG51bWJlcixcbiAgICAgICAgdG9rZW5BOiBzdHJpbmcsXG4gICAgICAgIHRva2VuQjogc3RyaW5nLFxuICAgICAgICBub3c6IG51bWJlciA9IERhdGUubm93KCksXG4gICAgKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICAvLyBTb3J0ZWQgc2V0IG1lbWJlcnMgdXNlIGNvb2xkb3duIGV4cGlyYXRpb24gdGltZSBhcyBzY29yZXMsIHNvIHNlbGVjdGluZyBtZW1iZXJzIHdpdGggc2NvcmVzIGxhcmdlciB0aGFuIGBEYXRlLm5vdygpYFxuICAgICAgICAvLyB3aWxsIGdpdmUgYSBjb21wbGV0ZSBsaXN0IG9mIG1ha2VycyBpbiBjb29sZG93bi5cbiAgICAgICAgY29uc3QgbWluU2NvcmUgPSBub3c7XG4gICAgICAgIGNvbnN0IG1heFNjb3JlID0gJytpbmYnO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkaXMuenJhbmdlYnlzY29yZShMTFJfQ09PTERPV05fU0VUX0tFWShjaGFpbklkLCB0b2tlbkEsIHRva2VuQiksIG1pblNjb3JlLCBtYXhTY29yZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIG1ha2VyIGFuZCB0b2tlbiBhZGRyZXNzZXMuXG4gICAgICogSWYgYmFsYW5jZXMgYXJlIHBhc3NlZCwgdmFsaWRhdGVzIHRoYXQgZXZlcnkgY2FjaGUga2V5IGhhcyBhIGNvcnJlc3BvbmRpbmcgdmFsdWUuXG4gICAgICogR2VuZXJhdGVzIGEgY2FjaGUga2V5IGZvciBldmVyeSBwYWlyIHRocm91Z2ggc3RyaW5nIGNvbmNhdGVuYXRpb24uXG4gICAgICovXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBwcmVmZXItZnVuY3Rpb24tb3Zlci1tZXRob2RcbiAgICBwcml2YXRlIF92YWxpZGF0ZUFuZEdldEJhbGFuY2VDYWNoZUtleXMoXG4gICAgICAgIGNoYWluSWQ6IG51bWJlcixcbiAgICAgICAgZXJjMjBPd25lcnM6IEVSQzIwT3duZXJbXSxcbiAgICAgICAgYmFsYW5jZXM/OiBCaWdOdW1iZXJbXSxcbiAgICApOiBzdHJpbmdbXSB7XG4gICAgICAgIGlmIChiYWxhbmNlcyAmJiBlcmMyME93bmVycy5sZW5ndGggIT09IGJhbGFuY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWtlciBhZGRyZXNzZXMgZG8gbm90IG1hdGNoIGJhbGFuY2VzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvd25lcnMsIHRva2VucyB9ID0gc3BsaXRBZGRyZXNzZXMoZXJjMjBPd25lcnMpO1xuICAgICAgICByZXR1cm4gb3duZXJzLm1hcCgob3duZXIsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBFUkMyMF9PV05FUl9CQUxBTkNFX0tFWShjaGFpbklkLCBvd25lciwgdG9rZW5zW2ldKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sInZlcnNpb24iOjN9