{"file":"/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts","mappings":"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","names":[],"sources":["/Users/davidwalsh/code-local/0x-rfq-api/src/utils/cache_client.ts"],"sourcesContent":["import { ZERO } from '@0x/protocol-utils';\r\nimport { BigNumber } from '@0x/utils';\r\nimport Redis from 'ioredis';\r\n\r\nimport { MAKER_TOKEN_BALANCE_EXPIRY_SECONDS } from '../core/constants';\r\nimport { ERC20Owner } from '../core/types';\r\n\r\nimport { splitAddresses } from './address_utils';\r\nimport { toPairString } from '../core/pair_utils';\r\n\r\nconst OTC_ORDER_NONCE_BUCKET_COUNTER_KEY = (chainId: number) => `otcorder.nonce.bucket.counter.chain.${chainId}`;\r\n// The value stored at this key is a set. The members of this set are each an ERC20_OWNER_BALANCE_KEY.\r\nconst ERC20_OWNERS_KEY = (chainId: number) => `erc20.owners.chain.${chainId}`;\r\nconst ERC20_OWNER_BALANCE_KEY = (chainId: number, ownerAddress: string, tokenAddress: string) =>\r\n    `erc20.owner.balance.chain.${chainId}.${ownerAddress}.${tokenAddress}`;\r\n// Use `chainId` and pair keys as Redis keys for sorted set entries, used for cooling down makers after bad last look rejection.\r\nconst LLR_COOLDOWN_SET_KEY = (chainId: number, tokenA: string, tokenB: string) =>\r\n    `coolingdown.makers.chain.${chainId}.pair.${toPairString(tokenA, tokenB)}`;\r\n\r\nexport class CacheClient {\r\n    constructor(private readonly _redis: Redis) {}\r\n\r\n    // Shut down the CacheClient safely\r\n    public async closeAsync(): Promise<'OK'> {\r\n        return this._redis.quit();\r\n    }\r\n\r\n    // Get the next OtcOrder Bucket\r\n    // NOTE: unliklely to ever hit this, but the node library we use tries to cast the response from Redis as a number.\r\n    // However, MAX_INT for js is lower than MAX_INT for Redis. We also need to be aware of if Redis' MAX_INT ever gets hit (error)\r\n    public async getNextOtcOrderBucketAsync(chainId: number): Promise<number> {\r\n        return this._redis.incr(OTC_ORDER_NONCE_BUCKET_COUNTER_KEY(chainId));\r\n    }\r\n\r\n    /**\r\n     * Fetches all maker token addresses to be updated.\r\n     * Token addresses set stores unique erc20Owners as balance cache keys.\r\n     */\r\n    public async getERC20OwnersAsync(chainId: number): Promise<ERC20Owner[]> {\r\n        const cacheKeys = await this._redis.smembers(ERC20_OWNERS_KEY(chainId));\r\n        // parse cache keys into ERC20Owner objects\r\n        // cache key follows the format of `prefix.${chainId}.${owner}.${token}`\r\n        return cacheKeys.map((cacheKey) => {\r\n            const addresses = cacheKey.split('.');\r\n            return {\r\n                owner: addresses[addresses.length - 2],\r\n                token: addresses[addresses.length - 1],\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a newly observed erc20Owner to the set of known maker tokens.\r\n     * The values in this set are keys used to retrieve the maker's balance.\r\n     * They are iterated upon in the next maker balance cache update.\r\n     */\r\n    public async addERC20OwnerAsync(chainId: number, erc20Owner: ERC20Owner): Promise<void> {\r\n        const { owners, tokens } = splitAddresses(erc20Owner);\r\n        await this._redis.sadd(ERC20_OWNERS_KEY(chainId), ERC20_OWNER_BALANCE_KEY(chainId, owners[0], tokens[0]));\r\n    }\r\n\r\n    /**\r\n     * Evicts maker token addresses with zero balances from the cache.\r\n     * We assume that market makers no longer supply liquidity for tokens with zero balances.\r\n     */\r\n    public async evictZeroBalancesAsync(chainId: number): Promise<number> {\r\n        const setKey = ERC20_OWNERS_KEY(chainId);\r\n        const cacheKeys = await this._redis.smembers(setKey);\r\n        if (cacheKeys.length === 0) {\r\n            return 0;\r\n        }\r\n        const balances = await this._redis.mget(cacheKeys);\r\n        const evictedKeys = cacheKeys.filter((_, idx) => {\r\n            const balance = balances[idx];\r\n            return balance != null && ZERO.eq(new BigNumber(balance));\r\n        });\r\n        if (evictedKeys.length === 0) {\r\n            return 0;\r\n        }\r\n        return this._redis.srem(setKey, evictedKeys);\r\n    }\r\n\r\n    /**\r\n     * Gets maker balances for provided erc20Owners from the cache.\r\n     * A cache miss will result in a null value, and otherwise a valid BigNumber.\r\n     * Throws an error if invalid addresses are passed.\r\n     * Each GET is a fast O(1) read request to the cache.\r\n     */\r\n    public async getERC20OwnerBalancesAsync(chainId: number, erc20Owners: ERC20Owner[]): Promise<(BigNumber | null)[]> {\r\n        const cacheKeys = this._validateAndGetBalanceCacheKeys(chainId, erc20Owners);\r\n        // Redis mGet only accepts non-empty arrays\r\n        // if erc20Owners is empty, balances should be empty as well\r\n        if (cacheKeys.length === 0) {\r\n            return [];\r\n        }\r\n        const balances = await this._redis.mget(cacheKeys);\r\n        return balances.map((balance) => (balance ? new BigNumber(balance) : null));\r\n    }\r\n\r\n    /**\r\n     * Sets and/or updates maker balances for provided maker and token addresses.\r\n     * Refreshes cache entry expiries to two minutes from now.\r\n     * Throws an error if invalid addresses or balances are passed.\r\n     * Each SET is a fast O(1) write request to the cache.\r\n     */\r\n    public async setERC20OwnerBalancesAsync(\r\n        chainId: number,\r\n        erc20Owners: ERC20Owner[],\r\n        balances: BigNumber[],\r\n    ): Promise<void> {\r\n        const cacheKeys = this._validateAndGetBalanceCacheKeys(chainId, erc20Owners, balances);\r\n        await Promise.all(\r\n            cacheKeys.map(async (cacheKey, i) =>\r\n                this._redis.set(cacheKey, balances[i].toString(), 'EX', MAKER_TOKEN_BALANCE_EXPIRY_SECONDS),\r\n            ),\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Add maker to cooldown sorted set of given pair. Maker Ids in the sorted set are sorted by\r\n     * cooldown period endTime, so as to allow quickly filter out these with expired cooldown period.\r\n     *\r\n     * @param makerId ID of maker to be added or updated\r\n     * @param endTime time stamp to end the cooldown period, in millisecond\r\n     * @param chainId chainId of the pair\r\n     * @param tokenA address of one trading token\r\n     * @param tokenB address of the other trading token\r\n     * @returns whether the sorted set get updated\r\n     */\r\n    public async addMakerToCooldownAsync(\r\n        makerId: string,\r\n        endTime: number,\r\n        chainId: number,\r\n        tokenA: string,\r\n        tokenB: string,\r\n    ): Promise<boolean> {\r\n        const changedMemberCount = await this._redis.zadd(\r\n            LLR_COOLDOWN_SET_KEY(chainId, tokenA, tokenB),\r\n            'GT', // only update if setting a higher score\r\n            'CH', // return number of set members get changed (added and updated)\r\n            endTime, // score to be sorted by\r\n            makerId, // value of the entry\r\n        );\r\n        return changedMemberCount > 0;\r\n    }\r\n\r\n    /**\r\n     * Get a list of makers that are cooling down for given pair. Only includes unexpired entries.\r\n     *\r\n     * @param chainId chainId of the pair\r\n     * @param tokenA address of one trading token\r\n     * @param tokenB address of the other trading token\r\n     * @param now current timestamp (for testing)\r\n     * @returns array of maker IDs\r\n     */\r\n    public async getMakersInCooldownForPairAsync(\r\n        chainId: number,\r\n        tokenA: string,\r\n        tokenB: string,\r\n        now: number = Date.now(),\r\n    ): Promise<string[]> {\r\n        // Sorted set members use cooldown expiration time as scores, so selecting members with scores larger than `Date.now()`\r\n        // will give a complete list of makers in cooldown.\r\n        const minScore = now;\r\n        const maxScore = '+inf';\r\n        return this._redis.zrangebyscore(LLR_COOLDOWN_SET_KEY(chainId, tokenA, tokenB), minScore, maxScore);\r\n    }\r\n\r\n    /**\r\n     * Validates maker and token addresses.\r\n     * If balances are passed, validates that every cache key has a corresponding value.\r\n     * Generates a cache key for every pair through string concatenation.\r\n     */\r\n    // tslint:disable-next-line: prefer-function-over-method\r\n    private _validateAndGetBalanceCacheKeys(\r\n        chainId: number,\r\n        erc20Owners: ERC20Owner[],\r\n        balances?: BigNumber[],\r\n    ): string[] {\r\n        if (balances && erc20Owners.length !== balances.length) {\r\n            throw new Error('Maker addresses do not match balances');\r\n        }\r\n        const { owners, tokens } = splitAddresses(erc20Owners);\r\n        return owners.map((owner, i) => {\r\n            return ERC20_OWNER_BALANCE_KEY(chainId, owner, tokens[i]);\r\n        });\r\n    }\r\n}\r\n"],"version":3}