5ffa21b8ba5772f0f62769fae5f780e1
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheClient = void 0;
const protocol_utils_1 = require("@0x/protocol-utils");
const utils_1 = require("@0x/utils");
const constants_1 = require("../core/constants");
const address_utils_1 = require("./address_utils");
const pair_utils_1 = require("../core/pair_utils");
const OTC_ORDER_NONCE_BUCKET_COUNTER_KEY = (chainId) => `otcorder.nonce.bucket.counter.chain.${chainId}`;
// The value stored at this key is a set. The members of this set are each an ERC20_OWNER_BALANCE_KEY.
const ERC20_OWNERS_KEY = (chainId) => `erc20.owners.chain.${chainId}`;
const ERC20_OWNER_BALANCE_KEY = (chainId, ownerAddress, tokenAddress) => `erc20.owner.balance.chain.${chainId}.${ownerAddress}.${tokenAddress}`;
// Use `chainId` and pair keys as Redis keys for sorted set entries, used for cooling down makers after bad last look rejection.
const LLR_COOLDOWN_SET_KEY = (chainId, tokenA, tokenB) => `coolingdown.makers.chain.${chainId}.pair.${(0, pair_utils_1.toPairString)(tokenA, tokenB)}`;
class CacheClient {
    constructor(_redis) {
        this._redis = _redis;
    }
    // Shut down the CacheClient safely
    async closeAsync() {
        return this._redis.quit();
    }
    // Get the next OtcOrder Bucket
    // NOTE: unliklely to ever hit this, but the node library we use tries to cast the response from Redis as a number.
    // However, MAX_INT for js is lower than MAX_INT for Redis. We also need to be aware of if Redis' MAX_INT ever gets hit (error)
    async getNextOtcOrderBucketAsync(chainId) {
        return this._redis.incr(OTC_ORDER_NONCE_BUCKET_COUNTER_KEY(chainId));
    }
    /**
     * Fetches all maker token addresses to be updated.
     * Token addresses set stores unique erc20Owners as balance cache keys.
     */
    async getERC20OwnersAsync(chainId) {
        const cacheKeys = await this._redis.smembers(ERC20_OWNERS_KEY(chainId));
        // parse cache keys into ERC20Owner objects
        // cache key follows the format of `prefix.${chainId}.${owner}.${token}`
        return cacheKeys.map((cacheKey) => {
            const addresses = cacheKey.split('.');
            return {
                owner: addresses[addresses.length - 2],
                token: addresses[addresses.length - 1],
            };
        });
    }
    /**
     * Adds a newly observed erc20Owner to the set of known maker tokens.
     * The values in this set are keys used to retrieve the maker's balance.
     * They are iterated upon in the next maker balance cache update.
     */
    async addERC20OwnerAsync(chainId, erc20Owner) {
        const { owners, tokens } = (0, address_utils_1.splitAddresses)(erc20Owner);
        await this._redis.sadd(ERC20_OWNERS_KEY(chainId), ERC20_OWNER_BALANCE_KEY(chainId, owners[0], tokens[0]));
    }
    /**
     * Evicts maker token addresses with zero balances from the cache.
     * We assume that market makers no longer supply liquidity for tokens with zero balances.
     */
    async evictZeroBalancesAsync(chainId) {
        const setKey = ERC20_OWNERS_KEY(chainId);
        const cacheKeys = await this._redis.smembers(setKey);
        if (cacheKeys.length === 0) {
            return 0;
        }
        const balances = await this._redis.mget(cacheKeys);
        const evictedKeys = cacheKeys.filter((_, idx) => {
            const balance = balances[idx];
            return balance != null && protocol_utils_1.ZERO.eq(new utils_1.BigNumber(balance));
        });
        if (evictedKeys.length === 0) {
            return 0;
        }
        return this._redis.srem(setKey, evictedKeys);
    }
    /**
     * Gets maker balances for provided erc20Owners from the cache.
     * A cache miss will result in a null value, and otherwise a valid BigNumber.
     * Throws an error if invalid addresses are passed.
     * Each GET is a fast O(1) read request to the cache.
     */
    async getERC20OwnerBalancesAsync(chainId, erc20Owners) {
        const cacheKeys = this._validateAndGetBalanceCacheKeys(chainId, erc20Owners);
        // Redis mGet only accepts non-empty arrays
        // if erc20Owners is empty, balances should be empty as well
        if (cacheKeys.length === 0) {
            return [];
        }
        const balances = await this._redis.mget(cacheKeys);
        return balances.map((balance) => (balance ? new utils_1.BigNumber(balance) : null));
    }
    /**
     * Sets and/or updates maker balances for provided maker and token addresses.
     * Refreshes cache entry expiries to two minutes from now.
     * Throws an error if invalid addresses or balances are passed.
     * Each SET is a fast O(1) write request to the cache.
     */
    async setERC20OwnerBalancesAsync(chainId, erc20Owners, balances) {
        const cacheKeys = this._validateAndGetBalanceCacheKeys(chainId, erc20Owners, balances);
        await Promise.all(cacheKeys.map(async (cacheKey, i) => this._redis.set(cacheKey, balances[i].toString(), 'EX', constants_1.MAKER_TOKEN_BALANCE_EXPIRY_SECONDS)));
    }
    /**
     * Add maker to cooldown sorted set of given pair. Maker Ids in the sorted set are sorted by
     * cooldown period endTime, so as to allow quickly filter out these with expired cooldown period.
     *
     * @param makerId ID of maker to be added or updated
     * @param endTime time stamp to end the cooldown period, in millisecond
     * @param chainId chainId of the pair
     * @param tokenA address of one trading token
     * @param tokenB address of the other trading token
     * @returns whether the sorted set get updated
     */
    async addMakerToCooldownAsync(makerId, endTime, chainId, tokenA, tokenB) {
        const changedMemberCount = await this._redis.zadd(LLR_COOLDOWN_SET_KEY(chainId, tokenA, tokenB), 'GT', // only update if setting a higher score
        'CH', // return number of set members get changed (added and updated)
        endTime, // score to be sorted by
        makerId);
        return changedMemberCount > 0;
    }
    /**
     * Get a list of makers that are cooling down for given pair. Only includes unexpired entries.
     *
     * @param chainId chainId of the pair
     * @param tokenA address of one trading token
     * @param tokenB address of the other trading token
     * @param now current timestamp (for testing)
     * @returns array of maker IDs
     */
    async getMakersInCooldownForPairAsync(chainId, tokenA, tokenB, now = Date.now()) {
        // Sorted set members use cooldown expiration time as scores, so selecting members with scores larger than `Date.now()`
        // will give a complete list of makers in cooldown.
        const minScore = now;
        const maxScore = '+inf';
        return this._redis.zrangebyscore(LLR_COOLDOWN_SET_KEY(chainId, tokenA, tokenB), minScore, maxScore);
    }
    /**
     * Validates maker and token addresses.
     * If balances are passed, validates that every cache key has a corresponding value.
     * Generates a cache key for every pair through string concatenation.
     */
    // tslint:disable-next-line: prefer-function-over-method
    _validateAndGetBalanceCacheKeys(chainId, erc20Owners, balances) {
        if (balances && erc20Owners.length !== balances.length) {
            throw new Error('Maker addresses do not match balances');
        }
        const { owners, tokens } = (0, address_utils_1.splitAddresses)(erc20Owners);
        return owners.map((owner, i) => {
            return ERC20_OWNER_BALANCE_KEY(chainId, owner, tokens[i]);
        });
    }
}
exports.CacheClient = CacheClient;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy91dGlscy9jYWNoZV9jbGllbnQudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEsdURBQTBDO0FBQzFDLHFDQUFzQztBQUd0QyxpREFBdUU7QUFHdkUsbURBQWlEO0FBQ2pELG1EQUFrRDtBQUVsRCxNQUFNLGtDQUFrQyxHQUFHLENBQUMsT0FBZSxFQUFFLEVBQUUsQ0FBQyx1Q0FBdUMsT0FBTyxFQUFFLENBQUM7QUFDakgsc0dBQXNHO0FBQ3RHLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxPQUFlLEVBQUUsRUFBRSxDQUFDLHNCQUFzQixPQUFPLEVBQUUsQ0FBQztBQUM5RSxNQUFNLHVCQUF1QixHQUFHLENBQUMsT0FBZSxFQUFFLFlBQW9CLEVBQUUsWUFBb0IsRUFBRSxFQUFFLENBQzVGLDZCQUE2QixPQUFPLElBQUksWUFBWSxJQUFJLFlBQVksRUFBRSxDQUFDO0FBQzNFLGdJQUFnSTtBQUNoSSxNQUFNLG9CQUFvQixHQUFHLENBQUMsT0FBZSxFQUFFLE1BQWMsRUFBRSxNQUFjLEVBQUUsRUFBRSxDQUM3RSw0QkFBNEIsT0FBTyxTQUFTLElBQUEseUJBQVksRUFBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQztBQUUvRSxNQUFhLFdBQVc7SUFDcEIsWUFBNkIsTUFBYTtRQUFiLFdBQU0sR0FBTixNQUFNLENBQU87SUFBRyxDQUFDO0lBRTlDLG1DQUFtQztJQUM1QixLQUFLLENBQUMsVUFBVTtRQUNuQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDOUIsQ0FBQztJQUVELCtCQUErQjtJQUMvQixtSEFBbUg7SUFDbkgsK0hBQStIO0lBQ3hILEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxPQUFlO1FBQ25ELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsa0NBQWtDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksS0FB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SUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsb0JBQW9CLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDeEcsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCx3REFBd0Q7SUFDaEQsK0JBQStCLENBQ25DLE9BQWUsRUFDZixXQUF5QixFQUN6QixRQUFzQjtRQUV0QixJQUFJLFFBQVEsSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLFFBQVEsQ0FBQyxNQUFNLEVBQUU7WUFDcEQsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO1NBQzVEO1FBQ0QsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxJQUFBLDhCQUFjLEVBQUMsV0FBVyxDQUFDLENBQUM7UUFDdkQsT0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzNCLE9BQU8sdUJBQXVCLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5RCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7Q0FDSjtBQXhLRCxrQ0F3S0MiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy91dGlscy9jYWNoZV9jbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgWkVSTyB9IGZyb20gJ0AweC9wcm90b2NvbC11dGlscyc7XHJcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ0AweC91dGlscyc7XHJcbmltcG9ydCBSZWRpcyBmcm9tICdpb3JlZGlzJztcclxuXHJcbmltcG9ydCB7IE1BS0VSX1RPS0VOX0JBTEFOQ0VfRVhQSVJZX1NFQ09ORFMgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IEVSQzIwT3duZXIgfSBmcm9tICcuLi9jb3JlL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IHNwbGl0QWRkcmVzc2VzIH0gZnJvbSAnLi9hZGRyZXNzX3V0aWxzJztcclxuaW1wb3J0IHsgdG9QYWlyU3RyaW5nIH0gZnJvbSAnLi4vY29yZS9wYWlyX3V0aWxzJztcclxuXHJcbmNvbnN0IE9UQ19PUkRFUl9OT05DRV9CVUNLRVRfQ09VTlRFUl9LRVkgPSAoY2hhaW5JZDogbnVtYmVyKSA9PiBgb3Rjb3JkZXIubm9uY2UuYnVja2V0LmNvdW50ZXIuY2hhaW4uJHtjaGFpbklkfWA7XHJcbi8vIFRoZSB2YWx1ZSBzdG9yZWQgYXQgdGhpcyBrZXkgaXMgYSBzZXQuIFRoZSBtZW1iZXJzIG9mIHRoaXMgc2V0IGFyZSBlYWNoIGFuIEVSQzIwX09XTkVSX0JBTEFOQ0VfS0VZLlxyXG5jb25zdCBFUkMyMF9PV05FUlNfS0VZID0gKGNoYWluSWQ6IG51bWJlcikgPT4gYGVyYzIwLm93bmVycy5jaGFpbi4ke2NoYWluSWR9YDtcclxuY29uc3QgRVJDMjBfT1dORVJfQkFMQU5DRV9LRVkgPSAoY2hhaW5JZDogbnVtYmVyLCBvd25lckFkZHJlc3M6IHN0cmluZywgdG9rZW5BZGRyZXNzOiBzdHJpbmcpID0+XHJcbiAgICBgZXJjMjAub3duZXIuYmFsYW5jZS5jaGFpbi4ke2NoYWluSWR9LiR7b3duZXJBZGRyZXNzfS4ke3Rva2VuQWRkcmVzc31gO1xyXG4vLyBVc2UgYGNoYWluSWRgIGFuZCBwYWlyIGtleXMgYXMgUmVkaXMga2V5cyBmb3Igc29ydGVkIHNldCBlbnRyaWVzLCB1c2VkIGZvciBjb29saW5nIGRvd24gbWFrZXJzIGFmdGVyIGJhZCBsYXN0IGxvb2sgcmVqZWN0aW9uLlxyXG5jb25zdCBMTFJfQ09PTERPV05fU0VUX0tFWSA9IChjaGFpbklkOiBudW1iZXIsIHRva2VuQTogc3RyaW5nLCB0b2tlbkI6IHN0cmluZykgPT5cclxuICAgIGBjb29saW5nZG93bi5tYWtlcnMuY2hhaW4uJHtjaGFpbklkfS5wYWlyLiR7dG9QYWlyU3RyaW5nKHRva2VuQSwgdG9rZW5CKX1gO1xyXG5cclxuZXhwb3J0IGNsYXNzIENhY2hlQ2xpZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgX3JlZGlzOiBSZWRpcykge31cclxuXHJcbiAgICAvLyBTaHV0IGRvd24gdGhlIENhY2hlQ2xpZW50IHNhZmVseVxyXG4gICAgcHVibGljIGFzeW5jIGNsb3NlQXN5bmMoKTogUHJvbWlzZTwnT0snPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZGlzLnF1aXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgdGhlIG5leHQgT3RjT3JkZXIgQnVja2V0XHJcbiAgICAvLyBOT1RFOiB1bmxpa2xlbHkgdG8gZXZlciBoaXQgdGhpcywgYnV0IHRoZSBub2RlIGxpYnJhcnkgd2UgdXNlIHRyaWVzIHRvIGNhc3QgdGhlIHJlc3BvbnNlIGZyb20gUmVkaXMgYXMgYSBudW1iZXIuXHJcbiAgICAvLyBIb3dldmVyLCBNQVhfSU5UIGZvciBqcyBpcyBsb3dlciB0aGFuIE1BWF9JTlQgZm9yIFJlZGlzLiBXZSBhbHNvIG5lZWQgdG8gYmUgYXdhcmUgb2YgaWYgUmVkaXMnIE1BWF9JTlQgZXZlciBnZXRzIGhpdCAoZXJyb3IpXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0TmV4dE90Y09yZGVyQnVja2V0QXN5bmMoY2hhaW5JZDogbnVtYmVyKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVkaXMuaW5jcihPVENfT1JERVJfTk9OQ0VfQlVDS0VUX0NPVU5URVJfS0VZKGNoYWluSWQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoZXMgYWxsIG1ha2VyIHRva2VuIGFkZHJlc3NlcyB0byBiZSB1cGRhdGVkLlxyXG4gICAgICogVG9rZW4gYWRkcmVzc2VzIHNldCBzdG9yZXMgdW5pcXVlIGVyYzIwT3duZXJzIGFzIGJhbGFuY2UgY2FjaGUga2V5cy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldEVSQzIwT3duZXJzQXN5bmMoY2hhaW5JZDogbnVtYmVyKTogUHJvbWlzZTxFUkMyME93bmVyW10+IHtcclxuICAgICAgICBjb25zdCBjYWNoZUtleXMgPSBhd2FpdCB0aGlzLl9yZWRpcy5zbWVtYmVycyhFUkMyMF9PV05FUlNfS0VZKGNoYWluSWQpKTtcclxuICAgICAgICAvLyBwYXJzZSBjYWNoZSBrZXlzIGludG8gRVJDMjBPd25lciBvYmplY3RzXHJcbiAgICAgICAgLy8gY2FjaGUga2V5IGZvbGxvd3MgdGhlIGZvcm1hdCBvZiBgcHJlZml4LiR7Y2hhaW5JZH0uJHtvd25lcn0uJHt0b2tlbn1gXHJcbiAgICAgICAgcmV0dXJuIGNhY2hlS2V5cy5tYXAoKGNhY2hlS2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IGNhY2hlS2V5LnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBvd25lcjogYWRkcmVzc2VzW2FkZHJlc3Nlcy5sZW5ndGggLSAyXSxcclxuICAgICAgICAgICAgICAgIHRva2VuOiBhZGRyZXNzZXNbYWRkcmVzc2VzLmxlbmd0aCAtIDFdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ld2x5IG9ic2VydmVkIGVyYzIwT3duZXIgdG8gdGhlIHNldCBvZiBrbm93biBtYWtlciB0b2tlbnMuXHJcbiAgICAgKiBUaGUgdmFsdWVzIGluIHRoaXMgc2V0IGFyZSBrZXlzIHVzZWQgdG8gcmV0cmlldmUgdGhlIG1ha2VyJ3MgYmFsYW5jZS5cclxuICAgICAqIFRoZXkgYXJlIGl0ZXJhdGVkIHVwb24gaW4gdGhlIG5leHQgbWFrZXIgYmFsYW5jZSBjYWNoZSB1cGRhdGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBhZGRFUkMyME93bmVyQXN5bmMoY2hhaW5JZDogbnVtYmVyLCBlcmMyME93bmVyOiBFUkMyME93bmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgeyBvd25lcnMsIHRva2VucyB9ID0gc3BsaXRBZGRyZXNzZXMoZXJjMjBPd25lcik7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5fcmVkaXMuc2FkZChFUkMyMF9PV05FUlNfS0VZKGNoYWluSWQpLCBFUkMyMF9PV05FUl9CQUxBTkNFX0tFWShjaGFpbklkLCBvd25lcnNbMF0sIHRva2Vuc1swXSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXZpY3RzIG1ha2VyIHRva2VuIGFkZHJlc3NlcyB3aXRoIHplcm8gYmFsYW5jZXMgZnJvbSB0aGUgY2FjaGUuXHJcbiAgICAgKiBXZSBhc3N1bWUgdGhhdCBtYXJrZXQgbWFrZXJzIG5vIGxvbmdlciBzdXBwbHkgbGlxdWlkaXR5IGZvciB0b2tlbnMgd2l0aCB6ZXJvIGJhbGFuY2VzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZXZpY3RaZXJvQmFsYW5jZXNBc3luYyhjaGFpbklkOiBudW1iZXIpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgICAgIGNvbnN0IHNldEtleSA9IEVSQzIwX09XTkVSU19LRVkoY2hhaW5JZCk7XHJcbiAgICAgICAgY29uc3QgY2FjaGVLZXlzID0gYXdhaXQgdGhpcy5fcmVkaXMuc21lbWJlcnMoc2V0S2V5KTtcclxuICAgICAgICBpZiAoY2FjaGVLZXlzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLl9yZWRpcy5tZ2V0KGNhY2hlS2V5cyk7XHJcbiAgICAgICAgY29uc3QgZXZpY3RlZEtleXMgPSBjYWNoZUtleXMuZmlsdGVyKChfLCBpZHgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGJhbGFuY2VzW2lkeF07XHJcbiAgICAgICAgICAgIHJldHVybiBiYWxhbmNlICE9IG51bGwgJiYgWkVSTy5lcShuZXcgQmlnTnVtYmVyKGJhbGFuY2UpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoZXZpY3RlZEtleXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVkaXMuc3JlbShzZXRLZXksIGV2aWN0ZWRLZXlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgbWFrZXIgYmFsYW5jZXMgZm9yIHByb3ZpZGVkIGVyYzIwT3duZXJzIGZyb20gdGhlIGNhY2hlLlxyXG4gICAgICogQSBjYWNoZSBtaXNzIHdpbGwgcmVzdWx0IGluIGEgbnVsbCB2YWx1ZSwgYW5kIG90aGVyd2lzZSBhIHZhbGlkIEJpZ051bWJlci5cclxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBpbnZhbGlkIGFkZHJlc3NlcyBhcmUgcGFzc2VkLlxyXG4gICAgICogRWFjaCBHRVQgaXMgYSBmYXN0IE8oMSkgcmVhZCByZXF1ZXN0IHRvIHRoZSBjYWNoZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKGNoYWluSWQ6IG51bWJlciwgZXJjMjBPd25lcnM6IEVSQzIwT3duZXJbXSk6IFByb21pc2U8KEJpZ051bWJlciB8IG51bGwpW10+IHtcclxuICAgICAgICBjb25zdCBjYWNoZUtleXMgPSB0aGlzLl92YWxpZGF0ZUFuZEdldEJhbGFuY2VDYWNoZUtleXMoY2hhaW5JZCwgZXJjMjBPd25lcnMpO1xyXG4gICAgICAgIC8vIFJlZGlzIG1HZXQgb25seSBhY2NlcHRzIG5vbi1lbXB0eSBhcnJheXNcclxuICAgICAgICAvLyBpZiBlcmMyME93bmVycyBpcyBlbXB0eSwgYmFsYW5jZXMgc2hvdWxkIGJlIGVtcHR5IGFzIHdlbGxcclxuICAgICAgICBpZiAoY2FjaGVLZXlzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5fcmVkaXMubWdldChjYWNoZUtleXMpO1xyXG4gICAgICAgIHJldHVybiBiYWxhbmNlcy5tYXAoKGJhbGFuY2UpID0+IChiYWxhbmNlID8gbmV3IEJpZ051bWJlcihiYWxhbmNlKSA6IG51bGwpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYW5kL29yIHVwZGF0ZXMgbWFrZXIgYmFsYW5jZXMgZm9yIHByb3ZpZGVkIG1ha2VyIGFuZCB0b2tlbiBhZGRyZXNzZXMuXHJcbiAgICAgKiBSZWZyZXNoZXMgY2FjaGUgZW50cnkgZXhwaXJpZXMgdG8gdHdvIG1pbnV0ZXMgZnJvbSBub3cuXHJcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgaW52YWxpZCBhZGRyZXNzZXMgb3IgYmFsYW5jZXMgYXJlIHBhc3NlZC5cclxuICAgICAqIEVhY2ggU0VUIGlzIGEgZmFzdCBPKDEpIHdyaXRlIHJlcXVlc3QgdG8gdGhlIGNhY2hlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgc2V0RVJDMjBPd25lckJhbGFuY2VzQXN5bmMoXHJcbiAgICAgICAgY2hhaW5JZDogbnVtYmVyLFxyXG4gICAgICAgIGVyYzIwT3duZXJzOiBFUkMyME93bmVyW10sXHJcbiAgICAgICAgYmFsYW5jZXM6IEJpZ051bWJlcltdLFxyXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgY2FjaGVLZXlzID0gdGhpcy5fdmFsaWRhdGVBbmRHZXRCYWxhbmNlQ2FjaGVLZXlzKGNoYWluSWQsIGVyYzIwT3duZXJzLCBiYWxhbmNlcyk7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgICAgICAgIGNhY2hlS2V5cy5tYXAoYXN5bmMgKGNhY2hlS2V5LCBpKSA9PlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVkaXMuc2V0KGNhY2hlS2V5LCBiYWxhbmNlc1tpXS50b1N0cmluZygpLCAnRVgnLCBNQUtFUl9UT0tFTl9CQUxBTkNFX0VYUElSWV9TRUNPTkRTKSxcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIG1ha2VyIHRvIGNvb2xkb3duIHNvcnRlZCBzZXQgb2YgZ2l2ZW4gcGFpci4gTWFrZXIgSWRzIGluIHRoZSBzb3J0ZWQgc2V0IGFyZSBzb3J0ZWQgYnlcclxuICAgICAqIGNvb2xkb3duIHBlcmlvZCBlbmRUaW1lLCBzbyBhcyB0byBhbGxvdyBxdWlja2x5IGZpbHRlciBvdXQgdGhlc2Ugd2l0aCBleHBpcmVkIGNvb2xkb3duIHBlcmlvZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFrZXJJZCBJRCBvZiBtYWtlciB0byBiZSBhZGRlZCBvciB1cGRhdGVkXHJcbiAgICAgKiBAcGFyYW0gZW5kVGltZSB0aW1lIHN0YW1wIHRvIGVuZCB0aGUgY29vbGRvd24gcGVyaW9kLCBpbiBtaWxsaXNlY29uZFxyXG4gICAgICogQHBhcmFtIGNoYWluSWQgY2hhaW5JZCBvZiB0aGUgcGFpclxyXG4gICAgICogQHBhcmFtIHRva2VuQSBhZGRyZXNzIG9mIG9uZSB0cmFkaW5nIHRva2VuXHJcbiAgICAgKiBAcGFyYW0gdG9rZW5CIGFkZHJlc3Mgb2YgdGhlIG90aGVyIHRyYWRpbmcgdG9rZW5cclxuICAgICAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHNvcnRlZCBzZXQgZ2V0IHVwZGF0ZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGFkZE1ha2VyVG9Db29sZG93bkFzeW5jKFxyXG4gICAgICAgIG1ha2VySWQ6IHN0cmluZyxcclxuICAgICAgICBlbmRUaW1lOiBudW1iZXIsXHJcbiAgICAgICAgY2hhaW5JZDogbnVtYmVyLFxyXG4gICAgICAgIHRva2VuQTogc3RyaW5nLFxyXG4gICAgICAgIHRva2VuQjogc3RyaW5nLFxyXG4gICAgKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlZE1lbWJlckNvdW50ID0gYXdhaXQgdGhpcy5fcmVkaXMuemFkZChcclxuICAgICAgICAgICAgTExSX0NPT0xET1dOX1NFVF9LRVkoY2hhaW5JZCwgdG9rZW5BLCB0b2tlbkIpLFxyXG4gICAgICAgICAgICAnR1QnLCAvLyBvbmx5IHVwZGF0ZSBpZiBzZXR0aW5nIGEgaGlnaGVyIHNjb3JlXHJcbiAgICAgICAgICAgICdDSCcsIC8vIHJldHVybiBudW1iZXIgb2Ygc2V0IG1lbWJlcnMgZ2V0IGNoYW5nZWQgKGFkZGVkIGFuZCB1cGRhdGVkKVxyXG4gICAgICAgICAgICBlbmRUaW1lLCAvLyBzY29yZSB0byBiZSBzb3J0ZWQgYnlcclxuICAgICAgICAgICAgbWFrZXJJZCwgLy8gdmFsdWUgb2YgdGhlIGVudHJ5XHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gY2hhbmdlZE1lbWJlckNvdW50ID4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIGxpc3Qgb2YgbWFrZXJzIHRoYXQgYXJlIGNvb2xpbmcgZG93biBmb3IgZ2l2ZW4gcGFpci4gT25seSBpbmNsdWRlcyB1bmV4cGlyZWQgZW50cmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2hhaW5JZCBjaGFpbklkIG9mIHRoZSBwYWlyXHJcbiAgICAgKiBAcGFyYW0gdG9rZW5BIGFkZHJlc3Mgb2Ygb25lIHRyYWRpbmcgdG9rZW5cclxuICAgICAqIEBwYXJhbSB0b2tlbkIgYWRkcmVzcyBvZiB0aGUgb3RoZXIgdHJhZGluZyB0b2tlblxyXG4gICAgICogQHBhcmFtIG5vdyBjdXJyZW50IHRpbWVzdGFtcCAoZm9yIHRlc3RpbmcpXHJcbiAgICAgKiBAcmV0dXJucyBhcnJheSBvZiBtYWtlciBJRHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldE1ha2Vyc0luQ29vbGRvd25Gb3JQYWlyQXN5bmMoXHJcbiAgICAgICAgY2hhaW5JZDogbnVtYmVyLFxyXG4gICAgICAgIHRva2VuQTogc3RyaW5nLFxyXG4gICAgICAgIHRva2VuQjogc3RyaW5nLFxyXG4gICAgICAgIG5vdzogbnVtYmVyID0gRGF0ZS5ub3coKSxcclxuICAgICk6IFByb21pc2U8c3RyaW5nW10+IHtcclxuICAgICAgICAvLyBTb3J0ZWQgc2V0IG1lbWJlcnMgdXNlIGNvb2xkb3duIGV4cGlyYXRpb24gdGltZSBhcyBzY29yZXMsIHNvIHNlbGVjdGluZyBtZW1iZXJzIHdpdGggc2NvcmVzIGxhcmdlciB0aGFuIGBEYXRlLm5vdygpYFxyXG4gICAgICAgIC8vIHdpbGwgZ2l2ZSBhIGNvbXBsZXRlIGxpc3Qgb2YgbWFrZXJzIGluIGNvb2xkb3duLlxyXG4gICAgICAgIGNvbnN0IG1pblNjb3JlID0gbm93O1xyXG4gICAgICAgIGNvbnN0IG1heFNjb3JlID0gJytpbmYnO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWRpcy56cmFuZ2VieXNjb3JlKExMUl9DT09MRE9XTl9TRVRfS0VZKGNoYWluSWQsIHRva2VuQSwgdG9rZW5CKSwgbWluU2NvcmUsIG1heFNjb3JlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyBtYWtlciBhbmQgdG9rZW4gYWRkcmVzc2VzLlxyXG4gICAgICogSWYgYmFsYW5jZXMgYXJlIHBhc3NlZCwgdmFsaWRhdGVzIHRoYXQgZXZlcnkgY2FjaGUga2V5IGhhcyBhIGNvcnJlc3BvbmRpbmcgdmFsdWUuXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBjYWNoZSBrZXkgZm9yIGV2ZXJ5IHBhaXIgdGhyb3VnaCBzdHJpbmcgY29uY2F0ZW5hdGlvbi5cclxuICAgICAqL1xyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBwcmVmZXItZnVuY3Rpb24tb3Zlci1tZXRob2RcclxuICAgIHByaXZhdGUgX3ZhbGlkYXRlQW5kR2V0QmFsYW5jZUNhY2hlS2V5cyhcclxuICAgICAgICBjaGFpbklkOiBudW1iZXIsXHJcbiAgICAgICAgZXJjMjBPd25lcnM6IEVSQzIwT3duZXJbXSxcclxuICAgICAgICBiYWxhbmNlcz86IEJpZ051bWJlcltdLFxyXG4gICAgKTogc3RyaW5nW10ge1xyXG4gICAgICAgIGlmIChiYWxhbmNlcyAmJiBlcmMyME93bmVycy5sZW5ndGggIT09IGJhbGFuY2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ha2VyIGFkZHJlc3NlcyBkbyBub3QgbWF0Y2ggYmFsYW5jZXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBvd25lcnMsIHRva2VucyB9ID0gc3BsaXRBZGRyZXNzZXMoZXJjMjBPd25lcnMpO1xyXG4gICAgICAgIHJldHVybiBvd25lcnMubWFwKChvd25lciwgaSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gRVJDMjBfT1dORVJfQkFMQU5DRV9LRVkoY2hhaW5JZCwgb3duZXIsIHRva2Vuc1tpXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIl0sInZlcnNpb24iOjN9