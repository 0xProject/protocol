{"file":"/Users/davidwalsh/code-local/0x-rfq-api/src/services/WorkerService.ts","mappings":"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","names":[],"sources":["/Users/davidwalsh/code-local/0x-rfq-api/src/services/WorkerService.ts"],"sourcesContent":["// tslint:disable:max-file-line-count\r\nimport { MarketOperation } from '@0x/asset-swapper';\r\nimport { OtcOrder, Signature } from '@0x/protocol-utils';\r\nimport { BigNumber } from '@0x/utils';\r\nimport { Web3Wrapper } from '@0x/web3-wrapper';\r\nimport { retry } from '@lifeomic/attempt';\r\nimport delay from 'delay';\r\nimport { Counter, Gauge, Summary } from 'prom-client';\r\n\r\nimport {\r\n    ENABLE_LLR_COOLDOWN,\r\n    Integrator,\r\n    LLR_COOLDOWN_DURATION_SECONDS,\r\n    TAKER_SPECIFIED_SIDE_ENABLED,\r\n} from '../config';\r\nimport {\r\n    ETH_DECIMALS,\r\n    GAS_ESTIMATE_BUFFER,\r\n    GWEI_DECIMALS,\r\n    LLR_COOLDOWN_WINDOW_SECONDS,\r\n    ONE_MINUTE_S,\r\n    ONE_SECOND_MS,\r\n} from '../core/constants';\r\nimport { storedFeeToFee } from '../core/fee_utils';\r\nimport { Approval } from '../core/types';\r\nimport {\r\n    MetaTransactionJobEntity,\r\n    MetaTransactionSubmissionEntity,\r\n    RfqmV2JobEntity,\r\n    RfqmV2TransactionSubmissionEntity,\r\n} from '../entities';\r\nimport {\r\n    RfqmJobStatus,\r\n    RfqmTransactionSubmissionStatus,\r\n    RfqmTransactionSubmissionType,\r\n    SubmissionContextStatus,\r\n} from '../entities/types';\r\nimport { logger } from '../logger';\r\nimport { SignRequest } from '../quote-server/types';\r\nimport { CacheClient } from '../utils/cache_client';\r\nimport { GasStationAttendant } from '../utils/GasStationAttendant';\r\nimport { QuoteServerClient } from '../utils/quote_server_client';\r\nimport { RfqmDbUtils, storedOtcOrderToOtcOrder } from '../utils/rfqm_db_utils';\r\nimport { RfqBlockchainUtils } from '../utils/rfq_blockchain_utils';\r\nimport { RfqMakerManager } from '../utils/rfq_maker_manager';\r\nimport { getSignerFromHash, padSignature } from '../utils/signature_utils';\r\nimport { SubmissionContext } from '../utils/SubmissionContext';\r\n\r\nimport { RfqMakerBalanceCacheService } from './rfq_maker_balance_cache_service';\r\n\r\ninterface GasFees {\r\n    maxFeePerGas: BigNumber;\r\n    maxPriorityFeePerGas: BigNumber;\r\n}\r\n\r\n// https://stackoverflow.com/questions/47632622/typescript-and-filter-boolean\r\nfunction isDefined<T>(value: T): value is NonNullable<T> {\r\n    return value !== null && value !== undefined;\r\n}\r\n\r\nconst RFQM_WORKER_BALANCE = new Gauge({\r\n    name: 'rfqm_worker_balance',\r\n    labelNames: ['address', 'chain_id'],\r\n    help: 'Worker balance for RFQM',\r\n});\r\n\r\nconst RFQM_WORKER_READY = new Counter({\r\n    name: 'rfqm_worker_ready',\r\n    labelNames: ['address', 'chain_id'],\r\n    help: 'A worker passed the readiness check, and is ready to pick up work',\r\n});\r\n\r\nconst RFQM_WORKER_NOT_READY = new Counter({\r\n    name: 'rfqm_worker_not_ready',\r\n    labelNames: ['address', 'chain_id'],\r\n    help: 'A worker did not pass the readiness check, and was not able to pick up work',\r\n});\r\n\r\nconst RFQM_JOB_REPAIR = new Gauge({\r\n    name: 'rfqm_job_to_repair',\r\n    labelNames: ['address', 'chain_id'],\r\n    help: 'A submitted job failed and started repair mode',\r\n});\r\n\r\nconst RFQM_JOB_FAILED_MM_SIGNATURE_FAILED = new Counter({\r\n    name: 'rfqm_job_failed_mm_signature_failed',\r\n    help: 'A job failed because the market maker signature process failed. NOT triggered when the MM declines to sign.',\r\n    labelNames: ['makerUri', 'chain_id'],\r\n});\r\nconst RFQM_JOB_MM_REJECTED_LAST_LOOK = new Counter({\r\n    name: 'rfqm_job_mm_rejected_last_look',\r\n    help: 'A job rejected by market maker on last look',\r\n    labelNames: ['makerUri', 'chain_id'],\r\n});\r\n\r\nconst RFQM_PROCESS_JOB_LATENCY = new Summary({\r\n    name: 'rfqm_process_job_latency',\r\n    labelNames: ['chain_id', 'job_kind'],\r\n    help: 'Latency for the worker processing the job',\r\n});\r\n\r\nconst RFQM_JOB_COMPLETED = new Counter({\r\n    name: 'rfqm_job_completed',\r\n    help: 'An Rfqm Job completed with no errors',\r\n    labelNames: ['address', 'chain_id', 'job_kind'],\r\n});\r\n\r\nconst RFQM_JOB_COMPLETED_WITH_ERROR = new Counter({\r\n    name: 'rfqm_job_completed_with_error',\r\n    help: 'An Rfqm Job completed with an error',\r\n    labelNames: ['address', 'chain_id', 'job_kind'],\r\n});\r\n\r\nconst RFQM_CREATE_ACCESS_LIST_REQUEST = new Counter({\r\n    name: 'rfqm_create_access_list_request_total',\r\n    help: 'Number of requests for eth_createAccessList call',\r\n    labelNames: ['chain_id', 'status'],\r\n});\r\n\r\nconst RFQM_GAS_ESTIMATE_ACCESS_LIST = new Gauge({\r\n    name: 'rfqm_gas_estimate_acess_list',\r\n    help: 'Gas estimate of transaction with access list',\r\n    labelNames: ['chain_id'],\r\n});\r\n\r\nconst RFQM_GAS_ESTIMATE_NO_ACCESS_LIST = new Gauge({\r\n    name: 'rfqm_gas_estimate_no_access_list',\r\n    help: 'Gas estimate of transaction without access list',\r\n    labelNames: ['chain_id'],\r\n});\r\n\r\nconst RFQM_SIGNED_QUOTE_EXPIRY_TOO_SOON = new Counter({\r\n    name: 'rfqm_signed_quote_expiry_too_soon',\r\n    labelNames: ['chain_id'],\r\n    help: 'A signed quote was not queued because it would expire too soon',\r\n});\r\n\r\nconst RFQM_MINING_LATENCY = new Summary({\r\n    name: 'rfqm_mining_latency',\r\n    labelNames: ['chain_id'],\r\n    help: 'The time in seconds between when the first transaction for a job is sent and when a transaction for the job is mined',\r\n});\r\n\r\nconst PRICE_DECIMAL_PLACES = 6;\r\n\r\nconst MIN_GAS_PRICE_INCREASE = 0.1;\r\n\r\n// Retrying an EIP 1559 transaction: https://docs.alchemy.com/alchemy/guides/eip-1559/retry-eip-1559-tx\r\nconst MAX_PRIORITY_FEE_PER_GAS_MULTIPLIER = 1.5; // Increase multiplier for tip with each resubmission cycle\r\nconst MAX_FEE_PER_GAS_MULTIPLIER = 1.1; // Increase multiplier in max fee per gas with each cycle; limitation of geth node\r\n// During recovery, we may not be able to successfully execute\r\n// `estimateGasForAsync`. In this case we use this value.\r\nconst MAX_GAS_ESTIMATE = 500_000;\r\nconst SIMULATION_MAX_GAS_MULTIPLIER = 2; // Multiplier of configured max fee when performing transaction simulation\r\n\r\n// How often the worker should publish a heartbeat\r\nconst WORKER_HEARTBEAT_FREQUENCY_MS = ONE_SECOND_MS * 30; // tslint:disable-line: custom-no-magic-numbers\r\n\r\n/**\r\n * The service layer for Gasless Workers.\r\n *\r\n * Workers are bots with their own EOAs which pull\r\n * messages off an SQS queue, retrieve the related\r\n * job, and submit that job to the blockchain.\r\n */\r\nexport class WorkerService {\r\n    private _lastHeartbeatTime: Date | null = null;\r\n    private _maxFeePerGasCapWei: BigNumber;\r\n\r\n    public static shouldResubmitTransaction(gasFees: GasFees, gasPriceEstimate: BigNumber): boolean {\r\n        // Geth only allows replacement of transactions if the replacement gas price\r\n        // is at least 10% higher than the gas price of the transaction being replaced\r\n        return gasPriceEstimate.gte(gasFees.maxFeePerGas.multipliedBy(MIN_GAS_PRICE_INCREASE + 1));\r\n    }\r\n\r\n    // Returns a failure status for an invalid rfqm v2 job or null if job is valid.\r\n    public static validateRfqmV2Job(job: RfqmV2JobEntity, now: Date = new Date()): RfqmJobStatus | null {\r\n        const { makerUri, order, fee } = job;\r\n\r\n        if (makerUri === undefined) {\r\n            return RfqmJobStatus.FailedValidationNoMakerUri;\r\n        }\r\n\r\n        if (order === null) {\r\n            return RfqmJobStatus.FailedValidationNoOrder;\r\n        }\r\n\r\n        if (fee === null) {\r\n            return RfqmJobStatus.FailedValidationNoFee;\r\n        }\r\n\r\n        // Orders can expire if any of the following happen:\r\n        // 1) workers are backed up\r\n        // 2) an RFQM order broke during submission and the order is stuck in the queue for a long time.\r\n        const otcOrderStringFields = job.order.order;\r\n        const { expiry } = OtcOrder.parseExpiryAndNonce(new BigNumber(otcOrderStringFields.expiryAndNonce));\r\n        const expiryTimeMs = expiry.times(ONE_SECOND_MS);\r\n        if (expiryTimeMs.isNaN() || expiryTimeMs.lte(now.getTime())) {\r\n            return RfqmJobStatus.FailedExpired;\r\n        }\r\n        if (!job.takerSignature) {\r\n            return RfqmJobStatus.FailedValidationNoTakerSignature;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    // Returns a failure status for an invalid meta-transaction job or null if job is valid.\r\n    public static validateMetaTransactionJob(\r\n        job: MetaTransactionJobEntity,\r\n        now: Date = new Date(),\r\n    ): RfqmJobStatus | null {\r\n        const { expiry, fee, metaTransaction, takerSignature } = job;\r\n\r\n        if (metaTransaction === null) {\r\n            return RfqmJobStatus.FailedValidationNoOrder;\r\n        }\r\n\r\n        if (fee === null) {\r\n            return RfqmJobStatus.FailedValidationNoFee;\r\n        }\r\n\r\n        // Orders can expire if any of the following happen:\r\n        // 1) workers are backed up\r\n        // 2) an order broke during submission and the order is stuck in the queue for a long time.\r\n        const expiryTimeMs = expiry.times(ONE_SECOND_MS);\r\n        if (expiryTimeMs.isNaN() || expiryTimeMs.lte(now.getTime())) {\r\n            return RfqmJobStatus.FailedExpired;\r\n        }\r\n        if (!takerSignature) {\r\n            return RfqmJobStatus.FailedValidationNoTakerSignature;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    constructor(\r\n        private readonly _chainId: number,\r\n        private readonly _gasStationAttendant: GasStationAttendant,\r\n        private readonly _registryAddress: string,\r\n        private readonly _blockchainUtils: RfqBlockchainUtils,\r\n        private readonly _dbUtils: RfqmDbUtils,\r\n        private readonly _quoteServerClient: QuoteServerClient,\r\n        private readonly _transactionWatcherSleepTimeMs: number,\r\n        private readonly _cacheClient: CacheClient,\r\n        private readonly _rfqMakerBalanceCacheService: RfqMakerBalanceCacheService,\r\n        private readonly _rfqMakerManager: RfqMakerManager,\r\n        private readonly _initialMaxPriorityFeePerGasGwei: number,\r\n        maxFeePerGasCapGwei: number,\r\n        private readonly _enableAccessList?: boolean,\r\n    ) {\r\n        this._maxFeePerGasCapWei = new BigNumber(maxFeePerGasCapGwei).times(Math.pow(10, GWEI_DECIMALS));\r\n    }\r\n\r\n    public async workerBeforeLogicAsync(workerIndex: number, workerAddress: string): Promise<boolean> {\r\n        let gasPrice;\r\n        try {\r\n            gasPrice = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();\r\n        } catch (error) {\r\n            logger.error(\r\n                { errorMessage: error.message },\r\n                'Current gas price is unable to be fetched, marking worker as not ready.',\r\n            );\r\n            RFQM_WORKER_NOT_READY.labels(workerAddress, this._chainId.toString()).inc();\r\n            return false;\r\n        }\r\n\r\n        const balance = await this._blockchainUtils.getAccountBalanceAsync(workerAddress);\r\n        const balanceUnitAmount = Web3Wrapper.toUnitAmount(balance, ETH_DECIMALS).decimalPlaces(PRICE_DECIMAL_PLACES);\r\n        RFQM_WORKER_BALANCE.labels(workerAddress, this._chainId.toString()).set(balanceUnitAmount.toNumber());\r\n\r\n        // check for outstanding jobs from the worker and resolve them\r\n        const unresolvedJobs = await Promise.all([\r\n            this._dbUtils.findV2UnresolvedJobsAsync(workerAddress, this._chainId),\r\n            this._dbUtils.findUnresolvedMetaTransactionJobsAsync(workerAddress, this._chainId),\r\n        ]).then((x) => x.flat());\r\n\r\n        RFQM_JOB_REPAIR.labels(workerAddress, this._chainId.toString()).inc(unresolvedJobs.length);\r\n        for (const job of unresolvedJobs) {\r\n            const { kind } = job;\r\n            let jobIdentifier;\r\n\r\n            switch (kind) {\r\n                case 'rfqm_v2_job':\r\n                    jobIdentifier = job.orderHash;\r\n                    break;\r\n                case 'meta_transaction_job':\r\n                    jobIdentifier = job.id;\r\n                    break;\r\n                default:\r\n                    ((_x: never): never => {\r\n                        throw new Error('Unreachable');\r\n                    })(kind);\r\n            }\r\n\r\n            logger.info({ kind, jobIdentifier, workerAddress }, `Unresolved job found, attempting to reprocess`);\r\n            await this.processJobAsync(jobIdentifier, workerAddress, kind);\r\n        }\r\n\r\n        const isWorkerReady = await this._blockchainUtils.isWorkerReadyAsync(\r\n            this._chainId,\r\n            workerAddress,\r\n            balance,\r\n            BigNumber.min(gasPrice, this._maxFeePerGasCapWei),\r\n        );\r\n        if (!isWorkerReady) {\r\n            RFQM_WORKER_NOT_READY.labels(workerAddress, this._chainId.toString()).inc();\r\n            return false;\r\n        }\r\n\r\n        if (this._lastHeartbeatTime && Date.now() - this._lastHeartbeatTime.getTime() < WORKER_HEARTBEAT_FREQUENCY_MS) {\r\n            return true;\r\n        }\r\n\r\n        // Publish a heartbeat if the worker is ready to go\r\n        try {\r\n            if (workerIndex === undefined) {\r\n                throw new Error('Worker index is undefined');\r\n            }\r\n            // NOTE: when merging with `feature/multichain`, update this line with\r\n            // `const chainId = this._chain.chainId.\r\n            const chainId = this._chainId;\r\n            await this._dbUtils.upsertRfqmWorkerHeartbeatToDbAsync(workerAddress, workerIndex, balance, chainId);\r\n            this._lastHeartbeatTime = new Date();\r\n        } catch (error) {\r\n            logger.error(\r\n                { workerAddress, balance, errorMessage: error.message },\r\n                'Worker failed to write a heartbeat to storage',\r\n            );\r\n        }\r\n\r\n        RFQM_WORKER_READY.labels(workerAddress, this._chainId.toString()).inc();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Top-level logic the worker uses to take a v2 job or meta-transaction job to completion.\r\n     * The identifier (orderHash for v2 job and jod id for meta-transaction job) can come from\r\n     * either an unfinished job found during the worker before logic or from an SQS message.\r\n     *\r\n     * Big picture steps:\r\n     * 1. Fetch the job from the database\r\n     * 2. Prepare the job by validating it (and getting the market maker signature for v2 job).\r\n     *    This step is different for v2 and meta-transaction jobs.\r\n     * 3. Submit a transaction if none exist, wait for mining + confirmation,\r\n     *    and submit new transactions if gas prices rise\r\n     * 4. Finalize the job status\r\n     *\r\n     * This function is the error boundary for job processing; errors will be caught, logged\r\n     * and swallowed. The worker will continue along its lifecycle.\r\n     *\r\n     * This function handles processing latency metrics & job success/fail counters.\r\n     */\r\n    public async processJobAsync(\r\n        identifier: string,\r\n        workerAddress: string,\r\n        kind: (RfqmV2JobEntity | MetaTransactionJobEntity)['kind'] = 'rfqm_v2_job',\r\n    ): Promise<void> {\r\n        logger.info({ kind, identifier, workerAddress }, 'Start process job');\r\n        const timerStopFunction = RFQM_PROCESS_JOB_LATENCY.labels(this._chainId.toString(), kind).startTimer();\r\n\r\n        try {\r\n            // Step 1: Find the job\r\n            let job;\r\n            switch (kind) {\r\n                case 'rfqm_v2_job':\r\n                    job = await this._dbUtils.findV2JobByOrderHashAsync(identifier);\r\n                    break;\r\n                case 'meta_transaction_job':\r\n                    job = await this._dbUtils.findMetaTransactionJobByIdAsync(identifier);\r\n                    break;\r\n                default:\r\n                    ((_x: never) => {\r\n                        throw new Error('unreachable');\r\n                    })(kind);\r\n            }\r\n\r\n            if (!job) {\r\n                throw new Error('No job found for identifier');\r\n            }\r\n\r\n            // Step 2: Prepare the job for submission\r\n\r\n            // Claim job for worker\r\n            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-extra-non-null-assertion\r\n            if (job.workerAddress!! && job.workerAddress !== workerAddress) {\r\n                throw new Error('Worker was sent a job claimed by a different worker');\r\n            }\r\n            job.workerAddress = workerAddress;\r\n            await this._dbUtils.updateRfqmJobAsync(job);\r\n            if (job.approval) {\r\n                // approval and trade workflow\r\n                await this.processApprovalAndTradeAsync(job, workerAddress);\r\n            } else {\r\n                // trade only workflow\r\n                await this.processTradeAsync(job, workerAddress);\r\n            }\r\n            logger.info({ kind, identifier, workerAddress }, 'Job completed without errors');\r\n            RFQM_JOB_COMPLETED.labels(workerAddress, this._chainId.toString(), kind).inc();\r\n        } catch (error) {\r\n            logger.error({ kind, workerAddress, identifier, errorMessage: error.message }, 'Job completed with error');\r\n            RFQM_JOB_COMPLETED_WITH_ERROR.labels(workerAddress, this._chainId.toString(), kind).inc();\r\n        } finally {\r\n            timerStopFunction();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process approval (gasless approval) and trade (swap with the 0x exchange proxy) submissions. For the first version,\r\n     * they will be processed SEQUENTIALLY. In the future, we want to send the two transaction in parallel.\r\n     * The reason we can't parallelize the submissions is both function would modify job.status.\r\n     *\r\n     * The method would:\r\n     * 1. Perform preliminary check on the job object (and updates job status to `PendingProcessing`)\r\n     * 2. Getting the market maker signature\r\n     * 3. Prepare approval\r\n     * 4. Submit approval\r\n     * 5. Wait until the approval transaction is successfully confirmed\r\n     * 6. Prepare trade (since the method has already got the market maker signature, it's not performed here)\r\n     * 7. Submit trade\r\n     */\r\n    public async processApprovalAndTradeAsync(\r\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\r\n        workerAddress: string,\r\n    ): Promise<void> {\r\n        const { approval, approvalSignature, kind } = job;\r\n        if (!approval || !approvalSignature) {\r\n            throw new Error('Non-approval job should not be processed by `processApprovalAndTradeAsync`');\r\n        }\r\n\r\n        // Perform preliminary check\r\n        await this.checkJobPreprocessingAsync(job);\r\n        if (kind === 'rfqm_v2_job') {\r\n            // Perform last look for rfqm v2 job\r\n            await this.checkLastLookAsync(job, workerAddress, false);\r\n        }\r\n\r\n        let tokenToApprove;\r\n        let identifier;\r\n        switch (kind) {\r\n            case 'rfqm_v2_job':\r\n                tokenToApprove = job.order.order.takerToken;\r\n                identifier = job.orderHash;\r\n                break;\r\n            case 'meta_transaction_job':\r\n                tokenToApprove = job.inputToken;\r\n                identifier = job.id;\r\n                break;\r\n            default:\r\n                ((_x: never) => {\r\n                    throw new Error('unreachable');\r\n                })(kind);\r\n        }\r\n\r\n        const approvalCalldata = await this.prepareApprovalAsync(job, tokenToApprove, approval, approvalSignature);\r\n        const approvalStatus = await this.submitToChainAsync({\r\n            kind: job.kind,\r\n            to: tokenToApprove,\r\n            from: workerAddress,\r\n            calldata: approvalCalldata,\r\n            expiry: job.expiry,\r\n            identifier,\r\n            submissionType: RfqmTransactionSubmissionType.Approval,\r\n            onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(\r\n                job,\r\n                RfqmTransactionSubmissionType.Approval,\r\n            ),\r\n        });\r\n\r\n        // Prepare and submit trade only if approval transaction is successful\r\n        if (approvalStatus === SubmissionContextStatus.SucceededConfirmed) {\r\n            let tradeCalldata;\r\n            switch (kind) {\r\n                case 'rfqm_v2_job':\r\n                    tradeCalldata = await this.preparerfqmV2TradeAsync(job, workerAddress, false);\r\n                    break;\r\n                case 'meta_transaction_job':\r\n                    tradeCalldata = await this.prepareMetaTransactionTradeAsync(job, workerAddress, false);\r\n                    break;\r\n                default:\r\n                    ((_x: never) => {\r\n                        throw new Error('unreachable');\r\n                    })(kind);\r\n            }\r\n\r\n            await this.submitToChainAsync({\r\n                kind: job.kind,\r\n                to: this._blockchainUtils.getExchangeProxyAddress(),\r\n                from: workerAddress,\r\n                calldata: tradeCalldata,\r\n                expiry: job.expiry,\r\n                identifier,\r\n                submissionType: RfqmTransactionSubmissionType.Trade,\r\n                onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(\r\n                    job,\r\n                    RfqmTransactionSubmissionType.Trade,\r\n                ),\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process trade (swap with the 0x exchange proxy) submissions. The method would prepare trade calldata\r\n     * and submit the trade to the blockchain. Note that job status would be updated to the corresponding state.\r\n     */\r\n    public async processTradeAsync(\r\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\r\n        workerAddress: string,\r\n    ): Promise<void> {\r\n        const { kind } = job;\r\n\r\n        let calldata;\r\n        let identifier;\r\n        switch (kind) {\r\n            case 'rfqm_v2_job':\r\n                identifier = job.orderHash;\r\n                calldata = await this.preparerfqmV2TradeAsync(job, workerAddress);\r\n                break;\r\n            case 'meta_transaction_job':\r\n                identifier = job.id;\r\n                calldata = await this.prepareMetaTransactionTradeAsync(job, workerAddress);\r\n                break;\r\n            default:\r\n                ((_x: never) => {\r\n                    throw new Error('unreachable');\r\n                })(kind);\r\n        }\r\n\r\n        await this.submitToChainAsync({\r\n            kind: job.kind,\r\n            to: this._blockchainUtils.getExchangeProxyAddress(),\r\n            from: workerAddress,\r\n            calldata,\r\n            expiry: job.expiry,\r\n            identifier,\r\n            submissionType: RfqmTransactionSubmissionType.Trade,\r\n            onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(\r\n                job,\r\n                RfqmTransactionSubmissionType.Trade,\r\n            ),\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Perform preliminary checks on a job before processing.\r\n     *\r\n     * The method would:\r\n     * 1. Call `RfqmService.validateRfqmV2Job` / `RfqmService.validateMetaTransactionJob` and check result. If there is an error, update the job status and throw exception\r\n     * 2. Make sure job.takerSignature is present or throw exception\r\n     * 3. Update job status to `PendingProcessing` if current status is `PendingEnqueued`\r\n     */\r\n    public async checkJobPreprocessingAsync(\r\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\r\n        now: Date = new Date(),\r\n    ): Promise<void> {\r\n        const { kind, takerSignature } = job;\r\n        let identifier;\r\n        let errorStatus;\r\n\r\n        switch (kind) {\r\n            case 'rfqm_v2_job':\r\n                identifier = job.orderHash;\r\n                errorStatus = WorkerService.validateRfqmV2Job(job, now);\r\n                break;\r\n            case 'meta_transaction_job':\r\n                identifier = job.id;\r\n                errorStatus = WorkerService.validateMetaTransactionJob(job, now);\r\n                break;\r\n            default:\r\n                ((_x: never) => {\r\n                    throw new Error('unreachable');\r\n                })(kind);\r\n        }\r\n\r\n        if (errorStatus !== null) {\r\n            job.status = errorStatus;\r\n            await this._dbUtils.updateRfqmJobAsync(job);\r\n\r\n            if (errorStatus === RfqmJobStatus.FailedExpired) {\r\n                RFQM_SIGNED_QUOTE_EXPIRY_TOO_SOON.labels(this._chainId.toString()).inc();\r\n            }\r\n            logger.error({ kind, identifier, errorStatus }, 'Job failed validation');\r\n            throw new Error('Job failed validation');\r\n        }\r\n\r\n        // Existence of taker signature has already been checked by\r\n        // `RfqmService.validateJob(job)`. Refine the type.\r\n        if (!takerSignature) {\r\n            throw new Error('No taker signature present');\r\n        }\r\n\r\n        if (job.status === RfqmJobStatus.PendingEnqueued) {\r\n            job.status = RfqmJobStatus.PendingProcessing;\r\n            await this._dbUtils.updateRfqmJobAsync(job);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares a rfqm v2 / meta-transaction job for approval submission by validatidating the job and constructing\r\n     * the calldata.\r\n     *\r\n     * Note that `job.status` would be modified to `FailedEthCallFailed` if transaction simulation failed.\r\n     *\r\n     * Handles retries of retryable errors. Throws for unretriable errors. Updates job in database.\r\n     *\r\n     * @returns The generated calldata for approval submission type.\r\n     * @throws If the approval cannot be submitted (e.g. it is expired).\r\n     */\r\n    public async prepareApprovalAsync(\r\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\r\n        tokenToApprove: string,\r\n        approval: Approval,\r\n        siganature: Signature,\r\n    ): Promise<string> {\r\n        const { kind } = job;\r\n        const calldata = await this._blockchainUtils.generateApprovalCalldataAsync(\r\n            tokenToApprove,\r\n            approval,\r\n            siganature,\r\n        );\r\n\r\n        let identifier;\r\n        let transactionSubmissions;\r\n        // Check to see if we have already submitted an approval transaction for this job. If we have, the job has already\r\n        // been checked and we can skip `eth_call` validation.\r\n        switch (kind) {\r\n            case 'rfqm_v2_job':\r\n                identifier = job.orderHash;\r\n                transactionSubmissions = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(\r\n                    identifier,\r\n                    RfqmTransactionSubmissionType.Approval,\r\n                );\r\n                break;\r\n            case 'meta_transaction_job':\r\n                identifier = job.id;\r\n                transactionSubmissions = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(\r\n                    identifier,\r\n                    RfqmTransactionSubmissionType.Approval,\r\n                );\r\n                break;\r\n            default:\r\n                ((_x: never) => {\r\n                    throw new Error('unreachable');\r\n                })(kind);\r\n        }\r\n\r\n        if (transactionSubmissions.length) {\r\n            if (!job.takerSignature) {\r\n                // This shouldn't happen\r\n                throw new Error('Encountered a job with submissions but no taker signature');\r\n            }\r\n            if (job.kind === 'rfqm_v2_job' && !job.makerSignature) {\r\n                // This shouldn't happen\r\n                throw new Error('Encountered a job with submissions but no maker signature');\r\n            }\r\n\r\n            return calldata;\r\n        }\r\n\r\n        // Simulate the transaction\r\n        try {\r\n            await retry(\r\n                async () => {\r\n                    // Use `estimateGasForAsync` to simulate the transaction. In ethers.js, provider.call and\r\n                    // provider.send('eth_call', ...) might not throw exception and the behavior might be dependent\r\n                    // on providers. Revisit this later\r\n                    return this._blockchainUtils.estimateGasForAsync({ to: tokenToApprove, data: calldata });\r\n                },\r\n                {\r\n                    delay: ONE_SECOND_MS,\r\n                    factor: 1,\r\n                    maxAttempts: 3,\r\n                    handleError: (error, context, _options) => {\r\n                        const { attemptNum: attemptNumber, attemptsRemaining } = context;\r\n                        logger.warn(\r\n                            { kind, attemptNumber, attemptsRemaining, errorMessage: error.message, stack: error.stack },\r\n                            'Error during eth_call approval validation. Retrying.',\r\n                        );\r\n                    },\r\n                },\r\n            );\r\n        } catch (error) {\r\n            job.status = RfqmJobStatus.FailedEthCallFailed;\r\n            await this._dbUtils.updateRfqmJobAsync(job);\r\n\r\n            logger.error(\r\n                { kind, identifier, errorMessage: error.message, stack: error.stack },\r\n                'eth_call approval validation failed',\r\n            );\r\n            throw new Error('Eth call approval validation failed');\r\n        }\r\n\r\n        return calldata;\r\n    }\r\n\r\n    /**\r\n     * Prepares an RfqmV2 Job for trade submission by validatidating the job, obtaining the\r\n     * market maker signature, and constructing the calldata.\r\n     *\r\n     * Note that `job.status` would be modified to corresponding status. For example, if maker signature\r\n     * is not valid, `job.status` would be set to `FailedSignFailed`.\r\n     *\r\n     * `shouldCheckLastLook` determines if the preliminary job check and getting market maker sigature\r\n     * would be performed and is default to `true`.\r\n     *\r\n     * Handles retries of retryable errors. Throws for unretriable errors, and logs\r\n     * ONLY IF the log needs more information than the orderHash and workerAddress,\r\n     * which are logged by the `processJobAsync` routine.\r\n     * Updates job in database.\r\n     *\r\n     * @returns The generated calldata for trade submission type.\r\n     * @throws If the trade cannot be submitted (e.g. it is expired).\r\n     */\r\n    public async preparerfqmV2TradeAsync(\r\n        job: RfqmV2JobEntity,\r\n        workerAddress: string,\r\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n        // eslint-disable-next-line @typescript-eslint/no-inferrable-types\r\n        shouldCheckLastLook: boolean = true,\r\n        now: Date = new Date(),\r\n    ): Promise<string> {\r\n        /**\r\n         * Ask: This is the probably the only change I made to the old trade only workflow. To change from making a copy of parameter\r\n         * and then returning the copied value to change parameter value directly. The rationale behind is to make the style consistent\r\n         * with the new generalized `submitToChainAsync` (it has to use changing parameter value paradigm in order to work). Let me know\r\n         * if you don't like this change.\r\n         */\r\n        const { makerUri, order, orderHash } = job;\r\n        const otcOrder = storedOtcOrderToOtcOrder(order);\r\n\r\n        // Check to see if we have already submitted a transaction for this job.\r\n        // If we have, the job is already prepared and we can skip ahead.\r\n        const transactionSubmissions = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(job.orderHash);\r\n        if (transactionSubmissions.length) {\r\n            if (!job.makerSignature) {\r\n                // This shouldn't happen\r\n                throw new Error('Encountered a job with submissions but no maker signature');\r\n            }\r\n            if (!job.takerSignature) {\r\n                // This shouldn't happen\r\n                throw new Error('Encountered a job with submissions but no taker signature');\r\n            }\r\n            const existingSubmissionCalldata = this._blockchainUtils.generateTakerSignedOtcOrderCallData(\r\n                otcOrder,\r\n                job.makerSignature,\r\n                job.takerSignature,\r\n                job.isUnwrap,\r\n                job.affiliateAddress,\r\n            );\r\n            return existingSubmissionCalldata;\r\n        }\r\n\r\n        if (shouldCheckLastLook) {\r\n            // Perform the preliminary job check and getting market maker sigature\r\n            await this.checkJobPreprocessingAsync(job, now);\r\n            await this.checkLastLookAsync(job, workerAddress, true);\r\n        }\r\n\r\n        // Maker signature must already be defined here -- refine the type\r\n        if (!job.makerSignature) {\r\n            throw new Error('Maker signature does not exist');\r\n        }\r\n        // Taker signature must already be defined here -- refine the type\r\n        if (!job.takerSignature) {\r\n            throw new Error('Taker signature does not exist');\r\n        }\r\n\r\n        // Verify the signer was the maker\r\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n        const signerAddress = getSignerFromHash(orderHash, job.makerSignature!).toLowerCase();\r\n        const makerAddress = order.order.maker.toLowerCase();\r\n        if (signerAddress !== makerAddress) {\r\n            logger.info({ signerAddress, makerAddress, orderHash, makerUri }, 'Possible use of smart contract wallet');\r\n            const isValidSigner = await this._blockchainUtils.isValidOrderSignerAsync(makerAddress, signerAddress);\r\n            if (!isValidSigner) {\r\n                job.status = RfqmJobStatus.FailedSignFailed;\r\n                await this._dbUtils.updateRfqmJobAsync(job);\r\n                throw new Error('Invalid order signer address');\r\n            }\r\n        }\r\n\r\n        // Generate the calldata\r\n        const calldata = this._blockchainUtils.generateTakerSignedOtcOrderCallData(\r\n            otcOrder,\r\n            job.makerSignature,\r\n            job.takerSignature,\r\n            job.isUnwrap,\r\n            job.affiliateAddress,\r\n        );\r\n\r\n        // With the Market Maker signature, execute a full eth_call to validate the\r\n        // transaction via `estimateGasForFillTakerSignedOtcOrderAsync`\r\n        try {\r\n            await retry(\r\n                async () => {\r\n                    // Maker signature must already be defined here -- refine the type\r\n                    if (!job.makerSignature) {\r\n                        throw new Error('Maker signature does not exist');\r\n                    }\r\n                    // Taker signature must already be defined here -- refine the type\r\n                    if (!job.takerSignature) {\r\n                        throw new Error('Taker signature does not exist');\r\n                    }\r\n\r\n                    return this._blockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(\r\n                        otcOrder,\r\n                        job.makerSignature,\r\n                        job.takerSignature,\r\n                        workerAddress,\r\n                        job.isUnwrap,\r\n                    );\r\n                },\r\n                {\r\n                    delay: ONE_SECOND_MS,\r\n                    factor: 1,\r\n                    maxAttempts: 3,\r\n                    handleError: (error, context, _options) => {\r\n                        const { attemptNum: attemptNumber, attemptsRemaining } = context;\r\n                        logger.warn(\r\n                            { orderHash, makerUri, attemptNumber, attemptsRemaining, error: error.message },\r\n                            'Error during eth_call validation when preparing otc order trade. Retrying',\r\n                        );\r\n                    },\r\n                },\r\n            );\r\n        } catch (error) {\r\n            job.status = RfqmJobStatus.FailedEthCallFailed;\r\n            await this._dbUtils.updateRfqmJobAsync(job);\r\n\r\n            logger.error(\r\n                { orderHash, error: error.message },\r\n                'eth_call validation failed when preparing otc order trade',\r\n            );\r\n\r\n            // Attempt to gather extra context upon eth_call failure\r\n            try {\r\n                const [makerBalance] = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(\r\n                    this._chainId,\r\n                    { owner: otcOrder.maker, token: otcOrder.makerToken },\r\n                );\r\n                const [takerBalance] = await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync({\r\n                    owner: otcOrder.taker,\r\n                    token: otcOrder.takerToken,\r\n                });\r\n                const blockNumber = await this._blockchainUtils.getCurrentBlockAsync();\r\n                logger.info(\r\n                    {\r\n                        makerBalance,\r\n                        takerBalance,\r\n                        calldata,\r\n                        blockNumber,\r\n                        orderHash,\r\n                        order: otcOrder,\r\n                        bucket: otcOrder.nonceBucket,\r\n                        nonce: otcOrder.nonce,\r\n                    },\r\n                    'Extra context after eth_call validation failed when preparing otc order trade',\r\n                );\r\n            } catch (error) {\r\n                logger.warn(\r\n                    { orderHash },\r\n                    'Failed to get extra context after eth_call validation failed when preparing otc order trade',\r\n                );\r\n            }\r\n            throw new Error('Eth call validation failed when preparing otc order trade');\r\n        }\r\n\r\n        return calldata;\r\n    }\r\n\r\n    /**\r\n     * Prepares a meta-transaction job for trade submission by validatidating the job and constructing the calldata.\r\n     *\r\n     * Note that `job.status` would be modified to corresponding status. For example, if the meta-transaction expires,\r\n     * `job.status` would be set to `FailedFailedExpired`.\r\n     *\r\n     * Handles retries of retryable errors. Throws for unretriable errors, and logs\r\n     * ONLY IF the log needs more information than the orderHash and workerAddress,\r\n     * which are logged by the `processJobAsync` routine.\r\n     * Updates job in database.\r\n     *\r\n     * @returns The generated calldata for trade submission type.\r\n     * @throws If the trade cannot be submitted (e.g. it is expired).\r\n     */\r\n    public async prepareMetaTransactionTradeAsync(\r\n        job: MetaTransactionJobEntity,\r\n        workerAddress: string,\r\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n        // eslint-disable-next-line @typescript-eslint/no-inferrable-types\r\n        shouldValidateJob: boolean = true,\r\n        now: Date = new Date(),\r\n    ): Promise<string> {\r\n        // ASK: What's the difference bewtween `metaTransaction.signer` vs `metaTransaction.sender`?\r\n        //      Which one is the taker address?\r\n        const { affiliateAddress, id: jobId, inputToken, metaTransaction, takerAddress, takerSignature } = job;\r\n\r\n        // Check to see if we have already submitted a transaction for this job.\r\n        // If we have, the job is already prepared and we can skip ahead.\r\n        const transactionSubmissions = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId);\r\n        if (transactionSubmissions.length) {\r\n            if (!takerSignature) {\r\n                // This shouldn't happen\r\n                throw new Error('Encountered a job with submissions but no taker signature');\r\n            }\r\n            const existingSubmissionCalldata = this._blockchainUtils.generateMetaTransactionCallData(\r\n                metaTransaction,\r\n                takerSignature,\r\n                affiliateAddress,\r\n            );\r\n            return existingSubmissionCalldata;\r\n        }\r\n\r\n        if (shouldValidateJob) {\r\n            // Perform the preliminary job check\r\n            await this.checkJobPreprocessingAsync(job, now);\r\n        }\r\n\r\n        // Taker signature must already be defined here -- refine the type\r\n        if (!takerSignature) {\r\n            throw new Error('Taker signature does not exist');\r\n        }\r\n\r\n        // Generate the calldata\r\n        const calldata = this._blockchainUtils.generateMetaTransactionCallData(\r\n            metaTransaction,\r\n            takerSignature,\r\n            affiliateAddress,\r\n        );\r\n\r\n        // execute a full eth_call to validate the\r\n        // transaction via `estimateGasForAsync`\r\n        try {\r\n            await retry(\r\n                async () => {\r\n                    // The following gas fee operations are added because `executeMetaTransaction` in 0x Exchange Proxy\r\n                    // would check whether the gas price of the transaction is within a window. If left empty, it will\r\n                    // fail the simulation. The gas fee estimation below is the same as the first gas fee estimation\r\n                    // used in `submitToChain`.\r\n                    const gasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();\r\n                    const initialMaxPriorityFeePerGas = new BigNumber(this._initialMaxPriorityFeePerGasGwei).times(\r\n                        Math.pow(10, GWEI_DECIMALS),\r\n                    );\r\n                    const gasFees: GasFees = {\r\n                        maxFeePerGas: BigNumber.min(\r\n                            gasPriceEstimate.multipliedBy(2).plus(initialMaxPriorityFeePerGas),\r\n                            // If the max fee is less than the base fee, simulations will fail (unlike submissions, which may sit in the mempool).\r\n                            // An extra multiplier mitigates, but does not solve, the issue.\r\n                            this._maxFeePerGasCapWei.multipliedBy(SIMULATION_MAX_GAS_MULTIPLIER),\r\n                        ),\r\n                        maxPriorityFeePerGas: initialMaxPriorityFeePerGas,\r\n                    };\r\n\r\n                    return this._blockchainUtils.estimateGasForAsync({\r\n                        from: workerAddress,\r\n                        to: this._blockchainUtils.getExchangeProxyAddress(),\r\n                        data: calldata,\r\n                        maxFeePerGas: gasFees.maxFeePerGas.toString(),\r\n                        maxPriorityFeePerGas: gasFees.maxPriorityFeePerGas.toString(),\r\n                    });\r\n                },\r\n                {\r\n                    delay: ONE_SECOND_MS,\r\n                    factor: 1,\r\n                    maxAttempts: 3,\r\n                    handleError: (error, context, _options) => {\r\n                        const { attemptNum: attemptNumber, attemptsRemaining } = context;\r\n                        logger.warn(\r\n                            { jobId, attemptNumber, attemptsRemaining, error: error.message },\r\n                            'Error during eth_call validation when preparing meta-transaction trade. Retrying',\r\n                        );\r\n                    },\r\n                },\r\n            );\r\n        } catch (error) {\r\n            job.status = RfqmJobStatus.FailedEthCallFailed;\r\n            await this._dbUtils.updateRfqmJobAsync(job);\r\n\r\n            logger.error(\r\n                { jobId, error: error.message },\r\n                'eth_call validation failed when preparing meta-transaction trade',\r\n            );\r\n\r\n            // Attempt to gather extra context upon eth_call failure\r\n            try {\r\n                const [takerBalance] = await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync([\r\n                    { owner: takerAddress, token: inputToken },\r\n                ]);\r\n                const blockNumber = await this._blockchainUtils.getCurrentBlockAsync();\r\n                logger.info(\r\n                    {\r\n                        calldata,\r\n                        blockNumber,\r\n                        jobId,\r\n                        metaTransaction,\r\n                        takerBalance,\r\n                    },\r\n                    'Extra context after eth_call validation failed when preparing meta-transaction trade',\r\n                );\r\n            } catch (error) {\r\n                logger.warn(\r\n                    { jobId },\r\n                    'Failed to get extra context after eth_call validation failed when preparing meta-transaction trade ',\r\n                );\r\n            }\r\n            throw new Error('Eth call validation failed when preparing meta-transaction trade');\r\n        }\r\n\r\n        return calldata;\r\n    }\r\n\r\n    /**\r\n     * Check last look by getting market maker signature. Handles retries when making request to market maker servers.\r\n     *\r\n     * When verifying the order is fillable by both the maker and the taker:\r\n     * - If `shouldCheckAllowance` is false, the method would only check balances but not the allowances the maker and\r\n     *   the taker set for 0x exchange proxy because the taker allowance will not be set when `checkLastLookAsync` is called as we\r\n     *   want to call this method as soon as possible to mitigate the latency brought by sequential submissions\r\n     *   (which would lead to higher decline to sign rate).\r\n     * - Otherwise, both balances and allowances would be checked.\r\n     */\r\n    public async checkLastLookAsync(\r\n        job: RfqmV2JobEntity,\r\n        workerAddress: string,\r\n        shouldCheckAllowance: boolean,\r\n    ): Promise<void> {\r\n        const { makerUri, order, orderHash, takerSignature } = job;\r\n        const otcOrder = storedOtcOrderToOtcOrder(order);\r\n        let { makerSignature } = job;\r\n\r\n        if (makerSignature) {\r\n            // Market Maker had already signed order\r\n            logger.info({ workerAddress, orderHash }, 'Order already signed');\r\n        } else {\r\n            // validate that order is fillable by both the maker and the taker according to balances (and allowances\r\n            // when `shouldCheckAllowance` is true)\r\n            const [makerBalance] = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(this._chainId, {\r\n                owner: otcOrder.maker,\r\n                token: otcOrder.makerToken,\r\n            });\r\n            const [takerBalance] = shouldCheckAllowance\r\n                ? await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync({\r\n                      owner: otcOrder.taker,\r\n                      token: otcOrder.takerToken,\r\n                  })\r\n                : await this._blockchainUtils.getTokenBalancesAsync({\r\n                      owner: otcOrder.taker,\r\n                      token: otcOrder.takerToken,\r\n                  });\r\n\r\n            if (makerBalance.lt(otcOrder.makerAmount) || takerBalance.lt(otcOrder.takerAmount)) {\r\n                logger.error(\r\n                    {\r\n                        orderHash,\r\n                        makerBalance,\r\n                        takerBalance,\r\n                        makerAmount: otcOrder.makerAmount,\r\n                        takerAmount: otcOrder.takerAmount,\r\n                    },\r\n                    'Order failed pre-sign validation',\r\n                );\r\n                job.status = RfqmJobStatus.FailedPresignValidationFailed;\r\n                await this._dbUtils.updateRfqmJobAsync(job);\r\n                throw new Error('Order failed pre-sign validation');\r\n            }\r\n\r\n            if (!takerSignature) {\r\n                logger.error('Order failed pre-sign validation due to empty takerSignature');\r\n                job.status = RfqmJobStatus.FailedPresignValidationFailed;\r\n                await this._dbUtils.updateRfqmJobAsync(job);\r\n                throw new Error('Order failed pre-sign validation due to empty takerSignature');\r\n            }\r\n\r\n            const signRequest: SignRequest = {\r\n                expiry: job.expiry,\r\n                fee: storedFeeToFee(job.fee),\r\n                order: otcOrder,\r\n                orderHash,\r\n                takerSignature,\r\n                ...(job.takerSpecifiedSide &&\r\n                    TAKER_SPECIFIED_SIDE_ENABLED && { takerSpecifiedSide: job.takerSpecifiedSide }),\r\n            };\r\n\r\n            // \"Last Look\" in v1 is replaced by market maker order signing in v2.\r\n            const signAttemptTimeMs = Date.now();\r\n            try {\r\n                makerSignature = await retry(\r\n                    async () =>\r\n                        this._quoteServerClient\r\n                            .signV2Async(makerUri, job.integratorId ?? '', signRequest)\r\n                            .then((s) => s ?? null),\r\n                    {\r\n                        delay: ONE_SECOND_MS,\r\n                        factor: 2,\r\n                        maxAttempts: 3,\r\n                        handleError: (error, context, _options) => {\r\n                            const { attemptNum: attemptNumber, attemptsRemaining } = context;\r\n                            logger.warn(\r\n                                { orderHash, makerUri, attemptNumber, attemptsRemaining, error: error.message },\r\n                                'Error encountered while attempting to get market maker signature',\r\n                            );\r\n                        },\r\n                    },\r\n                );\r\n            } catch (error) {\r\n                // The sign process has failed after retries\r\n                RFQM_JOB_FAILED_MM_SIGNATURE_FAILED.labels(makerUri, this._chainId.toString()).inc();\r\n                logger.error(\r\n                    { orderHash, makerUri, error: error.message },\r\n                    'RFQM v2 job failed due to market maker sign failure',\r\n                );\r\n                job.status = RfqmJobStatus.FailedSignFailed;\r\n                await this._dbUtils.updateRfqmJobAsync(job);\r\n                throw new Error('Job failed during market maker sign attempt');\r\n            }\r\n\r\n            logger.info({ makerUri, signed: !!makerSignature, orderHash }, 'Got signature response from market maker');\r\n            if (!makerSignature) {\r\n                // Market Maker has declined to sign the transaction\r\n                RFQM_JOB_MM_REJECTED_LAST_LOOK.labels(makerUri, this._chainId.toString()).inc();\r\n                job.lastLookResult = false;\r\n                job.status = RfqmJobStatus.FailedLastLookDeclined;\r\n                await this._dbUtils.updateRfqmJobAsync(job);\r\n\r\n                if (ENABLE_LLR_COOLDOWN) {\r\n                    try {\r\n                        const quote = await this._dbUtils.findV2QuoteByOrderHashAsync(orderHash);\r\n                        if (quote === null) {\r\n                            throw new Error(`Failed to find quote with order hash ${orderHash}`);\r\n                        }\r\n\r\n                        // `bad` last look rejection, rejected within the cooldown window\r\n                        if (\r\n                            signAttemptTimeMs - quote.createdAt.valueOf() <\r\n                            LLR_COOLDOWN_WINDOW_SECONDS * ONE_SECOND_MS\r\n                        ) {\r\n                            const makerId = this._rfqMakerManager.findMakerIdWithRfqmUri(makerUri);\r\n                            if (makerId === null) {\r\n                                throw new Error(`Failed to find maker ID with RFQm URI ${makerUri}`);\r\n                            }\r\n\r\n                            const cooldownEndTimeMs = signAttemptTimeMs + LLR_COOLDOWN_DURATION_SECONDS * ONE_SECOND_MS;\r\n\r\n                            // schedule cooldown\r\n                            const isScheduleUpdated = await this._cacheClient.addMakerToCooldownAsync(\r\n                                makerId,\r\n                                cooldownEndTimeMs,\r\n                                this._chainId,\r\n                                otcOrder.makerToken,\r\n                                otcOrder.takerToken,\r\n                            );\r\n\r\n                            logger.info(\r\n                                {\r\n                                    makerId,\r\n                                    chainId: this._chainId,\r\n                                    makerToken: otcOrder.makerToken,\r\n                                    takerToken: otcOrder.takerToken,\r\n                                    startTime: signAttemptTimeMs,\r\n                                    endTime: cooldownEndTimeMs,\r\n                                    orderHash,\r\n                                    isScheduleUpdated,\r\n                                },\r\n                                'LLR cooldown scheduled',\r\n                            );\r\n\r\n                            try {\r\n                                // insert cooldown entry to db for record keeping\r\n                                await this._dbUtils.writeV2LastLookRejectionCooldownAsync(\r\n                                    makerId,\r\n                                    this._chainId,\r\n                                    otcOrder.makerToken,\r\n                                    otcOrder.takerToken,\r\n                                    new Date(signAttemptTimeMs), // startTime\r\n                                    new Date(cooldownEndTimeMs), // endTime\r\n                                    orderHash,\r\n                                );\r\n                            } catch (e) {\r\n                                logger.warn({ orderHash, errorMessage: e.message }, 'Saving LLR cooldown failed');\r\n                            }\r\n                        }\r\n                    } catch (error) {\r\n                        logger.warn(\r\n                            { errorMessage: error.message },\r\n                            'Encountered error when detecting bad LLR and scheduling cooldown',\r\n                        );\r\n                    }\r\n                }\r\n\r\n                // We'd like some data on how much the price the market maker is offering\r\n                // has changed. We query the market maker's price endpoint with the same\r\n                // trade they've just declined to sign and log the result.\r\n                try {\r\n                    const declineToSignPriceCheckTimeMs = Date.now();\r\n                    const otcOrderParams = QuoteServerClient.makeQueryParameters({\r\n                        chainId: this._chainId,\r\n                        txOrigin: this._registryAddress,\r\n                        takerAddress: otcOrder.taker,\r\n                        marketOperation: MarketOperation.Sell,\r\n                        buyTokenAddress: otcOrder.makerToken,\r\n                        sellTokenAddress: otcOrder.takerToken,\r\n                        assetFillAmount: otcOrder.takerAmount,\r\n                        isLastLook: true,\r\n                        fee: storedFeeToFee(job.fee),\r\n                    });\r\n                    // Instead of adding a dependency to `ConfigManager` to get the actual integrator\r\n                    // (we only have the ID at this point), just create a stand-in.\r\n                    // This will send the same integrator ID to the market maker; they will not be\r\n                    // able to tell the difference.\r\n                    // `logRfqMakerNetworkInteraction` does use the `label`, however, but I think the\r\n                    // tradeoff is reasonable.\r\n                    const integrator: Integrator = {\r\n                        apiKeys: [],\r\n                        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n                        integratorId: job.integratorId!,\r\n                        allowedChainIds: [this._chainId],\r\n                        label: 'decline-to-sign-price-check',\r\n                        plp: true,\r\n                        rfqm: true,\r\n                        rfqt: true,\r\n                    };\r\n                    const priceResponse = await this._quoteServerClient.getPriceV2Async(\r\n                        job.makerUri,\r\n                        integrator,\r\n                        otcOrderParams,\r\n                        (u: string) => `${u}/rfqm/v2/price`,\r\n                    );\r\n                    if (!priceResponse) {\r\n                        throw new Error('Failed to get a price response');\r\n                    }\r\n                    const { makerAmount: priceCheckMakerAmount, takerAmount: priceCheckTakerAmount } = priceResponse;\r\n                    const originalPrice = otcOrder.makerAmount.dividedBy(priceCheckTakerAmount);\r\n                    const priceAfterReject = priceCheckMakerAmount.dividedBy(priceCheckTakerAmount);\r\n                    const bipsFactor = 10000;\r\n                    const priceDifferenceBips = originalPrice\r\n                        .minus(priceAfterReject)\r\n                        .dividedBy(originalPrice)\r\n                        .absoluteValue()\r\n                        .times(bipsFactor)\r\n                        .toPrecision(1);\r\n                    // The time, in seconds, between when we initiated the sign attempt and when we\r\n                    // initiated the price check after the maker declined to sign.\r\n                    const priceCheckDelayS = (declineToSignPriceCheckTimeMs - signAttemptTimeMs) / ONE_SECOND_MS;\r\n                    logger.info(\r\n                        {\r\n                            orderHash,\r\n                            originalPrice: originalPrice.toNumber(),\r\n                            priceAfterReject: priceAfterReject.toNumber(),\r\n                            priceCheckDelayS,\r\n                            priceDifferenceBips,\r\n                        },\r\n                        'Decline to sign price check',\r\n                    );\r\n                    try {\r\n                        job.llRejectPriceDifferenceBps = parseInt(priceDifferenceBips, 10);\r\n                        await this._dbUtils.updateRfqmJobAsync(job);\r\n                    } catch (e) {\r\n                        logger.warn({ orderHash, errorMessage: e.message }, 'Saving LL reject price difference failed');\r\n                    }\r\n                } catch (error) {\r\n                    logger.warn(\r\n                        { errorMessage: error.message },\r\n                        'Encountered error during decline to sign price check',\r\n                    );\r\n                }\r\n                throw new Error('Market Maker declined to sign');\r\n            }\r\n\r\n            // Certain market makers are returning signature components which are missing\r\n            // leading bytes. Add them if they don't exist.\r\n            const paddedSignature = padSignature(makerSignature);\r\n            if (paddedSignature.r !== makerSignature.r || paddedSignature.s !== makerSignature.s) {\r\n                logger.warn(\r\n                    { orderHash, r: paddedSignature.r, s: paddedSignature.s },\r\n                    'Got market maker signature with missing bytes',\r\n                );\r\n                makerSignature = paddedSignature;\r\n            }\r\n\r\n            job.makerSignature = paddedSignature;\r\n            job.lastLookResult = true;\r\n            job.status = RfqmJobStatus.PendingLastLookAccepted;\r\n            await this._dbUtils.updateRfqmJobAsync(job);\r\n        }\r\n\r\n        // Maker signature must already be defined here -- refine the type\r\n        if (!makerSignature) {\r\n            throw new Error('Maker signature does not exist');\r\n        }\r\n\r\n        // Verify the signer was the maker\r\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n        const signerAddress = getSignerFromHash(orderHash, makerSignature!).toLowerCase();\r\n        const makerAddress = order.order.maker.toLowerCase();\r\n        if (signerAddress !== makerAddress) {\r\n            logger.info({ signerAddress, makerAddress, orderHash, makerUri }, 'Possible use of smart contract wallet');\r\n            const isValidSigner = await this._blockchainUtils.isValidOrderSignerAsync(makerAddress, signerAddress);\r\n            if (!isValidSigner) {\r\n                job.status = RfqmJobStatus.FailedSignFailed;\r\n                await this._dbUtils.updateRfqmJobAsync(job);\r\n                throw new Error('Invalid order signer address');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Submits a specific type of submission to the blockchain.\r\n     *\r\n     * First checks to see if there are previous transactions with the submission type and enters the\r\n     * watch loop; if not, submits an initial transaction and enters the watch loop.\r\n     *\r\n     * During the watch loop, waits for a transaction to be mined and confirmed;\r\n     * replaces the transaction if gas prices rise while a transactions are in the mempool.\r\n     *\r\n     * @param opts Options object that contains:\r\n     *        - `to`: The address to send to.\r\n     *        - `from`: The address submitting the transaction (usually the worker address).\r\n     *        - `calldata`: Calldata to submit.\r\n     *        - `expiry`: Exiry before the submission is considered invalid.\r\n     *        - `identifier`: The job identifier. For rfqm_v2_job, it should be order hash; for meta-transaction, it should be job id.\r\n     *        - `submissionType`: The type of submission.\r\n     *        - `onSubmissionContextStatusUpdate`: Callback to perform appropriate actions when the submission context statuses change.\r\n     *        - `now`: The current time.\r\n     * @returns FailedRevertedConfirmed or SucceededConfirmed.\r\n     * @throws Submission context status is FailedExpired or unhandled exceptions.\r\n     */\r\n    public async submitToChainAsync(opts: {\r\n        kind: (RfqmV2JobEntity | MetaTransactionJobEntity)['kind'];\r\n        to: string;\r\n        from: string;\r\n        calldata: string;\r\n        expiry: BigNumber;\r\n        identifier: string;\r\n        submissionType: RfqmTransactionSubmissionType;\r\n        onSubmissionContextStatusUpdate: (\r\n            newSubmissionContextStatus: SubmissionContextStatus,\r\n            oldSubmissionContextStatus?: SubmissionContextStatus,\r\n        ) => Promise<void>;\r\n    }): Promise<SubmissionContextStatus.FailedRevertedConfirmed | SubmissionContextStatus.SucceededConfirmed> {\r\n        const { kind, to, from, calldata, expiry, identifier, submissionType, onSubmissionContextStatusUpdate } = opts;\r\n\r\n        let previousSubmissionsWithPresubmits;\r\n        switch (kind) {\r\n            case 'rfqm_v2_job':\r\n                previousSubmissionsWithPresubmits = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(\r\n                    identifier,\r\n                    submissionType,\r\n                );\r\n                break;\r\n            case 'meta_transaction_job':\r\n                previousSubmissionsWithPresubmits = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(\r\n                    identifier,\r\n                    submissionType,\r\n                );\r\n                break;\r\n            default:\r\n                ((_x: never) => {\r\n                    throw new Error('unreachable');\r\n                })(kind);\r\n        }\r\n\r\n        const previousSubmissions = await this._recoverPresubmitTransactionsAsync(previousSubmissionsWithPresubmits);\r\n\r\n        const gasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();\r\n\r\n        // For the first submission, we use the \"fast\" gas estimate to approximate the base fee.\r\n        // We use the strategy outlined in https://www.blocknative.com/blog/eip-1559-fees --\r\n        // The `maxFeePerGas` is 2x the base fee (plus priority tip). Since we don't have a\r\n        // handy oracle for the en vogue priorty fee we start with 2 gwei and work up from there.\r\n        const initialMaxPriorityFeePerGas = new BigNumber(this._initialMaxPriorityFeePerGasGwei).times(\r\n            Math.pow(10, GWEI_DECIMALS),\r\n        );\r\n\r\n        let gasFees: GasFees = {\r\n            maxFeePerGas: BigNumber.min(\r\n                gasPriceEstimate.multipliedBy(2).plus(initialMaxPriorityFeePerGas),\r\n                this._maxFeePerGasCapWei,\r\n            ),\r\n            maxPriorityFeePerGas: initialMaxPriorityFeePerGas,\r\n        };\r\n\r\n        let submissionContext;\r\n        let nonce;\r\n        let gasEstimate;\r\n\r\n        if (!previousSubmissions.length) {\r\n            // There's an edge case here where there are previous submissions but they're all in `PRESUBMIT`.\r\n            // Those are filtered out if they can't be found on the blockchain so we end up here.\r\n            // If this occurs we need to check if the transaction is expired.\r\n            const nowSeconds = new BigNumber(new Date().getTime() / ONE_SECOND_MS);\r\n\r\n            if (expiry.isLessThan(nowSeconds)) {\r\n                await onSubmissionContextStatusUpdate(SubmissionContextStatus.FailedExpired);\r\n                throw new Error(`Exceed expiry ${expiry} for kind ${kind} and submission type ${submissionType}`);\r\n            }\r\n\r\n            logger.info({ kind, identifier, from }, 'Attempting to submit first transaction');\r\n            await onSubmissionContextStatusUpdate(SubmissionContextStatus.PendingSubmitted);\r\n\r\n            logger.info(\r\n                {\r\n                    kind,\r\n                    gasFees,\r\n                    gasPriceEstimate,\r\n                    identifier,\r\n                    submissionCount: 1,\r\n                    from,\r\n                    submissionType,\r\n                },\r\n                'Submitting transaction',\r\n            );\r\n\r\n            nonce = await this._blockchainUtils.getNonceAsync(from);\r\n            const gasEstimateWithoutBuffer = await this._blockchainUtils.estimateGasForAsync({\r\n                to,\r\n                from,\r\n                data: calldata,\r\n                // The following gas fee properties are added because `executeMetaTransaction` in 0x Exchange Proxy\r\n                // would check whether the gas price of the transaction is within a window. If left empty, it will\r\n                // fail the simulation.\r\n                maxFeePerGas: gasFees.maxFeePerGas.toString(),\r\n                maxPriorityFeePerGas: gasFees.maxPriorityFeePerGas.toString(),\r\n            });\r\n            // Add buffer to gas estimate returned by `eth_estimateGas` as the RPC method\r\n            // tends to under estimate gas usage\r\n            gasEstimate = Math.ceil((GAS_ESTIMATE_BUFFER + 1) * gasEstimateWithoutBuffer);\r\n            let accessListWithGas;\r\n\r\n            if (this._enableAccessList) {\r\n                try {\r\n                    accessListWithGas = await this._blockchainUtils.createAccessListForAsync({\r\n                        to,\r\n                        from,\r\n                        data: calldata,\r\n                    });\r\n                    RFQM_CREATE_ACCESS_LIST_REQUEST.labels(this._chainId.toString(), 'success').inc();\r\n                } catch (error) {\r\n                    RFQM_CREATE_ACCESS_LIST_REQUEST.labels(this._chainId.toString(), 'failure').inc();\r\n                    logger.warn({ kind, calldata, from }, 'Failed to create access list');\r\n                }\r\n\r\n                if (accessListWithGas !== undefined && accessListWithGas.gasEstimate) {\r\n                    // Add buffer to gas estimate returned by `eth_estimateGas` as the RPC method\r\n                    // tends to under estimate gas usage\r\n                    accessListWithGas.gasEstimate = Math.ceil(\r\n                        (GAS_ESTIMATE_BUFFER + 1) * accessListWithGas.gasEstimate,\r\n                    );\r\n\r\n                    logger.info(\r\n                        { gasEstimate, accessListGasEstimate: accessListWithGas.gasEstimate },\r\n                        'Regular gas estimate vs access list gas estimate',\r\n                    );\r\n                    RFQM_GAS_ESTIMATE_NO_ACCESS_LIST.labels(this._chainId.toString()).set(gasEstimate);\r\n                    RFQM_GAS_ESTIMATE_ACCESS_LIST.labels(this._chainId.toString()).set(accessListWithGas.gasEstimate);\r\n                }\r\n            }\r\n\r\n            const firstSubmission = await this._submitTransactionAsync(\r\n                kind,\r\n                identifier,\r\n                from,\r\n                calldata,\r\n                gasFees,\r\n                nonce,\r\n                gasEstimate,\r\n                submissionType,\r\n                to,\r\n            );\r\n\r\n            logger.info(\r\n                { kind, from, identifier, submissionType, transactionHash: firstSubmission.transactionHash },\r\n                'Successfully submitted transaction',\r\n            );\r\n\r\n            submissionContext = new SubmissionContext(this._blockchainUtils, [firstSubmission] as\r\n                | RfqmV2TransactionSubmissionEntity[]\r\n                | MetaTransactionSubmissionEntity[]);\r\n        } else {\r\n            logger.info({ kind, from, identifier, submissionType }, `Previous submissions found, recovering context`);\r\n            submissionContext = new SubmissionContext(this._blockchainUtils, previousSubmissions);\r\n            nonce = submissionContext.nonce;\r\n\r\n            // If we've already submitted a transaction and it has been mined,\r\n            // using `_blockchainUtils.estimateGasForAsync` will throw\r\n            // given the same calldata. In the edge case where a transaction has been sent\r\n            // but not mined, we would ideally pull the gas estimate from the previous\r\n            // transaction. Unfortunately, we currently do not store it on the\r\n            // `RfqmV2TransactionSubmissionEntity`. As a workaround, we'll just use an\r\n            // overestimate..\r\n            gasEstimate = MAX_GAS_ESTIMATE;\r\n        }\r\n\r\n        // The \"Watch Loop\"\r\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            // We've already submitted the transaction once at this point, so we first need to wait before checking the status.\r\n            await delay(this._transactionWatcherSleepTimeMs);\r\n            const oldSubmissionContextStatus = submissionContext.submissionContextStatus;\r\n            const newSubmissionContextStatus = await this._checkSubmissionReceiptsAndUpdateDbAsync(\r\n                identifier,\r\n                submissionContext,\r\n            );\r\n            logger.info(\r\n                { kind, submissionType, oldSubmissionContextStatus, newSubmissionContextStatus },\r\n                'Old and new submission context statuses',\r\n            );\r\n            await onSubmissionContextStatusUpdate(newSubmissionContextStatus, oldSubmissionContextStatus);\r\n\r\n            switch (newSubmissionContextStatus) {\r\n                case SubmissionContextStatus.PendingSubmitted:\r\n                    // We've put in at least one transaction but none have been mined yet.\r\n                    // Check to make sure we haven't passed the expiry window.\r\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n                    // eslint-disable-next-line no-case-declarations\r\n                    const nowSeconds = new BigNumber(new Date().getTime() / ONE_SECOND_MS);\r\n\r\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n                    // eslint-disable-next-line no-case-declarations\r\n                    const secondsPastExpiration = nowSeconds.minus(expiry);\r\n\r\n                    // If we're more than 120 seconds past expiration, give up.\r\n                    // See https://github.com/rolandkofler/blocktime for some\r\n                    // analysis of expected block times. Two minutes was selected\r\n                    // to cover most cases without locking up the worker for too long.\r\n                    if (secondsPastExpiration.isGreaterThan(ONE_MINUTE_S * 2)) {\r\n                        await onSubmissionContextStatusUpdate(\r\n                            SubmissionContextStatus.FailedExpired,\r\n                            oldSubmissionContextStatus,\r\n                        );\r\n                        throw new Error(\r\n                            `Exceed expiry ${expiry} for kind ${kind} and submission type ${submissionType}`,\r\n                        );\r\n                    }\r\n                    // If we're past expiration by less than a minute, don't put in any new transactions\r\n                    // but keep watching in case a receipt shows up\r\n                    if (secondsPastExpiration.isGreaterThan(0)) {\r\n                        continue;\r\n                    }\r\n\r\n                    // \"Fast\" gas price estimation; used to approximate the base fee\r\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n                    // eslint-disable-next-line no-case-declarations\r\n                    const newGasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();\r\n\r\n                    if (submissionContext.transactionType === 0) {\r\n                        throw new Error('Non-EIP-1559 transactions are not implemented');\r\n                    }\r\n\r\n                    // We don't wait for gas conditions to change. Rather, we increase the gas\r\n                    // based bid based onthe knowledge that time (and therefore blocks, theoretically)\r\n                    // has passed without a transaction being mined.\r\n\r\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n                    // eslint-disable-next-line no-case-declarations\r\n                    const { maxFeePerGas: oldMaxFeePerGas, maxPriorityFeePerGas: oldMaxPriorityFeePerGas } =\r\n                        submissionContext.maxGasFees;\r\n\r\n                    if (oldMaxFeePerGas.isGreaterThanOrEqualTo(this._maxFeePerGasCapWei)) {\r\n                        // If we've reached the max fee per gas we'd like to pay, just\r\n                        // continue watching the transactions to see if one gets mined.\r\n                        logger.info(\r\n                            { kind, submissionType, oldMaxFeePerGas, maxFeePerGasCap: this._maxFeePerGasCapWei },\r\n                            'Exceeds max fee per gas',\r\n                        );\r\n                        continue;\r\n                    }\r\n\r\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n                    // eslint-disable-next-line no-case-declarations\r\n                    const newMaxPriorityFeePerGas = oldMaxPriorityFeePerGas\r\n                        .multipliedBy(MAX_PRIORITY_FEE_PER_GAS_MULTIPLIER)\r\n                        .integerValue(BigNumber.ROUND_CEIL);\r\n\r\n                    // The RPC nodes still need at least a 0.1 increase in both values to accept the new transaction.\r\n                    // For the new max fee per gas, we'll take the maximum of a 0.1 increase from the last value\r\n                    // or the value from an increase in the base fee.\r\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n                    // eslint-disable-next-line no-case-declarations\r\n                    const newMaxFeePerGas = BigNumber.max(\r\n                        oldMaxFeePerGas.multipliedBy(MAX_FEE_PER_GAS_MULTIPLIER).integerValue(BigNumber.ROUND_CEIL),\r\n                        newGasPriceEstimate.multipliedBy(2).plus(newMaxPriorityFeePerGas),\r\n                    );\r\n\r\n                    gasFees = {\r\n                        maxFeePerGas: newMaxFeePerGas,\r\n                        maxPriorityFeePerGas: newMaxPriorityFeePerGas,\r\n                    };\r\n\r\n                    logger.info(\r\n                        {\r\n                            kind,\r\n                            gasFees,\r\n                            gasPriceEstimate,\r\n                            identifier,\r\n                            submissionCount: submissionContext.transactions.length + 1,\r\n                            from,\r\n                            submissionType,\r\n                        },\r\n                        'Submitting transaction',\r\n                    );\r\n\r\n                    try {\r\n                        const newTransaction = await this._submitTransactionAsync(\r\n                            kind,\r\n                            identifier,\r\n                            from,\r\n                            calldata,\r\n                            gasFees,\r\n                            nonce,\r\n                            gasEstimate,\r\n                            submissionType,\r\n                            to,\r\n                        );\r\n                        logger.info(\r\n                            {\r\n                                kind,\r\n                                from,\r\n                                identifier,\r\n                                transactionHash: newTransaction.transactionHash,\r\n                                submissionType,\r\n                            },\r\n                            'Successfully resubmited tx with higher gas price',\r\n                        );\r\n                        submissionContext.addTransaction(newTransaction);\r\n                    } catch (err) {\r\n                        const errorMessage = err.message;\r\n                        const isNonceTooLow = /nonce too low/.test(errorMessage);\r\n                        logger.warn(\r\n                            { from, kind, identifier, submissionType, errorMessage: err.message, isNonceTooLow },\r\n                            'Encountered an error re-submitting a tx',\r\n                        );\r\n                        if (isNonceTooLow) {\r\n                            logger.info(\r\n                                { from, kind, identifier, submissionType },\r\n                                'Ignore nonce too low error on re-submission. A previous submission was successful',\r\n                            );\r\n                            break;\r\n                        }\r\n\r\n                        // Rethrow on all other types of errors\r\n                        throw err;\r\n                    }\r\n                    break;\r\n\r\n                case SubmissionContextStatus.FailedRevertedUnconfirmed:\r\n                case SubmissionContextStatus.SucceededUnconfirmed:\r\n                    break;\r\n                case SubmissionContextStatus.FailedRevertedConfirmed:\r\n                case SubmissionContextStatus.SucceededConfirmed:\r\n                    return newSubmissionContextStatus;\r\n                default:\r\n                    ((_x: never) => {\r\n                        throw new Error('unreachable');\r\n                    })(newSubmissionContextStatus);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the callback function to supply to `submitToChainAsync`.\r\n     *\r\n     * Note that `job.status` would be updated to appropriate state by  the callback function according to old & new\r\n     * submission context status and submission type. There would be job status update ONLY IF the new and old submission\r\n     * context statuses differ.\r\n     *\r\n     * This function also \"closes over\" `job` so that it's accessible in the callback function. Refer the docstring of\r\n     * `RfqmTransactionSubmissionContextStatus` for more details on submission context.\r\n     *\r\n     * @param job A rfqm v2 job or a meta transactino job object.\r\n     * @param submissionType Type of submission.\r\n     * @returns Function would make appropriate update to job status according to submission context statuses and submission type.\r\n     */\r\n    private _getOnSubmissionContextStatusUpdateCallback(\r\n        job: RfqmV2JobEntity | MetaTransactionJobEntity,\r\n        submissionType: RfqmTransactionSubmissionType,\r\n    ): (\r\n        newSubmissionContextStatus: SubmissionContextStatus,\r\n        oldSubmissionContextStatus?: SubmissionContextStatus,\r\n    ) => Promise<void> {\r\n        return async (\r\n            newSubmissionContextStatus: SubmissionContextStatus,\r\n            oldSubmissionContextStatus?: SubmissionContextStatus,\r\n        ): Promise<void> => {\r\n            if (newSubmissionContextStatus !== oldSubmissionContextStatus) {\r\n                let newJobStatus: RfqmJobStatus;\r\n                switch (submissionType) {\r\n                    case RfqmTransactionSubmissionType.Approval:\r\n                        newJobStatus =\r\n                            SubmissionContext.approvalSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\r\n                        break;\r\n                    case RfqmTransactionSubmissionType.Trade:\r\n                        newJobStatus =\r\n                            SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);\r\n                        break;\r\n                    default:\r\n                        ((_x: never) => {\r\n                            throw new Error('unreachable');\r\n                        })(submissionType);\r\n                }\r\n\r\n                job.status = newJobStatus;\r\n                await this._dbUtils.updateRfqmJobAsync(job);\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Transaction Submissions, which may include transactions with the\r\n     * \"Presbumit\" status, and resolves or removes the \"Presubmit\" transactions.\r\n     *\r\n     * If there are previous submissions in the \"Presubmit\" state,\r\n     *\r\n     * For \"Presubmit\" transactions, we check to see if the transaction was actually sent to\r\n     * the mempool or not, as that is indeterminate. Depending on the result of the check, we\r\n     * update the status to \"Submitted\" or remove them from the submissions in memory.\r\n     * Note that we leave the transaction record present in the database so that if the worker\r\n     * dies again and the submission actually went through but was not found at the time of\r\n     * this check we can potentially recover it later.\r\n     */\r\n    private async _recoverPresubmitTransactionsAsync<\r\n        T extends RfqmV2TransactionSubmissionEntity[] | MetaTransactionSubmissionEntity[],\r\n    >(transactionSubmissions: T): Promise<T> {\r\n        // Any is so nasty -- https://dev.to/shadow1349/typescript-tip-of-the-week-generics-170g\r\n        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        const result: any = await Promise.all(\r\n            transactionSubmissions.map(async (transactionSubmission) => {\r\n                // If the transaction is any status other than \"Presubmit\" then we'll leave it\r\n                if (transactionSubmission.status !== RfqmTransactionSubmissionStatus.Presubmit) {\r\n                    return transactionSubmission;\r\n                }\r\n                // For transactions in presubmit, check the mempool and chain to see if they exist\r\n                const transactionResponse = await this._blockchainUtils.getTransactionAsync(\r\n                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n                    transactionSubmission.transactionHash!,\r\n                );\r\n                if (transactionResponse) {\r\n                    // If it does exist, update the status. If not, remove it.\r\n                    transactionSubmission.status = RfqmTransactionSubmissionStatus.Submitted;\r\n                    await this._dbUtils.updateRfqmTransactionSubmissionsAsync([transactionSubmission] as T);\r\n                    return transactionSubmission;\r\n                } else {\r\n                    return null;\r\n                }\r\n            }),\r\n        ).then((x) => x.filter(isDefined));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Check for receipts from the tx hashes and update databases with status of all tx's.\r\n     */\r\n    private async _checkSubmissionReceiptsAndUpdateDbAsync(\r\n        identifier: string,\r\n        submissionContext: SubmissionContext<RfqmV2TransactionSubmissionEntity[] | MetaTransactionSubmissionEntity[]>,\r\n    ): Promise<\r\n        | SubmissionContextStatus.PendingSubmitted\r\n        | SubmissionContextStatus.FailedRevertedConfirmed\r\n        | SubmissionContextStatus.FailedRevertedUnconfirmed\r\n        | SubmissionContextStatus.SucceededConfirmed\r\n        | SubmissionContextStatus.SucceededUnconfirmed\r\n    > {\r\n        // At most one tx can be mined, since they all have the same nonce.\r\n        const minedReceipt = await submissionContext.getReceiptAsync();\r\n\r\n        // If the tx hasn't been mined yet, there're no database updates to do.\r\n        if (!minedReceipt) {\r\n            return SubmissionContextStatus.PendingSubmitted;\r\n        }\r\n\r\n        // Attempt to publish the mining latency\r\n        try {\r\n            const { timestamp: minedBlockTimestampS } = await this._blockchainUtils.getBlockAsync(\r\n                minedReceipt.blockHash,\r\n            );\r\n            const firstSubmissionTimestampS = submissionContext.firstSubmissionTimestampS;\r\n            RFQM_MINING_LATENCY.labels(this._chainId.toString()).observe(\r\n                minedBlockTimestampS - firstSubmissionTimestampS,\r\n            );\r\n        } catch (e) {\r\n            logger.warn(\r\n                { orderHash: identifier, errorMessage: e.message, stack: e.stack },\r\n                'Failed to meter the mining latency',\r\n            );\r\n        }\r\n\r\n        await submissionContext.updateForReceiptAsync(minedReceipt);\r\n        await this._dbUtils.updateRfqmTransactionSubmissionsAsync(submissionContext.transactions);\r\n        return submissionContext.submissionContextStatus;\r\n    }\r\n\r\n    /**\r\n     * Determine transaction properties and submit a transaction\r\n     */\r\n    private async _submitTransactionAsync(\r\n        kind: (RfqmV2JobEntity | MetaTransactionJobEntity)['kind'],\r\n        identifier: string,\r\n        workerAddress: string,\r\n        callData: string,\r\n        gasFees: GasFees,\r\n        nonce: number,\r\n        gasEstimate: number,\r\n        submissionType: RfqmTransactionSubmissionType = RfqmTransactionSubmissionType.Trade,\r\n        to: string = this._blockchainUtils.getExchangeProxyAddress(),\r\n    ): Promise<RfqmV2TransactionSubmissionEntity | MetaTransactionSubmissionEntity> {\r\n        const txOptions = {\r\n            ...gasFees,\r\n            from: workerAddress,\r\n            to,\r\n            gas: gasEstimate,\r\n            nonce,\r\n            value: 0,\r\n        };\r\n\r\n        const transactionRequest = this._blockchainUtils.transformTxDataToTransactionRequest(\r\n            txOptions,\r\n            this._chainId,\r\n            callData,\r\n        );\r\n        const { signedTransaction, transactionHash } = await this._blockchainUtils.signTransactionAsync(\r\n            transactionRequest,\r\n        );\r\n\r\n        let partialEntity;\r\n        let transactionSubmissionEntity;\r\n        switch (kind) {\r\n            case 'rfqm_v2_job':\r\n                partialEntity = {\r\n                    ...gasFees,\r\n                    transactionHash,\r\n                    orderHash: identifier,\r\n                    createdAt: new Date(),\r\n                    from: workerAddress,\r\n                    to,\r\n                    nonce,\r\n                    status: RfqmTransactionSubmissionStatus.Presubmit,\r\n                    type: submissionType,\r\n                };\r\n                transactionSubmissionEntity = await this._dbUtils.writeV2RfqmTransactionSubmissionToDbAsync(\r\n                    partialEntity,\r\n                );\r\n                break;\r\n            case 'meta_transaction_job':\r\n                partialEntity = {\r\n                    ...gasFees,\r\n                    transactionHash,\r\n                    metaTransactionJobId: identifier,\r\n                    createdAt: new Date(),\r\n                    from: workerAddress,\r\n                    to,\r\n                    nonce,\r\n                    status: RfqmTransactionSubmissionStatus.Presubmit,\r\n                    type: submissionType,\r\n                };\r\n                transactionSubmissionEntity = await this._dbUtils.writeMetaTransactionSubmissionAsync(partialEntity);\r\n                break;\r\n            default:\r\n                ((_x: never) => {\r\n                    throw new Error('unreachable');\r\n                })(kind);\r\n        }\r\n\r\n        const transactionHashFromSubmit = await this._blockchainUtils.submitSignedTransactionAsync(signedTransaction);\r\n\r\n        if (transactionHash !== transactionHashFromSubmit) {\r\n            // This should never ever happen\r\n            logger.error(\r\n                { kind, submissionType, identifier, transactionHashFromSubmit, transactionHash },\r\n                'Mismatch between transaction hash calculated before submit and after submit',\r\n            );\r\n            throw new Error('Mismatch between transaction hash calculated before submit and after submit');\r\n        }\r\n\r\n        logger.info(\r\n            { kind, submissionType, identifier, workerAddress, transactionHash },\r\n            'Transaction calldata submitted to exchange proxy',\r\n        );\r\n\r\n        const updatedTransactionSubmission = [\r\n            {\r\n                ...transactionSubmissionEntity,\r\n                status: RfqmTransactionSubmissionStatus.Submitted,\r\n            },\r\n        ] as RfqmV2TransactionSubmissionEntity[] | MetaTransactionSubmissionEntity[];\r\n\r\n        await this._dbUtils.updateRfqmTransactionSubmissionsAsync(updatedTransactionSubmission);\r\n\r\n        let updatedEntity;\r\n        switch (kind) {\r\n            case 'rfqm_v2_job':\r\n                updatedEntity = await this._dbUtils.findV2TransactionSubmissionByTransactionHashAsync(\r\n                    transactionHashFromSubmit,\r\n                );\r\n                break;\r\n            case 'meta_transaction_job':\r\n                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me\r\n                // eslint-disable-next-line no-case-declarations\r\n                const updatedSubmissionEntities =\r\n                    await this._dbUtils.findMetaTransactionSubmissionsByTransactionHashAsync(\r\n                        transactionHashFromSubmit,\r\n                        submissionType,\r\n                    );\r\n                if (updatedSubmissionEntities.length !== 1) {\r\n                    // A transaction hash should never be submitted twice in our system. However, RFQ-562 mentioned cases like this could\r\n                    // happen in our system. Add more log and throw the error to surface it.\r\n                    logger.error(\r\n                        { kind, submissionType, transactionHash },\r\n                        'Transaction hash have been submitted not exactly once',\r\n                    );\r\n                    throw new Error('Transaction hash have been submitted not exactly once');\r\n                }\r\n\r\n                updatedEntity = updatedSubmissionEntities[0];\r\n                break;\r\n            default:\r\n                ((_x: never) => {\r\n                    throw new Error('unreachable');\r\n                })(kind);\r\n        }\r\n\r\n        if (!updatedEntity) {\r\n            // This should never happen -- we just saved it\r\n            throw new Error(\r\n                `Could not find updated entity with transaction hash ${transactionHashFromSubmit} of kind ${kind} and submission type ${submissionType}`,\r\n            );\r\n        }\r\n\r\n        return updatedEntity;\r\n    }\r\n}\r\n"],"version":3}