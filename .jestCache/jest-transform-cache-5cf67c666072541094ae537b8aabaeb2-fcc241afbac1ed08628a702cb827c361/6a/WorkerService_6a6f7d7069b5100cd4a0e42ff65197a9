9528e6a8cee9d154e111774e9754a88f
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerService = void 0;
// tslint:disable:max-file-line-count
const asset_swapper_1 = require("@0x/asset-swapper");
const protocol_utils_1 = require("@0x/protocol-utils");
const utils_1 = require("@0x/utils");
const web3_wrapper_1 = require("@0x/web3-wrapper");
const attempt_1 = require("@lifeomic/attempt");
const delay_1 = require("delay");
const prom_client_1 = require("prom-client");
const config_1 = require("../config");
const constants_1 = require("../core/constants");
const fee_utils_1 = require("../core/fee_utils");
const types_1 = require("../entities/types");
const logger_1 = require("../logger");
const quote_server_client_1 = require("../utils/quote_server_client");
const rfqm_db_utils_1 = require("../utils/rfqm_db_utils");
const signature_utils_1 = require("../utils/signature_utils");
const SubmissionContext_1 = require("../utils/SubmissionContext");
// https://stackoverflow.com/questions/47632622/typescript-and-filter-boolean
function isDefined(value) {
    return value !== null && value !== undefined;
}
const RFQM_WORKER_BALANCE = new prom_client_1.Gauge({
    name: 'rfqm_worker_balance',
    labelNames: ['address', 'chain_id'],
    help: 'Worker balance for RFQM',
});
const RFQM_WORKER_READY = new prom_client_1.Counter({
    name: 'rfqm_worker_ready',
    labelNames: ['address', 'chain_id'],
    help: 'A worker passed the readiness check, and is ready to pick up work',
});
const RFQM_WORKER_NOT_READY = new prom_client_1.Counter({
    name: 'rfqm_worker_not_ready',
    labelNames: ['address', 'chain_id'],
    help: 'A worker did not pass the readiness check, and was not able to pick up work',
});
const RFQM_JOB_REPAIR = new prom_client_1.Gauge({
    name: 'rfqm_job_to_repair',
    labelNames: ['address', 'chain_id'],
    help: 'A submitted job failed and started repair mode',
});
const RFQM_JOB_FAILED_MM_SIGNATURE_FAILED = new prom_client_1.Counter({
    name: 'rfqm_job_failed_mm_signature_failed',
    help: 'A job failed because the market maker signature process failed. NOT triggered when the MM declines to sign.',
    labelNames: ['makerUri', 'chain_id'],
});
const RFQM_JOB_MM_REJECTED_LAST_LOOK = new prom_client_1.Counter({
    name: 'rfqm_job_mm_rejected_last_look',
    help: 'A job rejected by market maker on last look',
    labelNames: ['makerUri', 'chain_id'],
});
const RFQM_PROCESS_JOB_LATENCY = new prom_client_1.Summary({
    name: 'rfqm_process_job_latency',
    labelNames: ['chain_id', 'job_kind'],
    help: 'Latency for the worker processing the job',
});
const RFQM_JOB_COMPLETED = new prom_client_1.Counter({
    name: 'rfqm_job_completed',
    help: 'An Rfqm Job completed with no errors',
    labelNames: ['address', 'chain_id', 'job_kind'],
});
const RFQM_JOB_COMPLETED_WITH_ERROR = new prom_client_1.Counter({
    name: 'rfqm_job_completed_with_error',
    help: 'An Rfqm Job completed with an error',
    labelNames: ['address', 'chain_id', 'job_kind'],
});
const RFQM_CREATE_ACCESS_LIST_REQUEST = new prom_client_1.Counter({
    name: 'rfqm_create_access_list_request_total',
    help: 'Number of requests for eth_createAccessList call',
    labelNames: ['chain_id', 'status'],
});
const RFQM_GAS_ESTIMATE_ACCESS_LIST = new prom_client_1.Gauge({
    name: 'rfqm_gas_estimate_acess_list',
    help: 'Gas estimate of transaction with access list',
    labelNames: ['chain_id'],
});
const RFQM_GAS_ESTIMATE_NO_ACCESS_LIST = new prom_client_1.Gauge({
    name: 'rfqm_gas_estimate_no_access_list',
    help: 'Gas estimate of transaction without access list',
    labelNames: ['chain_id'],
});
const RFQM_SIGNED_QUOTE_EXPIRY_TOO_SOON = new prom_client_1.Counter({
    name: 'rfqm_signed_quote_expiry_too_soon',
    labelNames: ['chain_id'],
    help: 'A signed quote was not queued because it would expire too soon',
});
const RFQM_MINING_LATENCY = new prom_client_1.Summary({
    name: 'rfqm_mining_latency',
    labelNames: ['chain_id'],
    help: 'The time in seconds between when the first transaction for a job is sent and when a transaction for the job is mined',
});
const PRICE_DECIMAL_PLACES = 6;
const MIN_GAS_PRICE_INCREASE = 0.1;
// Retrying an EIP 1559 transaction: https://docs.alchemy.com/alchemy/guides/eip-1559/retry-eip-1559-tx
const MAX_PRIORITY_FEE_PER_GAS_MULTIPLIER = 1.5; // Increase multiplier for tip with each resubmission cycle
const MAX_FEE_PER_GAS_MULTIPLIER = 1.1; // Increase multiplier in max fee per gas with each cycle; limitation of geth node
// During recovery, we may not be able to successfully execute
// `estimateGasForAsync`. In this case we use this value.
const MAX_GAS_ESTIMATE = 500000;
const SIMULATION_MAX_GAS_MULTIPLIER = 2; // Multiplier of configured max fee when performing transaction simulation
// How often the worker should publish a heartbeat
const WORKER_HEARTBEAT_FREQUENCY_MS = constants_1.ONE_SECOND_MS * 30; // tslint:disable-line: custom-no-magic-numbers
/**
 * The service layer for Gasless Workers.
 *
 * Workers are bots with their own EOAs which pull
 * messages off an SQS queue, retrieve the related
 * job, and submit that job to the blockchain.
 */
class WorkerService {
    constructor(_chainId, _gasStationAttendant, _registryAddress, _blockchainUtils, _dbUtils, _quoteServerClient, _transactionWatcherSleepTimeMs, _cacheClient, _rfqMakerBalanceCacheService, _rfqMakerManager, _initialMaxPriorityFeePerGasGwei, maxFeePerGasCapGwei, _enableAccessList) {
        this._chainId = _chainId;
        this._gasStationAttendant = _gasStationAttendant;
        this._registryAddress = _registryAddress;
        this._blockchainUtils = _blockchainUtils;
        this._dbUtils = _dbUtils;
        this._quoteServerClient = _quoteServerClient;
        this._transactionWatcherSleepTimeMs = _transactionWatcherSleepTimeMs;
        this._cacheClient = _cacheClient;
        this._rfqMakerBalanceCacheService = _rfqMakerBalanceCacheService;
        this._rfqMakerManager = _rfqMakerManager;
        this._initialMaxPriorityFeePerGasGwei = _initialMaxPriorityFeePerGasGwei;
        this._enableAccessList = _enableAccessList;
        this._lastHeartbeatTime = null;
        this._maxFeePerGasCapWei = new utils_1.BigNumber(maxFeePerGasCapGwei).times(Math.pow(10, constants_1.GWEI_DECIMALS));
    }
    static shouldResubmitTransaction(gasFees, gasPriceEstimate) {
        // Geth only allows replacement of transactions if the replacement gas price
        // is at least 10% higher than the gas price of the transaction being replaced
        return gasPriceEstimate.gte(gasFees.maxFeePerGas.multipliedBy(MIN_GAS_PRICE_INCREASE + 1));
    }
    // Returns a failure status for an invalid rfqm v2 job or null if job is valid.
    static validateRfqmV2Job(job, now = new Date()) {
        const { makerUri, order, fee } = job;
        if (makerUri === undefined) {
            return types_1.RfqmJobStatus.FailedValidationNoMakerUri;
        }
        if (order === null) {
            return types_1.RfqmJobStatus.FailedValidationNoOrder;
        }
        if (fee === null) {
            return types_1.RfqmJobStatus.FailedValidationNoFee;
        }
        // Orders can expire if any of the following happen:
        // 1) workers are backed up
        // 2) an RFQM order broke during submission and the order is stuck in the queue for a long time.
        const otcOrderStringFields = job.order.order;
        const { expiry } = protocol_utils_1.OtcOrder.parseExpiryAndNonce(new utils_1.BigNumber(otcOrderStringFields.expiryAndNonce));
        const expiryTimeMs = expiry.times(constants_1.ONE_SECOND_MS);
        if (expiryTimeMs.isNaN() || expiryTimeMs.lte(now.getTime())) {
            return types_1.RfqmJobStatus.FailedExpired;
        }
        if (!job.takerSignature) {
            return types_1.RfqmJobStatus.FailedValidationNoTakerSignature;
        }
        return null;
    }
    // Returns a failure status for an invalid meta-transaction job or null if job is valid.
    static validateMetaTransactionJob(job, now = new Date()) {
        const { expiry, fee, metaTransaction, takerSignature } = job;
        if (metaTransaction === null) {
            return types_1.RfqmJobStatus.FailedValidationNoOrder;
        }
        if (fee === null) {
            return types_1.RfqmJobStatus.FailedValidationNoFee;
        }
        // Orders can expire if any of the following happen:
        // 1) workers are backed up
        // 2) an order broke during submission and the order is stuck in the queue for a long time.
        const expiryTimeMs = expiry.times(constants_1.ONE_SECOND_MS);
        if (expiryTimeMs.isNaN() || expiryTimeMs.lte(now.getTime())) {
            return types_1.RfqmJobStatus.FailedExpired;
        }
        if (!takerSignature) {
            return types_1.RfqmJobStatus.FailedValidationNoTakerSignature;
        }
        return null;
    }
    async workerBeforeLogicAsync(workerIndex, workerAddress) {
        let gasPrice;
        try {
            gasPrice = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();
        }
        catch (error) {
            logger_1.logger.error({ errorMessage: error.message }, 'Current gas price is unable to be fetched, marking worker as not ready.');
            RFQM_WORKER_NOT_READY.labels(workerAddress, this._chainId.toString()).inc();
            return false;
        }
        const balance = await this._blockchainUtils.getAccountBalanceAsync(workerAddress);
        const balanceUnitAmount = web3_wrapper_1.Web3Wrapper.toUnitAmount(balance, constants_1.ETH_DECIMALS).decimalPlaces(PRICE_DECIMAL_PLACES);
        RFQM_WORKER_BALANCE.labels(workerAddress, this._chainId.toString()).set(balanceUnitAmount.toNumber());
        // check for outstanding jobs from the worker and resolve them
        const unresolvedJobs = await Promise.all([
            this._dbUtils.findV2UnresolvedJobsAsync(workerAddress, this._chainId),
            this._dbUtils.findUnresolvedMetaTransactionJobsAsync(workerAddress, this._chainId),
        ]).then((x) => x.flat());
        RFQM_JOB_REPAIR.labels(workerAddress, this._chainId.toString()).inc(unresolvedJobs.length);
        for (const job of unresolvedJobs) {
            const { kind } = job;
            let jobIdentifier;
            switch (kind) {
                case 'rfqm_v2_job':
                    jobIdentifier = job.orderHash;
                    break;
                case 'meta_transaction_job':
                    jobIdentifier = job.id;
                    break;
                default:
                    ((_x) => {
                        throw new Error('Unreachable');
                    })(kind);
            }
            logger_1.logger.info({ kind, jobIdentifier, workerAddress }, `Unresolved job found, attempting to reprocess`);
            await this.processJobAsync(jobIdentifier, workerAddress, kind);
        }
        const isWorkerReady = await this._blockchainUtils.isWorkerReadyAsync(this._chainId, workerAddress, balance, utils_1.BigNumber.min(gasPrice, this._maxFeePerGasCapWei));
        if (!isWorkerReady) {
            RFQM_WORKER_NOT_READY.labels(workerAddress, this._chainId.toString()).inc();
            return false;
        }
        if (this._lastHeartbeatTime && Date.now() - this._lastHeartbeatTime.getTime() < WORKER_HEARTBEAT_FREQUENCY_MS) {
            return true;
        }
        // Publish a heartbeat if the worker is ready to go
        try {
            if (workerIndex === undefined) {
                throw new Error('Worker index is undefined');
            }
            // NOTE: when merging with `feature/multichain`, update this line with
            // `const chainId = this._chain.chainId.
            const chainId = this._chainId;
            await this._dbUtils.upsertRfqmWorkerHeartbeatToDbAsync(workerAddress, workerIndex, balance, chainId);
            this._lastHeartbeatTime = new Date();
        }
        catch (error) {
            logger_1.logger.error({ workerAddress, balance, errorMessage: error.message }, 'Worker failed to write a heartbeat to storage');
        }
        RFQM_WORKER_READY.labels(workerAddress, this._chainId.toString()).inc();
        return true;
    }
    /**
     * Top-level logic the worker uses to take a v2 job or meta-transaction job to completion.
     * The identifier (orderHash for v2 job and jod id for meta-transaction job) can come from
     * either an unfinished job found during the worker before logic or from an SQS message.
     *
     * Big picture steps:
     * 1. Fetch the job from the database
     * 2. Prepare the job by validating it (and getting the market maker signature for v2 job).
     *    This step is different for v2 and meta-transaction jobs.
     * 3. Submit a transaction if none exist, wait for mining + confirmation,
     *    and submit new transactions if gas prices rise
     * 4. Finalize the job status
     *
     * This function is the error boundary for job processing; errors will be caught, logged
     * and swallowed. The worker will continue along its lifecycle.
     *
     * This function handles processing latency metrics & job success/fail counters.
     */
    async processJobAsync(identifier, workerAddress, kind = 'rfqm_v2_job') {
        logger_1.logger.info({ kind, identifier, workerAddress }, 'Start process job');
        const timerStopFunction = RFQM_PROCESS_JOB_LATENCY.labels(this._chainId.toString(), kind).startTimer();
        try {
            // Step 1: Find the job
            let job;
            switch (kind) {
                case 'rfqm_v2_job':
                    job = await this._dbUtils.findV2JobByOrderHashAsync(identifier);
                    break;
                case 'meta_transaction_job':
                    job = await this._dbUtils.findMetaTransactionJobByIdAsync(identifier);
                    break;
                default:
                    ((_x) => {
                        throw new Error('unreachable');
                    })(kind);
            }
            if (!job) {
                throw new Error('No job found for identifier');
            }
            // Step 2: Prepare the job for submission
            // Claim job for worker
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-extra-non-null-assertion
            if (job.workerAddress && job.workerAddress !== workerAddress) {
                throw new Error('Worker was sent a job claimed by a different worker');
            }
            job.workerAddress = workerAddress;
            await this._dbUtils.updateRfqmJobAsync(job);
            if (job.approval) {
                // approval and trade workflow
                await this.processApprovalAndTradeAsync(job, workerAddress);
            }
            else {
                // trade only workflow
                await this.processTradeAsync(job, workerAddress);
            }
            logger_1.logger.info({ kind, identifier, workerAddress }, 'Job completed without errors');
            RFQM_JOB_COMPLETED.labels(workerAddress, this._chainId.toString(), kind).inc();
        }
        catch (error) {
            logger_1.logger.error({ kind, workerAddress, identifier, errorMessage: error.message }, 'Job completed with error');
            RFQM_JOB_COMPLETED_WITH_ERROR.labels(workerAddress, this._chainId.toString(), kind).inc();
        }
        finally {
            timerStopFunction();
        }
    }
    /**
     * Process approval (gasless approval) and trade (swap with the 0x exchange proxy) submissions. For the first version,
     * they will be processed SEQUENTIALLY. In the future, we want to send the two transaction in parallel.
     * The reason we can't parallelize the submissions is both function would modify job.status.
     *
     * The method would:
     * 1. Perform preliminary check on the job object (and updates job status to `PendingProcessing`)
     * 2. Getting the market maker signature
     * 3. Prepare approval
     * 4. Submit approval
     * 5. Wait until the approval transaction is successfully confirmed
     * 6. Prepare trade (since the method has already got the market maker signature, it's not performed here)
     * 7. Submit trade
     */
    async processApprovalAndTradeAsync(job, workerAddress) {
        const { approval, approvalSignature, kind } = job;
        if (!approval || !approvalSignature) {
            throw new Error('Non-approval job should not be processed by `processApprovalAndTradeAsync`');
        }
        // Perform preliminary check
        await this.checkJobPreprocessingAsync(job);
        if (kind === 'rfqm_v2_job') {
            // Perform last look for rfqm v2 job
            await this.checkLastLookAsync(job, workerAddress, false);
        }
        let tokenToApprove;
        let identifier;
        switch (kind) {
            case 'rfqm_v2_job':
                tokenToApprove = job.order.order.takerToken;
                identifier = job.orderHash;
                break;
            case 'meta_transaction_job':
                tokenToApprove = job.inputToken;
                identifier = job.id;
                break;
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(kind);
        }
        const approvalCalldata = await this.prepareApprovalAsync(job, tokenToApprove, approval, approvalSignature);
        const approvalStatus = await this.submitToChainAsync({
            kind: job.kind,
            to: tokenToApprove,
            from: workerAddress,
            calldata: approvalCalldata,
            expiry: job.expiry,
            identifier,
            submissionType: types_1.RfqmTransactionSubmissionType.Approval,
            onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(job, types_1.RfqmTransactionSubmissionType.Approval),
        });
        // Prepare and submit trade only if approval transaction is successful
        if (approvalStatus === types_1.SubmissionContextStatus.SucceededConfirmed) {
            let tradeCalldata;
            switch (kind) {
                case 'rfqm_v2_job':
                    tradeCalldata = await this.preparerfqmV2TradeAsync(job, workerAddress, false);
                    break;
                case 'meta_transaction_job':
                    tradeCalldata = await this.prepareMetaTransactionTradeAsync(job, workerAddress, false);
                    break;
                default:
                    ((_x) => {
                        throw new Error('unreachable');
                    })(kind);
            }
            await this.submitToChainAsync({
                kind: job.kind,
                to: this._blockchainUtils.getExchangeProxyAddress(),
                from: workerAddress,
                calldata: tradeCalldata,
                expiry: job.expiry,
                identifier,
                submissionType: types_1.RfqmTransactionSubmissionType.Trade,
                onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(job, types_1.RfqmTransactionSubmissionType.Trade),
            });
        }
    }
    /**
     * Process trade (swap with the 0x exchange proxy) submissions. The method would prepare trade calldata
     * and submit the trade to the blockchain. Note that job status would be updated to the corresponding state.
     */
    async processTradeAsync(job, workerAddress) {
        const { kind } = job;
        let calldata;
        let identifier;
        switch (kind) {
            case 'rfqm_v2_job':
                identifier = job.orderHash;
                calldata = await this.preparerfqmV2TradeAsync(job, workerAddress);
                break;
            case 'meta_transaction_job':
                identifier = job.id;
                calldata = await this.prepareMetaTransactionTradeAsync(job, workerAddress);
                break;
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(kind);
        }
        await this.submitToChainAsync({
            kind: job.kind,
            to: this._blockchainUtils.getExchangeProxyAddress(),
            from: workerAddress,
            calldata,
            expiry: job.expiry,
            identifier,
            submissionType: types_1.RfqmTransactionSubmissionType.Trade,
            onSubmissionContextStatusUpdate: this._getOnSubmissionContextStatusUpdateCallback(job, types_1.RfqmTransactionSubmissionType.Trade),
        });
    }
    /**
     * Perform preliminary checks on a job before processing.
     *
     * The method would:
     * 1. Call `RfqmService.validateRfqmV2Job` / `RfqmService.validateMetaTransactionJob` and check result. If there is an error, update the job status and throw exception
     * 2. Make sure job.takerSignature is present or throw exception
     * 3. Update job status to `PendingProcessing` if current status is `PendingEnqueued`
     */
    async checkJobPreprocessingAsync(job, now = new Date()) {
        const { kind, takerSignature } = job;
        let identifier;
        let errorStatus;
        switch (kind) {
            case 'rfqm_v2_job':
                identifier = job.orderHash;
                errorStatus = WorkerService.validateRfqmV2Job(job, now);
                break;
            case 'meta_transaction_job':
                identifier = job.id;
                errorStatus = WorkerService.validateMetaTransactionJob(job, now);
                break;
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(kind);
        }
        if (errorStatus !== null) {
            job.status = errorStatus;
            await this._dbUtils.updateRfqmJobAsync(job);
            if (errorStatus === types_1.RfqmJobStatus.FailedExpired) {
                RFQM_SIGNED_QUOTE_EXPIRY_TOO_SOON.labels(this._chainId.toString()).inc();
            }
            logger_1.logger.error({ kind, identifier, errorStatus }, 'Job failed validation');
            throw new Error('Job failed validation');
        }
        // Existence of taker signature has already been checked by
        // `RfqmService.validateJob(job)`. Refine the type.
        if (!takerSignature) {
            throw new Error('No taker signature present');
        }
        if (job.status === types_1.RfqmJobStatus.PendingEnqueued) {
            job.status = types_1.RfqmJobStatus.PendingProcessing;
            await this._dbUtils.updateRfqmJobAsync(job);
        }
    }
    /**
     * Prepares a rfqm v2 / meta-transaction job for approval submission by validatidating the job and constructing
     * the calldata.
     *
     * Note that `job.status` would be modified to `FailedEthCallFailed` if transaction simulation failed.
     *
     * Handles retries of retryable errors. Throws for unretriable errors. Updates job in database.
     *
     * @returns The generated calldata for approval submission type.
     * @throws If the approval cannot be submitted (e.g. it is expired).
     */
    async prepareApprovalAsync(job, tokenToApprove, approval, siganature) {
        const { kind } = job;
        const calldata = await this._blockchainUtils.generateApprovalCalldataAsync(tokenToApprove, approval, siganature);
        let identifier;
        let transactionSubmissions;
        // Check to see if we have already submitted an approval transaction for this job. If we have, the job has already
        // been checked and we can skip `eth_call` validation.
        switch (kind) {
            case 'rfqm_v2_job':
                identifier = job.orderHash;
                transactionSubmissions = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(identifier, types_1.RfqmTransactionSubmissionType.Approval);
                break;
            case 'meta_transaction_job':
                identifier = job.id;
                transactionSubmissions = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(identifier, types_1.RfqmTransactionSubmissionType.Approval);
                break;
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(kind);
        }
        if (transactionSubmissions.length) {
            if (!job.takerSignature) {
                // This shouldn't happen
                throw new Error('Encountered a job with submissions but no taker signature');
            }
            if (job.kind === 'rfqm_v2_job' && !job.makerSignature) {
                // This shouldn't happen
                throw new Error('Encountered a job with submissions but no maker signature');
            }
            return calldata;
        }
        // Simulate the transaction
        try {
            await (0, attempt_1.retry)(async () => {
                // Use `estimateGasForAsync` to simulate the transaction. In ethers.js, provider.call and
                // provider.send('eth_call', ...) might not throw exception and the behavior might be dependent
                // on providers. Revisit this later
                return this._blockchainUtils.estimateGasForAsync({ to: tokenToApprove, data: calldata });
            }, {
                delay: constants_1.ONE_SECOND_MS,
                factor: 1,
                maxAttempts: 3,
                handleError: (error, context, _options) => {
                    const { attemptNum: attemptNumber, attemptsRemaining } = context;
                    logger_1.logger.warn({ kind, attemptNumber, attemptsRemaining, errorMessage: error.message, stack: error.stack }, 'Error during eth_call approval validation. Retrying.');
                },
            });
        }
        catch (error) {
            job.status = types_1.RfqmJobStatus.FailedEthCallFailed;
            await this._dbUtils.updateRfqmJobAsync(job);
            logger_1.logger.error({ kind, identifier, errorMessage: error.message, stack: error.stack }, 'eth_call approval validation failed');
            throw new Error('Eth call approval validation failed');
        }
        return calldata;
    }
    /**
     * Prepares an RfqmV2 Job for trade submission by validatidating the job, obtaining the
     * market maker signature, and constructing the calldata.
     *
     * Note that `job.status` would be modified to corresponding status. For example, if maker signature
     * is not valid, `job.status` would be set to `FailedSignFailed`.
     *
     * `shouldCheckLastLook` determines if the preliminary job check and getting market maker sigature
     * would be performed and is default to `true`.
     *
     * Handles retries of retryable errors. Throws for unretriable errors, and logs
     * ONLY IF the log needs more information than the orderHash and workerAddress,
     * which are logged by the `processJobAsync` routine.
     * Updates job in database.
     *
     * @returns The generated calldata for trade submission type.
     * @throws If the trade cannot be submitted (e.g. it is expired).
     */
    async preparerfqmV2TradeAsync(job, workerAddress, 
    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
    // eslint-disable-next-line @typescript-eslint/no-inferrable-types
    shouldCheckLastLook = true, now = new Date()) {
        /**
         * Ask: This is the probably the only change I made to the old trade only workflow. To change from making a copy of parameter
         * and then returning the copied value to change parameter value directly. The rationale behind is to make the style consistent
         * with the new generalized `submitToChainAsync` (it has to use changing parameter value paradigm in order to work). Let me know
         * if you don't like this change.
         */
        const { makerUri, order, orderHash } = job;
        const otcOrder = (0, rfqm_db_utils_1.storedOtcOrderToOtcOrder)(order);
        // Check to see if we have already submitted a transaction for this job.
        // If we have, the job is already prepared and we can skip ahead.
        const transactionSubmissions = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(job.orderHash);
        if (transactionSubmissions.length) {
            if (!job.makerSignature) {
                // This shouldn't happen
                throw new Error('Encountered a job with submissions but no maker signature');
            }
            if (!job.takerSignature) {
                // This shouldn't happen
                throw new Error('Encountered a job with submissions but no taker signature');
            }
            const existingSubmissionCalldata = this._blockchainUtils.generateTakerSignedOtcOrderCallData(otcOrder, job.makerSignature, job.takerSignature, job.isUnwrap, job.affiliateAddress);
            return existingSubmissionCalldata;
        }
        if (shouldCheckLastLook) {
            // Perform the preliminary job check and getting market maker sigature
            await this.checkJobPreprocessingAsync(job, now);
            await this.checkLastLookAsync(job, workerAddress, true);
        }
        // Maker signature must already be defined here -- refine the type
        if (!job.makerSignature) {
            throw new Error('Maker signature does not exist');
        }
        // Taker signature must already be defined here -- refine the type
        if (!job.takerSignature) {
            throw new Error('Taker signature does not exist');
        }
        // Verify the signer was the maker
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const signerAddress = (0, signature_utils_1.getSignerFromHash)(orderHash, job.makerSignature).toLowerCase();
        const makerAddress = order.order.maker.toLowerCase();
        if (signerAddress !== makerAddress) {
            logger_1.logger.info({ signerAddress, makerAddress, orderHash, makerUri }, 'Possible use of smart contract wallet');
            const isValidSigner = await this._blockchainUtils.isValidOrderSignerAsync(makerAddress, signerAddress);
            if (!isValidSigner) {
                job.status = types_1.RfqmJobStatus.FailedSignFailed;
                await this._dbUtils.updateRfqmJobAsync(job);
                throw new Error('Invalid order signer address');
            }
        }
        // Generate the calldata
        const calldata = this._blockchainUtils.generateTakerSignedOtcOrderCallData(otcOrder, job.makerSignature, job.takerSignature, job.isUnwrap, job.affiliateAddress);
        // With the Market Maker signature, execute a full eth_call to validate the
        // transaction via `estimateGasForFillTakerSignedOtcOrderAsync`
        try {
            await (0, attempt_1.retry)(async () => {
                // Maker signature must already be defined here -- refine the type
                if (!job.makerSignature) {
                    throw new Error('Maker signature does not exist');
                }
                // Taker signature must already be defined here -- refine the type
                if (!job.takerSignature) {
                    throw new Error('Taker signature does not exist');
                }
                return this._blockchainUtils.estimateGasForFillTakerSignedOtcOrderAsync(otcOrder, job.makerSignature, job.takerSignature, workerAddress, job.isUnwrap);
            }, {
                delay: constants_1.ONE_SECOND_MS,
                factor: 1,
                maxAttempts: 3,
                handleError: (error, context, _options) => {
                    const { attemptNum: attemptNumber, attemptsRemaining } = context;
                    logger_1.logger.warn({ orderHash, makerUri, attemptNumber, attemptsRemaining, error: error.message }, 'Error during eth_call validation when preparing otc order trade. Retrying');
                },
            });
        }
        catch (error) {
            job.status = types_1.RfqmJobStatus.FailedEthCallFailed;
            await this._dbUtils.updateRfqmJobAsync(job);
            logger_1.logger.error({ orderHash, error: error.message }, 'eth_call validation failed when preparing otc order trade');
            // Attempt to gather extra context upon eth_call failure
            try {
                const [makerBalance] = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(this._chainId, { owner: otcOrder.maker, token: otcOrder.makerToken });
                const [takerBalance] = await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync({
                    owner: otcOrder.taker,
                    token: otcOrder.takerToken,
                });
                const blockNumber = await this._blockchainUtils.getCurrentBlockAsync();
                logger_1.logger.info({
                    makerBalance,
                    takerBalance,
                    calldata,
                    blockNumber,
                    orderHash,
                    order: otcOrder,
                    bucket: otcOrder.nonceBucket,
                    nonce: otcOrder.nonce,
                }, 'Extra context after eth_call validation failed when preparing otc order trade');
            }
            catch (error) {
                logger_1.logger.warn({ orderHash }, 'Failed to get extra context after eth_call validation failed when preparing otc order trade');
            }
            throw new Error('Eth call validation failed when preparing otc order trade');
        }
        return calldata;
    }
    /**
     * Prepares a meta-transaction job for trade submission by validatidating the job and constructing the calldata.
     *
     * Note that `job.status` would be modified to corresponding status. For example, if the meta-transaction expires,
     * `job.status` would be set to `FailedFailedExpired`.
     *
     * Handles retries of retryable errors. Throws for unretriable errors, and logs
     * ONLY IF the log needs more information than the orderHash and workerAddress,
     * which are logged by the `processJobAsync` routine.
     * Updates job in database.
     *
     * @returns The generated calldata for trade submission type.
     * @throws If the trade cannot be submitted (e.g. it is expired).
     */
    async prepareMetaTransactionTradeAsync(job, workerAddress, 
    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
    // eslint-disable-next-line @typescript-eslint/no-inferrable-types
    shouldValidateJob = true, now = new Date()) {
        // ASK: What's the difference bewtween `metaTransaction.signer` vs `metaTransaction.sender`?
        //      Which one is the taker address?
        const { affiliateAddress, id: jobId, inputToken, metaTransaction, takerAddress, takerSignature } = job;
        // Check to see if we have already submitted a transaction for this job.
        // If we have, the job is already prepared and we can skip ahead.
        const transactionSubmissions = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(jobId);
        if (transactionSubmissions.length) {
            if (!takerSignature) {
                // This shouldn't happen
                throw new Error('Encountered a job with submissions but no taker signature');
            }
            const existingSubmissionCalldata = this._blockchainUtils.generateMetaTransactionCallData(metaTransaction, takerSignature, affiliateAddress);
            return existingSubmissionCalldata;
        }
        if (shouldValidateJob) {
            // Perform the preliminary job check
            await this.checkJobPreprocessingAsync(job, now);
        }
        // Taker signature must already be defined here -- refine the type
        if (!takerSignature) {
            throw new Error('Taker signature does not exist');
        }
        // Generate the calldata
        const calldata = this._blockchainUtils.generateMetaTransactionCallData(metaTransaction, takerSignature, affiliateAddress);
        // execute a full eth_call to validate the
        // transaction via `estimateGasForAsync`
        try {
            await (0, attempt_1.retry)(async () => {
                // The following gas fee operations are added because `executeMetaTransaction` in 0x Exchange Proxy
                // would check whether the gas price of the transaction is within a window. If left empty, it will
                // fail the simulation. The gas fee estimation below is the same as the first gas fee estimation
                // used in `submitToChain`.
                const gasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();
                const initialMaxPriorityFeePerGas = new utils_1.BigNumber(this._initialMaxPriorityFeePerGasGwei).times(Math.pow(10, constants_1.GWEI_DECIMALS));
                const gasFees = {
                    maxFeePerGas: utils_1.BigNumber.min(gasPriceEstimate.multipliedBy(2).plus(initialMaxPriorityFeePerGas), 
                    // If the max fee is less than the base fee, simulations will fail (unlike submissions, which may sit in the mempool).
                    // An extra multiplier mitigates, but does not solve, the issue.
                    this._maxFeePerGasCapWei.multipliedBy(SIMULATION_MAX_GAS_MULTIPLIER)),
                    maxPriorityFeePerGas: initialMaxPriorityFeePerGas,
                };
                return this._blockchainUtils.estimateGasForAsync({
                    from: workerAddress,
                    to: this._blockchainUtils.getExchangeProxyAddress(),
                    data: calldata,
                    maxFeePerGas: gasFees.maxFeePerGas.toString(),
                    maxPriorityFeePerGas: gasFees.maxPriorityFeePerGas.toString(),
                });
            }, {
                delay: constants_1.ONE_SECOND_MS,
                factor: 1,
                maxAttempts: 3,
                handleError: (error, context, _options) => {
                    const { attemptNum: attemptNumber, attemptsRemaining } = context;
                    logger_1.logger.warn({ jobId, attemptNumber, attemptsRemaining, error: error.message }, 'Error during eth_call validation when preparing meta-transaction trade. Retrying');
                },
            });
        }
        catch (error) {
            job.status = types_1.RfqmJobStatus.FailedEthCallFailed;
            await this._dbUtils.updateRfqmJobAsync(job);
            logger_1.logger.error({ jobId, error: error.message }, 'eth_call validation failed when preparing meta-transaction trade');
            // Attempt to gather extra context upon eth_call failure
            try {
                const [takerBalance] = await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync([
                    { owner: takerAddress, token: inputToken },
                ]);
                const blockNumber = await this._blockchainUtils.getCurrentBlockAsync();
                logger_1.logger.info({
                    calldata,
                    blockNumber,
                    jobId,
                    metaTransaction,
                    takerBalance,
                }, 'Extra context after eth_call validation failed when preparing meta-transaction trade');
            }
            catch (error) {
                logger_1.logger.warn({ jobId }, 'Failed to get extra context after eth_call validation failed when preparing meta-transaction trade ');
            }
            throw new Error('Eth call validation failed when preparing meta-transaction trade');
        }
        return calldata;
    }
    /**
     * Check last look by getting market maker signature. Handles retries when making request to market maker servers.
     *
     * When verifying the order is fillable by both the maker and the taker:
     * - If `shouldCheckAllowance` is false, the method would only check balances but not the allowances the maker and
     *   the taker set for 0x exchange proxy because the taker allowance will not be set when `checkLastLookAsync` is called as we
     *   want to call this method as soon as possible to mitigate the latency brought by sequential submissions
     *   (which would lead to higher decline to sign rate).
     * - Otherwise, both balances and allowances would be checked.
     */
    async checkLastLookAsync(job, workerAddress, shouldCheckAllowance) {
        const { makerUri, order, orderHash, takerSignature } = job;
        const otcOrder = (0, rfqm_db_utils_1.storedOtcOrderToOtcOrder)(order);
        let { makerSignature } = job;
        if (makerSignature) {
            // Market Maker had already signed order
            logger_1.logger.info({ workerAddress, orderHash }, 'Order already signed');
        }
        else {
            // validate that order is fillable by both the maker and the taker according to balances (and allowances
            // when `shouldCheckAllowance` is true)
            const [makerBalance] = await this._rfqMakerBalanceCacheService.getERC20OwnerBalancesAsync(this._chainId, {
                owner: otcOrder.maker,
                token: otcOrder.makerToken,
            });
            const [takerBalance] = shouldCheckAllowance
                ? await this._blockchainUtils.getMinOfBalancesAndAllowancesAsync({
                    owner: otcOrder.taker,
                    token: otcOrder.takerToken,
                })
                : await this._blockchainUtils.getTokenBalancesAsync({
                    owner: otcOrder.taker,
                    token: otcOrder.takerToken,
                });
            if (makerBalance.lt(otcOrder.makerAmount) || takerBalance.lt(otcOrder.takerAmount)) {
                logger_1.logger.error({
                    orderHash,
                    makerBalance,
                    takerBalance,
                    makerAmount: otcOrder.makerAmount,
                    takerAmount: otcOrder.takerAmount,
                }, 'Order failed pre-sign validation');
                job.status = types_1.RfqmJobStatus.FailedPresignValidationFailed;
                await this._dbUtils.updateRfqmJobAsync(job);
                throw new Error('Order failed pre-sign validation');
            }
            if (!takerSignature) {
                logger_1.logger.error('Order failed pre-sign validation due to empty takerSignature');
                job.status = types_1.RfqmJobStatus.FailedPresignValidationFailed;
                await this._dbUtils.updateRfqmJobAsync(job);
                throw new Error('Order failed pre-sign validation due to empty takerSignature');
            }
            const signRequest = {
                expiry: job.expiry,
                fee: (0, fee_utils_1.storedFeeToFee)(job.fee),
                order: otcOrder,
                orderHash,
                takerSignature,
                ...(job.takerSpecifiedSide &&
                    config_1.TAKER_SPECIFIED_SIDE_ENABLED && { takerSpecifiedSide: job.takerSpecifiedSide }),
            };
            // "Last Look" in v1 is replaced by market maker order signing in v2.
            const signAttemptTimeMs = Date.now();
            try {
                makerSignature = await (0, attempt_1.retry)(async () => {
                    var _a;
                    return this._quoteServerClient
                        .signV2Async(makerUri, (_a = job.integratorId) !== null && _a !== void 0 ? _a : '', signRequest)
                        .then((s) => s !== null && s !== void 0 ? s : null);
                }, {
                    delay: constants_1.ONE_SECOND_MS,
                    factor: 2,
                    maxAttempts: 3,
                    handleError: (error, context, _options) => {
                        const { attemptNum: attemptNumber, attemptsRemaining } = context;
                        logger_1.logger.warn({ orderHash, makerUri, attemptNumber, attemptsRemaining, error: error.message }, 'Error encountered while attempting to get market maker signature');
                    },
                });
            }
            catch (error) {
                // The sign process has failed after retries
                RFQM_JOB_FAILED_MM_SIGNATURE_FAILED.labels(makerUri, this._chainId.toString()).inc();
                logger_1.logger.error({ orderHash, makerUri, error: error.message }, 'RFQM v2 job failed due to market maker sign failure');
                job.status = types_1.RfqmJobStatus.FailedSignFailed;
                await this._dbUtils.updateRfqmJobAsync(job);
                throw new Error('Job failed during market maker sign attempt');
            }
            logger_1.logger.info({ makerUri, signed: !!makerSignature, orderHash }, 'Got signature response from market maker');
            if (!makerSignature) {
                // Market Maker has declined to sign the transaction
                RFQM_JOB_MM_REJECTED_LAST_LOOK.labels(makerUri, this._chainId.toString()).inc();
                job.lastLookResult = false;
                job.status = types_1.RfqmJobStatus.FailedLastLookDeclined;
                await this._dbUtils.updateRfqmJobAsync(job);
                if (config_1.ENABLE_LLR_COOLDOWN) {
                    try {
                        const quote = await this._dbUtils.findV2QuoteByOrderHashAsync(orderHash);
                        if (quote === null) {
                            throw new Error(`Failed to find quote with order hash ${orderHash}`);
                        }
                        // `bad` last look rejection, rejected within the cooldown window
                        if (signAttemptTimeMs - quote.createdAt.valueOf() <
                            constants_1.LLR_COOLDOWN_WINDOW_SECONDS * constants_1.ONE_SECOND_MS) {
                            const makerId = this._rfqMakerManager.findMakerIdWithRfqmUri(makerUri);
                            if (makerId === null) {
                                throw new Error(`Failed to find maker ID with RFQm URI ${makerUri}`);
                            }
                            const cooldownEndTimeMs = signAttemptTimeMs + config_1.LLR_COOLDOWN_DURATION_SECONDS * constants_1.ONE_SECOND_MS;
                            // schedule cooldown
                            const isScheduleUpdated = await this._cacheClient.addMakerToCooldownAsync(makerId, cooldownEndTimeMs, this._chainId, otcOrder.makerToken, otcOrder.takerToken);
                            logger_1.logger.info({
                                makerId,
                                chainId: this._chainId,
                                makerToken: otcOrder.makerToken,
                                takerToken: otcOrder.takerToken,
                                startTime: signAttemptTimeMs,
                                endTime: cooldownEndTimeMs,
                                orderHash,
                                isScheduleUpdated,
                            }, 'LLR cooldown scheduled');
                            try {
                                // insert cooldown entry to db for record keeping
                                await this._dbUtils.writeV2LastLookRejectionCooldownAsync(makerId, this._chainId, otcOrder.makerToken, otcOrder.takerToken, new Date(signAttemptTimeMs), // startTime
                                new Date(cooldownEndTimeMs), // endTime
                                orderHash);
                            }
                            catch (e) {
                                logger_1.logger.warn({ orderHash, errorMessage: e.message }, 'Saving LLR cooldown failed');
                            }
                        }
                    }
                    catch (error) {
                        logger_1.logger.warn({ errorMessage: error.message }, 'Encountered error when detecting bad LLR and scheduling cooldown');
                    }
                }
                // We'd like some data on how much the price the market maker is offering
                // has changed. We query the market maker's price endpoint with the same
                // trade they've just declined to sign and log the result.
                try {
                    const declineToSignPriceCheckTimeMs = Date.now();
                    const otcOrderParams = quote_server_client_1.QuoteServerClient.makeQueryParameters({
                        chainId: this._chainId,
                        txOrigin: this._registryAddress,
                        takerAddress: otcOrder.taker,
                        marketOperation: asset_swapper_1.MarketOperation.Sell,
                        buyTokenAddress: otcOrder.makerToken,
                        sellTokenAddress: otcOrder.takerToken,
                        assetFillAmount: otcOrder.takerAmount,
                        isLastLook: true,
                        fee: (0, fee_utils_1.storedFeeToFee)(job.fee),
                    });
                    // Instead of adding a dependency to `ConfigManager` to get the actual integrator
                    // (we only have the ID at this point), just create a stand-in.
                    // This will send the same integrator ID to the market maker; they will not be
                    // able to tell the difference.
                    // `logRfqMakerNetworkInteraction` does use the `label`, however, but I think the
                    // tradeoff is reasonable.
                    const integrator = {
                        apiKeys: [],
                        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        integratorId: job.integratorId,
                        allowedChainIds: [this._chainId],
                        label: 'decline-to-sign-price-check',
                        plp: true,
                        rfqm: true,
                        rfqt: true,
                    };
                    const priceResponse = await this._quoteServerClient.getPriceV2Async(job.makerUri, integrator, otcOrderParams, (u) => `${u}/rfqm/v2/price`);
                    if (!priceResponse) {
                        throw new Error('Failed to get a price response');
                    }
                    const { makerAmount: priceCheckMakerAmount, takerAmount: priceCheckTakerAmount } = priceResponse;
                    const originalPrice = otcOrder.makerAmount.dividedBy(priceCheckTakerAmount);
                    const priceAfterReject = priceCheckMakerAmount.dividedBy(priceCheckTakerAmount);
                    const bipsFactor = 10000;
                    const priceDifferenceBips = originalPrice
                        .minus(priceAfterReject)
                        .dividedBy(originalPrice)
                        .absoluteValue()
                        .times(bipsFactor)
                        .toPrecision(1);
                    // The time, in seconds, between when we initiated the sign attempt and when we
                    // initiated the price check after the maker declined to sign.
                    const priceCheckDelayS = (declineToSignPriceCheckTimeMs - signAttemptTimeMs) / constants_1.ONE_SECOND_MS;
                    logger_1.logger.info({
                        orderHash,
                        originalPrice: originalPrice.toNumber(),
                        priceAfterReject: priceAfterReject.toNumber(),
                        priceCheckDelayS,
                        priceDifferenceBips,
                    }, 'Decline to sign price check');
                    try {
                        job.llRejectPriceDifferenceBps = parseInt(priceDifferenceBips, 10);
                        await this._dbUtils.updateRfqmJobAsync(job);
                    }
                    catch (e) {
                        logger_1.logger.warn({ orderHash, errorMessage: e.message }, 'Saving LL reject price difference failed');
                    }
                }
                catch (error) {
                    logger_1.logger.warn({ errorMessage: error.message }, 'Encountered error during decline to sign price check');
                }
                throw new Error('Market Maker declined to sign');
            }
            // Certain market makers are returning signature components which are missing
            // leading bytes. Add them if they don't exist.
            const paddedSignature = (0, signature_utils_1.padSignature)(makerSignature);
            if (paddedSignature.r !== makerSignature.r || paddedSignature.s !== makerSignature.s) {
                logger_1.logger.warn({ orderHash, r: paddedSignature.r, s: paddedSignature.s }, 'Got market maker signature with missing bytes');
                makerSignature = paddedSignature;
            }
            job.makerSignature = paddedSignature;
            job.lastLookResult = true;
            job.status = types_1.RfqmJobStatus.PendingLastLookAccepted;
            await this._dbUtils.updateRfqmJobAsync(job);
        }
        // Maker signature must already be defined here -- refine the type
        if (!makerSignature) {
            throw new Error('Maker signature does not exist');
        }
        // Verify the signer was the maker
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const signerAddress = (0, signature_utils_1.getSignerFromHash)(orderHash, makerSignature).toLowerCase();
        const makerAddress = order.order.maker.toLowerCase();
        if (signerAddress !== makerAddress) {
            logger_1.logger.info({ signerAddress, makerAddress, orderHash, makerUri }, 'Possible use of smart contract wallet');
            const isValidSigner = await this._blockchainUtils.isValidOrderSignerAsync(makerAddress, signerAddress);
            if (!isValidSigner) {
                job.status = types_1.RfqmJobStatus.FailedSignFailed;
                await this._dbUtils.updateRfqmJobAsync(job);
                throw new Error('Invalid order signer address');
            }
        }
    }
    /**
     * Submits a specific type of submission to the blockchain.
     *
     * First checks to see if there are previous transactions with the submission type and enters the
     * watch loop; if not, submits an initial transaction and enters the watch loop.
     *
     * During the watch loop, waits for a transaction to be mined and confirmed;
     * replaces the transaction if gas prices rise while a transactions are in the mempool.
     *
     * @param opts Options object that contains:
     *        - `to`: The address to send to.
     *        - `from`: The address submitting the transaction (usually the worker address).
     *        - `calldata`: Calldata to submit.
     *        - `expiry`: Exiry before the submission is considered invalid.
     *        - `identifier`: The job identifier. For rfqm_v2_job, it should be order hash; for meta-transaction, it should be job id.
     *        - `submissionType`: The type of submission.
     *        - `onSubmissionContextStatusUpdate`: Callback to perform appropriate actions when the submission context statuses change.
     *        - `now`: The current time.
     * @returns FailedRevertedConfirmed or SucceededConfirmed.
     * @throws Submission context status is FailedExpired or unhandled exceptions.
     */
    async submitToChainAsync(opts) {
        const { kind, to, from, calldata, expiry, identifier, submissionType, onSubmissionContextStatusUpdate } = opts;
        let previousSubmissionsWithPresubmits;
        switch (kind) {
            case 'rfqm_v2_job':
                previousSubmissionsWithPresubmits = await this._dbUtils.findV2TransactionSubmissionsByOrderHashAsync(identifier, submissionType);
                break;
            case 'meta_transaction_job':
                previousSubmissionsWithPresubmits = await this._dbUtils.findMetaTransactionSubmissionsByJobIdAsync(identifier, submissionType);
                break;
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(kind);
        }
        const previousSubmissions = await this._recoverPresubmitTransactionsAsync(previousSubmissionsWithPresubmits);
        const gasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();
        // For the first submission, we use the "fast" gas estimate to approximate the base fee.
        // We use the strategy outlined in https://www.blocknative.com/blog/eip-1559-fees --
        // The `maxFeePerGas` is 2x the base fee (plus priority tip). Since we don't have a
        // handy oracle for the en vogue priorty fee we start with 2 gwei and work up from there.
        const initialMaxPriorityFeePerGas = new utils_1.BigNumber(this._initialMaxPriorityFeePerGasGwei).times(Math.pow(10, constants_1.GWEI_DECIMALS));
        let gasFees = {
            maxFeePerGas: utils_1.BigNumber.min(gasPriceEstimate.multipliedBy(2).plus(initialMaxPriorityFeePerGas), this._maxFeePerGasCapWei),
            maxPriorityFeePerGas: initialMaxPriorityFeePerGas,
        };
        let submissionContext;
        let nonce;
        let gasEstimate;
        if (!previousSubmissions.length) {
            // There's an edge case here where there are previous submissions but they're all in `PRESUBMIT`.
            // Those are filtered out if they can't be found on the blockchain so we end up here.
            // If this occurs we need to check if the transaction is expired.
            const nowSeconds = new utils_1.BigNumber(new Date().getTime() / constants_1.ONE_SECOND_MS);
            if (expiry.isLessThan(nowSeconds)) {
                await onSubmissionContextStatusUpdate(types_1.SubmissionContextStatus.FailedExpired);
                throw new Error(`Exceed expiry ${expiry} for kind ${kind} and submission type ${submissionType}`);
            }
            logger_1.logger.info({ kind, identifier, from }, 'Attempting to submit first transaction');
            await onSubmissionContextStatusUpdate(types_1.SubmissionContextStatus.PendingSubmitted);
            logger_1.logger.info({
                kind,
                gasFees,
                gasPriceEstimate,
                identifier,
                submissionCount: 1,
                from,
                submissionType,
            }, 'Submitting transaction');
            nonce = await this._blockchainUtils.getNonceAsync(from);
            const gasEstimateWithoutBuffer = await this._blockchainUtils.estimateGasForAsync({
                to,
                from,
                data: calldata,
                // The following gas fee properties are added because `executeMetaTransaction` in 0x Exchange Proxy
                // would check whether the gas price of the transaction is within a window. If left empty, it will
                // fail the simulation.
                maxFeePerGas: gasFees.maxFeePerGas.toString(),
                maxPriorityFeePerGas: gasFees.maxPriorityFeePerGas.toString(),
            });
            // Add buffer to gas estimate returned by `eth_estimateGas` as the RPC method
            // tends to under estimate gas usage
            gasEstimate = Math.ceil((constants_1.GAS_ESTIMATE_BUFFER + 1) * gasEstimateWithoutBuffer);
            let accessListWithGas;
            if (this._enableAccessList) {
                try {
                    accessListWithGas = await this._blockchainUtils.createAccessListForAsync({
                        to,
                        from,
                        data: calldata,
                    });
                    RFQM_CREATE_ACCESS_LIST_REQUEST.labels(this._chainId.toString(), 'success').inc();
                }
                catch (error) {
                    RFQM_CREATE_ACCESS_LIST_REQUEST.labels(this._chainId.toString(), 'failure').inc();
                    logger_1.logger.warn({ kind, calldata, from }, 'Failed to create access list');
                }
                if (accessListWithGas !== undefined && accessListWithGas.gasEstimate) {
                    // Add buffer to gas estimate returned by `eth_estimateGas` as the RPC method
                    // tends to under estimate gas usage
                    accessListWithGas.gasEstimate = Math.ceil((constants_1.GAS_ESTIMATE_BUFFER + 1) * accessListWithGas.gasEstimate);
                    logger_1.logger.info({ gasEstimate, accessListGasEstimate: accessListWithGas.gasEstimate }, 'Regular gas estimate vs access list gas estimate');
                    RFQM_GAS_ESTIMATE_NO_ACCESS_LIST.labels(this._chainId.toString()).set(gasEstimate);
                    RFQM_GAS_ESTIMATE_ACCESS_LIST.labels(this._chainId.toString()).set(accessListWithGas.gasEstimate);
                }
            }
            const firstSubmission = await this._submitTransactionAsync(kind, identifier, from, calldata, gasFees, nonce, gasEstimate, submissionType, to);
            logger_1.logger.info({ kind, from, identifier, submissionType, transactionHash: firstSubmission.transactionHash }, 'Successfully submitted transaction');
            submissionContext = new SubmissionContext_1.SubmissionContext(this._blockchainUtils, [firstSubmission]);
        }
        else {
            logger_1.logger.info({ kind, from, identifier, submissionType }, `Previous submissions found, recovering context`);
            submissionContext = new SubmissionContext_1.SubmissionContext(this._blockchainUtils, previousSubmissions);
            nonce = submissionContext.nonce;
            // If we've already submitted a transaction and it has been mined,
            // using `_blockchainUtils.estimateGasForAsync` will throw
            // given the same calldata. In the edge case where a transaction has been sent
            // but not mined, we would ideally pull the gas estimate from the previous
            // transaction. Unfortunately, we currently do not store it on the
            // `RfqmV2TransactionSubmissionEntity`. As a workaround, we'll just use an
            // overestimate..
            gasEstimate = MAX_GAS_ESTIMATE;
        }
        // The "Watch Loop"
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line no-constant-condition
        while (true) {
            // We've already submitted the transaction once at this point, so we first need to wait before checking the status.
            await (0, delay_1.default)(this._transactionWatcherSleepTimeMs);
            const oldSubmissionContextStatus = submissionContext.submissionContextStatus;
            const newSubmissionContextStatus = await this._checkSubmissionReceiptsAndUpdateDbAsync(identifier, submissionContext);
            logger_1.logger.info({ kind, submissionType, oldSubmissionContextStatus, newSubmissionContextStatus }, 'Old and new submission context statuses');
            await onSubmissionContextStatusUpdate(newSubmissionContextStatus, oldSubmissionContextStatus);
            switch (newSubmissionContextStatus) {
                case types_1.SubmissionContextStatus.PendingSubmitted:
                    // We've put in at least one transaction but none have been mined yet.
                    // Check to make sure we haven't passed the expiry window.
                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                    // eslint-disable-next-line no-case-declarations
                    const nowSeconds = new utils_1.BigNumber(new Date().getTime() / constants_1.ONE_SECOND_MS);
                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                    // eslint-disable-next-line no-case-declarations
                    const secondsPastExpiration = nowSeconds.minus(expiry);
                    // If we're more than 120 seconds past expiration, give up.
                    // See https://github.com/rolandkofler/blocktime for some
                    // analysis of expected block times. Two minutes was selected
                    // to cover most cases without locking up the worker for too long.
                    if (secondsPastExpiration.isGreaterThan(constants_1.ONE_MINUTE_S * 2)) {
                        await onSubmissionContextStatusUpdate(types_1.SubmissionContextStatus.FailedExpired, oldSubmissionContextStatus);
                        throw new Error(`Exceed expiry ${expiry} for kind ${kind} and submission type ${submissionType}`);
                    }
                    // If we're past expiration by less than a minute, don't put in any new transactions
                    // but keep watching in case a receipt shows up
                    if (secondsPastExpiration.isGreaterThan(0)) {
                        continue;
                    }
                    // "Fast" gas price estimation; used to approximate the base fee
                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                    // eslint-disable-next-line no-case-declarations
                    const newGasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();
                    if (submissionContext.transactionType === 0) {
                        throw new Error('Non-EIP-1559 transactions are not implemented');
                    }
                    // We don't wait for gas conditions to change. Rather, we increase the gas
                    // based bid based onthe knowledge that time (and therefore blocks, theoretically)
                    // has passed without a transaction being mined.
                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                    // eslint-disable-next-line no-case-declarations
                    const { maxFeePerGas: oldMaxFeePerGas, maxPriorityFeePerGas: oldMaxPriorityFeePerGas } = submissionContext.maxGasFees;
                    if (oldMaxFeePerGas.isGreaterThanOrEqualTo(this._maxFeePerGasCapWei)) {
                        // If we've reached the max fee per gas we'd like to pay, just
                        // continue watching the transactions to see if one gets mined.
                        logger_1.logger.info({ kind, submissionType, oldMaxFeePerGas, maxFeePerGasCap: this._maxFeePerGasCapWei }, 'Exceeds max fee per gas');
                        continue;
                    }
                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                    // eslint-disable-next-line no-case-declarations
                    const newMaxPriorityFeePerGas = oldMaxPriorityFeePerGas
                        .multipliedBy(MAX_PRIORITY_FEE_PER_GAS_MULTIPLIER)
                        .integerValue(utils_1.BigNumber.ROUND_CEIL);
                    // The RPC nodes still need at least a 0.1 increase in both values to accept the new transaction.
                    // For the new max fee per gas, we'll take the maximum of a 0.1 increase from the last value
                    // or the value from an increase in the base fee.
                    // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                    // eslint-disable-next-line no-case-declarations
                    const newMaxFeePerGas = utils_1.BigNumber.max(oldMaxFeePerGas.multipliedBy(MAX_FEE_PER_GAS_MULTIPLIER).integerValue(utils_1.BigNumber.ROUND_CEIL), newGasPriceEstimate.multipliedBy(2).plus(newMaxPriorityFeePerGas));
                    gasFees = {
                        maxFeePerGas: newMaxFeePerGas,
                        maxPriorityFeePerGas: newMaxPriorityFeePerGas,
                    };
                    logger_1.logger.info({
                        kind,
                        gasFees,
                        gasPriceEstimate,
                        identifier,
                        submissionCount: submissionContext.transactions.length + 1,
                        from,
                        submissionType,
                    }, 'Submitting transaction');
                    try {
                        const newTransaction = await this._submitTransactionAsync(kind, identifier, from, calldata, gasFees, nonce, gasEstimate, submissionType, to);
                        logger_1.logger.info({
                            kind,
                            from,
                            identifier,
                            transactionHash: newTransaction.transactionHash,
                            submissionType,
                        }, 'Successfully resubmited tx with higher gas price');
                        submissionContext.addTransaction(newTransaction);
                    }
                    catch (err) {
                        const errorMessage = err.message;
                        const isNonceTooLow = /nonce too low/.test(errorMessage);
                        logger_1.logger.warn({ from, kind, identifier, submissionType, errorMessage: err.message, isNonceTooLow }, 'Encountered an error re-submitting a tx');
                        if (isNonceTooLow) {
                            logger_1.logger.info({ from, kind, identifier, submissionType }, 'Ignore nonce too low error on re-submission. A previous submission was successful');
                            break;
                        }
                        // Rethrow on all other types of errors
                        throw err;
                    }
                    break;
                case types_1.SubmissionContextStatus.FailedRevertedUnconfirmed:
                case types_1.SubmissionContextStatus.SucceededUnconfirmed:
                    break;
                case types_1.SubmissionContextStatus.FailedRevertedConfirmed:
                case types_1.SubmissionContextStatus.SucceededConfirmed:
                    return newSubmissionContextStatus;
                default:
                    ((_x) => {
                        throw new Error('unreachable');
                    })(newSubmissionContextStatus);
            }
        }
    }
    /**
     * Get the callback function to supply to `submitToChainAsync`.
     *
     * Note that `job.status` would be updated to appropriate state by  the callback function according to old & new
     * submission context status and submission type. There would be job status update ONLY IF the new and old submission
     * context statuses differ.
     *
     * This function also "closes over" `job` so that it's accessible in the callback function. Refer the docstring of
     * `RfqmTransactionSubmissionContextStatus` for more details on submission context.
     *
     * @param job A rfqm v2 job or a meta transactino job object.
     * @param submissionType Type of submission.
     * @returns Function would make appropriate update to job status according to submission context statuses and submission type.
     */
    _getOnSubmissionContextStatusUpdateCallback(job, submissionType) {
        return async (newSubmissionContextStatus, oldSubmissionContextStatus) => {
            if (newSubmissionContextStatus !== oldSubmissionContextStatus) {
                let newJobStatus;
                switch (submissionType) {
                    case types_1.RfqmTransactionSubmissionType.Approval:
                        newJobStatus =
                            SubmissionContext_1.SubmissionContext.approvalSubmissionContextStatusToJobStatus(newSubmissionContextStatus);
                        break;
                    case types_1.RfqmTransactionSubmissionType.Trade:
                        newJobStatus =
                            SubmissionContext_1.SubmissionContext.tradeSubmissionContextStatusToJobStatus(newSubmissionContextStatus);
                        break;
                    default:
                        ((_x) => {
                            throw new Error('unreachable');
                        })(submissionType);
                }
                job.status = newJobStatus;
                await this._dbUtils.updateRfqmJobAsync(job);
            }
        };
    }
    /**
     * Takes an array of Transaction Submissions, which may include transactions with the
     * "Presbumit" status, and resolves or removes the "Presubmit" transactions.
     *
     * If there are previous submissions in the "Presubmit" state,
     *
     * For "Presubmit" transactions, we check to see if the transaction was actually sent to
     * the mempool or not, as that is indeterminate. Depending on the result of the check, we
     * update the status to "Submitted" or remove them from the submissions in memory.
     * Note that we leave the transaction record present in the database so that if the worker
     * dies again and the submission actually went through but was not found at the time of
     * this check we can potentially recover it later.
     */
    async _recoverPresubmitTransactionsAsync(transactionSubmissions) {
        // Any is so nasty -- https://dev.to/shadow1349/typescript-tip-of-the-week-generics-170g
        // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = await Promise.all(transactionSubmissions.map(async (transactionSubmission) => {
            // If the transaction is any status other than "Presubmit" then we'll leave it
            if (transactionSubmission.status !== types_1.RfqmTransactionSubmissionStatus.Presubmit) {
                return transactionSubmission;
            }
            // For transactions in presubmit, check the mempool and chain to see if they exist
            const transactionResponse = await this._blockchainUtils.getTransactionAsync(
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            transactionSubmission.transactionHash);
            if (transactionResponse) {
                // If it does exist, update the status. If not, remove it.
                transactionSubmission.status = types_1.RfqmTransactionSubmissionStatus.Submitted;
                await this._dbUtils.updateRfqmTransactionSubmissionsAsync([transactionSubmission]);
                return transactionSubmission;
            }
            else {
                return null;
            }
        })).then((x) => x.filter(isDefined));
        return result;
    }
    /**
     * Check for receipts from the tx hashes and update databases with status of all tx's.
     */
    async _checkSubmissionReceiptsAndUpdateDbAsync(identifier, submissionContext) {
        // At most one tx can be mined, since they all have the same nonce.
        const minedReceipt = await submissionContext.getReceiptAsync();
        // If the tx hasn't been mined yet, there're no database updates to do.
        if (!minedReceipt) {
            return types_1.SubmissionContextStatus.PendingSubmitted;
        }
        // Attempt to publish the mining latency
        try {
            const { timestamp: minedBlockTimestampS } = await this._blockchainUtils.getBlockAsync(minedReceipt.blockHash);
            const firstSubmissionTimestampS = submissionContext.firstSubmissionTimestampS;
            RFQM_MINING_LATENCY.labels(this._chainId.toString()).observe(minedBlockTimestampS - firstSubmissionTimestampS);
        }
        catch (e) {
            logger_1.logger.warn({ orderHash: identifier, errorMessage: e.message, stack: e.stack }, 'Failed to meter the mining latency');
        }
        await submissionContext.updateForReceiptAsync(minedReceipt);
        await this._dbUtils.updateRfqmTransactionSubmissionsAsync(submissionContext.transactions);
        return submissionContext.submissionContextStatus;
    }
    /**
     * Determine transaction properties and submit a transaction
     */
    async _submitTransactionAsync(kind, identifier, workerAddress, callData, gasFees, nonce, gasEstimate, submissionType = types_1.RfqmTransactionSubmissionType.Trade, to = this._blockchainUtils.getExchangeProxyAddress()) {
        const txOptions = {
            ...gasFees,
            from: workerAddress,
            to,
            gas: gasEstimate,
            nonce,
            value: 0,
        };
        const transactionRequest = this._blockchainUtils.transformTxDataToTransactionRequest(txOptions, this._chainId, callData);
        const { signedTransaction, transactionHash } = await this._blockchainUtils.signTransactionAsync(transactionRequest);
        let partialEntity;
        let transactionSubmissionEntity;
        switch (kind) {
            case 'rfqm_v2_job':
                partialEntity = {
                    ...gasFees,
                    transactionHash,
                    orderHash: identifier,
                    createdAt: new Date(),
                    from: workerAddress,
                    to,
                    nonce,
                    status: types_1.RfqmTransactionSubmissionStatus.Presubmit,
                    type: submissionType,
                };
                transactionSubmissionEntity = await this._dbUtils.writeV2RfqmTransactionSubmissionToDbAsync(partialEntity);
                break;
            case 'meta_transaction_job':
                partialEntity = {
                    ...gasFees,
                    transactionHash,
                    metaTransactionJobId: identifier,
                    createdAt: new Date(),
                    from: workerAddress,
                    to,
                    nonce,
                    status: types_1.RfqmTransactionSubmissionStatus.Presubmit,
                    type: submissionType,
                };
                transactionSubmissionEntity = await this._dbUtils.writeMetaTransactionSubmissionAsync(partialEntity);
                break;
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(kind);
        }
        const transactionHashFromSubmit = await this._blockchainUtils.submitSignedTransactionAsync(signedTransaction);
        if (transactionHash !== transactionHashFromSubmit) {
            // This should never ever happen
            logger_1.logger.error({ kind, submissionType, identifier, transactionHashFromSubmit, transactionHash }, 'Mismatch between transaction hash calculated before submit and after submit');
            throw new Error('Mismatch between transaction hash calculated before submit and after submit');
        }
        logger_1.logger.info({ kind, submissionType, identifier, workerAddress, transactionHash }, 'Transaction calldata submitted to exchange proxy');
        const updatedTransactionSubmission = [
            {
                ...transactionSubmissionEntity,
                status: types_1.RfqmTransactionSubmissionStatus.Submitted,
            },
        ];
        await this._dbUtils.updateRfqmTransactionSubmissionsAsync(updatedTransactionSubmission);
        let updatedEntity;
        switch (kind) {
            case 'rfqm_v2_job':
                updatedEntity = await this._dbUtils.findV2TransactionSubmissionByTransactionHashAsync(transactionHashFromSubmit);
                break;
            case 'meta_transaction_job':
                // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                // eslint-disable-next-line no-case-declarations
                const updatedSubmissionEntities = await this._dbUtils.findMetaTransactionSubmissionsByTransactionHashAsync(transactionHashFromSubmit, submissionType);
                if (updatedSubmissionEntities.length !== 1) {
                    // A transaction hash should never be submitted twice in our system. However, RFQ-562 mentioned cases like this could
                    // happen in our system. Add more log and throw the error to surface it.
                    logger_1.logger.error({ kind, submissionType, transactionHash }, 'Transaction hash have been submitted not exactly once');
                    throw new Error('Transaction hash have been submitted not exactly once');
                }
                updatedEntity = updatedSubmissionEntities[0];
                break;
            default:
                ((_x) => {
                    throw new Error('unreachable');
                })(kind);
        }
        if (!updatedEntity) {
            // This should never happen -- we just saved it
            throw new Error(`Could not find updated entity with transaction hash ${transactionHashFromSubmit} of kind ${kind} and submission type ${submissionType}`);
        }
        return updatedEntity;
    }
}
exports.WorkerService = WorkerService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2Rhdmlkd2Fsc2gvY29kZS1sb2NhbC8weC1yZnEtYXBpL3NyYy9zZXJ2aWNlcy9Xb3JrZXJTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUFxQztBQUNyQyxxREFBb0Q7QUFDcEQsdURBQXlEO0FBQ3pELHFDQUFzQztBQUN0QyxtREFBK0M7QUFDL0MsK0NBQTBDO0FBQzFDLGlDQUEwQjtBQUMxQiw2Q0FBc0Q7QUFFdEQsc0NBS21CO0FBQ25CLGlEQU8yQjtBQUMzQixpREFBbUQ7QUFRbkQsNkNBSzJCO0FBQzNCLHNDQUFtQztBQUluQyxzRUFBaUU7QUFDakUsMERBQStFO0FBRy9FLDhEQUEyRTtBQUMzRSxrRUFBK0Q7QUFTL0QsNkVBQTZFO0FBQzdFLFNBQVMsU0FBUyxDQUFJLEtBQVE7SUFDMUIsT0FBTyxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxTQUFTLENBQUM7QUFDakQsQ0FBQztBQUVELE1BQU0sbUJBQW1CLEdBQUcsSUFBSSxtQkFBSyxDQUFDO0lBQ2xDLElBQUksRUFBRSxxQkFBcUI7SUFDM0IsVUFBVSxFQUFFLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQztJQUNuQyxJQUFJLEVBQUUseUJBQXlCO0NBQ2xDLENBQUMsQ0FBQztBQUVILE1BQU0saUJBQWlCLEdBQUcsSUFBSSxxQkFBTyxDQUFDO0lBQ2xDLElBQUksRUFBRSxtQkFBbUI7SUFDekIsVUFBVSxFQUFFLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQztJQUNuQyxJQUFJLEVBQUUsbUVBQW1FO0NBQzVFLENBQUMsQ0FBQztBQUVILE1BQU0scUJBQXFCLEdBQUcsSUFBSSxxQkFBTyxDQUFDO0lBQ3RDLElBQUksRUFBRSx1QkFBdUI7SUFDN0IsVUFBVSxFQUFFLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQztJQUNuQyxJQUFJLEVBQUUsNkVBQTZFO0NBQ3RGLENBQUMsQ0FBQztBQUVILE1BQU0sZUFBZSxHQUFHLElBQUksbUJBQUssQ0FBQztJQUM5QixJQUFJLEVBQUUsb0JBQW9CO0lB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QUssQ0FDUixFQUFFLElBQUksRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLEVBQ3pDLHVEQUF1RCxDQUMxRCxDQUFDO29CQUNGLE1BQU0sSUFBSSxLQUFLLENBQUMsdURBQXVELENBQUMsQ0FBQztpQkFDNUU7Z0JBRUQsYUFBYSxHQUFHLHlCQUF5QixDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM3QyxNQUFNO1lBQ1Y7Z0JBQ0ksQ0FBQyxDQUFDLEVBQVMsRUFBRSxFQUFFO29CQUNYLE1BQU0sSUFBSSxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBQ25DLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2hCO1FBRUQsSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUNoQiwrQ0FBK0M7WUFDL0MsTUFBTSxJQUFJLEtBQUssQ0FDWCx1REFBdUQseUJBQXlCLFlBQVksSUFBSSx3QkFBd0IsY0FBYyxFQUFFLENBQzNJLENBQUM7U0FDTDtRQUVELE9BQU8sYUFBYSxDQUFDO0lBQ3pCLENBQUM7Q0FDSjtBQXp1REQsc0NBeXVEQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvZGF2aWR3YWxzaC9jb2RlLWxvY2FsLzB4LXJmcS1hcGkvc3JjL3NlcnZpY2VzL1dvcmtlclNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6bWF4LWZpbGUtbGluZS1jb3VudFxyXG5pbXBvcnQgeyBNYXJrZXRPcGVyYXRpb24gfSBmcm9tICdAMHgvYXNzZXQtc3dhcHBlcic7XHJcbmltcG9ydCB7IE90Y09yZGVyLCBTaWduYXR1cmUgfSBmcm9tICdAMHgvcHJvdG9jb2wtdXRpbHMnO1xyXG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdAMHgvdXRpbHMnO1xyXG5pbXBvcnQgeyBXZWIzV3JhcHBlciB9IGZyb20gJ0AweC93ZWIzLXdyYXBwZXInO1xyXG5pbXBvcnQgeyByZXRyeSB9IGZyb20gJ0BsaWZlb21pYy9hdHRlbXB0JztcclxuaW1wb3J0IGRlbGF5IGZyb20gJ2RlbGF5JztcclxuaW1wb3J0IHsgQ291bnRlciwgR2F1Z2UsIFN1bW1hcnkgfSBmcm9tICdwcm9tLWNsaWVudCc7XHJcblxyXG5pbXBvcnQge1xyXG4gICAgRU5BQkxFX0xMUl9DT09MRE9XTixcclxuICAgIEludGVncmF0b3IsXHJcbiAgICBMTFJfQ09PTERPV05fRFVSQVRJT05fU0VDT05EUyxcclxuICAgIFRBS0VSX1NQRUNJRklFRF9TSURFX0VOQUJMRUQsXHJcbn0gZnJvbSAnLi4vY29uZmlnJztcclxuaW1wb3J0IHtcclxuICAgIEVUSF9ERUNJTUFMUyxcclxuICAgIEdBU19FU1RJTUFURV9CVUZGRVIsXHJcbiAgICBHV0VJX0RFQ0lNQUxTLFxyXG4gICAgTExSX0NPT0xET1dOX1dJTkRPV19TRUNPTkRTLFxyXG4gICAgT05FX01JTlVURV9TLFxyXG4gICAgT05FX1NFQ09ORF9NUyxcclxufSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IHN0b3JlZEZlZVRvRmVlIH0gZnJvbSAnLi4vY29yZS9mZWVfdXRpbHMnO1xyXG5pbXBvcnQgeyBBcHByb3ZhbCB9IGZyb20gJy4uL2NvcmUvdHlwZXMnO1xyXG5pbXBvcnQge1xyXG4gICAgTWV0YVRyYW5zYWN0aW9uSm9iRW50aXR5LFxyXG4gICAgTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eSxcclxuICAgIFJmcW1WMkpvYkVudGl0eSxcclxuICAgIFJmcW1WMlRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eSxcclxufSBmcm9tICcuLi9lbnRpdGllcyc7XHJcbmltcG9ydCB7XHJcbiAgICBSZnFtSm9iU3RhdHVzLFxyXG4gICAgUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblN0YXR1cyxcclxuICAgIFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25UeXBlLFxyXG4gICAgU3VibWlzc2lvbkNvbnRleHRTdGF0dXMsXHJcbn0gZnJvbSAnLi4vZW50aXRpZXMvdHlwZXMnO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xyXG5pbXBvcnQgeyBTaWduUmVxdWVzdCB9IGZyb20gJy4uL3F1b3RlLXNlcnZlci90eXBlcyc7XHJcbmltcG9ydCB7IENhY2hlQ2xpZW50IH0gZnJvbSAnLi4vdXRpbHMvY2FjaGVfY2xpZW50JztcclxuaW1wb3J0IHsgR2FzU3RhdGlvbkF0dGVuZGFudCB9IGZyb20gJy4uL3V0aWxzL0dhc1N0YXRpb25BdHRlbmRhbnQnO1xyXG5pbXBvcnQgeyBRdW90ZVNlcnZlckNsaWVudCB9IGZyb20gJy4uL3V0aWxzL3F1b3RlX3NlcnZlcl9jbGllbnQnO1xyXG5pbXBvcnQgeyBSZnFtRGJVdGlscywgc3RvcmVkT3RjT3JkZXJUb090Y09yZGVyIH0gZnJvbSAnLi4vdXRpbHMvcmZxbV9kYl91dGlscyc7XHJcbmltcG9ydCB7IFJmcUJsb2NrY2hhaW5VdGlscyB9IGZyb20gJy4uL3V0aWxzL3JmcV9ibG9ja2NoYWluX3V0aWxzJztcclxuaW1wb3J0IHsgUmZxTWFrZXJNYW5hZ2VyIH0gZnJvbSAnLi4vdXRpbHMvcmZxX21ha2VyX21hbmFnZXInO1xyXG5pbXBvcnQgeyBnZXRTaWduZXJGcm9tSGFzaCwgcGFkU2lnbmF0dXJlIH0gZnJvbSAnLi4vdXRpbHMvc2lnbmF0dXJlX3V0aWxzJztcclxuaW1wb3J0IHsgU3VibWlzc2lvbkNvbnRleHQgfSBmcm9tICcuLi91dGlscy9TdWJtaXNzaW9uQ29udGV4dCc7XHJcblxyXG5pbXBvcnQgeyBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UgfSBmcm9tICcuL3JmcV9tYWtlcl9iYWxhbmNlX2NhY2hlX3NlcnZpY2UnO1xyXG5cclxuaW50ZXJmYWNlIEdhc0ZlZXMge1xyXG4gICAgbWF4RmVlUGVyR2FzOiBCaWdOdW1iZXI7XHJcbiAgICBtYXhQcmlvcml0eUZlZVBlckdhczogQmlnTnVtYmVyO1xyXG59XHJcblxyXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NzYzMjYyMi90eXBlc2NyaXB0LWFuZC1maWx0ZXItYm9vbGVhblxyXG5mdW5jdGlvbiBpc0RlZmluZWQ8VD4odmFsdWU6IFQpOiB2YWx1ZSBpcyBOb25OdWxsYWJsZTxUPiB7XHJcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcclxufVxyXG5cclxuY29uc3QgUkZRTV9XT1JLRVJfQkFMQU5DRSA9IG5ldyBHYXVnZSh7XHJcbiAgICBuYW1lOiAncmZxbV93b3JrZXJfYmFsYW5jZScsXHJcbiAgICBsYWJlbE5hbWVzOiBbJ2FkZHJlc3MnLCAnY2hhaW5faWQnXSxcclxuICAgIGhlbHA6ICdXb3JrZXIgYmFsYW5jZSBmb3IgUkZRTScsXHJcbn0pO1xyXG5cclxuY29uc3QgUkZRTV9XT1JLRVJfUkVBRFkgPSBuZXcgQ291bnRlcih7XHJcbiAgICBuYW1lOiAncmZxbV93b3JrZXJfcmVhZHknLFxyXG4gICAgbGFiZWxOYW1lczogWydhZGRyZXNzJywgJ2NoYWluX2lkJ10sXHJcbiAgICBoZWxwOiAnQSB3b3JrZXIgcGFzc2VkIHRoZSByZWFkaW5lc3MgY2hlY2ssIGFuZCBpcyByZWFkeSB0byBwaWNrIHVwIHdvcmsnLFxyXG59KTtcclxuXHJcbmNvbnN0IFJGUU1fV09SS0VSX05PVF9SRUFEWSA9IG5ldyBDb3VudGVyKHtcclxuICAgIG5hbWU6ICdyZnFtX3dvcmtlcl9ub3RfcmVhZHknLFxyXG4gICAgbGFiZWxOYW1lczogWydhZGRyZXNzJywgJ2NoYWluX2lkJ10sXHJcbiAgICBoZWxwOiAnQSB3b3JrZXIgZGlkIG5vdCBwYXNzIHRoZSByZWFkaW5lc3MgY2hlY2ssIGFuZCB3YXMgbm90IGFibGUgdG8gcGljayB1cCB3b3JrJyxcclxufSk7XHJcblxyXG5jb25zdCBSRlFNX0pPQl9SRVBBSVIgPSBuZXcgR2F1Z2Uoe1xyXG4gICAgbmFtZTogJ3JmcW1fam9iX3RvX3JlcGFpcicsXHJcbiAgICBsYWJlbE5hbWVzOiBbJ2FkZHJlc3MnLCAnY2hhaW5faWQnXSxcclxuICAgIGhlbHA6ICdBIHN1Ym1pdHRlZCBqb2IgZmFpbGVkIGFuZCBzdGFydGVkIHJlcGFpciBtb2RlJyxcclxufSk7XHJcblxyXG5jb25zdCBSRlFNX0pPQl9GQUlMRURfTU1fU0lHTkFUVVJFX0ZBSUxFRCA9IG5ldyBDb3VudGVyKHtcclxuICAgIG5hbWU6ICdyZnFtX2pvYl9mYWlsZWRfbW1fc2lnbmF0dXJlX2ZhaWxlZCcsXHJcbiAgICBoZWxwOiAnQSBqb2IgZmFpbGVkIGJlY2F1c2UgdGhlIG1hcmtldCBtYWtlciBzaWduYXR1cmUgcHJvY2VzcyBmYWlsZWQuIE5PVCB0cmlnZ2VyZWQgd2hlbiB0aGUgTU0gZGVjbGluZXMgdG8gc2lnbi4nLFxyXG4gICAgbGFiZWxOYW1lczogWydtYWtlclVyaScsICdjaGFpbl9pZCddLFxyXG59KTtcclxuY29uc3QgUkZRTV9KT0JfTU1fUkVKRUNURURfTEFTVF9MT09LID0gbmV3IENvdW50ZXIoe1xyXG4gICAgbmFtZTogJ3JmcW1fam9iX21tX3JlamVjdGVkX2xhc3RfbG9vaycsXHJcbiAgICBoZWxwOiAnQSBqb2IgcmVqZWN0ZWQgYnkgbWFya2V0IG1ha2VyIG9uIGxhc3QgbG9vaycsXHJcbiAgICBsYWJlbE5hbWVzOiBbJ21ha2VyVXJpJywgJ2NoYWluX2lkJ10sXHJcbn0pO1xyXG5cclxuY29uc3QgUkZRTV9QUk9DRVNTX0pPQl9MQVRFTkNZID0gbmV3IFN1bW1hcnkoe1xyXG4gICAgbmFtZTogJ3JmcW1fcHJvY2Vzc19qb2JfbGF0ZW5jeScsXHJcbiAgICBsYWJlbE5hbWVzOiBbJ2NoYWluX2lkJywgJ2pvYl9raW5kJ10sXHJcbiAgICBoZWxwOiAnTGF0ZW5jeSBmb3IgdGhlIHdvcmtlciBwcm9jZXNzaW5nIHRoZSBqb2InLFxyXG59KTtcclxuXHJcbmNvbnN0IFJGUU1fSk9CX0NPTVBMRVRFRCA9IG5ldyBDb3VudGVyKHtcclxuICAgIG5hbWU6ICdyZnFtX2pvYl9jb21wbGV0ZWQnLFxyXG4gICAgaGVscDogJ0FuIFJmcW0gSm9iIGNvbXBsZXRlZCB3aXRoIG5vIGVycm9ycycsXHJcbiAgICBsYWJlbE5hbWVzOiBbJ2FkZHJlc3MnLCAnY2hhaW5faWQnLCAnam9iX2tpbmQnXSxcclxufSk7XHJcblxyXG5jb25zdCBSRlFNX0pPQl9DT01QTEVURURfV0lUSF9FUlJPUiA9IG5ldyBDb3VudGVyKHtcclxuICAgIG5hbWU6ICdyZnFtX2pvYl9jb21wbGV0ZWRfd2l0aF9lcnJvcicsXHJcbiAgICBoZWxwOiAnQW4gUmZxbSBKb2IgY29tcGxldGVkIHdpdGggYW4gZXJyb3InLFxyXG4gICAgbGFiZWxOYW1lczogWydhZGRyZXNzJywgJ2NoYWluX2lkJywgJ2pvYl9raW5kJ10sXHJcbn0pO1xyXG5cclxuY29uc3QgUkZRTV9DUkVBVEVfQUNDRVNTX0xJU1RfUkVRVUVTVCA9IG5ldyBDb3VudGVyKHtcclxuICAgIG5hbWU6ICdyZnFtX2NyZWF0ZV9hY2Nlc3NfbGlzdF9yZXF1ZXN0X3RvdGFsJyxcclxuICAgIGhlbHA6ICdOdW1iZXIgb2YgcmVxdWVzdHMgZm9yIGV0aF9jcmVhdGVBY2Nlc3NMaXN0IGNhbGwnLFxyXG4gICAgbGFiZWxOYW1lczogWydjaGFpbl9pZCcsICdzdGF0dXMnXSxcclxufSk7XHJcblxyXG5jb25zdCBSRlFNX0dBU19FU1RJTUFURV9BQ0NFU1NfTElTVCA9IG5ldyBHYXVnZSh7XHJcbiAgICBuYW1lOiAncmZxbV9nYXNfZXN0aW1hdGVfYWNlc3NfbGlzdCcsXHJcbiAgICBoZWxwOiAnR2FzIGVzdGltYXRlIG9mIHRyYW5zYWN0aW9uIHdpdGggYWNjZXNzIGxpc3QnLFxyXG4gICAgbGFiZWxOYW1lczogWydjaGFpbl9pZCddLFxyXG59KTtcclxuXHJcbmNvbnN0IFJGUU1fR0FTX0VTVElNQVRFX05PX0FDQ0VTU19MSVNUID0gbmV3IEdhdWdlKHtcclxuICAgIG5hbWU6ICdyZnFtX2dhc19lc3RpbWF0ZV9ub19hY2Nlc3NfbGlzdCcsXHJcbiAgICBoZWxwOiAnR2FzIGVzdGltYXRlIG9mIHRyYW5zYWN0aW9uIHdpdGhvdXQgYWNjZXNzIGxpc3QnLFxyXG4gICAgbGFiZWxOYW1lczogWydjaGFpbl9pZCddLFxyXG59KTtcclxuXHJcbmNvbnN0IFJGUU1fU0lHTkVEX1FVT1RFX0VYUElSWV9UT09fU09PTiA9IG5ldyBDb3VudGVyKHtcclxuICAgIG5hbWU6ICdyZnFtX3NpZ25lZF9xdW90ZV9leHBpcnlfdG9vX3Nvb24nLFxyXG4gICAgbGFiZWxOYW1lczogWydjaGFpbl9pZCddLFxyXG4gICAgaGVscDogJ0Egc2lnbmVkIHF1b3RlIHdhcyBub3QgcXVldWVkIGJlY2F1c2UgaXQgd291bGQgZXhwaXJlIHRvbyBzb29uJyxcclxufSk7XHJcblxyXG5jb25zdCBSRlFNX01JTklOR19MQVRFTkNZID0gbmV3IFN1bW1hcnkoe1xyXG4gICAgbmFtZTogJ3JmcW1fbWluaW5nX2xhdGVuY3knLFxyXG4gICAgbGFiZWxOYW1lczogWydjaGFpbl9pZCddLFxyXG4gICAgaGVscDogJ1RoZSB0aW1lIGluIHNlY29uZHMgYmV0d2VlbiB3aGVuIHRoZSBmaXJzdCB0cmFuc2FjdGlvbiBmb3IgYSBqb2IgaXMgc2VudCBhbmQgd2hlbiBhIHRyYW5zYWN0aW9uIGZvciB0aGUgam9iIGlzIG1pbmVkJyxcclxufSk7XHJcblxyXG5jb25zdCBQUklDRV9ERUNJTUFMX1BMQUNFUyA9IDY7XHJcblxyXG5jb25zdCBNSU5fR0FTX1BSSUNFX0lOQ1JFQVNFID0gMC4xO1xyXG5cclxuLy8gUmV0cnlpbmcgYW4gRUlQIDE1NTkgdHJhbnNhY3Rpb246IGh0dHBzOi8vZG9jcy5hbGNoZW15LmNvbS9hbGNoZW15L2d1aWRlcy9laXAtMTU1OS9yZXRyeS1laXAtMTU1OS10eFxyXG5jb25zdCBNQVhfUFJJT1JJVFlfRkVFX1BFUl9HQVNfTVVMVElQTElFUiA9IDEuNTsgLy8gSW5jcmVhc2UgbXVsdGlwbGllciBmb3IgdGlwIHdpdGggZWFjaCByZXN1Ym1pc3Npb24gY3ljbGVcclxuY29uc3QgTUFYX0ZFRV9QRVJfR0FTX01VTFRJUExJRVIgPSAxLjE7IC8vIEluY3JlYXNlIG11bHRpcGxpZXIgaW4gbWF4IGZlZSBwZXIgZ2FzIHdpdGggZWFjaCBjeWNsZTsgbGltaXRhdGlvbiBvZiBnZXRoIG5vZGVcclxuLy8gRHVyaW5nIHJlY292ZXJ5LCB3ZSBtYXkgbm90IGJlIGFibGUgdG8gc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVcclxuLy8gYGVzdGltYXRlR2FzRm9yQXN5bmNgLiBJbiB0aGlzIGNhc2Ugd2UgdXNlIHRoaXMgdmFsdWUuXHJcbmNvbnN0IE1BWF9HQVNfRVNUSU1BVEUgPSA1MDBfMDAwO1xyXG5jb25zdCBTSU1VTEFUSU9OX01BWF9HQVNfTVVMVElQTElFUiA9IDI7IC8vIE11bHRpcGxpZXIgb2YgY29uZmlndXJlZCBtYXggZmVlIHdoZW4gcGVyZm9ybWluZyB0cmFuc2FjdGlvbiBzaW11bGF0aW9uXHJcblxyXG4vLyBIb3cgb2Z0ZW4gdGhlIHdvcmtlciBzaG91bGQgcHVibGlzaCBhIGhlYXJ0YmVhdFxyXG5jb25zdCBXT1JLRVJfSEVBUlRCRUFUX0ZSRVFVRU5DWV9NUyA9IE9ORV9TRUNPTkRfTVMgKiAzMDsgLy8gdHNsaW50OmRpc2FibGUtbGluZTogY3VzdG9tLW5vLW1hZ2ljLW51bWJlcnNcclxuXHJcbi8qKlxyXG4gKiBUaGUgc2VydmljZSBsYXllciBmb3IgR2FzbGVzcyBXb3JrZXJzLlxyXG4gKlxyXG4gKiBXb3JrZXJzIGFyZSBib3RzIHdpdGggdGhlaXIgb3duIEVPQXMgd2hpY2ggcHVsbFxyXG4gKiBtZXNzYWdlcyBvZmYgYW4gU1FTIHF1ZXVlLCByZXRyaWV2ZSB0aGUgcmVsYXRlZFxyXG4gKiBqb2IsIGFuZCBzdWJtaXQgdGhhdCBqb2IgdG8gdGhlIGJsb2NrY2hhaW4uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV29ya2VyU2VydmljZSB7XHJcbiAgICBwcml2YXRlIF9sYXN0SGVhcnRiZWF0VGltZTogRGF0ZSB8IG51bGwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfbWF4RmVlUGVyR2FzQ2FwV2VpOiBCaWdOdW1iZXI7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBzaG91bGRSZXN1Ym1pdFRyYW5zYWN0aW9uKGdhc0ZlZXM6IEdhc0ZlZXMsIGdhc1ByaWNlRXN0aW1hdGU6IEJpZ051bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIC8vIEdldGggb25seSBhbGxvd3MgcmVwbGFjZW1lbnQgb2YgdHJhbnNhY3Rpb25zIGlmIHRoZSByZXBsYWNlbWVudCBnYXMgcHJpY2VcclxuICAgICAgICAvLyBpcyBhdCBsZWFzdCAxMCUgaGlnaGVyIHRoYW4gdGhlIGdhcyBwcmljZSBvZiB0aGUgdHJhbnNhY3Rpb24gYmVpbmcgcmVwbGFjZWRcclxuICAgICAgICByZXR1cm4gZ2FzUHJpY2VFc3RpbWF0ZS5ndGUoZ2FzRmVlcy5tYXhGZWVQZXJHYXMubXVsdGlwbGllZEJ5KE1JTl9HQVNfUFJJQ0VfSU5DUkVBU0UgKyAxKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJucyBhIGZhaWx1cmUgc3RhdHVzIGZvciBhbiBpbnZhbGlkIHJmcW0gdjIgam9iIG9yIG51bGwgaWYgam9iIGlzIHZhbGlkLlxyXG4gICAgcHVibGljIHN0YXRpYyB2YWxpZGF0ZVJmcW1WMkpvYihqb2I6IFJmcW1WMkpvYkVudGl0eSwgbm93OiBEYXRlID0gbmV3IERhdGUoKSk6IFJmcW1Kb2JTdGF0dXMgfCBudWxsIHtcclxuICAgICAgICBjb25zdCB7IG1ha2VyVXJpLCBvcmRlciwgZmVlIH0gPSBqb2I7XHJcblxyXG4gICAgICAgIGlmIChtYWtlclVyaSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZnFtSm9iU3RhdHVzLkZhaWxlZFZhbGlkYXRpb25Ob01ha2VyVXJpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9yZGVyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZnFtSm9iU3RhdHVzLkZhaWxlZFZhbGlkYXRpb25Ob09yZGVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZlZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUmZxbUpvYlN0YXR1cy5GYWlsZWRWYWxpZGF0aW9uTm9GZWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPcmRlcnMgY2FuIGV4cGlyZSBpZiBhbnkgb2YgdGhlIGZvbGxvd2luZyBoYXBwZW46XHJcbiAgICAgICAgLy8gMSkgd29ya2VycyBhcmUgYmFja2VkIHVwXHJcbiAgICAgICAgLy8gMikgYW4gUkZRTSBvcmRlciBicm9rZSBkdXJpbmcgc3VibWlzc2lvbiBhbmQgdGhlIG9yZGVyIGlzIHN0dWNrIGluIHRoZSBxdWV1ZSBmb3IgYSBsb25nIHRpbWUuXHJcbiAgICAgICAgY29uc3Qgb3RjT3JkZXJTdHJpbmdGaWVsZHMgPSBqb2Iub3JkZXIub3JkZXI7XHJcbiAgICAgICAgY29uc3QgeyBleHBpcnkgfSA9IE90Y09yZGVyLnBhcnNlRXhwaXJ5QW5kTm9uY2UobmV3IEJpZ051bWJlcihvdGNPcmRlclN0cmluZ0ZpZWxkcy5leHBpcnlBbmROb25jZSkpO1xyXG4gICAgICAgIGNvbnN0IGV4cGlyeVRpbWVNcyA9IGV4cGlyeS50aW1lcyhPTkVfU0VDT05EX01TKTtcclxuICAgICAgICBpZiAoZXhwaXJ5VGltZU1zLmlzTmFOKCkgfHwgZXhwaXJ5VGltZU1zLmx0ZShub3cuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUmZxbUpvYlN0YXR1cy5GYWlsZWRFeHBpcmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWpvYi50YWtlclNpZ25hdHVyZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUmZxbUpvYlN0YXR1cy5GYWlsZWRWYWxpZGF0aW9uTm9UYWtlclNpZ25hdHVyZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHVybnMgYSBmYWlsdXJlIHN0YXR1cyBmb3IgYW4gaW52YWxpZCBtZXRhLXRyYW5zYWN0aW9uIGpvYiBvciBudWxsIGlmIGpvYiBpcyB2YWxpZC5cclxuICAgIHB1YmxpYyBzdGF0aWMgdmFsaWRhdGVNZXRhVHJhbnNhY3Rpb25Kb2IoXHJcbiAgICAgICAgam9iOiBNZXRhVHJhbnNhY3Rpb25Kb2JFbnRpdHksXHJcbiAgICAgICAgbm93OiBEYXRlID0gbmV3IERhdGUoKSxcclxuICAgICk6IFJmcW1Kb2JTdGF0dXMgfCBudWxsIHtcclxuICAgICAgICBjb25zdCB7IGV4cGlyeSwgZmVlLCBtZXRhVHJhbnNhY3Rpb24sIHRha2VyU2lnbmF0dXJlIH0gPSBqb2I7XHJcblxyXG4gICAgICAgIGlmIChtZXRhVHJhbnNhY3Rpb24gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJmcW1Kb2JTdGF0dXMuRmFpbGVkVmFsaWRhdGlvbk5vT3JkZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZmVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZnFtSm9iU3RhdHVzLkZhaWxlZFZhbGlkYXRpb25Ob0ZlZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE9yZGVycyBjYW4gZXhwaXJlIGlmIGFueSBvZiB0aGUgZm9sbG93aW5nIGhhcHBlbjpcclxuICAgICAgICAvLyAxKSB3b3JrZXJzIGFyZSBiYWNrZWQgdXBcclxuICAgICAgICAvLyAyKSBhbiBvcmRlciBicm9rZSBkdXJpbmcgc3VibWlzc2lvbiBhbmQgdGhlIG9yZGVyIGlzIHN0dWNrIGluIHRoZSBxdWV1ZSBmb3IgYSBsb25nIHRpbWUuXHJcbiAgICAgICAgY29uc3QgZXhwaXJ5VGltZU1zID0gZXhwaXJ5LnRpbWVzKE9ORV9TRUNPTkRfTVMpO1xyXG4gICAgICAgIGlmIChleHBpcnlUaW1lTXMuaXNOYU4oKSB8fCBleHBpcnlUaW1lTXMubHRlKG5vdy5nZXRUaW1lKCkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZnFtSm9iU3RhdHVzLkZhaWxlZEV4cGlyZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGFrZXJTaWduYXR1cmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJmcW1Kb2JTdGF0dXMuRmFpbGVkVmFsaWRhdGlvbk5vVGFrZXJTaWduYXR1cmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9jaGFpbklkOiBudW1iZXIsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfZ2FzU3RhdGlvbkF0dGVuZGFudDogR2FzU3RhdGlvbkF0dGVuZGFudCxcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9yZWdpc3RyeUFkZHJlc3M6IHN0cmluZyxcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9ibG9ja2NoYWluVXRpbHM6IFJmcUJsb2NrY2hhaW5VdGlscyxcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9kYlV0aWxzOiBSZnFtRGJVdGlscyxcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9xdW90ZVNlcnZlckNsaWVudDogUXVvdGVTZXJ2ZXJDbGllbnQsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfdHJhbnNhY3Rpb25XYXRjaGVyU2xlZXBUaW1lTXM6IG51bWJlcixcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9jYWNoZUNsaWVudDogQ2FjaGVDbGllbnQsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfcmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlOiBSZnFNYWtlckJhbGFuY2VDYWNoZVNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfcmZxTWFrZXJNYW5hZ2VyOiBSZnFNYWtlck1hbmFnZXIsXHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfaW5pdGlhbE1heFByaW9yaXR5RmVlUGVyR2FzR3dlaTogbnVtYmVyLFxyXG4gICAgICAgIG1heEZlZVBlckdhc0NhcEd3ZWk6IG51bWJlcixcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IF9lbmFibGVBY2Nlc3NMaXN0PzogYm9vbGVhbixcclxuICAgICkge1xyXG4gICAgICAgIHRoaXMuX21heEZlZVBlckdhc0NhcFdlaSA9IG5ldyBCaWdOdW1iZXIobWF4RmVlUGVyR2FzQ2FwR3dlaSkudGltZXMoTWF0aC5wb3coMTAsIEdXRUlfREVDSU1BTFMpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgd29ya2VyQmVmb3JlTG9naWNBc3luYyh3b3JrZXJJbmRleDogbnVtYmVyLCB3b3JrZXJBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgICAgICBsZXQgZ2FzUHJpY2U7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZ2FzUHJpY2UgPSBhd2FpdCB0aGlzLl9nYXNTdGF0aW9uQXR0ZW5kYW50LmdldEV4cGVjdGVkVHJhbnNhY3Rpb25HYXNSYXRlQXN5bmMoKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICB7IGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSB9LFxyXG4gICAgICAgICAgICAgICAgJ0N1cnJlbnQgZ2FzIHByaWNlIGlzIHVuYWJsZSB0byBiZSBmZXRjaGVkLCBtYXJraW5nIHdvcmtlciBhcyBub3QgcmVhZHkuJyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgUkZRTV9XT1JLRVJfTk9UX1JFQURZLmxhYmVscyh3b3JrZXJBZGRyZXNzLCB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLmluYygpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldEFjY291bnRCYWxhbmNlQXN5bmMod29ya2VyQWRkcmVzcyk7XHJcbiAgICAgICAgY29uc3QgYmFsYW5jZVVuaXRBbW91bnQgPSBXZWIzV3JhcHBlci50b1VuaXRBbW91bnQoYmFsYW5jZSwgRVRIX0RFQ0lNQUxTKS5kZWNpbWFsUGxhY2VzKFBSSUNFX0RFQ0lNQUxfUExBQ0VTKTtcclxuICAgICAgICBSRlFNX1dPUktFUl9CQUxBTkNFLmxhYmVscyh3b3JrZXJBZGRyZXNzLCB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLnNldChiYWxhbmNlVW5pdEFtb3VudC50b051bWJlcigpKTtcclxuXHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIG91dHN0YW5kaW5nIGpvYnMgZnJvbSB0aGUgd29ya2VyIGFuZCByZXNvbHZlIHRoZW1cclxuICAgICAgICBjb25zdCB1bnJlc29sdmVkSm9icyA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgdGhpcy5fZGJVdGlscy5maW5kVjJVbnJlc29sdmVkSm9ic0FzeW5jKHdvcmtlckFkZHJlc3MsIHRoaXMuX2NoYWluSWQpLFxyXG4gICAgICAgICAgICB0aGlzLl9kYlV0aWxzLmZpbmRVbnJlc29sdmVkTWV0YVRyYW5zYWN0aW9uSm9ic0FzeW5jKHdvcmtlckFkZHJlc3MsIHRoaXMuX2NoYWluSWQpLFxyXG4gICAgICAgIF0pLnRoZW4oKHgpID0+IHguZmxhdCgpKTtcclxuXHJcbiAgICAgICAgUkZRTV9KT0JfUkVQQUlSLmxhYmVscyh3b3JrZXJBZGRyZXNzLCB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLmluYyh1bnJlc29sdmVkSm9icy5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgam9iIG9mIHVucmVzb2x2ZWRKb2JzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsga2luZCB9ID0gam9iO1xyXG4gICAgICAgICAgICBsZXQgam9iSWRlbnRpZmllcjtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoa2luZCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmZxbV92Ml9qb2InOlxyXG4gICAgICAgICAgICAgICAgICAgIGpvYklkZW50aWZpZXIgPSBqb2Iub3JkZXJIYXNoO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbWV0YV90cmFuc2FjdGlvbl9qb2InOlxyXG4gICAgICAgICAgICAgICAgICAgIGpvYklkZW50aWZpZXIgPSBqb2IuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICgoX3g6IG5ldmVyKTogbmV2ZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVhY2hhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkoa2luZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKHsga2luZCwgam9iSWRlbnRpZmllciwgd29ya2VyQWRkcmVzcyB9LCBgVW5yZXNvbHZlZCBqb2IgZm91bmQsIGF0dGVtcHRpbmcgdG8gcmVwcm9jZXNzYCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0pvYkFzeW5jKGpvYklkZW50aWZpZXIsIHdvcmtlckFkZHJlc3MsIGtpbmQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgaXNXb3JrZXJSZWFkeSA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5pc1dvcmtlclJlYWR5QXN5bmMoXHJcbiAgICAgICAgICAgIHRoaXMuX2NoYWluSWQsXHJcbiAgICAgICAgICAgIHdvcmtlckFkZHJlc3MsXHJcbiAgICAgICAgICAgIGJhbGFuY2UsXHJcbiAgICAgICAgICAgIEJpZ051bWJlci5taW4oZ2FzUHJpY2UsIHRoaXMuX21heEZlZVBlckdhc0NhcFdlaSksXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAoIWlzV29ya2VyUmVhZHkpIHtcclxuICAgICAgICAgICAgUkZRTV9XT1JLRVJfTk9UX1JFQURZLmxhYmVscyh3b3JrZXJBZGRyZXNzLCB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLmluYygpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fbGFzdEhlYXJ0YmVhdFRpbWUgJiYgRGF0ZS5ub3coKSAtIHRoaXMuX2xhc3RIZWFydGJlYXRUaW1lLmdldFRpbWUoKSA8IFdPUktFUl9IRUFSVEJFQVRfRlJFUVVFTkNZX01TKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHVibGlzaCBhIGhlYXJ0YmVhdCBpZiB0aGUgd29ya2VyIGlzIHJlYWR5IHRvIGdvXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHdvcmtlckluZGV4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyIGluZGV4IGlzIHVuZGVmaW5lZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IHdoZW4gbWVyZ2luZyB3aXRoIGBmZWF0dXJlL211bHRpY2hhaW5gLCB1cGRhdGUgdGhpcyBsaW5lIHdpdGhcclxuICAgICAgICAgICAgLy8gYGNvbnN0IGNoYWluSWQgPSB0aGlzLl9jaGFpbi5jaGFpbklkLlxyXG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gdGhpcy5fY2hhaW5JZDtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGJVdGlscy51cHNlcnRSZnFtV29ya2VySGVhcnRiZWF0VG9EYkFzeW5jKHdvcmtlckFkZHJlc3MsIHdvcmtlckluZGV4LCBiYWxhbmNlLCBjaGFpbklkKTtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdEhlYXJ0YmVhdFRpbWUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcclxuICAgICAgICAgICAgICAgIHsgd29ya2VyQWRkcmVzcywgYmFsYW5jZSwgZXJyb3JNZXNzYWdlOiBlcnJvci5tZXNzYWdlIH0sXHJcbiAgICAgICAgICAgICAgICAnV29ya2VyIGZhaWxlZCB0byB3cml0ZSBhIGhlYXJ0YmVhdCB0byBzdG9yYWdlJyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFJGUU1fV09SS0VSX1JFQURZLmxhYmVscyh3b3JrZXJBZGRyZXNzLCB0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLmluYygpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVG9wLWxldmVsIGxvZ2ljIHRoZSB3b3JrZXIgdXNlcyB0byB0YWtlIGEgdjIgam9iIG9yIG1ldGEtdHJhbnNhY3Rpb24gam9iIHRvIGNvbXBsZXRpb24uXHJcbiAgICAgKiBUaGUgaWRlbnRpZmllciAob3JkZXJIYXNoIGZvciB2MiBqb2IgYW5kIGpvZCBpZCBmb3IgbWV0YS10cmFuc2FjdGlvbiBqb2IpIGNhbiBjb21lIGZyb21cclxuICAgICAqIGVpdGhlciBhbiB1bmZpbmlzaGVkIGpvYiBmb3VuZCBkdXJpbmcgdGhlIHdvcmtlciBiZWZvcmUgbG9naWMgb3IgZnJvbSBhbiBTUVMgbWVzc2FnZS5cclxuICAgICAqXHJcbiAgICAgKiBCaWcgcGljdHVyZSBzdGVwczpcclxuICAgICAqIDEuIEZldGNoIHRoZSBqb2IgZnJvbSB0aGUgZGF0YWJhc2VcclxuICAgICAqIDIuIFByZXBhcmUgdGhlIGpvYiBieSB2YWxpZGF0aW5nIGl0IChhbmQgZ2V0dGluZyB0aGUgbWFya2V0IG1ha2VyIHNpZ25hdHVyZSBmb3IgdjIgam9iKS5cclxuICAgICAqICAgIFRoaXMgc3RlcCBpcyBkaWZmZXJlbnQgZm9yIHYyIGFuZCBtZXRhLXRyYW5zYWN0aW9uIGpvYnMuXHJcbiAgICAgKiAzLiBTdWJtaXQgYSB0cmFuc2FjdGlvbiBpZiBub25lIGV4aXN0LCB3YWl0IGZvciBtaW5pbmcgKyBjb25maXJtYXRpb24sXHJcbiAgICAgKiAgICBhbmQgc3VibWl0IG5ldyB0cmFuc2FjdGlvbnMgaWYgZ2FzIHByaWNlcyByaXNlXHJcbiAgICAgKiA0LiBGaW5hbGl6ZSB0aGUgam9iIHN0YXR1c1xyXG4gICAgICpcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGVycm9yIGJvdW5kYXJ5IGZvciBqb2IgcHJvY2Vzc2luZzsgZXJyb3JzIHdpbGwgYmUgY2F1Z2h0LCBsb2dnZWRcclxuICAgICAqIGFuZCBzd2FsbG93ZWQuIFRoZSB3b3JrZXIgd2lsbCBjb250aW51ZSBhbG9uZyBpdHMgbGlmZWN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyBwcm9jZXNzaW5nIGxhdGVuY3kgbWV0cmljcyAmIGpvYiBzdWNjZXNzL2ZhaWwgY291bnRlcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBwcm9jZXNzSm9iQXN5bmMoXHJcbiAgICAgICAgaWRlbnRpZmllcjogc3RyaW5nLFxyXG4gICAgICAgIHdvcmtlckFkZHJlc3M6IHN0cmluZyxcclxuICAgICAgICBraW5kOiAoUmZxbVYySm9iRW50aXR5IHwgTWV0YVRyYW5zYWN0aW9uSm9iRW50aXR5KVsna2luZCddID0gJ3JmcW1fdjJfam9iJyxcclxuICAgICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGxvZ2dlci5pbmZvKHsga2luZCwgaWRlbnRpZmllciwgd29ya2VyQWRkcmVzcyB9LCAnU3RhcnQgcHJvY2VzcyBqb2InKTtcclxuICAgICAgICBjb25zdCB0aW1lclN0b3BGdW5jdGlvbiA9IFJGUU1fUFJPQ0VTU19KT0JfTEFURU5DWS5sYWJlbHModGhpcy5fY2hhaW5JZC50b1N0cmluZygpLCBraW5kKS5zdGFydFRpbWVyKCk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFN0ZXAgMTogRmluZCB0aGUgam9iXHJcbiAgICAgICAgICAgIGxldCBqb2I7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoa2luZCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmZxbV92Ml9qb2InOlxyXG4gICAgICAgICAgICAgICAgICAgIGpvYiA9IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZFYySm9iQnlPcmRlckhhc2hBc3luYyhpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21ldGFfdHJhbnNhY3Rpb25fam9iJzpcclxuICAgICAgICAgICAgICAgICAgICBqb2IgPSBhd2FpdCB0aGlzLl9kYlV0aWxzLmZpbmRNZXRhVHJhbnNhY3Rpb25Kb2JCeUlkQXN5bmMoaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICgoX3g6IG5ldmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcclxuICAgICAgICAgICAgICAgICAgICB9KShraW5kKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFqb2IpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gam9iIGZvdW5kIGZvciBpZGVudGlmaWVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN0ZXAgMjogUHJlcGFyZSB0aGUgam9iIGZvciBzdWJtaXNzaW9uXHJcblxyXG4gICAgICAgICAgICAvLyBDbGFpbSBqb2IgZm9yIHdvcmtlclxyXG4gICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uLEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1ub24tbnVsbC1hc3NlcnRpb25cclxuICAgICAgICAgICAgaWYgKGpvYi53b3JrZXJBZGRyZXNzISEgJiYgam9iLndvcmtlckFkZHJlc3MgIT09IHdvcmtlckFkZHJlc3MpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyIHdhcyBzZW50IGEgam9iIGNsYWltZWQgYnkgYSBkaWZmZXJlbnQgd29ya2VyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgam9iLndvcmtlckFkZHJlc3MgPSB3b3JrZXJBZGRyZXNzO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9kYlV0aWxzLnVwZGF0ZVJmcW1Kb2JBc3luYyhqb2IpO1xyXG4gICAgICAgICAgICBpZiAoam9iLmFwcHJvdmFsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhcHByb3ZhbCBhbmQgdHJhZGUgd29ya2Zsb3dcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0FwcHJvdmFsQW5kVHJhZGVBc3luYyhqb2IsIHdvcmtlckFkZHJlc3MpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdHJhZGUgb25seSB3b3JrZmxvd1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzVHJhZGVBc3luYyhqb2IsIHdvcmtlckFkZHJlc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKHsga2luZCwgaWRlbnRpZmllciwgd29ya2VyQWRkcmVzcyB9LCAnSm9iIGNvbXBsZXRlZCB3aXRob3V0IGVycm9ycycpO1xyXG4gICAgICAgICAgICBSRlFNX0pPQl9DT01QTEVURUQubGFiZWxzKHdvcmtlckFkZHJlc3MsIHRoaXMuX2NoYWluSWQudG9TdHJpbmcoKSwga2luZCkuaW5jKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKHsga2luZCwgd29ya2VyQWRkcmVzcywgaWRlbnRpZmllciwgZXJyb3JNZXNzYWdlOiBlcnJvci5tZXNzYWdlIH0sICdKb2IgY29tcGxldGVkIHdpdGggZXJyb3InKTtcclxuICAgICAgICAgICAgUkZRTV9KT0JfQ09NUExFVEVEX1dJVEhfRVJST1IubGFiZWxzKHdvcmtlckFkZHJlc3MsIHRoaXMuX2NoYWluSWQudG9TdHJpbmcoKSwga2luZCkuaW5jKCk7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdGltZXJTdG9wRnVuY3Rpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzIGFwcHJvdmFsIChnYXNsZXNzIGFwcHJvdmFsKSBhbmQgdHJhZGUgKHN3YXAgd2l0aCB0aGUgMHggZXhjaGFuZ2UgcHJveHkpIHN1Ym1pc3Npb25zLiBGb3IgdGhlIGZpcnN0IHZlcnNpb24sXHJcbiAgICAgKiB0aGV5IHdpbGwgYmUgcHJvY2Vzc2VkIFNFUVVFTlRJQUxMWS4gSW4gdGhlIGZ1dHVyZSwgd2Ugd2FudCB0byBzZW5kIHRoZSB0d28gdHJhbnNhY3Rpb24gaW4gcGFyYWxsZWwuXHJcbiAgICAgKiBUaGUgcmVhc29uIHdlIGNhbid0IHBhcmFsbGVsaXplIHRoZSBzdWJtaXNzaW9ucyBpcyBib3RoIGZ1bmN0aW9uIHdvdWxkIG1vZGlmeSBqb2Iuc3RhdHVzLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBtZXRob2Qgd291bGQ6XHJcbiAgICAgKiAxLiBQZXJmb3JtIHByZWxpbWluYXJ5IGNoZWNrIG9uIHRoZSBqb2Igb2JqZWN0IChhbmQgdXBkYXRlcyBqb2Igc3RhdHVzIHRvIGBQZW5kaW5nUHJvY2Vzc2luZ2ApXHJcbiAgICAgKiAyLiBHZXR0aW5nIHRoZSBtYXJrZXQgbWFrZXIgc2lnbmF0dXJlXHJcbiAgICAgKiAzLiBQcmVwYXJlIGFwcHJvdmFsXHJcbiAgICAgKiA0LiBTdWJtaXQgYXBwcm92YWxcclxuICAgICAqIDUuIFdhaXQgdW50aWwgdGhlIGFwcHJvdmFsIHRyYW5zYWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBjb25maXJtZWRcclxuICAgICAqIDYuIFByZXBhcmUgdHJhZGUgKHNpbmNlIHRoZSBtZXRob2QgaGFzIGFscmVhZHkgZ290IHRoZSBtYXJrZXQgbWFrZXIgc2lnbmF0dXJlLCBpdCdzIG5vdCBwZXJmb3JtZWQgaGVyZSlcclxuICAgICAqIDcuIFN1Ym1pdCB0cmFkZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcHJvY2Vzc0FwcHJvdmFsQW5kVHJhZGVBc3luYyhcclxuICAgICAgICBqb2I6IFJmcW1WMkpvYkVudGl0eSB8IE1ldGFUcmFuc2FjdGlvbkpvYkVudGl0eSxcclxuICAgICAgICB3b3JrZXJBZGRyZXNzOiBzdHJpbmcsXHJcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB7IGFwcHJvdmFsLCBhcHByb3ZhbFNpZ25hdHVyZSwga2luZCB9ID0gam9iO1xyXG4gICAgICAgIGlmICghYXBwcm92YWwgfHwgIWFwcHJvdmFsU2lnbmF0dXJlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLWFwcHJvdmFsIGpvYiBzaG91bGQgbm90IGJlIHByb2Nlc3NlZCBieSBgcHJvY2Vzc0FwcHJvdmFsQW5kVHJhZGVBc3luY2AnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBlcmZvcm0gcHJlbGltaW5hcnkgY2hlY2tcclxuICAgICAgICBhd2FpdCB0aGlzLmNoZWNrSm9iUHJlcHJvY2Vzc2luZ0FzeW5jKGpvYik7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09ICdyZnFtX3YyX2pvYicpIHtcclxuICAgICAgICAgICAgLy8gUGVyZm9ybSBsYXN0IGxvb2sgZm9yIHJmcW0gdjIgam9iXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2hlY2tMYXN0TG9va0FzeW5jKGpvYiwgd29ya2VyQWRkcmVzcywgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHRva2VuVG9BcHByb3ZlO1xyXG4gICAgICAgIGxldCBpZGVudGlmaWVyO1xyXG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xyXG4gICAgICAgICAgICBjYXNlICdyZnFtX3YyX2pvYic6XHJcbiAgICAgICAgICAgICAgICB0b2tlblRvQXBwcm92ZSA9IGpvYi5vcmRlci5vcmRlci50YWtlclRva2VuO1xyXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IGpvYi5vcmRlckhhc2g7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbWV0YV90cmFuc2FjdGlvbl9qb2InOlxyXG4gICAgICAgICAgICAgICAgdG9rZW5Ub0FwcHJvdmUgPSBqb2IuaW5wdXRUb2tlbjtcclxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBqb2IuaWQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICgoX3g6IG5ldmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfSkoa2luZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBhcHByb3ZhbENhbGxkYXRhID0gYXdhaXQgdGhpcy5wcmVwYXJlQXBwcm92YWxBc3luYyhqb2IsIHRva2VuVG9BcHByb3ZlLCBhcHByb3ZhbCwgYXBwcm92YWxTaWduYXR1cmUpO1xyXG4gICAgICAgIGNvbnN0IGFwcHJvdmFsU3RhdHVzID0gYXdhaXQgdGhpcy5zdWJtaXRUb0NoYWluQXN5bmMoe1xyXG4gICAgICAgICAgICBraW5kOiBqb2Iua2luZCxcclxuICAgICAgICAgICAgdG86IHRva2VuVG9BcHByb3ZlLFxyXG4gICAgICAgICAgICBmcm9tOiB3b3JrZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICBjYWxsZGF0YTogYXBwcm92YWxDYWxsZGF0YSxcclxuICAgICAgICAgICAgZXhwaXJ5OiBqb2IuZXhwaXJ5LFxyXG4gICAgICAgICAgICBpZGVudGlmaWVyLFxyXG4gICAgICAgICAgICBzdWJtaXNzaW9uVHlwZTogUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblR5cGUuQXBwcm92YWwsXHJcbiAgICAgICAgICAgIG9uU3VibWlzc2lvbkNvbnRleHRTdGF0dXNVcGRhdGU6IHRoaXMuX2dldE9uU3VibWlzc2lvbkNvbnRleHRTdGF0dXNVcGRhdGVDYWxsYmFjayhcclxuICAgICAgICAgICAgICAgIGpvYixcclxuICAgICAgICAgICAgICAgIFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25UeXBlLkFwcHJvdmFsLFxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBQcmVwYXJlIGFuZCBzdWJtaXQgdHJhZGUgb25seSBpZiBhcHByb3ZhbCB0cmFuc2FjdGlvbiBpcyBzdWNjZXNzZnVsXHJcbiAgICAgICAgaWYgKGFwcHJvdmFsU3RhdHVzID09PSBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cy5TdWNjZWVkZWRDb25maXJtZWQpIHtcclxuICAgICAgICAgICAgbGV0IHRyYWRlQ2FsbGRhdGE7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoa2luZCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmZxbV92Ml9qb2InOlxyXG4gICAgICAgICAgICAgICAgICAgIHRyYWRlQ2FsbGRhdGEgPSBhd2FpdCB0aGlzLnByZXBhcmVyZnFtVjJUcmFkZUFzeW5jKGpvYiwgd29ya2VyQWRkcmVzcywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbWV0YV90cmFuc2FjdGlvbl9qb2InOlxyXG4gICAgICAgICAgICAgICAgICAgIHRyYWRlQ2FsbGRhdGEgPSBhd2FpdCB0aGlzLnByZXBhcmVNZXRhVHJhbnNhY3Rpb25UcmFkZUFzeW5jKGpvYiwgd29ya2VyQWRkcmVzcywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAoKF94OiBuZXZlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkoa2luZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3VibWl0VG9DaGFpbkFzeW5jKHtcclxuICAgICAgICAgICAgICAgIGtpbmQ6IGpvYi5raW5kLFxyXG4gICAgICAgICAgICAgICAgdG86IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZXRFeGNoYW5nZVByb3h5QWRkcmVzcygpLFxyXG4gICAgICAgICAgICAgICAgZnJvbTogd29ya2VyQWRkcmVzcyxcclxuICAgICAgICAgICAgICAgIGNhbGxkYXRhOiB0cmFkZUNhbGxkYXRhLFxyXG4gICAgICAgICAgICAgICAgZXhwaXJ5OiBqb2IuZXhwaXJ5LFxyXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcixcclxuICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25UeXBlOiBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZS5UcmFkZSxcclxuICAgICAgICAgICAgICAgIG9uU3VibWlzc2lvbkNvbnRleHRTdGF0dXNVcGRhdGU6IHRoaXMuX2dldE9uU3VibWlzc2lvbkNvbnRleHRTdGF0dXNVcGRhdGVDYWxsYmFjayhcclxuICAgICAgICAgICAgICAgICAgICBqb2IsXHJcbiAgICAgICAgICAgICAgICAgICAgUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblR5cGUuVHJhZGUsXHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzIHRyYWRlIChzd2FwIHdpdGggdGhlIDB4IGV4Y2hhbmdlIHByb3h5KSBzdWJtaXNzaW9ucy4gVGhlIG1ldGhvZCB3b3VsZCBwcmVwYXJlIHRyYWRlIGNhbGxkYXRhXHJcbiAgICAgKiBhbmQgc3VibWl0IHRoZSB0cmFkZSB0byB0aGUgYmxvY2tjaGFpbi4gTm90ZSB0aGF0IGpvYiBzdGF0dXMgd291bGQgYmUgdXBkYXRlZCB0byB0aGUgY29ycmVzcG9uZGluZyBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIHByb2Nlc3NUcmFkZUFzeW5jKFxyXG4gICAgICAgIGpvYjogUmZxbVYySm9iRW50aXR5IHwgTWV0YVRyYW5zYWN0aW9uSm9iRW50aXR5LFxyXG4gICAgICAgIHdvcmtlckFkZHJlc3M6IHN0cmluZyxcclxuICAgICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHsga2luZCB9ID0gam9iO1xyXG5cclxuICAgICAgICBsZXQgY2FsbGRhdGE7XHJcbiAgICAgICAgbGV0IGlkZW50aWZpZXI7XHJcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JmcW1fdjJfam9iJzpcclxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBqb2Iub3JkZXJIYXNoO1xyXG4gICAgICAgICAgICAgICAgY2FsbGRhdGEgPSBhd2FpdCB0aGlzLnByZXBhcmVyZnFtVjJUcmFkZUFzeW5jKGpvYiwgd29ya2VyQWRkcmVzcyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbWV0YV90cmFuc2FjdGlvbl9qb2InOlxyXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IGpvYi5pZDtcclxuICAgICAgICAgICAgICAgIGNhbGxkYXRhID0gYXdhaXQgdGhpcy5wcmVwYXJlTWV0YVRyYW5zYWN0aW9uVHJhZGVBc3luYyhqb2IsIHdvcmtlckFkZHJlc3MpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAoKF94OiBuZXZlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcclxuICAgICAgICAgICAgICAgIH0pKGtpbmQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5zdWJtaXRUb0NoYWluQXN5bmMoe1xyXG4gICAgICAgICAgICBraW5kOiBqb2Iua2luZCxcclxuICAgICAgICAgICAgdG86IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZXRFeGNoYW5nZVByb3h5QWRkcmVzcygpLFxyXG4gICAgICAgICAgICBmcm9tOiB3b3JrZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICBjYWxsZGF0YSxcclxuICAgICAgICAgICAgZXhwaXJ5OiBqb2IuZXhwaXJ5LFxyXG4gICAgICAgICAgICBpZGVudGlmaWVyLFxyXG4gICAgICAgICAgICBzdWJtaXNzaW9uVHlwZTogUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblR5cGUuVHJhZGUsXHJcbiAgICAgICAgICAgIG9uU3VibWlzc2lvbkNvbnRleHRTdGF0dXNVcGRhdGU6IHRoaXMuX2dldE9uU3VibWlzc2lvbkNvbnRleHRTdGF0dXNVcGRhdGVDYWxsYmFjayhcclxuICAgICAgICAgICAgICAgIGpvYixcclxuICAgICAgICAgICAgICAgIFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25UeXBlLlRyYWRlLFxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybSBwcmVsaW1pbmFyeSBjaGVja3Mgb24gYSBqb2IgYmVmb3JlIHByb2Nlc3NpbmcuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIG1ldGhvZCB3b3VsZDpcclxuICAgICAqIDEuIENhbGwgYFJmcW1TZXJ2aWNlLnZhbGlkYXRlUmZxbVYySm9iYCAvIGBSZnFtU2VydmljZS52YWxpZGF0ZU1ldGFUcmFuc2FjdGlvbkpvYmAgYW5kIGNoZWNrIHJlc3VsdC4gSWYgdGhlcmUgaXMgYW4gZXJyb3IsIHVwZGF0ZSB0aGUgam9iIHN0YXR1cyBhbmQgdGhyb3cgZXhjZXB0aW9uXHJcbiAgICAgKiAyLiBNYWtlIHN1cmUgam9iLnRha2VyU2lnbmF0dXJlIGlzIHByZXNlbnQgb3IgdGhyb3cgZXhjZXB0aW9uXHJcbiAgICAgKiAzLiBVcGRhdGUgam9iIHN0YXR1cyB0byBgUGVuZGluZ1Byb2Nlc3NpbmdgIGlmIGN1cnJlbnQgc3RhdHVzIGlzIGBQZW5kaW5nRW5xdWV1ZWRgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBjaGVja0pvYlByZXByb2Nlc3NpbmdBc3luYyhcclxuICAgICAgICBqb2I6IFJmcW1WMkpvYkVudGl0eSB8IE1ldGFUcmFuc2FjdGlvbkpvYkVudGl0eSxcclxuICAgICAgICBub3c6IERhdGUgPSBuZXcgRGF0ZSgpLFxyXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgeyBraW5kLCB0YWtlclNpZ25hdHVyZSB9ID0gam9iO1xyXG4gICAgICAgIGxldCBpZGVudGlmaWVyO1xyXG4gICAgICAgIGxldCBlcnJvclN0YXR1cztcclxuXHJcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JmcW1fdjJfam9iJzpcclxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBqb2Iub3JkZXJIYXNoO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JTdGF0dXMgPSBXb3JrZXJTZXJ2aWNlLnZhbGlkYXRlUmZxbVYySm9iKGpvYiwgbm93KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtZXRhX3RyYW5zYWN0aW9uX2pvYic6XHJcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gam9iLmlkO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JTdGF0dXMgPSBXb3JrZXJTZXJ2aWNlLnZhbGlkYXRlTWV0YVRyYW5zYWN0aW9uSm9iKGpvYiwgbm93KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgKChfeDogbmV2ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9KShraW5kKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlcnJvclN0YXR1cyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBqb2Iuc3RhdHVzID0gZXJyb3JTdGF0dXM7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbUpvYkFzeW5jKGpvYik7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXJyb3JTdGF0dXMgPT09IFJmcW1Kb2JTdGF0dXMuRmFpbGVkRXhwaXJlZCkge1xyXG4gICAgICAgICAgICAgICAgUkZRTV9TSUdORURfUVVPVEVfRVhQSVJZX1RPT19TT09OLmxhYmVscyh0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLmluYygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcih7IGtpbmQsIGlkZW50aWZpZXIsIGVycm9yU3RhdHVzIH0sICdKb2IgZmFpbGVkIHZhbGlkYXRpb24nKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKb2IgZmFpbGVkIHZhbGlkYXRpb24nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV4aXN0ZW5jZSBvZiB0YWtlciBzaWduYXR1cmUgaGFzIGFscmVhZHkgYmVlbiBjaGVja2VkIGJ5XHJcbiAgICAgICAgLy8gYFJmcW1TZXJ2aWNlLnZhbGlkYXRlSm9iKGpvYilgLiBSZWZpbmUgdGhlIHR5cGUuXHJcbiAgICAgICAgaWYgKCF0YWtlclNpZ25hdHVyZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRha2VyIHNpZ25hdHVyZSBwcmVzZW50Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoam9iLnN0YXR1cyA9PT0gUmZxbUpvYlN0YXR1cy5QZW5kaW5nRW5xdWV1ZWQpIHtcclxuICAgICAgICAgICAgam9iLnN0YXR1cyA9IFJmcW1Kb2JTdGF0dXMuUGVuZGluZ1Byb2Nlc3Npbmc7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbUpvYkFzeW5jKGpvYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJlcGFyZXMgYSByZnFtIHYyIC8gbWV0YS10cmFuc2FjdGlvbiBqb2IgZm9yIGFwcHJvdmFsIHN1Ym1pc3Npb24gYnkgdmFsaWRhdGlkYXRpbmcgdGhlIGpvYiBhbmQgY29uc3RydWN0aW5nXHJcbiAgICAgKiB0aGUgY2FsbGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IGBqb2Iuc3RhdHVzYCB3b3VsZCBiZSBtb2RpZmllZCB0byBgRmFpbGVkRXRoQ2FsbEZhaWxlZGAgaWYgdHJhbnNhY3Rpb24gc2ltdWxhdGlvbiBmYWlsZWQuXHJcbiAgICAgKlxyXG4gICAgICogSGFuZGxlcyByZXRyaWVzIG9mIHJldHJ5YWJsZSBlcnJvcnMuIFRocm93cyBmb3IgdW5yZXRyaWFibGUgZXJyb3JzLiBVcGRhdGVzIGpvYiBpbiBkYXRhYmFzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIGNhbGxkYXRhIGZvciBhcHByb3ZhbCBzdWJtaXNzaW9uIHR5cGUuXHJcbiAgICAgKiBAdGhyb3dzIElmIHRoZSBhcHByb3ZhbCBjYW5ub3QgYmUgc3VibWl0dGVkIChlLmcuIGl0IGlzIGV4cGlyZWQpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcHJlcGFyZUFwcHJvdmFsQXN5bmMoXHJcbiAgICAgICAgam9iOiBSZnFtVjJKb2JFbnRpdHkgfCBNZXRhVHJhbnNhY3Rpb25Kb2JFbnRpdHksXHJcbiAgICAgICAgdG9rZW5Ub0FwcHJvdmU6IHN0cmluZyxcclxuICAgICAgICBhcHByb3ZhbDogQXBwcm92YWwsXHJcbiAgICAgICAgc2lnYW5hdHVyZTogU2lnbmF0dXJlLFxyXG4gICAgKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgICAgICBjb25zdCB7IGtpbmQgfSA9IGpvYjtcclxuICAgICAgICBjb25zdCBjYWxsZGF0YSA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZW5lcmF0ZUFwcHJvdmFsQ2FsbGRhdGFBc3luYyhcclxuICAgICAgICAgICAgdG9rZW5Ub0FwcHJvdmUsXHJcbiAgICAgICAgICAgIGFwcHJvdmFsLFxyXG4gICAgICAgICAgICBzaWdhbmF0dXJlLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGxldCBpZGVudGlmaWVyO1xyXG4gICAgICAgIGxldCB0cmFuc2FjdGlvblN1Ym1pc3Npb25zO1xyXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGFscmVhZHkgc3VibWl0dGVkIGFuIGFwcHJvdmFsIHRyYW5zYWN0aW9uIGZvciB0aGlzIGpvYi4gSWYgd2UgaGF2ZSwgdGhlIGpvYiBoYXMgYWxyZWFkeVxyXG4gICAgICAgIC8vIGJlZW4gY2hlY2tlZCBhbmQgd2UgY2FuIHNraXAgYGV0aF9jYWxsYCB2YWxpZGF0aW9uLlxyXG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xyXG4gICAgICAgICAgICBjYXNlICdyZnFtX3YyX2pvYic6XHJcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gam9iLm9yZGVySGFzaDtcclxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uU3VibWlzc2lvbnMgPSBhd2FpdCB0aGlzLl9kYlV0aWxzLmZpbmRWMlRyYW5zYWN0aW9uU3VibWlzc2lvbnNCeU9yZGVySGFzaEFzeW5jKFxyXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblR5cGUuQXBwcm92YWwsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21ldGFfdHJhbnNhY3Rpb25fam9iJzpcclxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBqb2IuaWQ7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblN1Ym1pc3Npb25zID0gYXdhaXQgdGhpcy5fZGJVdGlscy5maW5kTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbnNCeUpvYklkQXN5bmMoXHJcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcixcclxuICAgICAgICAgICAgICAgICAgICBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZS5BcHByb3ZhbCxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICgoX3g6IG5ldmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfSkoa2luZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHJhbnNhY3Rpb25TdWJtaXNzaW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKCFqb2IudGFrZXJTaWduYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlblxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvdW50ZXJlZCBhIGpvYiB3aXRoIHN1Ym1pc3Npb25zIGJ1dCBubyB0YWtlciBzaWduYXR1cmUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoam9iLmtpbmQgPT09ICdyZnFtX3YyX2pvYicgJiYgIWpvYi5tYWtlclNpZ25hdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIGEgam9iIHdpdGggc3VibWlzc2lvbnMgYnV0IG5vIG1ha2VyIHNpZ25hdHVyZScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTaW11bGF0ZSB0aGUgdHJhbnNhY3Rpb25cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCByZXRyeShcclxuICAgICAgICAgICAgICAgIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYGVzdGltYXRlR2FzRm9yQXN5bmNgIHRvIHNpbXVsYXRlIHRoZSB0cmFuc2FjdGlvbi4gSW4gZXRoZXJzLmpzLCBwcm92aWRlci5jYWxsIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3ZpZGVyLnNlbmQoJ2V0aF9jYWxsJywgLi4uKSBtaWdodCBub3QgdGhyb3cgZXhjZXB0aW9uIGFuZCB0aGUgYmVoYXZpb3IgbWlnaHQgYmUgZGVwZW5kZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gcHJvdmlkZXJzLiBSZXZpc2l0IHRoaXMgbGF0ZXJcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2tjaGFpblV0aWxzLmVzdGltYXRlR2FzRm9yQXN5bmMoeyB0bzogdG9rZW5Ub0FwcHJvdmUsIGRhdGE6IGNhbGxkYXRhIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheTogT05FX1NFQ09ORF9NUyxcclxuICAgICAgICAgICAgICAgICAgICBmYWN0b3I6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4QXR0ZW1wdHM6IDMsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3I6IChlcnJvciwgY29udGV4dCwgX29wdGlvbnMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhdHRlbXB0TnVtOiBhdHRlbXB0TnVtYmVyLCBhdHRlbXB0c1JlbWFpbmluZyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGtpbmQsIGF0dGVtcHROdW1iZXIsIGF0dGVtcHRzUmVtYWluaW5nLCBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsIHN0YWNrOiBlcnJvci5zdGFjayB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Vycm9yIGR1cmluZyBldGhfY2FsbCBhcHByb3ZhbCB2YWxpZGF0aW9uLiBSZXRyeWluZy4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGpvYi5zdGF0dXMgPSBSZnFtSm9iU3RhdHVzLkZhaWxlZEV0aENhbGxGYWlsZWQ7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbUpvYkFzeW5jKGpvYik7XHJcblxyXG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICB7IGtpbmQsIGlkZW50aWZpZXIsIGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSwgc3RhY2s6IGVycm9yLnN0YWNrIH0sXHJcbiAgICAgICAgICAgICAgICAnZXRoX2NhbGwgYXBwcm92YWwgdmFsaWRhdGlvbiBmYWlsZWQnLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aCBjYWxsIGFwcHJvdmFsIHZhbGlkYXRpb24gZmFpbGVkJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2FsbGRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwYXJlcyBhbiBSZnFtVjIgSm9iIGZvciB0cmFkZSBzdWJtaXNzaW9uIGJ5IHZhbGlkYXRpZGF0aW5nIHRoZSBqb2IsIG9idGFpbmluZyB0aGVcclxuICAgICAqIG1hcmtldCBtYWtlciBzaWduYXR1cmUsIGFuZCBjb25zdHJ1Y3RpbmcgdGhlIGNhbGxkYXRhLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCBgam9iLnN0YXR1c2Agd291bGQgYmUgbW9kaWZpZWQgdG8gY29ycmVzcG9uZGluZyBzdGF0dXMuIEZvciBleGFtcGxlLCBpZiBtYWtlciBzaWduYXR1cmVcclxuICAgICAqIGlzIG5vdCB2YWxpZCwgYGpvYi5zdGF0dXNgIHdvdWxkIGJlIHNldCB0byBgRmFpbGVkU2lnbkZhaWxlZGAuXHJcbiAgICAgKlxyXG4gICAgICogYHNob3VsZENoZWNrTGFzdExvb2tgIGRldGVybWluZXMgaWYgdGhlIHByZWxpbWluYXJ5IGpvYiBjaGVjayBhbmQgZ2V0dGluZyBtYXJrZXQgbWFrZXIgc2lnYXR1cmVcclxuICAgICAqIHdvdWxkIGJlIHBlcmZvcm1lZCBhbmQgaXMgZGVmYXVsdCB0byBgdHJ1ZWAuXHJcbiAgICAgKlxyXG4gICAgICogSGFuZGxlcyByZXRyaWVzIG9mIHJldHJ5YWJsZSBlcnJvcnMuIFRocm93cyBmb3IgdW5yZXRyaWFibGUgZXJyb3JzLCBhbmQgbG9nc1xyXG4gICAgICogT05MWSBJRiB0aGUgbG9nIG5lZWRzIG1vcmUgaW5mb3JtYXRpb24gdGhhbiB0aGUgb3JkZXJIYXNoIGFuZCB3b3JrZXJBZGRyZXNzLFxyXG4gICAgICogd2hpY2ggYXJlIGxvZ2dlZCBieSB0aGUgYHByb2Nlc3NKb2JBc3luY2Agcm91dGluZS5cclxuICAgICAqIFVwZGF0ZXMgam9iIGluIGRhdGFiYXNlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgY2FsbGRhdGEgZm9yIHRyYWRlIHN1Ym1pc3Npb24gdHlwZS5cclxuICAgICAqIEB0aHJvd3MgSWYgdGhlIHRyYWRlIGNhbm5vdCBiZSBzdWJtaXR0ZWQgKGUuZy4gaXQgaXMgZXhwaXJlZCkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBwcmVwYXJlcmZxbVYyVHJhZGVBc3luYyhcclxuICAgICAgICBqb2I6IFJmcW1WMkpvYkVudGl0eSxcclxuICAgICAgICB3b3JrZXJBZGRyZXNzOiBzdHJpbmcsXHJcbiAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8taW5mZXJyYWJsZS10eXBlc1xyXG4gICAgICAgIHNob3VsZENoZWNrTGFzdExvb2s6IGJvb2xlYW4gPSB0cnVlLFxyXG4gICAgICAgIG5vdzogRGF0ZSA9IG5ldyBEYXRlKCksXHJcbiAgICApOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFzazogVGhpcyBpcyB0aGUgcHJvYmFibHkgdGhlIG9ubHkgY2hhbmdlIEkgbWFkZSB0byB0aGUgb2xkIHRyYWRlIG9ubHkgd29ya2Zsb3cuIFRvIGNoYW5nZSBmcm9tIG1ha2luZyBhIGNvcHkgb2YgcGFyYW1ldGVyXHJcbiAgICAgICAgICogYW5kIHRoZW4gcmV0dXJuaW5nIHRoZSBjb3BpZWQgdmFsdWUgdG8gY2hhbmdlIHBhcmFtZXRlciB2YWx1ZSBkaXJlY3RseS4gVGhlIHJhdGlvbmFsZSBiZWhpbmQgaXMgdG8gbWFrZSB0aGUgc3R5bGUgY29uc2lzdGVudFxyXG4gICAgICAgICAqIHdpdGggdGhlIG5ldyBnZW5lcmFsaXplZCBgc3VibWl0VG9DaGFpbkFzeW5jYCAoaXQgaGFzIHRvIHVzZSBjaGFuZ2luZyBwYXJhbWV0ZXIgdmFsdWUgcGFyYWRpZ20gaW4gb3JkZXIgdG8gd29yaykuIExldCBtZSBrbm93XHJcbiAgICAgICAgICogaWYgeW91IGRvbid0IGxpa2UgdGhpcyBjaGFuZ2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3QgeyBtYWtlclVyaSwgb3JkZXIsIG9yZGVySGFzaCB9ID0gam9iO1xyXG4gICAgICAgIGNvbnN0IG90Y09yZGVyID0gc3RvcmVkT3RjT3JkZXJUb090Y09yZGVyKG9yZGVyKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYWxyZWFkeSBzdWJtaXR0ZWQgYSB0cmFuc2FjdGlvbiBmb3IgdGhpcyBqb2IuXHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSwgdGhlIGpvYiBpcyBhbHJlYWR5IHByZXBhcmVkIGFuZCB3ZSBjYW4gc2tpcCBhaGVhZC5cclxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvblN1Ym1pc3Npb25zID0gYXdhaXQgdGhpcy5fZGJVdGlscy5maW5kVjJUcmFuc2FjdGlvblN1Ym1pc3Npb25zQnlPcmRlckhhc2hBc3luYyhqb2Iub3JkZXJIYXNoKTtcclxuICAgICAgICBpZiAodHJhbnNhY3Rpb25TdWJtaXNzaW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKCFqb2IubWFrZXJTaWduYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlblxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvdW50ZXJlZCBhIGpvYiB3aXRoIHN1Ym1pc3Npb25zIGJ1dCBubyBtYWtlciBzaWduYXR1cmUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWpvYi50YWtlclNpZ25hdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIGEgam9iIHdpdGggc3VibWlzc2lvbnMgYnV0IG5vIHRha2VyIHNpZ25hdHVyZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU3VibWlzc2lvbkNhbGxkYXRhID0gdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdlbmVyYXRlVGFrZXJTaWduZWRPdGNPcmRlckNhbGxEYXRhKFxyXG4gICAgICAgICAgICAgICAgb3RjT3JkZXIsXHJcbiAgICAgICAgICAgICAgICBqb2IubWFrZXJTaWduYXR1cmUsXHJcbiAgICAgICAgICAgICAgICBqb2IudGFrZXJTaWduYXR1cmUsXHJcbiAgICAgICAgICAgICAgICBqb2IuaXNVbndyYXAsXHJcbiAgICAgICAgICAgICAgICBqb2IuYWZmaWxpYXRlQWRkcmVzcyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nU3VibWlzc2lvbkNhbGxkYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNob3VsZENoZWNrTGFzdExvb2spIHtcclxuICAgICAgICAgICAgLy8gUGVyZm9ybSB0aGUgcHJlbGltaW5hcnkgam9iIGNoZWNrIGFuZCBnZXR0aW5nIG1hcmtldCBtYWtlciBzaWdhdHVyZVxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNoZWNrSm9iUHJlcHJvY2Vzc2luZ0FzeW5jKGpvYiwgbm93KTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGVja0xhc3RMb29rQXN5bmMoam9iLCB3b3JrZXJBZGRyZXNzLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1ha2VyIHNpZ25hdHVyZSBtdXN0IGFscmVhZHkgYmUgZGVmaW5lZCBoZXJlIC0tIHJlZmluZSB0aGUgdHlwZVxyXG4gICAgICAgIGlmICgham9iLm1ha2VyU2lnbmF0dXJlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFrZXIgc2lnbmF0dXJlIGRvZXMgbm90IGV4aXN0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRha2VyIHNpZ25hdHVyZSBtdXN0IGFscmVhZHkgYmUgZGVmaW5lZCBoZXJlIC0tIHJlZmluZSB0aGUgdHlwZVxyXG4gICAgICAgIGlmICgham9iLnRha2VyU2lnbmF0dXJlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFrZXIgc2lnbmF0dXJlIGRvZXMgbm90IGV4aXN0Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBWZXJpZnkgdGhlIHNpZ25lciB3YXMgdGhlIG1ha2VyXHJcbiAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXHJcbiAgICAgICAgY29uc3Qgc2lnbmVyQWRkcmVzcyA9IGdldFNpZ25lckZyb21IYXNoKG9yZGVySGFzaCwgam9iLm1ha2VyU2lnbmF0dXJlISkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBtYWtlckFkZHJlc3MgPSBvcmRlci5vcmRlci5tYWtlci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChzaWduZXJBZGRyZXNzICE9PSBtYWtlckFkZHJlc3MpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmluZm8oeyBzaWduZXJBZGRyZXNzLCBtYWtlckFkZHJlc3MsIG9yZGVySGFzaCwgbWFrZXJVcmkgfSwgJ1Bvc3NpYmxlIHVzZSBvZiBzbWFydCBjb250cmFjdCB3YWxsZXQnKTtcclxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNpZ25lciA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5pc1ZhbGlkT3JkZXJTaWduZXJBc3luYyhtYWtlckFkZHJlc3MsIHNpZ25lckFkZHJlc3MpO1xyXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRTaWduZXIpIHtcclxuICAgICAgICAgICAgICAgIGpvYi5zdGF0dXMgPSBSZnFtSm9iU3RhdHVzLkZhaWxlZFNpZ25GYWlsZWQ7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9kYlV0aWxzLnVwZGF0ZVJmcW1Kb2JBc3luYyhqb2IpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9yZGVyIHNpZ25lciBhZGRyZXNzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSBjYWxsZGF0YVxyXG4gICAgICAgIGNvbnN0IGNhbGxkYXRhID0gdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdlbmVyYXRlVGFrZXJTaWduZWRPdGNPcmRlckNhbGxEYXRhKFxyXG4gICAgICAgICAgICBvdGNPcmRlcixcclxuICAgICAgICAgICAgam9iLm1ha2VyU2lnbmF0dXJlLFxyXG4gICAgICAgICAgICBqb2IudGFrZXJTaWduYXR1cmUsXHJcbiAgICAgICAgICAgIGpvYi5pc1Vud3JhcCxcclxuICAgICAgICAgICAgam9iLmFmZmlsaWF0ZUFkZHJlc3MsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gV2l0aCB0aGUgTWFya2V0IE1ha2VyIHNpZ25hdHVyZSwgZXhlY3V0ZSBhIGZ1bGwgZXRoX2NhbGwgdG8gdmFsaWRhdGUgdGhlXHJcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gdmlhIGBlc3RpbWF0ZUdhc0ZvckZpbGxUYWtlclNpZ25lZE90Y09yZGVyQXN5bmNgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgcmV0cnkoXHJcbiAgICAgICAgICAgICAgICBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZXIgc2lnbmF0dXJlIG11c3QgYWxyZWFkeSBiZSBkZWZpbmVkIGhlcmUgLS0gcmVmaW5lIHRoZSB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqb2IubWFrZXJTaWduYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWtlciBzaWduYXR1cmUgZG9lcyBub3QgZXhpc3QnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGFrZXIgc2lnbmF0dXJlIG11c3QgYWxyZWFkeSBiZSBkZWZpbmVkIGhlcmUgLS0gcmVmaW5lIHRoZSB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqb2IudGFrZXJTaWduYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWtlciBzaWduYXR1cmUgZG9lcyBub3QgZXhpc3QnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZXN0aW1hdGVHYXNGb3JGaWxsVGFrZXJTaWduZWRPdGNPcmRlckFzeW5jKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGNPcmRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9iLm1ha2VyU2lnbmF0dXJlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2IudGFrZXJTaWduYXR1cmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlckFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvYi5pc1Vud3JhcCxcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheTogT05FX1NFQ09ORF9NUyxcclxuICAgICAgICAgICAgICAgICAgICBmYWN0b3I6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4QXR0ZW1wdHM6IDMsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3I6IChlcnJvciwgY29udGV4dCwgX29wdGlvbnMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhdHRlbXB0TnVtOiBhdHRlbXB0TnVtYmVyLCBhdHRlbXB0c1JlbWFpbmluZyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG9yZGVySGFzaCwgbWFrZXJVcmksIGF0dGVtcHROdW1iZXIsIGF0dGVtcHRzUmVtYWluaW5nLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Vycm9yIGR1cmluZyBldGhfY2FsbCB2YWxpZGF0aW9uIHdoZW4gcHJlcGFyaW5nIG90YyBvcmRlciB0cmFkZS4gUmV0cnlpbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGpvYi5zdGF0dXMgPSBSZnFtSm9iU3RhdHVzLkZhaWxlZEV0aENhbGxGYWlsZWQ7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbUpvYkFzeW5jKGpvYik7XHJcblxyXG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICB7IG9yZGVySGFzaCwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSxcclxuICAgICAgICAgICAgICAgICdldGhfY2FsbCB2YWxpZGF0aW9uIGZhaWxlZCB3aGVuIHByZXBhcmluZyBvdGMgb3JkZXIgdHJhZGUnLFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBnYXRoZXIgZXh0cmEgY29udGV4dCB1cG9uIGV0aF9jYWxsIGZhaWx1cmVcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFttYWtlckJhbGFuY2VdID0gYXdhaXQgdGhpcy5fcmZxTWFrZXJCYWxhbmNlQ2FjaGVTZXJ2aWNlLmdldEVSQzIwT3duZXJCYWxhbmNlc0FzeW5jKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYWluSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgeyBvd25lcjogb3RjT3JkZXIubWFrZXIsIHRva2VuOiBvdGNPcmRlci5tYWtlclRva2VuIH0sXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW3Rha2VyQmFsYW5jZV0gPSBhd2FpdCB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZ2V0TWluT2ZCYWxhbmNlc0FuZEFsbG93YW5jZXNBc3luYyh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IG90Y09yZGVyLnRha2VyLFxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBvdGNPcmRlci50YWtlclRva2VuLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZXRDdXJyZW50QmxvY2tBc3luYygpO1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlckJhbGFuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRha2VyQmFsYW5jZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlckhhc2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyOiBvdGNPcmRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVja2V0OiBvdGNPcmRlci5ub25jZUJ1Y2tldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9uY2U6IG90Y09yZGVyLm5vbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgJ0V4dHJhIGNvbnRleHQgYWZ0ZXIgZXRoX2NhbGwgdmFsaWRhdGlvbiBmYWlsZWQgd2hlbiBwcmVwYXJpbmcgb3RjIG9yZGVyIHRyYWRlJyxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcclxuICAgICAgICAgICAgICAgICAgICB7IG9yZGVySGFzaCB9LFxyXG4gICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZ2V0IGV4dHJhIGNvbnRleHQgYWZ0ZXIgZXRoX2NhbGwgdmFsaWRhdGlvbiBmYWlsZWQgd2hlbiBwcmVwYXJpbmcgb3RjIG9yZGVyIHRyYWRlJyxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdGggY2FsbCB2YWxpZGF0aW9uIGZhaWxlZCB3aGVuIHByZXBhcmluZyBvdGMgb3JkZXIgdHJhZGUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjYWxsZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByZXBhcmVzIGEgbWV0YS10cmFuc2FjdGlvbiBqb2IgZm9yIHRyYWRlIHN1Ym1pc3Npb24gYnkgdmFsaWRhdGlkYXRpbmcgdGhlIGpvYiBhbmQgY29uc3RydWN0aW5nIHRoZSBjYWxsZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgYGpvYi5zdGF0dXNgIHdvdWxkIGJlIG1vZGlmaWVkIHRvIGNvcnJlc3BvbmRpbmcgc3RhdHVzLiBGb3IgZXhhbXBsZSwgaWYgdGhlIG1ldGEtdHJhbnNhY3Rpb24gZXhwaXJlcyxcclxuICAgICAqIGBqb2Iuc3RhdHVzYCB3b3VsZCBiZSBzZXQgdG8gYEZhaWxlZEZhaWxlZEV4cGlyZWRgLlxyXG4gICAgICpcclxuICAgICAqIEhhbmRsZXMgcmV0cmllcyBvZiByZXRyeWFibGUgZXJyb3JzLiBUaHJvd3MgZm9yIHVucmV0cmlhYmxlIGVycm9ycywgYW5kIGxvZ3NcclxuICAgICAqIE9OTFkgSUYgdGhlIGxvZyBuZWVkcyBtb3JlIGluZm9ybWF0aW9uIHRoYW4gdGhlIG9yZGVySGFzaCBhbmQgd29ya2VyQWRkcmVzcyxcclxuICAgICAqIHdoaWNoIGFyZSBsb2dnZWQgYnkgdGhlIGBwcm9jZXNzSm9iQXN5bmNgIHJvdXRpbmUuXHJcbiAgICAgKiBVcGRhdGVzIGpvYiBpbiBkYXRhYmFzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIGNhbGxkYXRhIGZvciB0cmFkZSBzdWJtaXNzaW9uIHR5cGUuXHJcbiAgICAgKiBAdGhyb3dzIElmIHRoZSB0cmFkZSBjYW5ub3QgYmUgc3VibWl0dGVkIChlLmcuIGl0IGlzIGV4cGlyZWQpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcHJlcGFyZU1ldGFUcmFuc2FjdGlvblRyYWRlQXN5bmMoXHJcbiAgICAgICAgam9iOiBNZXRhVHJhbnNhY3Rpb25Kb2JFbnRpdHksXHJcbiAgICAgICAgd29ya2VyQWRkcmVzczogc3RyaW5nLFxyXG4gICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWluZmVycmFibGUtdHlwZXNcclxuICAgICAgICBzaG91bGRWYWxpZGF0ZUpvYjogYm9vbGVhbiA9IHRydWUsXHJcbiAgICAgICAgbm93OiBEYXRlID0gbmV3IERhdGUoKSxcclxuICAgICk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgLy8gQVNLOiBXaGF0J3MgdGhlIGRpZmZlcmVuY2UgYmV3dHdlZW4gYG1ldGFUcmFuc2FjdGlvbi5zaWduZXJgIHZzIGBtZXRhVHJhbnNhY3Rpb24uc2VuZGVyYD9cclxuICAgICAgICAvLyAgICAgIFdoaWNoIG9uZSBpcyB0aGUgdGFrZXIgYWRkcmVzcz9cclxuICAgICAgICBjb25zdCB7IGFmZmlsaWF0ZUFkZHJlc3MsIGlkOiBqb2JJZCwgaW5wdXRUb2tlbiwgbWV0YVRyYW5zYWN0aW9uLCB0YWtlckFkZHJlc3MsIHRha2VyU2lnbmF0dXJlIH0gPSBqb2I7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGFscmVhZHkgc3VibWl0dGVkIGEgdHJhbnNhY3Rpb24gZm9yIHRoaXMgam9iLlxyXG4gICAgICAgIC8vIElmIHdlIGhhdmUsIHRoZSBqb2IgaXMgYWxyZWFkeSBwcmVwYXJlZCBhbmQgd2UgY2FuIHNraXAgYWhlYWQuXHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25TdWJtaXNzaW9ucyA9IGF3YWl0IHRoaXMuX2RiVXRpbHMuZmluZE1ldGFUcmFuc2FjdGlvblN1Ym1pc3Npb25zQnlKb2JJZEFzeW5jKGpvYklkKTtcclxuICAgICAgICBpZiAodHJhbnNhY3Rpb25TdWJtaXNzaW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKCF0YWtlclNpZ25hdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIGEgam9iIHdpdGggc3VibWlzc2lvbnMgYnV0IG5vIHRha2VyIHNpZ25hdHVyZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU3VibWlzc2lvbkNhbGxkYXRhID0gdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdlbmVyYXRlTWV0YVRyYW5zYWN0aW9uQ2FsbERhdGEoXHJcbiAgICAgICAgICAgICAgICBtZXRhVHJhbnNhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICB0YWtlclNpZ25hdHVyZSxcclxuICAgICAgICAgICAgICAgIGFmZmlsaWF0ZUFkZHJlc3MsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ1N1Ym1pc3Npb25DYWxsZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzaG91bGRWYWxpZGF0ZUpvYikge1xyXG4gICAgICAgICAgICAvLyBQZXJmb3JtIHRoZSBwcmVsaW1pbmFyeSBqb2IgY2hlY2tcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGVja0pvYlByZXByb2Nlc3NpbmdBc3luYyhqb2IsIG5vdyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUYWtlciBzaWduYXR1cmUgbXVzdCBhbHJlYWR5IGJlIGRlZmluZWQgaGVyZSAtLSByZWZpbmUgdGhlIHR5cGVcclxuICAgICAgICBpZiAoIXRha2VyU2lnbmF0dXJlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFrZXIgc2lnbmF0dXJlIGRvZXMgbm90IGV4aXN0Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgY2FsbGRhdGFcclxuICAgICAgICBjb25zdCBjYWxsZGF0YSA9IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZW5lcmF0ZU1ldGFUcmFuc2FjdGlvbkNhbGxEYXRhKFxyXG4gICAgICAgICAgICBtZXRhVHJhbnNhY3Rpb24sXHJcbiAgICAgICAgICAgIHRha2VyU2lnbmF0dXJlLFxyXG4gICAgICAgICAgICBhZmZpbGlhdGVBZGRyZXNzLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIGV4ZWN1dGUgYSBmdWxsIGV0aF9jYWxsIHRvIHZhbGlkYXRlIHRoZVxyXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIHZpYSBgZXN0aW1hdGVHYXNGb3JBc3luY2BcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCByZXRyeShcclxuICAgICAgICAgICAgICAgIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGdhcyBmZWUgb3BlcmF0aW9ucyBhcmUgYWRkZWQgYmVjYXVzZSBgZXhlY3V0ZU1ldGFUcmFuc2FjdGlvbmAgaW4gMHggRXhjaGFuZ2UgUHJveHlcclxuICAgICAgICAgICAgICAgICAgICAvLyB3b3VsZCBjaGVjayB3aGV0aGVyIHRoZSBnYXMgcHJpY2Ugb2YgdGhlIHRyYW5zYWN0aW9uIGlzIHdpdGhpbiBhIHdpbmRvdy4gSWYgbGVmdCBlbXB0eSwgaXQgd2lsbFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZhaWwgdGhlIHNpbXVsYXRpb24uIFRoZSBnYXMgZmVlIGVzdGltYXRpb24gYmVsb3cgaXMgdGhlIHNhbWUgYXMgdGhlIGZpcnN0IGdhcyBmZWUgZXN0aW1hdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgaW4gYHN1Ym1pdFRvQ2hhaW5gLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLl9nYXNTdGF0aW9uQXR0ZW5kYW50LmdldEV4cGVjdGVkVHJhbnNhY3Rpb25HYXNSYXRlQXN5bmMoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsTWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBuZXcgQmlnTnVtYmVyKHRoaXMuX2luaXRpYWxNYXhQcmlvcml0eUZlZVBlckdhc0d3ZWkpLnRpbWVzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdygxMCwgR1dFSV9ERUNJTUFMUyksXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNGZWVzOiBHYXNGZWVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXM6IEJpZ051bWJlci5taW4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXNQcmljZUVzdGltYXRlLm11bHRpcGxpZWRCeSgyKS5wbHVzKGluaXRpYWxNYXhQcmlvcml0eUZlZVBlckdhcyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbWF4IGZlZSBpcyBsZXNzIHRoYW4gdGhlIGJhc2UgZmVlLCBzaW11bGF0aW9ucyB3aWxsIGZhaWwgKHVubGlrZSBzdWJtaXNzaW9ucywgd2hpY2ggbWF5IHNpdCBpbiB0aGUgbWVtcG9vbCkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbiBleHRyYSBtdWx0aXBsaWVyIG1pdGlnYXRlcywgYnV0IGRvZXMgbm90IHNvbHZlLCB0aGUgaXNzdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXhGZWVQZXJHYXNDYXBXZWkubXVsdGlwbGllZEJ5KFNJTVVMQVRJT05fTUFYX0dBU19NVUxUSVBMSUVSKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGluaXRpYWxNYXhQcmlvcml0eUZlZVBlckdhcyxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2tjaGFpblV0aWxzLmVzdGltYXRlR2FzRm9yQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB3b3JrZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldEV4Y2hhbmdlUHJveHlBZGRyZXNzKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNhbGxkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXM6IGdhc0ZlZXMubWF4RmVlUGVyR2FzLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBnYXNGZWVzLm1heFByaW9yaXR5RmVlUGVyR2FzLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5OiBPTkVfU0VDT05EX01TLFxyXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcjogMSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhBdHRlbXB0czogMyxcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcjogKGVycm9yLCBjb250ZXh0LCBfb3B0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGF0dGVtcHROdW06IGF0dGVtcHROdW1iZXIsIGF0dGVtcHRzUmVtYWluaW5nIH0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgam9iSWQsIGF0dGVtcHROdW1iZXIsIGF0dGVtcHRzUmVtYWluaW5nLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Vycm9yIGR1cmluZyBldGhfY2FsbCB2YWxpZGF0aW9uIHdoZW4gcHJlcGFyaW5nIG1ldGEtdHJhbnNhY3Rpb24gdHJhZGUuIFJldHJ5aW5nJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBqb2Iuc3RhdHVzID0gUmZxbUpvYlN0YXR1cy5GYWlsZWRFdGhDYWxsRmFpbGVkO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9kYlV0aWxzLnVwZGF0ZVJmcW1Kb2JBc3luYyhqb2IpO1xyXG5cclxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgeyBqb2JJZCwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSxcclxuICAgICAgICAgICAgICAgICdldGhfY2FsbCB2YWxpZGF0aW9uIGZhaWxlZCB3aGVuIHByZXBhcmluZyBtZXRhLXRyYW5zYWN0aW9uIHRyYWRlJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ2F0aGVyIGV4dHJhIGNvbnRleHQgdXBvbiBldGhfY2FsbCBmYWlsdXJlXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbdGFrZXJCYWxhbmNlXSA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZXRNaW5PZkJhbGFuY2VzQW5kQWxsb3dhbmNlc0FzeW5jKFtcclxuICAgICAgICAgICAgICAgICAgICB7IG93bmVyOiB0YWtlckFkZHJlc3MsIHRva2VuOiBpbnB1dFRva2VuIH0sXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldEN1cnJlbnRCbG9ja0FzeW5jKCk7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9iSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFUcmFuc2FjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFrZXJCYWxhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgJ0V4dHJhIGNvbnRleHQgYWZ0ZXIgZXRoX2NhbGwgdmFsaWRhdGlvbiBmYWlsZWQgd2hlbiBwcmVwYXJpbmcgbWV0YS10cmFuc2FjdGlvbiB0cmFkZScsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXHJcbiAgICAgICAgICAgICAgICAgICAgeyBqb2JJZCB9LFxyXG4gICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZ2V0IGV4dHJhIGNvbnRleHQgYWZ0ZXIgZXRoX2NhbGwgdmFsaWRhdGlvbiBmYWlsZWQgd2hlbiBwcmVwYXJpbmcgbWV0YS10cmFuc2FjdGlvbiB0cmFkZSAnLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aCBjYWxsIHZhbGlkYXRpb24gZmFpbGVkIHdoZW4gcHJlcGFyaW5nIG1ldGEtdHJhbnNhY3Rpb24gdHJhZGUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjYWxsZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGxhc3QgbG9vayBieSBnZXR0aW5nIG1hcmtldCBtYWtlciBzaWduYXR1cmUuIEhhbmRsZXMgcmV0cmllcyB3aGVuIG1ha2luZyByZXF1ZXN0IHRvIG1hcmtldCBtYWtlciBzZXJ2ZXJzLlxyXG4gICAgICpcclxuICAgICAqIFdoZW4gdmVyaWZ5aW5nIHRoZSBvcmRlciBpcyBmaWxsYWJsZSBieSBib3RoIHRoZSBtYWtlciBhbmQgdGhlIHRha2VyOlxyXG4gICAgICogLSBJZiBgc2hvdWxkQ2hlY2tBbGxvd2FuY2VgIGlzIGZhbHNlLCB0aGUgbWV0aG9kIHdvdWxkIG9ubHkgY2hlY2sgYmFsYW5jZXMgYnV0IG5vdCB0aGUgYWxsb3dhbmNlcyB0aGUgbWFrZXIgYW5kXHJcbiAgICAgKiAgIHRoZSB0YWtlciBzZXQgZm9yIDB4IGV4Y2hhbmdlIHByb3h5IGJlY2F1c2UgdGhlIHRha2VyIGFsbG93YW5jZSB3aWxsIG5vdCBiZSBzZXQgd2hlbiBgY2hlY2tMYXN0TG9va0FzeW5jYCBpcyBjYWxsZWQgYXMgd2VcclxuICAgICAqICAgd2FudCB0byBjYWxsIHRoaXMgbWV0aG9kIGFzIHNvb24gYXMgcG9zc2libGUgdG8gbWl0aWdhdGUgdGhlIGxhdGVuY3kgYnJvdWdodCBieSBzZXF1ZW50aWFsIHN1Ym1pc3Npb25zXHJcbiAgICAgKiAgICh3aGljaCB3b3VsZCBsZWFkIHRvIGhpZ2hlciBkZWNsaW5lIHRvIHNpZ24gcmF0ZSkuXHJcbiAgICAgKiAtIE90aGVyd2lzZSwgYm90aCBiYWxhbmNlcyBhbmQgYWxsb3dhbmNlcyB3b3VsZCBiZSBjaGVja2VkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgY2hlY2tMYXN0TG9va0FzeW5jKFxyXG4gICAgICAgIGpvYjogUmZxbVYySm9iRW50aXR5LFxyXG4gICAgICAgIHdvcmtlckFkZHJlc3M6IHN0cmluZyxcclxuICAgICAgICBzaG91bGRDaGVja0FsbG93YW5jZTogYm9vbGVhbixcclxuICAgICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHsgbWFrZXJVcmksIG9yZGVyLCBvcmRlckhhc2gsIHRha2VyU2lnbmF0dXJlIH0gPSBqb2I7XHJcbiAgICAgICAgY29uc3Qgb3RjT3JkZXIgPSBzdG9yZWRPdGNPcmRlclRvT3RjT3JkZXIob3JkZXIpO1xyXG4gICAgICAgIGxldCB7IG1ha2VyU2lnbmF0dXJlIH0gPSBqb2I7XHJcblxyXG4gICAgICAgIGlmIChtYWtlclNpZ25hdHVyZSkge1xyXG4gICAgICAgICAgICAvLyBNYXJrZXQgTWFrZXIgaGFkIGFscmVhZHkgc2lnbmVkIG9yZGVyXHJcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKHsgd29ya2VyQWRkcmVzcywgb3JkZXJIYXNoIH0sICdPcmRlciBhbHJlYWR5IHNpZ25lZCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHZhbGlkYXRlIHRoYXQgb3JkZXIgaXMgZmlsbGFibGUgYnkgYm90aCB0aGUgbWFrZXIgYW5kIHRoZSB0YWtlciBhY2NvcmRpbmcgdG8gYmFsYW5jZXMgKGFuZCBhbGxvd2FuY2VzXHJcbiAgICAgICAgICAgIC8vIHdoZW4gYHNob3VsZENoZWNrQWxsb3dhbmNlYCBpcyB0cnVlKVxyXG4gICAgICAgICAgICBjb25zdCBbbWFrZXJCYWxhbmNlXSA9IGF3YWl0IHRoaXMuX3JmcU1ha2VyQmFsYW5jZUNhY2hlU2VydmljZS5nZXRFUkMyME93bmVyQmFsYW5jZXNBc3luYyh0aGlzLl9jaGFpbklkLCB7XHJcbiAgICAgICAgICAgICAgICBvd25lcjogb3RjT3JkZXIubWFrZXIsXHJcbiAgICAgICAgICAgICAgICB0b2tlbjogb3RjT3JkZXIubWFrZXJUb2tlbixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IFt0YWtlckJhbGFuY2VdID0gc2hvdWxkQ2hlY2tBbGxvd2FuY2VcclxuICAgICAgICAgICAgICAgID8gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldE1pbk9mQmFsYW5jZXNBbmRBbGxvd2FuY2VzQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgb3duZXI6IG90Y09yZGVyLnRha2VyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW46IG90Y09yZGVyLnRha2VyVG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICA6IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5nZXRUb2tlbkJhbGFuY2VzQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgb3duZXI6IG90Y09yZGVyLnRha2VyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW46IG90Y09yZGVyLnRha2VyVG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1ha2VyQmFsYW5jZS5sdChvdGNPcmRlci5tYWtlckFtb3VudCkgfHwgdGFrZXJCYWxhbmNlLmx0KG90Y09yZGVyLnRha2VyQW1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJIYXNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlckJhbGFuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRha2VyQmFsYW5jZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZXJBbW91bnQ6IG90Y09yZGVyLm1ha2VyQW1vdW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWtlckFtb3VudDogb3RjT3JkZXIudGFrZXJBbW91bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAnT3JkZXIgZmFpbGVkIHByZS1zaWduIHZhbGlkYXRpb24nLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGpvYi5zdGF0dXMgPSBSZnFtSm9iU3RhdHVzLkZhaWxlZFByZXNpZ25WYWxpZGF0aW9uRmFpbGVkO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGJVdGlscy51cGRhdGVSZnFtSm9iQXN5bmMoam9iKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3JkZXIgZmFpbGVkIHByZS1zaWduIHZhbGlkYXRpb24nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCF0YWtlclNpZ25hdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdPcmRlciBmYWlsZWQgcHJlLXNpZ24gdmFsaWRhdGlvbiBkdWUgdG8gZW1wdHkgdGFrZXJTaWduYXR1cmUnKTtcclxuICAgICAgICAgICAgICAgIGpvYi5zdGF0dXMgPSBSZnFtSm9iU3RhdHVzLkZhaWxlZFByZXNpZ25WYWxpZGF0aW9uRmFpbGVkO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGJVdGlscy51cGRhdGVSZnFtSm9iQXN5bmMoam9iKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3JkZXIgZmFpbGVkIHByZS1zaWduIHZhbGlkYXRpb24gZHVlIHRvIGVtcHR5IHRha2VyU2lnbmF0dXJlJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ25SZXF1ZXN0OiBTaWduUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIGV4cGlyeTogam9iLmV4cGlyeSxcclxuICAgICAgICAgICAgICAgIGZlZTogc3RvcmVkRmVlVG9GZWUoam9iLmZlZSksXHJcbiAgICAgICAgICAgICAgICBvcmRlcjogb3RjT3JkZXIsXHJcbiAgICAgICAgICAgICAgICBvcmRlckhhc2gsXHJcbiAgICAgICAgICAgICAgICB0YWtlclNpZ25hdHVyZSxcclxuICAgICAgICAgICAgICAgIC4uLihqb2IudGFrZXJTcGVjaWZpZWRTaWRlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgVEFLRVJfU1BFQ0lGSUVEX1NJREVfRU5BQkxFRCAmJiB7IHRha2VyU3BlY2lmaWVkU2lkZTogam9iLnRha2VyU3BlY2lmaWVkU2lkZSB9KSxcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIFwiTGFzdCBMb29rXCIgaW4gdjEgaXMgcmVwbGFjZWQgYnkgbWFya2V0IG1ha2VyIG9yZGVyIHNpZ25pbmcgaW4gdjIuXHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ25BdHRlbXB0VGltZU1zID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIG1ha2VyU2lnbmF0dXJlID0gYXdhaXQgcmV0cnkoXHJcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMgKCkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVvdGVTZXJ2ZXJDbGllbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zaWduVjJBc3luYyhtYWtlclVyaSwgam9iLmludGVncmF0b3JJZCA/PyAnJywgc2lnblJlcXVlc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigocykgPT4gcyA/PyBudWxsKSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiBPTkVfU0VDT05EX01TLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3I6IDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEF0dGVtcHRzOiAzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcjogKGVycm9yLCBjb250ZXh0LCBfb3B0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhdHRlbXB0TnVtOiBhdHRlbXB0TnVtYmVyLCBhdHRlbXB0c1JlbWFpbmluZyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgb3JkZXJIYXNoLCBtYWtlclVyaSwgYXR0ZW1wdE51bWJlciwgYXR0ZW1wdHNSZW1haW5pbmcsIGVycm9yOiBlcnJvci5tZXNzYWdlIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Vycm9yIGVuY291bnRlcmVkIHdoaWxlIGF0dGVtcHRpbmcgdG8gZ2V0IG1hcmtldCBtYWtlciBzaWduYXR1cmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBzaWduIHByb2Nlc3MgaGFzIGZhaWxlZCBhZnRlciByZXRyaWVzXHJcbiAgICAgICAgICAgICAgICBSRlFNX0pPQl9GQUlMRURfTU1fU0lHTkFUVVJFX0ZBSUxFRC5sYWJlbHMobWFrZXJVcmksIHRoaXMuX2NoYWluSWQudG9TdHJpbmcoKSkuaW5jKCk7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgeyBvcmRlckhhc2gsIG1ha2VyVXJpLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICdSRlFNIHYyIGpvYiBmYWlsZWQgZHVlIHRvIG1hcmtldCBtYWtlciBzaWduIGZhaWx1cmUnLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGpvYi5zdGF0dXMgPSBSZnFtSm9iU3RhdHVzLkZhaWxlZFNpZ25GYWlsZWQ7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9kYlV0aWxzLnVwZGF0ZVJmcW1Kb2JBc3luYyhqb2IpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKb2IgZmFpbGVkIGR1cmluZyBtYXJrZXQgbWFrZXIgc2lnbiBhdHRlbXB0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKHsgbWFrZXJVcmksIHNpZ25lZDogISFtYWtlclNpZ25hdHVyZSwgb3JkZXJIYXNoIH0sICdHb3Qgc2lnbmF0dXJlIHJlc3BvbnNlIGZyb20gbWFya2V0IG1ha2VyJyk7XHJcbiAgICAgICAgICAgIGlmICghbWFrZXJTaWduYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1hcmtldCBNYWtlciBoYXMgZGVjbGluZWQgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25cclxuICAgICAgICAgICAgICAgIFJGUU1fSk9CX01NX1JFSkVDVEVEX0xBU1RfTE9PSy5sYWJlbHMobWFrZXJVcmksIHRoaXMuX2NoYWluSWQudG9TdHJpbmcoKSkuaW5jKCk7XHJcbiAgICAgICAgICAgICAgICBqb2IubGFzdExvb2tSZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGpvYi5zdGF0dXMgPSBSZnFtSm9iU3RhdHVzLkZhaWxlZExhc3RMb29rRGVjbGluZWQ7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9kYlV0aWxzLnVwZGF0ZVJmcW1Kb2JBc3luYyhqb2IpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChFTkFCTEVfTExSX0NPT0xET1dOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcXVvdGUgPSBhd2FpdCB0aGlzLl9kYlV0aWxzLmZpbmRWMlF1b3RlQnlPcmRlckhhc2hBc3luYyhvcmRlckhhc2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVvdGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgcXVvdGUgd2l0aCBvcmRlciBoYXNoICR7b3JkZXJIYXNofWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgYmFkYCBsYXN0IGxvb2sgcmVqZWN0aW9uLCByZWplY3RlZCB3aXRoaW4gdGhlIGNvb2xkb3duIHdpbmRvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduQXR0ZW1wdFRpbWVNcyAtIHF1b3RlLmNyZWF0ZWRBdC52YWx1ZU9mKCkgPFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTExSX0NPT0xET1dOX1dJTkRPV19TRUNPTkRTICogT05FX1NFQ09ORF9NU1xyXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ha2VySWQgPSB0aGlzLl9yZnFNYWtlck1hbmFnZXIuZmluZE1ha2VySWRXaXRoUmZxbVVyaShtYWtlclVyaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFrZXJJZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgbWFrZXIgSUQgd2l0aCBSRlFtIFVSSSAke21ha2VyVXJpfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb2xkb3duRW5kVGltZU1zID0gc2lnbkF0dGVtcHRUaW1lTXMgKyBMTFJfQ09PTERPV05fRFVSQVRJT05fU0VDT05EUyAqIE9ORV9TRUNPTkRfTVM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2NoZWR1bGUgY29vbGRvd25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzU2NoZWR1bGVVcGRhdGVkID0gYXdhaXQgdGhpcy5fY2FjaGVDbGllbnQuYWRkTWFrZXJUb0Nvb2xkb3duQXN5bmMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZXJJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29sZG93bkVuZFRpbWVNcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90Y09yZGVyLm1ha2VyVG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RjT3JkZXIudGFrZXJUb2tlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlcklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiB0aGlzLl9jaGFpbklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlclRva2VuOiBvdGNPcmRlci5tYWtlclRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWtlclRva2VuOiBvdGNPcmRlci50YWtlclRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHNpZ25BdHRlbXB0VGltZU1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRUaW1lOiBjb29sZG93bkVuZFRpbWVNcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJIYXNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NjaGVkdWxlVXBkYXRlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdMTFIgY29vbGRvd24gc2NoZWR1bGVkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgY29vbGRvd24gZW50cnkgdG8gZGIgZm9yIHJlY29yZCBrZWVwaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGJVdGlscy53cml0ZVYyTGFzdExvb2tSZWplY3Rpb25Db29sZG93bkFzeW5jKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlcklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGNPcmRlci5tYWtlclRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGNPcmRlci50YWtlclRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShzaWduQXR0ZW1wdFRpbWVNcyksIC8vIHN0YXJ0VGltZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShjb29sZG93bkVuZFRpbWVNcyksIC8vIGVuZFRpbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJIYXNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oeyBvcmRlckhhc2gsIGVycm9yTWVzc2FnZTogZS5tZXNzYWdlIH0sICdTYXZpbmcgTExSIGNvb2xkb3duIGZhaWxlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGVycm9yTWVzc2FnZTogZXJyb3IubWVzc2FnZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0VuY291bnRlcmVkIGVycm9yIHdoZW4gZGV0ZWN0aW5nIGJhZCBMTFIgYW5kIHNjaGVkdWxpbmcgY29vbGRvd24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSdkIGxpa2Ugc29tZSBkYXRhIG9uIGhvdyBtdWNoIHRoZSBwcmljZSB0aGUgbWFya2V0IG1ha2VyIGlzIG9mZmVyaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBoYXMgY2hhbmdlZC4gV2UgcXVlcnkgdGhlIG1hcmtldCBtYWtlcidzIHByaWNlIGVuZHBvaW50IHdpdGggdGhlIHNhbWVcclxuICAgICAgICAgICAgICAgIC8vIHRyYWRlIHRoZXkndmUganVzdCBkZWNsaW5lZCB0byBzaWduIGFuZCBsb2cgdGhlIHJlc3VsdC5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjbGluZVRvU2lnblByaWNlQ2hlY2tUaW1lTXMgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG90Y09yZGVyUGFyYW1zID0gUXVvdGVTZXJ2ZXJDbGllbnQubWFrZVF1ZXJ5UGFyYW1ldGVycyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuX2NoYWluSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4T3JpZ2luOiB0aGlzLl9yZWdpc3RyeUFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRha2VyQWRkcmVzczogb3RjT3JkZXIudGFrZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtldE9wZXJhdGlvbjogTWFya2V0T3BlcmF0aW9uLlNlbGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1eVRva2VuQWRkcmVzczogb3RjT3JkZXIubWFrZXJUb2tlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsbFRva2VuQWRkcmVzczogb3RjT3JkZXIudGFrZXJUb2tlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXRGaWxsQW1vdW50OiBvdGNPcmRlci50YWtlckFtb3VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNMYXN0TG9vazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVlOiBzdG9yZWRGZWVUb0ZlZShqb2IuZmVlKSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGFkZGluZyBhIGRlcGVuZGVuY3kgdG8gYENvbmZpZ01hbmFnZXJgIHRvIGdldCB0aGUgYWN0dWFsIGludGVncmF0b3JcclxuICAgICAgICAgICAgICAgICAgICAvLyAod2Ugb25seSBoYXZlIHRoZSBJRCBhdCB0aGlzIHBvaW50KSwganVzdCBjcmVhdGUgYSBzdGFuZC1pbi5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgc2VuZCB0aGUgc2FtZSBpbnRlZ3JhdG9yIElEIHRvIHRoZSBtYXJrZXQgbWFrZXI7IHRoZXkgd2lsbCBub3QgYmVcclxuICAgICAgICAgICAgICAgICAgICAvLyBhYmxlIHRvIHRlbGwgdGhlIGRpZmZlcmVuY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYGxvZ1JmcU1ha2VyTmV0d29ya0ludGVyYWN0aW9uYCBkb2VzIHVzZSB0aGUgYGxhYmVsYCwgaG93ZXZlciwgYnV0IEkgdGhpbmsgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhZGVvZmYgaXMgcmVhc29uYWJsZS5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlZ3JhdG9yOiBJbnRlZ3JhdG9yID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlLZXlzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhdG9ySWQ6IGpvYi5pbnRlZ3JhdG9ySWQhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2VkQ2hhaW5JZHM6IFt0aGlzLl9jaGFpbklkXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdkZWNsaW5lLXRvLXNpZ24tcHJpY2UtY2hlY2snLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbHA6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJmcW06IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJmcXQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmljZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcXVvdGVTZXJ2ZXJDbGllbnQuZ2V0UHJpY2VWMkFzeW5jKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2IubWFrZXJVcmksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVncmF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG90Y09yZGVyUGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodTogc3RyaW5nKSA9PiBgJHt1fS9yZnFtL3YyL3ByaWNlYCxcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJpY2VSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYSBwcmljZSByZXNwb25zZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG1ha2VyQW1vdW50OiBwcmljZUNoZWNrTWFrZXJBbW91bnQsIHRha2VyQW1vdW50OiBwcmljZUNoZWNrVGFrZXJBbW91bnQgfSA9IHByaWNlUmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxQcmljZSA9IG90Y09yZGVyLm1ha2VyQW1vdW50LmRpdmlkZWRCeShwcmljZUNoZWNrVGFrZXJBbW91bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByaWNlQWZ0ZXJSZWplY3QgPSBwcmljZUNoZWNrTWFrZXJBbW91bnQuZGl2aWRlZEJ5KHByaWNlQ2hlY2tUYWtlckFtb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmlwc0ZhY3RvciA9IDEwMDAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByaWNlRGlmZmVyZW5jZUJpcHMgPSBvcmlnaW5hbFByaWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5taW51cyhwcmljZUFmdGVyUmVqZWN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGl2aWRlZEJ5KG9yaWdpbmFsUHJpY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hYnNvbHV0ZVZhbHVlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRpbWVzKGJpcHNGYWN0b3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50b1ByZWNpc2lvbigxKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdGltZSwgaW4gc2Vjb25kcywgYmV0d2VlbiB3aGVuIHdlIGluaXRpYXRlZCB0aGUgc2lnbiBhdHRlbXB0IGFuZCB3aGVuIHdlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhdGVkIHRoZSBwcmljZSBjaGVjayBhZnRlciB0aGUgbWFrZXIgZGVjbGluZWQgdG8gc2lnbi5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmljZUNoZWNrRGVsYXlTID0gKGRlY2xpbmVUb1NpZ25QcmljZUNoZWNrVGltZU1zIC0gc2lnbkF0dGVtcHRUaW1lTXMpIC8gT05FX1NFQ09ORF9NUztcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJIYXNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxQcmljZTogb3JpZ2luYWxQcmljZS50b051bWJlcigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2VBZnRlclJlamVjdDogcHJpY2VBZnRlclJlamVjdC50b051bWJlcigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2VDaGVja0RlbGF5UyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlRGlmZmVyZW5jZUJpcHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdEZWNsaW5lIHRvIHNpZ24gcHJpY2UgY2hlY2snLFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9iLmxsUmVqZWN0UHJpY2VEaWZmZXJlbmNlQnBzID0gcGFyc2VJbnQocHJpY2VEaWZmZXJlbmNlQmlwcywgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9kYlV0aWxzLnVwZGF0ZVJmcW1Kb2JBc3luYyhqb2IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oeyBvcmRlckhhc2gsIGVycm9yTWVzc2FnZTogZS5tZXNzYWdlIH0sICdTYXZpbmcgTEwgcmVqZWN0IHByaWNlIGRpZmZlcmVuY2UgZmFpbGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VuY291bnRlcmVkIGVycm9yIGR1cmluZyBkZWNsaW5lIHRvIHNpZ24gcHJpY2UgY2hlY2snLFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hcmtldCBNYWtlciBkZWNsaW5lZCB0byBzaWduJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENlcnRhaW4gbWFya2V0IG1ha2VycyBhcmUgcmV0dXJuaW5nIHNpZ25hdHVyZSBjb21wb25lbnRzIHdoaWNoIGFyZSBtaXNzaW5nXHJcbiAgICAgICAgICAgIC8vIGxlYWRpbmcgYnl0ZXMuIEFkZCB0aGVtIGlmIHRoZXkgZG9uJ3QgZXhpc3QuXHJcbiAgICAgICAgICAgIGNvbnN0IHBhZGRlZFNpZ25hdHVyZSA9IHBhZFNpZ25hdHVyZShtYWtlclNpZ25hdHVyZSk7XHJcbiAgICAgICAgICAgIGlmIChwYWRkZWRTaWduYXR1cmUuciAhPT0gbWFrZXJTaWduYXR1cmUuciB8fCBwYWRkZWRTaWduYXR1cmUucyAhPT0gbWFrZXJTaWduYXR1cmUucykge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXHJcbiAgICAgICAgICAgICAgICAgICAgeyBvcmRlckhhc2gsIHI6IHBhZGRlZFNpZ25hdHVyZS5yLCBzOiBwYWRkZWRTaWduYXR1cmUucyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICdHb3QgbWFya2V0IG1ha2VyIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgYnl0ZXMnLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIG1ha2VyU2lnbmF0dXJlID0gcGFkZGVkU2lnbmF0dXJlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBqb2IubWFrZXJTaWduYXR1cmUgPSBwYWRkZWRTaWduYXR1cmU7XHJcbiAgICAgICAgICAgIGpvYi5sYXN0TG9va1Jlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGpvYi5zdGF0dXMgPSBSZnFtSm9iU3RhdHVzLlBlbmRpbmdMYXN0TG9va0FjY2VwdGVkO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9kYlV0aWxzLnVwZGF0ZVJmcW1Kb2JBc3luYyhqb2IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTWFrZXIgc2lnbmF0dXJlIG11c3QgYWxyZWFkeSBiZSBkZWZpbmVkIGhlcmUgLS0gcmVmaW5lIHRoZSB0eXBlXHJcbiAgICAgICAgaWYgKCFtYWtlclNpZ25hdHVyZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ha2VyIHNpZ25hdHVyZSBkb2VzIG5vdCBleGlzdCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVmVyaWZ5IHRoZSBzaWduZXIgd2FzIHRoZSBtYWtlclxyXG4gICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgICAgIGNvbnN0IHNpZ25lckFkZHJlc3MgPSBnZXRTaWduZXJGcm9tSGFzaChvcmRlckhhc2gsIG1ha2VyU2lnbmF0dXJlISkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBtYWtlckFkZHJlc3MgPSBvcmRlci5vcmRlci5tYWtlci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChzaWduZXJBZGRyZXNzICE9PSBtYWtlckFkZHJlc3MpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmluZm8oeyBzaWduZXJBZGRyZXNzLCBtYWtlckFkZHJlc3MsIG9yZGVySGFzaCwgbWFrZXJVcmkgfSwgJ1Bvc3NpYmxlIHVzZSBvZiBzbWFydCBjb250cmFjdCB3YWxsZXQnKTtcclxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNpZ25lciA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5pc1ZhbGlkT3JkZXJTaWduZXJBc3luYyhtYWtlckFkZHJlc3MsIHNpZ25lckFkZHJlc3MpO1xyXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRTaWduZXIpIHtcclxuICAgICAgICAgICAgICAgIGpvYi5zdGF0dXMgPSBSZnFtSm9iU3RhdHVzLkZhaWxlZFNpZ25GYWlsZWQ7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9kYlV0aWxzLnVwZGF0ZVJmcW1Kb2JBc3luYyhqb2IpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9yZGVyIHNpZ25lciBhZGRyZXNzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJtaXRzIGEgc3BlY2lmaWMgdHlwZSBvZiBzdWJtaXNzaW9uIHRvIHRoZSBibG9ja2NoYWluLlxyXG4gICAgICpcclxuICAgICAqIEZpcnN0IGNoZWNrcyB0byBzZWUgaWYgdGhlcmUgYXJlIHByZXZpb3VzIHRyYW5zYWN0aW9ucyB3aXRoIHRoZSBzdWJtaXNzaW9uIHR5cGUgYW5kIGVudGVycyB0aGVcclxuICAgICAqIHdhdGNoIGxvb3A7IGlmIG5vdCwgc3VibWl0cyBhbiBpbml0aWFsIHRyYW5zYWN0aW9uIGFuZCBlbnRlcnMgdGhlIHdhdGNoIGxvb3AuXHJcbiAgICAgKlxyXG4gICAgICogRHVyaW5nIHRoZSB3YXRjaCBsb29wLCB3YWl0cyBmb3IgYSB0cmFuc2FjdGlvbiB0byBiZSBtaW5lZCBhbmQgY29uZmlybWVkO1xyXG4gICAgICogcmVwbGFjZXMgdGhlIHRyYW5zYWN0aW9uIGlmIGdhcyBwcmljZXMgcmlzZSB3aGlsZSBhIHRyYW5zYWN0aW9ucyBhcmUgaW4gdGhlIG1lbXBvb2wuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdHMgT3B0aW9ucyBvYmplY3QgdGhhdCBjb250YWluczpcclxuICAgICAqICAgICAgICAtIGB0b2A6IFRoZSBhZGRyZXNzIHRvIHNlbmQgdG8uXHJcbiAgICAgKiAgICAgICAgLSBgZnJvbWA6IFRoZSBhZGRyZXNzIHN1Ym1pdHRpbmcgdGhlIHRyYW5zYWN0aW9uICh1c3VhbGx5IHRoZSB3b3JrZXIgYWRkcmVzcykuXHJcbiAgICAgKiAgICAgICAgLSBgY2FsbGRhdGFgOiBDYWxsZGF0YSB0byBzdWJtaXQuXHJcbiAgICAgKiAgICAgICAgLSBgZXhwaXJ5YDogRXhpcnkgYmVmb3JlIHRoZSBzdWJtaXNzaW9uIGlzIGNvbnNpZGVyZWQgaW52YWxpZC5cclxuICAgICAqICAgICAgICAtIGBpZGVudGlmaWVyYDogVGhlIGpvYiBpZGVudGlmaWVyLiBGb3IgcmZxbV92Ml9qb2IsIGl0IHNob3VsZCBiZSBvcmRlciBoYXNoOyBmb3IgbWV0YS10cmFuc2FjdGlvbiwgaXQgc2hvdWxkIGJlIGpvYiBpZC5cclxuICAgICAqICAgICAgICAtIGBzdWJtaXNzaW9uVHlwZWA6IFRoZSB0eXBlIG9mIHN1Ym1pc3Npb24uXHJcbiAgICAgKiAgICAgICAgLSBgb25TdWJtaXNzaW9uQ29udGV4dFN0YXR1c1VwZGF0ZWA6IENhbGxiYWNrIHRvIHBlcmZvcm0gYXBwcm9wcmlhdGUgYWN0aW9ucyB3aGVuIHRoZSBzdWJtaXNzaW9uIGNvbnRleHQgc3RhdHVzZXMgY2hhbmdlLlxyXG4gICAgICogICAgICAgIC0gYG5vd2A6IFRoZSBjdXJyZW50IHRpbWUuXHJcbiAgICAgKiBAcmV0dXJucyBGYWlsZWRSZXZlcnRlZENvbmZpcm1lZCBvciBTdWNjZWVkZWRDb25maXJtZWQuXHJcbiAgICAgKiBAdGhyb3dzIFN1Ym1pc3Npb24gY29udGV4dCBzdGF0dXMgaXMgRmFpbGVkRXhwaXJlZCBvciB1bmhhbmRsZWQgZXhjZXB0aW9ucy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIHN1Ym1pdFRvQ2hhaW5Bc3luYyhvcHRzOiB7XHJcbiAgICAgICAga2luZDogKFJmcW1WMkpvYkVudGl0eSB8IE1ldGFUcmFuc2FjdGlvbkpvYkVudGl0eSlbJ2tpbmQnXTtcclxuICAgICAgICB0bzogc3RyaW5nO1xyXG4gICAgICAgIGZyb206IHN0cmluZztcclxuICAgICAgICBjYWxsZGF0YTogc3RyaW5nO1xyXG4gICAgICAgIGV4cGlyeTogQmlnTnVtYmVyO1xyXG4gICAgICAgIGlkZW50aWZpZXI6IHN0cmluZztcclxuICAgICAgICBzdWJtaXNzaW9uVHlwZTogUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblR5cGU7XHJcbiAgICAgICAgb25TdWJtaXNzaW9uQ29udGV4dFN0YXR1c1VwZGF0ZTogKFxyXG4gICAgICAgICAgICBuZXdTdWJtaXNzaW9uQ29udGV4dFN0YXR1czogU3VibWlzc2lvbkNvbnRleHRTdGF0dXMsXHJcbiAgICAgICAgICAgIG9sZFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzPzogU3VibWlzc2lvbkNvbnRleHRTdGF0dXMsXHJcbiAgICAgICAgKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gICAgfSk6IFByb21pc2U8U3VibWlzc2lvbkNvbnRleHRTdGF0dXMuRmFpbGVkUmV2ZXJ0ZWRDb25maXJtZWQgfCBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cy5TdWNjZWVkZWRDb25maXJtZWQ+IHtcclxuICAgICAgICBjb25zdCB7IGtpbmQsIHRvLCBmcm9tLCBjYWxsZGF0YSwgZXhwaXJ5LCBpZGVudGlmaWVyLCBzdWJtaXNzaW9uVHlwZSwgb25TdWJtaXNzaW9uQ29udGV4dFN0YXR1c1VwZGF0ZSB9ID0gb3B0cztcclxuXHJcbiAgICAgICAgbGV0IHByZXZpb3VzU3VibWlzc2lvbnNXaXRoUHJlc3VibWl0cztcclxuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcclxuICAgICAgICAgICAgY2FzZSAncmZxbV92Ml9qb2InOlxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNTdWJtaXNzaW9uc1dpdGhQcmVzdWJtaXRzID0gYXdhaXQgdGhpcy5fZGJVdGlscy5maW5kVjJUcmFuc2FjdGlvblN1Ym1pc3Npb25zQnlPcmRlckhhc2hBc3luYyhcclxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25UeXBlLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtZXRhX3RyYW5zYWN0aW9uX2pvYic6XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91c1N1Ym1pc3Npb25zV2l0aFByZXN1Ym1pdHMgPSBhd2FpdCB0aGlzLl9kYlV0aWxzLmZpbmRNZXRhVHJhbnNhY3Rpb25TdWJtaXNzaW9uc0J5Sm9iSWRBc3luYyhcclxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25UeXBlLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgKChfeDogbmV2ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9KShraW5kKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzU3VibWlzc2lvbnMgPSBhd2FpdCB0aGlzLl9yZWNvdmVyUHJlc3VibWl0VHJhbnNhY3Rpb25zQXN5bmMocHJldmlvdXNTdWJtaXNzaW9uc1dpdGhQcmVzdWJtaXRzKTtcclxuXHJcbiAgICAgICAgY29uc3QgZ2FzUHJpY2VFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuX2dhc1N0YXRpb25BdHRlbmRhbnQuZ2V0RXhwZWN0ZWRUcmFuc2FjdGlvbkdhc1JhdGVBc3luYygpO1xyXG5cclxuICAgICAgICAvLyBGb3IgdGhlIGZpcnN0IHN1Ym1pc3Npb24sIHdlIHVzZSB0aGUgXCJmYXN0XCIgZ2FzIGVzdGltYXRlIHRvIGFwcHJveGltYXRlIHRoZSBiYXNlIGZlZS5cclxuICAgICAgICAvLyBXZSB1c2UgdGhlIHN0cmF0ZWd5IG91dGxpbmVkIGluIGh0dHBzOi8vd3d3LmJsb2NrbmF0aXZlLmNvbS9ibG9nL2VpcC0xNTU5LWZlZXMgLS1cclxuICAgICAgICAvLyBUaGUgYG1heEZlZVBlckdhc2AgaXMgMnggdGhlIGJhc2UgZmVlIChwbHVzIHByaW9yaXR5IHRpcCkuIFNpbmNlIHdlIGRvbid0IGhhdmUgYVxyXG4gICAgICAgIC8vIGhhbmR5IG9yYWNsZSBmb3IgdGhlIGVuIHZvZ3VlIHByaW9ydHkgZmVlIHdlIHN0YXJ0IHdpdGggMiBnd2VpIGFuZCB3b3JrIHVwIGZyb20gdGhlcmUuXHJcbiAgICAgICAgY29uc3QgaW5pdGlhbE1heFByaW9yaXR5RmVlUGVyR2FzID0gbmV3IEJpZ051bWJlcih0aGlzLl9pbml0aWFsTWF4UHJpb3JpdHlGZWVQZXJHYXNHd2VpKS50aW1lcyhcclxuICAgICAgICAgICAgTWF0aC5wb3coMTAsIEdXRUlfREVDSU1BTFMpLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGxldCBnYXNGZWVzOiBHYXNGZWVzID0ge1xyXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IEJpZ051bWJlci5taW4oXHJcbiAgICAgICAgICAgICAgICBnYXNQcmljZUVzdGltYXRlLm11bHRpcGxpZWRCeSgyKS5wbHVzKGluaXRpYWxNYXhQcmlvcml0eUZlZVBlckdhcyksXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhGZWVQZXJHYXNDYXBXZWksXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBpbml0aWFsTWF4UHJpb3JpdHlGZWVQZXJHYXMsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbGV0IHN1Ym1pc3Npb25Db250ZXh0O1xyXG4gICAgICAgIGxldCBub25jZTtcclxuICAgICAgICBsZXQgZ2FzRXN0aW1hdGU7XHJcblxyXG4gICAgICAgIGlmICghcHJldmlvdXNTdWJtaXNzaW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUncyBhbiBlZGdlIGNhc2UgaGVyZSB3aGVyZSB0aGVyZSBhcmUgcHJldmlvdXMgc3VibWlzc2lvbnMgYnV0IHRoZXkncmUgYWxsIGluIGBQUkVTVUJNSVRgLlxyXG4gICAgICAgICAgICAvLyBUaG9zZSBhcmUgZmlsdGVyZWQgb3V0IGlmIHRoZXkgY2FuJ3QgYmUgZm91bmQgb24gdGhlIGJsb2NrY2hhaW4gc28gd2UgZW5kIHVwIGhlcmUuXHJcbiAgICAgICAgICAgIC8vIElmIHRoaXMgb2NjdXJzIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGV4cGlyZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IG5vd1NlY29uZHMgPSBuZXcgQmlnTnVtYmVyKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gT05FX1NFQ09ORF9NUyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXhwaXJ5LmlzTGVzc1RoYW4obm93U2Vjb25kcykpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IG9uU3VibWlzc2lvbkNvbnRleHRTdGF0dXNVcGRhdGUoU3VibWlzc2lvbkNvbnRleHRTdGF0dXMuRmFpbGVkRXhwaXJlZCk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4Y2VlZCBleHBpcnkgJHtleHBpcnl9IGZvciBraW5kICR7a2luZH0gYW5kIHN1Ym1pc3Npb24gdHlwZSAke3N1Ym1pc3Npb25UeXBlfWApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsb2dnZXIuaW5mbyh7IGtpbmQsIGlkZW50aWZpZXIsIGZyb20gfSwgJ0F0dGVtcHRpbmcgdG8gc3VibWl0IGZpcnN0IHRyYW5zYWN0aW9uJyk7XHJcbiAgICAgICAgICAgIGF3YWl0IG9uU3VibWlzc2lvbkNvbnRleHRTdGF0dXNVcGRhdGUoU3VibWlzc2lvbkNvbnRleHRTdGF0dXMuUGVuZGluZ1N1Ym1pdHRlZCk7XHJcblxyXG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBraW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIGdhc0ZlZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2FzUHJpY2VFc3RpbWF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25Db3VudDogMSxcclxuICAgICAgICAgICAgICAgICAgICBmcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25UeXBlLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICdTdWJtaXR0aW5nIHRyYW5zYWN0aW9uJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIG5vbmNlID0gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldE5vbmNlQXN5bmMoZnJvbSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGdhc0VzdGltYXRlV2l0aG91dEJ1ZmZlciA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5lc3RpbWF0ZUdhc0ZvckFzeW5jKHtcclxuICAgICAgICAgICAgICAgIHRvLFxyXG4gICAgICAgICAgICAgICAgZnJvbSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IGNhbGxkYXRhLFxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBnYXMgZmVlIHByb3BlcnRpZXMgYXJlIGFkZGVkIGJlY2F1c2UgYGV4ZWN1dGVNZXRhVHJhbnNhY3Rpb25gIGluIDB4IEV4Y2hhbmdlIFByb3h5XHJcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBjaGVjayB3aGV0aGVyIHRoZSBnYXMgcHJpY2Ugb2YgdGhlIHRyYW5zYWN0aW9uIGlzIHdpdGhpbiBhIHdpbmRvdy4gSWYgbGVmdCBlbXB0eSwgaXQgd2lsbFxyXG4gICAgICAgICAgICAgICAgLy8gZmFpbCB0aGUgc2ltdWxhdGlvbi5cclxuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhczogZ2FzRmVlcy5tYXhGZWVQZXJHYXMudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBnYXNGZWVzLm1heFByaW9yaXR5RmVlUGVyR2FzLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBBZGQgYnVmZmVyIHRvIGdhcyBlc3RpbWF0ZSByZXR1cm5lZCBieSBgZXRoX2VzdGltYXRlR2FzYCBhcyB0aGUgUlBDIG1ldGhvZFxyXG4gICAgICAgICAgICAvLyB0ZW5kcyB0byB1bmRlciBlc3RpbWF0ZSBnYXMgdXNhZ2VcclxuICAgICAgICAgICAgZ2FzRXN0aW1hdGUgPSBNYXRoLmNlaWwoKEdBU19FU1RJTUFURV9CVUZGRVIgKyAxKSAqIGdhc0VzdGltYXRlV2l0aG91dEJ1ZmZlcik7XHJcbiAgICAgICAgICAgIGxldCBhY2Nlc3NMaXN0V2l0aEdhcztcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVBY2Nlc3NMaXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc0xpc3RXaXRoR2FzID0gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmNyZWF0ZUFjY2Vzc0xpc3RGb3JBc3luYyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjYWxsZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBSRlFNX0NSRUFURV9BQ0NFU1NfTElTVF9SRVFVRVNULmxhYmVscyh0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCksICdzdWNjZXNzJykuaW5jKCk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIFJGUU1fQ1JFQVRFX0FDQ0VTU19MSVNUX1JFUVVFU1QubGFiZWxzKHRoaXMuX2NoYWluSWQudG9TdHJpbmcoKSwgJ2ZhaWx1cmUnKS5pbmMoKTtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2Fybih7IGtpbmQsIGNhbGxkYXRhLCBmcm9tIH0sICdGYWlsZWQgdG8gY3JlYXRlIGFjY2VzcyBsaXN0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFjY2Vzc0xpc3RXaXRoR2FzICE9PSB1bmRlZmluZWQgJiYgYWNjZXNzTGlzdFdpdGhHYXMuZ2FzRXN0aW1hdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYnVmZmVyIHRvIGdhcyBlc3RpbWF0ZSByZXR1cm5lZCBieSBgZXRoX2VzdGltYXRlR2FzYCBhcyB0aGUgUlBDIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRlbmRzIHRvIHVuZGVyIGVzdGltYXRlIGdhcyB1c2FnZVxyXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc0xpc3RXaXRoR2FzLmdhc0VzdGltYXRlID0gTWF0aC5jZWlsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoR0FTX0VTVElNQVRFX0JVRkZFUiArIDEpICogYWNjZXNzTGlzdFdpdGhHYXMuZ2FzRXN0aW1hdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgZ2FzRXN0aW1hdGUsIGFjY2Vzc0xpc3RHYXNFc3RpbWF0ZTogYWNjZXNzTGlzdFdpdGhHYXMuZ2FzRXN0aW1hdGUgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZ3VsYXIgZ2FzIGVzdGltYXRlIHZzIGFjY2VzcyBsaXN0IGdhcyBlc3RpbWF0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBSRlFNX0dBU19FU1RJTUFURV9OT19BQ0NFU1NfTElTVC5sYWJlbHModGhpcy5fY2hhaW5JZC50b1N0cmluZygpKS5zZXQoZ2FzRXN0aW1hdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIFJGUU1fR0FTX0VTVElNQVRFX0FDQ0VTU19MSVNULmxhYmVscyh0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLnNldChhY2Nlc3NMaXN0V2l0aEdhcy5nYXNFc3RpbWF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0U3VibWlzc2lvbiA9IGF3YWl0IHRoaXMuX3N1Ym1pdFRyYW5zYWN0aW9uQXN5bmMoXHJcbiAgICAgICAgICAgICAgICBraW5kLFxyXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcixcclxuICAgICAgICAgICAgICAgIGZyb20sXHJcbiAgICAgICAgICAgICAgICBjYWxsZGF0YSxcclxuICAgICAgICAgICAgICAgIGdhc0ZlZXMsXHJcbiAgICAgICAgICAgICAgICBub25jZSxcclxuICAgICAgICAgICAgICAgIGdhc0VzdGltYXRlLFxyXG4gICAgICAgICAgICAgICAgc3VibWlzc2lvblR5cGUsXHJcbiAgICAgICAgICAgICAgICB0byxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxyXG4gICAgICAgICAgICAgICAgeyBraW5kLCBmcm9tLCBpZGVudGlmaWVyLCBzdWJtaXNzaW9uVHlwZSwgdHJhbnNhY3Rpb25IYXNoOiBmaXJzdFN1Ym1pc3Npb24udHJhbnNhY3Rpb25IYXNoIH0sXHJcbiAgICAgICAgICAgICAgICAnU3VjY2Vzc2Z1bGx5IHN1Ym1pdHRlZCB0cmFuc2FjdGlvbicsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBzdWJtaXNzaW9uQ29udGV4dCA9IG5ldyBTdWJtaXNzaW9uQ29udGV4dCh0aGlzLl9ibG9ja2NoYWluVXRpbHMsIFtmaXJzdFN1Ym1pc3Npb25dIGFzXHJcbiAgICAgICAgICAgICAgICB8IFJmcW1WMlRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eVtdXHJcbiAgICAgICAgICAgICAgICB8IE1ldGFUcmFuc2FjdGlvblN1Ym1pc3Npb25FbnRpdHlbXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmluZm8oeyBraW5kLCBmcm9tLCBpZGVudGlmaWVyLCBzdWJtaXNzaW9uVHlwZSB9LCBgUHJldmlvdXMgc3VibWlzc2lvbnMgZm91bmQsIHJlY292ZXJpbmcgY29udGV4dGApO1xyXG4gICAgICAgICAgICBzdWJtaXNzaW9uQ29udGV4dCA9IG5ldyBTdWJtaXNzaW9uQ29udGV4dCh0aGlzLl9ibG9ja2NoYWluVXRpbHMsIHByZXZpb3VzU3VibWlzc2lvbnMpO1xyXG4gICAgICAgICAgICBub25jZSA9IHN1Ym1pc3Npb25Db250ZXh0Lm5vbmNlO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBzdWJtaXR0ZWQgYSB0cmFuc2FjdGlvbiBhbmQgaXQgaGFzIGJlZW4gbWluZWQsXHJcbiAgICAgICAgICAgIC8vIHVzaW5nIGBfYmxvY2tjaGFpblV0aWxzLmVzdGltYXRlR2FzRm9yQXN5bmNgIHdpbGwgdGhyb3dcclxuICAgICAgICAgICAgLy8gZ2l2ZW4gdGhlIHNhbWUgY2FsbGRhdGEuIEluIHRoZSBlZGdlIGNhc2Ugd2hlcmUgYSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBzZW50XHJcbiAgICAgICAgICAgIC8vIGJ1dCBub3QgbWluZWQsIHdlIHdvdWxkIGlkZWFsbHkgcHVsbCB0aGUgZ2FzIGVzdGltYXRlIGZyb20gdGhlIHByZXZpb3VzXHJcbiAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uLiBVbmZvcnR1bmF0ZWx5LCB3ZSBjdXJyZW50bHkgZG8gbm90IHN0b3JlIGl0IG9uIHRoZVxyXG4gICAgICAgICAgICAvLyBgUmZxbVYyVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5YC4gQXMgYSB3b3JrYXJvdW5kLCB3ZSdsbCBqdXN0IHVzZSBhblxyXG4gICAgICAgICAgICAvLyBvdmVyZXN0aW1hdGUuLlxyXG4gICAgICAgICAgICBnYXNFc3RpbWF0ZSA9IE1BWF9HQVNfRVNUSU1BVEU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgXCJXYXRjaCBMb29wXCJcclxuICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgc3VibWl0dGVkIHRoZSB0cmFuc2FjdGlvbiBvbmNlIGF0IHRoaXMgcG9pbnQsIHNvIHdlIGZpcnN0IG5lZWQgdG8gd2FpdCBiZWZvcmUgY2hlY2tpbmcgdGhlIHN0YXR1cy5cclxuICAgICAgICAgICAgYXdhaXQgZGVsYXkodGhpcy5fdHJhbnNhY3Rpb25XYXRjaGVyU2xlZXBUaW1lTXMpO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRTdWJtaXNzaW9uQ29udGV4dFN0YXR1cyA9IHN1Ym1pc3Npb25Db250ZXh0LnN1Ym1pc3Npb25Db250ZXh0U3RhdHVzO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdTdWJtaXNzaW9uQ29udGV4dFN0YXR1cyA9IGF3YWl0IHRoaXMuX2NoZWNrU3VibWlzc2lvblJlY2VpcHRzQW5kVXBkYXRlRGJBc3luYyhcclxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICBzdWJtaXNzaW9uQ29udGV4dCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXHJcbiAgICAgICAgICAgICAgICB7IGtpbmQsIHN1Ym1pc3Npb25UeXBlLCBvbGRTdWJtaXNzaW9uQ29udGV4dFN0YXR1cywgbmV3U3VibWlzc2lvbkNvbnRleHRTdGF0dXMgfSxcclxuICAgICAgICAgICAgICAgICdPbGQgYW5kIG5ldyBzdWJtaXNzaW9uIGNvbnRleHQgc3RhdHVzZXMnLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBhd2FpdCBvblN1Ym1pc3Npb25Db250ZXh0U3RhdHVzVXBkYXRlKG5ld1N1Ym1pc3Npb25Db250ZXh0U3RhdHVzLCBvbGRTdWJtaXNzaW9uQ29udGV4dFN0YXR1cyk7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKG5ld1N1Ym1pc3Npb25Db250ZXh0U3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLlBlbmRpbmdTdWJtaXR0ZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UndmUgcHV0IGluIGF0IGxlYXN0IG9uZSB0cmFuc2FjdGlvbiBidXQgbm9uZSBoYXZlIGJlZW4gbWluZWQgeWV0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIG1ha2Ugc3VyZSB3ZSBoYXZlbid0IHBhc3NlZCB0aGUgZXhwaXJ5IHdpbmRvdy5cclxuICAgICAgICAgICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNhc2UtZGVjbGFyYXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93U2Vjb25kcyA9IG5ldyBCaWdOdW1iZXIobmV3IERhdGUoKS5nZXRUaW1lKCkgLyBPTkVfU0VDT05EX01TKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jYXNlLWRlY2xhcmF0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlY29uZHNQYXN0RXhwaXJhdGlvbiA9IG5vd1NlY29uZHMubWludXMoZXhwaXJ5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgbW9yZSB0aGFuIDEyMCBzZWNvbmRzIHBhc3QgZXhwaXJhdGlvbiwgZ2l2ZSB1cC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JvbGFuZGtvZmxlci9ibG9ja3RpbWUgZm9yIHNvbWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbmFseXNpcyBvZiBleHBlY3RlZCBibG9jayB0aW1lcy4gVHdvIG1pbnV0ZXMgd2FzIHNlbGVjdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gY292ZXIgbW9zdCBjYXNlcyB3aXRob3V0IGxvY2tpbmcgdXAgdGhlIHdvcmtlciBmb3IgdG9vIGxvbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY29uZHNQYXN0RXhwaXJhdGlvbi5pc0dyZWF0ZXJUaGFuKE9ORV9NSU5VVEVfUyAqIDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG9uU3VibWlzc2lvbkNvbnRleHRTdGF0dXNVcGRhdGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cy5GYWlsZWRFeHBpcmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkU3VibWlzc2lvbkNvbnRleHRTdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBFeGNlZWQgZXhwaXJ5ICR7ZXhwaXJ5fSBmb3Iga2luZCAke2tpbmR9IGFuZCBzdWJtaXNzaW9uIHR5cGUgJHtzdWJtaXNzaW9uVHlwZX1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBwYXN0IGV4cGlyYXRpb24gYnkgbGVzcyB0aGFuIGEgbWludXRlLCBkb24ndCBwdXQgaW4gYW55IG5ldyB0cmFuc2FjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAvLyBidXQga2VlcCB3YXRjaGluZyBpbiBjYXNlIGEgcmVjZWlwdCBzaG93cyB1cFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWNvbmRzUGFzdEV4cGlyYXRpb24uaXNHcmVhdGVyVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFwiRmFzdFwiIGdhcyBwcmljZSBlc3RpbWF0aW9uOyB1c2VkIHRvIGFwcHJveGltYXRlIHRoZSBiYXNlIGZlZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY2FzZS1kZWNsYXJhdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdHYXNQcmljZUVzdGltYXRlID0gYXdhaXQgdGhpcy5fZ2FzU3RhdGlvbkF0dGVuZGFudC5nZXRFeHBlY3RlZFRyYW5zYWN0aW9uR2FzUmF0ZUFzeW5jKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJtaXNzaW9uQ29udGV4dC50cmFuc2FjdGlvblR5cGUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24tRUlQLTE1NTkgdHJhbnNhY3Rpb25zIGFyZSBub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhaXQgZm9yIGdhcyBjb25kaXRpb25zIHRvIGNoYW5nZS4gUmF0aGVyLCB3ZSBpbmNyZWFzZSB0aGUgZ2FzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFzZWQgYmlkIGJhc2VkIG9udGhlIGtub3dsZWRnZSB0aGF0IHRpbWUgKGFuZCB0aGVyZWZvcmUgYmxvY2tzLCB0aGVvcmV0aWNhbGx5KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBwYXNzZWQgd2l0aG91dCBhIHRyYW5zYWN0aW9uIGJlaW5nIG1pbmVkLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAkZXNsaW50LWZpeC1tZSBodHRwczovL2dpdGh1Yi5jb20vcmhpbm9kYXZpZC9lc2xpbnQtZml4LW1lXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNhc2UtZGVjbGFyYXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBtYXhGZWVQZXJHYXM6IG9sZE1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IG9sZE1heFByaW9yaXR5RmVlUGVyR2FzIH0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uQ29udGV4dC5tYXhHYXNGZWVzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkTWF4RmVlUGVyR2FzLmlzR3JlYXRlclRoYW5PckVxdWFsVG8odGhpcy5fbWF4RmVlUGVyR2FzQ2FwV2VpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIHRoZSBtYXggZmVlIHBlciBnYXMgd2UnZCBsaWtlIHRvIHBheSwganVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZSB3YXRjaGluZyB0aGUgdHJhbnNhY3Rpb25zIHRvIHNlZSBpZiBvbmUgZ2V0cyBtaW5lZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGtpbmQsIHN1Ym1pc3Npb25UeXBlLCBvbGRNYXhGZWVQZXJHYXMsIG1heEZlZVBlckdhc0NhcDogdGhpcy5fbWF4RmVlUGVyR2FzQ2FwV2VpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRXhjZWVkcyBtYXggZmVlIHBlciBnYXMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY2FzZS1kZWNsYXJhdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdNYXhQcmlvcml0eUZlZVBlckdhcyA9IG9sZE1heFByaW9yaXR5RmVlUGVyR2FzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tdWx0aXBsaWVkQnkoTUFYX1BSSU9SSVRZX0ZFRV9QRVJfR0FTX01VTFRJUExJRVIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlZ2VyVmFsdWUoQmlnTnVtYmVyLlJPVU5EX0NFSUwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgUlBDIG5vZGVzIHN0aWxsIG5lZWQgYXQgbGVhc3QgYSAwLjEgaW5jcmVhc2UgaW4gYm90aCB2YWx1ZXMgdG8gYWNjZXB0IHRoZSBuZXcgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRoZSBuZXcgbWF4IGZlZSBwZXIgZ2FzLCB3ZSdsbCB0YWtlIHRoZSBtYXhpbXVtIG9mIGEgMC4xIGluY3JlYXNlIGZyb20gdGhlIGxhc3QgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBvciB0aGUgdmFsdWUgZnJvbSBhbiBpbmNyZWFzZSBpbiB0aGUgYmFzZSBmZWUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jYXNlLWRlY2xhcmF0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld01heEZlZVBlckdhcyA9IEJpZ051bWJlci5tYXgoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZE1heEZlZVBlckdhcy5tdWx0aXBsaWVkQnkoTUFYX0ZFRV9QRVJfR0FTX01VTFRJUExJRVIpLmludGVnZXJWYWx1ZShCaWdOdW1iZXIuUk9VTkRfQ0VJTCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0dhc1ByaWNlRXN0aW1hdGUubXVsdGlwbGllZEJ5KDIpLnBsdXMobmV3TWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdhc0ZlZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEZlZVBlckdhczogbmV3TWF4RmVlUGVyR2FzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXNGZWVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FzUHJpY2VFc3RpbWF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uQ291bnQ6IHN1Ym1pc3Npb25Db250ZXh0LnRyYW5zYWN0aW9ucy5sZW5ndGggKyAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25UeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnU3VibWl0dGluZyB0cmFuc2FjdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLl9zdWJtaXRUcmFuc2FjdGlvbkFzeW5jKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXNGZWVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXNFc3RpbWF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25UeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogbmV3VHJhbnNhY3Rpb24udHJhbnNhY3Rpb25IYXNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25UeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdTdWNjZXNzZnVsbHkgcmVzdWJtaXRlZCB0eCB3aXRoIGhpZ2hlciBnYXMgcHJpY2UnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uQ29udGV4dC5hZGRUcmFuc2FjdGlvbihuZXdUcmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVyci5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc05vbmNlVG9vTG93ID0gL25vbmNlIHRvbyBsb3cvLnRlc3QoZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGZyb20sIGtpbmQsIGlkZW50aWZpZXIsIHN1Ym1pc3Npb25UeXBlLCBlcnJvck1lc3NhZ2U6IGVyci5tZXNzYWdlLCBpc05vbmNlVG9vTG93IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRW5jb3VudGVyZWQgYW4gZXJyb3IgcmUtc3VibWl0dGluZyBhIHR4JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTm9uY2VUb29Mb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZnJvbSwga2luZCwgaWRlbnRpZmllciwgc3VibWlzc2lvblR5cGUgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnSWdub3JlIG5vbmNlIHRvbyBsb3cgZXJyb3Igb24gcmUtc3VibWlzc2lvbi4gQSBwcmV2aW91cyBzdWJtaXNzaW9uIHdhcyBzdWNjZXNzZnVsJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0aHJvdyBvbiBhbGwgb3RoZXIgdHlwZXMgb2YgZXJyb3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cy5GYWlsZWRSZXZlcnRlZFVuY29uZmlybWVkOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cy5TdWNjZWVkZWRVbmNvbmZpcm1lZDpcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgU3VibWlzc2lvbkNvbnRleHRTdGF0dXMuRmFpbGVkUmV2ZXJ0ZWRDb25maXJtZWQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLlN1Y2NlZWRlZENvbmZpcm1lZDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3U3VibWlzc2lvbkNvbnRleHRTdGF0dXM7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICgoX3g6IG5ldmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcclxuICAgICAgICAgICAgICAgICAgICB9KShuZXdTdWJtaXNzaW9uQ29udGV4dFN0YXR1cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHN1cHBseSB0byBgc3VibWl0VG9DaGFpbkFzeW5jYC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgYGpvYi5zdGF0dXNgIHdvdWxkIGJlIHVwZGF0ZWQgdG8gYXBwcm9wcmlhdGUgc3RhdGUgYnkgIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBhY2NvcmRpbmcgdG8gb2xkICYgbmV3XHJcbiAgICAgKiBzdWJtaXNzaW9uIGNvbnRleHQgc3RhdHVzIGFuZCBzdWJtaXNzaW9uIHR5cGUuIFRoZXJlIHdvdWxkIGJlIGpvYiBzdGF0dXMgdXBkYXRlIE9OTFkgSUYgdGhlIG5ldyBhbmQgb2xkIHN1Ym1pc3Npb25cclxuICAgICAqIGNvbnRleHQgc3RhdHVzZXMgZGlmZmVyLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWxzbyBcImNsb3NlcyBvdmVyXCIgYGpvYmAgc28gdGhhdCBpdCdzIGFjY2Vzc2libGUgaW4gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLiBSZWZlciB0aGUgZG9jc3RyaW5nIG9mXHJcbiAgICAgKiBgUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvbkNvbnRleHRTdGF0dXNgIGZvciBtb3JlIGRldGFpbHMgb24gc3VibWlzc2lvbiBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBqb2IgQSByZnFtIHYyIGpvYiBvciBhIG1ldGEgdHJhbnNhY3Rpbm8gam9iIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBzdWJtaXNzaW9uVHlwZSBUeXBlIG9mIHN1Ym1pc3Npb24uXHJcbiAgICAgKiBAcmV0dXJucyBGdW5jdGlvbiB3b3VsZCBtYWtlIGFwcHJvcHJpYXRlIHVwZGF0ZSB0byBqb2Igc3RhdHVzIGFjY29yZGluZyB0byBzdWJtaXNzaW9uIGNvbnRleHQgc3RhdHVzZXMgYW5kIHN1Ym1pc3Npb24gdHlwZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfZ2V0T25TdWJtaXNzaW9uQ29udGV4dFN0YXR1c1VwZGF0ZUNhbGxiYWNrKFxyXG4gICAgICAgIGpvYjogUmZxbVYySm9iRW50aXR5IHwgTWV0YVRyYW5zYWN0aW9uSm9iRW50aXR5LFxyXG4gICAgICAgIHN1Ym1pc3Npb25UeXBlOiBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZSxcclxuICAgICk6IChcclxuICAgICAgICBuZXdTdWJtaXNzaW9uQ29udGV4dFN0YXR1czogU3VibWlzc2lvbkNvbnRleHRTdGF0dXMsXHJcbiAgICAgICAgb2xkU3VibWlzc2lvbkNvbnRleHRTdGF0dXM/OiBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cyxcclxuICAgICkgPT4gUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIGFzeW5jIChcclxuICAgICAgICAgICAgbmV3U3VibWlzc2lvbkNvbnRleHRTdGF0dXM6IFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLFxyXG4gICAgICAgICAgICBvbGRTdWJtaXNzaW9uQ29udGV4dFN0YXR1cz86IFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLFxyXG4gICAgICAgICk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgICAgICAgICBpZiAobmV3U3VibWlzc2lvbkNvbnRleHRTdGF0dXMgIT09IG9sZFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3Sm9iU3RhdHVzOiBSZnFtSm9iU3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdWJtaXNzaW9uVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblR5cGUuQXBwcm92YWw6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0pvYlN0YXR1cyA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdWJtaXNzaW9uQ29udGV4dC5hcHByb3ZhbFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzVG9Kb2JTdGF0dXMobmV3U3VibWlzc2lvbkNvbnRleHRTdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25UeXBlLlRyYWRlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdKb2JTdGF0dXMgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3VibWlzc2lvbkNvbnRleHQudHJhZGVTdWJtaXNzaW9uQ29udGV4dFN0YXR1c1RvSm9iU3RhdHVzKG5ld1N1Ym1pc3Npb25Db250ZXh0U3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgKChfeDogbmV2ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkoc3VibWlzc2lvblR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGpvYi5zdGF0dXMgPSBuZXdKb2JTdGF0dXM7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9kYlV0aWxzLnVwZGF0ZVJmcW1Kb2JBc3luYyhqb2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGFuIGFycmF5IG9mIFRyYW5zYWN0aW9uIFN1Ym1pc3Npb25zLCB3aGljaCBtYXkgaW5jbHVkZSB0cmFuc2FjdGlvbnMgd2l0aCB0aGVcclxuICAgICAqIFwiUHJlc2J1bWl0XCIgc3RhdHVzLCBhbmQgcmVzb2x2ZXMgb3IgcmVtb3ZlcyB0aGUgXCJQcmVzdWJtaXRcIiB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlcmUgYXJlIHByZXZpb3VzIHN1Ym1pc3Npb25zIGluIHRoZSBcIlByZXN1Ym1pdFwiIHN0YXRlLFxyXG4gICAgICpcclxuICAgICAqIEZvciBcIlByZXN1Ym1pdFwiIHRyYW5zYWN0aW9ucywgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSB0cmFuc2FjdGlvbiB3YXMgYWN0dWFsbHkgc2VudCB0b1xyXG4gICAgICogdGhlIG1lbXBvb2wgb3Igbm90LCBhcyB0aGF0IGlzIGluZGV0ZXJtaW5hdGUuIERlcGVuZGluZyBvbiB0aGUgcmVzdWx0IG9mIHRoZSBjaGVjaywgd2VcclxuICAgICAqIHVwZGF0ZSB0aGUgc3RhdHVzIHRvIFwiU3VibWl0dGVkXCIgb3IgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc3VibWlzc2lvbnMgaW4gbWVtb3J5LlxyXG4gICAgICogTm90ZSB0aGF0IHdlIGxlYXZlIHRoZSB0cmFuc2FjdGlvbiByZWNvcmQgcHJlc2VudCBpbiB0aGUgZGF0YWJhc2Ugc28gdGhhdCBpZiB0aGUgd29ya2VyXHJcbiAgICAgKiBkaWVzIGFnYWluIGFuZCB0aGUgc3VibWlzc2lvbiBhY3R1YWxseSB3ZW50IHRocm91Z2ggYnV0IHdhcyBub3QgZm91bmQgYXQgdGhlIHRpbWUgb2ZcclxuICAgICAqIHRoaXMgY2hlY2sgd2UgY2FuIHBvdGVudGlhbGx5IHJlY292ZXIgaXQgbGF0ZXIuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgX3JlY292ZXJQcmVzdWJtaXRUcmFuc2FjdGlvbnNBc3luYzxcclxuICAgICAgICBUIGV4dGVuZHMgUmZxbVYyVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5W10gfCBNZXRhVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5W10sXHJcbiAgICA+KHRyYW5zYWN0aW9uU3VibWlzc2lvbnM6IFQpOiBQcm9taXNlPFQ+IHtcclxuICAgICAgICAvLyBBbnkgaXMgc28gbmFzdHkgLS0gaHR0cHM6Ly9kZXYudG8vc2hhZG93MTM0OS90eXBlc2NyaXB0LXRpcC1vZi10aGUtd2Vlay1nZW5lcmljcy0xNzBnXHJcbiAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgY29uc3QgcmVzdWx0OiBhbnkgPSBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb25TdWJtaXNzaW9ucy5tYXAoYXN5bmMgKHRyYW5zYWN0aW9uU3VibWlzc2lvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRyYW5zYWN0aW9uIGlzIGFueSBzdGF0dXMgb3RoZXIgdGhhbiBcIlByZXN1Ym1pdFwiIHRoZW4gd2UnbGwgbGVhdmUgaXRcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvblN1Ym1pc3Npb24uc3RhdHVzICE9PSBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uU3RhdHVzLlByZXN1Ym1pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvblN1Ym1pc3Npb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgdHJhbnNhY3Rpb25zIGluIHByZXN1Ym1pdCwgY2hlY2sgdGhlIG1lbXBvb2wgYW5kIGNoYWluIHRvIHNlZSBpZiB0aGV5IGV4aXN0XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvblJlc3BvbnNlID0gYXdhaXQgdGhpcy5fYmxvY2tjaGFpblV0aWxzLmdldFRyYW5zYWN0aW9uQXN5bmMoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJGVzbGludC1maXgtbWUgaHR0cHM6Ly9naXRodWIuY29tL3JoaW5vZGF2aWQvZXNsaW50LWZpeC1tZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TdWJtaXNzaW9uLnRyYW5zYWN0aW9uSGFzaCEsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBkb2VzIGV4aXN0LCB1cGRhdGUgdGhlIHN0YXR1cy4gSWYgbm90LCByZW1vdmUgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TdWJtaXNzaW9uLnN0YXR1cyA9IFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25TdGF0dXMuU3VibWl0dGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvbnNBc3luYyhbdHJhbnNhY3Rpb25TdWJtaXNzaW9uXSBhcyBUKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25TdWJtaXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgKS50aGVuKCh4KSA9PiB4LmZpbHRlcihpc0RlZmluZWQpKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgZm9yIHJlY2VpcHRzIGZyb20gdGhlIHR4IGhhc2hlcyBhbmQgdXBkYXRlIGRhdGFiYXNlcyB3aXRoIHN0YXR1cyBvZiBhbGwgdHgncy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBfY2hlY2tTdWJtaXNzaW9uUmVjZWlwdHNBbmRVcGRhdGVEYkFzeW5jKFxyXG4gICAgICAgIGlkZW50aWZpZXI6IHN0cmluZyxcclxuICAgICAgICBzdWJtaXNzaW9uQ29udGV4dDogU3VibWlzc2lvbkNvbnRleHQ8UmZxbVYyVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5W10gfCBNZXRhVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5W10+LFxyXG4gICAgKTogUHJvbWlzZTxcclxuICAgICAgICB8IFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLlBlbmRpbmdTdWJtaXR0ZWRcclxuICAgICAgICB8IFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLkZhaWxlZFJldmVydGVkQ29uZmlybWVkXHJcbiAgICAgICAgfCBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cy5GYWlsZWRSZXZlcnRlZFVuY29uZmlybWVkXHJcbiAgICAgICAgfCBTdWJtaXNzaW9uQ29udGV4dFN0YXR1cy5TdWNjZWVkZWRDb25maXJtZWRcclxuICAgICAgICB8IFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLlN1Y2NlZWRlZFVuY29uZmlybWVkXHJcbiAgICA+IHtcclxuICAgICAgICAvLyBBdCBtb3N0IG9uZSB0eCBjYW4gYmUgbWluZWQsIHNpbmNlIHRoZXkgYWxsIGhhdmUgdGhlIHNhbWUgbm9uY2UuXHJcbiAgICAgICAgY29uc3QgbWluZWRSZWNlaXB0ID0gYXdhaXQgc3VibWlzc2lvbkNvbnRleHQuZ2V0UmVjZWlwdEFzeW5jKCk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSB0eCBoYXNuJ3QgYmVlbiBtaW5lZCB5ZXQsIHRoZXJlJ3JlIG5vIGRhdGFiYXNlIHVwZGF0ZXMgdG8gZG8uXHJcbiAgICAgICAgaWYgKCFtaW5lZFJlY2VpcHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN1Ym1pc3Npb25Db250ZXh0U3RhdHVzLlBlbmRpbmdTdWJtaXR0ZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdHRlbXB0IHRvIHB1Ymxpc2ggdGhlIG1pbmluZyBsYXRlbmN5XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgeyB0aW1lc3RhbXA6IG1pbmVkQmxvY2tUaW1lc3RhbXBTIH0gPSBhd2FpdCB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZ2V0QmxvY2tBc3luYyhcclxuICAgICAgICAgICAgICAgIG1pbmVkUmVjZWlwdC5ibG9ja0hhc2gsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0U3VibWlzc2lvblRpbWVzdGFtcFMgPSBzdWJtaXNzaW9uQ29udGV4dC5maXJzdFN1Ym1pc3Npb25UaW1lc3RhbXBTO1xyXG4gICAgICAgICAgICBSRlFNX01JTklOR19MQVRFTkNZLmxhYmVscyh0aGlzLl9jaGFpbklkLnRvU3RyaW5nKCkpLm9ic2VydmUoXHJcbiAgICAgICAgICAgICAgICBtaW5lZEJsb2NrVGltZXN0YW1wUyAtIGZpcnN0U3VibWlzc2lvblRpbWVzdGFtcFMsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihcclxuICAgICAgICAgICAgICAgIHsgb3JkZXJIYXNoOiBpZGVudGlmaWVyLCBlcnJvck1lc3NhZ2U6IGUubWVzc2FnZSwgc3RhY2s6IGUuc3RhY2sgfSxcclxuICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gbWV0ZXIgdGhlIG1pbmluZyBsYXRlbmN5JyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGF3YWl0IHN1Ym1pc3Npb25Db250ZXh0LnVwZGF0ZUZvclJlY2VpcHRBc3luYyhtaW5lZFJlY2VpcHQpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuX2RiVXRpbHMudXBkYXRlUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvbnNBc3luYyhzdWJtaXNzaW9uQ29udGV4dC50cmFuc2FjdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBzdWJtaXNzaW9uQ29udGV4dC5zdWJtaXNzaW9uQ29udGV4dFN0YXR1cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZSB0cmFuc2FjdGlvbiBwcm9wZXJ0aWVzIGFuZCBzdWJtaXQgYSB0cmFuc2FjdGlvblxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIF9zdWJtaXRUcmFuc2FjdGlvbkFzeW5jKFxyXG4gICAgICAgIGtpbmQ6IChSZnFtVjJKb2JFbnRpdHkgfCBNZXRhVHJhbnNhY3Rpb25Kb2JFbnRpdHkpWydraW5kJ10sXHJcbiAgICAgICAgaWRlbnRpZmllcjogc3RyaW5nLFxyXG4gICAgICAgIHdvcmtlckFkZHJlc3M6IHN0cmluZyxcclxuICAgICAgICBjYWxsRGF0YTogc3RyaW5nLFxyXG4gICAgICAgIGdhc0ZlZXM6IEdhc0ZlZXMsXHJcbiAgICAgICAgbm9uY2U6IG51bWJlcixcclxuICAgICAgICBnYXNFc3RpbWF0ZTogbnVtYmVyLFxyXG4gICAgICAgIHN1Ym1pc3Npb25UeXBlOiBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uVHlwZSA9IFJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25UeXBlLlRyYWRlLFxyXG4gICAgICAgIHRvOiBzdHJpbmcgPSB0aGlzLl9ibG9ja2NoYWluVXRpbHMuZ2V0RXhjaGFuZ2VQcm94eUFkZHJlc3MoKSxcclxuICAgICk6IFByb21pc2U8UmZxbVYyVHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5IHwgTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eT4ge1xyXG4gICAgICAgIGNvbnN0IHR4T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgLi4uZ2FzRmVlcyxcclxuICAgICAgICAgICAgZnJvbTogd29ya2VyQWRkcmVzcyxcclxuICAgICAgICAgICAgdG8sXHJcbiAgICAgICAgICAgIGdhczogZ2FzRXN0aW1hdGUsXHJcbiAgICAgICAgICAgIG5vbmNlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvblJlcXVlc3QgPSB0aGlzLl9ibG9ja2NoYWluVXRpbHMudHJhbnNmb3JtVHhEYXRhVG9UcmFuc2FjdGlvblJlcXVlc3QoXHJcbiAgICAgICAgICAgIHR4T3B0aW9ucyxcclxuICAgICAgICAgICAgdGhpcy5fY2hhaW5JZCxcclxuICAgICAgICAgICAgY2FsbERhdGEsXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCB7IHNpZ25lZFRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbkhhc2ggfSA9IGF3YWl0IHRoaXMuX2Jsb2NrY2hhaW5VdGlscy5zaWduVHJhbnNhY3Rpb25Bc3luYyhcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb25SZXF1ZXN0LFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGxldCBwYXJ0aWFsRW50aXR5O1xyXG4gICAgICAgIGxldCB0cmFuc2FjdGlvblN1Ym1pc3Npb25FbnRpdHk7XHJcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JmcW1fdjJfam9iJzpcclxuICAgICAgICAgICAgICAgIHBhcnRpYWxFbnRpdHkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4uZ2FzRmVlcyxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2gsXHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJIYXNoOiBpZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgICAgICAgICBmcm9tOiB3b3JrZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblN0YXR1cy5QcmVzdWJtaXQsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogc3VibWlzc2lvblR5cGUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5ID0gYXdhaXQgdGhpcy5fZGJVdGlscy53cml0ZVYyUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblRvRGJBc3luYyhcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsRW50aXR5LFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtZXRhX3RyYW5zYWN0aW9uX2pvYic6XHJcbiAgICAgICAgICAgICAgICBwYXJ0aWFsRW50aXR5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmdhc0ZlZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGFUcmFuc2FjdGlvbkpvYklkOiBpZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgICAgICAgICBmcm9tOiB3b3JrZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogUmZxbVRyYW5zYWN0aW9uU3VibWlzc2lvblN0YXR1cy5QcmVzdWJtaXQsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogc3VibWlzc2lvblR5cGUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5ID0gYXdhaXQgdGhpcy5fZGJVdGlscy53cml0ZU1ldGFUcmFuc2FjdGlvblN1Ym1pc3Npb25Bc3luYyhwYXJ0aWFsRW50aXR5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgKChfeDogbmV2ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9KShraW5kKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaEZyb21TdWJtaXQgPSBhd2FpdCB0aGlzLl9ibG9ja2NoYWluVXRpbHMuc3VibWl0U2lnbmVkVHJhbnNhY3Rpb25Bc3luYyhzaWduZWRUcmFuc2FjdGlvbik7XHJcblxyXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbkhhc2ggIT09IHRyYW5zYWN0aW9uSGFzaEZyb21TdWJtaXQpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgZXZlciBoYXBwZW5cclxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgeyBraW5kLCBzdWJtaXNzaW9uVHlwZSwgaWRlbnRpZmllciwgdHJhbnNhY3Rpb25IYXNoRnJvbVN1Ym1pdCwgdHJhbnNhY3Rpb25IYXNoIH0sXHJcbiAgICAgICAgICAgICAgICAnTWlzbWF0Y2ggYmV0d2VlbiB0cmFuc2FjdGlvbiBoYXNoIGNhbGN1bGF0ZWQgYmVmb3JlIHN1Ym1pdCBhbmQgYWZ0ZXIgc3VibWl0JyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaCBiZXR3ZWVuIHRyYW5zYWN0aW9uIGhhc2ggY2FsY3VsYXRlZCBiZWZvcmUgc3VibWl0IGFuZCBhZnRlciBzdWJtaXQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxvZ2dlci5pbmZvKFxyXG4gICAgICAgICAgICB7IGtpbmQsIHN1Ym1pc3Npb25UeXBlLCBpZGVudGlmaWVyLCB3b3JrZXJBZGRyZXNzLCB0cmFuc2FjdGlvbkhhc2ggfSxcclxuICAgICAgICAgICAgJ1RyYW5zYWN0aW9uIGNhbGxkYXRhIHN1Ym1pdHRlZCB0byBleGNoYW5nZSBwcm94eScsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgdXBkYXRlZFRyYW5zYWN0aW9uU3VibWlzc2lvbiA9IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLi4udHJhbnNhY3Rpb25TdWJtaXNzaW9uRW50aXR5LFxyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBSZnFtVHJhbnNhY3Rpb25TdWJtaXNzaW9uU3RhdHVzLlN1Ym1pdHRlZCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdIGFzIFJmcW1WMlRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eVtdIHwgTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbkVudGl0eVtdO1xyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLl9kYlV0aWxzLnVwZGF0ZVJmcW1UcmFuc2FjdGlvblN1Ym1pc3Npb25zQXN5bmModXBkYXRlZFRyYW5zYWN0aW9uU3VibWlzc2lvbik7XHJcblxyXG4gICAgICAgIGxldCB1cGRhdGVkRW50aXR5O1xyXG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xyXG4gICAgICAgICAgICBjYXNlICdyZnFtX3YyX2pvYic6XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkRW50aXR5ID0gYXdhaXQgdGhpcy5fZGJVdGlscy5maW5kVjJUcmFuc2FjdGlvblN1Ym1pc3Npb25CeVRyYW5zYWN0aW9uSGFzaEFzeW5jKFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaEZyb21TdWJtaXQsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21ldGFfdHJhbnNhY3Rpb25fam9iJzpcclxuICAgICAgICAgICAgICAgIC8vICRlc2xpbnQtZml4LW1lIGh0dHBzOi8vZ2l0aHViLmNvbS9yaGlub2RhdmlkL2VzbGludC1maXgtbWVcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jYXNlLWRlY2xhcmF0aW9uc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFN1Ym1pc3Npb25FbnRpdGllcyA9XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZGJVdGlscy5maW5kTWV0YVRyYW5zYWN0aW9uU3VibWlzc2lvbnNCeVRyYW5zYWN0aW9uSGFzaEFzeW5jKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2hGcm9tU3VibWl0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWRTdWJtaXNzaW9uRW50aXRpZXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSB0cmFuc2FjdGlvbiBoYXNoIHNob3VsZCBuZXZlciBiZSBzdWJtaXR0ZWQgdHdpY2UgaW4gb3VyIHN5c3RlbS4gSG93ZXZlciwgUkZRLTU2MiBtZW50aW9uZWQgY2FzZXMgbGlrZSB0aGlzIGNvdWxkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFwcGVuIGluIG91ciBzeXN0ZW0uIEFkZCBtb3JlIGxvZyBhbmQgdGhyb3cgdGhlIGVycm9yIHRvIHN1cmZhY2UgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGtpbmQsIHN1Ym1pc3Npb25UeXBlLCB0cmFuc2FjdGlvbkhhc2ggfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYW5zYWN0aW9uIGhhc2ggaGF2ZSBiZWVuIHN1Ym1pdHRlZCBub3QgZXhhY3RseSBvbmNlJyxcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gaGFzaCBoYXZlIGJlZW4gc3VibWl0dGVkIG5vdCBleGFjdGx5IG9uY2UnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkRW50aXR5ID0gdXBkYXRlZFN1Ym1pc3Npb25FbnRpdGllc1swXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgKChfeDogbmV2ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9KShraW5kKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdXBkYXRlZEVudGl0eSkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4gLS0gd2UganVzdCBzYXZlZCBpdFxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICBgQ291bGQgbm90IGZpbmQgdXBkYXRlZCBlbnRpdHkgd2l0aCB0cmFuc2FjdGlvbiBoYXNoICR7dHJhbnNhY3Rpb25IYXNoRnJvbVN1Ym1pdH0gb2Yga2luZCAke2tpbmR9IGFuZCBzdWJtaXNzaW9uIHR5cGUgJHtzdWJtaXNzaW9uVHlwZX1gLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRFbnRpdHk7XHJcbiAgICB9XHJcbn1cclxuIl0sInZlcnNpb24iOjN9