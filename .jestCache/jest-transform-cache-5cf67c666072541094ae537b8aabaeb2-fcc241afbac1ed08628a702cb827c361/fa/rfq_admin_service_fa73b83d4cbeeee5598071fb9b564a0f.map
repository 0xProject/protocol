{"file":"/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_admin_service.ts","mappings":";;;AAAA,qCAAsC;AAEtC,iDAAkD;AAClD,6CAA6E;AAC7E,sCAAmC;AAKnC;;;;GAIG;AACH,MAAa,eAAe;IACxB,YAA6B,QAAqB;QAArB,aAAQ,GAAR,QAAQ,CAAa;IAAG,CAAC;IAEtD;;;OAGG;IACI,KAAK,CAAC,gBAAgB,CAAC,WAAqB,EAAE,MAAY,IAAI,IAAI,EAAE;QACvE,MAAM,YAAY,GAAa,EAAE,CAAC;QAClC,MAAM,cAAc,GAAa,EAAE,CAAC;QAEpC,MAAM,SAAS,GAAG,KAAK,EAAE,SAAiB,EAAiB,EAAE;YACzD,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,yBAAyB,CAAC,SAAS,CAAC,CAAC;YAErE,IAAI,CAAC,GAAG,EAAE;gBACN,eAAM,CAAC,KAAK,CAAC,EAAE,SAAS,EAAE,EAAE,6BAA6B,CAAC,CAAC;gBAC3D,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBAC/B,OAAO;aACV;YAED,IAAI,CAAC,iCAAyB,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;gBACjD,eAAM,CAAC,KAAK,CAAC,EAAE,SAAS,EAAE,MAAM,EAAE,GAAG,CAAC,MAAM,EAAE,EAAE,kCAAkC,CAAC,CAAC;gBACpF,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBAC/B,OAAO;aACV;YAED,IAAI;gBACA,MAAM,EAAE,MAAM,EAAE,GAAG,GAAG,CAAC;gBACvB,MAAM,uBAAuB,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,iBAAS,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC/D,MAAM,UAAU,GAAG,IAAI,iBAAS,CAAC,GAAG,CAAC,OAAO,EAAE,GAAG,yBAAa,CAAC,CAAC;gBAEhE,IAAI,UAAU,CAAC,aAAa,CAAC,uBAAuB,CAAC,EAAE;oBACnD,GAAG,CAAC,MAAM,GAAG,qBAAa,CAAC,aAAa,CAAC;oBACzC,MAAM,IAAI,CAAC,QAAQ,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC;oBAC5C,eAAM,CAAC,IAAI,CAAC,EAAE,SAAS,EAAE,EAAE,wCAAwC,CAAC,CAAC;oBACrE,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;iBAChC;qBAAM;oBACH,eAAM,CAAC,KAAK,CAAC,EAAE,SAAS,EAAE,EAAE,oCAAoC,CAAC,CAAC;oBAClE,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;iBAClC;aACJ;YAAC,OAAO,KAAK,EAAE;gBACZ,eAAM,CAAC,KAAK,CAAC,EAAE,SAAS,EAAE,EAAE,4BAA4B,CAAC,CAAC;gBAC1D,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;aAClC;QACL,CAAC,CAAC;QAEF,MAAM,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAExD,OAAO;YACH,YAAY;YACZ,cAAc;SACjB,CAAC;IACN,CAAC;CACJ;AArDD,0CAqDC","names":[],"sources":["/Users/davidwalsh/code-local/0x-rfq-api/src/services/rfq_admin_service.ts"],"sourcesContent":["import { BigNumber } from '@0x/utils';\r\n\r\nimport { ONE_SECOND_MS } from '../core/constants';\r\nimport { RfqmJobStatus, UnresolvedRfqmJobStatuses } from '../entities/types';\r\nimport { logger } from '../logger';\r\nimport { RfqmDbUtils } from '../utils/rfqm_db_utils';\r\n\r\nimport { CleanupJobsResponse } from './types';\r\n\r\n/**\r\n * RfqAdminService is the coordination layer for admin HTTP services.\r\n * It currently uses the admin API key for authentication, but\r\n * this can be replaced with a more sophisticated means of authentication.\r\n */\r\nexport class RfqAdminService {\r\n    constructor(private readonly _dbUtils: RfqmDbUtils) {}\r\n\r\n    /**\r\n     * Cleans up pending jobs by manually setting the status to `FailedExpired`.\r\n     * Ignores jobs not in a pending status.\r\n     */\r\n    public async cleanupJobsAsync(orderHashes: string[], now: Date = new Date()): Promise<CleanupJobsResponse> {\r\n        const modifiedJobs: string[] = [];\r\n        const unmodifiedJobs: string[] = [];\r\n\r\n        const handleJob = async (orderHash: string): Promise<void> => {\r\n            const job = await this._dbUtils.findV2JobByOrderHashAsync(orderHash);\r\n\r\n            if (!job) {\r\n                logger.error({ orderHash }, `No job found for order hash`);\r\n                unmodifiedJobs.push(orderHash);\r\n                return;\r\n            }\r\n\r\n            if (!UnresolvedRfqmJobStatuses.includes(job.status)) {\r\n                logger.error({ orderHash, status: job.status }, 'Tried to clean up a resolved job');\r\n                unmodifiedJobs.push(orderHash);\r\n                return;\r\n            }\r\n\r\n            try {\r\n                const { expiry } = job;\r\n                const thirtySecondsPastExpiry = expiry.plus(new BigNumber(30));\r\n                const nowSeconds = new BigNumber(now.getTime() / ONE_SECOND_MS);\r\n\r\n                if (nowSeconds.isGreaterThan(thirtySecondsPastExpiry)) {\r\n                    job.status = RfqmJobStatus.FailedExpired;\r\n                    await this._dbUtils.updateRfqmJobAsync(job);\r\n                    logger.info({ orderHash }, 'Job status manually updated to failure');\r\n                    modifiedJobs.push(orderHash);\r\n                } else {\r\n                    logger.error({ orderHash }, 'Tried to clean up an unexpired job');\r\n                    unmodifiedJobs.push(orderHash);\r\n                }\r\n            } catch (error) {\r\n                logger.error({ orderHash }, 'Failed to clean up the job');\r\n                unmodifiedJobs.push(orderHash);\r\n            }\r\n        };\r\n\r\n        await Promise.all(orderHashes.map((h) => handleJob(h)));\r\n\r\n        return {\r\n            modifiedJobs,\r\n            unmodifiedJobs,\r\n        };\r\n    }\r\n}\r\n"],"version":3}