{
    "schemaVersion": "2.0.0",
    "contractName": "UniswapV3MultiQuoter",
    "compilerOutput": {
        "abi": [
            {
                "inputs": [
                    {
                        "internalType": "contract IUniswapV3Factory",
                        "name": "factory",
                        "type": "address"
                    },
                    {
                        "internalType": "bytes",
                        "name": "path",
                        "type": "bytes"
                    },
                    {
                        "internalType": "uint256[]",
                        "name": "amountsIn",
                        "type": "uint256[]"
                    }
                ],
                "name": "quoteExactMultiInput",
                "outputs": [],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "contract IUniswapV3Factory",
                        "name": "factory",
                        "type": "address"
                    },
                    {
                        "internalType": "bytes",
                        "name": "path",
                        "type": "bytes"
                    },
                    {
                        "internalType": "uint256[]",
                        "name": "amountsOut",
                        "type": "uint256[]"
                    }
                ],
                "name": "quoteExactMultiOutput",
                "outputs": [],
                "stateMutability": "view",
                "type": "function"
            }
        ],
        "devdoc": {
            "kind": "dev",
            "methods": {
                "quoteExactMultiInput(address,bytes,uint256[])": {
                    "details": "This function reverts at the end of the quoting logic and encodes (uint256[] amountsOut, uint256[] gasEstimates) into the revert reason. See additional documentation below.",
                    "params": {
                        "amountsIn": "The amounts in of the first token to swap",
                        "factory": "The factory contract managing UniswapV3 pools",
                        "path": "The path of the swap, i.e. each token pair and the pool fee"
                    }
                },
                "quoteExactMultiOutput(address,bytes,uint256[])": {
                    "details": "This function reverts at the end of the quoting logic and encodes (uint256[] amountsIn, uint256[] gasEstimates) into the revert reason. See additional documentation below.",
                    "params": {
                        "amountsOut": "The amounts out of the last token to receive",
                        "factory": "The factory contract managing UniswapV3 pools",
                        "path": "The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order"
                    }
                }
            },
            "title": "Provides quotes for multiple swap amounts",
            "version": 1
        },
        "evm": {
            "bytecode": {
                "object": "0x608060405234801561001057600080fd5b50612c7a806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c806332dccba01461003b578063551e2bdf14610050575b600080fd5b61004e610049366004612683565b610063565b005b61004e61005e366004612683565b610472565b600081516001600160401b038111801561007c57600080fd5b506040519080825280602002602001820160405280156100a6578160200160208202803683370190505b509050600082516001600160401b03811180156100c257600080fd5b506040519080825280602002602001820160405280156100ec578160200160208202803683370190505b50905060005b60018451038110156101585783816001018151811061010d57fe5b602002602001015184828151811061012157fe5b602002602001015111156101505760405162461bcd60e51b815260040161014790612ab7565b60405180910390fd5b6001016100f2565b5082515b600080600061016a8861074b565b604051630b4c774160e11b815292955090935091506001600160a01b0380851681851610916000918c1690631698ee82906101ad90879089908890600401612a3e565b60206040518083038186803b1580156101c557600080fd5b505afa1580156101d9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101fd91906126fe565b90506000866001600160401b038111801561021757600080fd5b50604051908082528060200260200182016040528015610241578160200160208202803683370190505b50905060005b87811015610285578a818151811061025b57fe5b602002602001015160000382828151811061027257fe5b6020908102919091010152600101610247565b5060006102b9838584876102ad5773fffd8963efd1fc6a506488495d951d5263988d256102b4565b6401000276a45b61077c565b905060005b888110156103bd576000856102ed57826020015182815181106102dd57fe5b6020026020010151600003610309565b826040015182815181106102fd57fe5b60200260200101516000035b90508c828151811061031757fe5b6020026020010151811461032e57819950506103bd565b85610350578260400151828151811061034357fe5b6020026020010151610369565b8260200151828151811061036057fe5b60200260200101515b8d838151811061037557fe5b6020908102919091010152825180518390811061038e57fe5b60200260200101518b83815181106103a257fe5b602002602001018181510191508181525050506001016102be565b508715806103d157506103cf8c611027565b155b1561045b5760005b88811015610414578b81815181106103ed57fe5b60200260200101518b828151811061040157fe5b60209081029190910101526001016103d9565b5060008a8a60405160240161042a929190612a66565b60408051601f198184030181529190526020810180516001600160e01b0316631577da3360e01b1781528151919250fd5b6104648c611033565b9b505050505050505061015c565b60005b60018251038110156104d25781816001018151811061049057fe5b60200260200101518282815181106104a457fe5b602002602001015111156104ca5760405162461bcd60e51b815260040161014790612aa7565b600101610475565b50600081516001600160401b03811180156104ec57600080fd5b50604051908082528060200260200182016040528015610516578160200160208202803683370190505b5090505b60008060006105288661074b565b604051630b4c774160e11b815292955090935091506001600160a01b0380841681861610916000918a1690631698ee829061056b90889088908890600401612a3e565b60206040518083038186803b15801561058357600080fd5b505afa158015610597573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105bb91906126fe565b9050600087516001600160401b03811180156105d657600080fd5b50604051908082528060200260200182016040528015610600578160200160208202803683370190505b50905060005b88518110156106425788818151811061061b57fe5b602002602001015182828151811061062f57fe5b6020908102919091010152600101610606565b50600061066a838584876102ad5773fffd8963efd1fc6a506488495d951d5263988d256102b4565b905060005b895181101561070b578461069d578160200151818151811061068d57fe5b60200260200101516000036106b9565b816040015181815181106106ad57fe5b60200260200101516000035b8a82815181106106c557fe5b602090810291909101015281518051829081106106de57fe5b60200260200101518982815181106106f257fe5b602090810291909101018051909101905260010161066f565b506107158a611027565b1561072a576107238a611033565b995061073f565b6000898960405160240161042a929190612a66565b5050505050505061051a565b600080806107598482611050565b9250610766846014611100565b9050610773846017611050565b91509193909250565b610784612489565b82516001600160401b038111801561079b57600080fd5b506040519080825280602002602001820160405280156107c5578160200160208202803683370190505b50815282516001600160401b03811180156107df57600080fd5b50604051908082528060200260200182016040528015610809578160200160208202803683370190505b50602082015282516001600160401b038111801561082657600080fd5b50604051908082528060200260200182016040528015610850578160200160208202803683370190505b508160400181905250600080866001600160a01b0316633850c7bd6040518163ffffffff1660e01b815260040160e06040518083038186803b15801561089557600080fd5b505afa1580156108a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108cd9190612808565b5050505050915091506000876001600160a01b031663d0c93a7c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561091157600080fd5b505afa158015610925573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610949919061271c565b90506000886001600160a01b031663ddca3f436040518163ffffffff1660e01b815260040160206040518083038186803b15801561098657600080fd5b505afa15801561099a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109be91906128a4565b9050600080886000815181106109d057fe5b602002602001015113905060006040518060e001604052808a6000815181106109f557fe5b6020026020010151815260200160008152602001876001600160a01b031681526020018660020b81526020018c6001600160a01b0316631a6865026040518163ffffffff1660e01b815260040160206040518083038186803b158015610a5a57600080fd5b505afa158015610a6e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a92919061273a565b6001600160801b0316815260200160008152602001600081525090505b805115801590610ad55750876001600160a01b031681604001516001600160a01b031614155b15610f5357610ae26124aa565b5a60e082015260408201516001600160a01b031681526060820151610b0a908d90878e6111a7565b15156040830152600290810b810b60208301819052620d89e719910b1215610b3b57620d89e7196020820152610b5a565b6020810151620d89e860029190910b1315610b5a57620d89e860208201525b610b6781602001516113b3565b6001600160a01b031660608201526040820151610bd8908c610ba1578a6001600160a01b031683606001516001600160a01b031611610bbb565b8a6001600160a01b031683606001516001600160a01b0316105b610bc9578260600151610bcb565b8a5b60808501518551886116e5565b60c085015260a084015260808301526001600160a01b031660408301528215610c3a57610c0e8160c001518260800151016118d7565b825103825260a0810151610c3090610c25906118d7565b6020840151906118ed565b6020830152610c75565b610c478160a001516118d7565b825101825260c08101516080820151610c6f91610c6491016118d7565b602084015190611903565b60208301525b80606001516001600160a01b031682604001516001600160a01b03161415610d9457806040015115610d5557602081015160405163f30dba9360e01b81526000916001600160a01b038f169163f30dba9391610cd391600401612a99565b6101006040518083038186803b158015610cec57600080fd5b505afa158015610d00573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d249190612758565b5050505050509150508b15610d37576000035b610d45836080015182611919565b6001600160801b03166080840152505b8a610d64578060200151610d6d565b60018160200151035b600290810b900b60608301525a8160e00151038260c0018181510191508181525050610dcf565b80600001516001600160a01b031682604001516001600160a01b031614610dcf57610dc282604001516119cf565b600290810b900b60608301525b8151610f4d578215158b151514610e025781602001518a8360a0015181518110610df557fe5b6020026020010151610e20565b898260a0015181518110610e1257fe5b602002602001015182602001515b89602001518460a0015181518110610e3457fe5b602002602001018a604001518560a0015181518110610e4f57fe5b602002602001018281525082815250505080606001516001600160a01b031682604001516001600160a01b031614610eb857610e965a8260e00151038360c0015101611ced565b885160a084015181518110610ea757fe5b602002602001018181525050610ee3565b610ec58260c00151611ced565b885160a084015181518110610ed657fe5b6020026020010181815250505b60018a51038260a001511415610eff575050505050505061101f565b60a082018051600181019091528a51610f4a918c918110610f1c57fe5b60200260200101518b8460a0015181518110610f3457fe5b60200260200101516118ed90919063ffffffff16565b82525b50610aaf565b60a08101515b8951811015611017578215158b151514610f9157816020015182600001518b8381518110610f8357fe5b602002602001015103610fb1565b81600001518a8281518110610fa257fe5b60200260200101510382602001515b89602001518381518110610fc157fe5b602002602001018a604001518481518110610fd857fe5b6020026020010182815250828152505050610ff68260c00151611ced565b885180518390811061100457fe5b6020908102919091010152600101610f59565b505050505050505b949350505050565b8051604211155b919050565b805160609061104a90839060179060161901611d01565b92915050565b60008182601401101561109f576040805162461bcd60e51b8152602060048201526012602482015271746f416464726573735f6f766572666c6f7760701b604482015290519081900360640190fd5b81601401835110156110f0576040805162461bcd60e51b8152602060048201526015602482015274746f416464726573735f6f75744f66426f756e647360581b604482015290519081900360640190fd5b500160200151600160601b900490565b60008182600301101561114e576040805162461bcd60e51b8152602060048201526011602482015270746f55696e7432345f6f766572666c6f7760781b604482015290519081900360640190fd5b816003018351101561119e576040805162461bcd60e51b8152602060048201526014602482015273746f55696e7432345f6f75744f66426f756e647360601b604482015290519081900360640190fd5b50016003015190565b60008060008460020b8660020b816111bb57fe5b05905060008660020b1280156111e257508460020b8660020b816111db57fe5b0760020b15155b156111ec57600019015b83156112ca576000806111fe83611e54565b60405163299ce14b60e11b81529193509150600160ff83161b8001600019019060009082906001600160a01b038d1690635339c29690611242908890600401612a8b565b60206040518083038186803b15801561125a57600080fd5b505afa15801561126e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061129291906128c2565b1680151596509050856112ac57888360ff168603026112bf565b886112b682611e66565b840360ff168603025b9650505050506113a9565b6000806112d983600101611e54565b60405163299ce14b60e11b81529193509150600019600160ff84161b01199060009082906001600160a01b038d1690635339c2969061131c908890600401612a8b565b60206040518083038186803b15801561133457600080fd5b505afa158015611348573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061136c91906128c2565b16801515965090508561138c57888360ff0360ff168660010101026113a2565b888361139783611f06565b0360ff168660010101025b9650505050505b5094509492505050565b60008060008360020b126113ca578260020b6113d2565b8260020b6000035b9050620d89e8811115611410576040805162461bcd60e51b81526020600482015260016024820152601560fa1b604482015290519081900360640190fd5b60006001821661142457600160801b611436565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff169050600282161561146a576ffff97272373d413259a46990580e213a0260801c5b6004821615611489576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b60088216156114a8576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b60108216156114c7576fffcb9843d60f6159c9db58835c9266440260801c5b60208216156114e6576fff973b41fa98c081472e6896dfb254c00260801c5b6040821615611505576fff2ea16466c96a3843ec78b326b528610260801c5b6080821615611524576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615611544576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b610200821615611564576ff987a7253ac413176f2b074cf7815e540260801c5b610400821615611584576ff3392b0822b70005940c7a398e4b70f30260801c5b6108008216156115a4576fe7159475a2c29b7443b29c7fa6e889d90260801c5b6110008216156115c4576fd097f3bdfd2022b8845ad8f792aa58250260801c5b6120008216156115e4576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615611604576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615611624576f31be135f97d08fd981231505542fcfa60260801c5b62010000821615611645576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b62020000821615611665576e5d6af8dedb81196699c329225ee6040260801c5b62040000821615611684576d2216e584f5fa1ea926041bedfe980260801c5b620800008216156116a1576b048a170391f7dc42444e8fa20260801c5b60008460020b13156116bc5780600019816116b857fe5b0490505b6401000000008106156116d05760016116d3565b60005b60ff16602082901c0192505050919050565b60008080806001600160a01b03808916908a16101581871280159061176a57600061171e8989620f42400362ffffff16620f4240611fef565b905082611737576117328c8c8c600161209e565b611744565b6117448b8d8c6001612117565b9550858110611755578a9650611764565b6117618c8b83866121c2565b96505b506117b4565b816117815761177c8b8b8b6000612117565b61178e565b61178e8a8c8b600061209e565b93508388600003106117a2578995506117b4565b6117b18b8a8a6000038561220e565b95505b6001600160a01b038a8116908716148215611817578080156117d35750815b6117e9576117e4878d8c6001612117565b6117eb565b855b95508080156117f8575081155b61180e57611809878d8c600061209e565b611810565b845b9450611861565b8080156118215750815b611837576118328c888c600161209e565b611839565b855b9550808015611846575081155b61185c576118578c888c6000612117565b61185e565b845b94505b8115801561187157508860000385115b1561187d578860000394505b81801561189c57508a6001600160a01b0316876001600160a01b031614155b156118ab5785890393506118c8565b6118c5868962ffffff168a620f42400362ffffff1661225a565b93505b50505095509550955095915050565b6000600160ff1b82106118e957600080fd5b5090565b8082038281131560008312151461104a57600080fd5b8181018281121560008312151461104a57600080fd5b60008082600f0b121561197e57826001600160801b03168260000384039150816001600160801b031610611979576040805162461bcd60e51b81526020600482015260026024820152614c5360f01b604482015290519081900360640190fd5b61104a565b826001600160801b03168284019150816001600160801b0316101561104a576040805162461bcd60e51b81526020600482015260026024820152614c4160f01b604482015290519081900360640190fd5b60006401000276a36001600160a01b03831610801590611a0b575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b038316105b611a40576040805162461bcd60e51b81526020600482015260016024820152602960f91b604482015290519081900360640190fd5b640100000000600160c01b03602083901b166001600160801b03811160071b81811c6001600160401b03811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c60ff8111600390811b91821c600f811160021b90811c918211600190811b92831c97908811961790941790921717909117171760808110611ad357607f810383901c9150611add565b80607f0383901b91505b908002607f81811c60ff83811c9190911c800280831c81831c1c800280841c81841c1c800280851c81851c1c800280861c81861c1c800280871c81871c1c800280881c81881c1c800280891c81891c1c8002808a1c818a1c1c8002808b1c818b1c1c8002808c1c818c1c1c8002808d1c818d1c1c8002808e1c9c81901c9c909c1c80029c8d901c9e9d607f198f0160401b60c09190911c678000000000000000161760c19b909b1c674000000000000000169a909a1760c29990991c672000000000000000169890981760c39790971c671000000000000000169690961760c49590951c670800000000000000169490941760c59390931c670400000000000000169290921760c69190911c670200000000000000161760c79190911c670100000000000000161760c89190911c6680000000000000161760c99190911c6640000000000000161760ca9190911c6620000000000000161760cb9190911c6610000000000000161760cc9190911c6608000000000000161760cd9190911c66040000000000001617693627a301d71055774c8581026f028f6481ab7f045a5af012a19d003aa9198101608090811d906fdb2df09e81959a81455e260799a0632f8301901d600281810b9083900b14611cde57886001600160a01b0316611cc2826113b3565b6001600160a01b03161115611cd75781611cd9565b805b611ce0565b815b9998505050505050505050565b6000606460a683020461c350019050919050565b60608182601f011015611d4c576040805162461bcd60e51b815260206004820152600e60248201526d736c6963655f6f766572666c6f7760901b604482015290519081900360640190fd5b828284011015611d94576040805162461bcd60e51b815260206004820152600e60248201526d736c6963655f6f766572666c6f7760901b604482015290519081900360640190fd5b81830184511015611de0576040805162461bcd60e51b8152602060048201526011602482015270736c6963655f6f75744f66426f756e647360781b604482015290519081900360640190fd5b606082158015611dff5760405191506000825260208201604052611e49565b6040519150601f8416801560200281840101858101878315602002848b0101015b81831015611e38578051835260209283019201611e20565b5050858452601f01601f1916604052505b5090505b9392505050565b60020b600881901d9161010090910790565b6000808211611e7457600080fd5b600160801b8210611e8757608091821c91015b680100000000000000008210611e9f57604091821c91015b6401000000008210611eb357602091821c91015b620100008210611ec557601091821c91015b6101008210611ed657600891821c91015b60108210611ee657600491821c91015b60048210611ef657600291821c91015b6002821061102e57600101919050565b6000808211611f1457600080fd5b5060ff6001600160801b03821615611f2f57607f1901611f37565b608082901c91505b6001600160401b03821615611f4f57603f1901611f57565b604082901c91505b63ffffffff821615611f6c57601f1901611f74565b602082901c91505b61ffff821615611f8757600f1901611f8f565b601082901c91505b60ff821615611fa15760071901611fa9565b600882901c91505b600f821615611fbb5760031901611fc3565b600482901c91505b6003821615611fd55760011901611fdd565b600282901c91505b600182161561102e5760001901919050565b6000808060001985870986860292508281109083900303905080612025576000841161201a57600080fd5b508290049050611e4d565b80841161203157600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b6000836001600160a01b0316856001600160a01b031611156120be579293925b816120eb576120e6836001600160801b03168686036001600160a01b0316600160601b611fef565b61210e565b61210e836001600160801b03168686036001600160a01b0316600160601b61225a565b95945050505050565b6000836001600160a01b0316856001600160a01b03161115612137579293925b600160601b600160e01b03606084901b166001600160a01b03868603811690871661216157600080fd5b8361219157866001600160a01b03166121848383896001600160a01b0316611fef565b8161218b57fe5b046121b7565b6121b76121a88383896001600160a01b031661225a565b886001600160a01b0316612294565b979650505050505050565b600080856001600160a01b0316116121d957600080fd5b6000846001600160801b0316116121ef57600080fd5b81612201576120e6858585600161229f565b61210e8585856001612380565b600080856001600160a01b03161161222557600080fd5b6000846001600160801b03161161223b57600080fd5b8161224d576120e68585856000612380565b61210e858585600061229f565b6000612267848484611fef565b90506000828061227357fe5b8486091115611e4d57600019811061228a57600080fd5b6001019392505050565b808204910615150190565b600081156123125760006001600160a01b038411156122d5576122d084600160601b876001600160801b0316611fef565b6122ed565b6001600160801b038516606085901b816122eb57fe5b045b905061230a6123056001600160a01b03881683612463565b612473565b91505061101f565b60006001600160a01b038411156123405761233b84600160601b876001600160801b031661225a565b612357565b612357606085901b6001600160801b038716612294565b905080866001600160a01b03161161236e57600080fd5b6001600160a01b03861603905061101f565b60008261238e57508361101f565b600160601b600160e01b03606085901b16821561241c576001600160a01b038616848102908582816123bc57fe5b0414156123ed578181018281106123eb576123e183896001600160a01b03168361225a565b935050505061101f565b505b6124138261240e878a6001600160a01b0316868161240757fe5b0490612463565b612294565b9250505061101f565b6001600160a01b0386168481029085828161243357fe5b0414801561244057508082115b61244957600080fd5b8082036123e1612305846001600160a01b038b168461225a565b8082018281101561104a57600080fd5b806001600160a01b038116811461102e57600080fd5b60405180606001604052806060815260200160608152602001606081525090565b60405180610100016040528060006001600160a01b03168152602001600060020b815260200160001515815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001600081525090565b600061251961251484612af0565b612ac7565b9050808382526020820190508285602086028201111561253857600080fd5b60005b85811015612564578161254e8882612657565b845250602092830192919091019060010161253b565b5050509392505050565b600061257c61251484612b13565b90508281526020810184848401111561259457600080fd5b61259f848285612bbc565b509392505050565b600082601f8301126125b857600080fd5b813561101f848260208601612506565b805161104a81612bca565b600082601f8301126125e457600080fd5b813561101f84826020860161256e565b803561104a81612be1565b805161104a81612be1565b805161104a81612bea565b805161104a81612bf3565b805161104a81612bfc565b805161104a81612c05565b805161104a81612c17565b805161104a81612c0e565b805161104a81612c20565b803561104a81612c29565b805161104a81612c29565b805161104a81612c32565b805161104a81612c3b565b60008060006060848603121561269857600080fd5b60006126a486866125f4565b93505060208401356001600160401b038111156126c057600080fd5b6126cc868287016125d3565b92505060408401356001600160401b038111156126e857600080fd5b6126f4868287016125a7565b9150509250925092565b60006020828403121561271057600080fd5b600061101f84846125ff565b60006020828403121561272e57600080fd5b600061101f8484612615565b60006020828403121561274c57600080fd5b600061101f848461262b565b600080600080600080600080610100898b03121561277557600080fd5b60006127818b8b61262b565b98505060206127928b828c0161260a565b97505060406127a38b828c01612662565b96505060606127b48b828c01612662565b95505060806127c58b828c01612620565b94505060a06127d68b828c01612636565b93505060c06127e78b828c0161266d565b92505060e06127f88b828c016125c8565b9150509295985092959890939650565b600080600080600080600060e0888a03121561282357600080fd5b600061282f8a8a612636565b97505060206128408a828b01612615565b96505060406128518a828b01612641565b95505060606128628a828b01612641565b94505060806128738a828b01612641565b93505060a06128848a828b01612678565b92505060c06128958a828b016125c8565b91505092959891949750929550565b6000602082840312156128b657600080fd5b600061101f848461264c565b6000602082840312156128d457600080fd5b600061101f8484612662565b60006128ec8383612a35565b505060200190565b6128fd81612b50565b82525050565b600061290e82612b43565b6129188185612b47565b935061292383612b3d565b8060005b8381101561295157815161293b88826128e0565b975061294683612b3d565b925050600101612927565b509495945050505050565b6128fd81612b71565b6128fd81612b77565b600061297b603f83612b47565b7f556e697377617056334d756c746951756f7465722f616d6f756e7473496e206d81527f757374206265206d6f6e6f746f6e6963616c6c7920696e6372656173696e6700602082015260400192915050565b60006129da604083612b47565b7f556e697377617056334d756c746951756f7465722f616d6f756e74734f75742081527f6d757374206265206d6f6e6f746f6e6963616c6c7920696e6372656173696e67602082015260400192915050565b6128fd81612ba2565b6128fd81612baa565b60608101612a4c82866128f4565b612a5960208301856128f4565b61101f6040830184612a2c565b60408082528101612a778185612903565b9050818103602083015261101f8184612903565b6020810161104a828461295c565b6020810161104a8284612965565b6020808252810161104a8161296e565b6020808252810161104a816129cd565b6040518181016001600160401b0381118282101715612ae857612ae8612bc8565b604052919050565b60006001600160401b03821115612b0957612b09612bc8565b5060209081020190565b60006001600160401b03821115612b2c57612b2c612bc8565b506020601f91909101601f19160190565b60200190565b5190565b90815260200190565b600061104a82612b96565b151590565b600061104a82612b50565b600f0b90565b60010b90565b60020b90565b60060b90565b6001600160801b031690565b61ffff1690565b6001600160a01b031690565b62ffffff1690565b90565b63ffffffff1690565b60ff1690565b82818337506000910152565bfe5b612bd381612b5b565b8114612bde57600080fd5b50565b612bd381612b60565b612bd381612b6b565b612bd381612b77565b612bd381612b7d565b612bd381612b83565b612bd381612b8f565b612bd381612b96565b612bd381612ba2565b612bd381612baa565b612bd381612bad565b612bd381612bb656fea2646970667358221220b713688eee39097d8c2a4ca7163f028bcdbc2cf4822cf8bbeff86b7d77fd6ea564736f6c63430007060033",
                "sourceMap": "1318:19447:0:-:0;;;;;;;;;;;;;;;;;;;"
            },
            "deployedBytecode": {
                "object": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c806332dccba01461003b578063551e2bdf14610050575b600080fd5b61004e610049366004612683565b610063565b005b61004e61005e366004612683565b610472565b600081516001600160401b038111801561007c57600080fd5b506040519080825280602002602001820160405280156100a6578160200160208202803683370190505b509050600082516001600160401b03811180156100c257600080fd5b506040519080825280602002602001820160405280156100ec578160200160208202803683370190505b50905060005b60018451038110156101585783816001018151811061010d57fe5b602002602001015184828151811061012157fe5b602002602001015111156101505760405162461bcd60e51b815260040161014790612ab7565b60405180910390fd5b6001016100f2565b5082515b600080600061016a8861074b565b604051630b4c774160e11b815292955090935091506001600160a01b0380851681851610916000918c1690631698ee82906101ad90879089908890600401612a3e565b60206040518083038186803b1580156101c557600080fd5b505afa1580156101d9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101fd91906126fe565b90506000866001600160401b038111801561021757600080fd5b50604051908082528060200260200182016040528015610241578160200160208202803683370190505b50905060005b87811015610285578a818151811061025b57fe5b602002602001015160000382828151811061027257fe5b6020908102919091010152600101610247565b5060006102b9838584876102ad5773fffd8963efd1fc6a506488495d951d5263988d256102b4565b6401000276a45b61077c565b905060005b888110156103bd576000856102ed57826020015182815181106102dd57fe5b6020026020010151600003610309565b826040015182815181106102fd57fe5b60200260200101516000035b90508c828151811061031757fe5b6020026020010151811461032e57819950506103bd565b85610350578260400151828151811061034357fe5b6020026020010151610369565b8260200151828151811061036057fe5b60200260200101515b8d838151811061037557fe5b6020908102919091010152825180518390811061038e57fe5b60200260200101518b83815181106103a257fe5b602002602001018181510191508181525050506001016102be565b508715806103d157506103cf8c611027565b155b1561045b5760005b88811015610414578b81815181106103ed57fe5b60200260200101518b828151811061040157fe5b60209081029190910101526001016103d9565b5060008a8a60405160240161042a929190612a66565b60408051601f198184030181529190526020810180516001600160e01b0316631577da3360e01b1781528151919250fd5b6104648c611033565b9b505050505050505061015c565b60005b60018251038110156104d25781816001018151811061049057fe5b60200260200101518282815181106104a457fe5b602002602001015111156104ca5760405162461bcd60e51b815260040161014790612aa7565b600101610475565b50600081516001600160401b03811180156104ec57600080fd5b50604051908082528060200260200182016040528015610516578160200160208202803683370190505b5090505b60008060006105288661074b565b604051630b4c774160e11b815292955090935091506001600160a01b0380841681861610916000918a1690631698ee829061056b90889088908890600401612a3e565b60206040518083038186803b15801561058357600080fd5b505afa158015610597573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105bb91906126fe565b9050600087516001600160401b03811180156105d657600080fd5b50604051908082528060200260200182016040528015610600578160200160208202803683370190505b50905060005b88518110156106425788818151811061061b57fe5b602002602001015182828151811061062f57fe5b6020908102919091010152600101610606565b50600061066a838584876102ad5773fffd8963efd1fc6a506488495d951d5263988d256102b4565b905060005b895181101561070b578461069d578160200151818151811061068d57fe5b60200260200101516000036106b9565b816040015181815181106106ad57fe5b60200260200101516000035b8a82815181106106c557fe5b602090810291909101015281518051829081106106de57fe5b60200260200101518982815181106106f257fe5b602090810291909101018051909101905260010161066f565b506107158a611027565b1561072a576107238a611033565b995061073f565b6000898960405160240161042a929190612a66565b5050505050505061051a565b600080806107598482611050565b9250610766846014611100565b9050610773846017611050565b91509193909250565b610784612489565b82516001600160401b038111801561079b57600080fd5b506040519080825280602002602001820160405280156107c5578160200160208202803683370190505b50815282516001600160401b03811180156107df57600080fd5b50604051908082528060200260200182016040528015610809578160200160208202803683370190505b50602082015282516001600160401b038111801561082657600080fd5b50604051908082528060200260200182016040528015610850578160200160208202803683370190505b508160400181905250600080866001600160a01b0316633850c7bd6040518163ffffffff1660e01b815260040160e06040518083038186803b15801561089557600080fd5b505afa1580156108a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108cd9190612808565b5050505050915091506000876001600160a01b031663d0c93a7c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561091157600080fd5b505afa158015610925573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610949919061271c565b90506000886001600160a01b031663ddca3f436040518163ffffffff1660e01b815260040160206040518083038186803b15801561098657600080fd5b505afa15801561099a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109be91906128a4565b9050600080886000815181106109d057fe5b602002602001015113905060006040518060e001604052808a6000815181106109f557fe5b6020026020010151815260200160008152602001876001600160a01b031681526020018660020b81526020018c6001600160a01b0316631a6865026040518163ffffffff1660e01b815260040160206040518083038186803b158015610a5a57600080fd5b505afa158015610a6e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a92919061273a565b6001600160801b0316815260200160008152602001600081525090505b805115801590610ad55750876001600160a01b031681604001516001600160a01b031614155b15610f5357610ae26124aa565b5a60e082015260408201516001600160a01b031681526060820151610b0a908d90878e6111a7565b15156040830152600290810b810b60208301819052620d89e719910b1215610b3b57620d89e7196020820152610b5a565b6020810151620d89e860029190910b1315610b5a57620d89e860208201525b610b6781602001516113b3565b6001600160a01b031660608201526040820151610bd8908c610ba1578a6001600160a01b031683606001516001600160a01b031611610bbb565b8a6001600160a01b031683606001516001600160a01b0316105b610bc9578260600151610bcb565b8a5b60808501518551886116e5565b60c085015260a084015260808301526001600160a01b031660408301528215610c3a57610c0e8160c001518260800151016118d7565b825103825260a0810151610c3090610c25906118d7565b6020840151906118ed565b6020830152610c75565b610c478160a001516118d7565b825101825260c08101516080820151610c6f91610c6491016118d7565b602084015190611903565b60208301525b80606001516001600160a01b031682604001516001600160a01b03161415610d9457806040015115610d5557602081015160405163f30dba9360e01b81526000916001600160a01b038f169163f30dba9391610cd391600401612a99565b6101006040518083038186803b158015610cec57600080fd5b505afa158015610d00573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d249190612758565b5050505050509150508b15610d37576000035b610d45836080015182611919565b6001600160801b03166080840152505b8a610d64578060200151610d6d565b60018160200151035b600290810b900b60608301525a8160e00151038260c0018181510191508181525050610dcf565b80600001516001600160a01b031682604001516001600160a01b031614610dcf57610dc282604001516119cf565b600290810b900b60608301525b8151610f4d578215158b151514610e025781602001518a8360a0015181518110610df557fe5b6020026020010151610e20565b898260a0015181518110610e1257fe5b602002602001015182602001515b89602001518460a0015181518110610e3457fe5b602002602001018a604001518560a0015181518110610e4f57fe5b602002602001018281525082815250505080606001516001600160a01b031682604001516001600160a01b031614610eb857610e965a8260e00151038360c0015101611ced565b885160a084015181518110610ea757fe5b602002602001018181525050610ee3565b610ec58260c00151611ced565b885160a084015181518110610ed657fe5b6020026020010181815250505b60018a51038260a001511415610eff575050505050505061101f565b60a082018051600181019091528a51610f4a918c918110610f1c57fe5b60200260200101518b8460a0015181518110610f3457fe5b60200260200101516118ed90919063ffffffff16565b82525b50610aaf565b60a08101515b8951811015611017578215158b151514610f9157816020015182600001518b8381518110610f8357fe5b602002602001015103610fb1565b81600001518a8281518110610fa257fe5b60200260200101510382602001515b89602001518381518110610fc157fe5b602002602001018a604001518481518110610fd857fe5b6020026020010182815250828152505050610ff68260c00151611ced565b885180518390811061100457fe5b6020908102919091010152600101610f59565b505050505050505b949350505050565b8051604211155b919050565b805160609061104a90839060179060161901611d01565b92915050565b60008182601401101561109f576040805162461bcd60e51b8152602060048201526012602482015271746f416464726573735f6f766572666c6f7760701b604482015290519081900360640190fd5b81601401835110156110f0576040805162461bcd60e51b8152602060048201526015602482015274746f416464726573735f6f75744f66426f756e647360581b604482015290519081900360640190fd5b500160200151600160601b900490565b60008182600301101561114e576040805162461bcd60e51b8152602060048201526011602482015270746f55696e7432345f6f766572666c6f7760781b604482015290519081900360640190fd5b816003018351101561119e576040805162461bcd60e51b8152602060048201526014602482015273746f55696e7432345f6f75744f66426f756e647360601b604482015290519081900360640190fd5b50016003015190565b60008060008460020b8660020b816111bb57fe5b05905060008660020b1280156111e257508460020b8660020b816111db57fe5b0760020b15155b156111ec57600019015b83156112ca576000806111fe83611e54565b60405163299ce14b60e11b81529193509150600160ff83161b8001600019019060009082906001600160a01b038d1690635339c29690611242908890600401612a8b565b60206040518083038186803b15801561125a57600080fd5b505afa15801561126e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061129291906128c2565b1680151596509050856112ac57888360ff168603026112bf565b886112b682611e66565b840360ff168603025b9650505050506113a9565b6000806112d983600101611e54565b60405163299ce14b60e11b81529193509150600019600160ff84161b01199060009082906001600160a01b038d1690635339c2969061131c908890600401612a8b565b60206040518083038186803b15801561133457600080fd5b505afa158015611348573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061136c91906128c2565b16801515965090508561138c57888360ff0360ff168660010101026113a2565b888361139783611f06565b0360ff168660010101025b9650505050505b5094509492505050565b60008060008360020b126113ca578260020b6113d2565b8260020b6000035b9050620d89e8811115611410576040805162461bcd60e51b81526020600482015260016024820152601560fa1b604482015290519081900360640190fd5b60006001821661142457600160801b611436565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff169050600282161561146a576ffff97272373d413259a46990580e213a0260801c5b6004821615611489576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b60088216156114a8576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b60108216156114c7576fffcb9843d60f6159c9db58835c9266440260801c5b60208216156114e6576fff973b41fa98c081472e6896dfb254c00260801c5b6040821615611505576fff2ea16466c96a3843ec78b326b528610260801c5b6080821615611524576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615611544576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b610200821615611564576ff987a7253ac413176f2b074cf7815e540260801c5b610400821615611584576ff3392b0822b70005940c7a398e4b70f30260801c5b6108008216156115a4576fe7159475a2c29b7443b29c7fa6e889d90260801c5b6110008216156115c4576fd097f3bdfd2022b8845ad8f792aa58250260801c5b6120008216156115e4576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615611604576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615611624576f31be135f97d08fd981231505542fcfa60260801c5b62010000821615611645576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b62020000821615611665576e5d6af8dedb81196699c329225ee6040260801c5b62040000821615611684576d2216e584f5fa1ea926041bedfe980260801c5b620800008216156116a1576b048a170391f7dc42444e8fa20260801c5b60008460020b13156116bc5780600019816116b857fe5b0490505b6401000000008106156116d05760016116d3565b60005b60ff16602082901c0192505050919050565b60008080806001600160a01b03808916908a16101581871280159061176a57600061171e8989620f42400362ffffff16620f4240611fef565b905082611737576117328c8c8c600161209e565b611744565b6117448b8d8c6001612117565b9550858110611755578a9650611764565b6117618c8b83866121c2565b96505b506117b4565b816117815761177c8b8b8b6000612117565b61178e565b61178e8a8c8b600061209e565b93508388600003106117a2578995506117b4565b6117b18b8a8a6000038561220e565b95505b6001600160a01b038a8116908716148215611817578080156117d35750815b6117e9576117e4878d8c6001612117565b6117eb565b855b95508080156117f8575081155b61180e57611809878d8c600061209e565b611810565b845b9450611861565b8080156118215750815b611837576118328c888c600161209e565b611839565b855b9550808015611846575081155b61185c576118578c888c6000612117565b61185e565b845b94505b8115801561187157508860000385115b1561187d578860000394505b81801561189c57508a6001600160a01b0316876001600160a01b031614155b156118ab5785890393506118c8565b6118c5868962ffffff168a620f42400362ffffff1661225a565b93505b50505095509550955095915050565b6000600160ff1b82106118e957600080fd5b5090565b8082038281131560008312151461104a57600080fd5b8181018281121560008312151461104a57600080fd5b60008082600f0b121561197e57826001600160801b03168260000384039150816001600160801b031610611979576040805162461bcd60e51b81526020600482015260026024820152614c5360f01b604482015290519081900360640190fd5b61104a565b826001600160801b03168284019150816001600160801b0316101561104a576040805162461bcd60e51b81526020600482015260026024820152614c4160f01b604482015290519081900360640190fd5b60006401000276a36001600160a01b03831610801590611a0b575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b038316105b611a40576040805162461bcd60e51b81526020600482015260016024820152602960f91b604482015290519081900360640190fd5b640100000000600160c01b03602083901b166001600160801b03811160071b81811c6001600160401b03811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c60ff8111600390811b91821c600f811160021b90811c918211600190811b92831c97908811961790941790921717909117171760808110611ad357607f810383901c9150611add565b80607f0383901b91505b908002607f81811c60ff83811c9190911c800280831c81831c1c800280841c81841c1c800280851c81851c1c800280861c81861c1c800280871c81871c1c800280881c81881c1c800280891c81891c1c8002808a1c818a1c1c8002808b1c818b1c1c8002808c1c818c1c1c8002808d1c818d1c1c8002808e1c9c81901c9c909c1c80029c8d901c9e9d607f198f0160401b60c09190911c678000000000000000161760c19b909b1c674000000000000000169a909a1760c29990991c672000000000000000169890981760c39790971c671000000000000000169690961760c49590951c670800000000000000169490941760c59390931c670400000000000000169290921760c69190911c670200000000000000161760c79190911c670100000000000000161760c89190911c6680000000000000161760c99190911c6640000000000000161760ca9190911c6620000000000000161760cb9190911c6610000000000000161760cc9190911c6608000000000000161760cd9190911c66040000000000001617693627a301d71055774c8581026f028f6481ab7f045a5af012a19d003aa9198101608090811d906fdb2df09e81959a81455e260799a0632f8301901d600281810b9083900b14611cde57886001600160a01b0316611cc2826113b3565b6001600160a01b03161115611cd75781611cd9565b805b611ce0565b815b9998505050505050505050565b6000606460a683020461c350019050919050565b60608182601f011015611d4c576040805162461bcd60e51b815260206004820152600e60248201526d736c6963655f6f766572666c6f7760901b604482015290519081900360640190fd5b828284011015611d94576040805162461bcd60e51b815260206004820152600e60248201526d736c6963655f6f766572666c6f7760901b604482015290519081900360640190fd5b81830184511015611de0576040805162461bcd60e51b8152602060048201526011602482015270736c6963655f6f75744f66426f756e647360781b604482015290519081900360640190fd5b606082158015611dff5760405191506000825260208201604052611e49565b6040519150601f8416801560200281840101858101878315602002848b0101015b81831015611e38578051835260209283019201611e20565b5050858452601f01601f1916604052505b5090505b9392505050565b60020b600881901d9161010090910790565b6000808211611e7457600080fd5b600160801b8210611e8757608091821c91015b680100000000000000008210611e9f57604091821c91015b6401000000008210611eb357602091821c91015b620100008210611ec557601091821c91015b6101008210611ed657600891821c91015b60108210611ee657600491821c91015b60048210611ef657600291821c91015b6002821061102e57600101919050565b6000808211611f1457600080fd5b5060ff6001600160801b03821615611f2f57607f1901611f37565b608082901c91505b6001600160401b03821615611f4f57603f1901611f57565b604082901c91505b63ffffffff821615611f6c57601f1901611f74565b602082901c91505b61ffff821615611f8757600f1901611f8f565b601082901c91505b60ff821615611fa15760071901611fa9565b600882901c91505b600f821615611fbb5760031901611fc3565b600482901c91505b6003821615611fd55760011901611fdd565b600282901c91505b600182161561102e5760001901919050565b6000808060001985870986860292508281109083900303905080612025576000841161201a57600080fd5b508290049050611e4d565b80841161203157600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b6000836001600160a01b0316856001600160a01b031611156120be579293925b816120eb576120e6836001600160801b03168686036001600160a01b0316600160601b611fef565b61210e565b61210e836001600160801b03168686036001600160a01b0316600160601b61225a565b95945050505050565b6000836001600160a01b0316856001600160a01b03161115612137579293925b600160601b600160e01b03606084901b166001600160a01b03868603811690871661216157600080fd5b8361219157866001600160a01b03166121848383896001600160a01b0316611fef565b8161218b57fe5b046121b7565b6121b76121a88383896001600160a01b031661225a565b886001600160a01b0316612294565b979650505050505050565b600080856001600160a01b0316116121d957600080fd5b6000846001600160801b0316116121ef57600080fd5b81612201576120e6858585600161229f565b61210e8585856001612380565b600080856001600160a01b03161161222557600080fd5b6000846001600160801b03161161223b57600080fd5b8161224d576120e68585856000612380565b61210e858585600061229f565b6000612267848484611fef565b90506000828061227357fe5b8486091115611e4d57600019811061228a57600080fd5b6001019392505050565b808204910615150190565b600081156123125760006001600160a01b038411156122d5576122d084600160601b876001600160801b0316611fef565b6122ed565b6001600160801b038516606085901b816122eb57fe5b045b905061230a6123056001600160a01b03881683612463565b612473565b91505061101f565b60006001600160a01b038411156123405761233b84600160601b876001600160801b031661225a565b612357565b612357606085901b6001600160801b038716612294565b905080866001600160a01b03161161236e57600080fd5b6001600160a01b03861603905061101f565b60008261238e57508361101f565b600160601b600160e01b03606085901b16821561241c576001600160a01b038616848102908582816123bc57fe5b0414156123ed578181018281106123eb576123e183896001600160a01b03168361225a565b935050505061101f565b505b6124138261240e878a6001600160a01b0316868161240757fe5b0490612463565b612294565b9250505061101f565b6001600160a01b0386168481029085828161243357fe5b0414801561244057508082115b61244957600080fd5b8082036123e1612305846001600160a01b038b168461225a565b8082018281101561104a57600080fd5b806001600160a01b038116811461102e57600080fd5b60405180606001604052806060815260200160608152602001606081525090565b60405180610100016040528060006001600160a01b03168152602001600060020b815260200160001515815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001600081525090565b600061251961251484612af0565b612ac7565b9050808382526020820190508285602086028201111561253857600080fd5b60005b85811015612564578161254e8882612657565b845250602092830192919091019060010161253b565b5050509392505050565b600061257c61251484612b13565b90508281526020810184848401111561259457600080fd5b61259f848285612bbc565b509392505050565b600082601f8301126125b857600080fd5b813561101f848260208601612506565b805161104a81612bca565b600082601f8301126125e457600080fd5b813561101f84826020860161256e565b803561104a81612be1565b805161104a81612be1565b805161104a81612bea565b805161104a81612bf3565b805161104a81612bfc565b805161104a81612c05565b805161104a81612c17565b805161104a81612c0e565b805161104a81612c20565b803561104a81612c29565b805161104a81612c29565b805161104a81612c32565b805161104a81612c3b565b60008060006060848603121561269857600080fd5b60006126a486866125f4565b93505060208401356001600160401b038111156126c057600080fd5b6126cc868287016125d3565b92505060408401356001600160401b038111156126e857600080fd5b6126f4868287016125a7565b9150509250925092565b60006020828403121561271057600080fd5b600061101f84846125ff565b60006020828403121561272e57600080fd5b600061101f8484612615565b60006020828403121561274c57600080fd5b600061101f848461262b565b600080600080600080600080610100898b03121561277557600080fd5b60006127818b8b61262b565b98505060206127928b828c0161260a565b97505060406127a38b828c01612662565b96505060606127b48b828c01612662565b95505060806127c58b828c01612620565b94505060a06127d68b828c01612636565b93505060c06127e78b828c0161266d565b92505060e06127f88b828c016125c8565b9150509295985092959890939650565b600080600080600080600060e0888a03121561282357600080fd5b600061282f8a8a612636565b97505060206128408a828b01612615565b96505060406128518a828b01612641565b95505060606128628a828b01612641565b94505060806128738a828b01612641565b93505060a06128848a828b01612678565b92505060c06128958a828b016125c8565b91505092959891949750929550565b6000602082840312156128b657600080fd5b600061101f848461264c565b6000602082840312156128d457600080fd5b600061101f8484612662565b60006128ec8383612a35565b505060200190565b6128fd81612b50565b82525050565b600061290e82612b43565b6129188185612b47565b935061292383612b3d565b8060005b8381101561295157815161293b88826128e0565b975061294683612b3d565b925050600101612927565b509495945050505050565b6128fd81612b71565b6128fd81612b77565b600061297b603f83612b47565b7f556e697377617056334d756c746951756f7465722f616d6f756e7473496e206d81527f757374206265206d6f6e6f746f6e6963616c6c7920696e6372656173696e6700602082015260400192915050565b60006129da604083612b47565b7f556e697377617056334d756c746951756f7465722f616d6f756e74734f75742081527f6d757374206265206d6f6e6f746f6e6963616c6c7920696e6372656173696e67602082015260400192915050565b6128fd81612ba2565b6128fd81612baa565b60608101612a4c82866128f4565b612a5960208301856128f4565b61101f6040830184612a2c565b60408082528101612a778185612903565b9050818103602083015261101f8184612903565b6020810161104a828461295c565b6020810161104a8284612965565b6020808252810161104a8161296e565b6020808252810161104a816129cd565b6040518181016001600160401b0381118282101715612ae857612ae8612bc8565b604052919050565b60006001600160401b03821115612b0957612b09612bc8565b5060209081020190565b60006001600160401b03821115612b2c57612b2c612bc8565b506020601f91909101601f19160190565b60200190565b5190565b90815260200190565b600061104a82612b96565b151590565b600061104a82612b50565b600f0b90565b60010b90565b60020b90565b60060b90565b6001600160801b031690565b61ffff1690565b6001600160a01b031690565b62ffffff1690565b90565b63ffffffff1690565b60ff1690565b82818337506000910152565bfe5b612bd381612b5b565b8114612bde57600080fd5b50565b612bd381612b60565b612bd381612b6b565b612bd381612b77565b612bd381612b7d565b612bd381612b83565b612bd381612b8f565b612bd381612b96565b612bd381612ba2565b612bd381612baa565b612bd381612bad565b612bd381612bb656fea2646970667358221220b713688eee39097d8c2a4ca7163f028bcdbc2cf4822cf8bbeff86b7d77fd6ea564736f6c63430007060033",
                "sourceMap": "1318:19447:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;7371:3037;;;;;;:::i;:::-;;:::i;:::-;;4513:2287;;;;;;:::i;:::-;;:::i;7371:3037::-;7538:26;7581:10;:17;-1:-1:-1;;;;;7567:32:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;7567:32:0;;7538:61;;7609:29;7655:10;:17;-1:-1:-1;;;;;7641:32:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;7641:32:0;;7609:64;;7689:9;7684:234;7728:1;7708:10;:17;:21;7704:1;:25;7684:234;;;7792:10;7803:1;7807;7803:5;7792:17;;;;;;;;;;;;;;7775:10;7786:1;7775:13;;;;;;;;;;;;;;:34;;7750:157;;;;-1:-1:-1;;;7750:157:0;;;;;;;:::i;:::-;;;;;;;;;7731:3;;7684:234;;;-1:-1:-1;7956:17:0;;7983:2419;8011:16;8029:15;8046:10;8060:22;:4;:20;:22::i;:::-;8168:39;;-1:-1:-1;;;8168:39:0;;8010:72;;-1:-1:-1;8010:72:0;;-1:-1:-1;8010:72:0;-1:-1:-1;;;;;;8114:18:0;;;;;;;;8096:15;;8168;;;;;:39;;8010:72;;;;;;8168:39;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;8146:61;;8288:23;8327:17;-1:-1:-1;;;;;8314:31:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;8314:31:0;;8288:57;;8364:9;8359:116;8383:17;8379:1;:21;8359:116;;;8446:10;8457:1;8446:13;;;;;;;;;;;;;;8438:22;;8425:7;8433:1;8425:10;;;;;;;;;;;;;;;;;:35;8402:3;;8359:116;;;;8489:29;8521:186;8548:4;8570:10;8598:7;8623:10;:70;;8666:27;8623:70;;;8636:27;8623:70;8521:9;:186::i;:::-;8489:218;;8727:9;8722:754;8746:17;8742:1;:21;8722:754;;;8788:22;8813:10;:72;;8866:6;:15;;;8882:1;8866:18;;;;;;;;;;;;;;8865:19;;8813:72;;;8835:6;:15;;;8851:1;8835:18;;;;;;;;;;;;;;8834:19;;8813:72;8788:97;;8925:10;8936:1;8925:13;;;;;;;;;;;;;;8907:14;:31;8903:559;;9158:1;9138:21;;9181:5;;;8903:559;9310:10;:70;;9361:6;:15;;;9377:1;9361:18;;;;;;;;;;;;;;9310:70;;;9331:6;:15;;;9347:1;9331:18;;;;;;;;;;;;;;9310:70;9294:10;9305:1;9294:13;;;;;;;;;;;;;;;;;:86;9421:19;;:22;;9441:1;;9421:22;;;;;;;;;;;;9402:12;9415:1;9402:15;;;;;;;;;;;;;:41;;;;;;;;;;;-1:-1:-1;8765:3:0;;8722:754;;;-1:-1:-1;9494:22:0;;;:50;;;9521:23;:4;:21;:23::i;:::-;9520:24;9494:50;9490:864;;;9569:9;9564:117;9588:17;9584:1;:21;9564:117;;;9649:10;9660:1;9649:13;;;;;;;;;;;;;;9634:9;9644:1;9634:12;;;;;;;;;;;;;;;;;:28;9607:3;;9564:117;;;;10036:25;10160:9;10191:12;10064:157;;;;;;;;;:::i;:::-;;;;-1:-1:-1;;10064:157:0;;;;;;;;;;;;;;-1:-1:-1;;;;;10064:157:0;-1:-1:-1;;;10064:157:0;;;10302:19;;10064:157;;-1:-1:-1;10270:52:0;10248:92;10375:16;:4;:14;:16::i;:::-;10368:23;;7983:2419;;;;;;;;;4513:2287;4683:9;4678:230;4721:1;4702:9;:16;:20;4698:1;:24;4678:230;;;4784:9;4794:1;4798;4794:5;4784:16;;;;;;;;;;;;;;4768:9;4778:1;4768:12;;;;;;;;;;;;;;:32;;4743:154;;;;-1:-1:-1;;;4743:154:0;;;;;;;:::i;:::-;4724:3;;4678:230;;;;4917:29;4963:9;:16;-1:-1:-1;;;;;4949:31:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;4949:31:0;;4917:63;;4991:1803;5019:15;5036:16;5054:10;5068:22;:4;:20;:22::i;:::-;5176:39;;-1:-1:-1;;;5176:39:0;;5018:72;;-1:-1:-1;5018:72:0;;-1:-1:-1;5018:72:0;-1:-1:-1;;;;;;5122:18:0;;;;;;;;5104:15;;5176;;;;;:39;;5018:72;;;;;;5176:39;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;5154:61;;5295:23;5334:9;:16;-1:-1:-1;;;;;5321:30:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;5321:30:0;;5295:56;;5370:9;5365:113;5389:9;:16;5385:1;:20;5365:113;;;5450:9;5460:1;5450:12;;;;;;;;;;;;;;5430:7;5438:1;5430:10;;;;;;;;;;;;;;;;;:33;5407:3;;5365:113;;;;5492:29;5524:186;5551:4;5573:10;5601:7;5626:10;:70;;5669:27;5626:70;;5524:186;5492:218;;5730:9;5725:226;5749:9;:16;5745:1;:20;5725:226;;;5805:10;:72;;5858:6;:15;;;5874:1;5858:18;;;;;;;;;;;;;;5857:19;;5805:72;;;5827:6;:15;;;5843:1;5827:18;;;;;;;;;;;;;;5826:19;;5805:72;5790:9;5800:1;5790:12;;;;;;;;;;;;;;;;;:87;5914:19;;:22;;5934:1;;5914:22;;;;;;;;;;;;5895:12;5908:1;5895:15;;;;;;;;;;;;;;;;;:41;;;;;;;5767:3;;5725:226;;;;6024:23;:4;:21;:23::i;:::-;6020:764;;;6074:16;:4;:14;:16::i;:::-;6067:23;;6020:764;;;6466:25;6590:9;6621:12;6494:157;;;;;;;;;:::i;6678:92::-;4991:1803;;;;;;;;;1779:314:13;1883:14;;;1983:17;:4;1883:14;1983;:17::i;:::-;1974:26;-1:-1:-1;2016:24:13;:4;304:2;2016:13;:24::i;:::-;2010:30;-1:-1:-1;2059:27:13;:4;507:20;2059:14;:27::i;:::-;2050:36;;1779:314;;;;;:::o;11477:5561:0:-;11646:29;;:::i;:::-;11723:7;:14;-1:-1:-1;;;;;11709:29:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;11709:29:0;-1:-1:-1;11687:51:0;;11779:14;;-1:-1:-1;;;;;11766:28:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;11766:28:0;-1:-1:-1;11748:15:0;;;:46;11835:14;;-1:-1:-1;;;;;11822:28:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;11822:28:0;;11804:6;:15;;:46;;;;11862:25;11889:15;11918:4;-1:-1:-1;;;;;11918:10:0;;:12;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;11861:69;;;;;;;;;11940:17;11960:4;-1:-1:-1;;;;;11960:16:0;;:18;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;11940:38;;11988:10;12001:4;-1:-1:-1;;;;;12001:8:0;;:10;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;11988:23;;12022:15;12053:1;12040:7;12048:1;12040:10;;;;;;;;;;;;;;:14;12022:32;;12065:22;12090:277;;;;;;;;12140:7;12148:1;12140:10;;;;;;;;;;;;;;12090:277;;;;12182:1;12090:277;;;;12211:17;-1:-1:-1;;;;;12090:277:0;;;;;12248:9;12090:277;;;;;;12282:4;-1:-1:-1;;;;;12282:14:0;;:16;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;;;;;12090:277:0;;;;;12326:1;12090:277;;;;12355:1;12090:277;;;12065:302;;12494:4114;12501:30;;:35;;;;:78;;;12562:17;-1:-1:-1;;;;;12540:39:0;:5;:18;;;-1:-1:-1;;;;;12540:39:0;;;12501:78;12494:4114;;;12595:28;;:::i;:::-;12654:9;12637:14;;;:26;12703:18;;;;-1:-1:-1;;;;;12678:43:0;;;12844:10;;;;12772:153;;12822:4;;12872:11;12901:10;12772:32;:153::i;:::-;12736:189;;12752:16;;;12736:189;;;;;;;12737:13;;;12736:189;;;-1:-1:-1;;13057:33:0;;;13053:216;;;-1:-1:-1;;13110:13:0;;;:33;13053:216;;;13168:13;;;;644:9:10;13168:33:0;;;;;;13164:105;;;644:9:10;13221:13:0;;;:33;13164:105;13354:42;13382:4;:13;;;13354:27;:42::i;:::-;-1:-1:-1;;;;;13330:66:0;:21;;;:66;13642:18;;;;13600:378;;13679:10;:98;;13760:17;-1:-1:-1;;;;;13736:41:0;:4;:21;;;-1:-1:-1;;;;;13736:41:0;;13679:98;;;13716:17;-1:-1:-1;;;;;13692:41:0;:4;:21;;;-1:-1:-1;;;;;13692:41:0;;13679:98;13678:184;;13841:4;:21;;;13678:184;;;13801:17;13678:184;13880:15;;;;13913:30;;13961:3;13600:24;:378::i;:::-;13582:14;;;13530:448;13566:14;;;13530:448;13551:13;;;13530:448;-1:-1:-1;;;;;13530:448:0;13531:18;;;13530:448;13993:434;;;;14061:43;14078:4;:14;;;14062:4;:13;;;:30;14061:41;:43::i;:::-;14027:77;;;;;14174:14;;;;14147:53;;14174:25;;:23;:25::i;:::-;14147:22;;;;;:26;:53::i;:::-;14122:22;;;:78;13993:434;;;14273:25;:4;:14;;;:23;:25::i;:::-;14239:59;;;;;14385:14;;;;14369:13;;;;14341:71;;14368:43;;14369:30;14368:41;:43::i;:::-;14341:22;;;;;:26;:71::i;:::-;14316:22;;;:96;13993:434;14522:4;:21;;;-1:-1:-1;;;;;14500:43:0;:5;:18;;;-1:-1:-1;;;;;14500:43:0;;14496:1024;;;14638:4;:16;;;14634:459;;;14727:13;;;;14716:25;;-1:-1:-1;;;14716:25:0;;14681:19;;-1:-1:-1;;;;;14716:10:0;;;;;:25;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;14678:63;;;;;;;;;14940:10;14936:44;;;14967:13;;14936:44;15021:53;15044:5;:15;;;15061:12;15021:22;:53::i;:::-;-1:-1:-1;;;;;15003:71:0;:15;;;:71;-1:-1:-1;14634:459:0;15124:10;:46;;15157:4;:13;;;15124:46;;;15153:1;15137:4;:13;;;:17;15124:46;15111:59;;;;;;:10;;;:59;15227:9;15210:4;:14;;;:26;15188:5;:18;;:48;;;;;;;;;;;14496:1024;;;15283:4;:22;;;-1:-1:-1;;;;;15261:44:0;:5;:18;;;-1:-1:-1;;;;;15261:44:0;;15257:263;;15458:47;15486:5;:18;;;15458:27;:47::i;:::-;15445:60;;;;;;:10;;;:60;15257:263;15538:30;;15534:1064;;15684:10;15670:24;;:10;:24;;;:176;;15794:5;:22;;;15818:7;15826:5;:18;;;15818:27;;;;;;;;;;;;;;15670:176;;;15718:7;15726:5;:18;;;15718:27;;;;;;;;;;;;;;15747:5;:22;;;15670:176;15594:6;:15;;;15610:5;:18;;;15594:35;;;;;;;;;;;;;15631:6;:15;;;15647:5;:18;;;15631:35;;;;;;;;;;;;;15593:253;;;;;;;;;;15891:4;:21;;;-1:-1:-1;;;;;15869:43:0;:5;:18;;;-1:-1:-1;;;;;15869:43:0;;15865:442;;15978:122;16068:9;16051:4;:14;;;:26;16029:5;:18;;;:49;15978:25;:122::i;:::-;15936:19;;15956:18;;;;15936:39;;;;;;;;;;;;;:164;;;;;15865:442;;;16243:45;16269:5;:18;;;16243:25;:45::i;:::-;16201:19;;16221:18;;;;16201:39;;;;;;;;;;;;;:87;;;;;15865:442;16368:1;16351:7;:14;:18;16329:5;:18;;;:40;16325:102;;;16393:15;;;;;;;;;16325:102;16445:18;;;:23;;16467:1;16445:23;;;;;16551:31;;16519:64;;16551:7;;:31;;;;;;;;;;;;16519:7;16527:5;:18;;;16519:27;;;;;;;;;;;;;;:31;;:64;;;;:::i;:::-;16486:97;;15534:1064;12494:4114;;;;16635:18;;;;16618:414;16659:7;:14;16655:1;:18;16618:414;;;16751:10;16737:24;;:10;:24;;;:200;;16869:5;:22;;;16906:5;:30;;;16893:7;16901:1;16893:10;;;;;;;;;;;;;;:43;16737:200;;;16794:5;:30;;;16781:7;16789:1;16781:10;;;;;;;;;;;;;;:43;16826:5;:22;;;16737:200;16695:6;:15;;;16711:1;16695:18;;;;;;;;;;;;;16715:6;:15;;;16731:1;16715:18;;;;;;;;;;;;;16694:243;;;;;;;;;;16976:45;17002:5;:18;;;16976:25;:45::i;:::-;16951:19;;:22;;16971:1;;16951:22;;;;;;;;;;;;;;;:70;16675:3;;16618:414;;;;11477:5561;;;;;;;;;;;;;:::o;992:138:13:-;1083:11;;777:24;-1:-1:-1;1083:40:13;992:138;;;;:::o;2635:149::-;2751:11;;2696:12;;2727:50;;2751:4;;507:20;;-1:-1:-1;;2751:25:13;2727:10;:50::i;:::-;2720:57;2635:149;-1:-1:-1;;2635:149:13:o;3412:416:12:-;3491:7;3533:6;3518;3527:2;3518:11;:21;;3510:52;;;;;-1:-1:-1;;;3510:52:12;;;;;;;;;;;;-1:-1:-1;;;3510:52:12;;;;;;;;;;;;;;;3597:6;3606:2;3597:11;3580:6;:13;:28;;3572:62;;;;;-1:-1:-1;;;3572:62:12;;;;;;;;;;;;-1:-1:-1;;;3572:62:12;;;;;;;;;;;;;;;-1:-1:-1;3722:30:12;3738:4;3722:30;3716:37;-1:-1:-1;;;3712:71:12;;;3412:416::o;3834:365::-;3912:6;3952;3938;3947:1;3938:10;:20;;3930:50;;;;;-1:-1:-1;;;3930:50:12;;;;;;;;;;;;-1:-1:-1;;;3930:50:12;;;;;;;;;;;;;;;4015:6;4024:1;4015:10;3998:6;:13;:27;;3990:60;;;;;-1:-1:-1;;;3990:60:12;;;;;;;;;;;;-1:-1:-1;;;3990:60:12;;;;;;;;;;;;;;;-1:-1:-1;4127:29:12;4143:3;4127:29;4121:36;;3834:365::o;18344:1923:0:-;18508:10;18520:16;18548;18574:11;18567:18;;:4;:18;;;;;;;;18548:37;;18606:1;18599:4;:8;;;:35;;;;;18618:11;18611:18;;:4;:18;;;;;;;;:23;;;;18599:35;18595:53;;;-1:-1:-1;;18636:12:0;18595:53;18698:3;18694:1567;;;18718:13;18733:12;18749:20;18758:10;18749:8;:20::i;:::-;18929:24;;-1:-1:-1;;;18929:24:0;;18717:52;;-1:-1:-1;18717:52:0;-1:-1:-1;18886:1:0;:11;;;;18865:33;;-1:-1:-1;;18865:33:0;;18850:12;;18865:33;;-1:-1:-1;;;;;18929:15:0;;;;;:24;;18717:52;;18929:24;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:31;19107:11;;;;-1:-1:-1;18929:31:0;-1:-1:-1;19107:11:0;19249:170;;19408:11;19397:6;19391:13;;19378:10;:26;19377:42;19249:170;;;19347:11;19308:34;19335:6;19308:26;:34::i;:::-;19299:6;:43;19293:50;;19280:10;:63;19279:79;19249:170;19242:177;;18694:1567;;;;;;;19548:13;19563:12;19579:24;19588:10;19601:1;19588:14;19579:8;:24::i;:::-;19741;;-1:-1:-1;;;19741:24:0;;19547:56;;-1:-1:-1;19547:56:0;-1:-1:-1;;;19708:1:0;19693:11;;;;19692:17;19690:20;;19675:12;;19690:20;;-1:-1:-1;;;;;19741:15:0;;;;;:24;;19547:56;;19741:24;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:31;19911:11;;;;-1:-1:-1;19741:31:0;-1:-1:-1;19911:11:0;20053:197;;20239:11;20228:6;20210:15;:24;20204:31;;20187:10;20200:1;20187:14;:48;20186:64;20053:197;;;20156:11;20145:6;20107:35;20135:6;20107:27;:35::i;:::-;:44;20101:51;;20084:10;20097:1;20084:14;:68;20083:84;20053:197;20046:204;;18694:1567;;;;;18344:1923;;;;;;;;:::o;1362:2580:10:-;1425:20;1457:15;1482:1;1475:4;:8;;;:57;;1526:4;1519:12;;1475:57;;;1502:4;1495:12;;1494:13;;1475:57;1457:75;-1:-1:-1;644:9:10;1550:28;;;1542:42;;;;;-1:-1:-1;;;1542:42:10;;;;;;;;;;;;-1:-1:-1;;;1542:42:10;;;;;;;;;;;;;;;1595:13;1621:3;1611:13;;:93;;-1:-1:-1;;;1611:93:10;;;1632:34;1611:93;1595:109;;;-1:-1:-1;1728:3:10;1718:13;;:18;1714:83;;1755:34;1747:42;1794:3;1746:51;1714:83;1821:3;1811:13;;:18;1807:83;;1848:34;1840:42;1887:3;1839:51;1807:83;1914:3;1904:13;;:18;1900:83;;1941:34;1933:42;1980:3;1932:51;1900:83;2007:4;1997:14;;:19;1993:84;;2035:34;2027:42;2074:3;2026:51;1993:84;2101:4;2091:14;;:19;2087:84;;2129:34;2121:42;2168:3;2120:51;2087:84;2195:4;2185:14;;:19;2181:84;;2223:34;2215:42;2262:3;2214:51;2181:84;2289:4;2279:14;;:19;2275:84;;2317:34;2309:42;2356:3;2308:51;2275:84;2383:5;2373:15;;:20;2369:85;;2412:34;2404:42;2451:3;2403:51;2369:85;2478:5;2468:15;;:20;2464:85;;2507:34;2499:42;2546:3;2498:51;2464:85;2573:5;2563:15;;:20;2559:85;;2602:34;2594:42;2641:3;2593:51;2559:85;2668:5;2658:15;;:20;2654:85;;2697:34;2689:42;2736:3;2688:51;2654:85;2763:6;2753:16;;:21;2749:86;;2793:34;2785:42;2832:3;2784:51;2749:86;2859:6;2849:16;;:21;2845:86;;2889:34;2881:42;2928:3;2880:51;2845:86;2955:6;2945:16;;:21;2941:86;;2985:34;2977:42;3024:3;2976:51;2941:86;3051:6;3041:16;;:21;3037:86;;3081:34;3073:42;3120:3;3072:51;3037:86;3147:7;3137:17;;:22;3133:86;;3178:33;3170:41;3216:3;3169:50;3133:86;3243:7;3233:17;;:22;3229:85;;3274:32;3266:40;3311:3;3265:49;3229:85;3338:7;3328:17;;:22;3324:83;;3369:30;3361:38;3404:3;3360:47;3324:83;3431:7;3421:17;;:22;3417:78;;3462:25;3454:33;3492:3;3453:42;3417:78;3517:1;3510:4;:8;;;3506:47;;;3548:5;-1:-1:-1;;3528:25:10;;;;;;3520:33;;3506:47;3912:7;3903:5;:17;:22;:30;;3932:1;3903:30;;;3928:1;3903:30;3886:48;;3896:2;3887:5;:11;;3886:48;3863:72;;1362:2580;;;;;:::o;1391:3239:9:-;1638:24;;;;-1:-1:-1;;;;;1797:41:9;;;;;;;;1863:20;;;;;;1894:1354;;1921:30;1954:61;1978:15;2002:7;1996:3;:13;1954:61;;2011:3;1954:15;:61::i;:::-;1921:94;;2040:10;:222;;2175:87;2205:19;2226:18;2246:9;2257:4;2175:29;:87::i;:::-;2040:222;;;2069:87;2099:18;2119:19;2140:9;2151:4;2069:29;:87::i;:::-;2029:233;;2306:8;2280:22;:34;2276:336;;2335:18;2316:37;;2276:336;;;2407:205;2468:19;2509:9;2540:22;2584:10;2407:39;:205::i;:::-;2388:224;;2276:336;1894:1354;;;;2655:10;:224;;2791:88;2821:19;2842:18;2862:9;2873:5;2791:29;:88::i;:::-;2655:224;;;2684:88;2714:18;2734:19;2755:9;2766:5;2684:29;:88::i;:::-;2643:236;;2926:9;2906:15;2905:16;;2897:38;2893:344;;2956:18;2937:37;;2893:344;;;3028:209;3090:19;3131:9;3171:15;3170:16;;3209:10;3028:40;:209::i;:::-;3009:228;;2893:344;-1:-1:-1;;;;;3269:38:9;;;;;;;3358:732;;;;3399:3;:14;;;;;3406:7;3399:14;:145;;3459:85;3489:16;3507:19;3528:9;3539:4;3459:29;:85::i;:::-;3399:145;;;3432:8;3399:145;3388:156;;3570:3;:15;;;;;3578:7;3577:8;3570:15;:148;;3632:86;3662:16;3680:19;3701:9;3712:5;3632:29;:86::i;:::-;3570:148;;;3604:9;3570:148;3558:160;;3358:732;;;3760:3;:14;;;;;3767:7;3760:14;:145;;3820:85;3850:19;3871:16;3889:9;3900:4;3820:29;:85::i;:::-;3760:145;;;3793:8;3760:145;3749:156;;3931:3;:15;;;;;3939:7;3938:8;3931:15;:148;;3993:86;4023:19;4044:16;4062:9;4073:5;3993:29;:86::i;:::-;3931:148;;;3965:9;3931:148;3919:160;;3358:732;4180:7;4179:8;:49;;;;;4212:15;4211:16;;4191:9;:37;4179:49;4175:117;;;4265:15;4264:16;;4244:37;;4175:117;4306:7;:49;;;;;4337:18;-1:-1:-1;;;;;4317:38:9;:16;-1:-1:-1;;;;;4317:38:9;;;4306:49;4302:322;;;4503:8;4484:15;4476:35;4464:47;;4302:322;;;4554:59;4580:8;4590:7;4554:59;;4605:7;4599:3;:13;4554:59;;:25;:59::i;:::-;4542:71;;4302:322;1391:3239;;;;;;;;;;;;;:::o;924:121:7:-;976:8;-1:-1:-1;;;1004:1:7;:10;996:19;;;;;;-1:-1:-1;1036:1:7;924:121::o;1573:120:6:-;1662:5;;;1657:16;;;;1629:8;1678:6;;;1657:28;1649:37;;;;;1276:120;1365:5;;;1360:16;;;;1332:8;1381:6;;;1360:28;1352:37;;;;;383:236:5;445:9;474:1;470;:5;;;466:147;;;523:1;-1:-1:-1;;;;;499:25:5;517:1;516:2;;504:1;:15;500:19;;;-1:-1:-1;;;;;499:25:5;;491:40;;;;;-1:-1:-1;;;491:40:5;;;;;;;;;;;;-1:-1:-1;;;491:40:5;;;;;;;;;;;;;;;466:147;;;594:1;-1:-1:-1;;;;;570:25:5;587:1;575;:14;571:18;;;-1:-1:-1;;;;;570:25:5;;;562:40;;;;;-1:-1:-1;;;562:40:5;;;;;;;;;;;;-1:-1:-1;;;562:40:5;;;;;;;;;;;;;;4361:4281:10;4434:10;824;-1:-1:-1;;;;;4563:30:10;;;;;;:63;;-1:-1:-1;1004:49:10;-1:-1:-1;;;;;4597:29:10;;;4563:63;4555:77;;;;;-1:-1:-1;;;4555:77:10;;;;;;;;;;;;-1:-1:-1;;;4555:77:10;;;;;;;;;;;;;;;-1:-1:-1;;;;;4683:2:10;4658:27;;;;-1:-1:-1;;;;;4788:41:10;;4785:1;4781:49;4878:9;;;-1:-1:-1;;;;;4945:25:10;;4942:1;4938:33;5019:9;;;5092:10;5086:17;;5083:1;5079:25;5152:9;;;5225:6;5219:13;;5216:1;5212:21;5281:9;;;5354:4;5348:11;;5345:1;5341:19;;;5408:9;;;5481:3;5475:10;;5472:1;5468:18;5534:9;;;5601:10;;;5598:1;5594:18;;;5660:9;;;;5720:10;;;4991;;5124;;;5253;;;5380;5506;;;5632;5750;5791:3;5784:10;;5780:79;;5816:3;5810;:9;5800:5;:20;;5796:24;;5780:79;;;5855:3;5849;:9;5839:5;:20;;5835:24;;5780:79;5958:9;;;5953:3;5949:19;;;5990:11;;;;6062:9;;;;6127;;6118:19;;;6159:11;;;6231:9;6296;;6287:19;;;6328:11;;;6400:9;6465;;6456:19;;;6497:11;;;6569:9;6634;;6625:19;;;6666:11;;;6738:9;6803;;6794:19;;;6835:11;;;6907:9;6972;;6963:19;;;7004:11;;;7076:9;7141;;7132:19;;;7173:11;;;7245:9;7310;;7301:19;;;7342:11;;;7414:9;7479;;7470:19;;;7511:11;;;7583:9;7648;;7639:19;;;7680:11;;;7752:9;7817;;7808:19;;;7849:11;;;7921:9;7986;;7977:19;;;8018:11;;;;8090:9;;;;8155;;8146:19;;;;;5958:9;-1:-1:-1;;5886:17:10;;5908:2;5885:25;6033:10;;;;;;;6023:21;6202:10;;;;;;;6192:21;;;;6371:10;;;;;;;6361:21;;;;6540:10;;;;;;;6530:21;;;;6709:10;;;;;;;6699:21;;;;6878:10;;;;;;;6868:21;;;;7047:10;;;;;;;7037:21;7216:10;;;;;;;7206:21;7385:10;;;;;;;7375:21;7554:10;;;;;;;7544:21;7723:10;;;;;;;7713:21;7892:10;;;;;;;7882:21;8061:10;;;;;;;8051:21;8230:10;;;;;;;8220:21;8292:24;8284:32;;-1:-1:-1;;8368:53:10;;5900:3;8367:62;;;;8478:39;8462:55;;8461:64;;8544:17;;;;;;;;;:91;;8604:12;-1:-1:-1;;;;;8574:42:10;:26;8593:6;8574:18;:26::i;:::-;-1:-1:-1;;;;;8574:42:10;;;:61;;8628:7;8574:61;;;8619:6;8574:61;8544:91;;;8564:7;8544:91;8537:98;4361:4281;-1:-1:-1;;;;;;;;;4361:4281:10:o;17455:169:0:-;17539:20;17606:3;17579;:23;;17578:31;17612:5;17578:39;17571:46;;17455:169;;;:::o;399:3007:12:-;521:12;569:7;553;563:2;553:12;:23;;545:50;;;;;-1:-1:-1;;;545:50:12;;;;;;;;;;;;-1:-1:-1;;;545:50:12;;;;;;;;;;;;;;;633:6;622:7;613:6;:16;:26;;605:53;;;;;-1:-1:-1;;;605:53:12;;;;;;;;;;;;-1:-1:-1;;;605:53:12;;;;;;;;;;;;;;;702:7;693:6;:16;676:6;:13;:33;;668:63;;;;;-1:-1:-1;;;668:63:12;;;;;;;;;;;;-1:-1:-1;;;668:63:12;;;;;;;;;;;;;;;742:22;805:15;;837:2099;;;;3089:4;3083:11;3070:24;;3287:1;3276:9;3269:20;3339:4;3328:9;3324:20;3318:4;3311:34;798:2565;;837:2099;1031:4;1025:11;1012:24;;1726:2;1717:7;1713:16;2128:9;2121:17;2115:4;2111:28;2099:9;2088;2084:25;2080:60;2180:7;2176:2;2172:16;2448:6;2434:9;2427:17;2421:4;2417:28;2405:9;2397:6;2393:22;2389:57;2385:70;2210:461;2485:3;2481:2;2478:11;2210:461;;;2639:9;;2628:21;;2530:4;2522:13;;;;2566;2210:461;;;-1:-1:-1;;2693:26:12;;;2913:2;2896:11;-1:-1:-1;;2892:25:12;2886:4;2879:39;-1:-1:-1;798:2565:12;-1:-1:-1;3390:9:12;-1:-1:-1;399:3007:12;;;;;;:::o;20603:160:0:-;20710:9;;20718:1;20710:9;;;;20752:3;20745:10;;;;20603:160::o;671:731:2:-;733:7;764:1;760;:5;752:14;;;;;;-1:-1:-1;;;781:1:2;:40;777:102;;843:3;837:9;;;;860:8;777:102;897:19;892:1;:24;888:84;;938:2;932:8;;;;954:7;888:84;990:11;985:1;:16;981:76;;1023:2;1017:8;;;;1039:7;981:76;1075:7;1070:1;:12;1066:72;;1104:2;1098:8;;;;1120:7;1066:72;1156:5;1151:1;:10;1147:68;;1183:1;1177:7;;;;1198:6;1147:68;1233:4;1228:1;:9;1224:67;;1259:1;1253:7;;;;1274:6;1224:67;1309:3;1304:1;:8;1300:66;;1334:1;1328:7;;;;1349:6;1300:66;1384:3;1379:1;:8;1375:20;;1394:1;1389:6;671:731;;;:::o;1893:894::-;1956:7;1987:1;1983;:5;1975:14;;;;;;-1:-1:-1;2004:3:2;-1:-1:-1;;;;;2021:21:2;;:25;2017:104;;-1:-1:-1;;2062:8:2;2017:104;;;2107:3;2101:9;;;;;2017:104;-1:-1:-1;;;;;2134:20:2;;:24;2130:101;;-1:-1:-1;;2174:7:2;2130:101;;;2218:2;2212:8;;;;;2130:101;2248:16;2244:20;;:24;2240:101;;-1:-1:-1;;2284:7:2;2240:101;;;2328:2;2322:8;;;;;2240:101;2358:16;2354:20;;:24;2350:101;;-1:-1:-1;;2394:7:2;2350:101;;;2438:2;2432:8;;;;;2350:101;2468:15;2464:19;;:23;2460:98;;-1:-1:-1;;2503:6:2;2460:98;;;2546:1;2540:7;;;;;2460:98;2575:3;2571:7;;:11;2567:86;;-1:-1:-1;;2598:6:2;2567:86;;;2641:1;2635:7;;;;;2567:86;2670:3;2666:7;;:11;2662:86;;-1:-1:-1;;2693:6:2;2662:86;;;2736:1;2730:7;;;;;2662:86;2765:3;2761:7;;:11;2757:23;;-1:-1:-1;;2774:6:2;1893:894;;;:::o;749:3776:4:-;861:14;;;-1:-1:-1;;1368:1:4;1365;1358:20;1400:9;;;;-1:-1:-1;1451:13:4;;;1435:14;;;;1431:34;;-1:-1:-1;1547:10:4;1543:179;;1595:1;1581:11;:15;1573:24;;;;;;-1:-1:-1;1648:23:4;;;;-1:-1:-1;1698:13:4;;1543:179;1849:5;1835:11;:19;1827:28;;;;;;2132:17;2208:11;2205:1;2202;2195:25;2560:12;2575;;;:26;;2695:22;;;;;3498:1;3479;:15;;3478:21;;3725:17;;;3721:21;;3714:28;3783:17;;;3779:21;;3772:28;3842:17;;;3838:21;;3831:28;3901:17;;;3897:21;;3890:28;3960:17;;;3956:21;;3949:28;4020:17;;;4016:21;;;4009:28;3067:12;;;;3063:23;;;3088:1;3059:31;2337:20;;;2326:32;;;3118:12;;;;2380:21;;;;2823:16;;;;3109:21;;;;4484:11;;;;;-1:-1:-1;;749:3776:4;;;;;:::o;8727:532:8:-;8892:15;8939:13;-1:-1:-1;;;;;8923:29:8;:13;-1:-1:-1;;;;;8923:29:8;;8919:98;;;8988:13;;9003;8919:98;9047:7;:205;;9177:75;9193:9;-1:-1:-1;;;;;9177:75:8;9220:13;9204;:29;-1:-1:-1;;;;;9177:75:8;-1:-1:-1;;;9177:15:8;:75::i;:::-;9047:205;;;9073:85;9099:9;-1:-1:-1;;;;;9073:85:8;9126:13;9110;:29;-1:-1:-1;;;;;9073:85:8;-1:-1:-1;;;9073:25:8;:85::i;:::-;9028:224;8727:532;-1:-1:-1;;;;;8727:532:8:o;7493:779::-;7658:15;7705:13;-1:-1:-1;;;;;7689:29:8;:13;-1:-1:-1;;;;;7689:29:8;;7685:98;;;7754:13;;7769;7685:98;-1:-1:-1;;;;;;;309:2:3;7815:45:8;;;;-1:-1:-1;;;;;7891:29:8;;;7870:50;;;7939:17;;7931:26;;;;;;7987:7;:278;;8252:13;-1:-1:-1;;;;;8195:70:8;:54;8211:10;8223;8235:13;-1:-1:-1;;;;;8195:54:8;:15;:54::i;:::-;:70;;;;;;7987:278;;;8013:163;8059:64;8085:10;8097;8109:13;-1:-1:-1;;;;;8059:64:8;:25;:64::i;:::-;8145:13;-1:-1:-1;;;;;8013:163:8;:24;:163::i;:::-;7968:297;7493:779;-1:-1:-1;;;;;;;7493:779:8:o;5299:550::-;5467:16;5514:1;5503:8;-1:-1:-1;;;;;5503:12:8;;5495:21;;;;;;5546:1;5534:9;-1:-1:-1;;;;;5534:13:8;;5526:22;;;;;;5644:10;:198;;5766:76;5806:8;5816:9;5827:8;5837:4;5766:39;:76::i;5644:198::-;5673:74;5711:8;5721:9;5732:8;5742:4;5673:37;:74::i;6395:550::-;6565:16;6612:1;6601:8;-1:-1:-1;;;;;6601:12:8;;6593:21;;;;;;6644:1;6632:9;-1:-1:-1;;;;;6632:13:8;;6624:22;;;;;;6736:10;:202;;6862:76;6900:8;6910:9;6921;6932:5;6862:37;:76::i;6736:202::-;6765:78;6805:8;6815:9;6826;6837:5;6765:39;:78::i;4807:315:4:-;4929:14;4964:25;4971:1;4974;4977:11;4964:6;:25::i;:::-;4955:34;;5031:1;5016:11;5003:25;;;;;5013:1;5010;5003:25;:29;4999:117;;;-1:-1:-1;;5056:6:4;:26;5048:35;;;;;;5097:8;;4807:315;;;;;:::o;492:165:11:-;613:9;;;627;;624:16;;609:32;;590:61::o;3597:1153:8:-;3770:7;3947:3;3943:801;;;3966:16;-1:-1:-1;;;;;4023:27:8;;;:180;;4151:52;4167:6;-1:-1:-1;;;4193:9:8;-1:-1:-1;;;;;4151:52:8;:15;:52::i;:::-;4023:180;;;-1:-1:-1;;;;;4077:47:8;;309:2:3;4078:33:8;;;4077:47;;;;;;4023:180;3966:255;-1:-1:-1;4243:43:8;:31;-1:-1:-1;;;;;4243:17:8;;3966:255;4243:21;:31::i;:::-;:41;:43::i;:::-;4236:50;;;;;3943:801;4317:16;-1:-1:-1;;;;;4374:27:8;;;:213;;4525:62;4551:6;-1:-1:-1;;;4577:9:8;-1:-1:-1;;;;;4525:62:8;:25;:62::i;:::-;4374:213;;;4428:70;309:2:3;4453:33:8;;;-1:-1:-1;;;;;4428:70:8;;:24;:70::i;:::-;4317:288;;4639:8;4628;-1:-1:-1;;;;;4628:19:8;;4620:28;;;;;;-1:-1:-1;;;;;4713:19:8;;;;-1:-1:-1;4698:35:8;;1405:1366;1576:7;1711:11;1707:32;;-1:-1:-1;1731:8:8;1724:15;;1707:32;-1:-1:-1;;;;;;;309:2:3;1770:45:8;;;;1826:939;;;;-1:-1:-1;;;;;1882:50:8;;1893:17;;;;1914:6;1893:17;1914:6;1882:38;;;;;:50;1878:323;;;1974:20;;;2016:25;;;2012:174;;2125:60;2151:10;2163:8;-1:-1:-1;;;;;2125:60:8;2173:11;2125:25;:60::i;:::-;2110:76;;;;;;;2012:174;1878:323;;2230:73;2255:10;2267:35;2295:6;2281:8;-1:-1:-1;;;;;2268:21:8;:10;:21;;;;;;;2267:27;:35::i;:::-;2230:24;:73::i;:::-;2215:89;;;;;;1826:939;-1:-1:-1;;;;;2530:50:8;;2541:17;;;;2562:6;2541:17;2562:6;2530:38;;;;;:50;:74;;;;;2597:7;2584:10;:20;2530:74;2522:83;;;;;;2641:20;;;2682:72;:60;2641:10;-1:-1:-1;;;;;2682:60:8;;2641:20;2682:25;:60::i;435:111:6:-;527:5;;;522:16;;;;514:25;;;;;357:111:7;459:1;-1:-1:-1;;;;;439:21:7;;;;431:30;;;;;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;24:622:14:-;;145:80;160:64;217:6;160:64;:::i;:::-;145:80;:::i;:::-;136:89;;245:5;273:6;266:5;259:21;299:4;292:5;288:16;281:23;;324:6;374:3;366:4;358:6;354:17;349:3;345:27;342:36;339:2;;;391:1;388;381:12;339:2;419:1;404:236;429:6;426:1;423:13;404:236;;;496:3;524:37;557:3;545:10;524:37;:::i;:::-;512:50;;-1:-1:-1;591:4:14;582:14;;;;616;;;;;451:1;444:9;404:236;;;408:14;126:520;;;;;;;:::o;652:342::-;;754:64;769:48;810:6;769:48;:::i;754:64::-;745:73;;841:6;834:5;827:21;879:4;872:5;868:16;917:3;908:6;903:3;899:16;896:25;893:2;;;934:1;931;924:12;893:2;947:41;981:6;976:3;971;947:41;:::i;:::-;735:259;;;;;;:::o;1017:303::-;;1137:3;1130:4;1122:6;1118:17;1114:27;1104:2;;1155:1;1152;1145:12;1104:2;1195:6;1182:20;1220:94;1310:3;1302:6;1295:4;1287:6;1283:17;1220:94;:::i;1326:137::-;1405:13;;1427:30;1405:13;1427:30;:::i;1482:271::-;;1586:3;1579:4;1571:6;1567:17;1563:27;1553:2;;1604:1;1601;1594:12;1553:2;1644:6;1631:20;1669:78;1743:3;1735:6;1728:4;1720:6;1716:17;1669:78;:::i;1759:191::-;1856:20;;1885:59;1856:20;1885:59;:::i;1956:189::-;2061:13;;2083:56;2061:13;2083:56;:::i;2151:141::-;2232:13;;2254:32;2232:13;2254:32;:::i;2298:139::-;2378:13;;2400:31;2378:13;2400:31;:::i;2443:139::-;2523:13;;2545:31;2523:13;2545:31;:::i;2588:143::-;2670:13;;2692:33;2670:13;2692:33;:::i;2737:143::-;2819:13;;2841:33;2819:13;2841:33;:::i;2886:141::-;2967:13;;2989:32;2967:13;2989:32;:::i;3033:141::-;3114:13;;3136:32;3114:13;3136:32;:::i;3180:139::-;3251:20;;3280:33;3251:20;3280:33;:::i;3325:143::-;3407:13;;3429:33;3407:13;3429:33;:::i;3474:141::-;3555:13;;3577:32;3555:13;3577:32;:::i;3621:139::-;3701:13;;3723:31;3701:13;3723:31;:::i;3766:858::-;;;;3968:2;3956:9;3947:7;3943:23;3939:32;3936:2;;;3984:1;3981;3974:12;3936:2;4027:1;4052:79;4123:7;4103:9;4052:79;:::i;:::-;4042:89;;3998:143;4208:2;4197:9;4193:18;4180:32;-1:-1:-1;;;;;4231:6:14;4228:30;4225:2;;;4271:1;4268;4261:12;4225:2;4299:62;4353:7;4344:6;4333:9;4329:22;4299:62;:::i;:::-;4289:72;;4151:220;4438:2;4427:9;4423:18;4410:32;-1:-1:-1;;;;;4461:6:14;4458:30;4455:2;;;4501:1;4498;4491:12;4455:2;4529:78;4599:7;4590:6;4579:9;4575:22;4529:78;:::i;:::-;4519:88;;4381:236;3926:698;;;;;:::o;4630:330::-;;4772:2;4760:9;4751:7;4747:23;4743:32;4740:2;;;4788:1;4785;4778:12;4740:2;4831:1;4856:87;4935:7;4915:9;4856:87;:::i;4966:280::-;;5083:2;5071:9;5062:7;5058:23;5054:32;5051:2;;;5099:1;5096;5089:12;5051:2;5142:1;5167:62;5221:7;5201:9;5167:62;:::i;5252:284::-;;5371:2;5359:9;5350:7;5346:23;5342:32;5339:2;;;5387:1;5384;5377:12;5339:2;5430:1;5455:64;5511:7;5491:9;5455:64;:::i;5542:1367::-;;;;;;;;;5773:3;5761:9;5752:7;5748:23;5744:33;5741:2;;;5790:1;5787;5780:12;5741:2;5833:1;5858:64;5914:7;5894:9;5858:64;:::i;:::-;5848:74;;5804:128;5971:2;5997:63;6052:7;6043:6;6032:9;6028:22;5997:63;:::i;:::-;5987:73;;5942:128;6109:2;6135:64;6191:7;6182:6;6171:9;6167:22;6135:64;:::i;:::-;6125:74;;6080:129;6248:2;6274:64;6330:7;6321:6;6310:9;6306:22;6274:64;:::i;:::-;6264:74;;6219:129;6387:3;6414:62;6468:7;6459:6;6448:9;6444:22;6414:62;:::i;:::-;6404:72;;6358:128;6525:3;6552:64;6608:7;6599:6;6588:9;6584:22;6552:64;:::i;:::-;6542:74;;6496:130;6665:3;6692:63;6747:7;6738:6;6727:9;6723:22;6692:63;:::i;:::-;6682:73;;6636:129;6804:3;6831:61;6884:7;6875:6;6864:9;6860:22;6831:61;:::i;:::-;6821:71;;6775:127;5731:1178;;;;;;;;;;;:::o;6915:1204::-;;;;;;;;7126:3;7114:9;7105:7;7101:23;7097:33;7094:2;;;7143:1;7140;7133:12;7094:2;7186:1;7211:64;7267:7;7247:9;7211:64;:::i;:::-;7201:74;;7157:128;7324:2;7350:62;7404:7;7395:6;7384:9;7380:22;7350:62;:::i;:::-;7340:72;;7295:127;7461:2;7487:63;7542:7;7533:6;7522:9;7518:22;7487:63;:::i;:::-;7477:73;;7432:128;7599:2;7625:63;7680:7;7671:6;7660:9;7656:22;7625:63;:::i;:::-;7615:73;;7570:128;7737:3;7764:63;7819:7;7810:6;7799:9;7795:22;7764:63;:::i;:::-;7754:73;;7708:129;7876:3;7903:62;7957:7;7948:6;7937:9;7933:22;7903:62;:::i;:::-;7893:72;;7847:128;8014:3;8041:61;8094:7;8085:6;8074:9;8070:22;8041:61;:::i;:::-;8031:71;;7985:127;7084:1035;;;;;;;;;;:::o;8125:282::-;;8243:2;8231:9;8222:7;8218:23;8214:32;8211:2;;;8259:1;8256;8249:12;8211:2;8302:1;8327:63;8382:7;8362:9;8327:63;:::i;8413:284::-;;8532:2;8520:9;8511:7;8507:23;8503:32;8500:2;;;8548:1;8545;8538:12;8500:2;8591:1;8616:64;8672:7;8652:9;8616:64;:::i;8703:179::-;;8793:46;8835:3;8827:6;8793:46;:::i;:::-;-1:-1:-1;;8871:4:14;8862:14;;8783:99::o;8888:118::-;8975:24;8993:5;8975:24;:::i;:::-;8970:3;8963:37;8953:53;;:::o;9042:732::-;;9190:54;9238:5;9190:54;:::i;:::-;9260:86;9339:6;9334:3;9260:86;:::i;:::-;9253:93;;9370:56;9420:5;9370:56;:::i;:::-;9449:7;9480:1;9465:284;9490:6;9487:1;9484:13;9465:284;;;9566:6;9560:13;9593:63;9652:3;9637:13;9593:63;:::i;:::-;9586:70;;9679:60;9732:6;9679:60;:::i;:::-;9669:70;-1:-1:-1;;9512:1:14;9505:9;9465:284;;;-1:-1:-1;9765:3:14;;9166:608;-1:-1:-1;;;;;9166:608:14:o;9780:112::-;9863:22;9879:5;9863:22;:::i;9898:112::-;9981:22;9997:5;9981:22;:::i;10016:395::-;;10179:67;10243:2;10238:3;10179:67;:::i;:::-;10276:34;10256:55;;10342:33;10337:2;10328:12;;10321:55;10402:2;10393:12;;10162:249;-1:-1:-1;;10162:249:14:o;10417:396::-;;10580:67;10644:2;10639:3;10580:67;:::i;:::-;10677:34;10657:55;;10743:34;10738:2;10729:12;;10722:56;10804:2;10795:12;;10563:250;-1:-1:-1;;10563:250:14:o;10819:115::-;10904:23;10921:5;10904:23;:::i;10940:108::-;11017:24;11035:5;11017:24;:::i;11054:438::-;11239:2;11224:18;;11252:71;11228:9;11296:6;11252:71;:::i;:::-;11333:72;11401:2;11390:9;11386:18;11377:6;11333:72;:::i;:::-;11415:70;11481:2;11470:9;11466:18;11457:6;11415:70;:::i;11498:634::-;11757:2;11770:47;;;11742:18;;11834:108;11742:18;11928:6;11834:108;:::i;:::-;11826:116;;11989:9;11983:4;11979:20;11974:2;11963:9;11959:18;11952:48;12017:108;12120:4;12111:6;12017:108;:::i;12138:214::-;12265:2;12250:18;;12278:67;12254:9;12318:6;12278:67;:::i;12358:214::-;12485:2;12470:18;;12498:67;12474:9;12538:6;12498:67;:::i;12578:419::-;12782:2;12795:47;;;12767:18;;12859:131;12767:18;12859:131;:::i;13003:419::-;13207:2;13220:47;;;13192:18;;13284:131;13192:18;13284:131;:::i;13428:278::-;13494:2;13488:9;13524:17;;;-1:-1:-1;;;;;13592:34:14;;13628:22;;;13589:62;13586:2;;;13654:13;;:::i;:::-;13685:2;13678:22;13468:238;;-1:-1:-1;13468:238:14:o;13712:306::-;;-1:-1:-1;;;;;13871:6:14;13868:30;13865:2;;;13901:13;;:::i;:::-;-1:-1:-1;13946:4:14;13934:17;;;13996:15;;13794:224::o;14024:326::-;;-1:-1:-1;;;;;14167:6:14;14164:30;14161:2;;;14197:13;;:::i;:::-;-1:-1:-1;14338:4:14;14277;14254:17;;;;-1:-1:-1;;14250:33:14;14328:15;;14090:260::o;14356:132::-;14476:4;14467:14;;14428:60::o;14494:114::-;14589:12;;14568:40::o;14733:184::-;14854:19;;;14906:4;14897:14;;14844:73::o;15098:96::-;;15164:24;15182:5;15164:24;:::i;15200:90::-;15270:13;15263:21;;15242:48::o;15296:122::-;;15388:24;15406:5;15388:24;:::i;15549:92::-;15625:2;15614:21;;15593:48::o;15647:90::-;15722:1;15711:20;;15690:47::o;15743:90::-;15818:1;15807:20;;15786:47::o;15839:90::-;15914:1;15903:20;;15882:47::o;15935:118::-;-1:-1:-1;;;;;16001:46:14;;15980:73::o;16059:89::-;16135:6;16124:18;;16103:45::o;16154:126::-;-1:-1:-1;;;;;16220:54:14;;16199:81::o;16286:91::-;16362:8;16351:20;;16330:47::o;16383:77::-;16449:5;16428:32::o;16466:93::-;16542:10;16531:22;;16510:49::o;16565:86::-;16640:4;16629:16;;16608:43::o;16657:154::-;16741:6;16736:3;16731;16718:30;-1:-1:-1;16803:1:14;16785:16;;16778:27;16708:103::o;16817:48::-;16850:9;16871:116;16941:21;16956:5;16941:21;:::i;:::-;16934:5;16931:32;16921:2;;16977:1;16974;16967:12;16921:2;16911:76;:::o;16993:174::-;17092:50;17136:5;17092:50;:::i;17347:120::-;17419:23;17436:5;17419:23;:::i;17473:118::-;17544:22;17560:5;17544:22;:::i;17597:118::-;17668:22;17684:5;17668:22;:::i;17721:122::-;17794:24;17812:5;17794:24;:::i;17849:120::-;17921:23;17938:5;17921:23;:::i;17975:122::-;18048:24;18066:5;18048:24;:::i;18103:120::-;18175:23;18192:5;18175:23;:::i;18229:122::-;18302:24;18320:5;18302:24;:::i;18357:120::-;18429:23;18446:5;18429:23;:::i;18483:118::-;18554:22;18570:5;18554:22;:::i"
            }
        }
    },
    "sourceTreeHashHex": "0x87c4c219e305fd5fa85d56a3e6119b41cb8a9d7e8fc28dfe75113399f105da1c",
    "sources": {
        "./UniswapV3MultiQuoter.sol": {
            "id": 0,
            "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n  Copyright 2021 ZeroEx Intl.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\npragma solidity ^0.7;\npragma experimental ABIEncoderV2;\n\nimport \"@uniswap/v3-core/contracts/libraries/TickMath.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/SwapMath.sol\";\nimport \"@uniswap/v3-periphery/contracts/libraries/Path.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/LiquidityMath.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/BitMath.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/SafeCast.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol\";\n\nimport \"./interfaces/IUniswapV3.sol\";\n\n/// @title Provides quotes for multiple swap amounts\n/// @notice Allows getting the expected amount out or amount in for multiple given swap amounts without executing the swap\ncontract UniswapV3MultiQuoter is IUniswapV3MultiQuoter {\n    // TODO: both quoteExactMultiInput and quoteExactMultiOutput revert at the end of the quoting logic\n    // and return results encodied into a revert reason. The revert should be removed and replaced with\n    // a normal return statement whenever UniswapV3Sampler stops having the two pool filtering logic.\n    // The two pool filtering logic causes pool's storage slots to be warmed up, causing gas estimates\n    // to be significantly below the gas used during settlement. Additionally, per the following EIP\n    // this revert logic might not clear warm storage slots in the future: https://eips.ethereum.org/EIPS/eip-3978\n    using Path for bytes;\n    using SafeCast for uint256;\n    using LowGasSafeMath for int256;\n\n    // the top level state of the multiswap, the results are transient.\n    struct SwapState {\n        // the amount remaining to be swapped in/out of the input/output asset\n        int256 amountSpecifiedRemaining;\n        // the amount already swapped out/in of the output/input asset\n        int256 amountCalculated;\n        // current sqrt(price)\n        uint160 sqrtPriceX96;\n        // the tick associated with the current price\n        int24 tick;\n        // the current liquidity in range\n        uint128 liquidity;\n        // the current quote amount we are querying liquidity for\n        uint256 amountsIndex;\n        // the current aggregate gas estimate for multi swap\n        uint256 gasAggregate;\n    }\n\n    // the intermediate calculations for each tick and quote amount\n    struct StepComputations {\n        // the price at the beginning of the step\n        uint160 sqrtPriceStartX96;\n        // the next tick to swap to from the current tick in the swap direction\n        int24 tickNext;\n        // whether tickNext is initialized or not\n        bool initialized;\n        // sqrt(price) for the next tick (1/0)\n        uint160 sqrtPriceNextX96;\n        // how much is being swapped in in this step\n        uint256 amountIn;\n        // how much is being swapped out\n        uint256 amountOut;\n        // how much fee is being paid in\n        uint256 feeAmount;\n        // how much gas was left before the current step\n        uint256 gasBefore;\n    }\n\n    // the result of multiswap\n    struct MultiSwapResult {\n        // the gas estimate for each of swap amounts\n        uint256[] gasEstimates;\n        // the token0 delta for each swap amount, positive indicates sent and negative indicates receipt\n        int256[] amounts0;\n        // the token1 delta for each swap amount, positive indicates sent and negative indicates receipt\n        int256[] amounts1;\n    }\n\n    /// @notice Quotes amounts out for a set of exact input swaps and provides results encoded into a revert reason\n    /// @param factory The factory contract managing UniswapV3 pools\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountsIn The amounts in of the first token to swap\n    /// @dev This function reverts at the end of the quoting logic and encodes (uint256[] amountsOut, uint256[] gasEstimates)\n    /// into the revert reason. See additional documentation below.\n    function quoteExactMultiInput(\n        IUniswapV3Factory factory,\n        bytes memory path,\n        uint256[] memory amountsIn\n    ) public view override {\n        for (uint256 i = 0; i < amountsIn.length - 1; ++i) {\n            require(\n                amountsIn[i] <= amountsIn[i + 1],\n                \"UniswapV3MultiQuoter/amountsIn must be monotonically increasing\"\n            );\n        }\n        uint256[] memory gasEstimates = new uint256[](amountsIn.length);\n\n        while (true) {\n            (address tokenIn, address tokenOut, uint24 fee) = path.decodeFirstPool();\n            bool zeroForOne = tokenIn < tokenOut;\n            IUniswapV3Pool pool = factory.getPool(tokenIn, tokenOut, fee);\n\n            // multiswap only accepts int256[] for input amounts\n            int256[] memory amounts = new int256[](amountsIn.length);\n            for (uint256 i = 0; i < amountsIn.length; ++i) {\n                amounts[i] = int256(amountsIn[i]);\n            }\n\n            MultiSwapResult memory result = multiswap(\n                pool,\n                zeroForOne,\n                amounts,\n                zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1\n            );\n\n            for (uint256 i = 0; i < amountsIn.length; ++i) {\n                amountsIn[i] = zeroForOne ? uint256(-result.amounts1[i]) : uint256(-result.amounts0[i]);\n                gasEstimates[i] += result.gasEstimates[i];\n            }\n\n            // decide whether to continue or terminate\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n            } else {\n                // quote results must be encoded into a revert because otherwise subsequent calls\n                // to UniswapV3MultiQuoter result in multiswap hitting pool storage slots that are\n                // already warm. This results in very inaccurate gas estimates when estimating gas\n                // usage for settlement.\n                bytes memory revertResult = abi.encodeWithSignature(\n                    \"result(uint256[],uint256[])\",\n                    amountsIn,\n                    gasEstimates\n                );\n                assembly {\n                    revert(add(revertResult, 0x20), mload(revertResult))\n                }\n            }\n        }\n    }\n\n    /// @notice Quotes amounts in a set of exact output swaps and provides results encoded into a revert reason\n    /// @param factory The factory contract managing UniswapV3 pools\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountsOut The amounts out of the last token to receive\n    /// @dev This function reverts at the end of the quoting logic and encodes (uint256[] amountsIn, uint256[] gasEstimates)\n    /// into the revert reason. See additional documentation below.\n    function quoteExactMultiOutput(\n        IUniswapV3Factory factory,\n        bytes memory path,\n        uint256[] memory amountsOut\n    ) public view override {\n        uint256[] memory amountsIn = new uint256[](amountsOut.length);\n        uint256[] memory gasEstimates = new uint256[](amountsOut.length);\n\n        for (uint256 i = 0; i < amountsOut.length - 1; ++i) {\n            require(\n                amountsOut[i] <= amountsOut[i + 1],\n                \"UniswapV3MultiQuoter/amountsOut must be monotonically increasing\"\n            );\n        }\n\n        uint256 nextAmountsLength = amountsOut.length;\n        while (true) {\n            (address tokenOut, address tokenIn, uint24 fee) = path.decodeFirstPool();\n            bool zeroForOne = tokenIn < tokenOut;\n            IUniswapV3Pool pool = factory.getPool(tokenIn, tokenOut, fee);\n\n            // multiswap only accepts int256[] for output amounts\n            int256[] memory amounts = new int256[](nextAmountsLength);\n            for (uint256 i = 0; i < nextAmountsLength; ++i) {\n                amounts[i] = -int256(amountsOut[i]);\n            }\n\n            MultiSwapResult memory result = multiswap(\n                pool,\n                zeroForOne,\n                amounts,\n                zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1\n            );\n\n            for (uint256 i = 0; i < nextAmountsLength; ++i) {\n                uint256 amountReceived = zeroForOne ? uint256(-result.amounts1[i]) : uint256(-result.amounts0[i]);\n                if (amountReceived != amountsOut[i]) {\n                    // for exact output swaps we need to check whether we would receive the full amount due to\n                    // multiswap behavior when hitting the limit\n                    nextAmountsLength = i;\n                    break;\n                } else {\n                    // populate amountsOut for the next pool\n                    amountsOut[i] = zeroForOne ? uint256(result.amounts0[i]) : uint256(result.amounts1[i]);\n                    gasEstimates[i] += result.gasEstimates[i];\n                }\n            }\n\n            if (nextAmountsLength == 0 || !path.hasMultiplePools()) {\n                for (uint256 i = 0; i < nextAmountsLength; ++i) {\n                    amountsIn[i] = amountsOut[i];\n                }\n\n                // quote results must be encoded into a revert because otherwise subsequent calls\n                // to UniswapV3MultiQuoter result in multiswap hitting pool storage slots that are\n                // already warm. This results in very inaccurate gas estimates when estimating gas\n                // usage for settlement.\n                bytes memory revertResult = abi.encodeWithSignature(\n                    \"result(uint256[],uint256[])\",\n                    amountsIn,\n                    gasEstimates\n                );\n                assembly {\n                    revert(add(revertResult, 0x20), mload(revertResult))\n                }\n            }\n\n            path = path.skipToken();\n        }\n    }\n\n    /// @notice swap multiple amounts of token0 for token1 or token1 for token1\n    /// @dev The results of multiswap includes slight rounding issues resulting from rounding up/rounding down in SqrtPriceMath library. Additionally,\n    /// it should be noted that multiswap requires a monotonically increasing list of amounts for exact inputs and monotonically decreasing list of\n    /// amounts for exact outputs.\n    /// @param pool The UniswapV3 pool to simulate each of the swap amounts for\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amounts The amounts of the swaps, positive values indicate exactInput and negative values indicate exact output\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @return result The results of the swap as a MultiSwapResult struct with gas used, token0 and token1 deltas\n    function multiswap(\n        IUniswapV3Pool pool,\n        bool zeroForOne,\n        int256[] memory amounts,\n        uint160 sqrtPriceLimitX96\n    ) private view returns (MultiSwapResult memory result) {\n        result.gasEstimates = new uint256[](amounts.length);\n        result.amounts0 = new int256[](amounts.length);\n        result.amounts1 = new int256[](amounts.length);\n\n        (uint160 sqrtPriceX96Start, int24 tickStart, , , , , ) = pool.slot0();\n        int24 tickSpacing = pool.tickSpacing();\n        uint24 fee = pool.fee();\n\n        bool exactInput = amounts[0] > 0;\n\n        SwapState memory state = SwapState({\n            amountSpecifiedRemaining: amounts[0],\n            amountCalculated: 0,\n            sqrtPriceX96: sqrtPriceX96Start,\n            tick: tickStart,\n            liquidity: pool.liquidity(),\n            amountsIndex: 0,\n            gasAggregate: 0\n        });\n\n        // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\n        while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != sqrtPriceLimitX96) {\n            StepComputations memory step;\n            step.gasBefore = gasleft();\n\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n            (step.tickNext, step.initialized) = nextInitializedTickWithinOneWord(\n                pool,\n                state.tick,\n                tickSpacing,\n                zeroForOne\n            );\n\n            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\n            if (step.tickNext < TickMath.MIN_TICK) {\n                step.tickNext = TickMath.MIN_TICK;\n            } else if (step.tickNext > TickMath.MAX_TICK) {\n                step.tickNext = TickMath.MAX_TICK;\n            }\n\n            // get the price for the next tick\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\n\n            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\n            (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(\n                state.sqrtPriceX96,\n                (zeroForOne ? step.sqrtPriceNextX96 < sqrtPriceLimitX96 : step.sqrtPriceNextX96 > sqrtPriceLimitX96)\n                    ? sqrtPriceLimitX96\n                    : step.sqrtPriceNextX96,\n                state.liquidity,\n                state.amountSpecifiedRemaining,\n                fee\n            );\n\n            if (exactInput) {\n                state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();\n                state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());\n            } else {\n                state.amountSpecifiedRemaining += step.amountOut.toInt256();\n                state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());\n            }\n\n            // shift tick if we reached the next price\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\n                // if the tick is initialized, run the tick transition\n                if (step.initialized) {\n                    (, int128 liquidityNet, , , , , , ) = pool.ticks(step.tickNext);\n\n                    // if we're moving leftward, we interpret liquidityNet as the opposite sign\n                    // safe because liquidityNet cannot be type(int128).min\n                    if (zeroForOne) liquidityNet = -liquidityNet;\n\n                    state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);\n                }\n\n                state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;\n                state.gasAggregate += step.gasBefore - gasleft();\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n                // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\n            }\n\n            if (state.amountSpecifiedRemaining == 0) {\n                (result.amounts0[state.amountsIndex], result.amounts1[state.amountsIndex]) = zeroForOne == exactInput\n                    ? (amounts[state.amountsIndex], state.amountCalculated)\n                    : (state.amountCalculated, amounts[state.amountsIndex]);\n\n                if (state.sqrtPriceX96 != step.sqrtPriceNextX96) {\n                    result.gasEstimates[state.amountsIndex] = scaleMultiswapGasEstimate(\n                        state.gasAggregate + (step.gasBefore - gasleft())\n                    );\n                } else {\n                    // we are moving to the next tick\n                    result.gasEstimates[state.amountsIndex] = scaleMultiswapGasEstimate(state.gasAggregate);\n                }\n\n                if (state.amountsIndex == amounts.length - 1) {\n                    return (result);\n                }\n\n                state.amountsIndex += 1;\n                state.amountSpecifiedRemaining = amounts[state.amountsIndex].sub(amounts[state.amountsIndex - 1]);\n            }\n        }\n\n        for (uint256 i = state.amountsIndex; i < amounts.length; ++i) {\n            (result.amounts0[i], result.amounts1[i]) = zeroForOne == exactInput\n                ? (amounts[i] - state.amountSpecifiedRemaining, state.amountCalculated)\n                : (state.amountCalculated, amounts[i] - state.amountSpecifiedRemaining);\n            result.gasEstimates[i] = scaleMultiswapGasEstimate(state.gasAggregate);\n        }\n    }\n\n    /// @notice Returns the multiswap gas estimate scaled to UniswapV3Pool:swap estimates\n    /// @dev These parameters have been determined by running a linear regression between UniswapV3QuoterV2\n    /// gas estimates and the unscaled gas estimates from multiswap\n    /// @param multiSwapEstimate the gas estimate from multiswap\n    /// @return swapEstimate the gas estimate equivalent for UniswapV3Pool:swap\n    function scaleMultiswapGasEstimate(uint256 multiSwapEstimate) private pure returns (uint256 swapEstimate) {\n        return (166 * multiSwapEstimate) / 100 + 50000;\n    }\n\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\n    /// to the left (less than or equal to) or right (greater than) of the given tick\n    /// @param pool The UniswapV3 pool to get next tick for\n    /// @param tick The starting tick\n    /// @param tickSpacing The spacing between usable ticks\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\n    function nextInitializedTickWithinOneWord(\n        IUniswapV3Pool pool,\n        int24 tick,\n        int24 tickSpacing,\n        bool lte\n    ) private view returns (int24 next, bool initialized) {\n        int24 compressed = tick / tickSpacing;\n        if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\n\n        if (lte) {\n            (int16 wordPos, uint8 bitPos) = position(compressed);\n            // all the 1s at or to the right of the current bitPos\n            uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\n            uint256 masked = pool.tickBitmap(wordPos) & mask;\n\n            // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\n            initialized = masked != 0;\n            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n            next = initialized\n                ? (compressed - int24(bitPos - BitMath.mostSignificantBit(masked))) * tickSpacing\n                : (compressed - int24(bitPos)) * tickSpacing;\n        } else {\n            // start from the word of the next tick, since the current tick state doesn't matter\n            (int16 wordPos, uint8 bitPos) = position(compressed + 1);\n            // all the 1s at or to the left of the bitPos\n            uint256 mask = ~((1 << bitPos) - 1);\n            uint256 masked = pool.tickBitmap(wordPos) & mask;\n\n            // if there are no initialized ticks to the left of the current tick, return leftmost in the word\n            initialized = masked != 0;\n            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n            next = initialized\n                ? (compressed + 1 + int24(BitMath.leastSignificantBit(masked) - bitPos)) * tickSpacing\n                : (compressed + 1 + int24(type(uint8).max - bitPos)) * tickSpacing;\n        }\n    }\n\n    /// @notice Computes the position in the mapping where the initialized bit for a tick lives\n    /// @param tick The tick for which to compute the position\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\n    /// @return bitPos The bit position in the word where the flag is stored\n    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {\n        wordPos = int16(tick >> 8);\n        bitPos = uint8(tick % 256);\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/TickMath.sol": {
            "id": 10,
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.8.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(MAX_TICK), 'T');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/SwapMath.sol": {
            "id": 9,
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport './FullMath.sol';\nimport './SqrtPriceMath.sol';\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\n    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\n    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n    /// @param liquidity The usable liquidity\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\n    /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap\n    /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap\n    /// @return feeAmount The amount of input that will be taken as a fee\n    function computeSwapStep(\n        uint160 sqrtRatioCurrentX96,\n        uint160 sqrtRatioTargetX96,\n        uint128 liquidity,\n        int256 amountRemaining,\n        uint24 feePips\n    )\n        internal\n        pure\n        returns (\n            uint160 sqrtRatioNextX96,\n            uint256 amountIn,\n            uint256 amountOut,\n            uint256 feeAmount\n        )\n    {\n        bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\n        bool exactIn = amountRemaining >= 0;\n\n        if (exactIn) {\n            uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);\n            amountIn = zeroForOne\n                ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\n                : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);\n            if (amountRemainingLessFee >= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;\n            else\n                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    amountRemainingLessFee,\n                    zeroForOne\n                );\n        } else {\n            amountOut = zeroForOne\n                ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\n                : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);\n            if (uint256(-amountRemaining) >= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;\n            else\n                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    uint256(-amountRemaining),\n                    zeroForOne\n                );\n        }\n\n        bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\n\n        // get the input/output amounts\n        if (zeroForOne) {\n            amountIn = max && exactIn\n                ? amountIn\n                : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);\n            amountOut = max && !exactIn\n                ? amountOut\n                : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);\n        } else {\n            amountIn = max && exactIn\n                ? amountIn\n                : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);\n            amountOut = max && !exactIn\n                ? amountOut\n                : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);\n        }\n\n        // cap the output amount to not exceed the remaining output amount\n        if (!exactIn && amountOut > uint256(-amountRemaining)) {\n            amountOut = uint256(-amountRemaining);\n        }\n\n        if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\n            // we didn't reach the target, so take the remainder of the maximum input as fee\n            feeAmount = uint256(amountRemaining) - amountIn;\n        } else {\n            feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);\n        }\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/FullMath.sol": {
            "id": 4,
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0 <0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(aC\u0017bC7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = -denominator & denominator;\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(aC\u0017bC7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/SqrtPriceMath.sol": {
            "id": 8,
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport './LowGasSafeMath.sol';\nimport './SafeCast.sol';\n\nimport './FullMath.sol';\nimport './UnsafeMath.sol';\nimport './FixedPoint96.sol';\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n\n    /// @notice Gets the next sqrt price given a delta of token0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of token0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amount,\n        bool add\n    ) internal pure returns (uint160) {\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            uint256 product;\n            if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n                uint256 denominator = numerator1 + product;\n                if (denominator >= numerator1)\n                    // always fits in 160 bits\n                    return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n            }\n\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));\n        } else {\n            uint256 product;\n            // if the product overflows, we know the denominator underflows\n            // in addition, we must check that the denominator does not underflow\n            require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\n            uint256 denominator = numerator1 - product;\n            return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of token1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of token1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amount,\n        bool add\n    ) internal pure returns (uint160) {\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient =\n                (\n                    amount <= type(uint160).max\n                        ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                        : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n                );\n\n            return uint256(sqrtPX96).add(quotient).toUint160();\n        } else {\n            uint256 quotient =\n                (\n                    amount <= type(uint160).max\n                        ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n                        : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n                );\n\n            require(sqrtPX96 > quotient);\n            // always fits 160 bits\n            return uint160(sqrtPX96 - quotient);\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of token0 or token1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of token0, or token1, is being swapped in\n    /// @param zeroForOne Whether the amount in is token0 or token1\n    /// @return sqrtQX96 The price after adding the input amount to token0 or token1\n    function getNextSqrtPriceFromInput(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amountIn,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtQX96) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we don't pass the target price\n        return\n            zeroForOne\n                ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n                : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of token0 or token1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of token0, or token1, is being swapped out\n    /// @param zeroForOne Whether the amount out is token0 or token1\n    /// @return sqrtQX96 The price after removing the output amount of token0 or token1\n    function getNextSqrtPriceFromOutput(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amountOut,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtQX96) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we pass the target price\n        return\n            zeroForOne\n                ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n                : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundUp\n    ) internal pure returns (uint256 amount0) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n        uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n\n        require(sqrtRatioAX96 > 0);\n\n        return\n            roundUp\n                ? UnsafeMath.divRoundingUp(\n                    FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),\n                    sqrtRatioAX96\n                )\n                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundUp\n    ) internal pure returns (uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return\n            roundUp\n                ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\n                : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n    }\n\n    /// @notice Helper that gets signed token0 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        int128 liquidity\n    ) internal pure returns (int256 amount0) {\n        return\n            liquidity < 0\n                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n    }\n\n    /// @notice Helper that gets signed token1 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        int128 liquidity\n    ) internal pure returns (int256 amount1) {\n        return\n            liquidity < 0\n                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol": {
            "id": 6,
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/SafeCast.sol": {
            "id": 7,
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/UnsafeMath.sol": {
            "id": 11,
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := add(div(x, y), gt(mod(x, y), 0))\n        }\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/FixedPoint96.sol": {
            "id": 3,
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
        },
        "@uniswap/v3-periphery/contracts/libraries/Path.sol": {
            "id": 13,
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport './BytesLib.sol';\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary Path {\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Returns the number of pools in the path\n    /// @param path The encoded swap path\n    /// @return The number of pools in the path\n    function numPools(bytes memory path) internal pure returns (uint256) {\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            address tokenA,\n            address tokenB,\n            uint24 fee\n        )\n    {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(0, POP_OFFSET);\n    }\n\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\n    /// @param path The swap path\n    /// @return The remaining token + fee elements in the path\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }\n}\n"
        },
        "@uniswap/v3-periphery/contracts/libraries/BytesLib.sol": {
            "id": 12,
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * @title Solidity Bytes Arrays Utils\n * @author GonC'alo SC! <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.5.0 <0.8.0;\n\nlibrary BytesLib {\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_start + _length >= _start, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    //zero out the 32 bytes slice we are about to return\n                    //we need to do it because Solidity does not garbage collect\n                    mstore(tempBytes, 0)\n\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, 'toAddress_overflow');\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, 'toUint24_overflow');\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/LiquidityMath.sol": {
            "id": 5,
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math library for liquidity\nlibrary LiquidityMath {\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x, 'LS');\n        } else {\n            require((z = x + uint128(y)) >= x, 'LA');\n        }\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/BitMath.sol": {
            "id": 2,
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        r = 255;\n        if (x & type(uint128).max > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & type(uint64).max > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & type(uint32).max > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & type(uint16).max > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & type(uint8).max > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}\n"
        },
        "./interfaces/IUniswapV3.sol": {
            "id": 1,
            "content": "pragma solidity >=0.6;\n\ninterface IUniswapV3QuoterV2 {\n    /// @return Returns the address of the Uniswap V3 factory\n    function factory() external view returns (IUniswapV3Factory);\n\n    // @notice Returns the amount out received for a given exact input swap without executing the swap\n    // @param path The path of the swap, i.e. each token pair and the pool fee\n    // @param amountIn The amount of the first token to swap\n    // @return amountOut The amount of the last token that would be received\n    // @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    // @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n    // @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInput(\n        bytes memory path,\n        uint256 amountIn\n    )\n        external\n        returns (\n            uint256 amountOut,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n\n    // @notice Returns the amount in required for a given exact output swap without executing the swap\n    // @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    // @param amountOut The amount of the last token to receive\n    // @return amountIn The amount of first token required to be paid\n    // @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    // @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n    // @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactOutput(\n        bytes memory path,\n        uint256 amountOut\n    )\n        external\n        returns (\n            uint256 amountIn,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n}\n\ninterface IUniswapV3Pool {\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(\n        int24 tick\n    )\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n}\n\ninterface IUniswapV3Factory {\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param a The contract address of either token0 or token1\n    /// @param b The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(address a, address b, uint24 fee) external view returns (IUniswapV3Pool pool);\n}\n\ninterface IUniswapV3MultiQuoter {\n    // @notice Returns the amounts out received for a given set of exact input swaps without executing the swap\n    /// @param factory The factory contract managing UniswapV3 pools\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountsIn The amounts in of the first token to swap\n    function quoteExactMultiInput(\n        IUniswapV3Factory factory,\n        bytes memory path,\n        uint256[] memory amountsIn\n    ) external view;\n\n    /// @notice Returns the amounts in received for a given set of exact output swaps without executing the swap\n    /// @param factory The factory contract managing UniswapV3 pools\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountsOut The amounts out of the last token to receive\n    function quoteExactMultiOutput(\n        IUniswapV3Factory factory,\n        bytes memory path,\n        uint256[] memory amountsOut\n    ) external view;\n}\n"
        }
    },
    "sourceCodes": {
        "./UniswapV3MultiQuoter.sol": "// SPDX-License-Identifier: Apache-2.0\n/*\n  Copyright 2021 ZeroEx Intl.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\npragma solidity ^0.7;\npragma experimental ABIEncoderV2;\n\nimport \"@uniswap/v3-core/contracts/libraries/TickMath.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/SwapMath.sol\";\nimport \"@uniswap/v3-periphery/contracts/libraries/Path.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/LiquidityMath.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/BitMath.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/SafeCast.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol\";\n\nimport \"./interfaces/IUniswapV3.sol\";\n\n/// @title Provides quotes for multiple swap amounts\n/// @notice Allows getting the expected amount out or amount in for multiple given swap amounts without executing the swap\ncontract UniswapV3MultiQuoter is IUniswapV3MultiQuoter {\n    // TODO: both quoteExactMultiInput and quoteExactMultiOutput revert at the end of the quoting logic\n    // and return results encodied into a revert reason. The revert should be removed and replaced with\n    // a normal return statement whenever UniswapV3Sampler stops having the two pool filtering logic.\n    // The two pool filtering logic causes pool's storage slots to be warmed up, causing gas estimates\n    // to be significantly below the gas used during settlement. Additionally, per the following EIP\n    // this revert logic might not clear warm storage slots in the future: https://eips.ethereum.org/EIPS/eip-3978\n    using Path for bytes;\n    using SafeCast for uint256;\n    using LowGasSafeMath for int256;\n\n    // the top level state of the multiswap, the results are transient.\n    struct SwapState {\n        // the amount remaining to be swapped in/out of the input/output asset\n        int256 amountSpecifiedRemaining;\n        // the amount already swapped out/in of the output/input asset\n        int256 amountCalculated;\n        // current sqrt(price)\n        uint160 sqrtPriceX96;\n        // the tick associated with the current price\n        int24 tick;\n        // the current liquidity in range\n        uint128 liquidity;\n        // the current quote amount we are querying liquidity for\n        uint256 amountsIndex;\n        // the current aggregate gas estimate for multi swap\n        uint256 gasAggregate;\n    }\n\n    // the intermediate calculations for each tick and quote amount\n    struct StepComputations {\n        // the price at the beginning of the step\n        uint160 sqrtPriceStartX96;\n        // the next tick to swap to from the current tick in the swap direction\n        int24 tickNext;\n        // whether tickNext is initialized or not\n        bool initialized;\n        // sqrt(price) for the next tick (1/0)\n        uint160 sqrtPriceNextX96;\n        // how much is being swapped in in this step\n        uint256 amountIn;\n        // how much is being swapped out\n        uint256 amountOut;\n        // how much fee is being paid in\n        uint256 feeAmount;\n        // how much gas was left before the current step\n        uint256 gasBefore;\n    }\n\n    // the result of multiswap\n    struct MultiSwapResult {\n        // the gas estimate for each of swap amounts\n        uint256[] gasEstimates;\n        // the token0 delta for each swap amount, positive indicates sent and negative indicates receipt\n        int256[] amounts0;\n        // the token1 delta for each swap amount, positive indicates sent and negative indicates receipt\n        int256[] amounts1;\n    }\n\n    /// @notice Quotes amounts out for a set of exact input swaps and provides results encoded into a revert reason\n    /// @param factory The factory contract managing UniswapV3 pools\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountsIn The amounts in of the first token to swap\n    /// @dev This function reverts at the end of the quoting logic and encodes (uint256[] amountsOut, uint256[] gasEstimates)\n    /// into the revert reason. See additional documentation below.\n    function quoteExactMultiInput(\n        IUniswapV3Factory factory,\n        bytes memory path,\n        uint256[] memory amountsIn\n    ) public view override {\n        for (uint256 i = 0; i < amountsIn.length - 1; ++i) {\n            require(\n                amountsIn[i] <= amountsIn[i + 1],\n                \"UniswapV3MultiQuoter/amountsIn must be monotonically increasing\"\n            );\n        }\n        uint256[] memory gasEstimates = new uint256[](amountsIn.length);\n\n        while (true) {\n            (address tokenIn, address tokenOut, uint24 fee) = path.decodeFirstPool();\n            bool zeroForOne = tokenIn < tokenOut;\n            IUniswapV3Pool pool = factory.getPool(tokenIn, tokenOut, fee);\n\n            // multiswap only accepts int256[] for input amounts\n            int256[] memory amounts = new int256[](amountsIn.length);\n            for (uint256 i = 0; i < amountsIn.length; ++i) {\n                amounts[i] = int256(amountsIn[i]);\n            }\n\n            MultiSwapResult memory result = multiswap(\n                pool,\n                zeroForOne,\n                amounts,\n                zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1\n            );\n\n            for (uint256 i = 0; i < amountsIn.length; ++i) {\n                amountsIn[i] = zeroForOne ? uint256(-result.amounts1[i]) : uint256(-result.amounts0[i]);\n                gasEstimates[i] += result.gasEstimates[i];\n            }\n\n            // decide whether to continue or terminate\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n            } else {\n                // quote results must be encoded into a revert because otherwise subsequent calls\n                // to UniswapV3MultiQuoter result in multiswap hitting pool storage slots that are\n                // already warm. This results in very inaccurate gas estimates when estimating gas\n                // usage for settlement.\n                bytes memory revertResult = abi.encodeWithSignature(\n                    \"result(uint256[],uint256[])\",\n                    amountsIn,\n                    gasEstimates\n                );\n                assembly {\n                    revert(add(revertResult, 0x20), mload(revertResult))\n                }\n            }\n        }\n    }\n\n    /// @notice Quotes amounts in a set of exact output swaps and provides results encoded into a revert reason\n    /// @param factory The factory contract managing UniswapV3 pools\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountsOut The amounts out of the last token to receive\n    /// @dev This function reverts at the end of the quoting logic and encodes (uint256[] amountsIn, uint256[] gasEstimates)\n    /// into the revert reason. See additional documentation below.\n    function quoteExactMultiOutput(\n        IUniswapV3Factory factory,\n        bytes memory path,\n        uint256[] memory amountsOut\n    ) public view override {\n        uint256[] memory amountsIn = new uint256[](amountsOut.length);\n        uint256[] memory gasEstimates = new uint256[](amountsOut.length);\n\n        for (uint256 i = 0; i < amountsOut.length - 1; ++i) {\n            require(\n                amountsOut[i] <= amountsOut[i + 1],\n                \"UniswapV3MultiQuoter/amountsOut must be monotonically increasing\"\n            );\n        }\n\n        uint256 nextAmountsLength = amountsOut.length;\n        while (true) {\n            (address tokenOut, address tokenIn, uint24 fee) = path.decodeFirstPool();\n            bool zeroForOne = tokenIn < tokenOut;\n            IUniswapV3Pool pool = factory.getPool(tokenIn, tokenOut, fee);\n\n            // multiswap only accepts int256[] for output amounts\n            int256[] memory amounts = new int256[](nextAmountsLength);\n            for (uint256 i = 0; i < nextAmountsLength; ++i) {\n                amounts[i] = -int256(amountsOut[i]);\n            }\n\n            MultiSwapResult memory result = multiswap(\n                pool,\n                zeroForOne,\n                amounts,\n                zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1\n            );\n\n            for (uint256 i = 0; i < nextAmountsLength; ++i) {\n                uint256 amountReceived = zeroForOne ? uint256(-result.amounts1[i]) : uint256(-result.amounts0[i]);\n                if (amountReceived != amountsOut[i]) {\n                    // for exact output swaps we need to check whether we would receive the full amount due to\n                    // multiswap behavior when hitting the limit\n                    nextAmountsLength = i;\n                    break;\n                } else {\n                    // populate amountsOut for the next pool\n                    amountsOut[i] = zeroForOne ? uint256(result.amounts0[i]) : uint256(result.amounts1[i]);\n                    gasEstimates[i] += result.gasEstimates[i];\n                }\n            }\n\n            if (nextAmountsLength == 0 || !path.hasMultiplePools()) {\n                for (uint256 i = 0; i < nextAmountsLength; ++i) {\n                    amountsIn[i] = amountsOut[i];\n                }\n\n                // quote results must be encoded into a revert because otherwise subsequent calls\n                // to UniswapV3MultiQuoter result in multiswap hitting pool storage slots that are\n                // already warm. This results in very inaccurate gas estimates when estimating gas\n                // usage for settlement.\n                bytes memory revertResult = abi.encodeWithSignature(\n                    \"result(uint256[],uint256[])\",\n                    amountsIn,\n                    gasEstimates\n                );\n                assembly {\n                    revert(add(revertResult, 0x20), mload(revertResult))\n                }\n            }\n\n            path = path.skipToken();\n        }\n    }\n\n    /// @notice swap multiple amounts of token0 for token1 or token1 for token1\n    /// @dev The results of multiswap includes slight rounding issues resulting from rounding up/rounding down in SqrtPriceMath library. Additionally,\n    /// it should be noted that multiswap requires a monotonically increasing list of amounts for exact inputs and monotonically decreasing list of\n    /// amounts for exact outputs.\n    /// @param pool The UniswapV3 pool to simulate each of the swap amounts for\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amounts The amounts of the swaps, positive values indicate exactInput and negative values indicate exact output\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @return result The results of the swap as a MultiSwapResult struct with gas used, token0 and token1 deltas\n    function multiswap(\n        IUniswapV3Pool pool,\n        bool zeroForOne,\n        int256[] memory amounts,\n        uint160 sqrtPriceLimitX96\n    ) private view returns (MultiSwapResult memory result) {\n        result.gasEstimates = new uint256[](amounts.length);\n        result.amounts0 = new int256[](amounts.length);\n        result.amounts1 = new int256[](amounts.length);\n\n        (uint160 sqrtPriceX96Start, int24 tickStart, , , , , ) = pool.slot0();\n        int24 tickSpacing = pool.tickSpacing();\n        uint24 fee = pool.fee();\n\n        bool exactInput = amounts[0] > 0;\n\n        SwapState memory state = SwapState({\n            amountSpecifiedRemaining: amounts[0],\n            amountCalculated: 0,\n            sqrtPriceX96: sqrtPriceX96Start,\n            tick: tickStart,\n            liquidity: pool.liquidity(),\n            amountsIndex: 0,\n            gasAggregate: 0\n        });\n\n        // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\n        while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != sqrtPriceLimitX96) {\n            StepComputations memory step;\n            step.gasBefore = gasleft();\n\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n            (step.tickNext, step.initialized) = nextInitializedTickWithinOneWord(\n                pool,\n                state.tick,\n                tickSpacing,\n                zeroForOne\n            );\n\n            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\n            if (step.tickNext < TickMath.MIN_TICK) {\n                step.tickNext = TickMath.MIN_TICK;\n            } else if (step.tickNext > TickMath.MAX_TICK) {\n                step.tickNext = TickMath.MAX_TICK;\n            }\n\n            // get the price for the next tick\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\n\n            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\n            (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(\n                state.sqrtPriceX96,\n                (zeroForOne ? step.sqrtPriceNextX96 < sqrtPriceLimitX96 : step.sqrtPriceNextX96 > sqrtPriceLimitX96)\n                    ? sqrtPriceLimitX96\n                    : step.sqrtPriceNextX96,\n                state.liquidity,\n                state.amountSpecifiedRemaining,\n                fee\n            );\n\n            if (exactInput) {\n                state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();\n                state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());\n            } else {\n                state.amountSpecifiedRemaining += step.amountOut.toInt256();\n                state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());\n            }\n\n            // shift tick if we reached the next price\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\n                // if the tick is initialized, run the tick transition\n                if (step.initialized) {\n                    (, int128 liquidityNet, , , , , , ) = pool.ticks(step.tickNext);\n\n                    // if we're moving leftward, we interpret liquidityNet as the opposite sign\n                    // safe because liquidityNet cannot be type(int128).min\n                    if (zeroForOne) liquidityNet = -liquidityNet;\n\n                    state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);\n                }\n\n                state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;\n                state.gasAggregate += step.gasBefore - gasleft();\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n                // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\n            }\n\n            if (state.amountSpecifiedRemaining == 0) {\n                (result.amounts0[state.amountsIndex], result.amounts1[state.amountsIndex]) = zeroForOne == exactInput\n                    ? (amounts[state.amountsIndex], state.amountCalculated)\n                    : (state.amountCalculated, amounts[state.amountsIndex]);\n\n                if (state.sqrtPriceX96 != step.sqrtPriceNextX96) {\n                    result.gasEstimates[state.amountsIndex] = scaleMultiswapGasEstimate(\n                        state.gasAggregate + (step.gasBefore - gasleft())\n                    );\n                } else {\n                    // we are moving to the next tick\n                    result.gasEstimates[state.amountsIndex] = scaleMultiswapGasEstimate(state.gasAggregate);\n                }\n\n                if (state.amountsIndex == amounts.length - 1) {\n                    return (result);\n                }\n\n                state.amountsIndex += 1;\n                state.amountSpecifiedRemaining = amounts[state.amountsIndex].sub(amounts[state.amountsIndex - 1]);\n            }\n        }\n\n        for (uint256 i = state.amountsIndex; i < amounts.length; ++i) {\n            (result.amounts0[i], result.amounts1[i]) = zeroForOne == exactInput\n                ? (amounts[i] - state.amountSpecifiedRemaining, state.amountCalculated)\n                : (state.amountCalculated, amounts[i] - state.amountSpecifiedRemaining);\n            result.gasEstimates[i] = scaleMultiswapGasEstimate(state.gasAggregate);\n        }\n    }\n\n    /// @notice Returns the multiswap gas estimate scaled to UniswapV3Pool:swap estimates\n    /// @dev These parameters have been determined by running a linear regression between UniswapV3QuoterV2\n    /// gas estimates and the unscaled gas estimates from multiswap\n    /// @param multiSwapEstimate the gas estimate from multiswap\n    /// @return swapEstimate the gas estimate equivalent for UniswapV3Pool:swap\n    function scaleMultiswapGasEstimate(uint256 multiSwapEstimate) private pure returns (uint256 swapEstimate) {\n        return (166 * multiSwapEstimate) / 100 + 50000;\n    }\n\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\n    /// to the left (less than or equal to) or right (greater than) of the given tick\n    /// @param pool The UniswapV3 pool to get next tick for\n    /// @param tick The starting tick\n    /// @param tickSpacing The spacing between usable ticks\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\n    function nextInitializedTickWithinOneWord(\n        IUniswapV3Pool pool,\n        int24 tick,\n        int24 tickSpacing,\n        bool lte\n    ) private view returns (int24 next, bool initialized) {\n        int24 compressed = tick / tickSpacing;\n        if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\n\n        if (lte) {\n            (int16 wordPos, uint8 bitPos) = position(compressed);\n            // all the 1s at or to the right of the current bitPos\n            uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\n            uint256 masked = pool.tickBitmap(wordPos) & mask;\n\n            // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\n            initialized = masked != 0;\n            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n            next = initialized\n                ? (compressed - int24(bitPos - BitMath.mostSignificantBit(masked))) * tickSpacing\n                : (compressed - int24(bitPos)) * tickSpacing;\n        } else {\n            // start from the word of the next tick, since the current tick state doesn't matter\n            (int16 wordPos, uint8 bitPos) = position(compressed + 1);\n            // all the 1s at or to the left of the bitPos\n            uint256 mask = ~((1 << bitPos) - 1);\n            uint256 masked = pool.tickBitmap(wordPos) & mask;\n\n            // if there are no initialized ticks to the left of the current tick, return leftmost in the word\n            initialized = masked != 0;\n            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n            next = initialized\n                ? (compressed + 1 + int24(BitMath.leastSignificantBit(masked) - bitPos)) * tickSpacing\n                : (compressed + 1 + int24(type(uint8).max - bitPos)) * tickSpacing;\n        }\n    }\n\n    /// @notice Computes the position in the mapping where the initialized bit for a tick lives\n    /// @param tick The tick for which to compute the position\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\n    /// @return bitPos The bit position in the word where the flag is stored\n    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {\n        wordPos = int16(tick >> 8);\n        bitPos = uint8(tick % 256);\n    }\n}\n",
        "@uniswap/v3-core/contracts/libraries/TickMath.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.8.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(MAX_TICK), 'T');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n}\n",
        "@uniswap/v3-core/contracts/libraries/SwapMath.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport './FullMath.sol';\nimport './SqrtPriceMath.sol';\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\n    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\n    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n    /// @param liquidity The usable liquidity\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\n    /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap\n    /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap\n    /// @return feeAmount The amount of input that will be taken as a fee\n    function computeSwapStep(\n        uint160 sqrtRatioCurrentX96,\n        uint160 sqrtRatioTargetX96,\n        uint128 liquidity,\n        int256 amountRemaining,\n        uint24 feePips\n    )\n        internal\n        pure\n        returns (\n            uint160 sqrtRatioNextX96,\n            uint256 amountIn,\n            uint256 amountOut,\n            uint256 feeAmount\n        )\n    {\n        bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\n        bool exactIn = amountRemaining >= 0;\n\n        if (exactIn) {\n            uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);\n            amountIn = zeroForOne\n                ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\n                : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);\n            if (amountRemainingLessFee >= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;\n            else\n                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    amountRemainingLessFee,\n                    zeroForOne\n                );\n        } else {\n            amountOut = zeroForOne\n                ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\n                : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);\n            if (uint256(-amountRemaining) >= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;\n            else\n                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    uint256(-amountRemaining),\n                    zeroForOne\n                );\n        }\n\n        bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\n\n        // get the input/output amounts\n        if (zeroForOne) {\n            amountIn = max && exactIn\n                ? amountIn\n                : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);\n            amountOut = max && !exactIn\n                ? amountOut\n                : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);\n        } else {\n            amountIn = max && exactIn\n                ? amountIn\n                : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);\n            amountOut = max && !exactIn\n                ? amountOut\n                : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);\n        }\n\n        // cap the output amount to not exceed the remaining output amount\n        if (!exactIn && amountOut > uint256(-amountRemaining)) {\n            amountOut = uint256(-amountRemaining);\n        }\n\n        if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\n            // we didn't reach the target, so take the remainder of the maximum input as fee\n            feeAmount = uint256(amountRemaining) - amountIn;\n        } else {\n            feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);\n        }\n    }\n}\n",
        "@uniswap/v3-core/contracts/libraries/FullMath.sol": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0 <0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(aC\u0017bC7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = -denominator & denominator;\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(aC\u0017bC7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n",
        "@uniswap/v3-core/contracts/libraries/SqrtPriceMath.sol": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport './LowGasSafeMath.sol';\nimport './SafeCast.sol';\n\nimport './FullMath.sol';\nimport './UnsafeMath.sol';\nimport './FixedPoint96.sol';\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n\n    /// @notice Gets the next sqrt price given a delta of token0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of token0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amount,\n        bool add\n    ) internal pure returns (uint160) {\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            uint256 product;\n            if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n                uint256 denominator = numerator1 + product;\n                if (denominator >= numerator1)\n                    // always fits in 160 bits\n                    return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n            }\n\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));\n        } else {\n            uint256 product;\n            // if the product overflows, we know the denominator underflows\n            // in addition, we must check that the denominator does not underflow\n            require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\n            uint256 denominator = numerator1 - product;\n            return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of token1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of token1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amount,\n        bool add\n    ) internal pure returns (uint160) {\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient =\n                (\n                    amount <= type(uint160).max\n                        ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                        : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n                );\n\n            return uint256(sqrtPX96).add(quotient).toUint160();\n        } else {\n            uint256 quotient =\n                (\n                    amount <= type(uint160).max\n                        ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n                        : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n                );\n\n            require(sqrtPX96 > quotient);\n            // always fits 160 bits\n            return uint160(sqrtPX96 - quotient);\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of token0 or token1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of token0, or token1, is being swapped in\n    /// @param zeroForOne Whether the amount in is token0 or token1\n    /// @return sqrtQX96 The price after adding the input amount to token0 or token1\n    function getNextSqrtPriceFromInput(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amountIn,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtQX96) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we don't pass the target price\n        return\n            zeroForOne\n                ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n                : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of token0 or token1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of token0, or token1, is being swapped out\n    /// @param zeroForOne Whether the amount out is token0 or token1\n    /// @return sqrtQX96 The price after removing the output amount of token0 or token1\n    function getNextSqrtPriceFromOutput(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amountOut,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtQX96) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we pass the target price\n        return\n            zeroForOne\n                ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n                : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundUp\n    ) internal pure returns (uint256 amount0) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n        uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n\n        require(sqrtRatioAX96 > 0);\n\n        return\n            roundUp\n                ? UnsafeMath.divRoundingUp(\n                    FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),\n                    sqrtRatioAX96\n                )\n                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundUp\n    ) internal pure returns (uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return\n            roundUp\n                ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\n                : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n    }\n\n    /// @notice Helper that gets signed token0 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        int128 liquidity\n    ) internal pure returns (int256 amount0) {\n        return\n            liquidity < 0\n                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n    }\n\n    /// @notice Helper that gets signed token1 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        int128 liquidity\n    ) internal pure returns (int256 amount1) {\n        return\n            liquidity < 0\n                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n    }\n}\n",
        "@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n",
        "@uniswap/v3-core/contracts/libraries/SafeCast.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}\n",
        "@uniswap/v3-core/contracts/libraries/UnsafeMath.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := add(div(x, y), gt(mod(x, y), 0))\n        }\n    }\n}\n",
        "@uniswap/v3-core/contracts/libraries/FixedPoint96.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n",
        "@uniswap/v3-periphery/contracts/libraries/Path.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport './BytesLib.sol';\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary Path {\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Returns the number of pools in the path\n    /// @param path The encoded swap path\n    /// @return The number of pools in the path\n    function numPools(bytes memory path) internal pure returns (uint256) {\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            address tokenA,\n            address tokenB,\n            uint24 fee\n        )\n    {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(0, POP_OFFSET);\n    }\n\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\n    /// @param path The swap path\n    /// @return The remaining token + fee elements in the path\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }\n}\n",
        "@uniswap/v3-periphery/contracts/libraries/BytesLib.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * @title Solidity Bytes Arrays Utils\n * @author GonC'alo SC! <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.5.0 <0.8.0;\n\nlibrary BytesLib {\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_start + _length >= _start, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    //zero out the 32 bytes slice we are about to return\n                    //we need to do it because Solidity does not garbage collect\n                    mstore(tempBytes, 0)\n\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, 'toAddress_overflow');\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, 'toUint24_overflow');\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}\n",
        "@uniswap/v3-core/contracts/libraries/LiquidityMath.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math library for liquidity\nlibrary LiquidityMath {\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x, 'LS');\n        } else {\n            require((z = x + uint128(y)) >= x, 'LA');\n        }\n    }\n}\n",
        "@uniswap/v3-core/contracts/libraries/BitMath.sol": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        r = 255;\n        if (x & type(uint128).max > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & type(uint64).max > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & type(uint32).max > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & type(uint16).max > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & type(uint8).max > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}\n",
        "./interfaces/IUniswapV3.sol": "pragma solidity >=0.6;\n\ninterface IUniswapV3QuoterV2 {\n    /// @return Returns the address of the Uniswap V3 factory\n    function factory() external view returns (IUniswapV3Factory);\n\n    // @notice Returns the amount out received for a given exact input swap without executing the swap\n    // @param path The path of the swap, i.e. each token pair and the pool fee\n    // @param amountIn The amount of the first token to swap\n    // @return amountOut The amount of the last token that would be received\n    // @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    // @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n    // @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInput(\n        bytes memory path,\n        uint256 amountIn\n    )\n        external\n        returns (\n            uint256 amountOut,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n\n    // @notice Returns the amount in required for a given exact output swap without executing the swap\n    // @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    // @param amountOut The amount of the last token to receive\n    // @return amountIn The amount of first token required to be paid\n    // @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    // @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n    // @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactOutput(\n        bytes memory path,\n        uint256 amountOut\n    )\n        external\n        returns (\n            uint256 amountIn,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n}\n\ninterface IUniswapV3Pool {\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(\n        int24 tick\n    )\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n}\n\ninterface IUniswapV3Factory {\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param a The contract address of either token0 or token1\n    /// @param b The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(address a, address b, uint24 fee) external view returns (IUniswapV3Pool pool);\n}\n\ninterface IUniswapV3MultiQuoter {\n    // @notice Returns the amounts out received for a given set of exact input swaps without executing the swap\n    /// @param factory The factory contract managing UniswapV3 pools\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountsIn The amounts in of the first token to swap\n    function quoteExactMultiInput(\n        IUniswapV3Factory factory,\n        bytes memory path,\n        uint256[] memory amountsIn\n    ) external view;\n\n    /// @notice Returns the amounts in received for a given set of exact output swaps without executing the swap\n    /// @param factory The factory contract managing UniswapV3 pools\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountsOut The amounts out of the last token to receive\n    function quoteExactMultiOutput(\n        IUniswapV3Factory factory,\n        bytes memory path,\n        uint256[] memory amountsOut\n    ) external view;\n}\n"
    },
    "compiler": {
        "name": "solc",
        "version": "0.7.6+commit.7338295f",
        "settings": {
            "remappings": [
                "@0x/contracts-utils=/Users/davidwalsh/code/0x-api/node_modules/@0x/contracts-utils",
                "@0x/contracts-erc20=/Users/davidwalsh/code/0x-api/node_modules/@0x/contracts-erc20",
                "@uniswap/v3-core=/Users/davidwalsh/code/0x-api/node_modules/@uniswap/v3-core",
                "@uniswap/v3-periphery=/Users/davidwalsh/code/0x-api/node_modules/@uniswap/v3-periphery"
            ],
            "optimizer": {
                "enabled": true,
                "runs": 200,
                "details": {
                    "yul": false,
                    "deduplicate": true
                }
            },
            "outputSelection": {
                "*": {
                    "*": [
                        "abi",
                        "devdoc",
                        "evm.bytecode.object",
                        "evm.bytecode.sourceMap",
                        "evm.deployedBytecode.object",
                        "evm.deployedBytecode.sourceMap"
                    ]
                }
            },
            "evmVersion": "istanbul"
        }
    },
    "chains": {}
}
