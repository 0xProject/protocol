// tslint:disable:max-file-line-count
import { TokenMetadata } from '@0x/token-metadata';
import { BigNumber } from '@0x/utils';

import { BPS_TO_RATIO, ZERO } from '../core/constants';
import {
    ConversionRates,
    DefaultFeeDetailsDeprecated,
    Fee,
    FeeBreakdown,
    FeeWithDetails,
    GasOnlyFeeDetailsDeprecated,
    IndicativeQuote,
    MarginBasedFeeDetailsDeprecated,
} from '../core/types';
import { logger } from '../logger';
import { ConfigManager } from '../utils/config_manager';
import { GasStationAttendant } from '../utils/GasStationAttendant';
import { getBestQuote } from '../utils/quote_comparison_utils';
import { calculateGasEstimate } from '../utils/rfqm_gas_estimate_utils';
import { TokenPriceOracle } from '../utils/TokenPriceOracle';
import { AmmQuote, ZeroExApiClient } from '../utils/ZeroExApiClient';

import { QuoteContext } from './types';

/**
 * Interface for the response of CalculateFeeAsync() method. Including `feeWithDetails` object, and two optional fields for fee model v2:
 * `quotesWithGasFee` are the original quotes returned by MM when queried with gas fee, and `ammQuoteUniqueId` is the unique
 * id (`decodedUniqueId`) of quote report generated by /swap API as it get called by RFQm fee servie.
 */
interface CalculateFeeResponse {
    feeWithDetails: FeeWithDetails;
    quotesWithGasFee?: IndicativeQuote[];
    ammQuoteUniqueId?: string;
}

/**
 * Pure function to calculate the amount of `default` fee, based on trade size and flat rate in `tradeSizeBps`. Trade size is denominated
 * in `tradeToken` (either `makerToken` or `takerToken`), which is selected by the caller.
 *
 * @param tradeTokenAmount amount of trade token (in base unit) in the trade.
 * @param feeRateBps flat fee rate represented by number of base points.
 * @param tradeTokenBaseUnitPriceUsd USD price of 1 base unit of trade token.
 * @returns `default` fee amount in fee token base unit.
 */
export const calculateDefaultFeeAmount = (
    tradeTokenAmount: BigNumber,
    feeRateBps: number,
    tradeTokenBaseUnitPriceUsd: BigNumber | null,
    feeTokenBaseUnitPriceUsd: BigNumber | null,
): BigNumber => {
    if (feeRateBps > 0 && tradeTokenBaseUnitPriceUsd !== null && feeTokenBaseUnitPriceUsd !== null) {
        return tradeTokenAmount
            .times(feeRateBps * BPS_TO_RATIO)
            .times(tradeTokenBaseUnitPriceUsd)
            .div(feeTokenBaseUnitPriceUsd)
            .integerValue();
    }

    return ZERO;
};

/**
 * Pure function to calculate the price improvement based on given MM quote and AMM quote.
 *
 * @param makerQuoteWithGasFee maker quote with gas fee taken into account.
 * @param ammQuote Amm quote from 0x-api, with only AMM liquidity sources considered.
 * @param isSelling whether taker is selling. If true taker specifies `takerAmount` which should be fixed across quotes,
 * and `quoteToken` is `makerToken`. Otherwise taker specifies `makerAmount` and `quoteToken` is `takerToken`.
 * @param quoteTokenBaseUnitPriceUsd USD price of 1 base unit of quote token.
 * @param feeTokenBaseUnitPriceUsd USD price of 1 base unit of fee token.
 * @returns price improvement of MM quote comparing with AMM quote, in base unit of fee token.
 */
export const calculatePriceImprovementAmount = (
    makerQuoteWithGasFee: IndicativeQuote,
    ammQuote: AmmQuote,
    isSelling: boolean,
    quoteTokenBaseUnitPriceUsd: BigNumber,
    feeTokenBaseUnitPriceUsd: BigNumber,
): BigNumber => {
    if (isSelling) {
        const makerTokenBaseUnitPriceUsd = quoteTokenBaseUnitPriceUsd;
        const rfqPrice = makerQuoteWithGasFee.makerAmount
            .times(makerTokenBaseUnitPriceUsd)
            .div(feeTokenBaseUnitPriceUsd);
        const ammPrice = ammQuote.makerAmount
            .times(new BigNumber(1).plus(ammQuote.expectedSlippage))
            .times(makerTokenBaseUnitPriceUsd)
            .div(feeTokenBaseUnitPriceUsd)
            .minus(ammQuote.estimatedGasFeeWei);
        if (rfqPrice.gt(ammPrice)) {
            return rfqPrice.minus(ammPrice).integerValue();
        }
    } else {
        const takerTokenBaseUnitPriceUsd = quoteTokenBaseUnitPriceUsd;
        const rfqPrice = makerQuoteWithGasFee.takerAmount
            .times(takerTokenBaseUnitPriceUsd)
            .div(feeTokenBaseUnitPriceUsd);
        const ammPrice = ammQuote.takerAmount
            .times(new BigNumber(1).minus(ammQuote.expectedSlippage))
            .times(takerTokenBaseUnitPriceUsd)
            .div(feeTokenBaseUnitPriceUsd)
            .plus(ammQuote.estimatedGasFeeWei);
        if (ammPrice.gt(rfqPrice)) {
            return ammPrice.minus(rfqPrice).integerValue();
        }
    }
    return ZERO;
};

/**
 * Pure function to revise a maker's quote with fees. This allows us to approximate what the maker's actual quote will be when we
 * ask them to include fees. Useful for reducing load to MM servers.
 *
 * @param quote the raw quote from a maker. For RFQm the raw quote already include gas fee.
 * @param fees fees to incorporate into the quote. For RFQm this will be the amount other than gas fee.
 * @param isSelling whether taker is selling. If true taker specifies `takerAmount` which should be fixed across quotes,
 * and `quoteToken` is `makerToken`. Otherwise taker specifies `makerAmount` and `quoteToken` is `takerToken`.
 * @param quoteTokenBaseUnitPriceUsd USD price of 1 base unit of quote token.
 * @param feeTokenBaseUnitPriceUsd USD price of 1 base unit of fee token.
 * @returns revised quote with fees taken into account.
 */
export const reviseQuoteWithFees = (
    quote: IndicativeQuote,
    fees: BigNumber,
    isSelling: boolean,
    quoteTokenBaseUnitPriceUsd: BigNumber,
    feeTokenBaseUnitPriceUsd: BigNumber,
): IndicativeQuote => {
    let { makerAmount, takerAmount } = quote;
    if (isSelling) {
        const makerTokenBaseUnitPriceUsd = quoteTokenBaseUnitPriceUsd;
        makerAmount = makerAmount
            .minus(fees.times(feeTokenBaseUnitPriceUsd).div(makerTokenBaseUnitPriceUsd))
            .integerValue();
    } else {
        const takerTokenBaseUnitPriceUsd = quoteTokenBaseUnitPriceUsd;
        takerAmount = takerAmount
            .plus(fees.times(feeTokenBaseUnitPriceUsd).div(takerTokenBaseUnitPriceUsd))
            .integerValue();
    }

    return { ...quote, makerAmount, takerAmount };
};

/**
 * FeeService is used by RfqmService to calculate RFQm Fees of all versions (0, 1 and 2).
 */
export class FeeService {
    constructor(
        private readonly _chainId: number,
        private readonly _feeTokenMetadata: TokenMetadata,
        private readonly _configManager: ConfigManager,
        private readonly _gasStationAttendant: GasStationAttendant,
        private readonly _tokenPriceOracle: TokenPriceOracle,
        private readonly _zeroExApiClient: ZeroExApiClient,
        private readonly _minExpiryDurationMs: number,
    ) {}

    /**
     * Retrieve estimated gas price from the gas station.
     *
     * @returns estimated gas price
     */
    public async getGasPriceEstimationAsync(): Promise<BigNumber> {
        const gasPriceEstimate = await this._gasStationAttendant.getExpectedTransactionGasRateAsync();
        return gasPriceEstimate;
    }

    /**
     * Calculate Fee for given quote context.
     *
     * @returns estimated fee with details
     */
    public async calculateFeeAsync(
        quoteContext: QuoteContext,
        fetchMmQuotesAsync?: (quoteContext: QuoteContext, fee: Fee) => Promise<IndicativeQuote[]>,
    ): Promise<CalculateFeeResponse> {
        const { feeModelVersion } = quoteContext;

        switch (feeModelVersion) {
            case 2:
                return this._calculateFeeV2Async(quoteContext, fetchMmQuotesAsync);
            case 1:
                return {
                    feeWithDetails: await this._calculateFeeV1Async(quoteContext),
                };
            case 0:
            default:
                return {
                    feeWithDetails: await this._calculateGasFeeAsync({ ...quoteContext, feeModelVersion: 0 }),
                };
        }
    }
    /**
     * Revise original maker quotes with fees. This allows us to approximate what the maker's actual quote will be when we ask them
     * to include fees. Useful for reducing load to MM servers.
     * @param quotes the raw quotes from the makers. For RFQm the raw quote already include gas fee.
     * @param fees fees to incorporate into the quote - amount in base unit of fee token. For RFQm this will be the amount other than
     * gas fee.
     * @param quoteContext context of quote request.
     * @returns revised quotes.
     */
    public async reviseQuotesAsync(
        quotes: IndicativeQuote[],
        fees: BigNumber,
        quoteContext: QuoteContext,
    ): Promise<IndicativeQuote[]> {
        if (fees.eq(ZERO)) {
            return quotes;
        }

        const { isSelling, makerToken, takerToken, makerTokenDecimals, takerTokenDecimals } = quoteContext;

        // `quoteToken` is one of `makerToken` and `takerToken` whose amount is specified by makers in the quotes.
        const quoteToken = isSelling ? makerToken : takerToken;
        const quoteTokenDecimal = isSelling ? makerTokenDecimals : takerTokenDecimals;

        const { feeTokenBaseUnitPriceUsd, tradeTokenBaseUnitPriceUsd: quoteTokenBaseUnitPriceUsd } =
            await this._fetchTokenPricesAsync(quoteToken, quoteTokenDecimal);

        if (feeTokenBaseUnitPriceUsd === null || quoteTokenBaseUnitPriceUsd === null) {
            return quotes;
        }

        return quotes.map((quote) =>
            // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            reviseQuoteWithFees(quote, fees, isSelling, quoteTokenBaseUnitPriceUsd!, feeTokenBaseUnitPriceUsd!),
        );
    }

    /**
     * Calculate gas fee for all fee model versions, based on gas price query and gas estimation.
     *
     * @returns estimated gas fee with `gasOnly` details
     */
    private async _calculateGasFeeAsync(
        quoteContext: QuoteContext,
    ): Promise<FeeWithDetails & { details: GasOnlyFeeDetailsDeprecated }> {
        const { workflow, takerToken, makerToken, isUnwrap, feeModelVersion } = quoteContext;

        if (workflow === 'rfqt') {
            const gasPrice = new BigNumber(0);
            const gasFeeAmount = new BigNumber(0);
            return {
                amount: gasFeeAmount,
                token: this._feeTokenMetadata.tokenAddress,
                type: 'fixed',
                details: {
                    kind: 'gasOnly',
                    feeModelVersion,
                    gasFeeAmount,
                    gasPrice,
                },
                breakdown: {},
                conversionRates: {
                    nativeTokenBaseUnitPriceUsd: null,
                    feeTokenBaseUnitPriceUsd: null,
                    takerTokenBaseUnitPriceUsd: null,
                    makerTokenBaseUnitPriceUsd: null,
                },
            };
        }

        const gasPrice: BigNumber = await this.getGasPriceEstimationAsync();
        const gasEstimate = calculateGasEstimate(makerToken, takerToken, 'otc', isUnwrap);
        const gasFeeAmount = gasPrice.times(gasEstimate);

        return {
            amount: gasFeeAmount,
            token: this._feeTokenMetadata.tokenAddress,
            type: 'fixed',
            details: {
                kind: 'gasOnly',
                feeModelVersion,
                gasFeeAmount,
                gasPrice,
            },
            breakdown: {
                gas: {
                    amount: gasFeeAmount,
                    details: {
                        gasPrice,
                        estimatedGas: new BigNumber(gasEstimate),
                    },
                },
            },
            conversionRates: {
                nativeTokenBaseUnitPriceUsd: null,
                feeTokenBaseUnitPriceUsd: null,
                takerTokenBaseUnitPriceUsd: null,
                makerTokenBaseUnitPriceUsd: null,
            },
        };
    }

    /**
     * Calculate fee with fee model v1, including gas fee and and zeroExFee. If token prices query
     * is successful, zeroExFee will be based on trade size and `tradeSizeBps`. If not, `gasOnly` fee
     * will be returned.
     *
     * @returns fee with `default` | `gasOnly` details
     */
    private async _calculateFeeV1Async(
        quoteContext: QuoteContext,
    ): Promise<FeeWithDetails & { details: DefaultFeeDetailsDeprecated | GasOnlyFeeDetailsDeprecated }> {
        const {
            workflow,
            takerToken,
            makerToken,
            takerAmount,
            makerAmount,
            takerTokenDecimals,
            makerTokenDecimals,
            isSelling,
            feeModelVersion,
        } = quoteContext;

        const { tradeSizeBps } = this._configManager.getFeeModelConfiguration(this._chainId, makerToken, takerToken);

        // Select trade token so that `tradeTokenAmount` is known from quote request
        const tradeToken = isSelling ? takerToken : makerToken;
        const tradeTokenDecimals = isSelling ? takerTokenDecimals : makerTokenDecimals;
        const tradeTokenAmount = isSelling ? takerAmount : makerAmount;

        const [gasFee, { feeTokenBaseUnitPriceUsd, tradeTokenBaseUnitPriceUsd }] = await Promise.all([
            this._calculateGasFeeAsync(quoteContext),
            tradeSizeBps > 0
                ? this._fetchTokenPricesAsync(tradeToken, tradeTokenDecimals)
                : { tradeTokenBaseUnitPriceUsd: null, feeTokenBaseUnitPriceUsd: null },
        ]);

        const wasUnableToFetchTokenPrices: boolean =
            tradeSizeBps > 0 && (feeTokenBaseUnitPriceUsd === null || tradeTokenBaseUnitPriceUsd === null);

        if (wasUnableToFetchTokenPrices) {
            return gasFee;
        }

        const zeroExFeeAmount =
            tradeSizeBps > 0
                ? calculateDefaultFeeAmount(
                      // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                      tradeTokenAmount!,
                      tradeSizeBps,
                      tradeTokenBaseUnitPriceUsd,
                      feeTokenBaseUnitPriceUsd,
                  )
                : ZERO;

        logger.info(
            {
                gasFee,
                feeTokenBaseUnitPriceUsd,
                tradeTokenBaseUnitPriceUsd,
                zeroExFeeAmount,
            },
            'Gas fee, token prices and 0x fee amount in `_calculateFeeV1Async`',
        );

        return {
            type: 'fixed',
            token: this._feeTokenMetadata.tokenAddress,
            amount: gasFee.amount.plus(zeroExFeeAmount),
            details: {
                kind: 'default',
                feeModelVersion,
                gasFeeAmount: gasFee.amount,
                gasPrice: gasFee.details.gasPrice,
                zeroExFeeAmount,
                tradeSizeBps,
                feeTokenBaseUnitPriceUsd,
                takerTokenBaseUnitPriceUsd: isSelling ? tradeTokenBaseUnitPriceUsd : null,
                makerTokenBaseUnitPriceUsd: isSelling ? null : tradeTokenBaseUnitPriceUsd,
            },
            breakdown: {
                // RFQ will not charge gas fee for RFQt as taker will pay it
                gas: workflow === 'rfqt' ? undefined : gasFee.breakdown.gas,
                zeroEx: {
                    amount: zeroExFeeAmount,
                    details: {
                        kind: 'volume',
                        tradeSizeBps,
                    },
                },
            },
            conversionRates: {
                nativeTokenBaseUnitPriceUsd: feeTokenBaseUnitPriceUsd,
                feeTokenBaseUnitPriceUsd,
                takerTokenBaseUnitPriceUsd: isSelling ? tradeTokenBaseUnitPriceUsd : null,
                makerTokenBaseUnitPriceUsd: isSelling ? null : tradeTokenBaseUnitPriceUsd,
            },
        };
    }

    /**
     * Calculate fee with fee model v2, including gas fee and zeroExFee. If price improvement detection
     * is successful, zeroExFee will be based on price improvement. If not:
     *     * Fall back to `default` fee if maker query and token prices query are both successful.
     *     * Fall back to `gasOnly` fee if either maker query and token prices query failed.
     *
     * @returns fee with `margin` (price improvement) | `default` | `gasOnly` details (legacy fee breakdown)
     * and a breakdown including gas fee and zeroEx fee details.
     */
    private async _calculateFeeV2Async(
        quoteContext: QuoteContext,
        fetchMmQuotesAsync?: (quoteContext: QuoteContext, fee: Fee) => Promise<IndicativeQuote[]>,
    ): Promise<CalculateFeeResponse> {
        const {
            workflow,
            takerToken,
            makerToken,
            takerTokenDecimals,
            makerTokenDecimals,
            isSelling,
            assetFillAmount,
            feeModelVersion,
        } = quoteContext;

        if (workflow === 'rfqt') {
            throw new Error(`Not implemented: price improvement based fee model for RFQt has not been implemented!`);
        }

        const { marginRakeRatio: rakeRatio, tradeSizeBps } = this._configManager.getFeeModelConfiguration(
            this._chainId,
            makerToken,
            takerToken,
        );

        // `quoteToken` is one of `makerToken` and `takerToken` whose amount is specified by makers in the quotes.
        const quoteToken = isSelling ? makerToken : takerToken;
        const quoteTokenDecimal = isSelling ? makerTokenDecimals : takerTokenDecimals;

        /**
         * Send all queries in parallel. Bypass AMM query and token price query if rakeRatio > 0.
         */
        const [
            { gasFee, quotes: quotesWithGasFee },
            ammQuote,
            { feeTokenBaseUnitPriceUsd, tradeTokenBaseUnitPriceUsd: quoteTokenBaseUnitPriceUsd },
        ] = await Promise.all([
            this._fetchGasFeeAndIndicativeQuotesAsync(quoteContext, fetchMmQuotesAsync),
            rakeRatio > 0 ? this._zeroExApiClient.fetchAmmQuoteAsync(quoteContext) : null,
            rakeRatio > 0
                ? this._fetchTokenPricesAsync(quoteToken, quoteTokenDecimal)
                : { feeTokenBaseUnitPriceUsd: null, tradeTokenBaseUnitPriceUsd: null },
        ]);

        const ammQuoteUniqueId = ammQuote?.decodedUniqueId;

        // Get the best quote
        const bestMakerQuoteWithGasFee = getBestQuote(
            quotesWithGasFee,
            isSelling,
            takerToken,
            makerToken,
            assetFillAmount,
            this._minExpiryDurationMs,
        );

        const wasUnableToFetchMakerQuote: boolean = bestMakerQuoteWithGasFee === null;
        const wasUnableToFetchTokenPrices: boolean =
            rakeRatio > 0 && (feeTokenBaseUnitPriceUsd === null || quoteTokenBaseUnitPriceUsd === null);
        const wasUnableToFetchAmmQuote: boolean = rakeRatio > 0 && ammQuote === null;

        let zeroExFeeAmount: BigNumber;
        let feeWithDetails: FeeWithDetails;

        if (wasUnableToFetchMakerQuote || wasUnableToFetchTokenPrices) {
            /**
             * If maker query or token prices query failed: fallback to `gasOnly` fee.
             */
            zeroExFeeAmount = ZERO;
            feeWithDetails = gasFee;
        } else if (wasUnableToFetchAmmQuote) {
            /**
             * If maker query and token price query are successful, but AMM query failed,
             * fall back to `default` fee calculated with `tradeSizeBps`.
             */
            const quoteTokenAmount = isSelling
                ? // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                  bestMakerQuoteWithGasFee!.makerAmount
                : // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                  bestMakerQuoteWithGasFee!.takerAmount;
            zeroExFeeAmount = calculateDefaultFeeAmount(
                quoteTokenAmount,
                tradeSizeBps,
                quoteTokenBaseUnitPriceUsd,
                feeTokenBaseUnitPriceUsd,
            );

            const details: DefaultFeeDetailsDeprecated = {
                kind: 'default',
                feeModelVersion,
                gasFeeAmount: gasFee.amount,
                gasPrice: gasFee.details.gasPrice,
                zeroExFeeAmount,
                tradeSizeBps,
                feeTokenBaseUnitPriceUsd,
                takerTokenBaseUnitPriceUsd: isSelling ? null : quoteTokenBaseUnitPriceUsd,
                makerTokenBaseUnitPriceUsd: isSelling ? quoteTokenBaseUnitPriceUsd : null,
            };

            const breakdown: FeeBreakdown = {
                gas: gasFee.breakdown.gas,
                zeroEx: {
                    amount: zeroExFeeAmount,
                    details: {
                        kind: 'volume',
                        tradeSizeBps,
                    },
                },
            };

            const conversionRates: ConversionRates = {
                nativeTokenBaseUnitPriceUsd: feeTokenBaseUnitPriceUsd,
                feeTokenBaseUnitPriceUsd,
                takerTokenBaseUnitPriceUsd: isSelling ? null : quoteTokenBaseUnitPriceUsd,
                makerTokenBaseUnitPriceUsd: isSelling ? quoteTokenBaseUnitPriceUsd : null,
            };

            feeWithDetails = {
                type: 'fixed',
                token: this._feeTokenMetadata.tokenAddress,
                amount: gasFee.amount.plus(zeroExFeeAmount),
                details,
                breakdown,
                conversionRates,
            };
        } else {
            /**
             * If all queries are successful: return `priceImprovement` based fee, calculated from `priceImprovement` and `rakeRatio`.
             */
            const priceImprovement =
                rakeRatio > 0
                    ? calculatePriceImprovementAmount(
                          // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                          bestMakerQuoteWithGasFee!,
                          // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                          ammQuote!,
                          isSelling,
                          // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                          quoteTokenBaseUnitPriceUsd!,
                          // $eslint-fix-me https://github.com/rhinodavid/eslint-fix-me
                          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                          feeTokenBaseUnitPriceUsd!,
                      )
                    : ZERO;
            zeroExFeeAmount = priceImprovement.times(rakeRatio).integerValue();

            const details: MarginBasedFeeDetailsDeprecated = {
                kind: 'margin',
                feeModelVersion,
                gasFeeAmount: gasFee.amount,
                gasPrice: gasFee.details.gasPrice,
                zeroExFeeAmount,
                margin: priceImprovement, // legacy field name `margin`
                marginRakeRatio: rakeRatio, // legacy field name `marginRakeRatio`
                feeTokenBaseUnitPriceUsd,
                takerTokenBaseUnitPriceUsd: isSelling ? null : quoteTokenBaseUnitPriceUsd,
                makerTokenBaseUnitPriceUsd: isSelling ? quoteTokenBaseUnitPriceUsd : null,
            };

            const breakdown: FeeBreakdown = {
                gas: gasFee.breakdown.gas,
                zeroEx: {
                    amount: zeroExFeeAmount,
                    details: {
                        kind: 'price_improvement',
                        priceImprovement,
                        rakeRatio,
                    },
                },
            };

            const conversionRates: ConversionRates = {
                nativeTokenBaseUnitPriceUsd: feeTokenBaseUnitPriceUsd,
                feeTokenBaseUnitPriceUsd,
                takerTokenBaseUnitPriceUsd: isSelling ? null : quoteTokenBaseUnitPriceUsd,
                makerTokenBaseUnitPriceUsd: isSelling ? quoteTokenBaseUnitPriceUsd : null,
            };

            feeWithDetails = {
                type: 'fixed',
                token: this._feeTokenMetadata.tokenAddress,
                amount: zeroExFeeAmount.plus(gasFee.amount),
                details,
                breakdown,
                conversionRates,
            };
        }

        return {
            feeWithDetails,
            quotesWithGasFee,
            ammQuoteUniqueId,
        };
    }

    /**
     * Internal method to fetch prices of tradingToken (either makerToken or takerToken) and feeToken.
     */
    private async _fetchTokenPricesAsync(
        tradeToken: string,
        tradeTokenDecimals: number,
    ): Promise<{
        tradeTokenBaseUnitPriceUsd: BigNumber | null;
        feeTokenBaseUnitPriceUsd: BigNumber | null;
    }> {
        const [tradeTokenBaseUnitPriceUsd, feeTokenBaseUnitPriceUsd] =
            await this._tokenPriceOracle.batchFetchTokenPriceAsync([
                {
                    chainId: this._chainId,
                    tokenAddress: tradeToken,
                    tokenDecimals: tradeTokenDecimals,
                },
                {
                    chainId: this._chainId,
                    tokenAddress: this._feeTokenMetadata.tokenAddress,
                    tokenDecimals: this._feeTokenMetadata.decimals,
                },
            ]);

        return {
            tradeTokenBaseUnitPriceUsd,
            feeTokenBaseUnitPriceUsd,
        };
    }

    private async _fetchGasFeeAndIndicativeQuotesAsync(
        quoteContext: QuoteContext,
        fetchMmQuotesAsync?: (quoteContext: QuoteContext, fee: Fee) => Promise<IndicativeQuote[]>,
    ): Promise<{
        gasFee: FeeWithDetails;
        quotes: IndicativeQuote[];
    }> {
        const gasFee = await this._calculateGasFeeAsync(quoteContext);
        const quotes = fetchMmQuotesAsync === undefined ? [] : await fetchMmQuotesAsync(quoteContext, gasFee);

        return {
            gasFee,
            quotes,
        };
    }
}
