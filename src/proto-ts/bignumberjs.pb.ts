// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: bignumberjs.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";

//========================================//
//                 Types                  //
//========================================//

/**
 **
 *  Property representation of a bignumber.js instance. See:
 *  https://mikemcl.github.io/bignumber.js/#instance-properties
 */
export interface Bignumberjs {
  c: bigint[];
  e?: number | null | undefined;
  /**
   * `true` -> 1, `false` -> -1
   */
  s?: boolean | null | undefined;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Bignumberjs = {
  /**
   * Serializes Bignumberjs to protobuf.
   */
  encode: function (msg: Partial<Bignumberjs>): Uint8Array {
    return Bignumberjs._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Bignumberjs from protobuf.
   */
  decode: function (bytes: ByteSource): Bignumberjs {
    return Bignumberjs._readMessage(
      Bignumberjs.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes Bignumberjs with all fields set to their default value.
   */
  initialize: function (): Bignumberjs {
    return {
      c: [],
      e: undefined,
      s: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Bignumberjs>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c?.length) {
      writer.writePackedInt64String(
        1,
        msg.c.map((x) => x.toString() as any)
      );
    }
    if (msg.e != undefined) {
      writer.writeSint32(2, msg.e);
    }
    if (msg.s != undefined) {
      writer.writeBool(3, msg.s);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Bignumberjs, reader: BinaryReader): Bignumberjs {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.c.push(...reader.readPackedInt64String().map(BigInt));
          } else {
            msg.c.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 2: {
          msg.e = reader.readSint32();
          break;
        }
        case 3: {
          msg.s = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const BignumberjsJSON = {
  /**
   * Serializes Bignumberjs to JSON.
   */
  encode: function (msg: Partial<Bignumberjs>): string {
    return JSON.stringify(BignumberjsJSON._writeMessage(msg));
  },

  /**
   * Deserializes Bignumberjs from JSON.
   */
  decode: function (json: string): Bignumberjs {
    return BignumberjsJSON._readMessage(
      BignumberjsJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes Bignumberjs with all fields set to their default value.
   */
  initialize: function (): Bignumberjs {
    return {
      c: [],
      e: undefined,
      s: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Bignumberjs>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c?.length) {
      json["c"] = msg.c.map((x) => x.toString());
    }
    if (msg.e != undefined) {
      json["e"] = msg.e;
    }
    if (msg.s != undefined) {
      json["s"] = msg.s;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Bignumberjs, json: any): Bignumberjs {
    const _c = json["c"];
    if (_c) {
      msg.c = _c.map(BigInt);
    }
    const _e = json["e"];
    if (_e) {
      msg.e = _e;
    }
    const _s = json["s"];
    if (_s) {
      msg.s = _s;
    }
    return msg;
  },
};
