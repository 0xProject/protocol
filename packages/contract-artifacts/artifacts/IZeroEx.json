{
    "schemaVersion": "2.0.0",
    "contractName": "IZeroEx",
    "compilerOutput": {
        "abi": [
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": false, "internalType": "bytes32", "name": "orderHash", "type": "bytes32" },
                    { "indexed": false, "internalType": "address", "name": "maker", "type": "address" },
                    { "indexed": false, "internalType": "uint64", "name": "expiry", "type": "uint64" }
                ],
                "name": "ExpiredRfqOrder",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": false, "internalType": "bytes32", "name": "orderHash", "type": "bytes32" },
                    { "indexed": false, "internalType": "address", "name": "maker", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "taker", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "feeRecipient", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "makerToken", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "takerToken", "type": "address" },
                    {
                        "indexed": false,
                        "internalType": "uint128",
                        "name": "takerTokenFilledAmount",
                        "type": "uint128"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint128",
                        "name": "makerTokenFilledAmount",
                        "type": "uint128"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint128",
                        "name": "takerTokenFeeFilledAmount",
                        "type": "uint128"
                    },
                    { "indexed": false, "internalType": "uint256", "name": "protocolFeePaid", "type": "uint256" },
                    { "indexed": false, "internalType": "bytes32", "name": "pool", "type": "bytes32" }
                ],
                "name": "LimitOrderFilled",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": false, "internalType": "address", "name": "inputToken", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "outputToken", "type": "address" },
                    { "indexed": false, "internalType": "uint256", "name": "inputTokenAmount", "type": "uint256" },
                    { "indexed": false, "internalType": "uint256", "name": "outputTokenAmount", "type": "uint256" },
                    { "indexed": false, "internalType": "address", "name": "provider", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "recipient", "type": "address" }
                ],
                "name": "LiquidityProviderSwap",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": false, "internalType": "bytes32", "name": "hash", "type": "bytes32" },
                    { "indexed": true, "internalType": "bytes4", "name": "selector", "type": "bytes4" },
                    { "indexed": false, "internalType": "address", "name": "signer", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "sender", "type": "address" }
                ],
                "name": "MetaTransactionExecuted",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": false, "internalType": "address", "name": "caller", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "migrator", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "newOwner", "type": "address" }
                ],
                "name": "Migrated",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": false, "internalType": "bytes32", "name": "orderHash", "type": "bytes32" },
                    { "indexed": false, "internalType": "address", "name": "maker", "type": "address" }
                ],
                "name": "OrderCancelled",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": false, "internalType": "address", "name": "maker", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "signer", "type": "address" },
                    { "indexed": false, "internalType": "bool", "name": "allowed", "type": "bool" }
                ],
                "name": "OrderSignerRegistered",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": true, "internalType": "address", "name": "previousOwner", "type": "address" },
                    { "indexed": true, "internalType": "address", "name": "newOwner", "type": "address" }
                ],
                "name": "OwnershipTransferred",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": false, "internalType": "address", "name": "maker", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "makerToken", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "takerToken", "type": "address" },
                    { "indexed": false, "internalType": "uint256", "name": "minValidSalt", "type": "uint256" }
                ],
                "name": "PairCancelledLimitOrders",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": false, "internalType": "address", "name": "maker", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "makerToken", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "takerToken", "type": "address" },
                    { "indexed": false, "internalType": "uint256", "name": "minValidSalt", "type": "uint256" }
                ],
                "name": "PairCancelledRfqOrders",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": true, "internalType": "bytes4", "name": "selector", "type": "bytes4" },
                    { "indexed": false, "internalType": "address", "name": "oldImpl", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "newImpl", "type": "address" }
                ],
                "name": "ProxyFunctionUpdated",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [{ "indexed": false, "internalType": "address", "name": "quoteSigner", "type": "address" }],
                "name": "QuoteSignerUpdated",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": false, "internalType": "bytes32", "name": "orderHash", "type": "bytes32" },
                    { "indexed": false, "internalType": "address", "name": "maker", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "taker", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "makerToken", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "takerToken", "type": "address" },
                    {
                        "indexed": false,
                        "internalType": "uint128",
                        "name": "takerTokenFilledAmount",
                        "type": "uint128"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint128",
                        "name": "makerTokenFilledAmount",
                        "type": "uint128"
                    },
                    { "indexed": false, "internalType": "bytes32", "name": "pool", "type": "bytes32" }
                ],
                "name": "RfqOrderFilled",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": false, "internalType": "address", "name": "origin", "type": "address" },
                    { "indexed": false, "internalType": "address[]", "name": "addrs", "type": "address[]" },
                    { "indexed": false, "internalType": "bool", "name": "allowed", "type": "bool" }
                ],
                "name": "RfqOrderOriginsAllowed",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": true, "internalType": "address", "name": "taker", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "inputToken", "type": "address" },
                    { "indexed": false, "internalType": "address", "name": "outputToken", "type": "address" },
                    { "indexed": false, "internalType": "uint256", "name": "inputTokenAmount", "type": "uint256" },
                    { "indexed": false, "internalType": "uint256", "name": "outputTokenAmount", "type": "uint256" }
                ],
                "name": "TransformedERC20",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": false, "internalType": "address", "name": "transformerDeployer", "type": "address" }
                ],
                "name": "TransformerDeployerUpdated",
                "type": "event"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerTokenFeeAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "sender", "type": "address" },
                            { "internalType": "address", "name": "feeRecipient", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.LimitOrder",
                        "name": "order",
                        "type": "tuple"
                    },
                    {
                        "components": [
                            {
                                "internalType": "enum LibSignature.SignatureType",
                                "name": "signatureType",
                                "type": "uint8"
                            },
                            { "internalType": "uint8", "name": "v", "type": "uint8" },
                            { "internalType": "bytes32", "name": "r", "type": "bytes32" },
                            { "internalType": "bytes32", "name": "s", "type": "bytes32" }
                        ],
                        "internalType": "struct LibSignature.Signature",
                        "name": "signature",
                        "type": "tuple"
                    },
                    { "internalType": "uint128", "name": "takerTokenFillAmount", "type": "uint128" },
                    { "internalType": "address", "name": "taker", "type": "address" },
                    { "internalType": "address", "name": "sender", "type": "address" }
                ],
                "name": "_fillLimitOrder",
                "outputs": [
                    { "internalType": "uint128", "name": "takerTokenFilledAmount", "type": "uint128" },
                    { "internalType": "uint128", "name": "makerTokenFilledAmount", "type": "uint128" }
                ],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "txOrigin", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.RfqOrder",
                        "name": "order",
                        "type": "tuple"
                    },
                    {
                        "components": [
                            {
                                "internalType": "enum LibSignature.SignatureType",
                                "name": "signatureType",
                                "type": "uint8"
                            },
                            { "internalType": "uint8", "name": "v", "type": "uint8" },
                            { "internalType": "bytes32", "name": "r", "type": "bytes32" },
                            { "internalType": "bytes32", "name": "s", "type": "bytes32" }
                        ],
                        "internalType": "struct LibSignature.Signature",
                        "name": "signature",
                        "type": "tuple"
                    },
                    { "internalType": "uint128", "name": "takerTokenFillAmount", "type": "uint128" },
                    { "internalType": "address", "name": "taker", "type": "address" }
                ],
                "name": "_fillRfqOrder",
                "outputs": [
                    { "internalType": "uint128", "name": "takerTokenFilledAmount", "type": "uint128" },
                    { "internalType": "uint128", "name": "makerTokenFilledAmount", "type": "uint128" }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "address payable", "name": "taker", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "inputToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "outputToken", "type": "address" },
                            { "internalType": "uint256", "name": "inputTokenAmount", "type": "uint256" },
                            { "internalType": "uint256", "name": "minOutputTokenAmount", "type": "uint256" },
                            {
                                "components": [
                                    { "internalType": "uint32", "name": "deploymentNonce", "type": "uint32" },
                                    { "internalType": "bytes", "name": "data", "type": "bytes" }
                                ],
                                "internalType": "struct ITransformERC20Feature.Transformation[]",
                                "name": "transformations",
                                "type": "tuple[]"
                            }
                        ],
                        "internalType": "struct ITransformERC20Feature.TransformERC20Args",
                        "name": "args",
                        "type": "tuple"
                    }
                ],
                "name": "_transformERC20",
                "outputs": [{ "internalType": "uint256", "name": "outputTokenAmount", "type": "uint256" }],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerTokenFeeAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "sender", "type": "address" },
                            { "internalType": "address", "name": "feeRecipient", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.LimitOrder[]",
                        "name": "orders",
                        "type": "tuple[]"
                    }
                ],
                "name": "batchCancelLimitOrders",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "contract IERC20TokenV06[]", "name": "makerTokens", "type": "address[]" },
                    { "internalType": "contract IERC20TokenV06[]", "name": "takerTokens", "type": "address[]" },
                    { "internalType": "uint256[]", "name": "minValidSalts", "type": "uint256[]" }
                ],
                "name": "batchCancelPairLimitOrders",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "address", "name": "maker", "type": "address" },
                    { "internalType": "contract IERC20TokenV06[]", "name": "makerTokens", "type": "address[]" },
                    { "internalType": "contract IERC20TokenV06[]", "name": "takerTokens", "type": "address[]" },
                    { "internalType": "uint256[]", "name": "minValidSalts", "type": "uint256[]" }
                ],
                "name": "batchCancelPairLimitOrdersWithSigner",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "contract IERC20TokenV06[]", "name": "makerTokens", "type": "address[]" },
                    { "internalType": "contract IERC20TokenV06[]", "name": "takerTokens", "type": "address[]" },
                    { "internalType": "uint256[]", "name": "minValidSalts", "type": "uint256[]" }
                ],
                "name": "batchCancelPairRfqOrders",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "address", "name": "maker", "type": "address" },
                    { "internalType": "contract IERC20TokenV06[]", "name": "makerTokens", "type": "address[]" },
                    { "internalType": "contract IERC20TokenV06[]", "name": "takerTokens", "type": "address[]" },
                    { "internalType": "uint256[]", "name": "minValidSalts", "type": "uint256[]" }
                ],
                "name": "batchCancelPairRfqOrdersWithSigner",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "txOrigin", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.RfqOrder[]",
                        "name": "orders",
                        "type": "tuple[]"
                    }
                ],
                "name": "batchCancelRfqOrders",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "address payable", "name": "signer", "type": "address" },
                            { "internalType": "address", "name": "sender", "type": "address" },
                            { "internalType": "uint256", "name": "minGasPrice", "type": "uint256" },
                            { "internalType": "uint256", "name": "maxGasPrice", "type": "uint256" },
                            { "internalType": "uint256", "name": "expirationTimeSeconds", "type": "uint256" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" },
                            { "internalType": "bytes", "name": "callData", "type": "bytes" },
                            { "internalType": "uint256", "name": "value", "type": "uint256" },
                            { "internalType": "contract IERC20TokenV06", "name": "feeToken", "type": "address" },
                            { "internalType": "uint256", "name": "feeAmount", "type": "uint256" }
                        ],
                        "internalType": "struct IMetaTransactionsFeature.MetaTransactionData[]",
                        "name": "mtxs",
                        "type": "tuple[]"
                    },
                    {
                        "components": [
                            {
                                "internalType": "enum LibSignature.SignatureType",
                                "name": "signatureType",
                                "type": "uint8"
                            },
                            { "internalType": "uint8", "name": "v", "type": "uint8" },
                            { "internalType": "bytes32", "name": "r", "type": "bytes32" },
                            { "internalType": "bytes32", "name": "s", "type": "bytes32" }
                        ],
                        "internalType": "struct LibSignature.Signature[]",
                        "name": "signatures",
                        "type": "tuple[]"
                    }
                ],
                "name": "batchExecuteMetaTransactions",
                "outputs": [{ "internalType": "bytes[]", "name": "returnResults", "type": "bytes[]" }],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "inputToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "outputToken", "type": "address" },
                            { "internalType": "uint256", "name": "sellAmount", "type": "uint256" },
                            {
                                "components": [
                                    { "internalType": "bytes4", "name": "selector", "type": "bytes4" },
                                    { "internalType": "uint256", "name": "sellAmount", "type": "uint256" },
                                    { "internalType": "bytes", "name": "data", "type": "bytes" }
                                ],
                                "internalType": "struct IMultiplexFeature.WrappedBatchCall[]",
                                "name": "calls",
                                "type": "tuple[]"
                            }
                        ],
                        "internalType": "struct IMultiplexFeature.BatchFillData",
                        "name": "fillData",
                        "type": "tuple"
                    },
                    { "internalType": "uint256", "name": "minBuyAmount", "type": "uint256" }
                ],
                "name": "batchFill",
                "outputs": [{ "internalType": "uint256", "name": "outputTokenAmount", "type": "uint256" }],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerTokenFeeAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "sender", "type": "address" },
                            { "internalType": "address", "name": "feeRecipient", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.LimitOrder[]",
                        "name": "orders",
                        "type": "tuple[]"
                    },
                    {
                        "components": [
                            {
                                "internalType": "enum LibSignature.SignatureType",
                                "name": "signatureType",
                                "type": "uint8"
                            },
                            { "internalType": "uint8", "name": "v", "type": "uint8" },
                            { "internalType": "bytes32", "name": "r", "type": "bytes32" },
                            { "internalType": "bytes32", "name": "s", "type": "bytes32" }
                        ],
                        "internalType": "struct LibSignature.Signature[]",
                        "name": "signatures",
                        "type": "tuple[]"
                    },
                    { "internalType": "uint128[]", "name": "takerTokenFillAmounts", "type": "uint128[]" },
                    { "internalType": "bool", "name": "revertIfIncomplete", "type": "bool" }
                ],
                "name": "batchFillLimitOrders",
                "outputs": [
                    { "internalType": "uint128[]", "name": "takerTokenFilledAmounts", "type": "uint128[]" },
                    { "internalType": "uint128[]", "name": "makerTokenFilledAmounts", "type": "uint128[]" }
                ],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "txOrigin", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.RfqOrder[]",
                        "name": "orders",
                        "type": "tuple[]"
                    },
                    {
                        "components": [
                            {
                                "internalType": "enum LibSignature.SignatureType",
                                "name": "signatureType",
                                "type": "uint8"
                            },
                            { "internalType": "uint8", "name": "v", "type": "uint8" },
                            { "internalType": "bytes32", "name": "r", "type": "bytes32" },
                            { "internalType": "bytes32", "name": "s", "type": "bytes32" }
                        ],
                        "internalType": "struct LibSignature.Signature[]",
                        "name": "signatures",
                        "type": "tuple[]"
                    },
                    { "internalType": "uint128[]", "name": "takerTokenFillAmounts", "type": "uint128[]" },
                    { "internalType": "bool", "name": "revertIfIncomplete", "type": "bool" }
                ],
                "name": "batchFillRfqOrders",
                "outputs": [
                    { "internalType": "uint128[]", "name": "takerTokenFilledAmounts", "type": "uint128[]" },
                    { "internalType": "uint128[]", "name": "makerTokenFilledAmounts", "type": "uint128[]" }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerTokenFeeAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "sender", "type": "address" },
                            { "internalType": "address", "name": "feeRecipient", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.LimitOrder[]",
                        "name": "orders",
                        "type": "tuple[]"
                    },
                    {
                        "components": [
                            {
                                "internalType": "enum LibSignature.SignatureType",
                                "name": "signatureType",
                                "type": "uint8"
                            },
                            { "internalType": "uint8", "name": "v", "type": "uint8" },
                            { "internalType": "bytes32", "name": "r", "type": "bytes32" },
                            { "internalType": "bytes32", "name": "s", "type": "bytes32" }
                        ],
                        "internalType": "struct LibSignature.Signature[]",
                        "name": "signatures",
                        "type": "tuple[]"
                    }
                ],
                "name": "batchGetLimitOrderRelevantStates",
                "outputs": [
                    {
                        "components": [
                            { "internalType": "bytes32", "name": "orderHash", "type": "bytes32" },
                            { "internalType": "enum LibNativeOrder.OrderStatus", "name": "status", "type": "uint8" },
                            { "internalType": "uint128", "name": "takerTokenFilledAmount", "type": "uint128" }
                        ],
                        "internalType": "struct LibNativeOrder.OrderInfo[]",
                        "name": "orderInfos",
                        "type": "tuple[]"
                    },
                    { "internalType": "uint128[]", "name": "actualFillableTakerTokenAmounts", "type": "uint128[]" },
                    { "internalType": "bool[]", "name": "isSignatureValids", "type": "bool[]" }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "txOrigin", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.RfqOrder[]",
                        "name": "orders",
                        "type": "tuple[]"
                    },
                    {
                        "components": [
                            {
                                "internalType": "enum LibSignature.SignatureType",
                                "name": "signatureType",
                                "type": "uint8"
                            },
                            { "internalType": "uint8", "name": "v", "type": "uint8" },
                            { "internalType": "bytes32", "name": "r", "type": "bytes32" },
                            { "internalType": "bytes32", "name": "s", "type": "bytes32" }
                        ],
                        "internalType": "struct LibSignature.Signature[]",
                        "name": "signatures",
                        "type": "tuple[]"
                    }
                ],
                "name": "batchGetRfqOrderRelevantStates",
                "outputs": [
                    {
                        "components": [
                            { "internalType": "bytes32", "name": "orderHash", "type": "bytes32" },
                            { "internalType": "enum LibNativeOrder.OrderStatus", "name": "status", "type": "uint8" },
                            { "internalType": "uint128", "name": "takerTokenFilledAmount", "type": "uint128" }
                        ],
                        "internalType": "struct LibNativeOrder.OrderInfo[]",
                        "name": "orderInfos",
                        "type": "tuple[]"
                    },
                    { "internalType": "uint128[]", "name": "actualFillableTakerTokenAmounts", "type": "uint128[]" },
                    { "internalType": "bool[]", "name": "isSignatureValids", "type": "bool[]" }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerTokenFeeAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "sender", "type": "address" },
                            { "internalType": "address", "name": "feeRecipient", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.LimitOrder",
                        "name": "order",
                        "type": "tuple"
                    }
                ],
                "name": "cancelLimitOrder",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                    { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                    { "internalType": "uint256", "name": "minValidSalt", "type": "uint256" }
                ],
                "name": "cancelPairLimitOrders",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "address", "name": "maker", "type": "address" },
                    { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                    { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                    { "internalType": "uint256", "name": "minValidSalt", "type": "uint256" }
                ],
                "name": "cancelPairLimitOrdersWithSigner",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                    { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                    { "internalType": "uint256", "name": "minValidSalt", "type": "uint256" }
                ],
                "name": "cancelPairRfqOrders",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "address", "name": "maker", "type": "address" },
                    { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                    { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                    { "internalType": "uint256", "name": "minValidSalt", "type": "uint256" }
                ],
                "name": "cancelPairRfqOrdersWithSigner",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "txOrigin", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.RfqOrder",
                        "name": "order",
                        "type": "tuple"
                    }
                ],
                "name": "cancelRfqOrder",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "createTransformWallet",
                "outputs": [{ "internalType": "contract IFlashWallet", "name": "wallet", "type": "address" }],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "address payable", "name": "signer", "type": "address" },
                            { "internalType": "address", "name": "sender", "type": "address" },
                            { "internalType": "uint256", "name": "minGasPrice", "type": "uint256" },
                            { "internalType": "uint256", "name": "maxGasPrice", "type": "uint256" },
                            { "internalType": "uint256", "name": "expirationTimeSeconds", "type": "uint256" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" },
                            { "internalType": "bytes", "name": "callData", "type": "bytes" },
                            { "internalType": "uint256", "name": "value", "type": "uint256" },
                            { "internalType": "contract IERC20TokenV06", "name": "feeToken", "type": "address" },
                            { "internalType": "uint256", "name": "feeAmount", "type": "uint256" }
                        ],
                        "internalType": "struct IMetaTransactionsFeature.MetaTransactionData",
                        "name": "mtx",
                        "type": "tuple"
                    },
                    {
                        "components": [
                            {
                                "internalType": "enum LibSignature.SignatureType",
                                "name": "signatureType",
                                "type": "uint8"
                            },
                            { "internalType": "uint8", "name": "v", "type": "uint8" },
                            { "internalType": "bytes32", "name": "r", "type": "bytes32" },
                            { "internalType": "bytes32", "name": "s", "type": "bytes32" }
                        ],
                        "internalType": "struct LibSignature.Signature",
                        "name": "signature",
                        "type": "tuple"
                    }
                ],
                "name": "executeMetaTransaction",
                "outputs": [{ "internalType": "bytes", "name": "returnResult", "type": "bytes" }],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "bytes4", "name": "selector", "type": "bytes4" },
                    { "internalType": "address", "name": "impl", "type": "address" }
                ],
                "name": "extend",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerTokenFeeAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "sender", "type": "address" },
                            { "internalType": "address", "name": "feeRecipient", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.LimitOrder",
                        "name": "order",
                        "type": "tuple"
                    },
                    {
                        "components": [
                            {
                                "internalType": "enum LibSignature.SignatureType",
                                "name": "signatureType",
                                "type": "uint8"
                            },
                            { "internalType": "uint8", "name": "v", "type": "uint8" },
                            { "internalType": "bytes32", "name": "r", "type": "bytes32" },
                            { "internalType": "bytes32", "name": "s", "type": "bytes32" }
                        ],
                        "internalType": "struct LibSignature.Signature",
                        "name": "signature",
                        "type": "tuple"
                    },
                    { "internalType": "uint128", "name": "takerTokenFillAmount", "type": "uint128" }
                ],
                "name": "fillLimitOrder",
                "outputs": [
                    { "internalType": "uint128", "name": "takerTokenFilledAmount", "type": "uint128" },
                    { "internalType": "uint128", "name": "makerTokenFilledAmount", "type": "uint128" }
                ],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerTokenFeeAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "sender", "type": "address" },
                            { "internalType": "address", "name": "feeRecipient", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.LimitOrder",
                        "name": "order",
                        "type": "tuple"
                    },
                    {
                        "components": [
                            {
                                "internalType": "enum LibSignature.SignatureType",
                                "name": "signatureType",
                                "type": "uint8"
                            },
                            { "internalType": "uint8", "name": "v", "type": "uint8" },
                            { "internalType": "bytes32", "name": "r", "type": "bytes32" },
                            { "internalType": "bytes32", "name": "s", "type": "bytes32" }
                        ],
                        "internalType": "struct LibSignature.Signature",
                        "name": "signature",
                        "type": "tuple"
                    },
                    { "internalType": "uint128", "name": "takerTokenFillAmount", "type": "uint128" }
                ],
                "name": "fillOrKillLimitOrder",
                "outputs": [{ "internalType": "uint128", "name": "makerTokenFilledAmount", "type": "uint128" }],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "txOrigin", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.RfqOrder",
                        "name": "order",
                        "type": "tuple"
                    },
                    {
                        "components": [
                            {
                                "internalType": "enum LibSignature.SignatureType",
                                "name": "signatureType",
                                "type": "uint8"
                            },
                            { "internalType": "uint8", "name": "v", "type": "uint8" },
                            { "internalType": "bytes32", "name": "r", "type": "bytes32" },
                            { "internalType": "bytes32", "name": "s", "type": "bytes32" }
                        ],
                        "internalType": "struct LibSignature.Signature",
                        "name": "signature",
                        "type": "tuple"
                    },
                    { "internalType": "uint128", "name": "takerTokenFillAmount", "type": "uint128" }
                ],
                "name": "fillOrKillRfqOrder",
                "outputs": [{ "internalType": "uint128", "name": "makerTokenFilledAmount", "type": "uint128" }],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "txOrigin", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.RfqOrder",
                        "name": "order",
                        "type": "tuple"
                    },
                    {
                        "components": [
                            {
                                "internalType": "enum LibSignature.SignatureType",
                                "name": "signatureType",
                                "type": "uint8"
                            },
                            { "internalType": "uint8", "name": "v", "type": "uint8" },
                            { "internalType": "bytes32", "name": "r", "type": "bytes32" },
                            { "internalType": "bytes32", "name": "s", "type": "bytes32" }
                        ],
                        "internalType": "struct LibSignature.Signature",
                        "name": "signature",
                        "type": "tuple"
                    },
                    { "internalType": "uint128", "name": "takerTokenFillAmount", "type": "uint128" }
                ],
                "name": "fillRfqOrder",
                "outputs": [
                    { "internalType": "uint128", "name": "takerTokenFilledAmount", "type": "uint128" },
                    { "internalType": "uint128", "name": "makerTokenFilledAmount", "type": "uint128" }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerTokenFeeAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "sender", "type": "address" },
                            { "internalType": "address", "name": "feeRecipient", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.LimitOrder",
                        "name": "order",
                        "type": "tuple"
                    }
                ],
                "name": "getLimitOrderHash",
                "outputs": [{ "internalType": "bytes32", "name": "orderHash", "type": "bytes32" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerTokenFeeAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "sender", "type": "address" },
                            { "internalType": "address", "name": "feeRecipient", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.LimitOrder",
                        "name": "order",
                        "type": "tuple"
                    }
                ],
                "name": "getLimitOrderInfo",
                "outputs": [
                    {
                        "components": [
                            { "internalType": "bytes32", "name": "orderHash", "type": "bytes32" },
                            { "internalType": "enum LibNativeOrder.OrderStatus", "name": "status", "type": "uint8" },
                            { "internalType": "uint128", "name": "takerTokenFilledAmount", "type": "uint128" }
                        ],
                        "internalType": "struct LibNativeOrder.OrderInfo",
                        "name": "orderInfo",
                        "type": "tuple"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerTokenFeeAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "sender", "type": "address" },
                            { "internalType": "address", "name": "feeRecipient", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.LimitOrder",
                        "name": "order",
                        "type": "tuple"
                    },
                    {
                        "components": [
                            {
                                "internalType": "enum LibSignature.SignatureType",
                                "name": "signatureType",
                                "type": "uint8"
                            },
                            { "internalType": "uint8", "name": "v", "type": "uint8" },
                            { "internalType": "bytes32", "name": "r", "type": "bytes32" },
                            { "internalType": "bytes32", "name": "s", "type": "bytes32" }
                        ],
                        "internalType": "struct LibSignature.Signature",
                        "name": "signature",
                        "type": "tuple"
                    }
                ],
                "name": "getLimitOrderRelevantState",
                "outputs": [
                    {
                        "components": [
                            { "internalType": "bytes32", "name": "orderHash", "type": "bytes32" },
                            { "internalType": "enum LibNativeOrder.OrderStatus", "name": "status", "type": "uint8" },
                            { "internalType": "uint128", "name": "takerTokenFilledAmount", "type": "uint128" }
                        ],
                        "internalType": "struct LibNativeOrder.OrderInfo",
                        "name": "orderInfo",
                        "type": "tuple"
                    },
                    { "internalType": "uint128", "name": "actualFillableTakerTokenAmount", "type": "uint128" },
                    { "internalType": "bool", "name": "isSignatureValid", "type": "bool" }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "address payable", "name": "signer", "type": "address" },
                            { "internalType": "address", "name": "sender", "type": "address" },
                            { "internalType": "uint256", "name": "minGasPrice", "type": "uint256" },
                            { "internalType": "uint256", "name": "maxGasPrice", "type": "uint256" },
                            { "internalType": "uint256", "name": "expirationTimeSeconds", "type": "uint256" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" },
                            { "internalType": "bytes", "name": "callData", "type": "bytes" },
                            { "internalType": "uint256", "name": "value", "type": "uint256" },
                            { "internalType": "contract IERC20TokenV06", "name": "feeToken", "type": "address" },
                            { "internalType": "uint256", "name": "feeAmount", "type": "uint256" }
                        ],
                        "internalType": "struct IMetaTransactionsFeature.MetaTransactionData",
                        "name": "mtx",
                        "type": "tuple"
                    }
                ],
                "name": "getMetaTransactionExecutedBlock",
                "outputs": [{ "internalType": "uint256", "name": "blockNumber", "type": "uint256" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "address payable", "name": "signer", "type": "address" },
                            { "internalType": "address", "name": "sender", "type": "address" },
                            { "internalType": "uint256", "name": "minGasPrice", "type": "uint256" },
                            { "internalType": "uint256", "name": "maxGasPrice", "type": "uint256" },
                            { "internalType": "uint256", "name": "expirationTimeSeconds", "type": "uint256" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" },
                            { "internalType": "bytes", "name": "callData", "type": "bytes" },
                            { "internalType": "uint256", "name": "value", "type": "uint256" },
                            { "internalType": "contract IERC20TokenV06", "name": "feeToken", "type": "address" },
                            { "internalType": "uint256", "name": "feeAmount", "type": "uint256" }
                        ],
                        "internalType": "struct IMetaTransactionsFeature.MetaTransactionData",
                        "name": "mtx",
                        "type": "tuple"
                    }
                ],
                "name": "getMetaTransactionHash",
                "outputs": [{ "internalType": "bytes32", "name": "mtxHash", "type": "bytes32" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{ "internalType": "bytes32", "name": "mtxHash", "type": "bytes32" }],
                "name": "getMetaTransactionHashExecutedBlock",
                "outputs": [{ "internalType": "uint256", "name": "blockNumber", "type": "uint256" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getProtocolFeeMultiplier",
                "outputs": [{ "internalType": "uint32", "name": "multiplier", "type": "uint32" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getQuoteSigner",
                "outputs": [{ "internalType": "address", "name": "signer", "type": "address" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "txOrigin", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.RfqOrder",
                        "name": "order",
                        "type": "tuple"
                    }
                ],
                "name": "getRfqOrderHash",
                "outputs": [{ "internalType": "bytes32", "name": "orderHash", "type": "bytes32" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "txOrigin", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.RfqOrder",
                        "name": "order",
                        "type": "tuple"
                    }
                ],
                "name": "getRfqOrderInfo",
                "outputs": [
                    {
                        "components": [
                            { "internalType": "bytes32", "name": "orderHash", "type": "bytes32" },
                            { "internalType": "enum LibNativeOrder.OrderStatus", "name": "status", "type": "uint8" },
                            { "internalType": "uint128", "name": "takerTokenFilledAmount", "type": "uint128" }
                        ],
                        "internalType": "struct LibNativeOrder.OrderInfo",
                        "name": "orderInfo",
                        "type": "tuple"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "contract IERC20TokenV06", "name": "makerToken", "type": "address" },
                            { "internalType": "contract IERC20TokenV06", "name": "takerToken", "type": "address" },
                            { "internalType": "uint128", "name": "makerAmount", "type": "uint128" },
                            { "internalType": "uint128", "name": "takerAmount", "type": "uint128" },
                            { "internalType": "address", "name": "maker", "type": "address" },
                            { "internalType": "address", "name": "taker", "type": "address" },
                            { "internalType": "address", "name": "txOrigin", "type": "address" },
                            { "internalType": "bytes32", "name": "pool", "type": "bytes32" },
                            { "internalType": "uint64", "name": "expiry", "type": "uint64" },
                            { "internalType": "uint256", "name": "salt", "type": "uint256" }
                        ],
                        "internalType": "struct LibNativeOrder.RfqOrder",
                        "name": "order",
                        "type": "tuple"
                    },
                    {
                        "components": [
                            {
                                "internalType": "enum LibSignature.SignatureType",
                                "name": "signatureType",
                                "type": "uint8"
                            },
                            { "internalType": "uint8", "name": "v", "type": "uint8" },
                            { "internalType": "bytes32", "name": "r", "type": "bytes32" },
                            { "internalType": "bytes32", "name": "s", "type": "bytes32" }
                        ],
                        "internalType": "struct LibSignature.Signature",
                        "name": "signature",
                        "type": "tuple"
                    }
                ],
                "name": "getRfqOrderRelevantState",
                "outputs": [
                    {
                        "components": [
                            { "internalType": "bytes32", "name": "orderHash", "type": "bytes32" },
                            { "internalType": "enum LibNativeOrder.OrderStatus", "name": "status", "type": "uint8" },
                            { "internalType": "uint128", "name": "takerTokenFilledAmount", "type": "uint128" }
                        ],
                        "internalType": "struct LibNativeOrder.OrderInfo",
                        "name": "orderInfo",
                        "type": "tuple"
                    },
                    { "internalType": "uint128", "name": "actualFillableTakerTokenAmount", "type": "uint128" },
                    { "internalType": "bool", "name": "isSignatureValid", "type": "bool" }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "bytes4", "name": "selector", "type": "bytes4" },
                    { "internalType": "uint256", "name": "idx", "type": "uint256" }
                ],
                "name": "getRollbackEntryAtIndex",
                "outputs": [{ "internalType": "address", "name": "impl", "type": "address" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{ "internalType": "bytes4", "name": "selector", "type": "bytes4" }],
                "name": "getRollbackLength",
                "outputs": [{ "internalType": "uint256", "name": "rollbackLength", "type": "uint256" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getTransformWallet",
                "outputs": [{ "internalType": "contract IFlashWallet", "name": "wallet", "type": "address" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getTransformerDeployer",
                "outputs": [{ "internalType": "address", "name": "deployer", "type": "address" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "address", "name": "maker", "type": "address" },
                    { "internalType": "address", "name": "signer", "type": "address" }
                ],
                "name": "isValidOrderSigner",
                "outputs": [{ "internalType": "bool", "name": "isAllowed", "type": "bool" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "address", "name": "target", "type": "address" },
                    { "internalType": "bytes", "name": "data", "type": "bytes" },
                    { "internalType": "address", "name": "newOwner", "type": "address" }
                ],
                "name": "migrate",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "components": [
                            { "internalType": "address[]", "name": "tokens", "type": "address[]" },
                            { "internalType": "uint256", "name": "sellAmount", "type": "uint256" },
                            {
                                "components": [
                                    { "internalType": "bytes4", "name": "selector", "type": "bytes4" },
                                    { "internalType": "bytes", "name": "data", "type": "bytes" }
                                ],
                                "internalType": "struct IMultiplexFeature.WrappedMultiHopCall[]",
                                "name": "calls",
                                "type": "tuple[]"
                            }
                        ],
                        "internalType": "struct IMultiplexFeature.MultiHopFillData",
                        "name": "fillData",
                        "type": "tuple"
                    },
                    { "internalType": "uint256", "name": "minBuyAmount", "type": "uint256" }
                ],
                "name": "multiHopFill",
                "outputs": [{ "internalType": "uint256", "name": "outputTokenAmount", "type": "uint256" }],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "owner",
                "outputs": [{ "internalType": "address", "name": "ownerAddress", "type": "address" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "address", "name": "signer", "type": "address" },
                    { "internalType": "bool", "name": "allowed", "type": "bool" }
                ],
                "name": "registerAllowedOrderSigner",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "address[]", "name": "origins", "type": "address[]" },
                    { "internalType": "bool", "name": "allowed", "type": "bool" }
                ],
                "name": "registerAllowedRfqOrigins",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "bytes4", "name": "selector", "type": "bytes4" },
                    { "internalType": "address", "name": "targetImpl", "type": "address" }
                ],
                "name": "rollback",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "bytes", "name": "encodedPath", "type": "bytes" },
                    { "internalType": "uint256", "name": "minBuyAmount", "type": "uint256" },
                    { "internalType": "address", "name": "recipient", "type": "address" }
                ],
                "name": "sellEthForTokenToUniswapV3",
                "outputs": [{ "internalType": "uint256", "name": "buyAmount", "type": "uint256" }],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "contract IERC20TokenV06", "name": "inputToken", "type": "address" },
                    { "internalType": "contract IERC20TokenV06", "name": "outputToken", "type": "address" },
                    { "internalType": "contract ILiquidityProvider", "name": "provider", "type": "address" },
                    { "internalType": "address", "name": "recipient", "type": "address" },
                    { "internalType": "uint256", "name": "sellAmount", "type": "uint256" },
                    { "internalType": "uint256", "name": "minBuyAmount", "type": "uint256" },
                    { "internalType": "bytes", "name": "auxiliaryData", "type": "bytes" }
                ],
                "name": "sellToLiquidityProvider",
                "outputs": [{ "internalType": "uint256", "name": "boughtAmount", "type": "uint256" }],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "contract IERC20TokenV06[]", "name": "tokens", "type": "address[]" },
                    { "internalType": "uint256", "name": "sellAmount", "type": "uint256" },
                    { "internalType": "uint256", "name": "minBuyAmount", "type": "uint256" },
                    { "internalType": "enum IPancakeSwapFeature.ProtocolFork", "name": "fork", "type": "uint8" }
                ],
                "name": "sellToPancakeSwap",
                "outputs": [{ "internalType": "uint256", "name": "buyAmount", "type": "uint256" }],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "contract IERC20TokenV06[]", "name": "tokens", "type": "address[]" },
                    { "internalType": "uint256", "name": "sellAmount", "type": "uint256" },
                    { "internalType": "uint256", "name": "minBuyAmount", "type": "uint256" },
                    { "internalType": "bool", "name": "isSushi", "type": "bool" }
                ],
                "name": "sellToUniswap",
                "outputs": [{ "internalType": "uint256", "name": "buyAmount", "type": "uint256" }],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "bytes", "name": "encodedPath", "type": "bytes" },
                    { "internalType": "uint256", "name": "sellAmount", "type": "uint256" },
                    { "internalType": "uint256", "name": "minBuyAmount", "type": "uint256" },
                    { "internalType": "address payable", "name": "recipient", "type": "address" }
                ],
                "name": "sellTokenForEthToUniswapV3",
                "outputs": [{ "internalType": "uint256", "name": "buyAmount", "type": "uint256" }],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "bytes", "name": "encodedPath", "type": "bytes" },
                    { "internalType": "uint256", "name": "sellAmount", "type": "uint256" },
                    { "internalType": "uint256", "name": "minBuyAmount", "type": "uint256" },
                    { "internalType": "address", "name": "recipient", "type": "address" }
                ],
                "name": "sellTokenForTokenToUniswapV3",
                "outputs": [{ "internalType": "uint256", "name": "buyAmount", "type": "uint256" }],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{ "internalType": "address", "name": "quoteSigner", "type": "address" }],
                "name": "setQuoteSigner",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{ "internalType": "address", "name": "transformerDeployer", "type": "address" }],
                "name": "setTransformerDeployer",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{ "internalType": "address", "name": "newOwner", "type": "address" }],
                "name": "transferOwnership",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{ "internalType": "bytes32[]", "name": "poolIds", "type": "bytes32[]" }],
                "name": "transferProtocolFeesForPools",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "contract IERC20TokenV06", "name": "inputToken", "type": "address" },
                    { "internalType": "contract IERC20TokenV06", "name": "outputToken", "type": "address" },
                    { "internalType": "uint256", "name": "inputTokenAmount", "type": "uint256" },
                    { "internalType": "uint256", "name": "minOutputTokenAmount", "type": "uint256" },
                    {
                        "components": [
                            { "internalType": "uint32", "name": "deploymentNonce", "type": "uint32" },
                            { "internalType": "bytes", "name": "data", "type": "bytes" }
                        ],
                        "internalType": "struct ITransformERC20Feature.Transformation[]",
                        "name": "transformations",
                        "type": "tuple[]"
                    }
                ],
                "name": "transformERC20",
                "outputs": [{ "internalType": "uint256", "name": "outputTokenAmount", "type": "uint256" }],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "int256", "name": "amount0Delta", "type": "int256" },
                    { "internalType": "int256", "name": "amount1Delta", "type": "int256" },
                    { "internalType": "bytes", "name": "data", "type": "bytes" }
                ],
                "name": "uniswapV3SwapCallback",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ],
        "devdoc": {
            "details": "Interface for a fully featured Exchange Proxy.",
            "kind": "dev",
            "methods": {
                "_fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address,address)": {
                    "details": "Fill a limit order. Internal variant. ETH protocol fees can be      attached to this call. Any unspent ETH will be refunded to      `msg.sender` (not `sender`).",
                    "params": {
                        "order": "The limit order.",
                        "sender": "The order sender.",
                        "signature": "The order signature.",
                        "taker": "The order taker.",
                        "takerTokenFillAmount": "Maximum taker token to fill this order with."
                    },
                    "returns": {
                        "makerTokenFilledAmount": "How much maker token was filled.",
                        "takerTokenFilledAmount": "How much maker token was filled."
                    }
                },
                "_fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address)": {
                    "details": "Fill an RFQ order. Internal variant.",
                    "params": {
                        "order": "The RFQ order.",
                        "signature": "The order signature.",
                        "taker": "The order taker.",
                        "takerTokenFillAmount": "Maximum taker token to fill this order with."
                    },
                    "returns": {
                        "makerTokenFilledAmount": "How much maker token was filled.",
                        "takerTokenFilledAmount": "How much maker token was filled."
                    }
                },
                "_transformERC20((address,address,address,uint256,uint256,(uint32,bytes)[]))": {
                    "details": "Internal version of `transformERC20()`. Only callable from within.",
                    "params": { "args": "A `TransformERC20Args` struct." },
                    "returns": { "outputTokenAmount": "The amount of `outputToken` received by the taker." }
                },
                "batchCancelLimitOrders((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256)[])": {
                    "details": "Cancel multiple limit orders. The caller must be the maker or a valid order signer.      Silently succeeds if the order has already been cancelled.",
                    "params": { "orders": "The limit orders." }
                },
                "batchCancelPairLimitOrders(address[],address[],uint256[])": {
                    "details": "Cancel all limit orders for a given maker and pairs with salts less      than the values provided. The caller must be the maker. Subsequent      calls to this function with the same caller and pair require the      new salt to be >= the old salt.",
                    "params": {
                        "makerTokens": "The maker tokens.",
                        "minValidSalts": "The new minimum valid salts.",
                        "takerTokens": "The taker tokens."
                    }
                },
                "batchCancelPairLimitOrdersWithSigner(address,address[],address[],uint256[])": {
                    "details": "Cancel all limit orders for a given maker and pairs with salts less      than the values provided. The caller must be a signer registered to the maker.      Subsequent calls to this function with the same maker and pair require the      new salt to be >= the old salt.",
                    "params": {
                        "maker": "The maker for which to cancel.",
                        "makerTokens": "The maker tokens.",
                        "minValidSalts": "The new minimum valid salts.",
                        "takerTokens": "The taker tokens."
                    }
                },
                "batchCancelPairRfqOrders(address[],address[],uint256[])": {
                    "details": "Cancel all RFQ orders for a given maker and pairs with salts less      than the values provided. The caller must be the maker. Subsequent      calls to this function with the same caller and pair require the      new salt to be >= the old salt.",
                    "params": {
                        "makerTokens": "The maker tokens.",
                        "minValidSalts": "The new minimum valid salts.",
                        "takerTokens": "The taker tokens."
                    }
                },
                "batchCancelPairRfqOrdersWithSigner(address,address[],address[],uint256[])": {
                    "details": "Cancel all RFQ orders for a given maker and pairs with salts less      than the values provided. The caller must be a signer registered to the maker.      Subsequent calls to this function with the same maker and pair require the      new salt to be >= the old salt.",
                    "params": {
                        "maker": "The maker for which to cancel.",
                        "makerTokens": "The maker tokens.",
                        "minValidSalts": "The new minimum valid salts.",
                        "takerTokens": "The taker tokens."
                    }
                },
                "batchCancelRfqOrders((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256)[])": {
                    "details": "Cancel multiple RFQ orders. The caller must be the maker or a valid order signer.      Silently succeeds if the order has already been cancelled.",
                    "params": { "orders": "The RFQ orders." }
                },
                "batchExecuteMetaTransactions((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256)[],(uint8,uint8,bytes32,bytes32)[])": {
                    "details": "Execute multiple meta-transactions.",
                    "params": {
                        "mtxs": "The meta-transactions.",
                        "signatures": "The signature by each respective `mtx.signer`."
                    },
                    "returns": { "returnResults": "The ABI-encoded results of the underlying calls." }
                },
                "batchFill((address,address,uint256,(bytes4,uint256,bytes)[]),uint256)": {
                    "details": "Executes a batch of fills selling `fillData.inputToken`      for `fillData.outputToken` in sequence. Refer to the      internal variant `_batchFill` for the allowed nested      operations.",
                    "params": {
                        "fillData": "Encodes the input/output tokens, the sell        amount, and the nested operations for this batch fill.",
                        "minBuyAmount": "The minimum amount of `fillData.outputToken`        to buy. Reverts if this amount is not met."
                    },
                    "returns": { "outputTokenAmount": "The amount of the output token bought." }
                },
                "batchFillLimitOrders((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256)[],(uint8,uint8,bytes32,bytes32)[],uint128[],bool)": {
                    "details": "Fills multiple limit orders.",
                    "params": {
                        "orders": "Array of limit orders.",
                        "revertIfIncomplete": "If true, reverts if this function fails to        fill the full fill amount for any individual order.",
                        "signatures": "Array of signatures corresponding to each order.",
                        "takerTokenFillAmounts": "Array of desired amounts to fill each order."
                    },
                    "returns": {
                        "makerTokenFilledAmounts": "Array of amounts filled, in maker token.",
                        "takerTokenFilledAmounts": "Array of amounts filled, in taker token."
                    }
                },
                "batchFillRfqOrders((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256)[],(uint8,uint8,bytes32,bytes32)[],uint128[],bool)": {
                    "details": "Fills multiple RFQ orders.",
                    "params": {
                        "orders": "Array of RFQ orders.",
                        "revertIfIncomplete": "If true, reverts if this function fails to        fill the full fill amount for any individual order.",
                        "signatures": "Array of signatures corresponding to each order.",
                        "takerTokenFillAmounts": "Array of desired amounts to fill each order."
                    },
                    "returns": {
                        "makerTokenFilledAmounts": "Array of amounts filled, in maker token.",
                        "takerTokenFilledAmounts": "Array of amounts filled, in taker token."
                    }
                },
                "batchGetLimitOrderRelevantStates((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256)[],(uint8,uint8,bytes32,bytes32)[])": {
                    "details": "Batch version of `getLimitOrderRelevantState()`, without reverting.      Orders that would normally cause `getLimitOrderRelevantState()`      to revert will have empty results.",
                    "params": { "orders": "The limit orders.", "signatures": "The order signatures." },
                    "returns": {
                        "actualFillableTakerTokenAmounts": "How much of each order is fillable         based on maker funds, in taker tokens.",
                        "isSignatureValids": "Whether each signature is valid for the order.",
                        "orderInfos": "Info about the orders."
                    }
                },
                "batchGetRfqOrderRelevantStates((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256)[],(uint8,uint8,bytes32,bytes32)[])": {
                    "details": "Batch version of `getRfqOrderRelevantState()`, without reverting.      Orders that would normally cause `getRfqOrderRelevantState()`      to revert will have empty results.",
                    "params": { "orders": "The RFQ orders.", "signatures": "The order signatures." },
                    "returns": {
                        "actualFillableTakerTokenAmounts": "How much of each order is fillable         based on maker funds, in taker tokens.",
                        "isSignatureValids": "Whether each signature is valid for the order.",
                        "orderInfos": "Info about the orders."
                    }
                },
                "cancelLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))": {
                    "details": "Cancel a single limit order. The caller must be the maker or a valid order signer.      Silently succeeds if the order has already been cancelled.",
                    "params": { "order": "The limit order." }
                },
                "cancelPairLimitOrders(address,address,uint256)": {
                    "details": "Cancel all limit orders for a given maker and pair with a salt less      than the value provided. The caller must be the maker. Subsequent      calls to this function with the same caller and pair require the      new salt to be >= the old salt.",
                    "params": {
                        "makerToken": "The maker token.",
                        "minValidSalt": "The new minimum valid salt.",
                        "takerToken": "The taker token."
                    }
                },
                "cancelPairLimitOrdersWithSigner(address,address,address,uint256)": {
                    "details": "Cancel all limit orders for a given maker and pair with a salt less      than the value provided. The caller must be a signer registered to the maker.      Subsequent calls to this function with the same maker and pair require the      new salt to be >= the old salt.",
                    "params": {
                        "maker": "The maker for which to cancel.",
                        "makerToken": "The maker token.",
                        "minValidSalt": "The new minimum valid salt.",
                        "takerToken": "The taker token."
                    }
                },
                "cancelPairRfqOrders(address,address,uint256)": {
                    "details": "Cancel all RFQ orders for a given maker and pair with a salt less      than the value provided. The caller must be the maker. Subsequent      calls to this function with the same caller and pair require the      new salt to be >= the old salt.",
                    "params": {
                        "makerToken": "The maker token.",
                        "minValidSalt": "The new minimum valid salt.",
                        "takerToken": "The taker token."
                    }
                },
                "cancelPairRfqOrdersWithSigner(address,address,address,uint256)": {
                    "details": "Cancel all RFQ orders for a given maker and pair with a salt less      than the value provided. The caller must be a signer registered to the maker.      Subsequent calls to this function with the same maker and pair require the      new salt to be >= the old salt.",
                    "params": {
                        "maker": "The maker for which to cancel.",
                        "makerToken": "The maker token.",
                        "minValidSalt": "The new minimum valid salt.",
                        "takerToken": "The taker token."
                    }
                },
                "cancelRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))": {
                    "details": "Cancel a single RFQ order. The caller must be the maker or a valid order signer.      Silently succeeds if the order has already been cancelled.",
                    "params": { "order": "The RFQ order." }
                },
                "createTransformWallet()": {
                    "details": "Deploy a new flash wallet instance and replace the current one with it.      Useful if we somehow break the current wallet instance.       Only callable by the owner.",
                    "returns": { "wallet": "The new wallet instance." }
                },
                "executeMetaTransaction((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256),(uint8,uint8,bytes32,bytes32))": {
                    "details": "Execute a single meta-transaction.",
                    "params": { "mtx": "The meta-transaction.", "signature": "The signature by `mtx.signer`." },
                    "returns": { "returnResult": "The ABI-encoded result of the underlying call." }
                },
                "extend(bytes4,address)": {
                    "details": "Register or replace a function.",
                    "params": {
                        "impl": "The implementation contract for the function.",
                        "selector": "The function selector."
                    }
                },
                "fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)": {
                    "details": "Fill a limit order. The taker and sender will be the caller.",
                    "params": {
                        "order": "The limit order. ETH protocol fees can be      attached to this call. Any unspent ETH will be refunded to      the caller.",
                        "signature": "The order signature.",
                        "takerTokenFillAmount": "Maximum taker token amount to fill this order with."
                    },
                    "returns": {
                        "makerTokenFilledAmount": "How much maker token was filled.",
                        "takerTokenFilledAmount": "How much maker token was filled."
                    }
                },
                "fillOrKillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)": {
                    "details": "Fill an RFQ order for exactly `takerTokenFillAmount` taker tokens.      The taker will be the caller. ETH protocol fees can be      attached to this call. Any unspent ETH will be refunded to      the caller.",
                    "params": {
                        "order": "The limit order.",
                        "signature": "The order signature.",
                        "takerTokenFillAmount": "How much taker token to fill this order with."
                    },
                    "returns": { "makerTokenFilledAmount": "How much maker token was filled." }
                },
                "fillOrKillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)": {
                    "details": "Fill an RFQ order for exactly `takerTokenFillAmount` taker tokens.      The taker will be the caller.",
                    "params": {
                        "order": "The RFQ order.",
                        "signature": "The order signature.",
                        "takerTokenFillAmount": "How much taker token to fill this order with."
                    },
                    "returns": { "makerTokenFilledAmount": "How much maker token was filled." }
                },
                "fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)": {
                    "details": "Fill an RFQ order for up to `takerTokenFillAmount` taker tokens.      The taker will be the caller.",
                    "params": {
                        "order": "The RFQ order.",
                        "signature": "The order signature.",
                        "takerTokenFillAmount": "Maximum taker token amount to fill this order with."
                    },
                    "returns": {
                        "makerTokenFilledAmount": "How much maker token was filled.",
                        "takerTokenFilledAmount": "How much maker token was filled."
                    }
                },
                "getLimitOrderHash((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))": {
                    "details": "Get the canonical hash of a limit order.",
                    "params": { "order": "The limit order." },
                    "returns": { "orderHash": "The order hash." }
                },
                "getLimitOrderInfo((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))": {
                    "details": "Get the order info for a limit order.",
                    "params": { "order": "The limit order." },
                    "returns": { "orderInfo": "Info about the order." }
                },
                "getLimitOrderRelevantState((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32))": {
                    "details": "Get order info, fillable amount, and signature validity for a limit order.      Fillable amount is determined using balances and allowances of the maker.",
                    "params": { "order": "The limit order.", "signature": "The order signature." },
                    "returns": {
                        "actualFillableTakerTokenAmount": "How much of the order is fillable         based on maker funds, in taker tokens.",
                        "isSignatureValid": "Whether the signature is valid.",
                        "orderInfo": "Info about the order."
                    }
                },
                "getMetaTransactionExecutedBlock((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256))": {
                    "details": "Get the block at which a meta-transaction has been executed.",
                    "params": { "mtx": "The meta-transaction." },
                    "returns": { "blockNumber": "The block height when the meta-transactioin was executed." }
                },
                "getMetaTransactionHash((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256))": {
                    "details": "Get the EIP712 hash of a meta-transaction.",
                    "params": { "mtx": "The meta-transaction." },
                    "returns": { "mtxHash": "The EIP712 hash of `mtx`." }
                },
                "getMetaTransactionHashExecutedBlock(bytes32)": {
                    "details": "Get the block at which a meta-transaction hash has been executed.",
                    "params": { "mtxHash": "The meta-transaction hash." },
                    "returns": { "blockNumber": "The block height when the meta-transactioin was executed." }
                },
                "getProtocolFeeMultiplier()": {
                    "details": "Get the protocol fee multiplier. This should be multiplied by the      gas price to arrive at the required protocol fee to fill a native order.",
                    "returns": { "multiplier": "The protocol fee multiplier." }
                },
                "getQuoteSigner()": {
                    "details": "Return the optional signer for `transformERC20()` calldata.",
                    "returns": { "signer": "The transform deployer address." }
                },
                "getRfqOrderHash((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))": {
                    "details": "Get the canonical hash of an RFQ order.",
                    "params": { "order": "The RFQ order." },
                    "returns": { "orderHash": "The order hash." }
                },
                "getRfqOrderInfo((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))": {
                    "details": "Get the order info for an RFQ order.",
                    "params": { "order": "The RFQ order." },
                    "returns": { "orderInfo": "Info about the order." }
                },
                "getRfqOrderRelevantState((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32))": {
                    "details": "Get order info, fillable amount, and signature validity for an RFQ order.      Fillable amount is determined using balances and allowances of the maker.",
                    "params": { "order": "The RFQ order.", "signature": "The order signature." },
                    "returns": {
                        "actualFillableTakerTokenAmount": "How much of the order is fillable         based on maker funds, in taker tokens.",
                        "isSignatureValid": "Whether the signature is valid.",
                        "orderInfo": "Info about the order."
                    }
                },
                "getRollbackEntryAtIndex(bytes4,uint256)": {
                    "details": "Retrieve an entry in the rollback history for a function.",
                    "params": { "idx": "The index in the rollback history.", "selector": "The function selector." },
                    "returns": { "impl": "An implementation address for the function at         index `idx`." }
                },
                "getRollbackLength(bytes4)": {
                    "details": "Retrieve the length of the rollback history for a function.",
                    "params": { "selector": "The function selector." },
                    "returns": {
                        "rollbackLength": "The number of items in the rollback history for         the function."
                    }
                },
                "getTransformWallet()": {
                    "details": "Return the current wallet instance that will serve as the execution      context for transformations.",
                    "returns": { "wallet": "The wallet instance." }
                },
                "getTransformerDeployer()": {
                    "details": "Return the allowed deployer for transformers.",
                    "returns": { "deployer": "The transform deployer address." }
                },
                "isValidOrderSigner(address,address)": {
                    "details": "checks if a given address is registered to sign on behalf of a maker address",
                    "params": {
                        "maker": "The maker address encoded in an order (can be a contract)",
                        "signer": "The address that is providing a signature"
                    }
                },
                "migrate(address,bytes,address)": {
                    "details": "Execute a migration function in the context of the ZeroEx contract.      The result of the function being called should be the magic bytes      0x2c64c5ef (`keccack('MIGRATE_SUCCESS')`). Only callable by the owner.      The owner will be temporarily set to `address(this)` inside the call.      Before returning, the owner will be set to `newOwner`.",
                    "params": {
                        "data": "The call data.",
                        "newOwner": "The address of the new owner.",
                        "target": "The migrator contract address."
                    }
                },
                "multiHopFill((address[],uint256,(bytes4,bytes)[]),uint256)": {
                    "details": "Executes a sequence of fills \"hopping\" through the      path of tokens given by `fillData.tokens`. Refer to the      internal variant `_multiHopFill` for the allowed nested      operations.",
                    "params": {
                        "fillData": "Encodes the path of tokens, the sell amount,        and the nested operations for this multi-hop fill.",
                        "minBuyAmount": "The minimum amount of the output token        to buy. Reverts if this amount is not met."
                    },
                    "returns": { "outputTokenAmount": "The amount of the output token bought." }
                },
                "owner()": {
                    "details": "The owner of this contract.",
                    "returns": { "ownerAddress": "The owner address." }
                },
                "registerAllowedOrderSigner(address,bool)": {
                    "details": "Register a signer who can sign on behalf of msg.sender      This allows one to sign on behalf of a contract that calls this function",
                    "params": {
                        "allowed": "True to register, false to unregister.",
                        "signer": "The address from which you plan to generate signatures"
                    }
                },
                "registerAllowedRfqOrigins(address[],bool)": {
                    "details": "Mark what tx.origin addresses are allowed to fill an order that      specifies the message sender as its txOrigin.",
                    "params": {
                        "allowed": "True to register, false to unregister.",
                        "origins": "An array of origin addresses to update."
                    }
                },
                "rollback(bytes4,address)": {
                    "details": "Roll back to a prior implementation of a function.",
                    "params": {
                        "selector": "The function selector.",
                        "targetImpl": "The address of an older implementation of the function."
                    }
                },
                "sellEthForTokenToUniswapV3(bytes,uint256,address)": {
                    "details": "Sell attached ETH directly against uniswap v3.",
                    "params": {
                        "encodedPath": "Uniswap-encoded path, where the first token is WETH.",
                        "minBuyAmount": "Minimum amount of the last token in the path to buy.",
                        "recipient": "The recipient of the bought tokens. Can be zero for sender."
                    },
                    "returns": { "buyAmount": "Amount of the last token in the path bought." }
                },
                "sellToLiquidityProvider(address,address,address,address,uint256,uint256,bytes)": {
                    "details": "Sells `sellAmount` of `inputToken` to the liquidity provider      at the given `provider` address.",
                    "params": {
                        "auxiliaryData": "Auxiliary data supplied to the `provider` contract.",
                        "inputToken": "The token being sold.",
                        "minBuyAmount": "The minimum acceptable amount of `outputToken` to        buy. Reverts if this amount is not satisfied.",
                        "outputToken": "The token being bought.",
                        "provider": "The address of the on-chain liquidity provider        to trade with.",
                        "recipient": "The recipient of the bought tokens. If equal to        address(0), `msg.sender` is assumed to be the recipient.",
                        "sellAmount": "The amount of `inputToken` to sell."
                    },
                    "returns": { "boughtAmount": "The amount of `outputToken` bought." }
                },
                "sellToPancakeSwap(address[],uint256,uint256,uint8)": {
                    "details": "Efficiently sell directly to PancakeSwap (and forks).",
                    "params": {
                        "fork": "The protocol fork to use.",
                        "minBuyAmount": "Minimum amount of `tokens[-1]` to buy.",
                        "sellAmount": "of `tokens[0]` Amount to sell.",
                        "tokens": "Sell path."
                    },
                    "returns": { "buyAmount": "Amount of `tokens[-1]` bought." }
                },
                "sellToUniswap(address[],uint256,uint256,bool)": {
                    "details": "Efficiently sell directly to uniswap/sushiswap.",
                    "params": {
                        "isSushi": "Use sushiswap if true.",
                        "minBuyAmount": "Minimum amount of `tokens[-1]` to buy.",
                        "sellAmount": "of `tokens[0]` Amount to sell.",
                        "tokens": "Sell path."
                    },
                    "returns": { "buyAmount": "Amount of `tokens[-1]` bought." }
                },
                "sellTokenForEthToUniswapV3(bytes,uint256,uint256,address)": {
                    "details": "Sell a token for ETH directly against uniswap v3.",
                    "params": {
                        "encodedPath": "Uniswap-encoded path, where the last token is WETH.",
                        "minBuyAmount": "Minimum amount of ETH to buy.",
                        "recipient": "The recipient of the bought tokens. Can be zero for sender.",
                        "sellAmount": "amount of the first token in the path to sell."
                    },
                    "returns": { "buyAmount": "Amount of ETH bought." }
                },
                "sellTokenForTokenToUniswapV3(bytes,uint256,uint256,address)": {
                    "details": "Sell a token for another token directly against uniswap v3.",
                    "params": {
                        "encodedPath": "Uniswap-encoded path.",
                        "minBuyAmount": "Minimum amount of the last token in the path to buy.",
                        "recipient": "The recipient of the bought tokens. Can be zero for sender.",
                        "sellAmount": "amount of the first token in the path to sell."
                    },
                    "returns": { "buyAmount": "Amount of the last token in the path bought." }
                },
                "setQuoteSigner(address)": {
                    "details": "Replace the optional signer for `transformERC20()` calldata.      Only callable by the owner.",
                    "params": { "quoteSigner": "The address of the new calldata signer." }
                },
                "setTransformerDeployer(address)": {
                    "details": "Replace the allowed deployer for transformers.      Only callable by the owner.",
                    "params": {
                        "transformerDeployer": "The address of the new trusted deployer        for transformers."
                    }
                },
                "transferOwnership(address)": {
                    "details": "Transfers ownership of the contract to a new address.",
                    "params": { "newOwner": "The address that will become the owner." }
                },
                "transferProtocolFeesForPools(bytes32[])": {
                    "details": "Transfers protocol fees from the `FeeCollector` pools into      the staking contract.",
                    "params": { "poolIds": "Staking pool IDs" }
                },
                "transformERC20(address,address,uint256,uint256,(uint32,bytes)[])": {
                    "details": "Executes a series of transformations to convert an ERC20 `inputToken`      to an ERC20 `outputToken`.",
                    "params": {
                        "inputToken": "The token being provided by the sender.        If `0xeee...`, ETH is implied and should be provided with the call.`",
                        "inputTokenAmount": "The amount of `inputToken` to take from the sender.",
                        "minOutputTokenAmount": "The minimum amount of `outputToken` the sender        must receive for the entire transformation to succeed.",
                        "outputToken": "The token to be acquired by the sender.        `0xeee...` implies ETH.",
                        "transformations": "The transformations to execute on the token balance(s)        in sequence."
                    },
                    "returns": { "outputTokenAmount": "The amount of `outputToken` received by the sender." }
                },
                "uniswapV3SwapCallback(int256,int256,bytes)": {
                    "details": "The UniswapV3 pool swap callback which pays the funds requested      by the caller (pool) from the taker to the pool. Can only be called      by a valid UniswapV3 pool.",
                    "params": {
                        "amount0Delta": "Token0 amount owed.",
                        "amount1Delta": "Token1 amount owed.",
                        "data": "Arbitrary data forwarded from swap() caller."
                    }
                }
            },
            "version": 1
        },
        "evm": { "bytecode": { "object": "0x" }, "deployedBytecode": { "immutableReferences": {}, "object": "0x" } }
    },
    "compiler": {
        "name": "solc",
        "version": "0.6.12+commit.27d51765",
        "settings": {
            "optimizer": {
                "enabled": true,
                "runs": 1000000,
                "details": { "yul": true, "deduplicate": true, "cse": true, "constantOptimizer": true }
            },
            "outputSelection": {
                "*": {
                    "*": [
                        "abi",
                        "devdoc",
                        "evm.bytecode.object",
                        "evm.bytecode.sourceMap",
                        "evm.deployedBytecode.object",
                        "evm.deployedBytecode.sourceMap",
                        "evm.methodIdentifiers"
                    ]
                }
            },
            "evmVersion": "istanbul"
        }
    },
    "chains": {}
}
